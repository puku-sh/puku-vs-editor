{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/common/watcher.ts","vs/platform/files/common/watcher.ts"],"names":[],"mappings":"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","file":"watcher.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { GLOBSTAR, IRelativePattern, parse, ParsedPattern } from '../../../base/common/glob.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isAbsolute } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { FileChangeFilter, FileChangeType, IFileChange, isParent } from './files.js';\n\ninterface IWatchRequest {\n\n\t/**\n\t * The path to watch.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\treadonly excludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\treadonly includes?: Array<string | IRelativePattern>;\n\n\t/**\n\t * If provided, file change events from the watcher that\n\t * are a result of this watch request will carry the same\n\t * id.\n\t */\n\treadonly correlationId?: number;\n\n\t/**\n\t * If provided, allows to filter the events that the watcher should consider\n\t * for emitting. If not provided, all events are emitted.\n\t *\n\t * For example, to emit added and updated events, set to:\n\t * `FileChangeFilter.ADDED | FileChangeFilter.UPDATED`.\n\t */\n\treadonly filter?: FileChangeFilter;\n}\n\nexport interface IWatchRequestWithCorrelation extends IWatchRequest {\n\treadonly correlationId: number;\n}\n\nexport function isWatchRequestWithCorrelation(request: IWatchRequest): request is IWatchRequestWithCorrelation {\n\treturn typeof request.correlationId === 'number';\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\treadonly recursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be recursive.\n\t */\n\treadonly recursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport function isRecursiveWatchRequest(request: IWatchRequest): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest = IRecursiveWatchRequest | INonRecursiveWatchRequest;\n\nexport interface IWatcherErrorEvent {\n\treadonly error: string;\n\treadonly request?: IUniversalWatchRequest;\n}\n\nexport interface IWatcher {\n\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<IWatcherErrorEvent>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherWithSubscribe extends IRecursiveWatcher {\n\n\t/**\n\t * Subscribe to file events for the given path. The callback is called\n\t * whenever a file event occurs for the path. If the watcher failed,\n\t * the error parameter is set to `true`.\n\t *\n\t * @returns an `IDisposable` to stop listening to events or `undefined`\n\t * if no events can be watched for the path given the current set of\n\t * recursive watch requests.\n\t */\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined;\n}\n\nexport interface IRecursiveWatcherOptions {\n\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly usePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly pollingInterval?: number;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(new MutableDisposable());\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\treadonly type: string;\n\t\t\treadonly restartOnError: boolean;\n\t\t}\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n\t\tdisposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n\t\tdisposables.add(this.watcher.onDidError(e => this.onError(e.error, e.request)));\n\t}\n\n\tprotected onError(error: string, failedRequest?: IUniversalWatchRequest): void {\n\n\t\t// Restart on error (up to N times, if possible)\n\t\tif (this.canRestart(error, failedRequest)) {\n\t\t\tif (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n\t\t\t\tthis.error(`restarting watcher after unexpected error: ${error}`);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(`gave up attempting to restart watcher after unexpected error: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart otherwise, report the error\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate canRestart(error: string, failedRequest?: IUniversalWatchRequest): boolean {\n\t\tif (!this.options.restartOnError) {\n\t\t\treturn false; // disabled by options\n\t\t}\n\n\t\tif (failedRequest) {\n\t\t\t// do not treat a failing request as a reason to restart the entire\n\t\t\t// watcher. it is possible that from a large amount of watch requests\n\t\t\t// some fail and we would constantly restart all requests only because\n\t\t\t// of that. rather, continue the watcher and leave the failed request\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\terror.indexOf('No space left on device') !== -1 ||\n\t\t\terror.indexOf('EMFILE') !== -1\n\t\t) {\n\t\t\t// do not restart when the error indicates that the system is running\n\t\t\t// out of handles for file watching. this is not recoverable anyway\n\t\t\t// and needs changes to the system before continuing\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\tprotected trace(message: string) {\n\t\tthis.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\toverride dispose(): void {\n\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'node.js', restartOnError: false });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'universal', restartOnError: true });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): IUniversalWatcher;\n}\n\nexport interface ILogMessage {\n\treadonly type: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\treadonly message: string;\n}\n\nexport function reviveFileChanges(changes: IFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: URI.revive(change.resource),\n\t\tcId: change.cId\n\t}));\n}\n\nexport function coalesceEvents(changes: IFileChange[]): IFileChange[] {\n\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(path: string, pattern: string | IRelativePattern): string | IRelativePattern {\n\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(path: string, patterns: Array<string | IRelativePattern>): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\n\tprivate readonly coalesced = new Set<IFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IFileChange>();\n\n\tprivate toKey(event: IFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.resource.fsPath;\n\t\t}\n\n\t\treturn event.resource.fsPath.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (existingEvent.resource.fsPath !== event.resource.fsPath && (event.type === FileChangeType.DELETED || event.type === FileChangeType.ADDED)) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IFileChange[] {\n\t\tconst addOrChangeEvents: IFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced).filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.resource.fsPath.length - e2.resource.fsPath.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(deletedPath => isParent(e.resource.fsPath, deletedPath, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.resource.fsPath);\n\n\t\t\treturn true;\n\t\t}).concat(addOrChangeEvents);\n\t}\n}\n\nexport function isFiltered(event: IFileChange, filter: FileChangeFilter | undefined): boolean {\n\tif (typeof filter === 'number') {\n\t\tswitch (event.type) {\n\t\t\tcase FileChangeType.ADDED:\n\t\t\t\treturn (filter & FileChangeFilter.ADDED) === 0;\n\t\t\tcase FileChangeType.DELETED:\n\t\t\t\treturn (filter & FileChangeFilter.DELETED) === 0;\n\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\treturn (filter & FileChangeFilter.UPDATED) === 0;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function requestFilterToString(filter: FileChangeFilter | undefined): string {\n\tif (typeof filter === 'number') {\n\t\tconst filters = [];\n\t\tif (filter & FileChangeFilter.ADDED) {\n\t\t\tfilters.push('Added');\n\t\t}\n\t\tif (filter & FileChangeFilter.DELETED) {\n\t\t\tfilters.push('Deleted');\n\t\t}\n\t\tif (filter & FileChangeFilter.UPDATED) {\n\t\t\tfilters.push('Updated');\n\t\t}\n\n\t\tif (filters.length === 0) {\n\t\t\treturn '<all>';\n\t\t}\n\n\t\treturn `[${filters.join(', ')}]`;\n\t}\n\n\treturn '<none>';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { GLOBSTAR, IRelativePattern, parse, ParsedPattern } from '../../../base/common/glob.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isAbsolute } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { FileChangeFilter, FileChangeType, IFileChange, isParent } from './files.js';\n\ninterface IWatchRequest {\n\n\t/**\n\t * The path to watch.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\treadonly excludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\treadonly includes?: Array<string | IRelativePattern>;\n\n\t/**\n\t * If provided, file change events from the watcher that\n\t * are a result of this watch request will carry the same\n\t * id.\n\t */\n\treadonly correlationId?: number;\n\n\t/**\n\t * If provided, allows to filter the events that the watcher should consider\n\t * for emitting. If not provided, all events are emitted.\n\t *\n\t * For example, to emit added and updated events, set to:\n\t * `FileChangeFilter.ADDED | FileChangeFilter.UPDATED`.\n\t */\n\treadonly filter?: FileChangeFilter;\n}\n\nexport interface IWatchRequestWithCorrelation extends IWatchRequest {\n\treadonly correlationId: number;\n}\n\nexport function isWatchRequestWithCorrelation(request: IWatchRequest): request is IWatchRequestWithCorrelation {\n\treturn typeof request.correlationId === 'number';\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\treadonly recursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be recursive.\n\t */\n\treadonly recursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport function isRecursiveWatchRequest(request: IWatchRequest): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest = IRecursiveWatchRequest | INonRecursiveWatchRequest;\n\nexport interface IWatcherErrorEvent {\n\treadonly error: string;\n\treadonly request?: IUniversalWatchRequest;\n}\n\nexport interface IWatcher {\n\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<IWatcherErrorEvent>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherWithSubscribe extends IRecursiveWatcher {\n\n\t/**\n\t * Subscribe to file events for the given path. The callback is called\n\t * whenever a file event occurs for the path. If the watcher failed,\n\t * the error parameter is set to `true`.\n\t *\n\t * @returns an `IDisposable` to stop listening to events or `undefined`\n\t * if no events can be watched for the path given the current set of\n\t * recursive watch requests.\n\t */\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined;\n}\n\nexport interface IRecursiveWatcherOptions {\n\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly usePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly pollingInterval?: number;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(new MutableDisposable());\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\treadonly type: string;\n\t\t\treadonly restartOnError: boolean;\n\t\t}\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n\t\tdisposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n\t\tdisposables.add(this.watcher.onDidError(e => this.onError(e.error, e.request)));\n\t}\n\n\tprotected onError(error: string, failedRequest?: IUniversalWatchRequest): void {\n\n\t\t// Restart on error (up to N times, if possible)\n\t\tif (this.canRestart(error, failedRequest)) {\n\t\t\tif (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n\t\t\t\tthis.error(`restarting watcher after unexpected error: ${error}`);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(`gave up attempting to restart watcher after unexpected error: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart otherwise, report the error\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate canRestart(error: string, failedRequest?: IUniversalWatchRequest): boolean {\n\t\tif (!this.options.restartOnError) {\n\t\t\treturn false; // disabled by options\n\t\t}\n\n\t\tif (failedRequest) {\n\t\t\t// do not treat a failing request as a reason to restart the entire\n\t\t\t// watcher. it is possible that from a large amount of watch requests\n\t\t\t// some fail and we would constantly restart all requests only because\n\t\t\t// of that. rather, continue the watcher and leave the failed request\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\terror.indexOf('No space left on device') !== -1 ||\n\t\t\terror.indexOf('EMFILE') !== -1\n\t\t) {\n\t\t\t// do not restart when the error indicates that the system is running\n\t\t\t// out of handles for file watching. this is not recoverable anyway\n\t\t\t// and needs changes to the system before continuing\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\tprotected trace(message: string) {\n\t\tthis.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\toverride dispose(): void {\n\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'node.js', restartOnError: false });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'universal', restartOnError: true });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): IUniversalWatcher;\n}\n\nexport interface ILogMessage {\n\treadonly type: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\treadonly message: string;\n}\n\nexport function reviveFileChanges(changes: IFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: URI.revive(change.resource),\n\t\tcId: change.cId\n\t}));\n}\n\nexport function coalesceEvents(changes: IFileChange[]): IFileChange[] {\n\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(path: string, pattern: string | IRelativePattern): string | IRelativePattern {\n\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(path: string, patterns: Array<string | IRelativePattern>): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\n\tprivate readonly coalesced = new Set<IFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IFileChange>();\n\n\tprivate toKey(event: IFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.resource.fsPath;\n\t\t}\n\n\t\treturn event.resource.fsPath.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (existingEvent.resource.fsPath !== event.resource.fsPath && (event.type === FileChangeType.DELETED || event.type === FileChangeType.ADDED)) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IFileChange[] {\n\t\tconst addOrChangeEvents: IFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced).filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.resource.fsPath.length - e2.resource.fsPath.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(deletedPath => isParent(e.resource.fsPath, deletedPath, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.resource.fsPath);\n\n\t\t\treturn true;\n\t\t}).concat(addOrChangeEvents);\n\t}\n}\n\nexport function isFiltered(event: IFileChange, filter: FileChangeFilter | undefined): boolean {\n\tif (typeof filter === 'number') {\n\t\tswitch (event.type) {\n\t\t\tcase FileChangeType.ADDED:\n\t\t\t\treturn (filter & FileChangeFilter.ADDED) === 0;\n\t\t\tcase FileChangeType.DELETED:\n\t\t\t\treturn (filter & FileChangeFilter.DELETED) === 0;\n\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\treturn (filter & FileChangeFilter.UPDATED) === 0;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function requestFilterToString(filter: FileChangeFilter | undefined): string {\n\tif (typeof filter === 'number') {\n\t\tconst filters = [];\n\t\tif (filter & FileChangeFilter.ADDED) {\n\t\t\tfilters.push('Added');\n\t\t}\n\t\tif (filter & FileChangeFilter.DELETED) {\n\t\t\tfilters.push('Deleted');\n\t\t}\n\t\tif (filter & FileChangeFilter.UPDATED) {\n\t\t\tfilters.push('Updated');\n\t\t}\n\n\t\tif (filters.length === 0) {\n\t\t\treturn '<all>';\n\t\t}\n\n\t\treturn `[${filters.join(', ')}]`;\n\t}\n\n\treturn '<none>';\n}\n"]}