{"version":3,"sources":["vs/platform/files/common/fileService.ts"],"names":[],"mappings":"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","file":"fileService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { Promises, ResourceQueue } from '../../../base/common/async.js';\nimport { bufferedStreamToBuffer, bufferToReadable, newWriteableBufferStream, readableToBuffer, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableBufferedStream, VSBufferReadableStream } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, DisposableStore, dispose, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { mark } from '../../../base/common/performance.js';\nimport { extUri, extUriIgnorePathCase, IExtUri, isAbsolutePath } from '../../../base/common/resources.js';\nimport { consumeStream, isReadableBufferedStream, isReadableStream, listenStream, newWriteableStream, peekReadable, peekStream, transform } from '../../../base/common/stream.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { ensureFileSystemProviderError, etag, ETAG_DISABLED, FileChangesEvent, IFileDeleteOptions, FileOperation, FileOperationError, FileOperationEvent, FileOperationResult, FilePermission, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, hasFileAtomicReadCapability, hasFileFolderCopyCapability, hasFileReadStreamCapability, hasOpenReadWriteCloseCapability, hasReadWriteCapability, ICreateFileOptions, IFileContent, IFileService, IFileStat, IFileStatWithMetadata, IFileStreamContent, IFileSystemProvider, IFileSystemProviderActivationEvent, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemProviderRegistrationEvent, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IReadFileOptions, IReadFileStreamOptions, IResolveFileOptions, IFileStatResult, IFileStatResultWithMetadata, IResolveMetadataFileOptions, IStat, IFileStatWithPartialMetadata, IWatchOptions, IWriteFileOptions, NotModifiedSinceFileOperationError, toFileOperationResult, toFileSystemProviderErrorCode, hasFileCloneCapability, TooLargeFileOperationError, hasFileAtomicDeleteCapability, hasFileAtomicWriteCapability, IWatchOptionsWithCorrelation, IFileSystemWatcher, IWatchOptionsWithoutCorrelation, hasFileRealpathCapability } from './files.js';\nimport { readFileIntoStream } from './io.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ErrorNoTelemetry } from '../../../base/common/errors.js';\n\nexport class FileService extends Disposable implements IFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t// Choose a buffer size that is a balance between memory needs and\n\t// manageable IPC overhead. The larger the buffer size, the less\n\t// roundtrips we have to do for reading/writing data.\n\tprivate readonly BUFFER_SIZE = 256 * 1024;\n\n\tconstructor(@ILogService private readonly logService: ILogService) {\n\t\tsuper();\n\t}\n\n\t//#region File System Provider\n\n\tprivate readonly _onDidChangeFileSystemProviderRegistrations = this._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\treadonly onDidChangeFileSystemProviderRegistrations = this._onDidChangeFileSystemProviderRegistrations.event;\n\n\tprivate readonly _onWillActivateFileSystemProvider = this._register(new Emitter<IFileSystemProviderActivationEvent>());\n\treadonly onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities = this._register(new Emitter<IFileSystemProviderCapabilitiesChangeEvent>());\n\treadonly onDidChangeFileSystemProviderCapabilities = this._onDidChangeFileSystemProviderCapabilities.event;\n\n\tprivate readonly provider = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable {\n\t\tif (this.provider.has(scheme)) {\n\t\t\tthrow new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n\t\t}\n\n\t\tmark(`code/registerFilesystem/${scheme}`);\n\n\t\tconst providerDisposables = new DisposableStore();\n\n\t\t// Add provider with event\n\t\tthis.provider.set(scheme, provider);\n\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });\n\n\t\t// Forward events from provider\n\t\tproviderDisposables.add(provider.onDidChangeFile(changes => {\n\t\t\tconst event = new FileChangesEvent(changes, !this.isPathCaseSensitive(provider));\n\n\t\t\t// Always emit any event internally\n\t\t\tthis.internalOnDidFilesChange.fire(event);\n\n\t\t\t// Only emit uncorrelated events in the global `onDidFilesChange` event\n\t\t\tif (!event.hasCorrelation()) {\n\t\t\t\tthis._onDidUncorrelatedFilesChange.fire(event);\n\t\t\t}\n\t\t}));\n\t\tif (typeof provider.onDidWatchError === 'function') {\n\t\t\tproviderDisposables.add(provider.onDidWatchError(error => this._onDidWatchError.fire(new Error(error))));\n\t\t}\n\t\tproviderDisposables.add(provider.onDidChangeCapabilities(() => this._onDidChangeFileSystemProviderCapabilities.fire({ provider, scheme })));\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });\n\t\t\tthis.provider.delete(scheme);\n\n\t\t\tdispose(providerDisposables);\n\t\t});\n\t}\n\n\tgetProvider(scheme: string): IFileSystemProvider | undefined {\n\t\treturn this.provider.get(scheme);\n\t}\n\n\tasync activateProvider(scheme: string): Promise<void> {\n\n\t\t// Emit an event that we are about to activate a provider with the given scheme.\n\t\t// Listeners can participate in the activation by registering a provider for it.\n\t\tconst joiners: Promise<void>[] = [];\n\t\tthis._onWillActivateFileSystemProvider.fire({\n\t\t\tscheme,\n\t\t\tjoin(promise) {\n\t\t\t\tjoiners.push(promise);\n\t\t\t},\n\t\t});\n\n\t\tif (this.provider.has(scheme)) {\n\t\t\treturn; // provider is already here so we can return directly\n\t\t}\n\n\t\t// If the provider is not yet there, make sure to join on the listeners assuming\n\t\t// that it takes a bit longer to register the file system provider.\n\t\tawait Promises.settled(joiners);\n\t}\n\n\tasync canHandleResource(resource: URI): Promise<boolean> {\n\n\t\t// Await activation of potentially extension contributed providers\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\treturn this.hasProvider(resource);\n\t}\n\n\thasProvider(resource: URI): boolean {\n\t\treturn this.provider.has(resource.scheme);\n\t}\n\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n\t\tconst provider = this.provider.get(resource.scheme);\n\n\t\treturn !!(provider && (provider.capabilities & capability));\n\t}\n\n\tlistCapabilities(): Iterable<{ scheme: string; capabilities: FileSystemProviderCapabilities }> {\n\t\treturn Iterable.map(this.provider, ([scheme, provider]) => ({ scheme, capabilities: provider.capabilities }));\n\t}\n\n\tprotected async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\n\t\t// Assert path is absolute\n\t\tif (!isAbsolutePath(resource)) {\n\t\t\tthrow new FileOperationError(localize('invalidPath', \"Unable to resolve filesystem provider with relative file path '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_INVALID_PATH);\n\t\t}\n\n\t\t// Activate provider\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\t// Assert provider\n\t\tconst provider = this.provider.get(resource.scheme);\n\t\tif (!provider) {\n\t\t\tconst error = new ErrorNoTelemetry();\n\t\t\terror.message = localize('noProviderFound', \"ENOPRO: No file system provider found for resource '{0}'\", resource.toString());\n\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate async withReadProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) || hasFileReadStreamCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n\t}\n\n\tprivate async withWriteProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n\t}\n\n\t//#endregion\n\n\t//#region Operation events\n\n\tprivate readonly _onDidRunOperation = this._register(new Emitter<FileOperationEvent>());\n\treadonly onDidRunOperation = this._onDidRunOperation.event;\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\ttry {\n\t\t\treturn await this.doResolveFile(resource, options);\n\t\t} catch (error) {\n\n\t\t\t// Specially handle file not found case as file operation result\n\t\t\tif (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\tthrow new FileOperationError(localize('fileNotFoundError', \"Unable to resolve nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Bubble up any other error as is\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async doResolveFile(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\tconst resolveTo = options?.resolveTo;\n\t\tconst resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n\t\tconst resolveMetadata = options?.resolveMetadata;\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\tlet trie: TernarySearchTree<URI, boolean> | undefined;\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n\t\t\t// lazy trie to check for recursive resolving\n\t\t\tif (!trie) {\n\t\t\t\ttrie = TernarySearchTree.forUris<true>(() => !isPathCaseSensitive);\n\t\t\t\ttrie.set(resource, true);\n\t\t\t\tif (resolveTo) {\n\t\t\t\t\ttrie.fill(true, resolveTo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check for recursive resolving\n\t\t\tif (trie.get(stat.resource) || trie.findSuperstr(stat.resource.with({ query: null, fragment: null } /* required for https://github.com/microsoft/vscode/issues/128151 */))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check for resolving single child folders\n\t\t\tif (stat.isDirectory && resolveSingleChildDescendants) {\n\t\t\t\treturn siblings === 1;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStatWithMetadata>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat> {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\t// convert to file stat\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource,\n\t\t\tname: providerExtUri.basename(resource),\n\t\t\tisFile: (stat.type & FileType.File) !== 0,\n\t\t\tisDirectory: (stat.type & FileType.Directory) !== 0,\n\t\t\tisSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n\t\t\tmtime: stat.mtime,\n\t\t\tctime: stat.ctime,\n\t\t\tsize: stat.size,\n\t\t\treadonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || Boolean(provider.capabilities & FileSystemProviderCapabilities.Readonly),\n\t\t\tlocked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),\n\t\t\tetag: etag({ mtime: stat.mtime, size: stat.size }),\n\t\t\tchildren: undefined\n\t\t};\n\n\t\t// check to recurse for directories\n\t\tif (fileStat.isDirectory && recurse(fileStat, siblings)) {\n\t\t\ttry {\n\t\t\t\tconst entries = await provider.readdir(resource);\n\t\t\t\tconst resolvedEntries = await Promises.settled(entries.map(async ([name, type]) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst childResource = providerExtUri.joinPath(resource, name);\n\t\t\t\t\t\tconst childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n\t\t\t\t\t\treturn await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t\treturn null; // can happen e.g. due to permission errors\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// make sure to get rid of null values that signal a failure to resolve a particular entry\n\t\t\t\tfileStat.children = coalesce(resolvedEntries);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\tfileStat.children = []; // gracefully handle errors, we may not have permissions to read\n\t\t\t}\n\n\t\t\treturn fileStat;\n\t\t}\n\n\t\treturn fileStat;\n\t}\n\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]>;\n\tasync resolveAll(toResolve: { resource: URI; options: IResolveMetadataFileOptions }[]): Promise<IFileStatResultWithMetadata[]>;\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]> {\n\t\treturn Promises.settled(toResolve.map(async entry => {\n\t\t\ttry {\n\t\t\t\treturn { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\treturn { stat: undefined, success: false };\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync stat(resource: URI): Promise<IFileStatWithPartialMetadata> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, true, () => false /* Do not resolve any children */);\n\t}\n\n\tasync realpath(resource: URI): Promise<URI | undefined> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasFileRealpathCapability(provider)) {\n\t\t\tconst realpath = await provider.realpath(resource);\n\n\t\t\treturn resource.with({ path: realpath });\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync exists(resource: URI): Promise<boolean> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\ttry {\n\t\t\tconst stat = await provider.stat(resource);\n\n\t\t\treturn !!stat;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateCreateFile(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateCreateFile(resource: URI, options?: ICreateFileOptions): Promise<void> {\n\n\t\t// validate overwrite\n\t\tif (!options?.overwrite && await this.exists(resource)) {\n\t\t\tthrow new FileOperationError(localize('fileExists', \"Unable to create file '{0}' that already exists when overwrite flag is not set\", this.resourceForError(resource)), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\t}\n\n\tasync createFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream = VSBuffer.fromString(''), options?: ICreateFileOptions): Promise<IFileStatWithMetadata> {\n\n\t\t// validate\n\t\tawait this.doValidateCreateFile(resource, options);\n\n\t\t// do write into file (this will create it too)\n\t\tconst fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n\t\t// events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\tlet writeFileOptions = options;\n\t\tif (hasFileAtomicWriteCapability(provider) && !writeFileOptions?.atomic) {\n\t\t\tconst enforcedAtomicWrite = provider.enforceAtomicWriteFile?.(resource);\n\t\t\tif (enforcedAtomicWrite) {\n\t\t\t\twriteFileOptions = { ...options, atomic: enforcedAtomicWrite };\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\n\t\t\t// validate write (this may already return a peeked-at buffer)\n\t\t\tlet { stat, buffer: bufferOrReadableOrStreamOrBufferedStream } = await this.validateWriteFile(provider, resource, bufferOrReadableOrStream, writeFileOptions);\n\n\t\t\t// mkdir recursively as needed\n\t\t\tif (!stat) {\n\t\t\t\tawait this.mkdirp(provider, providerExtUri.dirname(resource));\n\t\t\t}\n\n\t\t\t// optimization: if the provider has unbuffered write capability and the data\n\t\t\t// to write is not a buffer, we consume up to 3 chunks and try to write the data\n\t\t\t// unbuffered to reduce the overhead. If the stream or readable has more data\n\t\t\t// to provide we continue to write buffered.\n\t\t\tif (!bufferOrReadableOrStreamOrBufferedStream) {\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = await this.peekBufferForWriting(provider, bufferOrReadableOrStream);\n\t\t\t}\n\n\t\t\t// write file: unbuffered\n\t\t\tif (\n\t\t\t\t!hasOpenReadWriteCloseCapability(provider) ||\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// buffered writing is unsupported\n\t\t\t\t(hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) ||\t\t// data is a full buffer already\n\t\t\t\t(hasReadWriteCapability(provider) && hasFileAtomicWriteCapability(provider) && writeFileOptions?.atomic)\t// atomic write forces unbuffered write if the provider supports it\n\t\t\t) {\n\t\t\t\tawait this.doWriteUnbuffered(provider, resource, writeFileOptions, bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\n\t\t\t// write file: buffered\n\t\t\telse {\n\t\t\t\tawait this.doWriteBuffered(provider, resource, writeFileOptions, bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer ? bufferToReadable(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\n\t\t\t// events\n\t\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.WRITE));\n\t\t} catch (error) {\n\t\t\tthrow new FileOperationError(localize('err.write', \"Unable to write file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), writeFileOptions);\n\t\t}\n\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\n\tprivate async peekBufferForWriting(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream): Promise<VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream> {\n\t\tlet peekResult: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream;\n\t\tif (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof VSBuffer)) {\n\t\t\tif (isReadableStream(bufferOrReadableOrStream)) {\n\t\t\t\tconst bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n\t\t\t\tif (bufferedStream.ended) {\n\t\t\t\t\tpeekResult = VSBuffer.concat(bufferedStream.buffer);\n\t\t\t\t} else {\n\t\t\t\t\tpeekResult = bufferedStream;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpeekResult = peekReadable(bufferOrReadableOrStream, data => VSBuffer.concat(data), 3);\n\t\t\t}\n\t\t} else {\n\t\t\tpeekResult = bufferOrReadableOrStream;\n\t\t}\n\n\t\treturn peekResult;\n\t}\n\n\tprivate async validateWriteFile(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<{ stat: IStat | undefined; buffer: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream | undefined }> {\n\n\t\t// Validate unlock support\n\t\tconst unlock = !!options?.unlock;\n\t\tif (unlock && !(provider.capabilities & FileSystemProviderCapabilities.FileWriteUnlock)) {\n\t\t\tthrow new Error(localize('writeFailedUnlockUnsupported', \"Unable to unlock file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = !!options?.atomic;\n\t\tif (atomic) {\n\t\t\tif (!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicWrite)) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnsupported1', \"Unable to atomically write file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t\t}\n\n\t\t\tif (!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite)) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnsupported2', \"Unable to atomically write file '{0}' because provider does not support unbuffered writes.\", this.resourceForError(resource)));\n\t\t\t}\n\n\t\t\tif (unlock) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnlock', \"Unable to unlock file '{0}' because atomic write is enabled.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\t// Validate via file stat meta data\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn Object.create(null); // file might not exist\n\t\t}\n\n\t\t// File cannot be directory\n\t\tif ((stat.type & FileType.Directory) !== 0) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryWriteError', \"Unable to write file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// File cannot be readonly\n\t\tthis.throwIfFileIsReadonly(resource, stat);\n\n\t\t// Dirty write prevention: if the file on disk has been changed and does not match our expected\n\t\t// mtime and etag, we bail out to prevent dirty writing.\n\t\t//\n\t\t// First, we check for a mtime that is in the future before we do more checks. The assumption is\n\t\t// that only the mtime is an indicator for a file that has changed on disk.\n\t\t//\n\t\t// Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n\t\t// one using the etag() function. Relying only on the mtime check has prooven to produce false\n\t\t// positives due to file system weirdness (especially around remote file systems). As such, the\n\t\t// check for size is a weaker check because it can return a false negative if the file has changed\n\t\t// but to the same length. This is a compromise we take to avoid having to produce checksums of\n\t\t// the file content for comparison which would be much slower to compute.\n\t\t//\n\t\t// Third, if the etag() turns out to be different, we do one attempt to compare the buffer we\n\t\t// are about to write with the contents on disk to figure out if the contents are identical.\n\t\t// In that case we allow the writing as it would result in the same contents in the file.\n\t\tlet buffer: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream | undefined;\n\t\tif (\n\t\t\ttypeof options?.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n\t\t\ttypeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n\t\t\toptions.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size })\n\t\t) {\n\t\t\tbuffer = await this.peekBufferForWriting(provider, bufferOrReadableOrStream);\n\t\t\tif (buffer instanceof VSBuffer && buffer.byteLength === stat.size) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { value } = await this.readFile(resource, { limits: { size: stat.size } });\n\t\t\t\t\tif (buffer.equals(value)) {\n\t\t\t\t\t\treturn { stat, buffer }; // allow writing since contents are identical\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignore, throw the FILE_MODIFIED_SINCE error\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new FileOperationError(localize('fileModifiedError', \"File Modified Since\"), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\n\t\treturn { stat, buffer };\n\t}\n\n\tasync readFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\tif (options?.atomic) {\n\t\t\treturn this.doReadFileAtomic(provider, resource, options, token);\n\t\t}\n\n\t\treturn this.doReadFile(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileAtomic(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\treturn new Promise<IFileContent>((resolve, reject) => {\n\t\t\tthis.writeQueue.queueFor(resource, async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.doReadFile(provider, resource, options, token);\n\t\t\t\t\tresolve(content);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t}, this.getExtUri(provider).providerExtUri);\n\t\t});\n\t}\n\n\tprivate async doReadFile(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\tconst stream = await this.doReadFileStream(provider, resource, {\n\t\t\t...options,\n\t\t\t// optimization: since we know that the caller does not\n\t\t\t// care about buffering, we indicate this to the reader.\n\t\t\t// this reduces all the overhead the buffered reading\n\t\t\t// has (open, read, close) if the provider supports\n\t\t\t// unbuffered reading.\n\t\t\tpreferUnbuffered: true\n\t\t}, token);\n\n\t\treturn {\n\t\t\t...stream,\n\t\t\tvalue: await streamToBuffer(stream.value)\n\t\t};\n\t}\n\n\tasync readFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\treturn this.doReadFileStream(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileStream(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions & IReadFileStreamOptions & { preferUnbuffered?: boolean }, token?: CancellationToken): Promise<IFileStreamContent> {\n\n\t\t// install a cancellation token that gets cancelled\n\t\t// when any error occurs. this allows us to resolve\n\t\t// the content of the file while resolving metadata\n\t\t// but still cancel the operation in certain cases.\n\t\t//\n\t\t// in addition, we pass the optional token in that\n\t\t// we got from the outside to even allow for external\n\t\t// cancellation of the read operation.\n\t\tconst cancellableSource = new CancellationTokenSource(token);\n\n\t\tlet readFileOptions = options;\n\t\tif (hasFileAtomicReadCapability(provider) && provider.enforceAtomicReadFile?.(resource)) {\n\t\t\treadFileOptions = { ...options, atomic: true };\n\t\t}\n\n\t\t// validate read operation\n\t\tconst statPromise = this.validateReadFile(resource, readFileOptions).then(stat => stat, error => {\n\t\t\tcancellableSource.dispose(true);\n\n\t\t\tthrow error;\n\t\t});\n\n\t\tlet fileStream: VSBufferReadableStream | undefined = undefined;\n\t\ttry {\n\n\t\t\t// if the etag is provided, we await the result of the validation\n\t\t\t// due to the likelihood of hitting a NOT_MODIFIED_SINCE result.\n\t\t\t// otherwise, we let it run in parallel to the file reading for\n\t\t\t// optimal startup performance.\n\t\t\tif (typeof readFileOptions?.etag === 'string' && readFileOptions.etag !== ETAG_DISABLED) {\n\t\t\t\tawait statPromise;\n\t\t\t}\n\n\t\t\t// read unbuffered\n\t\t\tif (\n\t\t\t\t(readFileOptions?.atomic && hasFileAtomicReadCapability(provider)) ||\t\t\t\t\t\t\t\t// atomic reads are always unbuffered\n\t\t\t\t!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) ||\t// provider has no buffered capability\n\t\t\t\t(hasReadWriteCapability(provider) && readFileOptions?.preferUnbuffered)\t\t\t\t\t\t\t\t// unbuffered read is preferred\n\t\t\t) {\n\t\t\t\tfileStream = this.readFileUnbuffered(provider, resource, readFileOptions);\n\t\t\t}\n\n\t\t\t// read streamed (always prefer over primitive buffered read)\n\t\t\telse if (hasFileReadStreamCapability(provider)) {\n\t\t\t\tfileStream = this.readFileStreamed(provider, resource, cancellableSource.token, readFileOptions);\n\t\t\t}\n\n\t\t\t// read buffered\n\t\t\telse {\n\t\t\t\tfileStream = this.readFileBuffered(provider, resource, cancellableSource.token, readFileOptions);\n\t\t\t}\n\n\t\t\tfileStream.on('end', () => cancellableSource.dispose());\n\t\t\tfileStream.on('error', () => cancellableSource.dispose());\n\n\t\t\tconst fileStat = await statPromise;\n\n\t\t\treturn {\n\t\t\t\t...fileStat,\n\t\t\t\tvalue: fileStream\n\t\t\t};\n\t\t} catch (error) {\n\n\t\t\t// Await the stream to finish so that we exit this method\n\t\t\t// in a consistent state with file handles closed\n\t\t\t// (https://github.com/microsoft/vscode/issues/114024)\n\t\t\tif (fileStream) {\n\t\t\t\tawait consumeStream(fileStream);\n\t\t\t}\n\n\t\t\t// Re-throw errors as file operation errors but preserve\n\t\t\t// specific errors (such as not modified since)\n\t\t\tthrow this.restoreReadError(error, resource, readFileOptions);\n\t\t}\n\t}\n\n\tprivate restoreReadError(error: Error, resource: URI, options?: IReadFileStreamOptions): FileOperationError {\n\t\tconst message = localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString());\n\n\t\tif (error instanceof NotModifiedSinceFileOperationError) {\n\t\t\treturn new NotModifiedSinceFileOperationError(message, error.stat, options);\n\t\t}\n\n\t\tif (error instanceof TooLargeFileOperationError) {\n\t\t\treturn new TooLargeFileOperationError(message, error.fileOperationResult, error.size, error.options as IReadFileOptions);\n\t\t}\n\n\t\treturn new FileOperationError(message, toFileOperationResult(error), options);\n\t}\n\n\tprivate readFileStreamed(provider: IFileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst fileStream = provider.readFileStream(resource, options, token);\n\n\t\treturn transform(fileStream, {\n\t\t\tdata: data => data instanceof VSBuffer ? data : VSBuffer.wrap(data),\n\t\t\terror: error => this.restoreReadError(error, resource, options)\n\t\t}, data => VSBuffer.concat(data));\n\t}\n\n\tprivate readFileBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\n\t\treadFileIntoStream(provider, resource, stream, data => data, {\n\t\t\t...options,\n\t\t\tbufferSize: this.BUFFER_SIZE,\n\t\t\terrorTransformer: error => this.restoreReadError(error, resource, options)\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tprivate readFileUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithFileAtomicReadCapability, resource: URI, options?: IReadFileOptions & IReadFileStreamOptions): VSBufferReadableStream {\n\t\tconst stream = newWriteableStream<VSBuffer>(data => VSBuffer.concat(data));\n\n\t\t// Read the file into the stream async but do not wait for\n\t\t// this to complete because streams work via events\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tlet buffer: Uint8Array;\n\t\t\t\tif (options?.atomic && hasFileAtomicReadCapability(provider)) {\n\t\t\t\t\tbuffer = await provider.readFile(resource, { atomic: true });\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = await provider.readFile(resource);\n\t\t\t\t}\n\n\t\t\t\t// respect position option\n\t\t\t\tif (typeof options?.position === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(options.position);\n\t\t\t\t}\n\n\t\t\t\t// respect length option\n\t\t\t\tif (typeof options?.length === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(0, options.length);\n\t\t\t\t}\n\n\t\t\t\t// Throw if file is too large to load\n\t\t\t\tthis.validateReadFileLimits(resource, buffer.byteLength, options);\n\n\t\t\t\t// End stream with data\n\t\t\t\tstream.end(VSBuffer.wrap(buffer));\n\t\t\t} catch (err) {\n\t\t\t\tstream.error(err);\n\t\t\t\tstream.end();\n\t\t\t}\n\t\t})();\n\n\t\treturn stream;\n\t}\n\n\tprivate async validateReadFile(resource: URI, options?: IReadFileStreamOptions): Promise<IFileStatWithMetadata> {\n\t\tconst stat = await this.resolve(resource, { resolveMetadata: true });\n\n\t\t// Throw if resource is a directory\n\t\tif (stat.isDirectory) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryReadError', \"Unable to read file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// Throw if file not modified since (unless disabled)\n\t\tif (typeof options?.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n\t\t\tthrow new NotModifiedSinceFileOperationError(localize('fileNotModifiedError', \"File not modified since\"), stat, options);\n\t\t}\n\n\t\t// Throw if file is too large to load\n\t\tthis.validateReadFileLimits(resource, stat.size, options);\n\n\t\treturn stat;\n\t}\n\n\tprivate validateReadFileLimits(resource: URI, size: number, options?: IReadFileStreamOptions): void {\n\t\tif (typeof options?.limits?.size === 'number' && size > options.limits.size) {\n\t\t\tthrow new TooLargeFileOperationError(localize('fileTooLargeError', \"Unable to read file '{0}' that is too large to open\", this.resourceForError(resource)), FileOperationResult.FILE_TOO_LARGE, size, options);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'move', overwrite);\n\t}\n\n\tasync canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'copy', overwrite);\n\t}\n\n\tprivate async doCanMoveCopy(source: URI, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<Error | true> {\n\t\tif (source.toString() !== target.toString()) {\n\t\t\ttry {\n\t\t\t\tconst sourceProvider = mode === 'move' ? this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source) : await this.withReadProvider(source);\n\t\t\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t\t\tawait this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\t\t\t} catch (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// move\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = await this.withReadProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// copy\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async doMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n\t\tif (source.toString() === target.toString()) {\n\t\t\treturn mode; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\t// validation\n\t\tconst { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n\t\t// delete as needed (unless target is same resurce with different path case)\n\t\tif (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n\t\t\tawait this.del(target, { recursive: true });\n\t\t}\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// copy source => target\n\t\tif (mode === 'copy') {\n\n\t\t\t// same provider with fast copy: leverage copy() functionality\n\t\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\t\tawait sourceProvider.copy(source, target, { overwrite });\n\t\t\t}\n\n\t\t\t// when copying via buffer/unbuffered, we have to manually\n\t\t\t// traverse the source if it is a folder and not a file\n\t\t\telse {\n\t\t\t\tconst sourceFile = await this.resolve(source);\n\t\t\t\tif (sourceFile.isDirectory) {\n\t\t\t\t\tawait this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doCopyFile(sourceProvider, source, targetProvider, target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mode;\n\t\t}\n\n\t\t// move source => target\n\t\telse {\n\n\t\t\t// same provider: leverage rename() functionality\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tawait sourceProvider.rename(source, target, { overwrite });\n\n\t\t\t\treturn mode;\n\t\t\t}\n\n\t\t\t// across providers: copy to target & delete at source\n\t\t\telse {\n\t\t\t\tawait this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\t\t\t\tawait this.del(source, { recursive: true });\n\n\t\t\t\treturn 'copy';\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doCopyFile(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI): Promise<void> {\n\n\t\t// copy: source (buffered) => target (buffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (buffered) => target (unbuffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (buffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (unbuffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\t}\n\n\tprivate async doCopyFolder(sourceProvider: IFileSystemProvider, sourceFolder: IFileStat, targetProvider: IFileSystemProvider, targetFolder: URI): Promise<void> {\n\n\t\t// create folder in target\n\t\tawait targetProvider.mkdir(targetFolder);\n\n\t\t// create children in target\n\t\tif (Array.isArray(sourceFolder.children)) {\n\t\t\tawait Promises.settled(sourceFolder.children.map(async sourceChild => {\n\t\t\t\tconst targetChild = this.getExtUri(targetProvider).providerExtUri.joinPath(targetFolder, sourceChild.name);\n\t\t\t\tif (sourceChild.isDirectory) {\n\t\t\t\t\treturn this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async doValidateMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean; isSameResourceWithDifferentPathCase: boolean }> {\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\n\t\t// Check if source is equal or parent to target (requires providers to be the same)\n\t\tif (sourceProvider === targetProvider) {\n\t\t\tconst { providerExtUri, isPathCaseSensitive } = this.getExtUri(sourceProvider);\n\t\t\tif (!isPathCaseSensitive) {\n\t\t\t\tisSameResourceWithDifferentPathCase = providerExtUri.isEqual(source, target);\n\t\t\t}\n\n\t\t\tif (isSameResourceWithDifferentPathCase && mode === 'copy') {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError1', \"Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\n\t\t\tif (!isSameResourceWithDifferentPathCase && providerExtUri.isEqualOrParent(target, source)) {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError2', \"Unable to move/copy when source '{0}' is parent of target '{1}'.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\t\t}\n\n\t\t// Extra checks if target exists and this is not a rename\n\t\tconst exists = await this.exists(target);\n\t\tif (exists && !isSameResourceWithDifferentPathCase) {\n\n\t\t\t// Bail out if target exists and we are not about to overwrite\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(localize('unableToMoveCopyError3', \"Unable to move/copy '{0}' because target '{1}' already exists at destination.\", this.resourceForError(source), this.resourceForError(target)), FileOperationResult.FILE_MOVE_CONFLICT);\n\t\t\t}\n\n\t\t\t// Special case: if the target is a parent of the source, we cannot delete\n\t\t\t// it as it would delete the source as well. In this case we have to throw\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tconst { providerExtUri } = this.getExtUri(sourceProvider);\n\t\t\t\tif (providerExtUri.isEqualOrParent(source, target)) {\n\t\t\t\t\tthrow new Error(localize('unableToMoveCopyError4', \"Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { exists, isSameResourceWithDifferentPathCase };\n\t}\n\n\tprivate getExtUri(provider: IFileSystemProvider): { providerExtUri: IExtUri; isPathCaseSensitive: boolean } {\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\treturn {\n\t\t\tproviderExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,\n\t\t\tisPathCaseSensitive\n\t\t};\n\t}\n\n\tprivate isPathCaseSensitive(provider: IFileSystemProvider): boolean {\n\t\treturn !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t}\n\n\tasync createFolder(resource: URI): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// mkdir recursively\n\t\tawait this.mkdirp(provider, resource);\n\n\t\t// events\n\t\tconst fileStat = await this.resolve(resource, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async mkdirp(provider: IFileSystemProvider, directory: URI): Promise<void> {\n\t\tconst directoriesToCreate: string[] = [];\n\n\t\t// mkdir until we reach root\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\t\twhile (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {\n\t\t\ttry {\n\t\t\t\tconst stat = await provider.stat(directory);\n\t\t\t\tif ((stat.type & FileType.Directory) === 0) {\n\t\t\t\t\tthrow new Error(localize('mkdirExistsError', \"Unable to create folder '{0}' that already exists but is not a directory\", this.resourceForError(directory)));\n\t\t\t\t}\n\n\t\t\t\tbreak; // we have hit a directory that exists -> good\n\t\t\t} catch (error) {\n\n\t\t\t\t// Bubble up any other error that is not file not found\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Upon error, remember directories that need to be created\n\t\t\t\tdirectoriesToCreate.push(providerExtUri.basename(directory));\n\n\t\t\t\t// Continue up\n\t\t\t\tdirectory = providerExtUri.dirname(directory);\n\t\t\t}\n\t\t}\n\n\t\t// Create directories as needed\n\t\tfor (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n\t\t\tdirectory = providerExtUri.joinPath(directory, directoriesToCreate[i]);\n\n\t\t\ttry {\n\t\t\t\tawait provider.mkdir(directory);\n\t\t\t} catch (error) {\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n\t\t\t\t\t// For mkdirp() we tolerate that the mkdir() call fails\n\t\t\t\t\t// in case the folder already exists. This follows node.js\n\t\t\t\t\t// own implementation of fs.mkdir({ recursive: true }) and\n\t\t\t\t\t// reduces the chances of race conditions leading to errors\n\t\t\t\t\t// if multiple calls try to create the same folders\n\t\t\t\t\t// As such, we only throw an error here if it is other than\n\t\t\t\t\t// the fact that the file already exists.\n\t\t\t\t\t// (see also https://github.com/microsoft/vscode/issues/89834)\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync canDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateDelete(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<IFileSystemProvider> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// Validate trash support\n\t\tconst useTrash = !!options?.useTrash;\n\t\tif (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n\t\t\tthrow new Error(localize('deleteFailedTrashUnsupported', \"Unable to delete file '{0}' via trash because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = options?.atomic;\n\t\tif (atomic && !(provider.capabilities & FileSystemProviderCapabilities.FileAtomicDelete)) {\n\t\t\tthrow new Error(localize('deleteFailedAtomicUnsupported', \"Unable to delete file '{0}' atomically because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\tif (useTrash && atomic) {\n\t\t\tthrow new Error(localize('deleteFailedTrashAndAtomicUnsupported', \"Unable to atomically delete file '{0}' because using trash is enabled.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate delete\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\t// Handled later\n\t\t}\n\n\t\tif (stat) {\n\t\t\tthis.throwIfFileIsReadonly(resource, stat);\n\t\t} else {\n\t\t\tthrow new FileOperationError(localize('deleteFailedNotFound', \"Unable to delete nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t}\n\n\t\t// Validate recursive\n\t\tconst recursive = !!options?.recursive;\n\t\tif (!recursive) {\n\t\t\tconst stat = await this.resolve(resource);\n\t\t\tif (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n\t\t\t\tthrow new Error(localize('deleteFailedNonEmptyFolder', \"Unable to delete non-empty folder '{0}'.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tasync del(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void> {\n\t\tconst provider = await this.doValidateDelete(resource, options);\n\n\t\tlet deleteFileOptions = options;\n\t\tif (hasFileAtomicDeleteCapability(provider) && !deleteFileOptions?.atomic) {\n\t\t\tconst enforcedAtomicDelete = provider.enforceAtomicDelete?.(resource);\n\t\t\tif (enforcedAtomicDelete) {\n\t\t\t\tdeleteFileOptions = { ...options, atomic: enforcedAtomicDelete };\n\t\t\t}\n\t\t}\n\n\t\tconst useTrash = !!deleteFileOptions?.useTrash;\n\t\tconst recursive = !!deleteFileOptions?.recursive;\n\t\tconst atomic = deleteFileOptions?.atomic ?? false;\n\n\t\t// Delete through provider\n\t\tawait provider.delete(resource, { recursive, useTrash, atomic });\n\n\t\t// Events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tasync cloneFile(source: URI, target: URI): Promise<void> {\n\t\tconst sourceProvider = await this.withProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\tif (sourceProvider === targetProvider && this.getExtUri(sourceProvider).providerExtUri.isEqual(source, target)) {\n\t\t\treturn; // return early if paths are equal\n\t\t}\n\n\t\t// same provider, use `cloneFile` when native support is provided\n\t\tif (sourceProvider === targetProvider && hasFileCloneCapability(sourceProvider)) {\n\t\t\treturn sourceProvider.cloneFile(source, target);\n\t\t}\n\n\t\t// otherwise, either providers are different or there is no native\n\t\t// `cloneFile` support, then we fallback to emulate a clone as best\n\t\t// as we can with the other primitives\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// leverage `copy` method if provided and providers are identical\n\t\t// queue on the source to ensure atomic read\n\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\treturn this.writeQueue.queueFor(source, () => sourceProvider.copy(source, target, { overwrite: true }), this.getExtUri(sourceProvider).providerExtUri);\n\t\t}\n\n\t\t// otherwise copy via buffer/unbuffered and use a write queue\n\t\t// on the source to ensure atomic operation as much as possible\n\t\treturn this.writeQueue.queueFor(source, () => this.doCopyFile(sourceProvider, source, targetProvider, target), this.getExtUri(sourceProvider).providerExtUri);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly internalOnDidFilesChange = this._register(new Emitter<FileChangesEvent>());\n\n\tprivate readonly _onDidUncorrelatedFilesChange = this._register(new Emitter<FileChangesEvent>());\n\treadonly onDidFilesChange = this._onDidUncorrelatedFilesChange.event; // global `onDidFilesChange` skips correlated events\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<Error>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\tprivate readonly activeWatchers = new Map<number /* watch request hash */, { disposable: IDisposable; count: number }>();\n\n\tprivate static WATCHER_CORRELATION_IDS = 0;\n\n\tcreateWatcher(resource: URI, options: IWatchOptionsWithoutCorrelation & { recursive: false }): IFileSystemWatcher {\n\t\treturn this.watch(resource, {\n\t\t\t...options,\n\t\t\t// Explicitly set a correlation id so that file events that originate\n\t\t\t// from requests from extensions are exclusively routed back to the\n\t\t\t// extension host and not into the workbench.\n\t\t\tcorrelationId: FileService.WATCHER_CORRELATION_IDS++\n\t\t});\n\t}\n\n\twatch(resource: URI, options: IWatchOptionsWithCorrelation): IFileSystemWatcher;\n\twatch(resource: URI, options?: IWatchOptionsWithoutCorrelation): IDisposable;\n\twatch(resource: URI, options: IWatchOptions = { recursive: false, excludes: [] }): IFileSystemWatcher | IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Forward watch request to provider and wire in disposables\n\t\tlet watchDisposed = false;\n\t\tlet disposeWatch = () => { watchDisposed = true; };\n\t\tdisposables.add(toDisposable(() => disposeWatch()));\n\n\t\t// Watch and wire in disposable which is async but\n\t\t// check if we got disposed meanwhile and forward\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst disposable = await this.doWatch(resource, options);\n\t\t\t\tif (watchDisposed) {\n\t\t\t\t\tdispose(disposable);\n\t\t\t\t} else {\n\t\t\t\t\tdisposeWatch = () => dispose(disposable);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\t// When a correlation identifier is set, return a specific\n\t\t// watcher that only emits events matching that correalation.\n\t\tconst correlationId = options.correlationId;\n\t\tif (typeof correlationId === 'number') {\n\t\t\tconst fileChangeEmitter = disposables.add(new Emitter<FileChangesEvent>());\n\t\t\tdisposables.add(this.internalOnDidFilesChange.event(e => {\n\t\t\t\tif (e.correlates(correlationId)) {\n\t\t\t\t\tfileChangeEmitter.fire(e);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tconst watcher: IFileSystemWatcher = {\n\t\t\t\tonDidChange: fileChangeEmitter.event,\n\t\t\t\tdispose: () => disposables.dispose()\n\t\t\t};\n\n\t\t\treturn watcher;\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate async doWatch(resource: URI, options: IWatchOptions): Promise<IDisposable> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\t// Deduplicate identical watch requests\n\t\tconst watchHash = hash([this.getExtUri(provider).providerExtUri.getComparisonKey(resource), options]);\n\t\tlet watcher = this.activeWatchers.get(watchHash);\n\t\tif (!watcher) {\n\t\t\twatcher = {\n\t\t\t\tcount: 0,\n\t\t\t\tdisposable: provider.watch(resource, options)\n\t\t\t};\n\n\t\t\tthis.activeWatchers.set(watchHash, watcher);\n\t\t}\n\n\t\t// Increment usage counter\n\t\twatcher.count += 1;\n\n\t\treturn toDisposable(() => {\n\t\t\tif (watcher) {\n\n\t\t\t\t// Unref\n\t\t\t\twatcher.count--;\n\n\t\t\t\t// Dispose only when last user is reached\n\t\t\t\tif (watcher.count === 0) {\n\t\t\t\t\tdispose(watcher.disposable);\n\t\t\t\t\tthis.activeWatchers.delete(watchHash);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, watcher] of this.activeWatchers) {\n\t\t\tdispose(watcher.disposable);\n\t\t}\n\n\t\tthis.activeWatchers.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate readonly writeQueue = this._register(new ResourceQueue());\n\n\tprivate async doWriteBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options: IWriteFileOptions | undefined, readableOrStreamOrBufferedStream: VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, async () => {\n\n\t\t\t// open handle\n\t\t\tconst handle = await provider.open(resource, { create: true, unlock: options?.unlock ?? false });\n\n\t\t\t// write into handle until all bytes from buffer have been written\n\t\t\ttry {\n\t\t\t\tif (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n\t\t\t\t\tawait this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t\t} finally {\n\n\t\t\t\t// close handle always\n\t\t\t\tawait provider.close(handle);\n\t\t\t}\n\t\t}, this.getExtUri(provider).providerExtUri);\n\t}\n\n\tprivate async doWriteStreamBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet posInFile = 0;\n\t\tlet stream: VSBufferReadableStream;\n\n\t\t// Buffered stream: consume the buffer first by writing\n\t\t// it to the target before reading from the stream.\n\t\tif (isReadableBufferedStream(streamOrBufferedStream)) {\n\t\t\tif (streamOrBufferedStream.buffer.length > 0) {\n\t\t\t\tconst chunk = VSBuffer.concat(streamOrBufferedStream.buffer);\n\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\t\tposInFile += chunk.byteLength;\n\t\t\t}\n\n\t\t\t// If the stream has been consumed, return early\n\t\t\tif (streamOrBufferedStream.ended) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstream = streamOrBufferedStream.stream;\n\t\t}\n\n\t\t// Unbuffered stream - just take as is\n\t\telse {\n\t\t\tstream = streamOrBufferedStream;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlistenStream(stream, {\n\t\t\t\tonData: async chunk => {\n\n\t\t\t\t\t// pause stream to perform async write operation\n\t\t\t\t\tstream.pause();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tposInFile += chunk.byteLength;\n\n\t\t\t\t\t// resume stream now that we have successfully written\n\t\t\t\t\t// run this on the next tick to prevent increasing the\n\t\t\t\t\t// execution stack because resume() may call the event\n\t\t\t\t\t// handler again before finishing.\n\t\t\t\t\tsetTimeout(() => stream.resume());\n\t\t\t\t},\n\t\t\t\tonError: error => reject(error),\n\t\t\t\tonEnd: () => resolve()\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doWriteReadableBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: VSBufferReadable): Promise<void> {\n\t\tlet posInFile = 0;\n\n\t\tlet chunk: VSBuffer | null;\n\t\twhile ((chunk = readable.read()) !== null) {\n\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\tposInFile += chunk.byteLength;\n\t\t}\n\t}\n\n\tprivate async doWriteBuffer(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: VSBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n\t\tlet totalBytesWritten = 0;\n\t\twhile (totalBytesWritten < length) {\n\n\t\t\t// Write through the provider\n\t\t\tconst bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n\t\t\ttotalBytesWritten += bytesWritten;\n\t\t}\n\t}\n\n\tprivate async doWriteUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, () => this.doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream), this.getExtUri(provider).providerExtUri);\n\t}\n\n\tprivate async doWriteUnbufferedQueued(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet buffer: VSBuffer;\n\t\tif (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {\n\t\t\tbuffer = bufferOrReadableOrStreamOrBufferedStream;\n\t\t} else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await streamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await bufferedStreamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else {\n\t\t\tbuffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t}\n\n\t\t// Write through the provider\n\t\tawait provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true, unlock: options?.unlock ?? false, atomic: options?.atomic ?? false });\n\t}\n\n\tprivate async doPipeBuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, () => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target), this.getExtUri(targetProvider).providerExtUri);\n\t}\n\n\tprivate async doPipeBufferedQueued(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\tlet sourceHandle: number | undefined = undefined;\n\t\tlet targetHandle: number | undefined = undefined;\n\n\t\ttry {\n\n\t\t\t// Open handles\n\t\t\tsourceHandle = await sourceProvider.open(source, { create: false });\n\t\t\ttargetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t\tconst buffer = VSBuffer.alloc(this.BUFFER_SIZE);\n\n\t\t\tlet posInFile = 0;\n\t\t\tlet posInBuffer = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\t\t// write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) all bytes we read (bytesRead).\n\t\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n\t\t\t\tposInFile += bytesRead;\n\t\t\t\tposInBuffer += bytesRead;\n\n\t\t\t\t// when buffer full, fill it again from the beginning\n\t\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\t\tposInBuffer = 0;\n\t\t\t\t}\n\t\t\t} while (bytesRead > 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait Promises.settled([\n\t\t\t\ttypeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n\t\t\t\ttypeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate async doPipeUnbuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, () => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target), this.getExtUri(targetProvider).providerExtUri);\n\t}\n\n\tprivate async doPipeUnbufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true, unlock: false, atomic: false });\n\t}\n\n\tprivate async doPipeUnbufferedToBuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, () => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target), this.getExtUri(targetProvider).providerExtUri);\n\t}\n\n\tprivate async doPipeUnbufferedToBufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n\t\t// Open handle\n\t\tconst targetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t// Read entire buffer from source and write buffered\n\t\ttry {\n\t\t\tconst buffer = await sourceProvider.readFile(source);\n\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, VSBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait targetProvider.close(targetHandle);\n\t\t}\n\t}\n\n\tprivate async doPipeBufferedToUnbuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n\t\t// Read buffer via stream buffered\n\t\tconst buffer = await streamToBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n\t\t// Write buffer into target at once\n\t\tawait this.doWriteUnbuffered(targetProvider, target, undefined, buffer);\n\t}\n\n\tprotected throwIfFileSystemIsReadonly<T extends IFileSystemProvider>(provider: T, resource: URI): T {\n\t\tif (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify read-only file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate throwIfFileIsReadonly(resource: URI, stat: IStat): void {\n\t\tif ((stat.permissions ?? 0) & FilePermission.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify read-only file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\t}\n\n\tprivate resourceForError(resource: URI): string {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\treturn resource.fsPath;\n\t\t}\n\n\t\treturn resource.toString(true);\n\t}\n\n\t//#endregion\n}\n"]}