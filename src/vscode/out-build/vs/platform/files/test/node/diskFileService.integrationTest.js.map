{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/test/node/diskFileService.integrationTest.ts","vs/platform/files/test/node/diskFileService.integrationTest.ts"],"names":[],"mappings":"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","file":"diskFileService.integrationTest.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { createReadStream, existsSync, readdirSync, readFileSync, statSync, writeFileSync, promises } from 'fs';\nimport { tmpdir } from 'os';\nimport { timeout } from '../../../../base/common/async.js';\nimport { bufferToReadable, bufferToStream, streamToBuffer, streamToBufferReadableStream, VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FileAccess, Schemas } from '../../../../base/common/network.js';\nimport { basename, dirname, join, posix } from '../../../../base/common/path.js';\nimport { isLinux, isWindows } from '../../../../base/common/platform.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises } from '../../../../base/node/pfs.js';\nimport { flakySuite, getRandomTestPath } from '../../../../base/test/node/testUtils.js';\nimport { etag, IFileAtomicReadOptions, FileOperation, FileOperationError, FileOperationEvent, FileOperationResult, FilePermission, FileSystemProviderCapabilities, hasFileAtomicReadCapability, hasOpenReadWriteCloseCapability, IFileStat, IFileStatWithMetadata, IReadFileOptions, IStat, NotModifiedSinceFileOperationError, TooLargeFileOperationError, IFileAtomicOptions } from '../../common/files.js';\nimport { FileService } from '../../common/fileService.js';\nimport { DiskFileSystemProvider } from '../../node/diskFileSystemProvider.js';\nimport { NullLogService } from '../../../log/common/log.js';\n\nfunction getByName(root: IFileStat, name: string): IFileStat | undefined {\n\tif (root.children === undefined) {\n\t\treturn undefined;\n\t}\n\n\treturn root.children.find(child => child.name === name);\n}\n\nfunction toLineByLineReadable(content: string): VSBufferReadable {\n\tlet chunks = content.split('\\n');\n\tchunks = chunks.map((chunk, index) => {\n\t\tif (index === 0) {\n\t\t\treturn chunk;\n\t\t}\n\n\t\treturn '\\n' + chunk;\n\t});\n\n\treturn {\n\t\tread(): VSBuffer | null {\n\t\t\tconst chunk = chunks.shift();\n\t\t\tif (typeof chunk === 'string') {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\nexport class TestDiskFileSystemProvider extends DiskFileSystemProvider {\n\n\ttotalBytesRead: number = 0;\n\n\tprivate invalidStatSize: boolean = false;\n\tprivate smallStatSize: boolean = false;\n\tprivate readonly: boolean = false;\n\n\tprivate _testCapabilities!: FileSystemProviderCapabilities;\n\toverride get capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._testCapabilities) {\n\t\t\tthis._testCapabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.Trash |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone |\n\t\t\t\tFileSystemProviderCapabilities.FileRealpath;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._testCapabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._testCapabilities;\n\t}\n\n\toverride set capabilities(capabilities: FileSystemProviderCapabilities) {\n\t\tthis._testCapabilities = capabilities;\n\t}\n\n\tsetInvalidStatSize(enabled: boolean): void {\n\t\tthis.invalidStatSize = enabled;\n\t}\n\n\tsetSmallStatSize(enabled: boolean): void {\n\t\tthis.smallStatSize = enabled;\n\t}\n\n\tsetReadonly(readonly: boolean): void {\n\t\tthis.readonly = readonly;\n\t}\n\n\toverride async stat(resource: URI): Promise<IStat> {\n\t\tconst res = await super.stat(resource);\n\n\t\tif (this.invalidStatSize) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t(res as any).size = String(res.size) as any; // for https://github.com/microsoft/vscode/issues/72909\n\t\t} else if (this.smallStatSize) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t(res as any).size = 1;\n\t\t} else if (this.readonly) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t(res as any).permissions = FilePermission.Readonly;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\toverride async read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst bytesRead = await super.read(fd, pos, data, offset, length);\n\n\t\tthis.totalBytesRead += bytesRead;\n\n\t\treturn bytesRead;\n\t}\n\n\toverride async readFile(resource: URI, options?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tconst res = await super.readFile(resource, options);\n\n\t\tthis.totalBytesRead += res.byteLength;\n\n\t\treturn res;\n\t}\n}\n\nDiskFileSystemProvider.configureFlushOnWrite(false); // speed up all unit tests by disabling flush on write\n\nflakySuite('Disk File Service', function () {\n\n\tconst testSchema = 'test';\n\n\tlet service: FileService;\n\tlet fileProvider: TestDiskFileSystemProvider;\n\tlet testProvider: TestDiskFileSystemProvider;\n\n\tlet testDir: string;\n\n\tconst disposables = new DisposableStore();\n\n\tsetup(async () => {\n\t\tconst logService = new NullLogService();\n\n\t\tservice = disposables.add(new FileService(logService));\n\n\t\tfileProvider = disposables.add(new TestDiskFileSystemProvider(logService));\n\t\tdisposables.add(service.registerProvider(Schemas.file, fileProvider));\n\n\t\ttestProvider = disposables.add(new TestDiskFileSystemProvider(logService));\n\t\tdisposables.add(service.registerProvider(testSchema, testProvider));\n\n\t\ttestDir = getRandomTestPath(tmpdir(), 'vsctests', 'diskfileservice');\n\n\t\tconst sourceDir = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/service').fsPath;\n\n\t\tawait Promises.copy(sourceDir, testDir, { preserveSymlinks: false });\n\t});\n\n\tteardown(() => {\n\t\tdisposables.clear();\n\n\t\treturn Promises.rm(testDir);\n\t});\n\n\ttest('createFolder', async () => {\n\t\tlet event: FileOperationEvent | undefined;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\n\t\tconst newFolderResource = URI.file(join(parent.resource.fsPath, 'newFolder'));\n\n\t\tconst newFolder = await service.createFolder(newFolderResource);\n\n\t\tassert.strictEqual(newFolder.name, 'newFolder');\n\t\tassert.strictEqual(existsSync(newFolder.resource.fsPath), true);\n\n\t\tassert.ok(event);\n\t\tassert.strictEqual(event.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event.target!.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event.target!.isDirectory, true);\n\t});\n\n\ttest('createFolder: creating multiple folders at once', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst multiFolderPaths = ['a', 'couple', 'of', 'folders'];\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\n\t\tconst newFolderResource = URI.file(join(parent.resource.fsPath, ...multiFolderPaths));\n\n\t\tconst newFolder = await service.createFolder(newFolderResource);\n\n\t\tconst lastFolderName = multiFolderPaths[multiFolderPaths.length - 1];\n\t\tassert.strictEqual(newFolder.name, lastFolderName);\n\t\tassert.strictEqual(existsSync(newFolder.resource.fsPath), true);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event!.target!.isDirectory, true);\n\t});\n\n\ttest('exists', async () => {\n\t\tlet exists = await service.exists(URI.file(testDir));\n\t\tassert.strictEqual(exists, true);\n\n\t\texists = await service.exists(URI.file(testDir + 'something'));\n\t\tassert.strictEqual(exists, false);\n\t});\n\n\ttest('resolve - file', async () => {\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver/index.html');\n\t\tconst resolved = await service.resolve(resource);\n\n\t\tassert.strictEqual(resolved.name, 'index.html');\n\t\tassert.strictEqual(resolved.isFile, true);\n\t\tassert.strictEqual(resolved.isDirectory, false);\n\t\tassert.strictEqual(resolved.readonly, false);\n\t\tassert.strictEqual(resolved.isSymbolicLink, false);\n\t\tassert.strictEqual(resolved.resource.toString(), resource.toString());\n\t\tassert.strictEqual(resolved.children, undefined);\n\t\tassert.ok(resolved.mtime! > 0);\n\t\tassert.ok(resolved.ctime! > 0);\n\t\tassert.ok(resolved.size! > 0);\n\t});\n\n\ttest('resolve - directory', async () => {\n\t\tconst testsElements = ['examples', 'other', 'index.html', 'site.css'];\n\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver');\n\t\tconst result = await service.resolve(resource);\n\n\t\tassert.ok(result);\n\t\tassert.strictEqual(result.resource.toString(), resource.toString());\n\t\tassert.strictEqual(result.name, 'resolver');\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\t\tassert.strictEqual(result.readonly, false);\n\t\tassert.ok(result.mtime! > 0);\n\t\tassert.ok(result.ctime! > 0);\n\t\tassert.strictEqual(result.children.length, testsElements.length);\n\n\t\tassert.ok(result.children.every(entry => {\n\t\t\treturn testsElements.some(name => {\n\t\t\t\treturn basename(entry.resource.fsPath) === name;\n\t\t\t});\n\t\t}));\n\n\t\tresult.children.forEach(value => {\n\t\t\tassert.ok(basename(value.resource.fsPath));\n\t\t\tif (['examples', 'other'].indexOf(basename(value.resource.fsPath)) >= 0) {\n\t\t\t\tassert.ok(value.isDirectory);\n\t\t\t\tassert.strictEqual(value.mtime, undefined);\n\t\t\t\tassert.strictEqual(value.ctime, undefined);\n\t\t\t} else if (basename(value.resource.fsPath) === 'index.html') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.strictEqual(value.mtime, undefined);\n\t\t\t\tassert.strictEqual(value.ctime, undefined);\n\t\t\t} else if (basename(value.resource.fsPath) === 'site.css') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.strictEqual(value.mtime, undefined);\n\t\t\t\tassert.strictEqual(value.ctime, undefined);\n\t\t\t} else {\n\t\t\t\tassert.fail('Unexpected value ' + basename(value.resource.fsPath));\n\t\t\t}\n\t\t});\n\t});\n\n\ttest('resolve - directory - with metadata', async () => {\n\t\tconst testsElements = ['examples', 'other', 'index.html', 'site.css'];\n\n\t\tconst result = await service.resolve(FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver'), { resolveMetadata: true });\n\n\t\tassert.ok(result);\n\t\tassert.strictEqual(result.name, 'resolver');\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\t\tassert.ok(result.mtime > 0);\n\t\tassert.ok(result.ctime > 0);\n\t\tassert.strictEqual(result.children.length, testsElements.length);\n\n\t\tassert.ok(result.children.every(entry => {\n\t\t\treturn testsElements.some(name => {\n\t\t\t\treturn basename(entry.resource.fsPath) === name;\n\t\t\t});\n\t\t}));\n\n\t\tassert.ok(result.children.every(entry => entry.etag.length > 0));\n\n\t\tresult.children.forEach(value => {\n\t\t\tassert.ok(basename(value.resource.fsPath));\n\t\t\tif (['examples', 'other'].indexOf(basename(value.resource.fsPath)) >= 0) {\n\t\t\t\tassert.ok(value.isDirectory);\n\t\t\t\tassert.ok(value.mtime > 0);\n\t\t\t\tassert.ok(value.ctime > 0);\n\t\t\t} else if (basename(value.resource.fsPath) === 'index.html') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.ok(value.mtime > 0);\n\t\t\t\tassert.ok(value.ctime > 0);\n\t\t\t} else if (basename(value.resource.fsPath) === 'site.css') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.ok(value.mtime > 0);\n\t\t\t\tassert.ok(value.ctime > 0);\n\t\t\t} else {\n\t\t\t\tassert.fail('Unexpected value ' + basename(value.resource.fsPath));\n\t\t\t}\n\t\t});\n\t});\n\n\ttest('resolve - directory with resolveTo', async () => {\n\t\tconst resolved = await service.resolve(URI.file(testDir), { resolveTo: [URI.file(join(testDir, 'deep'))] });\n\t\tassert.strictEqual(resolved.children!.length, 8);\n\n\t\tconst deep = (getByName(resolved, 'deep')!);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\t});\n\n\ttest('resolve - directory - resolveTo single directory', async () => {\n\t\tconst resolverFixturesPath = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver').fsPath;\n\t\tconst result = await service.resolve(URI.file(resolverFixturesPath), { resolveTo: [URI.file(join(resolverFixturesPath, 'other/deep'))] });\n\n\t\tassert.ok(result);\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\n\t\tconst children = result.children;\n\t\tassert.strictEqual(children.length, 4);\n\n\t\tconst other = getByName(result, 'other');\n\t\tassert.ok(other);\n\t\tassert.ok(other.children!.length > 0);\n\n\t\tconst deep = getByName(other, 'deep');\n\t\tassert.ok(deep);\n\t\tassert.ok(deep.children!.length > 0);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\t});\n\n\ttest('resolve directory - resolveTo multiple directories', () => {\n\t\treturn testResolveDirectoryWithTarget(false);\n\t});\n\n\ttest('resolve directory - resolveTo with a URI that has query parameter (https://github.com/microsoft/vscode/issues/128151)', () => {\n\t\treturn testResolveDirectoryWithTarget(true);\n\t});\n\n\tasync function testResolveDirectoryWithTarget(withQueryParam: boolean): Promise<void> {\n\t\tconst resolverFixturesPath = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver').fsPath;\n\t\tconst result = await service.resolve(URI.file(resolverFixturesPath).with({ query: withQueryParam ? 'test' : undefined }), {\n\t\t\tresolveTo: [\n\t\t\t\tURI.file(join(resolverFixturesPath, 'other/deep')).with({ query: withQueryParam ? 'test' : undefined }),\n\t\t\t\tURI.file(join(resolverFixturesPath, 'examples')).with({ query: withQueryParam ? 'test' : undefined })\n\t\t\t]\n\t\t});\n\n\t\tassert.ok(result);\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\n\t\tconst children = result.children;\n\t\tassert.strictEqual(children.length, 4);\n\n\t\tconst other = getByName(result, 'other');\n\t\tassert.ok(other);\n\t\tassert.ok(other.children!.length > 0);\n\n\t\tconst deep = getByName(other, 'deep');\n\t\tassert.ok(deep);\n\t\tassert.ok(deep.children!.length > 0);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\n\t\tconst examples = getByName(result, 'examples');\n\t\tassert.ok(examples);\n\t\tassert.ok(examples.children!.length > 0);\n\t\tassert.strictEqual(examples.children!.length, 4);\n\t}\n\n\ttest('resolve directory - resolveSingleChildFolders', async () => {\n\t\tconst resolverFixturesPath = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver/other').fsPath;\n\t\tconst result = await service.resolve(URI.file(resolverFixturesPath), { resolveSingleChildDescendants: true });\n\n\t\tassert.ok(result);\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\n\t\tconst children = result.children;\n\t\tassert.strictEqual(children.length, 1);\n\n\t\tconst deep = getByName(result, 'deep');\n\t\tassert.ok(deep);\n\t\tassert.ok(deep.children!.length > 0);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\t});\n\n\ttest('resolves', async () => {\n\t\tconst res = await service.resolveAll([\n\t\t\t{ resource: URI.file(testDir), options: { resolveTo: [URI.file(join(testDir, 'deep'))] } },\n\t\t\t{ resource: URI.file(join(testDir, 'deep')) }\n\t\t]);\n\n\t\tconst r1 = (res[0].stat!);\n\t\tassert.strictEqual(r1.children!.length, 8);\n\n\t\tconst deep = (getByName(r1, 'deep')!);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\n\t\tconst r2 = (res[1].stat!);\n\t\tassert.strictEqual(r2.children!.length, 4);\n\t\tassert.strictEqual(r2.name, 'deep');\n\t});\n\n\ttest('resolve / realpath - folder symbolic link', async () => {\n\t\tconst link = URI.file(join(testDir, 'deep-link'));\n\t\tawait promises.symlink(join(testDir, 'deep'), link.fsPath, 'junction');\n\n\t\tconst resolved = await service.resolve(link);\n\t\tassert.strictEqual(resolved.children!.length, 4);\n\t\tassert.strictEqual(resolved.isDirectory, true);\n\t\tassert.strictEqual(resolved.isSymbolicLink, true);\n\n\t\tconst realpath = await service.realpath(link);\n\t\tassert.ok(realpath);\n\t\tassert.strictEqual(basename(realpath.fsPath), 'deep');\n\t});\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('resolve - file symbolic link', async () => {\n\t\tconst link = URI.file(join(testDir, 'lorem.txt-linked'));\n\t\tawait promises.symlink(join(testDir, 'lorem.txt'), link.fsPath);\n\n\t\tconst resolved = await service.resolve(link);\n\t\tassert.strictEqual(resolved.isDirectory, false);\n\t\tassert.strictEqual(resolved.isSymbolicLink, true);\n\t});\n\n\ttest('resolve - symbolic link pointing to nonexistent file does not break', async () => {\n\t\tawait promises.symlink(join(testDir, 'foo'), join(testDir, 'bar'), 'junction');\n\n\t\tconst resolved = await service.resolve(URI.file(testDir));\n\t\tassert.strictEqual(resolved.isDirectory, true);\n\t\tassert.strictEqual(resolved.children!.length, 9);\n\n\t\tconst resolvedLink = resolved.children?.find(child => child.name === 'bar' && child.isSymbolicLink);\n\t\tassert.ok(resolvedLink);\n\n\t\tassert.ok(!resolvedLink?.isDirectory);\n\t\tassert.ok(!resolvedLink?.isFile);\n\t});\n\n\ttest('stat - file', async () => {\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver/index.html');\n\t\tconst resolved = await service.stat(resource);\n\n\t\tassert.strictEqual(resolved.name, 'index.html');\n\t\tassert.strictEqual(resolved.isFile, true);\n\t\tassert.strictEqual(resolved.isDirectory, false);\n\t\tassert.strictEqual(resolved.readonly, false);\n\t\tassert.strictEqual(resolved.isSymbolicLink, false);\n\t\tassert.strictEqual(resolved.resource.toString(), resource.toString());\n\t\tassert.ok(resolved.mtime > 0);\n\t\tassert.ok(resolved.ctime > 0);\n\t\tassert.ok(resolved.size > 0);\n\t});\n\n\ttest('stat - directory', async () => {\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver');\n\t\tconst result = await service.stat(resource);\n\n\t\tassert.ok(result);\n\t\tassert.strictEqual(result.resource.toString(), resource.toString());\n\t\tassert.strictEqual(result.name, 'resolver');\n\t\tassert.ok(result.isDirectory);\n\t\tassert.strictEqual(result.readonly, false);\n\t\tassert.ok(result.mtime > 0);\n\t\tassert.ok(result.ctime > 0);\n\t});\n\n\ttest('deleteFile (non recursive)', async () => {\n\t\treturn testDeleteFile(false, false);\n\t});\n\n\ttest('deleteFile (recursive)', async () => {\n\t\treturn testDeleteFile(false, true);\n\t});\n\n\t(isLinux /* trash is unreliable on Linux */ ? test.skip : test)('deleteFile (useTrash)', async () => {\n\t\treturn testDeleteFile(true, false);\n\t});\n\n\tasync function testDeleteFile(useTrash: boolean, recursive: boolean): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst resource = URI.file(join(testDir, 'deep', 'conway.js'));\n\t\tconst source = await service.resolve(resource);\n\n\t\tassert.strictEqual(await service.canDelete(source.resource, { useTrash, recursive }), true);\n\t\tawait service.del(source.resource, { useTrash, recursive });\n\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), false);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.del(source.resource, { useTrash, recursive });\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual((<FileOperationError>error).fileOperationResult, FileOperationResult.FILE_NOT_FOUND);\n\t}\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('deleteFile - symbolic link (exists)', async () => {\n\t\tconst target = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst link = URI.file(join(testDir, 'lorem.txt-linked'));\n\t\tawait promises.symlink(target.fsPath, link.fsPath);\n\n\t\tconst source = await service.resolve(link);\n\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tassert.strictEqual(await service.canDelete(source.resource), true);\n\t\tawait service.del(source.resource);\n\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), false);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, link.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\n\t\tassert.strictEqual(existsSync(target.fsPath), true); // target the link pointed to is never deleted\n\t});\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('deleteFile - symbolic link (pointing to nonexistent file)', async () => {\n\t\tconst target = URI.file(join(testDir, 'foo'));\n\t\tconst link = URI.file(join(testDir, 'bar'));\n\t\tawait promises.symlink(target.fsPath, link.fsPath);\n\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tassert.strictEqual(await service.canDelete(link), true);\n\t\tawait service.del(link);\n\n\t\tassert.strictEqual(existsSync(link.fsPath), false);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, link.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\t});\n\n\ttest('deleteFolder (recursive)', async () => {\n\t\treturn testDeleteFolderRecursive(false, false);\n\t});\n\n\ttest('deleteFolder (recursive, atomic)', async () => {\n\t\treturn testDeleteFolderRecursive(false, { postfix: '.vsctmp' });\n\t});\n\n\t(isLinux /* trash is unreliable on Linux */ ? test.skip : test)('deleteFolder (recursive, useTrash)', async () => {\n\t\treturn testDeleteFolderRecursive(true, false);\n\t});\n\n\tasync function testDeleteFolderRecursive(useTrash: boolean, atomic: IFileAtomicOptions | false): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst resource = URI.file(join(testDir, 'deep'));\n\t\tconst source = await service.resolve(resource);\n\n\t\tassert.strictEqual(await service.canDelete(source.resource, { recursive: true, useTrash, atomic }), true);\n\t\tawait service.del(source.resource, { recursive: true, useTrash, atomic });\n\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\t}\n\n\ttest('deleteFolder (non recursive)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'deep'));\n\t\tconst source = await service.resolve(resource);\n\n\t\tassert.ok((await service.canDelete(source.resource)) instanceof Error);\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.del(source.resource);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('deleteFolder empty folder (recursive)', () => {\n\t\treturn testDeleteEmptyFolder(true);\n\t});\n\n\ttest('deleteFolder empty folder (non recursive)', () => {\n\t\treturn testDeleteEmptyFolder(false);\n\t});\n\n\tasync function testDeleteEmptyFolder(recursive: boolean): Promise<void> {\n\t\tconst { resource } = await service.createFolder(URI.file(join(testDir, 'deep', 'empty')));\n\n\t\tawait service.del(resource, { recursive });\n\n\t\tassert.strictEqual(await service.exists(resource), false);\n\t}\n\n\ttest('move', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, 'index.html'));\n\t\tconst sourceContents = readFileSync(source.fsPath);\n\n\t\tconst target = URI.file(join(dirname(source.fsPath), 'other.html'));\n\n\t\tassert.strictEqual(await service.canMove(source, target), true);\n\t\tconst renamed = await service.move(source, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\tconst targetContents = readFileSync(target.fsPath);\n\n\t\tassert.strictEqual(sourceContents.byteLength, targetContents.byteLength);\n\t\tassert.strictEqual(sourceContents.toString(), targetContents.toString());\n\t});\n\n\ttest('move - across providers (buffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers (unbuffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers (buffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers (unbuffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers - large (buffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\ttest('move - across providers - large (unbuffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\ttest('move - across providers - large (buffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\ttest('move - across providers - large (unbuffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\tasync function testMoveAcrossProviders(sourceFile = 'index.html'): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, sourceFile));\n\t\tconst sourceContents = readFileSync(source.fsPath);\n\n\t\tconst target = URI.file(join(dirname(source.fsPath), 'other.html')).with({ scheme: testSchema });\n\n\t\tassert.strictEqual(await service.canMove(source, target), true);\n\t\tconst renamed = await service.move(source, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\tconst targetContents = readFileSync(target.fsPath);\n\n\t\tassert.strictEqual(sourceContents.byteLength, targetContents.byteLength);\n\t\tassert.strictEqual(sourceContents.toString(), targetContents.toString());\n\t}\n\n\ttest('move - multi folder', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst multiFolderPaths = ['a', 'couple', 'of', 'folders'];\n\t\tconst renameToPath = join(...multiFolderPaths, 'other.html');\n\n\t\tconst source = URI.file(join(testDir, 'index.html'));\n\n\t\tassert.strictEqual(await service.canMove(source, URI.file(join(dirname(source.fsPath), renameToPath))), true);\n\t\tconst renamed = await service.move(source, URI.file(join(dirname(source.fsPath), renameToPath)));\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\t});\n\n\ttest('move - directory', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, 'deep'));\n\n\t\tassert.strictEqual(await service.canMove(source, URI.file(join(dirname(source.fsPath), 'deeper'))), true);\n\t\tconst renamed = await service.move(source, URI.file(join(dirname(source.fsPath), 'deeper')));\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\t});\n\n\ttest('move - directory - across providers (buffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\ttest('move - directory - across providers (unbuffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\ttest('move - directory - across providers (buffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\ttest('move - directory - across providers (unbuffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\tasync function testMoveFolderAcrossProviders(): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, 'deep'));\n\t\tconst sourceChildren = readdirSync(source.fsPath);\n\n\t\tconst target = URI.file(join(dirname(source.fsPath), 'deeper')).with({ scheme: testSchema });\n\n\t\tassert.strictEqual(await service.canMove(source, target), true);\n\t\tconst renamed = await service.move(source, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\tconst targetChildren = readdirSync(target.fsPath);\n\t\tassert.strictEqual(sourceChildren.length, targetChildren.length);\n\t\tfor (let i = 0; i < sourceChildren.length; i++) {\n\t\t\tassert.strictEqual(sourceChildren[i], targetChildren[i]);\n\t\t}\n\t}\n\n\ttest('move - MIX CASE', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tconst renamedResource = URI.file(join(dirname(source.resource.fsPath), 'INDEX.html'));\n\t\tassert.strictEqual(await service.canMove(source.resource, renamedResource), true);\n\t\tlet renamed = await service.move(source.resource, renamedResource);\n\n\t\tassert.strictEqual(existsSync(renamedResource.fsPath), true);\n\t\tassert.strictEqual(basename(renamedResource.fsPath), 'INDEX.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamedResource.fsPath);\n\n\t\trenamed = await service.resolve(renamedResource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, renamed.size);\n\t});\n\n\ttest('move - same file', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tassert.strictEqual(await service.canMove(source.resource, URI.file(source.resource.fsPath)), true);\n\t\tlet renamed = await service.move(source.resource, URI.file(source.resource.fsPath));\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(basename(renamed.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\trenamed = await service.resolve(renamed.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, renamed.size);\n\t});\n\n\ttest('move - same file #2', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tconst targetParent = URI.file(testDir);\n\t\tconst target = targetParent.with({ path: posix.join(targetParent.path, posix.basename(source.resource.path)) });\n\n\t\tassert.strictEqual(await service.canMove(source.resource, target), true);\n\t\tlet renamed = await service.move(source.resource, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(basename(renamed.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\trenamed = await service.resolve(renamed.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, renamed.size);\n\t});\n\n\ttest('move - source parent of target', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tassert.ok((await service.canMove(URI.file(testDir), URI.file(join(testDir, 'binary.txt'))) instanceof Error));\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.move(URI.file(testDir), URI.file(join(testDir, 'binary.txt')));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.ok(!event!);\n\n\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(originalSize, source.size);\n\t});\n\n\ttest('move - FILE_MOVE_CONFLICT', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tassert.ok((await service.canMove(source.resource, URI.file(join(testDir, 'binary.txt'))) instanceof Error));\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.move(source.resource, URI.file(join(testDir, 'binary.txt')));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_MOVE_CONFLICT);\n\t\tassert.ok(!event!);\n\n\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(originalSize, source.size);\n\t});\n\n\ttest('move - overwrite folder with file', async () => {\n\t\tlet createEvent: FileOperationEvent;\n\t\tlet moveEvent: FileOperationEvent;\n\t\tlet deleteEvent: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => {\n\t\t\tif (e.operation === FileOperation.CREATE) {\n\t\t\t\tcreateEvent = e;\n\t\t\t} else if (e.operation === FileOperation.DELETE) {\n\t\t\t\tdeleteEvent = e;\n\t\t\t} else if (e.operation === FileOperation.MOVE) {\n\t\t\t\tmoveEvent = e;\n\t\t\t}\n\t\t}));\n\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\t\tconst folderResource = URI.file(join(parent.resource.fsPath, 'conway.js'));\n\t\tconst f = await service.createFolder(folderResource);\n\t\tconst source = URI.file(join(testDir, 'deep', 'conway.js'));\n\n\t\tassert.strictEqual(await service.canMove(source, f.resource, true), true);\n\t\tconst moved = await service.move(source, f.resource, true);\n\n\t\tassert.strictEqual(existsSync(moved.resource.fsPath), true);\n\t\tassert.ok(statSync(moved.resource.fsPath).isFile);\n\t\tassert.ok(createEvent!);\n\t\tassert.ok(deleteEvent!);\n\t\tassert.ok(moveEvent!);\n\t\tassert.strictEqual(moveEvent!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(moveEvent!.target!.resource.fsPath, moved.resource.fsPath);\n\t\tassert.strictEqual(deleteEvent!.resource.fsPath, folderResource.fsPath);\n\t});\n\n\ttest('copy', async () => {\n\t\tawait doTestCopy();\n\t});\n\n\ttest('copy - unbuffered (FileSystemProviderCapabilities.FileReadWrite)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\tawait doTestCopy();\n\t});\n\n\ttest('copy - unbuffered large (FileSystemProviderCapabilities.FileReadWrite)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\tawait doTestCopy('lorem.txt');\n\t});\n\n\ttest('copy - buffered (FileSystemProviderCapabilities.FileOpenReadWriteClose)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\tawait doTestCopy();\n\t});\n\n\ttest('copy - buffered large (FileSystemProviderCapabilities.FileOpenReadWriteClose)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\tawait doTestCopy('lorem.txt');\n\t});\n\n\tfunction setCapabilities(provider: TestDiskFileSystemProvider, capabilities: FileSystemProviderCapabilities): void {\n\t\tprovider.capabilities = capabilities;\n\t\tif (isLinux) {\n\t\t\tprovider.capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t}\n\t}\n\n\tasync function doTestCopy(sourceName: string = 'index.html') {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, sourceName)));\n\t\tconst target = URI.file(join(testDir, 'other.html'));\n\n\t\tassert.strictEqual(await service.canCopy(source.resource, target), true);\n\t\tconst copied = await service.copy(source.resource, target);\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), true);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, copied.resource.fsPath);\n\n\t\tconst sourceContents = readFileSync(source.resource.fsPath);\n\t\tconst targetContents = readFileSync(target.fsPath);\n\n\t\tassert.strictEqual(sourceContents.byteLength, targetContents.byteLength);\n\t\tassert.strictEqual(sourceContents.toString(), targetContents.toString());\n\t}\n\n\ttest('copy - overwrite folder with file', async () => {\n\t\tlet createEvent: FileOperationEvent;\n\t\tlet copyEvent: FileOperationEvent;\n\t\tlet deleteEvent: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => {\n\t\t\tif (e.operation === FileOperation.CREATE) {\n\t\t\t\tcreateEvent = e;\n\t\t\t} else if (e.operation === FileOperation.DELETE) {\n\t\t\t\tdeleteEvent = e;\n\t\t\t} else if (e.operation === FileOperation.COPY) {\n\t\t\t\tcopyEvent = e;\n\t\t\t}\n\t\t}));\n\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\t\tconst folderResource = URI.file(join(parent.resource.fsPath, 'conway.js'));\n\t\tconst f = await service.createFolder(folderResource);\n\t\tconst source = URI.file(join(testDir, 'deep', 'conway.js'));\n\n\t\tassert.strictEqual(await service.canCopy(source, f.resource, true), true);\n\t\tconst copied = await service.copy(source, f.resource, true);\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.ok(statSync(copied.resource.fsPath).isFile);\n\t\tassert.ok(createEvent!);\n\t\tassert.ok(deleteEvent!);\n\t\tassert.ok(copyEvent!);\n\t\tassert.strictEqual(copyEvent!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(copyEvent!.target!.resource.fsPath, copied.resource.fsPath);\n\t\tassert.strictEqual(deleteEvent!.resource.fsPath, folderResource.fsPath);\n\t});\n\n\ttest('copy - MIX CASE same target - no overwrite', async () => {\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tconst target = URI.file(join(dirname(source.resource.fsPath), 'INDEX.html'));\n\n\t\tconst canCopy = await service.canCopy(source.resource, target);\n\n\t\tlet error;\n\t\tlet copied: IFileStatWithMetadata;\n\t\ttry {\n\t\t\tcopied = await service.copy(source.resource, target);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tif (isLinux) {\n\t\t\tassert.ok(!error);\n\t\t\tassert.strictEqual(canCopy, true);\n\n\t\t\tassert.strictEqual(existsSync(copied!.resource.fsPath), true);\n\t\t\tassert.ok(readdirSync(testDir).some(f => f === 'INDEX.html'));\n\t\t\tassert.strictEqual(source.size, copied!.size);\n\t\t} else {\n\t\t\tassert.ok(error);\n\t\t\tassert.ok(canCopy instanceof Error);\n\n\t\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\t\tassert.strictEqual(originalSize, source.size);\n\t\t}\n\t});\n\n\ttest('copy - MIX CASE same target - overwrite', async () => {\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tconst target = URI.file(join(dirname(source.resource.fsPath), 'INDEX.html'));\n\n\t\tconst canCopy = await service.canCopy(source.resource, target, true);\n\n\t\tlet error;\n\t\tlet copied: IFileStatWithMetadata;\n\t\ttry {\n\t\t\tcopied = await service.copy(source.resource, target, true);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tif (isLinux) {\n\t\t\tassert.ok(!error);\n\t\t\tassert.strictEqual(canCopy, true);\n\n\t\t\tassert.strictEqual(existsSync(copied!.resource.fsPath), true);\n\t\t\tassert.ok(readdirSync(testDir).some(f => f === 'INDEX.html'));\n\t\t\tassert.strictEqual(source.size, copied!.size);\n\t\t} else {\n\t\t\tassert.ok(error);\n\t\t\tassert.ok(canCopy instanceof Error);\n\n\t\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\t\tassert.strictEqual(originalSize, source.size);\n\t\t}\n\t});\n\n\ttest('copy - MIX CASE different target - overwrite', async () => {\n\t\tconst source1 = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source1.size > 0);\n\n\t\tconst renamed = await service.move(source1.resource, URI.file(join(dirname(source1.resource.fsPath), 'CONWAY.js')));\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.ok(readdirSync(testDir).some(f => f === 'CONWAY.js'));\n\t\tassert.strictEqual(source1.size, renamed.size);\n\n\t\tconst source2 = await service.resolve(URI.file(join(testDir, 'deep', 'conway.js')), { resolveMetadata: true });\n\t\tconst target = URI.file(join(testDir, basename(source2.resource.path)));\n\n\t\tassert.strictEqual(await service.canCopy(source2.resource, target, true), true);\n\t\tconst res = await service.copy(source2.resource, target, true);\n\t\tassert.strictEqual(existsSync(res.resource.fsPath), true);\n\t\tassert.ok(readdirSync(testDir).some(f => f === 'conway.js'));\n\t\tassert.strictEqual(source2.size, res.size);\n\t});\n\n\ttest('copy - same file', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tassert.strictEqual(await service.canCopy(source.resource, URI.file(source.resource.fsPath)), true);\n\t\tlet copied = await service.copy(source.resource, URI.file(source.resource.fsPath));\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.strictEqual(basename(copied.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, copied.resource.fsPath);\n\n\t\tcopied = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, copied.size);\n\t});\n\n\ttest('copy - same file #2', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tconst targetParent = URI.file(testDir);\n\t\tconst target = targetParent.with({ path: posix.join(targetParent.path, posix.basename(source.resource.path)) });\n\n\t\tassert.strictEqual(await service.canCopy(source.resource, URI.file(target.fsPath)), true);\n\t\tlet copied = await service.copy(source.resource, URI.file(target.fsPath));\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.strictEqual(basename(copied.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, copied.resource.fsPath);\n\n\t\tcopied = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, copied.size);\n\t});\n\n\ttest('cloneFile - basics', () => {\n\t\treturn testCloneFile();\n\t});\n\n\ttest('cloneFile - via copy capability', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileFolderCopy);\n\n\t\treturn testCloneFile();\n\t});\n\n\ttest('cloneFile - via pipe', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testCloneFile();\n\t});\n\n\tasync function testCloneFile(): Promise<void> {\n\t\tconst source1 = URI.file(join(testDir, 'index.html'));\n\t\tconst source1Size = (await service.resolve(source1, { resolveMetadata: true })).size;\n\n\t\tconst source2 = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst source2Size = (await service.resolve(source2, { resolveMetadata: true })).size;\n\n\t\tconst targetParent = URI.file(testDir);\n\n\t\t// same path is a no-op\n\t\tawait service.cloneFile(source1, source1);\n\n\t\t// simple clone to existing parent folder path\n\t\tconst target1 = targetParent.with({ path: posix.join(targetParent.path, `${posix.basename(source1.path)}-clone`) });\n\n\t\tawait service.cloneFile(source1, URI.file(target1.fsPath));\n\n\t\tassert.strictEqual(existsSync(target1.fsPath), true);\n\t\tassert.strictEqual(basename(target1.fsPath), 'index.html-clone');\n\n\t\tlet target1Size = (await service.resolve(target1, { resolveMetadata: true })).size;\n\n\t\tassert.strictEqual(source1Size, target1Size);\n\n\t\t// clone to same path overwrites\n\t\tawait service.cloneFile(source2, URI.file(target1.fsPath));\n\n\t\ttarget1Size = (await service.resolve(target1, { resolveMetadata: true })).size;\n\n\t\tassert.strictEqual(source2Size, target1Size);\n\t\tassert.notStrictEqual(source1Size, target1Size);\n\n\t\t// clone creates missing folders ad-hoc\n\t\tconst target2 = targetParent.with({ path: posix.join(targetParent.path, 'foo', 'bar', `${posix.basename(source1.path)}-clone`) });\n\n\t\tawait service.cloneFile(source1, URI.file(target2.fsPath));\n\n\t\tassert.strictEqual(existsSync(target2.fsPath), true);\n\t\tassert.strictEqual(basename(target2.fsPath), 'index.html-clone');\n\n\t\tconst target2Size = (await service.resolve(target2, { resolveMetadata: true })).size;\n\n\t\tassert.strictEqual(source1Size, target2Size);\n\t}\n\n\ttest('readFile - small file - default', () => {\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - buffered', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - buffered / readonly', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - unbuffered / readonly', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - streamed / readonly', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - large file - default', async () => {\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - large file - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - large file - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - large file - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - atomic (emulated on service level)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')), { atomic: true });\n\t});\n\n\ttest('readFile - atomic (natively supported)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite & FileSystemProviderCapabilities.FileAtomicRead);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')), { atomic: true });\n\t});\n\n\tasync function testReadFile(resource: URI, options?: IReadFileOptions): Promise<void> {\n\t\tconst content = await service.readFile(resource, options);\n\n\t\tassert.strictEqual(content.value.toString(), readFileSync(resource.fsPath).toString());\n\t}\n\n\ttest('readFileStream - small file - default', () => {\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFileStream - small file - buffered', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFileStream - small file - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFileStream - small file - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\tasync function testReadFileStream(resource: URI): Promise<void> {\n\t\tconst content = await service.readFileStream(resource);\n\n\t\tassert.strictEqual((await streamToBuffer(content.value)).toString(), readFileSync(resource.fsPath).toString());\n\t}\n\n\ttest('readFile - Files are intermingled #38331 - default', async () => {\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\ttest('readFile - Files are intermingled #38331 - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\ttest('readFile - Files are intermingled #38331 - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\ttest('readFile - Files are intermingled #38331 - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\tasync function testFilesNotIntermingled() {\n\t\tconst resource1 = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst resource2 = URI.file(join(testDir, 'some_utf16le.css'));\n\n\t\t// load in sequence and keep data\n\t\tconst value1 = await service.readFile(resource1);\n\t\tconst value2 = await service.readFile(resource2);\n\n\t\t// load in parallel in expect the same result\n\t\tconst result = await Promise.all([\n\t\t\tservice.readFile(resource1),\n\t\t\tservice.readFile(resource2)\n\t\t]);\n\n\t\tassert.strictEqual(result[0].value.toString(), value1.value.toString());\n\t\tassert.strictEqual(result[1].value.toString(), value2.value.toString());\n\t}\n\n\ttest('readFile - from position (ASCII) - default', async () => {\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\ttest('readFile - from position (ASCII) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\ttest('readFile - from position (ASCII) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\ttest('readFile - from position (ASCII) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\tasync function testReadFileFromPositionAscii() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst contents = await service.readFile(resource, { position: 6 });\n\n\t\tassert.strictEqual(contents.value.toString(), 'File');\n\t}\n\n\ttest('readFile - from position (with umlaut) - default', async () => {\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\ttest('readFile - from position (with umlaut) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\ttest('readFile - from position (with umlaut) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\ttest('readFile - from position (with umlaut) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\tasync function testReadFileFromPositionUmlaut() {\n\t\tconst resource = URI.file(join(testDir, 'small_umlaut.txt'));\n\n\t\tconst contents = await service.readFile(resource, { position: Buffer.from('Small File with ').length });\n\n\t\tassert.strictEqual(contents.value.toString(), 'mlaut');\n\t}\n\n\ttest('readFile - 3 bytes (ASCII) - default', async () => {\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\ttest('readFile - 3 bytes (ASCII) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\ttest('readFile - 3 bytes (ASCII) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\ttest('readFile - 3 bytes (ASCII) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\tasync function testReadThreeBytesFromFile() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst contents = await service.readFile(resource, { length: 3 });\n\n\t\tassert.strictEqual(contents.value.toString(), 'Sma');\n\t}\n\n\ttest('readFile - 20000 bytes (large) - default', async () => {\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 20000 bytes (large) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 20000 bytes (large) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 20000 bytes (large) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - default', async () => {\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\tasync function readLargeFileWithLength(length: number) {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst contents = await service.readFile(resource, { length });\n\n\t\tassert.strictEqual(contents.value.byteLength, length);\n\t}\n\n\ttest('readFile - FILE_IS_DIRECTORY', async () => {\n\t\tconst resource = URI.file(join(testDir, 'deep'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_IS_DIRECTORY);\n\t});\n\n\t(isWindows /* error code does not seem to be supported on windows */ ? test.skip : test)('readFile - FILE_NOT_DIRECTORY', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt', 'file.txt'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_NOT_DIRECTORY);\n\t});\n\n\ttest('readFile - FILE_NOT_FOUND', async () => {\n\t\tconst resource = URI.file(join(testDir, '404.html'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_NOT_FOUND);\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - default', async () => {\n\t\treturn testNotModifiedSince();\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testNotModifiedSince();\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testNotModifiedSince();\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testNotModifiedSince();\n\t});\n\n\tasync function testNotModifiedSince() {\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tconst contents = await service.readFile(resource);\n\t\tfileProvider.totalBytesRead = 0;\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource, { etag: contents.etag });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_NOT_MODIFIED_SINCE);\n\t\tassert.ok(error instanceof NotModifiedSinceFileOperationError && error.stat);\n\t\tassert.strictEqual(fileProvider.totalBytesRead, 0);\n\t}\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE does not fire wrongly - https://github.com/microsoft/vscode/issues/72909', async () => {\n\t\tfileProvider.setInvalidStatSize(true);\n\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tawait service.readFile(resource);\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource, { etag: undefined });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(!error);\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - default', async () => {\n\t\treturn testFileTooLarge();\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testFileTooLarge();\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testFileTooLarge();\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testFileTooLarge();\n\t});\n\n\tasync function testFileTooLarge() {\n\t\tawait doTestFileTooLarge(false);\n\n\t\t// Also test when the stat size is wrong\n\t\tfileProvider.setSmallStatSize(true);\n\t\treturn doTestFileTooLarge(true);\n\t}\n\n\tasync function doTestFileTooLarge(statSizeWrong: boolean) {\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource, { limits: { size: 10 } });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tif (!statSizeWrong) {\n\t\t\tassert.ok(error instanceof TooLargeFileOperationError);\n\t\t\tassert.ok(typeof error.size === 'number');\n\t\t}\n\t\tassert.strictEqual(error!.fileOperationResult, FileOperationResult.FILE_TOO_LARGE);\n\t}\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('readFile - dangling symbolic link - https://github.com/microsoft/vscode/issues/116049', async () => {\n\t\tconst link = URI.file(join(testDir, 'small.js-link'));\n\t\tawait promises.symlink(join(testDir, 'small.js'), link.fsPath);\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(link);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('createFile', async () => {\n\t\treturn assertCreateFile(contents => VSBuffer.fromString(contents));\n\t});\n\n\ttest('createFile (readable)', async () => {\n\t\treturn assertCreateFile(contents => bufferToReadable(VSBuffer.fromString(contents)));\n\t});\n\n\ttest('createFile (stream)', async () => {\n\t\treturn assertCreateFile(contents => bufferToStream(VSBuffer.fromString(contents)));\n\t});\n\n\tasync function assertCreateFile(converter: (content: string) => VSBuffer | VSBufferReadable | VSBufferReadableStream): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst contents = 'Hello World';\n\t\tconst resource = URI.file(join(testDir, 'test.txt'));\n\n\t\tassert.strictEqual(await service.canCreateFile(resource), true);\n\t\tconst fileStat = await service.createFile(resource, converter(contents));\n\t\tassert.strictEqual(fileStat.name, 'test.txt');\n\t\tassert.strictEqual(existsSync(fileStat.resource.fsPath), true);\n\t\tassert.strictEqual(readFileSync(fileStat.resource.fsPath).toString(), contents);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, resource.fsPath);\n\t}\n\n\ttest('createFile (does not overwrite by default)', async () => {\n\t\tconst contents = 'Hello World';\n\t\tconst resource = URI.file(join(testDir, 'test.txt'));\n\n\t\twriteFileSync(resource.fsPath, ''); // create file\n\n\t\tassert.ok((await service.canCreateFile(resource)) instanceof Error);\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.createFile(resource, VSBuffer.fromString(contents));\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('createFile (allows to overwrite existing)', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst contents = 'Hello World';\n\t\tconst resource = URI.file(join(testDir, 'test.txt'));\n\n\t\twriteFileSync(resource.fsPath, ''); // create file\n\n\t\tassert.strictEqual(await service.canCreateFile(resource, { overwrite: true }), true);\n\t\tconst fileStat = await service.createFile(resource, VSBuffer.fromString(contents), { overwrite: true });\n\t\tassert.strictEqual(fileStat.name, 'test.txt');\n\t\tassert.strictEqual(existsSync(fileStat.resource.fsPath), true);\n\t\tassert.strictEqual(readFileSync(fileStat.resource.fsPath).toString(), contents);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, resource.fsPath);\n\t});\n\n\ttest('writeFile - default', async () => {\n\t\treturn testWriteFile(false);\n\t});\n\n\ttest('writeFile - flush on write', async () => {\n\t\tDiskFileSystemProvider.configureFlushOnWrite(true);\n\t\ttry {\n\t\t\treturn await testWriteFile(false);\n\t\t} finally {\n\t\t\tDiskFileSystemProvider.configureFlushOnWrite(false);\n\t\t}\n\t});\n\n\ttest('writeFile - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFile(false);\n\t});\n\n\ttest('writeFile - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFile(false);\n\t});\n\n\ttest('writeFile - default (atomic)', async () => {\n\t\treturn testWriteFile(true);\n\t});\n\n\ttest('writeFile - flush on write (atomic)', async () => {\n\t\tDiskFileSystemProvider.configureFlushOnWrite(true);\n\t\ttry {\n\t\t\treturn await testWriteFile(true);\n\t\t} finally {\n\t\t\tDiskFileSystemProvider.configureFlushOnWrite(false);\n\t\t}\n\t});\n\n\ttest('writeFile - buffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\tlet e;\n\t\ttry {\n\t\t\tawait testWriteFile(true);\n\t\t} catch (error) {\n\t\t\te = error;\n\t\t}\n\n\t\tassert.ok(e);\n\t});\n\n\ttest('writeFile - unbuffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\treturn testWriteFile(true);\n\t});\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('writeFile - atomic writing does not break symlinks', async () => {\n\t\tconst link = URI.file(join(testDir, 'lorem.txt-linked'));\n\t\tawait promises.symlink(join(testDir, 'lorem.txt'), link.fsPath);\n\n\t\tconst content = 'Updates to the lorem file';\n\t\tawait service.writeFile(link, VSBuffer.fromString(content), { atomic: { postfix: '.vsctmp' } });\n\t\tassert.strictEqual(readFileSync(link.fsPath).toString(), content);\n\n\t\tconst resolved = await service.resolve(link);\n\t\tassert.strictEqual(resolved.isSymbolicLink, true);\n\t});\n\n\tasync function testWriteFile(atomic: boolean) {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { atomic: atomic ? { postfix: '.vsctmp' } : false });\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.WRITE);\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (large file) - default', async () => {\n\t\treturn testWriteFileLarge(false);\n\t});\n\n\ttest('writeFile (large file) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileLarge(false);\n\t});\n\n\ttest('writeFile (large file) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileLarge(false);\n\t});\n\n\ttest('writeFile (large file) - default (atomic)', async () => {\n\t\treturn testWriteFileLarge(true);\n\t});\n\n\ttest('writeFile (large file) - buffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\tlet e;\n\t\ttry {\n\t\t\tawait testWriteFileLarge(true);\n\t\t} catch (error) {\n\t\t\te = error;\n\t\t}\n\n\t\tassert.ok(e);\n\t});\n\n\ttest('writeFile (large file) - unbuffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\treturn testWriteFileLarge(true);\n\t});\n\n\tasync function testWriteFileLarge(atomic: boolean) {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst fileStat = await service.writeFile(resource, VSBuffer.fromString(newContent), { atomic: atomic ? { postfix: '.vsctmp' } : false });\n\t\tassert.strictEqual(fileStat.name, 'lorem.txt');\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (large file) - unbuffered (atomic) - concurrent writes with multiple services', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst promises: Promise<IFileStatWithMetadata>[] = [];\n\t\tlet suffix = 0;\n\t\tfor (let i = 0; i < 10; i++) {\n\t\t\tconst service = disposables.add(new FileService(new NullLogService()));\n\t\t\tdisposables.add(service.registerProvider(Schemas.file, fileProvider));\n\n\t\t\tpromises.push(service.writeFile(resource, VSBuffer.fromString(`${newContent}${++suffix}`), { atomic: { postfix: '.vsctmp' } }));\n\t\t\tawait timeout(0);\n\t\t}\n\n\t\tawait Promise.allSettled(promises);\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), `${newContent}${suffix}`);\n\t});\n\n\ttest('writeFile - buffered - readonly throws', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testWriteFileReadonlyThrows();\n\t});\n\n\ttest('writeFile - unbuffered - readonly throws', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testWriteFileReadonlyThrows();\n\t});\n\n\tasync function testWriteFileReadonlyThrows() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\n\t\tlet error: Error;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent));\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error!);\n\t}\n\n\ttest('writeFile (large file) - multiple parallel writes queue up and atomic read support (via file service)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst writePromises = Promise.all(['0', '00', '000', '0000', '00000'].map(async offset => {\n\t\t\tconst fileStat = await service.writeFile(resource, VSBuffer.fromString(offset + newContent));\n\t\t\tassert.strictEqual(fileStat.name, 'lorem.txt');\n\t\t}));\n\n\t\tconst readPromises = Promise.all(['0', '00', '000', '0000', '00000'].map(async () => {\n\t\t\tconst fileContent = await service.readFile(resource, { atomic: true });\n\t\t\tassert.ok(fileContent.value.byteLength > 0); // `atomic: true` ensures we never read a truncated file\n\t\t}));\n\n\t\tawait Promise.all([writePromises, readPromises]);\n\t});\n\n\ttest('provider - write barrier prevents dirty writes', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst provider = service.getProvider(resource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\n\t\tconst writePromises = Promise.all(['0', '00', '000', '0000', '00000'].map(async offset => {\n\t\t\tconst content = offset + newContent;\n\t\t\tconst contentBuffer = VSBuffer.fromString(content).buffer;\n\n\t\t\tconst fd = await provider.open(resource, { create: true, unlock: false });\n\t\t\ttry {\n\t\t\t\tawait provider.write(fd, 0, VSBuffer.fromString(content).buffer, 0, contentBuffer.byteLength);\n\n\t\t\t\t// Here since `close` is not called, all other writes are\n\t\t\t\t// waiting on the barrier to release, so doing a readFile\n\t\t\t\t// should give us a consistent view of the file contents\n\t\t\t\tassert.strictEqual((await promises.readFile(resource.fsPath)).toString(), content);\n\t\t\t} finally {\n\t\t\t\tawait provider.close(fd);\n\t\t\t}\n\t\t}));\n\n\t\tawait Promise.all([writePromises]);\n\t});\n\n\ttest('provider - write barrier is partitioned per resource', async () => {\n\t\tconst resource1 = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst resource2 = URI.file(join(testDir, 'test.txt'));\n\n\t\tconst provider = service.getProvider(resource1.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\n\t\tconst fd1 = await provider.open(resource1, { create: true, unlock: false });\n\t\tconst fd2 = await provider.open(resource2, { create: true, unlock: false });\n\n\t\tconst newContent = 'Hello World';\n\n\t\ttry {\n\t\t\tawait provider.write(fd1, 0, VSBuffer.fromString(newContent).buffer, 0, VSBuffer.fromString(newContent).buffer.byteLength);\n\t\t\tassert.strictEqual((await promises.readFile(resource1.fsPath)).toString(), newContent);\n\n\t\t\tawait provider.write(fd2, 0, VSBuffer.fromString(newContent).buffer, 0, VSBuffer.fromString(newContent).buffer.byteLength);\n\t\t\tassert.strictEqual((await promises.readFile(resource2.fsPath)).toString(), newContent);\n\t\t} finally {\n\t\t\tawait Promise.allSettled([\n\t\t\t\tawait provider.close(fd1),\n\t\t\t\tawait provider.close(fd2)\n\t\t\t]);\n\t\t}\n\t});\n\n\ttest('provider - write barrier not becoming stale', async () => {\n\t\tconst newFolder = join(testDir, 'new-folder');\n\t\tconst newResource = URI.file(join(newFolder, 'lorem.txt'));\n\n\t\tconst provider = service.getProvider(newResource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait provider.open(newResource, { create: true, unlock: false });\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error); // expected because `new-folder` does not exist\n\n\t\tawait promises.mkdir(newFolder);\n\n\t\tconst content = readFileSync(URI.file(join(testDir, 'lorem.txt')).fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\t\tconst newContentBuffer = VSBuffer.fromString(newContent).buffer;\n\n\t\tconst fd = await provider.open(newResource, { create: true, unlock: false });\n\t\ttry {\n\t\t\tawait provider.write(fd, 0, newContentBuffer, 0, newContentBuffer.byteLength);\n\n\t\t\tassert.strictEqual((await promises.readFile(newResource.fsPath)).toString(), newContent);\n\t\t} finally {\n\t\t\tawait provider.close(fd);\n\t\t}\n\t});\n\n\ttest('provider - atomic reads (write pending when read starts)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\t\tconst newContentBuffer = VSBuffer.fromString(newContent).buffer;\n\n\t\tconst provider = service.getProvider(resource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\t\tassert.ok(hasFileAtomicReadCapability(provider));\n\n\t\tlet atomicReadPromise: Promise<Uint8Array> | undefined = undefined;\n\t\tconst fd = await provider.open(resource, { create: true, unlock: false });\n\t\ttry {\n\n\t\t\t// Start reading while write is pending\n\t\t\tatomicReadPromise = provider.readFile(resource, { atomic: true });\n\n\t\t\t// Simulate a slow write, giving the read\n\t\t\t// a chance to succeed if it were not atomic\n\t\t\tawait timeout(20);\n\n\t\t\tawait provider.write(fd, 0, newContentBuffer, 0, newContentBuffer.byteLength);\n\t\t} finally {\n\t\t\tawait provider.close(fd);\n\t\t}\n\n\t\tassert.ok(atomicReadPromise);\n\n\t\tconst atomicReadResult = await atomicReadPromise;\n\t\tassert.strictEqual(atomicReadResult.byteLength, newContentBuffer.byteLength);\n\t});\n\n\ttest('provider - atomic reads (read pending when write starts)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\t\tconst newContentBuffer = VSBuffer.fromString(newContent).buffer;\n\n\t\tconst provider = service.getProvider(resource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\t\tassert.ok(hasFileAtomicReadCapability(provider));\n\n\t\tlet atomicReadPromise = provider.readFile(resource, { atomic: true });\n\n\t\tconst fdPromise = provider.open(resource, { create: true, unlock: false }).then(async fd => {\n\t\t\ttry {\n\t\t\t\treturn await provider.write(fd, 0, newContentBuffer, 0, newContentBuffer.byteLength);\n\t\t\t} finally {\n\t\t\t\tawait provider.close(fd);\n\t\t\t}\n\t\t});\n\n\t\tlet atomicReadResult = await atomicReadPromise;\n\t\tassert.strictEqual(atomicReadResult.byteLength, content.byteLength);\n\n\t\tawait fdPromise;\n\n\t\tatomicReadPromise = provider.readFile(resource, { atomic: true });\n\t\tatomicReadResult = await atomicReadPromise;\n\t\tassert.strictEqual(atomicReadResult.byteLength, newContentBuffer.byteLength);\n\t});\n\n\ttest('writeFile (readable) - default', async () => {\n\t\treturn testWriteFileReadable();\n\t});\n\n\ttest('writeFile (readable) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileReadable();\n\t});\n\n\ttest('writeFile (readable) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileReadable();\n\t});\n\n\tasync function testWriteFileReadable() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, toLineByLineReadable(newContent));\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (large file - readable) - default', async () => {\n\t\treturn testWriteFileLargeReadable();\n\t});\n\n\ttest('writeFile (large file - readable) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileLargeReadable();\n\t});\n\n\ttest('writeFile (large file - readable) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileLargeReadable();\n\t});\n\n\tasync function testWriteFileLargeReadable() {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst fileStat = await service.writeFile(resource, toLineByLineReadable(newContent));\n\t\tassert.strictEqual(fileStat.name, 'lorem.txt');\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (stream) - default', async () => {\n\t\treturn testWriteFileStream();\n\t});\n\n\ttest('writeFile (stream) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileStream();\n\t});\n\n\ttest('writeFile (stream) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileStream();\n\t});\n\n\tasync function testWriteFileStream() {\n\t\tconst source = URI.file(join(testDir, 'small.txt'));\n\t\tconst target = URI.file(join(testDir, 'small-copy.txt'));\n\n\t\tconst fileStat = await service.writeFile(target, streamToBufferReadableStream(createReadStream(source.fsPath)));\n\t\tassert.strictEqual(fileStat.name, 'small-copy.txt');\n\n\t\tconst targetContents = readFileSync(target.fsPath).toString();\n\t\tassert.strictEqual(readFileSync(source.fsPath).toString(), targetContents);\n\t}\n\n\ttest('writeFile (large file - stream) - default', async () => {\n\t\treturn testWriteFileLargeStream();\n\t});\n\n\ttest('writeFile (large file - stream) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileLargeStream();\n\t});\n\n\ttest('writeFile (large file - stream) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileLargeStream();\n\t});\n\n\tasync function testWriteFileLargeStream() {\n\t\tconst source = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst target = URI.file(join(testDir, 'lorem-copy.txt'));\n\n\t\tconst fileStat = await service.writeFile(target, streamToBufferReadableStream(createReadStream(source.fsPath)));\n\t\tassert.strictEqual(fileStat.name, 'lorem-copy.txt');\n\n\t\tconst targetContents = readFileSync(target.fsPath).toString();\n\t\tassert.strictEqual(readFileSync(source.fsPath).toString(), targetContents);\n\t}\n\n\ttest('writeFile (file is created including parents)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'other', 'newfile.txt'));\n\n\t\tconst content = 'File is created including parent';\n\t\tconst fileStat = await service.writeFile(resource, VSBuffer.fromString(content));\n\t\tassert.strictEqual(fileStat.name, 'newfile.txt');\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), content);\n\t});\n\n\ttest('writeFile - locked files and unlocking', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileWriteUnlock);\n\n\t\treturn testLockedFiles(false);\n\t});\n\n\ttest('writeFile (stream) - locked files and unlocking', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileWriteUnlock);\n\n\t\treturn testLockedFiles(false);\n\t});\n\n\ttest('writeFile - locked files and unlocking throws error when missing capability', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testLockedFiles(true);\n\t});\n\n\ttest('writeFile (stream) - locked files and unlocking throws error when missing capability', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testLockedFiles(true);\n\t});\n\n\tasync function testLockedFiles(expectError: boolean) {\n\t\tconst lockedFile = URI.file(join(testDir, 'my-locked-file'));\n\n\t\tconst content = await service.writeFile(lockedFile, VSBuffer.fromString('Locked File'));\n\t\tassert.strictEqual(content.locked, false);\n\n\t\tconst stats = await promises.stat(lockedFile.fsPath);\n\t\tawait promises.chmod(lockedFile.fsPath, stats.mode & ~0o200);\n\n\t\tlet stat = await service.stat(lockedFile);\n\t\tassert.strictEqual(stat.locked, true);\n\n\t\tlet error;\n\t\tconst newContent = 'Updates to locked file';\n\t\ttry {\n\t\t\tawait service.writeFile(lockedFile, VSBuffer.fromString(newContent));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t\terror = undefined;\n\n\t\tif (expectError) {\n\t\t\ttry {\n\t\t\t\tawait service.writeFile(lockedFile, VSBuffer.fromString(newContent), { unlock: true });\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\n\t\t\tassert.ok(error);\n\t\t} else {\n\t\t\tawait service.writeFile(lockedFile, VSBuffer.fromString(newContent), { unlock: true });\n\t\t\tassert.strictEqual(readFileSync(lockedFile.fsPath).toString(), newContent);\n\n\t\t\tstat = await service.stat(lockedFile);\n\t\t\tassert.strictEqual(stat.locked, false);\n\t\t}\n\t}\n\n\ttest('writeFile (error when folder is encountered)', async () => {\n\t\tconst resource = URI.file(testDir);\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString('File is created including parent'));\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('writeFile (no error when providing up to date etag)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst stat = await service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: stat.etag, mtime: stat.mtime });\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t});\n\n\ttest('writeFile - error when writing to file that has been updated meanwhile', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst stat = await service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: stat.etag, mtime: stat.mtime });\n\n\t\tconst newContentLeadingToError = newContent + newContent;\n\n\t\tconst fakeMtime = 1000;\n\t\tconst fakeSize = 1000;\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContentLeadingToError), { etag: etag({ mtime: fakeMtime, size: fakeSize }), mtime: fakeMtime });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.ok(error instanceof FileOperationError);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_MODIFIED_SINCE);\n\t});\n\n\ttest('writeFile - no error when writing to file where size is the same', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst stat = await service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = content; // same content\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: stat.etag, mtime: stat.mtime });\n\n\t\tconst newContentLeadingToNoError = newContent; // writing the same content should be OK\n\n\t\tconst fakeMtime = 1000;\n\t\tconst actualSize = newContent.length;\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContentLeadingToNoError), { etag: etag({ mtime: fakeMtime, size: actualSize }), mtime: fakeMtime });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(!error);\n\t});\n\n\ttest('writeFile - no error when writing to file where content is the same', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tawait service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = content; // same content\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: 'anything', mtime: 0 } /* fake it */);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(!error);\n\t});\n\n\ttest('writeFile - error when writing to file where content is the same length but different', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tawait service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = content.split('').reverse().join(''); // reverse content\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: 'anything', mtime: 0 } /* fake it */);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.ok(error instanceof FileOperationError);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_MODIFIED_SINCE);\n\t});\n\n\ttest('writeFile - no error when writing to same nonexistent folder multiple times different new files', async () => {\n\t\tconst newFolder = URI.file(join(testDir, 'some', 'new', 'folder'));\n\n\t\tconst file1 = joinPath(newFolder, 'file-1');\n\t\tconst file2 = joinPath(newFolder, 'file-2');\n\t\tconst file3 = joinPath(newFolder, 'file-3');\n\n\t\t// this essentially verifies that the mkdirp logic implemented\n\t\t// in the file service is able to receive multiple requests for\n\t\t// the same folder and will not throw errors if another racing\n\t\t// call succeeded first.\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait Promise.all([\n\t\t\tservice.writeFile(file1, VSBuffer.fromString(newContent)),\n\t\t\tservice.writeFile(file2, VSBuffer.fromString(newContent)),\n\t\t\tservice.writeFile(file3, VSBuffer.fromString(newContent))\n\t\t]);\n\n\t\tassert.ok(service.exists(file1));\n\t\tassert.ok(service.exists(file2));\n\t\tassert.ok(service.exists(file3));\n\t});\n\n\ttest('writeFile - error when writing to folder that is a file', async () => {\n\t\tconst existingFile = URI.file(join(testDir, 'my-file'));\n\n\t\tawait service.createFile(existingFile);\n\n\t\tconst newFile = joinPath(existingFile, 'file-1');\n\n\t\tlet error;\n\t\tconst newContent = 'Updates to the small file';\n\t\ttry {\n\t\t\tawait service.writeFile(newFile, VSBuffer.fromString(newContent));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('read - mixed positions', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\t// read multiple times from position 0\n\t\tlet buffer = VSBuffer.alloc(1024);\n\t\tlet fd = await fileProvider.open(resource, { create: false });\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tawait fileProvider.read(fd, 0, buffer.buffer, 0, 26);\n\t\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\t\t}\n\t\tawait fileProvider.close(fd);\n\n\t\t// read multiple times at various locations\n\t\tbuffer = VSBuffer.alloc(1024);\n\t\tfd = await fileProvider.open(resource, { create: false });\n\n\t\tlet posInFile = 0;\n\n\t\tawait fileProvider.read(fd, posInFile, buffer.buffer, 0, 26);\n\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\t\tposInFile += 26;\n\n\t\tawait fileProvider.read(fd, posInFile, buffer.buffer, 0, 1);\n\t\tassert.strictEqual(buffer.slice(0, 1).toString(), ',');\n\t\tposInFile += 1;\n\n\t\tawait fileProvider.read(fd, posInFile, buffer.buffer, 0, 12);\n\t\tassert.strictEqual(buffer.slice(0, 12).toString(), ' consectetur');\n\t\tposInFile += 12;\n\n\t\tawait fileProvider.read(fd, 98 /* no longer in sequence of posInFile */, buffer.buffer, 0, 9);\n\t\tassert.strictEqual(buffer.slice(0, 9).toString(), 'fermentum');\n\n\t\tawait fileProvider.read(fd, 27, buffer.buffer, 0, 12);\n\t\tassert.strictEqual(buffer.slice(0, 12).toString(), ' consectetur');\n\n\t\tawait fileProvider.read(fd, 26, buffer.buffer, 0, 1);\n\t\tassert.strictEqual(buffer.slice(0, 1).toString(), ',');\n\n\t\tawait fileProvider.read(fd, 0, buffer.buffer, 0, 26);\n\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\n\t\tawait fileProvider.read(fd, posInFile /* back in sequence */, buffer.buffer, 0, 11);\n\t\tassert.strictEqual(buffer.slice(0, 11).toString(), ' adipiscing');\n\n\t\tawait fileProvider.close(fd);\n\t});\n\n\ttest('write - mixed positions', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst buffer = VSBuffer.alloc(1024);\n\t\tconst fdWrite = await fileProvider.open(resource, { create: true, unlock: false });\n\t\tconst fdRead = await fileProvider.open(resource, { create: false });\n\n\t\tlet posInFileWrite = 0;\n\t\tlet posInFileRead = 0;\n\n\t\tconst initialContents = VSBuffer.fromString('Lorem ipsum dolor sit amet');\n\t\tawait fileProvider.write(fdWrite, posInFileWrite, initialContents.buffer, 0, initialContents.byteLength);\n\t\tposInFileWrite += initialContents.byteLength;\n\n\t\tawait fileProvider.read(fdRead, posInFileRead, buffer.buffer, 0, 26);\n\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\t\tposInFileRead += 26;\n\n\t\tconst contents = VSBuffer.fromString('Hello World');\n\n\t\tawait fileProvider.write(fdWrite, posInFileWrite, contents.buffer, 0, contents.byteLength);\n\t\tposInFileWrite += contents.byteLength;\n\n\t\tawait fileProvider.read(fdRead, posInFileRead, buffer.buffer, 0, contents.byteLength);\n\t\tassert.strictEqual(buffer.slice(0, contents.byteLength).toString(), 'Hello World');\n\t\tposInFileRead += contents.byteLength;\n\n\t\tawait fileProvider.write(fdWrite, 6, contents.buffer, 0, contents.byteLength);\n\n\t\tawait fileProvider.read(fdRead, 0, buffer.buffer, 0, 11);\n\t\tassert.strictEqual(buffer.slice(0, 11).toString(), 'Lorem Hello');\n\n\t\tawait fileProvider.write(fdWrite, posInFileWrite, contents.buffer, 0, contents.byteLength);\n\t\tposInFileWrite += contents.byteLength;\n\n\t\tawait fileProvider.read(fdRead, posInFileWrite - contents.byteLength, buffer.buffer, 0, contents.byteLength);\n\t\tassert.strictEqual(buffer.slice(0, contents.byteLength).toString(), 'Hello World');\n\n\t\tawait fileProvider.close(fdWrite);\n\t\tawait fileProvider.close(fdRead);\n\t});\n\n\ttest('readonly - is handled properly for a single resource', async () => {\n\t\tfileProvider.setReadonly(true);\n\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tconst resolveResult = await service.resolve(resource);\n\t\tassert.strictEqual(resolveResult.readonly, true);\n\n\t\tconst readResult = await service.readFile(resource);\n\t\tassert.strictEqual(readResult.readonly, true);\n\n\t\tlet writeFileError: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString('Hello Test'));\n\t\t} catch (error) {\n\t\t\twriteFileError = error;\n\t\t}\n\t\tassert.ok(writeFileError);\n\n\t\tlet deleteFileError: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.del(resource);\n\t\t} catch (error) {\n\t\t\tdeleteFileError = error;\n\t\t}\n\t\tassert.ok(deleteFileError);\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { createReadStream, existsSync, readdirSync, readFileSync, statSync, writeFileSync, promises } from 'fs';\nimport { tmpdir } from 'os';\nimport { timeout } from '../../../../base/common/async.js';\nimport { bufferToReadable, bufferToStream, streamToBuffer, streamToBufferReadableStream, VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FileAccess, Schemas } from '../../../../base/common/network.js';\nimport { basename, dirname, join, posix } from '../../../../base/common/path.js';\nimport { isLinux, isWindows } from '../../../../base/common/platform.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises } from '../../../../base/node/pfs.js';\nimport { flakySuite, getRandomTestPath } from '../../../../base/test/node/testUtils.js';\nimport { etag, IFileAtomicReadOptions, FileOperation, FileOperationError, FileOperationEvent, FileOperationResult, FilePermission, FileSystemProviderCapabilities, hasFileAtomicReadCapability, hasOpenReadWriteCloseCapability, IFileStat, IFileStatWithMetadata, IReadFileOptions, IStat, NotModifiedSinceFileOperationError, TooLargeFileOperationError, IFileAtomicOptions } from '../../common/files.js';\nimport { FileService } from '../../common/fileService.js';\nimport { DiskFileSystemProvider } from '../../node/diskFileSystemProvider.js';\nimport { NullLogService } from '../../../log/common/log.js';\n\nfunction getByName(root: IFileStat, name: string): IFileStat | undefined {\n\tif (root.children === undefined) {\n\t\treturn undefined;\n\t}\n\n\treturn root.children.find(child => child.name === name);\n}\n\nfunction toLineByLineReadable(content: string): VSBufferReadable {\n\tlet chunks = content.split('\\n');\n\tchunks = chunks.map((chunk, index) => {\n\t\tif (index === 0) {\n\t\t\treturn chunk;\n\t\t}\n\n\t\treturn '\\n' + chunk;\n\t});\n\n\treturn {\n\t\tread(): VSBuffer | null {\n\t\t\tconst chunk = chunks.shift();\n\t\t\tif (typeof chunk === 'string') {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\nexport class TestDiskFileSystemProvider extends DiskFileSystemProvider {\n\n\ttotalBytesRead: number = 0;\n\n\tprivate invalidStatSize: boolean = false;\n\tprivate smallStatSize: boolean = false;\n\tprivate readonly: boolean = false;\n\n\tprivate _testCapabilities!: FileSystemProviderCapabilities;\n\toverride get capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._testCapabilities) {\n\t\t\tthis._testCapabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.Trash |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone |\n\t\t\t\tFileSystemProviderCapabilities.FileRealpath;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._testCapabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._testCapabilities;\n\t}\n\n\toverride set capabilities(capabilities: FileSystemProviderCapabilities) {\n\t\tthis._testCapabilities = capabilities;\n\t}\n\n\tsetInvalidStatSize(enabled: boolean): void {\n\t\tthis.invalidStatSize = enabled;\n\t}\n\n\tsetSmallStatSize(enabled: boolean): void {\n\t\tthis.smallStatSize = enabled;\n\t}\n\n\tsetReadonly(readonly: boolean): void {\n\t\tthis.readonly = readonly;\n\t}\n\n\toverride async stat(resource: URI): Promise<IStat> {\n\t\tconst res = await super.stat(resource);\n\n\t\tif (this.invalidStatSize) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t(res as any).size = String(res.size) as any; // for https://github.com/microsoft/vscode/issues/72909\n\t\t} else if (this.smallStatSize) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t(res as any).size = 1;\n\t\t} else if (this.readonly) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t(res as any).permissions = FilePermission.Readonly;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\toverride async read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst bytesRead = await super.read(fd, pos, data, offset, length);\n\n\t\tthis.totalBytesRead += bytesRead;\n\n\t\treturn bytesRead;\n\t}\n\n\toverride async readFile(resource: URI, options?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tconst res = await super.readFile(resource, options);\n\n\t\tthis.totalBytesRead += res.byteLength;\n\n\t\treturn res;\n\t}\n}\n\nDiskFileSystemProvider.configureFlushOnWrite(false); // speed up all unit tests by disabling flush on write\n\nflakySuite('Disk File Service', function () {\n\n\tconst testSchema = 'test';\n\n\tlet service: FileService;\n\tlet fileProvider: TestDiskFileSystemProvider;\n\tlet testProvider: TestDiskFileSystemProvider;\n\n\tlet testDir: string;\n\n\tconst disposables = new DisposableStore();\n\n\tsetup(async () => {\n\t\tconst logService = new NullLogService();\n\n\t\tservice = disposables.add(new FileService(logService));\n\n\t\tfileProvider = disposables.add(new TestDiskFileSystemProvider(logService));\n\t\tdisposables.add(service.registerProvider(Schemas.file, fileProvider));\n\n\t\ttestProvider = disposables.add(new TestDiskFileSystemProvider(logService));\n\t\tdisposables.add(service.registerProvider(testSchema, testProvider));\n\n\t\ttestDir = getRandomTestPath(tmpdir(), 'vsctests', 'diskfileservice');\n\n\t\tconst sourceDir = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/service').fsPath;\n\n\t\tawait Promises.copy(sourceDir, testDir, { preserveSymlinks: false });\n\t});\n\n\tteardown(() => {\n\t\tdisposables.clear();\n\n\t\treturn Promises.rm(testDir);\n\t});\n\n\ttest('createFolder', async () => {\n\t\tlet event: FileOperationEvent | undefined;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\n\t\tconst newFolderResource = URI.file(join(parent.resource.fsPath, 'newFolder'));\n\n\t\tconst newFolder = await service.createFolder(newFolderResource);\n\n\t\tassert.strictEqual(newFolder.name, 'newFolder');\n\t\tassert.strictEqual(existsSync(newFolder.resource.fsPath), true);\n\n\t\tassert.ok(event);\n\t\tassert.strictEqual(event.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event.target!.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event.target!.isDirectory, true);\n\t});\n\n\ttest('createFolder: creating multiple folders at once', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst multiFolderPaths = ['a', 'couple', 'of', 'folders'];\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\n\t\tconst newFolderResource = URI.file(join(parent.resource.fsPath, ...multiFolderPaths));\n\n\t\tconst newFolder = await service.createFolder(newFolderResource);\n\n\t\tconst lastFolderName = multiFolderPaths[multiFolderPaths.length - 1];\n\t\tassert.strictEqual(newFolder.name, lastFolderName);\n\t\tassert.strictEqual(existsSync(newFolder.resource.fsPath), true);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, newFolderResource.fsPath);\n\t\tassert.strictEqual(event!.target!.isDirectory, true);\n\t});\n\n\ttest('exists', async () => {\n\t\tlet exists = await service.exists(URI.file(testDir));\n\t\tassert.strictEqual(exists, true);\n\n\t\texists = await service.exists(URI.file(testDir + 'something'));\n\t\tassert.strictEqual(exists, false);\n\t});\n\n\ttest('resolve - file', async () => {\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver/index.html');\n\t\tconst resolved = await service.resolve(resource);\n\n\t\tassert.strictEqual(resolved.name, 'index.html');\n\t\tassert.strictEqual(resolved.isFile, true);\n\t\tassert.strictEqual(resolved.isDirectory, false);\n\t\tassert.strictEqual(resolved.readonly, false);\n\t\tassert.strictEqual(resolved.isSymbolicLink, false);\n\t\tassert.strictEqual(resolved.resource.toString(), resource.toString());\n\t\tassert.strictEqual(resolved.children, undefined);\n\t\tassert.ok(resolved.mtime! > 0);\n\t\tassert.ok(resolved.ctime! > 0);\n\t\tassert.ok(resolved.size! > 0);\n\t});\n\n\ttest('resolve - directory', async () => {\n\t\tconst testsElements = ['examples', 'other', 'index.html', 'site.css'];\n\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver');\n\t\tconst result = await service.resolve(resource);\n\n\t\tassert.ok(result);\n\t\tassert.strictEqual(result.resource.toString(), resource.toString());\n\t\tassert.strictEqual(result.name, 'resolver');\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\t\tassert.strictEqual(result.readonly, false);\n\t\tassert.ok(result.mtime! > 0);\n\t\tassert.ok(result.ctime! > 0);\n\t\tassert.strictEqual(result.children.length, testsElements.length);\n\n\t\tassert.ok(result.children.every(entry => {\n\t\t\treturn testsElements.some(name => {\n\t\t\t\treturn basename(entry.resource.fsPath) === name;\n\t\t\t});\n\t\t}));\n\n\t\tresult.children.forEach(value => {\n\t\t\tassert.ok(basename(value.resource.fsPath));\n\t\t\tif (['examples', 'other'].indexOf(basename(value.resource.fsPath)) >= 0) {\n\t\t\t\tassert.ok(value.isDirectory);\n\t\t\t\tassert.strictEqual(value.mtime, undefined);\n\t\t\t\tassert.strictEqual(value.ctime, undefined);\n\t\t\t} else if (basename(value.resource.fsPath) === 'index.html') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.strictEqual(value.mtime, undefined);\n\t\t\t\tassert.strictEqual(value.ctime, undefined);\n\t\t\t} else if (basename(value.resource.fsPath) === 'site.css') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.strictEqual(value.mtime, undefined);\n\t\t\t\tassert.strictEqual(value.ctime, undefined);\n\t\t\t} else {\n\t\t\t\tassert.fail('Unexpected value ' + basename(value.resource.fsPath));\n\t\t\t}\n\t\t});\n\t});\n\n\ttest('resolve - directory - with metadata', async () => {\n\t\tconst testsElements = ['examples', 'other', 'index.html', 'site.css'];\n\n\t\tconst result = await service.resolve(FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver'), { resolveMetadata: true });\n\n\t\tassert.ok(result);\n\t\tassert.strictEqual(result.name, 'resolver');\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\t\tassert.ok(result.mtime > 0);\n\t\tassert.ok(result.ctime > 0);\n\t\tassert.strictEqual(result.children.length, testsElements.length);\n\n\t\tassert.ok(result.children.every(entry => {\n\t\t\treturn testsElements.some(name => {\n\t\t\t\treturn basename(entry.resource.fsPath) === name;\n\t\t\t});\n\t\t}));\n\n\t\tassert.ok(result.children.every(entry => entry.etag.length > 0));\n\n\t\tresult.children.forEach(value => {\n\t\t\tassert.ok(basename(value.resource.fsPath));\n\t\t\tif (['examples', 'other'].indexOf(basename(value.resource.fsPath)) >= 0) {\n\t\t\t\tassert.ok(value.isDirectory);\n\t\t\t\tassert.ok(value.mtime > 0);\n\t\t\t\tassert.ok(value.ctime > 0);\n\t\t\t} else if (basename(value.resource.fsPath) === 'index.html') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.ok(value.mtime > 0);\n\t\t\t\tassert.ok(value.ctime > 0);\n\t\t\t} else if (basename(value.resource.fsPath) === 'site.css') {\n\t\t\t\tassert.ok(!value.isDirectory);\n\t\t\t\tassert.ok(!value.children);\n\t\t\t\tassert.ok(value.mtime > 0);\n\t\t\t\tassert.ok(value.ctime > 0);\n\t\t\t} else {\n\t\t\t\tassert.fail('Unexpected value ' + basename(value.resource.fsPath));\n\t\t\t}\n\t\t});\n\t});\n\n\ttest('resolve - directory with resolveTo', async () => {\n\t\tconst resolved = await service.resolve(URI.file(testDir), { resolveTo: [URI.file(join(testDir, 'deep'))] });\n\t\tassert.strictEqual(resolved.children!.length, 8);\n\n\t\tconst deep = (getByName(resolved, 'deep')!);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\t});\n\n\ttest('resolve - directory - resolveTo single directory', async () => {\n\t\tconst resolverFixturesPath = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver').fsPath;\n\t\tconst result = await service.resolve(URI.file(resolverFixturesPath), { resolveTo: [URI.file(join(resolverFixturesPath, 'other/deep'))] });\n\n\t\tassert.ok(result);\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\n\t\tconst children = result.children;\n\t\tassert.strictEqual(children.length, 4);\n\n\t\tconst other = getByName(result, 'other');\n\t\tassert.ok(other);\n\t\tassert.ok(other.children!.length > 0);\n\n\t\tconst deep = getByName(other, 'deep');\n\t\tassert.ok(deep);\n\t\tassert.ok(deep.children!.length > 0);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\t});\n\n\ttest('resolve directory - resolveTo multiple directories', () => {\n\t\treturn testResolveDirectoryWithTarget(false);\n\t});\n\n\ttest('resolve directory - resolveTo with a URI that has query parameter (https://github.com/microsoft/vscode/issues/128151)', () => {\n\t\treturn testResolveDirectoryWithTarget(true);\n\t});\n\n\tasync function testResolveDirectoryWithTarget(withQueryParam: boolean): Promise<void> {\n\t\tconst resolverFixturesPath = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver').fsPath;\n\t\tconst result = await service.resolve(URI.file(resolverFixturesPath).with({ query: withQueryParam ? 'test' : undefined }), {\n\t\t\tresolveTo: [\n\t\t\t\tURI.file(join(resolverFixturesPath, 'other/deep')).with({ query: withQueryParam ? 'test' : undefined }),\n\t\t\t\tURI.file(join(resolverFixturesPath, 'examples')).with({ query: withQueryParam ? 'test' : undefined })\n\t\t\t]\n\t\t});\n\n\t\tassert.ok(result);\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\n\t\tconst children = result.children;\n\t\tassert.strictEqual(children.length, 4);\n\n\t\tconst other = getByName(result, 'other');\n\t\tassert.ok(other);\n\t\tassert.ok(other.children!.length > 0);\n\n\t\tconst deep = getByName(other, 'deep');\n\t\tassert.ok(deep);\n\t\tassert.ok(deep.children!.length > 0);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\n\t\tconst examples = getByName(result, 'examples');\n\t\tassert.ok(examples);\n\t\tassert.ok(examples.children!.length > 0);\n\t\tassert.strictEqual(examples.children!.length, 4);\n\t}\n\n\ttest('resolve directory - resolveSingleChildFolders', async () => {\n\t\tconst resolverFixturesPath = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver/other').fsPath;\n\t\tconst result = await service.resolve(URI.file(resolverFixturesPath), { resolveSingleChildDescendants: true });\n\n\t\tassert.ok(result);\n\t\tassert.ok(result.children);\n\t\tassert.ok(result.children.length > 0);\n\t\tassert.ok(result.isDirectory);\n\n\t\tconst children = result.children;\n\t\tassert.strictEqual(children.length, 1);\n\n\t\tconst deep = getByName(result, 'deep');\n\t\tassert.ok(deep);\n\t\tassert.ok(deep.children!.length > 0);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\t});\n\n\ttest('resolves', async () => {\n\t\tconst res = await service.resolveAll([\n\t\t\t{ resource: URI.file(testDir), options: { resolveTo: [URI.file(join(testDir, 'deep'))] } },\n\t\t\t{ resource: URI.file(join(testDir, 'deep')) }\n\t\t]);\n\n\t\tconst r1 = (res[0].stat!);\n\t\tassert.strictEqual(r1.children!.length, 8);\n\n\t\tconst deep = (getByName(r1, 'deep')!);\n\t\tassert.strictEqual(deep.children!.length, 4);\n\n\t\tconst r2 = (res[1].stat!);\n\t\tassert.strictEqual(r2.children!.length, 4);\n\t\tassert.strictEqual(r2.name, 'deep');\n\t});\n\n\ttest('resolve / realpath - folder symbolic link', async () => {\n\t\tconst link = URI.file(join(testDir, 'deep-link'));\n\t\tawait promises.symlink(join(testDir, 'deep'), link.fsPath, 'junction');\n\n\t\tconst resolved = await service.resolve(link);\n\t\tassert.strictEqual(resolved.children!.length, 4);\n\t\tassert.strictEqual(resolved.isDirectory, true);\n\t\tassert.strictEqual(resolved.isSymbolicLink, true);\n\n\t\tconst realpath = await service.realpath(link);\n\t\tassert.ok(realpath);\n\t\tassert.strictEqual(basename(realpath.fsPath), 'deep');\n\t});\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('resolve - file symbolic link', async () => {\n\t\tconst link = URI.file(join(testDir, 'lorem.txt-linked'));\n\t\tawait promises.symlink(join(testDir, 'lorem.txt'), link.fsPath);\n\n\t\tconst resolved = await service.resolve(link);\n\t\tassert.strictEqual(resolved.isDirectory, false);\n\t\tassert.strictEqual(resolved.isSymbolicLink, true);\n\t});\n\n\ttest('resolve - symbolic link pointing to nonexistent file does not break', async () => {\n\t\tawait promises.symlink(join(testDir, 'foo'), join(testDir, 'bar'), 'junction');\n\n\t\tconst resolved = await service.resolve(URI.file(testDir));\n\t\tassert.strictEqual(resolved.isDirectory, true);\n\t\tassert.strictEqual(resolved.children!.length, 9);\n\n\t\tconst resolvedLink = resolved.children?.find(child => child.name === 'bar' && child.isSymbolicLink);\n\t\tassert.ok(resolvedLink);\n\n\t\tassert.ok(!resolvedLink?.isDirectory);\n\t\tassert.ok(!resolvedLink?.isFile);\n\t});\n\n\ttest('stat - file', async () => {\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver/index.html');\n\t\tconst resolved = await service.stat(resource);\n\n\t\tassert.strictEqual(resolved.name, 'index.html');\n\t\tassert.strictEqual(resolved.isFile, true);\n\t\tassert.strictEqual(resolved.isDirectory, false);\n\t\tassert.strictEqual(resolved.readonly, false);\n\t\tassert.strictEqual(resolved.isSymbolicLink, false);\n\t\tassert.strictEqual(resolved.resource.toString(), resource.toString());\n\t\tassert.ok(resolved.mtime > 0);\n\t\tassert.ok(resolved.ctime > 0);\n\t\tassert.ok(resolved.size > 0);\n\t});\n\n\ttest('stat - directory', async () => {\n\t\tconst resource = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/resolver');\n\t\tconst result = await service.stat(resource);\n\n\t\tassert.ok(result);\n\t\tassert.strictEqual(result.resource.toString(), resource.toString());\n\t\tassert.strictEqual(result.name, 'resolver');\n\t\tassert.ok(result.isDirectory);\n\t\tassert.strictEqual(result.readonly, false);\n\t\tassert.ok(result.mtime > 0);\n\t\tassert.ok(result.ctime > 0);\n\t});\n\n\ttest('deleteFile (non recursive)', async () => {\n\t\treturn testDeleteFile(false, false);\n\t});\n\n\ttest('deleteFile (recursive)', async () => {\n\t\treturn testDeleteFile(false, true);\n\t});\n\n\t(isLinux /* trash is unreliable on Linux */ ? test.skip : test)('deleteFile (useTrash)', async () => {\n\t\treturn testDeleteFile(true, false);\n\t});\n\n\tasync function testDeleteFile(useTrash: boolean, recursive: boolean): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst resource = URI.file(join(testDir, 'deep', 'conway.js'));\n\t\tconst source = await service.resolve(resource);\n\n\t\tassert.strictEqual(await service.canDelete(source.resource, { useTrash, recursive }), true);\n\t\tawait service.del(source.resource, { useTrash, recursive });\n\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), false);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.del(source.resource, { useTrash, recursive });\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual((<FileOperationError>error).fileOperationResult, FileOperationResult.FILE_NOT_FOUND);\n\t}\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('deleteFile - symbolic link (exists)', async () => {\n\t\tconst target = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst link = URI.file(join(testDir, 'lorem.txt-linked'));\n\t\tawait promises.symlink(target.fsPath, link.fsPath);\n\n\t\tconst source = await service.resolve(link);\n\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tassert.strictEqual(await service.canDelete(source.resource), true);\n\t\tawait service.del(source.resource);\n\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), false);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, link.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\n\t\tassert.strictEqual(existsSync(target.fsPath), true); // target the link pointed to is never deleted\n\t});\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('deleteFile - symbolic link (pointing to nonexistent file)', async () => {\n\t\tconst target = URI.file(join(testDir, 'foo'));\n\t\tconst link = URI.file(join(testDir, 'bar'));\n\t\tawait promises.symlink(target.fsPath, link.fsPath);\n\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tassert.strictEqual(await service.canDelete(link), true);\n\t\tawait service.del(link);\n\n\t\tassert.strictEqual(existsSync(link.fsPath), false);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, link.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\t});\n\n\ttest('deleteFolder (recursive)', async () => {\n\t\treturn testDeleteFolderRecursive(false, false);\n\t});\n\n\ttest('deleteFolder (recursive, atomic)', async () => {\n\t\treturn testDeleteFolderRecursive(false, { postfix: '.vsctmp' });\n\t});\n\n\t(isLinux /* trash is unreliable on Linux */ ? test.skip : test)('deleteFolder (recursive, useTrash)', async () => {\n\t\treturn testDeleteFolderRecursive(true, false);\n\t});\n\n\tasync function testDeleteFolderRecursive(useTrash: boolean, atomic: IFileAtomicOptions | false): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst resource = URI.file(join(testDir, 'deep'));\n\t\tconst source = await service.resolve(resource);\n\n\t\tassert.strictEqual(await service.canDelete(source.resource, { recursive: true, useTrash, atomic }), true);\n\t\tawait service.del(source.resource, { recursive: true, useTrash, atomic });\n\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.DELETE);\n\t}\n\n\ttest('deleteFolder (non recursive)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'deep'));\n\t\tconst source = await service.resolve(resource);\n\n\t\tassert.ok((await service.canDelete(source.resource)) instanceof Error);\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.del(source.resource);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('deleteFolder empty folder (recursive)', () => {\n\t\treturn testDeleteEmptyFolder(true);\n\t});\n\n\ttest('deleteFolder empty folder (non recursive)', () => {\n\t\treturn testDeleteEmptyFolder(false);\n\t});\n\n\tasync function testDeleteEmptyFolder(recursive: boolean): Promise<void> {\n\t\tconst { resource } = await service.createFolder(URI.file(join(testDir, 'deep', 'empty')));\n\n\t\tawait service.del(resource, { recursive });\n\n\t\tassert.strictEqual(await service.exists(resource), false);\n\t}\n\n\ttest('move', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, 'index.html'));\n\t\tconst sourceContents = readFileSync(source.fsPath);\n\n\t\tconst target = URI.file(join(dirname(source.fsPath), 'other.html'));\n\n\t\tassert.strictEqual(await service.canMove(source, target), true);\n\t\tconst renamed = await service.move(source, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\tconst targetContents = readFileSync(target.fsPath);\n\n\t\tassert.strictEqual(sourceContents.byteLength, targetContents.byteLength);\n\t\tassert.strictEqual(sourceContents.toString(), targetContents.toString());\n\t});\n\n\ttest('move - across providers (buffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers (unbuffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers (buffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers (unbuffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders();\n\t});\n\n\ttest('move - across providers - large (buffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\ttest('move - across providers - large (unbuffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\ttest('move - across providers - large (buffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\ttest('move - across providers - large (unbuffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveAcrossProviders('lorem.txt');\n\t});\n\n\tasync function testMoveAcrossProviders(sourceFile = 'index.html'): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, sourceFile));\n\t\tconst sourceContents = readFileSync(source.fsPath);\n\n\t\tconst target = URI.file(join(dirname(source.fsPath), 'other.html')).with({ scheme: testSchema });\n\n\t\tassert.strictEqual(await service.canMove(source, target), true);\n\t\tconst renamed = await service.move(source, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\tconst targetContents = readFileSync(target.fsPath);\n\n\t\tassert.strictEqual(sourceContents.byteLength, targetContents.byteLength);\n\t\tassert.strictEqual(sourceContents.toString(), targetContents.toString());\n\t}\n\n\ttest('move - multi folder', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst multiFolderPaths = ['a', 'couple', 'of', 'folders'];\n\t\tconst renameToPath = join(...multiFolderPaths, 'other.html');\n\n\t\tconst source = URI.file(join(testDir, 'index.html'));\n\n\t\tassert.strictEqual(await service.canMove(source, URI.file(join(dirname(source.fsPath), renameToPath))), true);\n\t\tconst renamed = await service.move(source, URI.file(join(dirname(source.fsPath), renameToPath)));\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\t});\n\n\ttest('move - directory', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, 'deep'));\n\n\t\tassert.strictEqual(await service.canMove(source, URI.file(join(dirname(source.fsPath), 'deeper'))), true);\n\t\tconst renamed = await service.move(source, URI.file(join(dirname(source.fsPath), 'deeper')));\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\t});\n\n\ttest('move - directory - across providers (buffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\ttest('move - directory - across providers (unbuffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\ttest('move - directory - across providers (buffered => unbuffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\ttest('move - directory - across providers (unbuffered => buffered)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\t\tsetCapabilities(testProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testMoveFolderAcrossProviders();\n\t});\n\n\tasync function testMoveFolderAcrossProviders(): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = URI.file(join(testDir, 'deep'));\n\t\tconst sourceChildren = readdirSync(source.fsPath);\n\n\t\tconst target = URI.file(join(dirname(source.fsPath), 'deeper')).with({ scheme: testSchema });\n\n\t\tassert.strictEqual(await service.canMove(source, target), true);\n\t\tconst renamed = await service.move(source, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.fsPath), false);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\tconst targetChildren = readdirSync(target.fsPath);\n\t\tassert.strictEqual(sourceChildren.length, targetChildren.length);\n\t\tfor (let i = 0; i < sourceChildren.length; i++) {\n\t\t\tassert.strictEqual(sourceChildren[i], targetChildren[i]);\n\t\t}\n\t}\n\n\ttest('move - MIX CASE', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tconst renamedResource = URI.file(join(dirname(source.resource.fsPath), 'INDEX.html'));\n\t\tassert.strictEqual(await service.canMove(source.resource, renamedResource), true);\n\t\tlet renamed = await service.move(source.resource, renamedResource);\n\n\t\tassert.strictEqual(existsSync(renamedResource.fsPath), true);\n\t\tassert.strictEqual(basename(renamedResource.fsPath), 'INDEX.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamedResource.fsPath);\n\n\t\trenamed = await service.resolve(renamedResource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, renamed.size);\n\t});\n\n\ttest('move - same file', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tassert.strictEqual(await service.canMove(source.resource, URI.file(source.resource.fsPath)), true);\n\t\tlet renamed = await service.move(source.resource, URI.file(source.resource.fsPath));\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(basename(renamed.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\trenamed = await service.resolve(renamed.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, renamed.size);\n\t});\n\n\ttest('move - same file #2', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tconst targetParent = URI.file(testDir);\n\t\tconst target = targetParent.with({ path: posix.join(targetParent.path, posix.basename(source.resource.path)) });\n\n\t\tassert.strictEqual(await service.canMove(source.resource, target), true);\n\t\tlet renamed = await service.move(source.resource, target);\n\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.strictEqual(basename(renamed.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.MOVE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, renamed.resource.fsPath);\n\n\t\trenamed = await service.resolve(renamed.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, renamed.size);\n\t});\n\n\ttest('move - source parent of target', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tassert.ok((await service.canMove(URI.file(testDir), URI.file(join(testDir, 'binary.txt'))) instanceof Error));\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.move(URI.file(testDir), URI.file(join(testDir, 'binary.txt')));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.ok(!event!);\n\n\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(originalSize, source.size);\n\t});\n\n\ttest('move - FILE_MOVE_CONFLICT', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tassert.ok((await service.canMove(source.resource, URI.file(join(testDir, 'binary.txt'))) instanceof Error));\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.move(source.resource, URI.file(join(testDir, 'binary.txt')));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_MOVE_CONFLICT);\n\t\tassert.ok(!event!);\n\n\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(originalSize, source.size);\n\t});\n\n\ttest('move - overwrite folder with file', async () => {\n\t\tlet createEvent: FileOperationEvent;\n\t\tlet moveEvent: FileOperationEvent;\n\t\tlet deleteEvent: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => {\n\t\t\tif (e.operation === FileOperation.CREATE) {\n\t\t\t\tcreateEvent = e;\n\t\t\t} else if (e.operation === FileOperation.DELETE) {\n\t\t\t\tdeleteEvent = e;\n\t\t\t} else if (e.operation === FileOperation.MOVE) {\n\t\t\t\tmoveEvent = e;\n\t\t\t}\n\t\t}));\n\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\t\tconst folderResource = URI.file(join(parent.resource.fsPath, 'conway.js'));\n\t\tconst f = await service.createFolder(folderResource);\n\t\tconst source = URI.file(join(testDir, 'deep', 'conway.js'));\n\n\t\tassert.strictEqual(await service.canMove(source, f.resource, true), true);\n\t\tconst moved = await service.move(source, f.resource, true);\n\n\t\tassert.strictEqual(existsSync(moved.resource.fsPath), true);\n\t\tassert.ok(statSync(moved.resource.fsPath).isFile);\n\t\tassert.ok(createEvent!);\n\t\tassert.ok(deleteEvent!);\n\t\tassert.ok(moveEvent!);\n\t\tassert.strictEqual(moveEvent!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(moveEvent!.target!.resource.fsPath, moved.resource.fsPath);\n\t\tassert.strictEqual(deleteEvent!.resource.fsPath, folderResource.fsPath);\n\t});\n\n\ttest('copy', async () => {\n\t\tawait doTestCopy();\n\t});\n\n\ttest('copy - unbuffered (FileSystemProviderCapabilities.FileReadWrite)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\tawait doTestCopy();\n\t});\n\n\ttest('copy - unbuffered large (FileSystemProviderCapabilities.FileReadWrite)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\tawait doTestCopy('lorem.txt');\n\t});\n\n\ttest('copy - buffered (FileSystemProviderCapabilities.FileOpenReadWriteClose)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\tawait doTestCopy();\n\t});\n\n\ttest('copy - buffered large (FileSystemProviderCapabilities.FileOpenReadWriteClose)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\tawait doTestCopy('lorem.txt');\n\t});\n\n\tfunction setCapabilities(provider: TestDiskFileSystemProvider, capabilities: FileSystemProviderCapabilities): void {\n\t\tprovider.capabilities = capabilities;\n\t\tif (isLinux) {\n\t\t\tprovider.capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t}\n\t}\n\n\tasync function doTestCopy(sourceName: string = 'index.html') {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, sourceName)));\n\t\tconst target = URI.file(join(testDir, 'other.html'));\n\n\t\tassert.strictEqual(await service.canCopy(source.resource, target), true);\n\t\tconst copied = await service.copy(source.resource, target);\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.strictEqual(existsSync(source.resource.fsPath), true);\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, copied.resource.fsPath);\n\n\t\tconst sourceContents = readFileSync(source.resource.fsPath);\n\t\tconst targetContents = readFileSync(target.fsPath);\n\n\t\tassert.strictEqual(sourceContents.byteLength, targetContents.byteLength);\n\t\tassert.strictEqual(sourceContents.toString(), targetContents.toString());\n\t}\n\n\ttest('copy - overwrite folder with file', async () => {\n\t\tlet createEvent: FileOperationEvent;\n\t\tlet copyEvent: FileOperationEvent;\n\t\tlet deleteEvent: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => {\n\t\t\tif (e.operation === FileOperation.CREATE) {\n\t\t\t\tcreateEvent = e;\n\t\t\t} else if (e.operation === FileOperation.DELETE) {\n\t\t\t\tdeleteEvent = e;\n\t\t\t} else if (e.operation === FileOperation.COPY) {\n\t\t\t\tcopyEvent = e;\n\t\t\t}\n\t\t}));\n\n\t\tconst parent = await service.resolve(URI.file(testDir));\n\t\tconst folderResource = URI.file(join(parent.resource.fsPath, 'conway.js'));\n\t\tconst f = await service.createFolder(folderResource);\n\t\tconst source = URI.file(join(testDir, 'deep', 'conway.js'));\n\n\t\tassert.strictEqual(await service.canCopy(source, f.resource, true), true);\n\t\tconst copied = await service.copy(source, f.resource, true);\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.ok(statSync(copied.resource.fsPath).isFile);\n\t\tassert.ok(createEvent!);\n\t\tassert.ok(deleteEvent!);\n\t\tassert.ok(copyEvent!);\n\t\tassert.strictEqual(copyEvent!.resource.fsPath, source.fsPath);\n\t\tassert.strictEqual(copyEvent!.target!.resource.fsPath, copied.resource.fsPath);\n\t\tassert.strictEqual(deleteEvent!.resource.fsPath, folderResource.fsPath);\n\t});\n\n\ttest('copy - MIX CASE same target - no overwrite', async () => {\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tconst target = URI.file(join(dirname(source.resource.fsPath), 'INDEX.html'));\n\n\t\tconst canCopy = await service.canCopy(source.resource, target);\n\n\t\tlet error;\n\t\tlet copied: IFileStatWithMetadata;\n\t\ttry {\n\t\t\tcopied = await service.copy(source.resource, target);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tif (isLinux) {\n\t\t\tassert.ok(!error);\n\t\t\tassert.strictEqual(canCopy, true);\n\n\t\t\tassert.strictEqual(existsSync(copied!.resource.fsPath), true);\n\t\t\tassert.ok(readdirSync(testDir).some(f => f === 'INDEX.html'));\n\t\t\tassert.strictEqual(source.size, copied!.size);\n\t\t} else {\n\t\t\tassert.ok(error);\n\t\t\tassert.ok(canCopy instanceof Error);\n\n\t\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\t\tassert.strictEqual(originalSize, source.size);\n\t\t}\n\t});\n\n\ttest('copy - MIX CASE same target - overwrite', async () => {\n\t\tlet source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tconst originalSize = source.size;\n\t\tassert.ok(originalSize > 0);\n\n\t\tconst target = URI.file(join(dirname(source.resource.fsPath), 'INDEX.html'));\n\n\t\tconst canCopy = await service.canCopy(source.resource, target, true);\n\n\t\tlet error;\n\t\tlet copied: IFileStatWithMetadata;\n\t\ttry {\n\t\t\tcopied = await service.copy(source.resource, target, true);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tif (isLinux) {\n\t\t\tassert.ok(!error);\n\t\t\tassert.strictEqual(canCopy, true);\n\n\t\t\tassert.strictEqual(existsSync(copied!.resource.fsPath), true);\n\t\t\tassert.ok(readdirSync(testDir).some(f => f === 'INDEX.html'));\n\t\t\tassert.strictEqual(source.size, copied!.size);\n\t\t} else {\n\t\t\tassert.ok(error);\n\t\t\tassert.ok(canCopy instanceof Error);\n\n\t\t\tsource = await service.resolve(source.resource, { resolveMetadata: true });\n\t\t\tassert.strictEqual(originalSize, source.size);\n\t\t}\n\t});\n\n\ttest('copy - MIX CASE different target - overwrite', async () => {\n\t\tconst source1 = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source1.size > 0);\n\n\t\tconst renamed = await service.move(source1.resource, URI.file(join(dirname(source1.resource.fsPath), 'CONWAY.js')));\n\t\tassert.strictEqual(existsSync(renamed.resource.fsPath), true);\n\t\tassert.ok(readdirSync(testDir).some(f => f === 'CONWAY.js'));\n\t\tassert.strictEqual(source1.size, renamed.size);\n\n\t\tconst source2 = await service.resolve(URI.file(join(testDir, 'deep', 'conway.js')), { resolveMetadata: true });\n\t\tconst target = URI.file(join(testDir, basename(source2.resource.path)));\n\n\t\tassert.strictEqual(await service.canCopy(source2.resource, target, true), true);\n\t\tconst res = await service.copy(source2.resource, target, true);\n\t\tassert.strictEqual(existsSync(res.resource.fsPath), true);\n\t\tassert.ok(readdirSync(testDir).some(f => f === 'conway.js'));\n\t\tassert.strictEqual(source2.size, res.size);\n\t});\n\n\ttest('copy - same file', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tassert.strictEqual(await service.canCopy(source.resource, URI.file(source.resource.fsPath)), true);\n\t\tlet copied = await service.copy(source.resource, URI.file(source.resource.fsPath));\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.strictEqual(basename(copied.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, copied.resource.fsPath);\n\n\t\tcopied = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, copied.size);\n\t});\n\n\ttest('copy - same file #2', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst source = await service.resolve(URI.file(join(testDir, 'index.html')), { resolveMetadata: true });\n\t\tassert.ok(source.size > 0);\n\n\t\tconst targetParent = URI.file(testDir);\n\t\tconst target = targetParent.with({ path: posix.join(targetParent.path, posix.basename(source.resource.path)) });\n\n\t\tassert.strictEqual(await service.canCopy(source.resource, URI.file(target.fsPath)), true);\n\t\tlet copied = await service.copy(source.resource, URI.file(target.fsPath));\n\n\t\tassert.strictEqual(existsSync(copied.resource.fsPath), true);\n\t\tassert.strictEqual(basename(copied.resource.fsPath), 'index.html');\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, source.resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.COPY);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, copied.resource.fsPath);\n\n\t\tcopied = await service.resolve(source.resource, { resolveMetadata: true });\n\t\tassert.strictEqual(source.size, copied.size);\n\t});\n\n\ttest('cloneFile - basics', () => {\n\t\treturn testCloneFile();\n\t});\n\n\ttest('cloneFile - via copy capability', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileFolderCopy);\n\n\t\treturn testCloneFile();\n\t});\n\n\ttest('cloneFile - via pipe', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testCloneFile();\n\t});\n\n\tasync function testCloneFile(): Promise<void> {\n\t\tconst source1 = URI.file(join(testDir, 'index.html'));\n\t\tconst source1Size = (await service.resolve(source1, { resolveMetadata: true })).size;\n\n\t\tconst source2 = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst source2Size = (await service.resolve(source2, { resolveMetadata: true })).size;\n\n\t\tconst targetParent = URI.file(testDir);\n\n\t\t// same path is a no-op\n\t\tawait service.cloneFile(source1, source1);\n\n\t\t// simple clone to existing parent folder path\n\t\tconst target1 = targetParent.with({ path: posix.join(targetParent.path, `${posix.basename(source1.path)}-clone`) });\n\n\t\tawait service.cloneFile(source1, URI.file(target1.fsPath));\n\n\t\tassert.strictEqual(existsSync(target1.fsPath), true);\n\t\tassert.strictEqual(basename(target1.fsPath), 'index.html-clone');\n\n\t\tlet target1Size = (await service.resolve(target1, { resolveMetadata: true })).size;\n\n\t\tassert.strictEqual(source1Size, target1Size);\n\n\t\t// clone to same path overwrites\n\t\tawait service.cloneFile(source2, URI.file(target1.fsPath));\n\n\t\ttarget1Size = (await service.resolve(target1, { resolveMetadata: true })).size;\n\n\t\tassert.strictEqual(source2Size, target1Size);\n\t\tassert.notStrictEqual(source1Size, target1Size);\n\n\t\t// clone creates missing folders ad-hoc\n\t\tconst target2 = targetParent.with({ path: posix.join(targetParent.path, 'foo', 'bar', `${posix.basename(source1.path)}-clone`) });\n\n\t\tawait service.cloneFile(source1, URI.file(target2.fsPath));\n\n\t\tassert.strictEqual(existsSync(target2.fsPath), true);\n\t\tassert.strictEqual(basename(target2.fsPath), 'index.html-clone');\n\n\t\tconst target2Size = (await service.resolve(target2, { resolveMetadata: true })).size;\n\n\t\tassert.strictEqual(source1Size, target2Size);\n\t}\n\n\ttest('readFile - small file - default', () => {\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - buffered', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - buffered / readonly', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - unbuffered / readonly', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - small file - streamed / readonly', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFile - large file - default', async () => {\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - large file - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - large file - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - large file - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')));\n\t});\n\n\ttest('readFile - atomic (emulated on service level)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')), { atomic: true });\n\t});\n\n\ttest('readFile - atomic (natively supported)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite & FileSystemProviderCapabilities.FileAtomicRead);\n\n\t\treturn testReadFile(URI.file(join(testDir, 'lorem.txt')), { atomic: true });\n\t});\n\n\tasync function testReadFile(resource: URI, options?: IReadFileOptions): Promise<void> {\n\t\tconst content = await service.readFile(resource, options);\n\n\t\tassert.strictEqual(content.value.toString(), readFileSync(resource.fsPath).toString());\n\t}\n\n\ttest('readFileStream - small file - default', () => {\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFileStream - small file - buffered', () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFileStream - small file - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\ttest('readFileStream - small file - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFileStream(URI.file(join(testDir, 'small.txt')));\n\t});\n\n\tasync function testReadFileStream(resource: URI): Promise<void> {\n\t\tconst content = await service.readFileStream(resource);\n\n\t\tassert.strictEqual((await streamToBuffer(content.value)).toString(), readFileSync(resource.fsPath).toString());\n\t}\n\n\ttest('readFile - Files are intermingled #38331 - default', async () => {\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\ttest('readFile - Files are intermingled #38331 - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\ttest('readFile - Files are intermingled #38331 - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\ttest('readFile - Files are intermingled #38331 - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testFilesNotIntermingled();\n\t});\n\n\tasync function testFilesNotIntermingled() {\n\t\tconst resource1 = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst resource2 = URI.file(join(testDir, 'some_utf16le.css'));\n\n\t\t// load in sequence and keep data\n\t\tconst value1 = await service.readFile(resource1);\n\t\tconst value2 = await service.readFile(resource2);\n\n\t\t// load in parallel in expect the same result\n\t\tconst result = await Promise.all([\n\t\t\tservice.readFile(resource1),\n\t\t\tservice.readFile(resource2)\n\t\t]);\n\n\t\tassert.strictEqual(result[0].value.toString(), value1.value.toString());\n\t\tassert.strictEqual(result[1].value.toString(), value2.value.toString());\n\t}\n\n\ttest('readFile - from position (ASCII) - default', async () => {\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\ttest('readFile - from position (ASCII) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\ttest('readFile - from position (ASCII) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\ttest('readFile - from position (ASCII) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFileFromPositionAscii();\n\t});\n\n\tasync function testReadFileFromPositionAscii() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst contents = await service.readFile(resource, { position: 6 });\n\n\t\tassert.strictEqual(contents.value.toString(), 'File');\n\t}\n\n\ttest('readFile - from position (with umlaut) - default', async () => {\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\ttest('readFile - from position (with umlaut) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\ttest('readFile - from position (with umlaut) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\ttest('readFile - from position (with umlaut) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadFileFromPositionUmlaut();\n\t});\n\n\tasync function testReadFileFromPositionUmlaut() {\n\t\tconst resource = URI.file(join(testDir, 'small_umlaut.txt'));\n\n\t\tconst contents = await service.readFile(resource, { position: Buffer.from('Small File with ').length });\n\n\t\tassert.strictEqual(contents.value.toString(), 'mlaut');\n\t}\n\n\ttest('readFile - 3 bytes (ASCII) - default', async () => {\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\ttest('readFile - 3 bytes (ASCII) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\ttest('readFile - 3 bytes (ASCII) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\ttest('readFile - 3 bytes (ASCII) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testReadThreeBytesFromFile();\n\t});\n\n\tasync function testReadThreeBytesFromFile() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst contents = await service.readFile(resource, { length: 3 });\n\n\t\tassert.strictEqual(contents.value.toString(), 'Sma');\n\t}\n\n\ttest('readFile - 20000 bytes (large) - default', async () => {\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 20000 bytes (large) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 20000 bytes (large) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 20000 bytes (large) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn readLargeFileWithLength(20000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - default', async () => {\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\ttest('readFile - 80000 bytes (large) - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn readLargeFileWithLength(80000);\n\t});\n\n\tasync function readLargeFileWithLength(length: number) {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst contents = await service.readFile(resource, { length });\n\n\t\tassert.strictEqual(contents.value.byteLength, length);\n\t}\n\n\ttest('readFile - FILE_IS_DIRECTORY', async () => {\n\t\tconst resource = URI.file(join(testDir, 'deep'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_IS_DIRECTORY);\n\t});\n\n\t(isWindows /* error code does not seem to be supported on windows */ ? test.skip : test)('readFile - FILE_NOT_DIRECTORY', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt', 'file.txt'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_NOT_DIRECTORY);\n\t});\n\n\ttest('readFile - FILE_NOT_FOUND', async () => {\n\t\tconst resource = URI.file(join(testDir, '404.html'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_NOT_FOUND);\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - default', async () => {\n\t\treturn testNotModifiedSince();\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testNotModifiedSince();\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testNotModifiedSince();\n\t});\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testNotModifiedSince();\n\t});\n\n\tasync function testNotModifiedSince() {\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tconst contents = await service.readFile(resource);\n\t\tfileProvider.totalBytesRead = 0;\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource, { etag: contents.etag });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_NOT_MODIFIED_SINCE);\n\t\tassert.ok(error instanceof NotModifiedSinceFileOperationError && error.stat);\n\t\tassert.strictEqual(fileProvider.totalBytesRead, 0);\n\t}\n\n\ttest('readFile - FILE_NOT_MODIFIED_SINCE does not fire wrongly - https://github.com/microsoft/vscode/issues/72909', async () => {\n\t\tfileProvider.setInvalidStatSize(true);\n\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tawait service.readFile(resource);\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource, { etag: undefined });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(!error);\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - default', async () => {\n\t\treturn testFileTooLarge();\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testFileTooLarge();\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testFileTooLarge();\n\t});\n\n\ttest('readFile - FILE_TOO_LARGE - streamed', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadStream);\n\n\t\treturn testFileTooLarge();\n\t});\n\n\tasync function testFileTooLarge() {\n\t\tawait doTestFileTooLarge(false);\n\n\t\t// Also test when the stat size is wrong\n\t\tfileProvider.setSmallStatSize(true);\n\t\treturn doTestFileTooLarge(true);\n\t}\n\n\tasync function doTestFileTooLarge(statSizeWrong: boolean) {\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(resource, { limits: { size: 10 } });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tif (!statSizeWrong) {\n\t\t\tassert.ok(error instanceof TooLargeFileOperationError);\n\t\t\tassert.ok(typeof error.size === 'number');\n\t\t}\n\t\tassert.strictEqual(error!.fileOperationResult, FileOperationResult.FILE_TOO_LARGE);\n\t}\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('readFile - dangling symbolic link - https://github.com/microsoft/vscode/issues/116049', async () => {\n\t\tconst link = URI.file(join(testDir, 'small.js-link'));\n\t\tawait promises.symlink(join(testDir, 'small.js'), link.fsPath);\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.readFile(link);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('createFile', async () => {\n\t\treturn assertCreateFile(contents => VSBuffer.fromString(contents));\n\t});\n\n\ttest('createFile (readable)', async () => {\n\t\treturn assertCreateFile(contents => bufferToReadable(VSBuffer.fromString(contents)));\n\t});\n\n\ttest('createFile (stream)', async () => {\n\t\treturn assertCreateFile(contents => bufferToStream(VSBuffer.fromString(contents)));\n\t});\n\n\tasync function assertCreateFile(converter: (content: string) => VSBuffer | VSBufferReadable | VSBufferReadableStream): Promise<void> {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst contents = 'Hello World';\n\t\tconst resource = URI.file(join(testDir, 'test.txt'));\n\n\t\tassert.strictEqual(await service.canCreateFile(resource), true);\n\t\tconst fileStat = await service.createFile(resource, converter(contents));\n\t\tassert.strictEqual(fileStat.name, 'test.txt');\n\t\tassert.strictEqual(existsSync(fileStat.resource.fsPath), true);\n\t\tassert.strictEqual(readFileSync(fileStat.resource.fsPath).toString(), contents);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, resource.fsPath);\n\t}\n\n\ttest('createFile (does not overwrite by default)', async () => {\n\t\tconst contents = 'Hello World';\n\t\tconst resource = URI.file(join(testDir, 'test.txt'));\n\n\t\twriteFileSync(resource.fsPath, ''); // create file\n\n\t\tassert.ok((await service.canCreateFile(resource)) instanceof Error);\n\n\t\tlet error;\n\t\ttry {\n\t\t\tawait service.createFile(resource, VSBuffer.fromString(contents));\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('createFile (allows to overwrite existing)', async () => {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst contents = 'Hello World';\n\t\tconst resource = URI.file(join(testDir, 'test.txt'));\n\n\t\twriteFileSync(resource.fsPath, ''); // create file\n\n\t\tassert.strictEqual(await service.canCreateFile(resource, { overwrite: true }), true);\n\t\tconst fileStat = await service.createFile(resource, VSBuffer.fromString(contents), { overwrite: true });\n\t\tassert.strictEqual(fileStat.name, 'test.txt');\n\t\tassert.strictEqual(existsSync(fileStat.resource.fsPath), true);\n\t\tassert.strictEqual(readFileSync(fileStat.resource.fsPath).toString(), contents);\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.CREATE);\n\t\tassert.strictEqual(event!.target!.resource.fsPath, resource.fsPath);\n\t});\n\n\ttest('writeFile - default', async () => {\n\t\treturn testWriteFile(false);\n\t});\n\n\ttest('writeFile - flush on write', async () => {\n\t\tDiskFileSystemProvider.configureFlushOnWrite(true);\n\t\ttry {\n\t\t\treturn await testWriteFile(false);\n\t\t} finally {\n\t\t\tDiskFileSystemProvider.configureFlushOnWrite(false);\n\t\t}\n\t});\n\n\ttest('writeFile - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFile(false);\n\t});\n\n\ttest('writeFile - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFile(false);\n\t});\n\n\ttest('writeFile - default (atomic)', async () => {\n\t\treturn testWriteFile(true);\n\t});\n\n\ttest('writeFile - flush on write (atomic)', async () => {\n\t\tDiskFileSystemProvider.configureFlushOnWrite(true);\n\t\ttry {\n\t\t\treturn await testWriteFile(true);\n\t\t} finally {\n\t\t\tDiskFileSystemProvider.configureFlushOnWrite(false);\n\t\t}\n\t});\n\n\ttest('writeFile - buffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\tlet e;\n\t\ttry {\n\t\t\tawait testWriteFile(true);\n\t\t} catch (error) {\n\t\t\te = error;\n\t\t}\n\n\t\tassert.ok(e);\n\t});\n\n\ttest('writeFile - unbuffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\treturn testWriteFile(true);\n\t});\n\n\t(isWindows ? test.skip /* windows: cannot create file symbolic link without elevated context */ : test)('writeFile - atomic writing does not break symlinks', async () => {\n\t\tconst link = URI.file(join(testDir, 'lorem.txt-linked'));\n\t\tawait promises.symlink(join(testDir, 'lorem.txt'), link.fsPath);\n\n\t\tconst content = 'Updates to the lorem file';\n\t\tawait service.writeFile(link, VSBuffer.fromString(content), { atomic: { postfix: '.vsctmp' } });\n\t\tassert.strictEqual(readFileSync(link.fsPath).toString(), content);\n\n\t\tconst resolved = await service.resolve(link);\n\t\tassert.strictEqual(resolved.isSymbolicLink, true);\n\t});\n\n\tasync function testWriteFile(atomic: boolean) {\n\t\tlet event: FileOperationEvent;\n\t\tdisposables.add(service.onDidRunOperation(e => event = e));\n\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { atomic: atomic ? { postfix: '.vsctmp' } : false });\n\n\t\tassert.ok(event!);\n\t\tassert.strictEqual(event!.resource.fsPath, resource.fsPath);\n\t\tassert.strictEqual(event!.operation, FileOperation.WRITE);\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (large file) - default', async () => {\n\t\treturn testWriteFileLarge(false);\n\t});\n\n\ttest('writeFile (large file) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileLarge(false);\n\t});\n\n\ttest('writeFile (large file) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileLarge(false);\n\t});\n\n\ttest('writeFile (large file) - default (atomic)', async () => {\n\t\treturn testWriteFileLarge(true);\n\t});\n\n\ttest('writeFile (large file) - buffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\tlet e;\n\t\ttry {\n\t\t\tawait testWriteFileLarge(true);\n\t\t} catch (error) {\n\t\t\te = error;\n\t\t}\n\n\t\tassert.ok(e);\n\t});\n\n\ttest('writeFile (large file) - unbuffered (atomic)', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\treturn testWriteFileLarge(true);\n\t});\n\n\tasync function testWriteFileLarge(atomic: boolean) {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst fileStat = await service.writeFile(resource, VSBuffer.fromString(newContent), { atomic: atomic ? { postfix: '.vsctmp' } : false });\n\t\tassert.strictEqual(fileStat.name, 'lorem.txt');\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (large file) - unbuffered (atomic) - concurrent writes with multiple services', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileAtomicWrite);\n\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst promises: Promise<IFileStatWithMetadata>[] = [];\n\t\tlet suffix = 0;\n\t\tfor (let i = 0; i < 10; i++) {\n\t\t\tconst service = disposables.add(new FileService(new NullLogService()));\n\t\t\tdisposables.add(service.registerProvider(Schemas.file, fileProvider));\n\n\t\t\tpromises.push(service.writeFile(resource, VSBuffer.fromString(`${newContent}${++suffix}`), { atomic: { postfix: '.vsctmp' } }));\n\t\t\tawait timeout(0);\n\t\t}\n\n\t\tawait Promise.allSettled(promises);\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), `${newContent}${suffix}`);\n\t});\n\n\ttest('writeFile - buffered - readonly throws', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testWriteFileReadonlyThrows();\n\t});\n\n\ttest('writeFile - unbuffered - readonly throws', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.Readonly);\n\n\t\treturn testWriteFileReadonlyThrows();\n\t});\n\n\tasync function testWriteFileReadonlyThrows() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\n\t\tlet error: Error;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent));\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error!);\n\t}\n\n\ttest('writeFile (large file) - multiple parallel writes queue up and atomic read support (via file service)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst writePromises = Promise.all(['0', '00', '000', '0000', '00000'].map(async offset => {\n\t\t\tconst fileStat = await service.writeFile(resource, VSBuffer.fromString(offset + newContent));\n\t\t\tassert.strictEqual(fileStat.name, 'lorem.txt');\n\t\t}));\n\n\t\tconst readPromises = Promise.all(['0', '00', '000', '0000', '00000'].map(async () => {\n\t\t\tconst fileContent = await service.readFile(resource, { atomic: true });\n\t\t\tassert.ok(fileContent.value.byteLength > 0); // `atomic: true` ensures we never read a truncated file\n\t\t}));\n\n\t\tawait Promise.all([writePromises, readPromises]);\n\t});\n\n\ttest('provider - write barrier prevents dirty writes', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst provider = service.getProvider(resource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\n\t\tconst writePromises = Promise.all(['0', '00', '000', '0000', '00000'].map(async offset => {\n\t\t\tconst content = offset + newContent;\n\t\t\tconst contentBuffer = VSBuffer.fromString(content).buffer;\n\n\t\t\tconst fd = await provider.open(resource, { create: true, unlock: false });\n\t\t\ttry {\n\t\t\t\tawait provider.write(fd, 0, VSBuffer.fromString(content).buffer, 0, contentBuffer.byteLength);\n\n\t\t\t\t// Here since `close` is not called, all other writes are\n\t\t\t\t// waiting on the barrier to release, so doing a readFile\n\t\t\t\t// should give us a consistent view of the file contents\n\t\t\t\tassert.strictEqual((await promises.readFile(resource.fsPath)).toString(), content);\n\t\t\t} finally {\n\t\t\t\tawait provider.close(fd);\n\t\t\t}\n\t\t}));\n\n\t\tawait Promise.all([writePromises]);\n\t});\n\n\ttest('provider - write barrier is partitioned per resource', async () => {\n\t\tconst resource1 = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst resource2 = URI.file(join(testDir, 'test.txt'));\n\n\t\tconst provider = service.getProvider(resource1.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\n\t\tconst fd1 = await provider.open(resource1, { create: true, unlock: false });\n\t\tconst fd2 = await provider.open(resource2, { create: true, unlock: false });\n\n\t\tconst newContent = 'Hello World';\n\n\t\ttry {\n\t\t\tawait provider.write(fd1, 0, VSBuffer.fromString(newContent).buffer, 0, VSBuffer.fromString(newContent).buffer.byteLength);\n\t\t\tassert.strictEqual((await promises.readFile(resource1.fsPath)).toString(), newContent);\n\n\t\t\tawait provider.write(fd2, 0, VSBuffer.fromString(newContent).buffer, 0, VSBuffer.fromString(newContent).buffer.byteLength);\n\t\t\tassert.strictEqual((await promises.readFile(resource2.fsPath)).toString(), newContent);\n\t\t} finally {\n\t\t\tawait Promise.allSettled([\n\t\t\t\tawait provider.close(fd1),\n\t\t\t\tawait provider.close(fd2)\n\t\t\t]);\n\t\t}\n\t});\n\n\ttest('provider - write barrier not becoming stale', async () => {\n\t\tconst newFolder = join(testDir, 'new-folder');\n\t\tconst newResource = URI.file(join(newFolder, 'lorem.txt'));\n\n\t\tconst provider = service.getProvider(newResource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait provider.open(newResource, { create: true, unlock: false });\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error); // expected because `new-folder` does not exist\n\n\t\tawait promises.mkdir(newFolder);\n\n\t\tconst content = readFileSync(URI.file(join(testDir, 'lorem.txt')).fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\t\tconst newContentBuffer = VSBuffer.fromString(newContent).buffer;\n\n\t\tconst fd = await provider.open(newResource, { create: true, unlock: false });\n\t\ttry {\n\t\t\tawait provider.write(fd, 0, newContentBuffer, 0, newContentBuffer.byteLength);\n\n\t\t\tassert.strictEqual((await promises.readFile(newResource.fsPath)).toString(), newContent);\n\t\t} finally {\n\t\t\tawait provider.close(fd);\n\t\t}\n\t});\n\n\ttest('provider - atomic reads (write pending when read starts)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\t\tconst newContentBuffer = VSBuffer.fromString(newContent).buffer;\n\n\t\tconst provider = service.getProvider(resource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\t\tassert.ok(hasFileAtomicReadCapability(provider));\n\n\t\tlet atomicReadPromise: Promise<Uint8Array> | undefined = undefined;\n\t\tconst fd = await provider.open(resource, { create: true, unlock: false });\n\t\ttry {\n\n\t\t\t// Start reading while write is pending\n\t\t\tatomicReadPromise = provider.readFile(resource, { atomic: true });\n\n\t\t\t// Simulate a slow write, giving the read\n\t\t\t// a chance to succeed if it were not atomic\n\t\t\tawait timeout(20);\n\n\t\t\tawait provider.write(fd, 0, newContentBuffer, 0, newContentBuffer.byteLength);\n\t\t} finally {\n\t\t\tawait provider.close(fd);\n\t\t}\n\n\t\tassert.ok(atomicReadPromise);\n\n\t\tconst atomicReadResult = await atomicReadPromise;\n\t\tassert.strictEqual(atomicReadResult.byteLength, newContentBuffer.byteLength);\n\t});\n\n\ttest('provider - atomic reads (read pending when write starts)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\t\tconst newContentBuffer = VSBuffer.fromString(newContent).buffer;\n\n\t\tconst provider = service.getProvider(resource.scheme);\n\t\tassert.ok(provider);\n\t\tassert.ok(hasOpenReadWriteCloseCapability(provider));\n\t\tassert.ok(hasFileAtomicReadCapability(provider));\n\n\t\tlet atomicReadPromise = provider.readFile(resource, { atomic: true });\n\n\t\tconst fdPromise = provider.open(resource, { create: true, unlock: false }).then(async fd => {\n\t\t\ttry {\n\t\t\t\treturn await provider.write(fd, 0, newContentBuffer, 0, newContentBuffer.byteLength);\n\t\t\t} finally {\n\t\t\t\tawait provider.close(fd);\n\t\t\t}\n\t\t});\n\n\t\tlet atomicReadResult = await atomicReadPromise;\n\t\tassert.strictEqual(atomicReadResult.byteLength, content.byteLength);\n\n\t\tawait fdPromise;\n\n\t\tatomicReadPromise = provider.readFile(resource, { atomic: true });\n\t\tatomicReadResult = await atomicReadPromise;\n\t\tassert.strictEqual(atomicReadResult.byteLength, newContentBuffer.byteLength);\n\t});\n\n\ttest('writeFile (readable) - default', async () => {\n\t\treturn testWriteFileReadable();\n\t});\n\n\ttest('writeFile (readable) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileReadable();\n\t});\n\n\ttest('writeFile (readable) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileReadable();\n\t});\n\n\tasync function testWriteFileReadable() {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, toLineByLineReadable(newContent));\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (large file - readable) - default', async () => {\n\t\treturn testWriteFileLargeReadable();\n\t});\n\n\ttest('writeFile (large file - readable) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileLargeReadable();\n\t});\n\n\ttest('writeFile (large file - readable) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileLargeReadable();\n\t});\n\n\tasync function testWriteFileLargeReadable() {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst content = readFileSync(resource.fsPath);\n\t\tconst newContent = content.toString() + content.toString();\n\n\t\tconst fileStat = await service.writeFile(resource, toLineByLineReadable(newContent));\n\t\tassert.strictEqual(fileStat.name, 'lorem.txt');\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t}\n\n\ttest('writeFile (stream) - default', async () => {\n\t\treturn testWriteFileStream();\n\t});\n\n\ttest('writeFile (stream) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileStream();\n\t});\n\n\ttest('writeFile (stream) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileStream();\n\t});\n\n\tasync function testWriteFileStream() {\n\t\tconst source = URI.file(join(testDir, 'small.txt'));\n\t\tconst target = URI.file(join(testDir, 'small-copy.txt'));\n\n\t\tconst fileStat = await service.writeFile(target, streamToBufferReadableStream(createReadStream(source.fsPath)));\n\t\tassert.strictEqual(fileStat.name, 'small-copy.txt');\n\n\t\tconst targetContents = readFileSync(target.fsPath).toString();\n\t\tassert.strictEqual(readFileSync(source.fsPath).toString(), targetContents);\n\t}\n\n\ttest('writeFile (large file - stream) - default', async () => {\n\t\treturn testWriteFileLargeStream();\n\t});\n\n\ttest('writeFile (large file - stream) - buffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testWriteFileLargeStream();\n\t});\n\n\ttest('writeFile (large file - stream) - unbuffered', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testWriteFileLargeStream();\n\t});\n\n\tasync function testWriteFileLargeStream() {\n\t\tconst source = URI.file(join(testDir, 'lorem.txt'));\n\t\tconst target = URI.file(join(testDir, 'lorem-copy.txt'));\n\n\t\tconst fileStat = await service.writeFile(target, streamToBufferReadableStream(createReadStream(source.fsPath)));\n\t\tassert.strictEqual(fileStat.name, 'lorem-copy.txt');\n\n\t\tconst targetContents = readFileSync(target.fsPath).toString();\n\t\tassert.strictEqual(readFileSync(source.fsPath).toString(), targetContents);\n\t}\n\n\ttest('writeFile (file is created including parents)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'other', 'newfile.txt'));\n\n\t\tconst content = 'File is created including parent';\n\t\tconst fileStat = await service.writeFile(resource, VSBuffer.fromString(content));\n\t\tassert.strictEqual(fileStat.name, 'newfile.txt');\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), content);\n\t});\n\n\ttest('writeFile - locked files and unlocking', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.FileWriteUnlock);\n\n\t\treturn testLockedFiles(false);\n\t});\n\n\ttest('writeFile (stream) - locked files and unlocking', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose | FileSystemProviderCapabilities.FileWriteUnlock);\n\n\t\treturn testLockedFiles(false);\n\t});\n\n\ttest('writeFile - locked files and unlocking throws error when missing capability', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileReadWrite);\n\n\t\treturn testLockedFiles(true);\n\t});\n\n\ttest('writeFile (stream) - locked files and unlocking throws error when missing capability', async () => {\n\t\tsetCapabilities(fileProvider, FileSystemProviderCapabilities.FileOpenReadWriteClose);\n\n\t\treturn testLockedFiles(true);\n\t});\n\n\tasync function testLockedFiles(expectError: boolean) {\n\t\tconst lockedFile = URI.file(join(testDir, 'my-locked-file'));\n\n\t\tconst content = await service.writeFile(lockedFile, VSBuffer.fromString('Locked File'));\n\t\tassert.strictEqual(content.locked, false);\n\n\t\tconst stats = await promises.stat(lockedFile.fsPath);\n\t\tawait promises.chmod(lockedFile.fsPath, stats.mode & ~0o200);\n\n\t\tlet stat = await service.stat(lockedFile);\n\t\tassert.strictEqual(stat.locked, true);\n\n\t\tlet error;\n\t\tconst newContent = 'Updates to locked file';\n\t\ttry {\n\t\t\tawait service.writeFile(lockedFile, VSBuffer.fromString(newContent));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t\terror = undefined;\n\n\t\tif (expectError) {\n\t\t\ttry {\n\t\t\t\tawait service.writeFile(lockedFile, VSBuffer.fromString(newContent), { unlock: true });\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\n\t\t\tassert.ok(error);\n\t\t} else {\n\t\t\tawait service.writeFile(lockedFile, VSBuffer.fromString(newContent), { unlock: true });\n\t\t\tassert.strictEqual(readFileSync(lockedFile.fsPath).toString(), newContent);\n\n\t\t\tstat = await service.stat(lockedFile);\n\t\t\tassert.strictEqual(stat.locked, false);\n\t\t}\n\t}\n\n\ttest('writeFile (error when folder is encountered)', async () => {\n\t\tconst resource = URI.file(testDir);\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString('File is created including parent'));\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('writeFile (no error when providing up to date etag)', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst stat = await service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: stat.etag, mtime: stat.mtime });\n\n\t\tassert.strictEqual(readFileSync(resource.fsPath).toString(), newContent);\n\t});\n\n\ttest('writeFile - error when writing to file that has been updated meanwhile', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst stat = await service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: stat.etag, mtime: stat.mtime });\n\n\t\tconst newContentLeadingToError = newContent + newContent;\n\n\t\tconst fakeMtime = 1000;\n\t\tconst fakeSize = 1000;\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContentLeadingToError), { etag: etag({ mtime: fakeMtime, size: fakeSize }), mtime: fakeMtime });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.ok(error instanceof FileOperationError);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_MODIFIED_SINCE);\n\t});\n\n\ttest('writeFile - no error when writing to file where size is the same', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tconst stat = await service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = content; // same content\n\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: stat.etag, mtime: stat.mtime });\n\n\t\tconst newContentLeadingToNoError = newContent; // writing the same content should be OK\n\n\t\tconst fakeMtime = 1000;\n\t\tconst actualSize = newContent.length;\n\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContentLeadingToNoError), { etag: etag({ mtime: fakeMtime, size: actualSize }), mtime: fakeMtime });\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(!error);\n\t});\n\n\ttest('writeFile - no error when writing to file where content is the same', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tawait service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = content; // same content\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: 'anything', mtime: 0 } /* fake it */);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(!error);\n\t});\n\n\ttest('writeFile - error when writing to file where content is the same length but different', async () => {\n\t\tconst resource = URI.file(join(testDir, 'small.txt'));\n\n\t\tawait service.resolve(resource);\n\n\t\tconst content = readFileSync(resource.fsPath).toString();\n\t\tassert.strictEqual(content, 'Small File');\n\n\t\tconst newContent = content.split('').reverse().join(''); // reverse content\n\t\tlet error: FileOperationError | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString(newContent), { etag: 'anything', mtime: 0 } /* fake it */);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t}\n\n\t\tassert.ok(error);\n\t\tassert.ok(error instanceof FileOperationError);\n\t\tassert.strictEqual(error.fileOperationResult, FileOperationResult.FILE_MODIFIED_SINCE);\n\t});\n\n\ttest('writeFile - no error when writing to same nonexistent folder multiple times different new files', async () => {\n\t\tconst newFolder = URI.file(join(testDir, 'some', 'new', 'folder'));\n\n\t\tconst file1 = joinPath(newFolder, 'file-1');\n\t\tconst file2 = joinPath(newFolder, 'file-2');\n\t\tconst file3 = joinPath(newFolder, 'file-3');\n\n\t\t// this essentially verifies that the mkdirp logic implemented\n\t\t// in the file service is able to receive multiple requests for\n\t\t// the same folder and will not throw errors if another racing\n\t\t// call succeeded first.\n\t\tconst newContent = 'Updates to the small file';\n\t\tawait Promise.all([\n\t\t\tservice.writeFile(file1, VSBuffer.fromString(newContent)),\n\t\t\tservice.writeFile(file2, VSBuffer.fromString(newContent)),\n\t\t\tservice.writeFile(file3, VSBuffer.fromString(newContent))\n\t\t]);\n\n\t\tassert.ok(service.exists(file1));\n\t\tassert.ok(service.exists(file2));\n\t\tassert.ok(service.exists(file3));\n\t});\n\n\ttest('writeFile - error when writing to folder that is a file', async () => {\n\t\tconst existingFile = URI.file(join(testDir, 'my-file'));\n\n\t\tawait service.createFile(existingFile);\n\n\t\tconst newFile = joinPath(existingFile, 'file-1');\n\n\t\tlet error;\n\t\tconst newContent = 'Updates to the small file';\n\t\ttry {\n\t\t\tawait service.writeFile(newFile, VSBuffer.fromString(newContent));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error);\n\t});\n\n\ttest('read - mixed positions', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\t// read multiple times from position 0\n\t\tlet buffer = VSBuffer.alloc(1024);\n\t\tlet fd = await fileProvider.open(resource, { create: false });\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tawait fileProvider.read(fd, 0, buffer.buffer, 0, 26);\n\t\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\t\t}\n\t\tawait fileProvider.close(fd);\n\n\t\t// read multiple times at various locations\n\t\tbuffer = VSBuffer.alloc(1024);\n\t\tfd = await fileProvider.open(resource, { create: false });\n\n\t\tlet posInFile = 0;\n\n\t\tawait fileProvider.read(fd, posInFile, buffer.buffer, 0, 26);\n\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\t\tposInFile += 26;\n\n\t\tawait fileProvider.read(fd, posInFile, buffer.buffer, 0, 1);\n\t\tassert.strictEqual(buffer.slice(0, 1).toString(), ',');\n\t\tposInFile += 1;\n\n\t\tawait fileProvider.read(fd, posInFile, buffer.buffer, 0, 12);\n\t\tassert.strictEqual(buffer.slice(0, 12).toString(), ' consectetur');\n\t\tposInFile += 12;\n\n\t\tawait fileProvider.read(fd, 98 /* no longer in sequence of posInFile */, buffer.buffer, 0, 9);\n\t\tassert.strictEqual(buffer.slice(0, 9).toString(), 'fermentum');\n\n\t\tawait fileProvider.read(fd, 27, buffer.buffer, 0, 12);\n\t\tassert.strictEqual(buffer.slice(0, 12).toString(), ' consectetur');\n\n\t\tawait fileProvider.read(fd, 26, buffer.buffer, 0, 1);\n\t\tassert.strictEqual(buffer.slice(0, 1).toString(), ',');\n\n\t\tawait fileProvider.read(fd, 0, buffer.buffer, 0, 26);\n\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\n\t\tawait fileProvider.read(fd, posInFile /* back in sequence */, buffer.buffer, 0, 11);\n\t\tassert.strictEqual(buffer.slice(0, 11).toString(), ' adipiscing');\n\n\t\tawait fileProvider.close(fd);\n\t});\n\n\ttest('write - mixed positions', async () => {\n\t\tconst resource = URI.file(join(testDir, 'lorem.txt'));\n\n\t\tconst buffer = VSBuffer.alloc(1024);\n\t\tconst fdWrite = await fileProvider.open(resource, { create: true, unlock: false });\n\t\tconst fdRead = await fileProvider.open(resource, { create: false });\n\n\t\tlet posInFileWrite = 0;\n\t\tlet posInFileRead = 0;\n\n\t\tconst initialContents = VSBuffer.fromString('Lorem ipsum dolor sit amet');\n\t\tawait fileProvider.write(fdWrite, posInFileWrite, initialContents.buffer, 0, initialContents.byteLength);\n\t\tposInFileWrite += initialContents.byteLength;\n\n\t\tawait fileProvider.read(fdRead, posInFileRead, buffer.buffer, 0, 26);\n\t\tassert.strictEqual(buffer.slice(0, 26).toString(), 'Lorem ipsum dolor sit amet');\n\t\tposInFileRead += 26;\n\n\t\tconst contents = VSBuffer.fromString('Hello World');\n\n\t\tawait fileProvider.write(fdWrite, posInFileWrite, contents.buffer, 0, contents.byteLength);\n\t\tposInFileWrite += contents.byteLength;\n\n\t\tawait fileProvider.read(fdRead, posInFileRead, buffer.buffer, 0, contents.byteLength);\n\t\tassert.strictEqual(buffer.slice(0, contents.byteLength).toString(), 'Hello World');\n\t\tposInFileRead += contents.byteLength;\n\n\t\tawait fileProvider.write(fdWrite, 6, contents.buffer, 0, contents.byteLength);\n\n\t\tawait fileProvider.read(fdRead, 0, buffer.buffer, 0, 11);\n\t\tassert.strictEqual(buffer.slice(0, 11).toString(), 'Lorem Hello');\n\n\t\tawait fileProvider.write(fdWrite, posInFileWrite, contents.buffer, 0, contents.byteLength);\n\t\tposInFileWrite += contents.byteLength;\n\n\t\tawait fileProvider.read(fdRead, posInFileWrite - contents.byteLength, buffer.buffer, 0, contents.byteLength);\n\t\tassert.strictEqual(buffer.slice(0, contents.byteLength).toString(), 'Hello World');\n\n\t\tawait fileProvider.close(fdWrite);\n\t\tawait fileProvider.close(fdRead);\n\t});\n\n\ttest('readonly - is handled properly for a single resource', async () => {\n\t\tfileProvider.setReadonly(true);\n\n\t\tconst resource = URI.file(join(testDir, 'index.html'));\n\n\t\tconst resolveResult = await service.resolve(resource);\n\t\tassert.strictEqual(resolveResult.readonly, true);\n\n\t\tconst readResult = await service.readFile(resource);\n\t\tassert.strictEqual(readResult.readonly, true);\n\n\t\tlet writeFileError: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.writeFile(resource, VSBuffer.fromString('Hello Test'));\n\t\t} catch (error) {\n\t\t\twriteFileError = error;\n\t\t}\n\t\tassert.ok(writeFileError);\n\n\t\tlet deleteFileError: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait service.del(resource);\n\t\t} catch (error) {\n\t\t\tdeleteFileError = error;\n\t\t}\n\t\tassert.ok(deleteFileError);\n\t});\n});\n"]}