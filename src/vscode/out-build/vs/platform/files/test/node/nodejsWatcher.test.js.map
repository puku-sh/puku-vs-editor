{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/test/node/nodejsWatcher.test.ts","vs/platform/files/test/node/nodejsWatcher.test.ts"],"names":[],"mappings":"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","file":"nodejsWatcher.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport assert from 'assert';\nimport { tmpdir } from 'os';\nimport { basename, dirname, join } from '../../../../base/common/path.js';\nimport { Promises, RimRafMode } from '../../../../base/node/pfs.js';\nimport { getRandomTestPath } from '../../../../base/test/node/testUtils.js';\nimport { FileChangeFilter, FileChangeType } from '../../common/files.js';\nimport { INonRecursiveWatchRequest, IRecursiveWatcherWithSubscribe } from '../../common/watcher.js';\nimport { watchFileContents } from '../../node/watcher/nodejs/nodejsWatcherLib.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../../base/common/platform.js';\nimport { getDriveLetter } from '../../../../base/common/extpath.js';\nimport { ltrim } from '../../../../base/common/strings.js';\nimport { DeferredPromise, timeout } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { NodeJSWatcher } from '../../node/watcher/nodejs/nodejsWatcher.js';\nimport { FileAccess } from '../../../../base/common/network.js';\nimport { extUriBiasedIgnorePathCase } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { addUNCHostToAllowlist } from '../../../../base/node/unc.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { TestParcelWatcher } from './parcelWatcher.test.js';\n\n// this suite has shown flaky runs in Azure pipelines where\n// tasks would just hang and timeout after a while (not in\n// mocha but generally). as such they will run only on demand\n// whenever we update the watcher library.\n\nsuite.skip('File Watcher (node.js)', function () {\n\n\tthis.timeout(10000);\n\n\tclass TestNodeJSWatcher extends NodeJSWatcher {\n\n\t\tprotected override readonly suspendedWatchRequestPollingInterval = 100;\n\n\t\tprivate readonly _onDidWatch = this._register(new Emitter<void>());\n\t\treadonly onDidWatch = this._onDidWatch.event;\n\n\t\treadonly onWatchFail = this._onDidWatchFail.event;\n\n\t\tprotected override getUpdateWatchersDelay(): number {\n\t\t\treturn 0;\n\t\t}\n\n\t\tprotected override async doWatch(requests: INonRecursiveWatchRequest[]): Promise<void> {\n\t\t\tawait super.doWatch(requests);\n\t\t\tfor (const watcher of this.watchers) {\n\t\t\t\tawait watcher.instance.ready;\n\t\t\t}\n\n\t\t\tthis._onDidWatch.fire();\n\t\t}\n\t}\n\n\tlet testDir: string;\n\tlet watcher: TestNodeJSWatcher;\n\n\tlet loggingEnabled = false;\n\n\tfunction enableLogging(enable: boolean) {\n\t\tloggingEnabled = enable;\n\t\twatcher?.setVerboseLogging(enable);\n\t}\n\n\tenableLogging(loggingEnabled);\n\n\tsetup(async () => {\n\t\tawait createWatcher(undefined);\n\n\t\t// Rule out strange testing conditions by using the realpath\n\t\t// here. for example, on macOS the tmp dir is potentially a\n\t\t// symlink in some of the root folders, which is a rather\n\t\t// unrealisic case for the file watcher.\n\t\ttestDir = URI.file(getRandomTestPath(fs.realpathSync(tmpdir()), 'vsctests', 'filewatcher')).fsPath;\n\n\t\tconst sourceDir = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/service').fsPath;\n\n\t\tawait Promises.copy(sourceDir, testDir, { preserveSymlinks: false });\n\t});\n\n\tasync function createWatcher(accessor: IRecursiveWatcherWithSubscribe | undefined) {\n\t\tawait watcher?.stop();\n\t\twatcher?.dispose();\n\n\t\twatcher = new TestNodeJSWatcher(accessor);\n\t\twatcher?.setVerboseLogging(loggingEnabled);\n\n\t\twatcher.onDidLogMessage(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[non-recursive watcher test message] ${e.message}`);\n\t\t\t}\n\t\t});\n\n\t\twatcher.onDidError(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[non-recursive watcher test error] ${e}`);\n\t\t\t}\n\t\t});\n\t}\n\n\tteardown(async () => {\n\t\tawait watcher.stop();\n\t\twatcher.dispose();\n\n\t\t// Possible that the file watcher is still holding\n\t\t// onto the folders on Windows specifically and the\n\t\t// unlink would fail. In that case, do not fail the\n\t\t// test suite.\n\t\treturn Promises.rm(testDir).catch(error => console.error(error));\n\t});\n\n\tfunction toMsg(type: FileChangeType): string {\n\t\tswitch (type) {\n\t\t\tcase FileChangeType.ADDED: return 'added';\n\t\t\tcase FileChangeType.DELETED: return 'deleted';\n\t\t\tdefault: return 'changed';\n\t\t}\n\t}\n\n\tasync function awaitEvent(service: TestNodeJSWatcher, path: string, type: FileChangeType, correlationId?: number | null, expectedCount?: number): Promise<void> {\n\t\tif (loggingEnabled) {\n\t\t\tconsole.log(`Awaiting change type '${toMsg(type)}' on file '${path}'`);\n\t\t}\n\n\t\t// Await the event\n\t\tawait new Promise<void>(resolve => {\n\t\t\tlet counter = 0;\n\t\t\tconst disposable = service.onDidChangeFile(events => {\n\t\t\t\tfor (const event of events) {\n\t\t\t\t\tif (extUriBiasedIgnorePathCase.isEqual(event.resource, URI.file(path)) && event.type === type && (correlationId === null || event.cId === correlationId)) {\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tif (typeof expectedCount === 'number' && counter < expectedCount) {\n\t\t\t\t\t\t\tcontinue; // not yet\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\ttest('basics (folder watch)', async function () {\n\t\tconst request = { path: testDir, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\n\t\tconst instance = Array.from(watcher.watchers)[0].instance;\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, false);\n\t\tassert.strictEqual(instance.failed, false);\n\n\t\t// New file\n\t\tconst newFilePath = join(testDir, 'newFile.txt');\n\t\tlet changeFuture: Promise<unknown> = awaitEvent(watcher, newFilePath, FileChangeType.ADDED);\n\t\tawait Promises.writeFile(newFilePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\t// New folder\n\t\tconst newFolderPath = join(testDir, 'New Folder');\n\t\tchangeFuture = awaitEvent(watcher, newFolderPath, FileChangeType.ADDED);\n\t\tawait fs.promises.mkdir(newFolderPath);\n\t\tawait changeFuture;\n\n\t\t// Rename file\n\t\tlet renamedFilePath = join(testDir, 'renamedFile.txt');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, newFilePath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, renamedFilePath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(newFilePath, renamedFilePath);\n\t\tawait changeFuture;\n\n\t\t// Rename folder\n\t\tlet renamedFolderPath = join(testDir, 'Renamed Folder');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, newFolderPath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, renamedFolderPath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(newFolderPath, renamedFolderPath);\n\t\tawait changeFuture;\n\n\t\t// Rename file (same name, different case)\n\t\tconst caseRenamedFilePath = join(testDir, 'RenamedFile.txt');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFilePath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, caseRenamedFilePath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFilePath, caseRenamedFilePath);\n\t\tawait changeFuture;\n\t\trenamedFilePath = caseRenamedFilePath;\n\n\t\t// Rename folder (same name, different case)\n\t\tconst caseRenamedFolderPath = join(testDir, 'REnamed Folder');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFolderPath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, caseRenamedFolderPath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFolderPath, caseRenamedFolderPath);\n\t\tawait changeFuture;\n\t\trenamedFolderPath = caseRenamedFolderPath;\n\n\t\t// Move file\n\t\tconst movedFilepath = join(testDir, 'movedFile.txt');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFilePath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, movedFilepath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFilePath, movedFilepath);\n\t\tawait changeFuture;\n\n\t\t// Move folder\n\t\tconst movedFolderpath = join(testDir, 'Moved Folder');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFolderPath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, movedFolderpath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFolderPath, movedFolderpath);\n\t\tawait changeFuture;\n\n\t\t// Copy file\n\t\tconst copiedFilepath = join(testDir, 'copiedFile.txt');\n\t\tchangeFuture = awaitEvent(watcher, copiedFilepath, FileChangeType.ADDED);\n\t\tawait fs.promises.copyFile(movedFilepath, copiedFilepath);\n\t\tawait changeFuture;\n\n\t\t// Copy folder\n\t\tconst copiedFolderpath = join(testDir, 'Copied Folder');\n\t\tchangeFuture = awaitEvent(watcher, copiedFolderpath, FileChangeType.ADDED);\n\t\tawait Promises.copy(movedFolderpath, copiedFolderpath, { preserveSymlinks: false });\n\t\tawait changeFuture;\n\n\t\t// Change file\n\t\tchangeFuture = awaitEvent(watcher, copiedFilepath, FileChangeType.UPDATED);\n\t\tawait Promises.writeFile(copiedFilepath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Create new file\n\t\tconst anotherNewFilePath = join(testDir, 'anotherNewFile.txt');\n\t\tchangeFuture = awaitEvent(watcher, anotherNewFilePath, FileChangeType.ADDED);\n\t\tawait Promises.writeFile(anotherNewFilePath, 'Hello Another World');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, copiedFilepath, FileChangeType.DELETED);\n\t\tawait fs.promises.unlink(copiedFilepath);\n\t\tawait changeFuture;\n\n\t\t// Delete folder\n\t\tchangeFuture = awaitEvent(watcher, copiedFolderpath, FileChangeType.DELETED);\n\t\tawait fs.promises.rmdir(copiedFolderpath);\n\t\tawait changeFuture;\n\n\t\twatcher.dispose();\n\t});\n\n\ttest('basics (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\n\t\tconst instance = Array.from(watcher.watchers)[0].instance;\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, false);\n\t\tassert.strictEqual(instance.failed, false);\n\n\t\t// Change file\n\t\tlet changeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED);\n\t\tawait fs.promises.unlink(filePath);\n\t\tawait changeFuture;\n\n\t\t// Recreate watcher\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait watcher.watch([]);\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\t// Move file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED);\n\t\tawait Promises.rename(filePath, `${filePath}-moved`);\n\t\tawait changeFuture;\n\t});\n\n\ttest('atomic writes (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\t// Delete + Recreate file\n\t\tconst newFilePath = join(testDir, 'lorem.txt');\n\t\tconst changeFuture: Promise<unknown> = awaitEvent(watcher, newFilePath, FileChangeType.UPDATED);\n\t\tawait fs.promises.unlink(newFilePath);\n\t\tPromises.writeFile(newFilePath, 'Hello Atomic World');\n\t\tawait changeFuture;\n\t});\n\n\ttest('atomic writes (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\t// Delete + Recreate file\n\t\tconst newFilePath = join(filePath);\n\t\tconst changeFuture: Promise<unknown> = awaitEvent(watcher, newFilePath, FileChangeType.UPDATED);\n\t\tawait fs.promises.unlink(newFilePath);\n\t\tPromises.writeFile(newFilePath, 'Hello Atomic World');\n\t\tawait changeFuture;\n\t});\n\n\ttest('multiple events (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\t// multiple add\n\n\t\tconst newFilePath1 = join(testDir, 'newFile-1.txt');\n\t\tconst newFilePath2 = join(testDir, 'newFile-2.txt');\n\t\tconst newFilePath3 = join(testDir, 'newFile-3.txt');\n\n\t\tconst addedFuture1: Promise<unknown> = awaitEvent(watcher, newFilePath1, FileChangeType.ADDED);\n\t\tconst addedFuture2: Promise<unknown> = awaitEvent(watcher, newFilePath2, FileChangeType.ADDED);\n\t\tconst addedFuture3: Promise<unknown> = awaitEvent(watcher, newFilePath3, FileChangeType.ADDED);\n\n\t\tawait Promise.all([\n\t\t\tawait Promises.writeFile(newFilePath1, 'Hello World 1'),\n\t\t\tawait Promises.writeFile(newFilePath2, 'Hello World 2'),\n\t\t\tawait Promises.writeFile(newFilePath3, 'Hello World 3'),\n\t\t]);\n\n\t\tawait Promise.all([addedFuture1, addedFuture2, addedFuture3]);\n\n\t\t// multiple change\n\n\t\tconst changeFuture1: Promise<unknown> = awaitEvent(watcher, newFilePath1, FileChangeType.UPDATED);\n\t\tconst changeFuture2: Promise<unknown> = awaitEvent(watcher, newFilePath2, FileChangeType.UPDATED);\n\t\tconst changeFuture3: Promise<unknown> = awaitEvent(watcher, newFilePath3, FileChangeType.UPDATED);\n\n\t\tawait Promise.all([\n\t\t\tawait Promises.writeFile(newFilePath1, 'Hello Update 1'),\n\t\t\tawait Promises.writeFile(newFilePath2, 'Hello Update 2'),\n\t\t\tawait Promises.writeFile(newFilePath3, 'Hello Update 3'),\n\t\t]);\n\n\t\tawait Promise.all([changeFuture1, changeFuture2, changeFuture3]);\n\n\t\t// copy with multiple files\n\n\t\tconst copyFuture1: Promise<unknown> = awaitEvent(watcher, join(testDir, 'newFile-1-copy.txt'), FileChangeType.ADDED);\n\t\tconst copyFuture2: Promise<unknown> = awaitEvent(watcher, join(testDir, 'newFile-2-copy.txt'), FileChangeType.ADDED);\n\t\tconst copyFuture3: Promise<unknown> = awaitEvent(watcher, join(testDir, 'newFile-3-copy.txt'), FileChangeType.ADDED);\n\n\t\tawait Promise.all([\n\t\t\tPromises.copy(join(testDir, 'newFile-1.txt'), join(testDir, 'newFile-1-copy.txt'), { preserveSymlinks: false }),\n\t\t\tPromises.copy(join(testDir, 'newFile-2.txt'), join(testDir, 'newFile-2-copy.txt'), { preserveSymlinks: false }),\n\t\t\tPromises.copy(join(testDir, 'newFile-3.txt'), join(testDir, 'newFile-3-copy.txt'), { preserveSymlinks: false })\n\t\t]);\n\n\t\tawait Promise.all([copyFuture1, copyFuture2, copyFuture3]);\n\n\t\t// multiple delete\n\n\t\tconst deleteFuture1: Promise<unknown> = awaitEvent(watcher, newFilePath1, FileChangeType.DELETED);\n\t\tconst deleteFuture2: Promise<unknown> = awaitEvent(watcher, newFilePath2, FileChangeType.DELETED);\n\t\tconst deleteFuture3: Promise<unknown> = awaitEvent(watcher, newFilePath3, FileChangeType.DELETED);\n\n\t\tawait Promise.all([\n\t\t\tawait fs.promises.unlink(newFilePath1),\n\t\t\tawait fs.promises.unlink(newFilePath2),\n\t\t\tawait fs.promises.unlink(newFilePath3)\n\t\t]);\n\n\t\tawait Promise.all([deleteFuture1, deleteFuture2, deleteFuture3]);\n\t});\n\n\ttest('multiple events (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\t// multiple change\n\n\t\tconst changeFuture1: Promise<unknown> = awaitEvent(watcher, filePath, FileChangeType.UPDATED);\n\n\t\tawait Promise.all([\n\t\t\tawait Promises.writeFile(filePath, 'Hello Update 1'),\n\t\t\tawait Promises.writeFile(filePath, 'Hello Update 2'),\n\t\t\tawait Promises.writeFile(filePath, 'Hello Update 3'),\n\t\t]);\n\n\t\tawait Promise.all([changeFuture1]);\n\t});\n\n\ttest('excludes can be updated (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: ['**'], recursive: false }]);\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-excludes.txt'));\n\t});\n\n\ttest('excludes are ignored (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: ['**'], recursive: false }]);\n\n\t\treturn basicCrudTest(filePath, true);\n\t});\n\n\ttest('includes can be updated (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: ['nothing'], recursive: false }]);\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('non-includes are ignored (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], includes: ['nothing'], recursive: false }]);\n\n\t\treturn basicCrudTest(filePath, true);\n\t});\n\n\ttest('includes are supported (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: ['**/files-includes.txt'], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('includes are supported (folder watch, relative pattern explicit)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: [{ base: testDir, pattern: 'files-includes.txt' }], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('includes are supported (folder watch, relative pattern implicit)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: ['files-includes.txt'], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('correlationId is supported', async function () {\n\t\tconst correlationId = Math.random();\n\t\tawait watcher.watch([{ correlationId, path: testDir, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'newFile.txt'), undefined, correlationId);\n\t});\n\n\t(isWindows /* windows: cannot create file symbolic link without elevated context */ ? test.skip : test)('symlink support (folder watch)', async function () {\n\t\tconst link = join(testDir, 'deep-linked');\n\t\tconst linkTarget = join(testDir, 'deep');\n\t\tawait fs.promises.symlink(linkTarget, link);\n\n\t\tawait watcher.watch([{ path: link, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(link, 'newFile.txt'));\n\t});\n\n\tasync function basicCrudTest(filePath: string, skipAdd?: boolean, correlationId?: number | null, expectedCount?: number, awaitWatchAfterAdd?: boolean): Promise<void> {\n\t\tlet changeFuture: Promise<unknown>;\n\n\t\t// New file\n\t\tif (!skipAdd) {\n\t\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.ADDED, correlationId, expectedCount);\n\t\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\t\tawait changeFuture;\n\t\t\tif (awaitWatchAfterAdd) {\n\t\t\t\tawait Event.toPromise(watcher.onDidWatch);\n\t\t\t}\n\t\t}\n\n\t\t// Change file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, correlationId, expectedCount);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, correlationId, expectedCount);\n\t\tawait fs.promises.unlink(await Promises.realpath(filePath)); // support symlinks\n\t\tawait changeFuture;\n\t}\n\n\t(isWindows /* windows: cannot create file symbolic link without elevated context */ ? test.skip : test)('symlink support (file watch)', async function () {\n\t\tconst link = join(testDir, 'lorem.txt-linked');\n\t\tconst linkTarget = join(testDir, 'lorem.txt');\n\t\tawait fs.promises.symlink(linkTarget, link);\n\n\t\tawait watcher.watch([{ path: link, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(link, true);\n\t});\n\n\t(!isWindows /* UNC is windows only */ ? test.skip : test)('unc support (folder watch)', async function () {\n\t\taddUNCHostToAllowlist('localhost');\n\n\t\t// Local UNC paths are in the form of: \\\\localhost\\c$\\my_dir\n\t\tconst uncPath = `\\\\\\\\localhost\\\\${getDriveLetter(testDir)?.toLowerCase()}$\\\\${ltrim(testDir.substr(testDir.indexOf(':') + 1), '\\\\')}`;\n\n\t\tawait watcher.watch([{ path: uncPath, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(uncPath, 'newFile.txt'));\n\t});\n\n\t(!isWindows /* UNC is windows only */ ? test.skip : test)('unc support (file watch)', async function () {\n\t\taddUNCHostToAllowlist('localhost');\n\n\t\t// Local UNC paths are in the form of: \\\\localhost\\c$\\my_dir\n\t\tconst uncPath = `\\\\\\\\localhost\\\\${getDriveLetter(testDir)?.toLowerCase()}$\\\\${ltrim(testDir.substr(testDir.indexOf(':') + 1), '\\\\')}\\\\lorem.txt`;\n\n\t\tawait watcher.watch([{ path: uncPath, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(uncPath, true);\n\t});\n\n\t(isLinux /* linux: is case sensitive */ ? test.skip : test)('wrong casing (folder watch)', async function () {\n\t\tconst wrongCase = join(dirname(testDir), basename(testDir).toUpperCase());\n\n\t\tawait watcher.watch([{ path: wrongCase, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(wrongCase, 'newFile.txt'));\n\t});\n\n\t(isLinux /* linux: is case sensitive */ ? test.skip : test)('wrong casing (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'LOREM.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(filePath, true);\n\t});\n\n\ttest('invalid path does not explode', async function () {\n\t\tconst invalidPath = join(testDir, 'invalid');\n\n\t\tawait watcher.watch([{ path: invalidPath, excludes: [], recursive: false }]);\n\t});\n\n\ttest('watchFileContents', async function () {\n\t\tconst watchedPath = join(testDir, 'lorem.txt');\n\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst readyPromise = new DeferredPromise<void>();\n\t\tconst chunkPromise = new DeferredPromise<void>();\n\t\tconst watchPromise = watchFileContents(watchedPath, () => chunkPromise.complete(), () => readyPromise.complete(), cts.token);\n\n\t\tawait readyPromise.p;\n\n\t\tPromises.writeFile(watchedPath, 'Hello World');\n\n\t\tawait chunkPromise.p;\n\n\t\tcts.cancel(); // this will resolve `watchPromise`\n\n\t\treturn watchPromise;\n\t});\n\n\ttest('watching same or overlapping paths supported when correlation is applied', async function () {\n\t\tawait watcher.watch([\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: 1 }\n\t\t]);\n\n\t\tawait basicCrudTest(join(testDir, 'newFile_1.txt'), undefined, null, 1);\n\n\t\tawait watcher.watch([\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: 1 },\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: 2, },\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: undefined }\n\t\t]);\n\n\t\tawait basicCrudTest(join(testDir, 'newFile_2.txt'), undefined, null, 3);\n\t\tawait basicCrudTest(join(testDir, 'otherNewFile.txt'), undefined, null, 3);\n\t});\n\n\ttest('watching missing path emits watcher fail event', async function () {\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\n\t\tconst folderPath = join(testDir, 'missing');\n\t\twatcher.watch([{ path: folderPath, excludes: [], recursive: true }]);\n\n\t\tawait onDidWatchFail;\n\t});\n\n\ttest('deleting watched path emits watcher fail and delete event when correlated (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false, correlationId: 1 }]);\n\n\t\tconst instance = Array.from(watcher.watchers)[0].instance;\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst changeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, 1);\n\t\tfs.promises.unlink(filePath);\n\t\tawait onDidWatchFail;\n\t\tawait changeFuture;\n\t\tassert.strictEqual(instance.failed, true);\n\t});\n\n\t(isMacintosh || isWindows /* macOS: does not seem to report deletes on folders | Windows: reports on('error') event only */ ? test.skip : test)('deleting watched path emits watcher fail and delete event when correlated (folder watch)', async function () {\n\t\tconst folderPath = join(testDir, 'deep');\n\n\t\tawait watcher.watch([{ path: folderPath, excludes: [], recursive: false, correlationId: 1 }]);\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst changeFuture = awaitEvent(watcher, folderPath, FileChangeType.DELETED, 1);\n\t\tPromises.rm(folderPath, RimRafMode.UNLINK);\n\t\tawait onDidWatchFail;\n\t\tawait changeFuture;\n\t});\n\n\ttest('watch requests support suspend/resume (file, does not exist in beginning)', async function () {\n\t\tconst filePath = join(testDir, 'not-found.txt');\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), 'polling');\n\n\t\tawait basicCrudTest(filePath, undefined, null, undefined, true);\n\t\tawait basicCrudTest(filePath, undefined, null, undefined, true);\n\t});\n\n\ttest('watch requests support suspend/resume (file, exists in beginning)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tawait basicCrudTest(filePath, true);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), 'polling');\n\n\t\tawait basicCrudTest(filePath, undefined, null, undefined, true);\n\t});\n\n\t(isWindows /* Windows: does not seem to report this */ ? test.skip : test)('watch requests support suspend/resume (folder, does not exist in beginning)', async function () {\n\t\tlet onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\n\t\tconst folderPath = join(testDir, 'not-found');\n\t\tconst request = { path: folderPath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), 'polling');\n\n\t\tlet changeFuture = awaitEvent(watcher, folderPath, FileChangeType.ADDED);\n\t\tlet onDidWatch = Event.toPromise(watcher.onDidWatch);\n\t\tawait fs.promises.mkdir(folderPath);\n\t\tawait changeFuture;\n\t\tawait onDidWatch;\n\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\n\t\tif (isWindows) { // somehow failing on macOS/Linux\n\t\t\tconst filePath = join(folderPath, 'newFile.txt');\n\t\t\tawait basicCrudTest(filePath);\n\n\t\t\tonDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\t\tawait fs.promises.rmdir(folderPath);\n\t\t\tawait onDidWatchFail;\n\n\t\t\tchangeFuture = awaitEvent(watcher, folderPath, FileChangeType.ADDED);\n\t\t\tonDidWatch = Event.toPromise(watcher.onDidWatch);\n\t\t\tawait fs.promises.mkdir(folderPath);\n\t\t\tawait changeFuture;\n\t\t\tawait onDidWatch;\n\n\t\t\tawait timeout(500); // somehow needed on Linux\n\n\t\t\tawait basicCrudTest(filePath);\n\t\t}\n\t});\n\n\t(isMacintosh /* macOS: does not seem to report this */ ? test.skip : test)('watch requests support suspend/resume (folder, exists in beginning)', async function () {\n\t\tconst folderPath = join(testDir, 'deep');\n\t\tawait watcher.watch([{ path: folderPath, excludes: [], recursive: false }]);\n\n\t\tconst filePath = join(folderPath, 'newFile.txt');\n\t\tawait basicCrudTest(filePath);\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tawait Promises.rm(folderPath);\n\t\tawait onDidWatchFail;\n\n\t\tconst changeFuture = awaitEvent(watcher, folderPath, FileChangeType.ADDED);\n\t\tconst onDidWatch = Event.toPromise(watcher.onDidWatch);\n\t\tawait fs.promises.mkdir(folderPath);\n\t\tawait changeFuture;\n\t\tawait onDidWatch;\n\n\t\tawait timeout(500); // somehow needed on Linux\n\n\t\tawait basicCrudTest(filePath);\n\t});\n\n\ttest('parcel watcher reused when present for non-recursive file watching (uncorrelated)', function () {\n\t\treturn testParcelWatcherReused(undefined);\n\t});\n\n\ttest('parcel watcher reused when present for non-recursive file watching (correlated)', function () {\n\t\treturn testParcelWatcherReused(2);\n\t});\n\n\tfunction createParcelWatcher() {\n\t\tconst recursiveWatcher = new TestParcelWatcher();\n\t\trecursiveWatcher.setVerboseLogging(loggingEnabled);\n\t\trecursiveWatcher.onDidLogMessage(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[recursive watcher test message] ${e.message}`);\n\t\t\t}\n\t\t});\n\n\t\trecursiveWatcher.onDidError(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[recursive watcher test error] ${e.error}`);\n\t\t\t}\n\t\t});\n\n\t\treturn recursiveWatcher;\n\t}\n\n\tasync function testParcelWatcherReused(correlationId: number | undefined) {\n\t\tconst recursiveWatcher = createParcelWatcher();\n\t\tawait recursiveWatcher.watch([{ path: testDir, excludes: [], recursive: true, correlationId: 1 }]);\n\n\t\tconst recursiveInstance = Array.from(recursiveWatcher.watchers)[0];\n\t\tassert.strictEqual(recursiveInstance.subscriptionsCount, 0);\n\n\t\tawait createWatcher(recursiveWatcher);\n\n\t\tconst filePath = join(testDir, 'deep', 'conway.js');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false, correlationId }]);\n\n\t\tconst { instance } = Array.from(watcher.watchers)[0];\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, true);\n\t\tassert.strictEqual(recursiveInstance.subscriptionsCount, 1);\n\n\t\tlet changeFuture = awaitEvent(watcher, filePath, isMacintosh /* somehow fsevents seems to report still on the initial create from test setup */ ? FileChangeType.ADDED : FileChangeType.UPDATED, correlationId);\n\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\tawait recursiveWatcher.stop();\n\t\trecursiveWatcher.dispose();\n\n\t\tawait timeout(500); // give the watcher some time to restart\n\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, correlationId);\n\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, false);\n\t}\n\n\ttest('watch requests support suspend/resume (file, does not exist in beginning, parcel watcher reused)', async function () {\n\t\tconst recursiveWatcher = createParcelWatcher();\n\t\tawait recursiveWatcher.watch([{ path: testDir, excludes: [], recursive: true }]);\n\n\t\tawait createWatcher(recursiveWatcher);\n\n\t\tconst filePath = join(testDir, 'not-found-2.txt');\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), true);\n\n\t\tconst changeFuture = awaitEvent(watcher, filePath, FileChangeType.ADDED);\n\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\t});\n\n\ttest('event type filter (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tconst request = { path: filePath, excludes: [], recursive: false, filter: FileChangeFilter.UPDATED | FileChangeFilter.DELETED, correlationId: 1 };\n\t\tawait watcher.watch([request]);\n\n\t\t// Change file\n\t\tlet changeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, 1);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, 1);\n\t\tawait fs.promises.unlink(filePath);\n\t\tawait changeFuture;\n\t});\n\n\ttest('event type filter (folder watch)', async function () {\n\t\tconst request = { path: testDir, excludes: [], recursive: false, filter: FileChangeFilter.UPDATED | FileChangeFilter.DELETED, correlationId: 1 };\n\t\tawait watcher.watch([request]);\n\n\t\t// Change file\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tlet changeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, 1);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, 1);\n\t\tawait fs.promises.unlink(filePath);\n\t\tawait changeFuture;\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport assert from 'assert';\nimport { tmpdir } from 'os';\nimport { basename, dirname, join } from '../../../../base/common/path.js';\nimport { Promises, RimRafMode } from '../../../../base/node/pfs.js';\nimport { getRandomTestPath } from '../../../../base/test/node/testUtils.js';\nimport { FileChangeFilter, FileChangeType } from '../../common/files.js';\nimport { INonRecursiveWatchRequest, IRecursiveWatcherWithSubscribe } from '../../common/watcher.js';\nimport { watchFileContents } from '../../node/watcher/nodejs/nodejsWatcherLib.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../../base/common/platform.js';\nimport { getDriveLetter } from '../../../../base/common/extpath.js';\nimport { ltrim } from '../../../../base/common/strings.js';\nimport { DeferredPromise, timeout } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { NodeJSWatcher } from '../../node/watcher/nodejs/nodejsWatcher.js';\nimport { FileAccess } from '../../../../base/common/network.js';\nimport { extUriBiasedIgnorePathCase } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { addUNCHostToAllowlist } from '../../../../base/node/unc.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { TestParcelWatcher } from './parcelWatcher.test.js';\n\n// this suite has shown flaky runs in Azure pipelines where\n// tasks would just hang and timeout after a while (not in\n// mocha but generally). as such they will run only on demand\n// whenever we update the watcher library.\n\nsuite.skip('File Watcher (node.js)', function () {\n\n\tthis.timeout(10000);\n\n\tclass TestNodeJSWatcher extends NodeJSWatcher {\n\n\t\tprotected override readonly suspendedWatchRequestPollingInterval = 100;\n\n\t\tprivate readonly _onDidWatch = this._register(new Emitter<void>());\n\t\treadonly onDidWatch = this._onDidWatch.event;\n\n\t\treadonly onWatchFail = this._onDidWatchFail.event;\n\n\t\tprotected override getUpdateWatchersDelay(): number {\n\t\t\treturn 0;\n\t\t}\n\n\t\tprotected override async doWatch(requests: INonRecursiveWatchRequest[]): Promise<void> {\n\t\t\tawait super.doWatch(requests);\n\t\t\tfor (const watcher of this.watchers) {\n\t\t\t\tawait watcher.instance.ready;\n\t\t\t}\n\n\t\t\tthis._onDidWatch.fire();\n\t\t}\n\t}\n\n\tlet testDir: string;\n\tlet watcher: TestNodeJSWatcher;\n\n\tlet loggingEnabled = false;\n\n\tfunction enableLogging(enable: boolean) {\n\t\tloggingEnabled = enable;\n\t\twatcher?.setVerboseLogging(enable);\n\t}\n\n\tenableLogging(loggingEnabled);\n\n\tsetup(async () => {\n\t\tawait createWatcher(undefined);\n\n\t\t// Rule out strange testing conditions by using the realpath\n\t\t// here. for example, on macOS the tmp dir is potentially a\n\t\t// symlink in some of the root folders, which is a rather\n\t\t// unrealisic case for the file watcher.\n\t\ttestDir = URI.file(getRandomTestPath(fs.realpathSync(tmpdir()), 'vsctests', 'filewatcher')).fsPath;\n\n\t\tconst sourceDir = FileAccess.asFileUri('vs/platform/files/test/node/fixtures/service').fsPath;\n\n\t\tawait Promises.copy(sourceDir, testDir, { preserveSymlinks: false });\n\t});\n\n\tasync function createWatcher(accessor: IRecursiveWatcherWithSubscribe | undefined) {\n\t\tawait watcher?.stop();\n\t\twatcher?.dispose();\n\n\t\twatcher = new TestNodeJSWatcher(accessor);\n\t\twatcher?.setVerboseLogging(loggingEnabled);\n\n\t\twatcher.onDidLogMessage(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[non-recursive watcher test message] ${e.message}`);\n\t\t\t}\n\t\t});\n\n\t\twatcher.onDidError(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[non-recursive watcher test error] ${e}`);\n\t\t\t}\n\t\t});\n\t}\n\n\tteardown(async () => {\n\t\tawait watcher.stop();\n\t\twatcher.dispose();\n\n\t\t// Possible that the file watcher is still holding\n\t\t// onto the folders on Windows specifically and the\n\t\t// unlink would fail. In that case, do not fail the\n\t\t// test suite.\n\t\treturn Promises.rm(testDir).catch(error => console.error(error));\n\t});\n\n\tfunction toMsg(type: FileChangeType): string {\n\t\tswitch (type) {\n\t\t\tcase FileChangeType.ADDED: return 'added';\n\t\t\tcase FileChangeType.DELETED: return 'deleted';\n\t\t\tdefault: return 'changed';\n\t\t}\n\t}\n\n\tasync function awaitEvent(service: TestNodeJSWatcher, path: string, type: FileChangeType, correlationId?: number | null, expectedCount?: number): Promise<void> {\n\t\tif (loggingEnabled) {\n\t\t\tconsole.log(`Awaiting change type '${toMsg(type)}' on file '${path}'`);\n\t\t}\n\n\t\t// Await the event\n\t\tawait new Promise<void>(resolve => {\n\t\t\tlet counter = 0;\n\t\t\tconst disposable = service.onDidChangeFile(events => {\n\t\t\t\tfor (const event of events) {\n\t\t\t\t\tif (extUriBiasedIgnorePathCase.isEqual(event.resource, URI.file(path)) && event.type === type && (correlationId === null || event.cId === correlationId)) {\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tif (typeof expectedCount === 'number' && counter < expectedCount) {\n\t\t\t\t\t\t\tcontinue; // not yet\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\ttest('basics (folder watch)', async function () {\n\t\tconst request = { path: testDir, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\n\t\tconst instance = Array.from(watcher.watchers)[0].instance;\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, false);\n\t\tassert.strictEqual(instance.failed, false);\n\n\t\t// New file\n\t\tconst newFilePath = join(testDir, 'newFile.txt');\n\t\tlet changeFuture: Promise<unknown> = awaitEvent(watcher, newFilePath, FileChangeType.ADDED);\n\t\tawait Promises.writeFile(newFilePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\t// New folder\n\t\tconst newFolderPath = join(testDir, 'New Folder');\n\t\tchangeFuture = awaitEvent(watcher, newFolderPath, FileChangeType.ADDED);\n\t\tawait fs.promises.mkdir(newFolderPath);\n\t\tawait changeFuture;\n\n\t\t// Rename file\n\t\tlet renamedFilePath = join(testDir, 'renamedFile.txt');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, newFilePath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, renamedFilePath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(newFilePath, renamedFilePath);\n\t\tawait changeFuture;\n\n\t\t// Rename folder\n\t\tlet renamedFolderPath = join(testDir, 'Renamed Folder');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, newFolderPath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, renamedFolderPath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(newFolderPath, renamedFolderPath);\n\t\tawait changeFuture;\n\n\t\t// Rename file (same name, different case)\n\t\tconst caseRenamedFilePath = join(testDir, 'RenamedFile.txt');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFilePath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, caseRenamedFilePath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFilePath, caseRenamedFilePath);\n\t\tawait changeFuture;\n\t\trenamedFilePath = caseRenamedFilePath;\n\n\t\t// Rename folder (same name, different case)\n\t\tconst caseRenamedFolderPath = join(testDir, 'REnamed Folder');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFolderPath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, caseRenamedFolderPath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFolderPath, caseRenamedFolderPath);\n\t\tawait changeFuture;\n\t\trenamedFolderPath = caseRenamedFolderPath;\n\n\t\t// Move file\n\t\tconst movedFilepath = join(testDir, 'movedFile.txt');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFilePath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, movedFilepath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFilePath, movedFilepath);\n\t\tawait changeFuture;\n\n\t\t// Move folder\n\t\tconst movedFolderpath = join(testDir, 'Moved Folder');\n\t\tchangeFuture = Promise.all([\n\t\t\tawaitEvent(watcher, renamedFolderPath, FileChangeType.DELETED),\n\t\t\tawaitEvent(watcher, movedFolderpath, FileChangeType.ADDED)\n\t\t]);\n\t\tawait Promises.rename(renamedFolderPath, movedFolderpath);\n\t\tawait changeFuture;\n\n\t\t// Copy file\n\t\tconst copiedFilepath = join(testDir, 'copiedFile.txt');\n\t\tchangeFuture = awaitEvent(watcher, copiedFilepath, FileChangeType.ADDED);\n\t\tawait fs.promises.copyFile(movedFilepath, copiedFilepath);\n\t\tawait changeFuture;\n\n\t\t// Copy folder\n\t\tconst copiedFolderpath = join(testDir, 'Copied Folder');\n\t\tchangeFuture = awaitEvent(watcher, copiedFolderpath, FileChangeType.ADDED);\n\t\tawait Promises.copy(movedFolderpath, copiedFolderpath, { preserveSymlinks: false });\n\t\tawait changeFuture;\n\n\t\t// Change file\n\t\tchangeFuture = awaitEvent(watcher, copiedFilepath, FileChangeType.UPDATED);\n\t\tawait Promises.writeFile(copiedFilepath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Create new file\n\t\tconst anotherNewFilePath = join(testDir, 'anotherNewFile.txt');\n\t\tchangeFuture = awaitEvent(watcher, anotherNewFilePath, FileChangeType.ADDED);\n\t\tawait Promises.writeFile(anotherNewFilePath, 'Hello Another World');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, copiedFilepath, FileChangeType.DELETED);\n\t\tawait fs.promises.unlink(copiedFilepath);\n\t\tawait changeFuture;\n\n\t\t// Delete folder\n\t\tchangeFuture = awaitEvent(watcher, copiedFolderpath, FileChangeType.DELETED);\n\t\tawait fs.promises.rmdir(copiedFolderpath);\n\t\tawait changeFuture;\n\n\t\twatcher.dispose();\n\t});\n\n\ttest('basics (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\n\t\tconst instance = Array.from(watcher.watchers)[0].instance;\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, false);\n\t\tassert.strictEqual(instance.failed, false);\n\n\t\t// Change file\n\t\tlet changeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED);\n\t\tawait fs.promises.unlink(filePath);\n\t\tawait changeFuture;\n\n\t\t// Recreate watcher\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait watcher.watch([]);\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\t// Move file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED);\n\t\tawait Promises.rename(filePath, `${filePath}-moved`);\n\t\tawait changeFuture;\n\t});\n\n\ttest('atomic writes (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\t// Delete + Recreate file\n\t\tconst newFilePath = join(testDir, 'lorem.txt');\n\t\tconst changeFuture: Promise<unknown> = awaitEvent(watcher, newFilePath, FileChangeType.UPDATED);\n\t\tawait fs.promises.unlink(newFilePath);\n\t\tPromises.writeFile(newFilePath, 'Hello Atomic World');\n\t\tawait changeFuture;\n\t});\n\n\ttest('atomic writes (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\t// Delete + Recreate file\n\t\tconst newFilePath = join(filePath);\n\t\tconst changeFuture: Promise<unknown> = awaitEvent(watcher, newFilePath, FileChangeType.UPDATED);\n\t\tawait fs.promises.unlink(newFilePath);\n\t\tPromises.writeFile(newFilePath, 'Hello Atomic World');\n\t\tawait changeFuture;\n\t});\n\n\ttest('multiple events (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\t// multiple add\n\n\t\tconst newFilePath1 = join(testDir, 'newFile-1.txt');\n\t\tconst newFilePath2 = join(testDir, 'newFile-2.txt');\n\t\tconst newFilePath3 = join(testDir, 'newFile-3.txt');\n\n\t\tconst addedFuture1: Promise<unknown> = awaitEvent(watcher, newFilePath1, FileChangeType.ADDED);\n\t\tconst addedFuture2: Promise<unknown> = awaitEvent(watcher, newFilePath2, FileChangeType.ADDED);\n\t\tconst addedFuture3: Promise<unknown> = awaitEvent(watcher, newFilePath3, FileChangeType.ADDED);\n\n\t\tawait Promise.all([\n\t\t\tawait Promises.writeFile(newFilePath1, 'Hello World 1'),\n\t\t\tawait Promises.writeFile(newFilePath2, 'Hello World 2'),\n\t\t\tawait Promises.writeFile(newFilePath3, 'Hello World 3'),\n\t\t]);\n\n\t\tawait Promise.all([addedFuture1, addedFuture2, addedFuture3]);\n\n\t\t// multiple change\n\n\t\tconst changeFuture1: Promise<unknown> = awaitEvent(watcher, newFilePath1, FileChangeType.UPDATED);\n\t\tconst changeFuture2: Promise<unknown> = awaitEvent(watcher, newFilePath2, FileChangeType.UPDATED);\n\t\tconst changeFuture3: Promise<unknown> = awaitEvent(watcher, newFilePath3, FileChangeType.UPDATED);\n\n\t\tawait Promise.all([\n\t\t\tawait Promises.writeFile(newFilePath1, 'Hello Update 1'),\n\t\t\tawait Promises.writeFile(newFilePath2, 'Hello Update 2'),\n\t\t\tawait Promises.writeFile(newFilePath3, 'Hello Update 3'),\n\t\t]);\n\n\t\tawait Promise.all([changeFuture1, changeFuture2, changeFuture3]);\n\n\t\t// copy with multiple files\n\n\t\tconst copyFuture1: Promise<unknown> = awaitEvent(watcher, join(testDir, 'newFile-1-copy.txt'), FileChangeType.ADDED);\n\t\tconst copyFuture2: Promise<unknown> = awaitEvent(watcher, join(testDir, 'newFile-2-copy.txt'), FileChangeType.ADDED);\n\t\tconst copyFuture3: Promise<unknown> = awaitEvent(watcher, join(testDir, 'newFile-3-copy.txt'), FileChangeType.ADDED);\n\n\t\tawait Promise.all([\n\t\t\tPromises.copy(join(testDir, 'newFile-1.txt'), join(testDir, 'newFile-1-copy.txt'), { preserveSymlinks: false }),\n\t\t\tPromises.copy(join(testDir, 'newFile-2.txt'), join(testDir, 'newFile-2-copy.txt'), { preserveSymlinks: false }),\n\t\t\tPromises.copy(join(testDir, 'newFile-3.txt'), join(testDir, 'newFile-3-copy.txt'), { preserveSymlinks: false })\n\t\t]);\n\n\t\tawait Promise.all([copyFuture1, copyFuture2, copyFuture3]);\n\n\t\t// multiple delete\n\n\t\tconst deleteFuture1: Promise<unknown> = awaitEvent(watcher, newFilePath1, FileChangeType.DELETED);\n\t\tconst deleteFuture2: Promise<unknown> = awaitEvent(watcher, newFilePath2, FileChangeType.DELETED);\n\t\tconst deleteFuture3: Promise<unknown> = awaitEvent(watcher, newFilePath3, FileChangeType.DELETED);\n\n\t\tawait Promise.all([\n\t\t\tawait fs.promises.unlink(newFilePath1),\n\t\t\tawait fs.promises.unlink(newFilePath2),\n\t\t\tawait fs.promises.unlink(newFilePath3)\n\t\t]);\n\n\t\tawait Promise.all([deleteFuture1, deleteFuture2, deleteFuture3]);\n\t});\n\n\ttest('multiple events (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\t// multiple change\n\n\t\tconst changeFuture1: Promise<unknown> = awaitEvent(watcher, filePath, FileChangeType.UPDATED);\n\n\t\tawait Promise.all([\n\t\t\tawait Promises.writeFile(filePath, 'Hello Update 1'),\n\t\t\tawait Promises.writeFile(filePath, 'Hello Update 2'),\n\t\t\tawait Promises.writeFile(filePath, 'Hello Update 3'),\n\t\t]);\n\n\t\tawait Promise.all([changeFuture1]);\n\t});\n\n\ttest('excludes can be updated (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: ['**'], recursive: false }]);\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-excludes.txt'));\n\t});\n\n\ttest('excludes are ignored (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: ['**'], recursive: false }]);\n\n\t\treturn basicCrudTest(filePath, true);\n\t});\n\n\ttest('includes can be updated (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: ['nothing'], recursive: false }]);\n\t\tawait watcher.watch([{ path: testDir, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('non-includes are ignored (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], includes: ['nothing'], recursive: false }]);\n\n\t\treturn basicCrudTest(filePath, true);\n\t});\n\n\ttest('includes are supported (folder watch)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: ['**/files-includes.txt'], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('includes are supported (folder watch, relative pattern explicit)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: [{ base: testDir, pattern: 'files-includes.txt' }], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('includes are supported (folder watch, relative pattern implicit)', async function () {\n\t\tawait watcher.watch([{ path: testDir, excludes: [], includes: ['files-includes.txt'], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'files-includes.txt'));\n\t});\n\n\ttest('correlationId is supported', async function () {\n\t\tconst correlationId = Math.random();\n\t\tawait watcher.watch([{ correlationId, path: testDir, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(testDir, 'newFile.txt'), undefined, correlationId);\n\t});\n\n\t(isWindows /* windows: cannot create file symbolic link without elevated context */ ? test.skip : test)('symlink support (folder watch)', async function () {\n\t\tconst link = join(testDir, 'deep-linked');\n\t\tconst linkTarget = join(testDir, 'deep');\n\t\tawait fs.promises.symlink(linkTarget, link);\n\n\t\tawait watcher.watch([{ path: link, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(link, 'newFile.txt'));\n\t});\n\n\tasync function basicCrudTest(filePath: string, skipAdd?: boolean, correlationId?: number | null, expectedCount?: number, awaitWatchAfterAdd?: boolean): Promise<void> {\n\t\tlet changeFuture: Promise<unknown>;\n\n\t\t// New file\n\t\tif (!skipAdd) {\n\t\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.ADDED, correlationId, expectedCount);\n\t\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\t\tawait changeFuture;\n\t\t\tif (awaitWatchAfterAdd) {\n\t\t\t\tawait Event.toPromise(watcher.onDidWatch);\n\t\t\t}\n\t\t}\n\n\t\t// Change file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, correlationId, expectedCount);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, correlationId, expectedCount);\n\t\tawait fs.promises.unlink(await Promises.realpath(filePath)); // support symlinks\n\t\tawait changeFuture;\n\t}\n\n\t(isWindows /* windows: cannot create file symbolic link without elevated context */ ? test.skip : test)('symlink support (file watch)', async function () {\n\t\tconst link = join(testDir, 'lorem.txt-linked');\n\t\tconst linkTarget = join(testDir, 'lorem.txt');\n\t\tawait fs.promises.symlink(linkTarget, link);\n\n\t\tawait watcher.watch([{ path: link, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(link, true);\n\t});\n\n\t(!isWindows /* UNC is windows only */ ? test.skip : test)('unc support (folder watch)', async function () {\n\t\taddUNCHostToAllowlist('localhost');\n\n\t\t// Local UNC paths are in the form of: \\\\localhost\\c$\\my_dir\n\t\tconst uncPath = `\\\\\\\\localhost\\\\${getDriveLetter(testDir)?.toLowerCase()}$\\\\${ltrim(testDir.substr(testDir.indexOf(':') + 1), '\\\\')}`;\n\n\t\tawait watcher.watch([{ path: uncPath, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(uncPath, 'newFile.txt'));\n\t});\n\n\t(!isWindows /* UNC is windows only */ ? test.skip : test)('unc support (file watch)', async function () {\n\t\taddUNCHostToAllowlist('localhost');\n\n\t\t// Local UNC paths are in the form of: \\\\localhost\\c$\\my_dir\n\t\tconst uncPath = `\\\\\\\\localhost\\\\${getDriveLetter(testDir)?.toLowerCase()}$\\\\${ltrim(testDir.substr(testDir.indexOf(':') + 1), '\\\\')}\\\\lorem.txt`;\n\n\t\tawait watcher.watch([{ path: uncPath, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(uncPath, true);\n\t});\n\n\t(isLinux /* linux: is case sensitive */ ? test.skip : test)('wrong casing (folder watch)', async function () {\n\t\tconst wrongCase = join(dirname(testDir), basename(testDir).toUpperCase());\n\n\t\tawait watcher.watch([{ path: wrongCase, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(join(wrongCase, 'newFile.txt'));\n\t});\n\n\t(isLinux /* linux: is case sensitive */ ? test.skip : test)('wrong casing (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'LOREM.txt');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false }]);\n\n\t\treturn basicCrudTest(filePath, true);\n\t});\n\n\ttest('invalid path does not explode', async function () {\n\t\tconst invalidPath = join(testDir, 'invalid');\n\n\t\tawait watcher.watch([{ path: invalidPath, excludes: [], recursive: false }]);\n\t});\n\n\ttest('watchFileContents', async function () {\n\t\tconst watchedPath = join(testDir, 'lorem.txt');\n\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst readyPromise = new DeferredPromise<void>();\n\t\tconst chunkPromise = new DeferredPromise<void>();\n\t\tconst watchPromise = watchFileContents(watchedPath, () => chunkPromise.complete(), () => readyPromise.complete(), cts.token);\n\n\t\tawait readyPromise.p;\n\n\t\tPromises.writeFile(watchedPath, 'Hello World');\n\n\t\tawait chunkPromise.p;\n\n\t\tcts.cancel(); // this will resolve `watchPromise`\n\n\t\treturn watchPromise;\n\t});\n\n\ttest('watching same or overlapping paths supported when correlation is applied', async function () {\n\t\tawait watcher.watch([\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: 1 }\n\t\t]);\n\n\t\tawait basicCrudTest(join(testDir, 'newFile_1.txt'), undefined, null, 1);\n\n\t\tawait watcher.watch([\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: 1 },\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: 2, },\n\t\t\t{ path: testDir, excludes: [], recursive: false, correlationId: undefined }\n\t\t]);\n\n\t\tawait basicCrudTest(join(testDir, 'newFile_2.txt'), undefined, null, 3);\n\t\tawait basicCrudTest(join(testDir, 'otherNewFile.txt'), undefined, null, 3);\n\t});\n\n\ttest('watching missing path emits watcher fail event', async function () {\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\n\t\tconst folderPath = join(testDir, 'missing');\n\t\twatcher.watch([{ path: folderPath, excludes: [], recursive: true }]);\n\n\t\tawait onDidWatchFail;\n\t});\n\n\ttest('deleting watched path emits watcher fail and delete event when correlated (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false, correlationId: 1 }]);\n\n\t\tconst instance = Array.from(watcher.watchers)[0].instance;\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst changeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, 1);\n\t\tfs.promises.unlink(filePath);\n\t\tawait onDidWatchFail;\n\t\tawait changeFuture;\n\t\tassert.strictEqual(instance.failed, true);\n\t});\n\n\t(isMacintosh || isWindows /* macOS: does not seem to report deletes on folders | Windows: reports on('error') event only */ ? test.skip : test)('deleting watched path emits watcher fail and delete event when correlated (folder watch)', async function () {\n\t\tconst folderPath = join(testDir, 'deep');\n\n\t\tawait watcher.watch([{ path: folderPath, excludes: [], recursive: false, correlationId: 1 }]);\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst changeFuture = awaitEvent(watcher, folderPath, FileChangeType.DELETED, 1);\n\t\tPromises.rm(folderPath, RimRafMode.UNLINK);\n\t\tawait onDidWatchFail;\n\t\tawait changeFuture;\n\t});\n\n\ttest('watch requests support suspend/resume (file, does not exist in beginning)', async function () {\n\t\tconst filePath = join(testDir, 'not-found.txt');\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), 'polling');\n\n\t\tawait basicCrudTest(filePath, undefined, null, undefined, true);\n\t\tawait basicCrudTest(filePath, undefined, null, undefined, true);\n\t});\n\n\ttest('watch requests support suspend/resume (file, exists in beginning)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tawait basicCrudTest(filePath, true);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), 'polling');\n\n\t\tawait basicCrudTest(filePath, undefined, null, undefined, true);\n\t});\n\n\t(isWindows /* Windows: does not seem to report this */ ? test.skip : test)('watch requests support suspend/resume (folder, does not exist in beginning)', async function () {\n\t\tlet onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\n\t\tconst folderPath = join(testDir, 'not-found');\n\t\tconst request = { path: folderPath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), 'polling');\n\n\t\tlet changeFuture = awaitEvent(watcher, folderPath, FileChangeType.ADDED);\n\t\tlet onDidWatch = Event.toPromise(watcher.onDidWatch);\n\t\tawait fs.promises.mkdir(folderPath);\n\t\tawait changeFuture;\n\t\tawait onDidWatch;\n\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\n\t\tif (isWindows) { // somehow failing on macOS/Linux\n\t\t\tconst filePath = join(folderPath, 'newFile.txt');\n\t\t\tawait basicCrudTest(filePath);\n\n\t\t\tonDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\t\tawait fs.promises.rmdir(folderPath);\n\t\t\tawait onDidWatchFail;\n\n\t\t\tchangeFuture = awaitEvent(watcher, folderPath, FileChangeType.ADDED);\n\t\t\tonDidWatch = Event.toPromise(watcher.onDidWatch);\n\t\t\tawait fs.promises.mkdir(folderPath);\n\t\t\tawait changeFuture;\n\t\t\tawait onDidWatch;\n\n\t\t\tawait timeout(500); // somehow needed on Linux\n\n\t\t\tawait basicCrudTest(filePath);\n\t\t}\n\t});\n\n\t(isMacintosh /* macOS: does not seem to report this */ ? test.skip : test)('watch requests support suspend/resume (folder, exists in beginning)', async function () {\n\t\tconst folderPath = join(testDir, 'deep');\n\t\tawait watcher.watch([{ path: folderPath, excludes: [], recursive: false }]);\n\n\t\tconst filePath = join(folderPath, 'newFile.txt');\n\t\tawait basicCrudTest(filePath);\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tawait Promises.rm(folderPath);\n\t\tawait onDidWatchFail;\n\n\t\tconst changeFuture = awaitEvent(watcher, folderPath, FileChangeType.ADDED);\n\t\tconst onDidWatch = Event.toPromise(watcher.onDidWatch);\n\t\tawait fs.promises.mkdir(folderPath);\n\t\tawait changeFuture;\n\t\tawait onDidWatch;\n\n\t\tawait timeout(500); // somehow needed on Linux\n\n\t\tawait basicCrudTest(filePath);\n\t});\n\n\ttest('parcel watcher reused when present for non-recursive file watching (uncorrelated)', function () {\n\t\treturn testParcelWatcherReused(undefined);\n\t});\n\n\ttest('parcel watcher reused when present for non-recursive file watching (correlated)', function () {\n\t\treturn testParcelWatcherReused(2);\n\t});\n\n\tfunction createParcelWatcher() {\n\t\tconst recursiveWatcher = new TestParcelWatcher();\n\t\trecursiveWatcher.setVerboseLogging(loggingEnabled);\n\t\trecursiveWatcher.onDidLogMessage(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[recursive watcher test message] ${e.message}`);\n\t\t\t}\n\t\t});\n\n\t\trecursiveWatcher.onDidError(e => {\n\t\t\tif (loggingEnabled) {\n\t\t\t\tconsole.log(`[recursive watcher test error] ${e.error}`);\n\t\t\t}\n\t\t});\n\n\t\treturn recursiveWatcher;\n\t}\n\n\tasync function testParcelWatcherReused(correlationId: number | undefined) {\n\t\tconst recursiveWatcher = createParcelWatcher();\n\t\tawait recursiveWatcher.watch([{ path: testDir, excludes: [], recursive: true, correlationId: 1 }]);\n\n\t\tconst recursiveInstance = Array.from(recursiveWatcher.watchers)[0];\n\t\tassert.strictEqual(recursiveInstance.subscriptionsCount, 0);\n\n\t\tawait createWatcher(recursiveWatcher);\n\n\t\tconst filePath = join(testDir, 'deep', 'conway.js');\n\t\tawait watcher.watch([{ path: filePath, excludes: [], recursive: false, correlationId }]);\n\n\t\tconst { instance } = Array.from(watcher.watchers)[0];\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, true);\n\t\tassert.strictEqual(recursiveInstance.subscriptionsCount, 1);\n\n\t\tlet changeFuture = awaitEvent(watcher, filePath, isMacintosh /* somehow fsevents seems to report still on the initial create from test setup */ ? FileChangeType.ADDED : FileChangeType.UPDATED, correlationId);\n\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\tawait recursiveWatcher.stop();\n\t\trecursiveWatcher.dispose();\n\n\t\tawait timeout(500); // give the watcher some time to restart\n\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, correlationId);\n\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\tassert.strictEqual(instance.isReusingRecursiveWatcher, false);\n\t}\n\n\ttest('watch requests support suspend/resume (file, does not exist in beginning, parcel watcher reused)', async function () {\n\t\tconst recursiveWatcher = createParcelWatcher();\n\t\tawait recursiveWatcher.watch([{ path: testDir, excludes: [], recursive: true }]);\n\n\t\tawait createWatcher(recursiveWatcher);\n\n\t\tconst filePath = join(testDir, 'not-found-2.txt');\n\n\t\tconst onDidWatchFail = Event.toPromise(watcher.onWatchFail);\n\t\tconst request = { path: filePath, excludes: [], recursive: false };\n\t\tawait watcher.watch([request]);\n\t\tawait onDidWatchFail;\n\t\tassert.strictEqual(watcher.isSuspended(request), true);\n\n\t\tconst changeFuture = awaitEvent(watcher, filePath, FileChangeType.ADDED);\n\t\tawait Promises.writeFile(filePath, 'Hello World');\n\t\tawait changeFuture;\n\n\t\tassert.strictEqual(watcher.isSuspended(request), false);\n\t});\n\n\ttest('event type filter (file watch)', async function () {\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tconst request = { path: filePath, excludes: [], recursive: false, filter: FileChangeFilter.UPDATED | FileChangeFilter.DELETED, correlationId: 1 };\n\t\tawait watcher.watch([request]);\n\n\t\t// Change file\n\t\tlet changeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, 1);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, 1);\n\t\tawait fs.promises.unlink(filePath);\n\t\tawait changeFuture;\n\t});\n\n\ttest('event type filter (folder watch)', async function () {\n\t\tconst request = { path: testDir, excludes: [], recursive: false, filter: FileChangeFilter.UPDATED | FileChangeFilter.DELETED, correlationId: 1 };\n\t\tawait watcher.watch([request]);\n\n\t\t// Change file\n\t\tconst filePath = join(testDir, 'lorem.txt');\n\t\tlet changeFuture = awaitEvent(watcher, filePath, FileChangeType.UPDATED, 1);\n\t\tawait Promises.writeFile(filePath, 'Hello Change');\n\t\tawait changeFuture;\n\n\t\t// Delete file\n\t\tchangeFuture = awaitEvent(watcher, filePath, FileChangeType.DELETED, 1);\n\t\tawait fs.promises.unlink(filePath);\n\t\tawait changeFuture;\n\t});\n});\n"]}