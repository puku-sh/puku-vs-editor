{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/windows/electron-main/windowsStateHandler.ts","vs/platform/windows/electron-main/windowsStateHandler.ts"],"names":[],"mappings":"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","file":"windowsStateHandler.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from 'electron';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../base/common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { INativeWindowConfiguration, IWindowSettings } from '../../window/common/window.js';\nimport { IWindowsMainService } from './windows.js';\nimport { defaultWindowState, ICodeWindow, IWindowState as IWindowUIState, WindowMode } from '../../window/electron-main/window.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IWorkspaceIdentifier } from '../../workspace/common/workspace.js';\n\nexport interface IWindowState {\n\treadonly windowId?: number;\n\tworkspace?: IWorkspaceIdentifier;\n\tfolderUri?: URI;\n\tbackupPath?: string;\n\tremoteAuthority?: string;\n\tuiState: IWindowUIState;\n}\n\nexport interface IWindowsState {\n\tlastActiveWindow?: IWindowState;\n\tlastPluginDevelopmentHostWindow?: IWindowState;\n\topenedWindows: IWindowState[];\n}\n\ninterface INewWindowState extends IWindowUIState {\n\thasDefaultState?: boolean;\n}\n\ninterface ISerializedWindowsState {\n\treadonly lastActiveWindow?: ISerializedWindowState;\n\treadonly lastPluginDevelopmentHostWindow?: ISerializedWindowState;\n\treadonly openedWindows: ISerializedWindowState[];\n}\n\ninterface ISerializedWindowState {\n\treadonly workspaceIdentifier?: { id: string; configURIPath: string };\n\treadonly folder?: string;\n\treadonly backupPath?: string;\n\treadonly remoteAuthority?: string;\n\treadonly uiState: IWindowUIState;\n}\n\nexport class WindowsStateHandler extends Disposable {\n\n\tprivate static readonly windowsStateStorageKey = 'windowsState';\n\n\tget state() { return this._state; }\n\tprivate readonly _state: IWindowsState;\n\n\tprivate lastClosedState: IWindowState | undefined = undefined;\n\n\tprivate shuttingDown = false;\n\n\tconstructor(\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis._state = restoreWindowsState(this.stateService.getItem<ISerializedWindowsState>(WindowsStateHandler.windowsStateStorageKey));\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// When a window looses focus, save all windows state. This allows to\n\t\t// prevent loss of window-state data when OS is restarted without properly\n\t\t// shutting down the application (https://github.com/microsoft/vscode/issues/87171)\n\t\telectron.app.on('browser-window-blur', () => {\n\t\t\tif (!this.shuttingDown) {\n\t\t\t\tthis.saveWindowsState();\n\t\t\t}\n\t\t});\n\n\t\t// Handle various lifecycle events around windows\n\t\tthis._register(this.lifecycleMainService.onBeforeCloseWindow(window => this.onBeforeCloseWindow(window)));\n\t\tthis._register(this.lifecycleMainService.onBeforeShutdown(() => this.onBeforeShutdown()));\n\t\tthis._register(this.windowsMainService.onDidChangeWindowsCount(e => {\n\t\t\tif (e.newCount - e.oldCount > 0) {\n\t\t\t\t// clear last closed window state when a new window opens. this helps on macOS where\n\t\t\t\t// otherwise closing the last window, opening a new window and then quitting would\n\t\t\t\t// use the state of the previously closed window when restarting.\n\t\t\t\tthis.lastClosedState = undefined;\n\t\t\t}\n\t\t}));\n\n\t\t// try to save state before destroy because close will not fire\n\t\tthis._register(this.windowsMainService.onDidDestroyWindow(window => this.onBeforeCloseWindow(window)));\n\t}\n\n\t// Note that onBeforeShutdown() and onBeforeCloseWindow() are fired in different order depending on the OS:\n\t// - macOS: since the app will not quit when closing the last window, you will always first get\n\t//          the onBeforeShutdown() event followed by N onBeforeCloseWindow() events for each window\n\t// - other: on other OS, closing the last window will quit the app so the order depends on the\n\t//          user interaction: closing the last window will first trigger onBeforeCloseWindow()\n\t//          and then onBeforeShutdown(). Using the quit action however will first issue onBeforeShutdown()\n\t//          and then onBeforeCloseWindow().\n\t//\n\t// Here is the behavior on different OS depending on action taken (Electron 1.7.x):\n\t//\n\t// Legend\n\t// -  quit(N): quit application with N windows opened\n\t// - close(1): close one window via the window close button\n\t// - closeAll: close all windows via the taskbar command\n\t// - onBeforeShutdown(N): number of windows reported in this event handler\n\t// - onBeforeCloseWindow(N, M): number of windows reported and quitRequested boolean in this event handler\n\t//\n\t// macOS\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-     quit(0): onBeforeShutdown(0)\n\t// \t-    close(1): onBeforeCloseWindow(1, false)\n\t//\n\t// Windows\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-    close(1): onBeforeCloseWindow(2, false)[not last window]\n\t// \t-    close(1): onBeforeCloseWindow(1, false), onBeforeShutdown(0)[last window]\n\t// \t- closeAll(2): onBeforeCloseWindow(2, false), onBeforeCloseWindow(2, false), onBeforeShutdown(0)\n\t//\n\t// Linux\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-    close(1): onBeforeCloseWindow(2, false)[not last window]\n\t// \t-    close(1): onBeforeCloseWindow(1, false), onBeforeShutdown(0)[last window]\n\t// \t- closeAll(2): onBeforeCloseWindow(2, false), onBeforeCloseWindow(2, false), onBeforeShutdown(0)\n\t//\n\tprivate onBeforeShutdown(): void {\n\t\tthis.shuttingDown = true;\n\n\t\tthis.saveWindowsState();\n\t}\n\n\tprivate saveWindowsState(): void {\n\n\t\t// TODO@electron workaround for Electron not being able to restore\n\t\t// multiple (native) fullscreen windows on the same display at once\n\t\t// on macOS.\n\t\t// https://github.com/electron/electron/issues/34367\n\t\tconst displaysWithFullScreenWindow = new Set<number | undefined>();\n\n\t\tconst currentWindowsState: IWindowsState = {\n\t\t\topenedWindows: [],\n\t\t\tlastPluginDevelopmentHostWindow: this._state.lastPluginDevelopmentHostWindow,\n\t\t\tlastActiveWindow: this.lastClosedState\n\t\t};\n\n\t\t// 1.) Find a last active window (pick any other first window otherwise)\n\t\tif (!currentWindowsState.lastActiveWindow) {\n\t\t\tlet activeWindow = this.windowsMainService.getLastActiveWindow();\n\t\t\tif (!activeWindow || activeWindow.isExtensionDevelopmentHost) {\n\t\t\t\tactiveWindow = this.windowsMainService.getWindows().find(window => !window.isExtensionDevelopmentHost);\n\t\t\t}\n\n\t\t\tif (activeWindow) {\n\t\t\t\tcurrentWindowsState.lastActiveWindow = this.toWindowState(activeWindow);\n\n\t\t\t\tif (currentWindowsState.lastActiveWindow.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tdisplaysWithFullScreenWindow.add(currentWindowsState.lastActiveWindow.uiState.display); // always allow fullscreen for active window\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2.) Find extension host window\n\t\tconst extensionHostWindow = this.windowsMainService.getWindows().find(window => window.isExtensionDevelopmentHost && !window.isExtensionTestHost);\n\t\tif (extensionHostWindow) {\n\t\t\tcurrentWindowsState.lastPluginDevelopmentHostWindow = this.toWindowState(extensionHostWindow);\n\n\t\t\tif (currentWindowsState.lastPluginDevelopmentHostWindow.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\tif (displaysWithFullScreenWindow.has(currentWindowsState.lastPluginDevelopmentHostWindow.uiState.display)) {\n\t\t\t\t\tif (isMacintosh && !extensionHostWindow.win?.isSimpleFullScreen()) {\n\t\t\t\t\t\tcurrentWindowsState.lastPluginDevelopmentHostWindow.uiState.mode = WindowMode.Normal;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdisplaysWithFullScreenWindow.add(currentWindowsState.lastPluginDevelopmentHostWindow.uiState.display);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 3.) All windows (except extension host) for N >= 2 to support `restoreWindows: all` or for auto update\n\t\t//\n\t\t// Careful here: asking a window for its window state after it has been closed returns bogus values (width: 0, height: 0)\n\t\t// so if we ever want to persist the UI state of the last closed window (window count === 1), it has\n\t\t// to come from the stored lastClosedWindowState on Win/Linux at least\n\t\tif (this.windowsMainService.getWindowCount() > 1) {\n\t\t\tcurrentWindowsState.openedWindows = this.windowsMainService.getWindows().filter(window => !window.isExtensionDevelopmentHost).map(window => {\n\t\t\t\tconst windowState = this.toWindowState(window);\n\n\t\t\t\tif (windowState.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tif (displaysWithFullScreenWindow.has(windowState.uiState.display)) {\n\t\t\t\t\t\tif (isMacintosh && windowState.windowId !== currentWindowsState.lastActiveWindow?.windowId && !window.win?.isSimpleFullScreen()) {\n\t\t\t\t\t\t\twindowState.uiState.mode = WindowMode.Normal;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplaysWithFullScreenWindow.add(windowState.uiState.display);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn windowState;\n\t\t\t});\n\t\t}\n\n\t\t// Persist\n\t\tconst state = getWindowsStateStoreData(currentWindowsState);\n\t\tthis.stateService.setItem(WindowsStateHandler.windowsStateStorageKey, state);\n\n\t\tif (this.shuttingDown) {\n\t\t\tthis.logService.trace('[WindowsStateHandler] onBeforeShutdown', state);\n\t\t}\n\t}\n\n\t// See note on #onBeforeShutdown() for details how these events are flowing\n\tprivate onBeforeCloseWindow(window: ICodeWindow): void {\n\t\tif (this.lifecycleMainService.quitRequested) {\n\t\t\treturn; // during quit, many windows close in parallel so let it be handled in the before-quit handler\n\t\t}\n\n\t\t// On Window close, update our stored UI state of this window\n\t\tconst state: IWindowState = this.toWindowState(window);\n\t\tif (window.isExtensionDevelopmentHost && !window.isExtensionTestHost) {\n\t\t\tthis._state.lastPluginDevelopmentHostWindow = state; // do not let test run window state overwrite our extension development state\n\t\t}\n\n\t\t// Any non extension host window with same workspace or folder\n\t\telse if (!window.isExtensionDevelopmentHost && window.openedWorkspace) {\n\t\t\tthis._state.openedWindows.forEach(openedWindow => {\n\t\t\t\tconst sameWorkspace = isWorkspaceIdentifier(window.openedWorkspace) && openedWindow.workspace?.id === window.openedWorkspace.id;\n\t\t\t\tconst sameFolder = isSingleFolderWorkspaceIdentifier(window.openedWorkspace) && openedWindow.folderUri && extUriBiasedIgnorePathCase.isEqual(openedWindow.folderUri, window.openedWorkspace.uri);\n\n\t\t\t\tif (sameWorkspace || sameFolder) {\n\t\t\t\t\topenedWindow.uiState = state.uiState;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// On Windows and Linux closing the last window will trigger quit. Since we are storing all UI state\n\t\t// before quitting, we need to remember the UI state of this window to be able to persist it.\n\t\t// On macOS we keep the last closed window state ready in case the user wants to quit right after or\n\t\t// wants to open another window, in which case we use this state over the persisted one.\n\t\tif (this.windowsMainService.getWindowCount() === 1) {\n\t\t\tthis.lastClosedState = state;\n\t\t}\n\t}\n\n\tprivate toWindowState(window: ICodeWindow): IWindowState {\n\t\treturn {\n\t\t\twindowId: window.id,\n\t\t\tworkspace: isWorkspaceIdentifier(window.openedWorkspace) ? window.openedWorkspace : undefined,\n\t\t\tfolderUri: isSingleFolderWorkspaceIdentifier(window.openedWorkspace) ? window.openedWorkspace.uri : undefined,\n\t\t\tbackupPath: window.backupPath,\n\t\t\tremoteAuthority: window.remoteAuthority,\n\t\t\tuiState: window.serializeWindowState()\n\t\t};\n\t}\n\n\tgetNewWindowState(configuration: INativeWindowConfiguration): INewWindowState {\n\t\tconst state = this.doGetNewWindowState(configuration);\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\n\t\t// Fullscreen state gets special treatment\n\t\tif (state.mode === WindowMode.Fullscreen) {\n\n\t\t\t// Window state is not from a previous session: only allow fullscreen if we inherit it or user wants fullscreen\n\t\t\tlet allowFullscreen: boolean;\n\t\t\tif (state.hasDefaultState) {\n\t\t\t\tallowFullscreen = !!(windowConfig?.newWindowDimensions && ['fullscreen', 'inherit', 'offset'].indexOf(windowConfig.newWindowDimensions) >= 0);\n\t\t\t}\n\n\t\t\t// Window state is from a previous session: only allow fullscreen when we got updated or user wants to restore\n\t\t\telse {\n\t\t\t\tallowFullscreen = !!(this.lifecycleMainService.wasRestarted || windowConfig?.restoreFullscreen);\n\t\t\t}\n\n\t\t\tif (!allowFullscreen) {\n\t\t\t\tstate.mode = WindowMode.Normal;\n\t\t\t}\n\t\t}\n\n\t\treturn state;\n\t}\n\n\tprivate doGetNewWindowState(configuration: INativeWindowConfiguration): INewWindowState {\n\t\tconst lastActive = this.windowsMainService.getLastActiveWindow();\n\n\t\t// Restore state unless we are running extension tests\n\t\tif (!configuration.extensionTestsPath) {\n\n\t\t\t// extension development host Window - load from stored settings if any\n\t\t\tif (!!configuration.extensionDevelopmentPath && this.state.lastPluginDevelopmentHostWindow) {\n\t\t\t\treturn this.state.lastPluginDevelopmentHostWindow.uiState;\n\t\t\t}\n\n\t\t\t// Known Workspace - load from stored settings\n\t\t\tconst workspace = configuration.workspace;\n\t\t\tif (isWorkspaceIdentifier(workspace)) {\n\t\t\t\tconst stateForWorkspace = this.state.openedWindows.filter(openedWindow => openedWindow.workspace && openedWindow.workspace.id === workspace.id).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForWorkspace.length) {\n\t\t\t\t\treturn stateForWorkspace[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Known Folder - load from stored settings\n\t\t\tif (isSingleFolderWorkspaceIdentifier(workspace)) {\n\t\t\t\tconst stateForFolder = this.state.openedWindows.filter(openedWindow => openedWindow.folderUri && extUriBiasedIgnorePathCase.isEqual(openedWindow.folderUri, workspace.uri)).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForFolder.length) {\n\t\t\t\t\treturn stateForFolder[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Empty windows with backups\n\t\t\telse if (configuration.backupPath) {\n\t\t\t\tconst stateForEmptyWindow = this.state.openedWindows.filter(openedWindow => openedWindow.backupPath === configuration.backupPath).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForEmptyWindow.length) {\n\t\t\t\t\treturn stateForEmptyWindow[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First Window\n\t\t\tconst lastActiveState = this.lastClosedState || this.state.lastActiveWindow;\n\t\t\tif (!lastActive && lastActiveState) {\n\t\t\t\treturn lastActiveState.uiState;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// In any other case, we do not have any stored settings for the window state, so we come up with something smart\n\t\t//\n\n\t\t// We want the new window to open on the same display that the last active one is in\n\t\tlet displayToUse: electron.Display | undefined;\n\t\tconst displays = electron.screen.getAllDisplays();\n\n\t\t// Single Display\n\t\tif (displays.length === 1) {\n\t\t\tdisplayToUse = displays[0];\n\t\t}\n\n\t\t// Multi Display\n\t\telse {\n\n\t\t\t// on mac there is 1 menu per window so we need to use the monitor where the cursor currently is\n\t\t\tif (isMacintosh) {\n\t\t\t\tconst cursorPoint = electron.screen.getCursorScreenPoint();\n\t\t\t\tdisplayToUse = electron.screen.getDisplayNearestPoint(cursorPoint);\n\t\t\t}\n\n\t\t\t// if we have a last active window, use that display for the new window\n\t\t\tif (!displayToUse && lastActive) {\n\t\t\t\tdisplayToUse = electron.screen.getDisplayMatching(lastActive.getBounds());\n\t\t\t}\n\n\t\t\t// fallback to primary display or first display\n\t\t\tif (!displayToUse) {\n\t\t\t\tdisplayToUse = electron.screen.getPrimaryDisplay() || displays[0];\n\t\t\t}\n\t\t}\n\n\t\t// Compute x/y based on display bounds\n\t\t// Note: important to use Math.round() because Electron does not seem to be too happy about\n\t\t// display coordinates that are not absolute numbers.\n\t\tlet state = defaultWindowState(undefined, isWorkspaceIdentifier(configuration.workspace) || isSingleFolderWorkspaceIdentifier(configuration.workspace));\n\t\tstate.x = Math.round(displayToUse.bounds.x + (displayToUse.bounds.width / 2) - (state.width! / 2));\n\t\tstate.y = Math.round(displayToUse.bounds.y + (displayToUse.bounds.height / 2) - (state.height! / 2));\n\n\t\t// Check for newWindowDimensions setting and adjust accordingly\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\t\tlet ensureNoOverlap = true;\n\t\tif (windowConfig?.newWindowDimensions) {\n\t\t\tif (windowConfig.newWindowDimensions === 'maximized') {\n\t\t\t\tstate.mode = WindowMode.Maximized;\n\t\t\t\tensureNoOverlap = false;\n\t\t\t} else if (windowConfig.newWindowDimensions === 'fullscreen') {\n\t\t\t\tstate.mode = WindowMode.Fullscreen;\n\t\t\t\tensureNoOverlap = false;\n\t\t\t} else if ((windowConfig.newWindowDimensions === 'inherit' || windowConfig.newWindowDimensions === 'offset') && lastActive) {\n\t\t\t\tconst lastActiveState = lastActive.serializeWindowState();\n\t\t\t\tif (lastActiveState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tstate.mode = WindowMode.Fullscreen; // only take mode (fixes https://github.com/microsoft/vscode/issues/19331)\n\t\t\t\t} else {\n\t\t\t\t\tstate = {\n\t\t\t\t\t\t...lastActiveState,\n\t\t\t\t\t\tzoomLevel: undefined // do not inherit zoom level\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tensureNoOverlap = state.mode !== WindowMode.Fullscreen && windowConfig.newWindowDimensions === 'offset';\n\t\t\t}\n\t\t}\n\n\t\tif (ensureNoOverlap) {\n\t\t\tstate = this.ensureNoOverlap(state);\n\t\t}\n\n\t\t(state as INewWindowState).hasDefaultState = true; // flag as default state\n\n\t\treturn state;\n\t}\n\n\tprivate ensureNoOverlap(state: IWindowUIState): IWindowUIState {\n\t\tif (this.windowsMainService.getWindows().length === 0) {\n\t\t\treturn state;\n\t\t}\n\n\t\tstate.x = typeof state.x === 'number' ? state.x : 0;\n\t\tstate.y = typeof state.y === 'number' ? state.y : 0;\n\n\t\tconst existingWindowBounds = this.windowsMainService.getWindows().map(window => window.getBounds());\n\t\twhile (existingWindowBounds.some(bounds => bounds.x === state.x || bounds.y === state.y)) {\n\t\t\tstate.x += 30;\n\t\t\tstate.y += 30;\n\t\t}\n\n\t\treturn state;\n\t}\n}\n\nexport function restoreWindowsState(data: ISerializedWindowsState | undefined): IWindowsState {\n\tconst result: IWindowsState = { openedWindows: [] };\n\tconst windowsState = data || { openedWindows: [] };\n\n\tif (windowsState.lastActiveWindow) {\n\t\tresult.lastActiveWindow = restoreWindowState(windowsState.lastActiveWindow);\n\t}\n\n\tif (windowsState.lastPluginDevelopmentHostWindow) {\n\t\tresult.lastPluginDevelopmentHostWindow = restoreWindowState(windowsState.lastPluginDevelopmentHostWindow);\n\t}\n\n\tif (Array.isArray(windowsState.openedWindows)) {\n\t\tresult.openedWindows = windowsState.openedWindows.map(windowState => restoreWindowState(windowState));\n\t}\n\n\treturn result;\n}\n\nfunction restoreWindowState(windowState: ISerializedWindowState): IWindowState {\n\tconst result: IWindowState = { uiState: windowState.uiState };\n\tif (windowState.backupPath) {\n\t\tresult.backupPath = windowState.backupPath;\n\t}\n\n\tif (windowState.remoteAuthority) {\n\t\tresult.remoteAuthority = windowState.remoteAuthority;\n\t}\n\n\tif (windowState.folder) {\n\t\tresult.folderUri = URI.parse(windowState.folder);\n\t}\n\n\tif (windowState.workspaceIdentifier) {\n\t\tresult.workspace = { id: windowState.workspaceIdentifier.id, configPath: URI.parse(windowState.workspaceIdentifier.configURIPath) };\n\t}\n\n\treturn result;\n}\n\nexport function getWindowsStateStoreData(windowsState: IWindowsState): IWindowsState {\n\treturn {\n\t\tlastActiveWindow: windowsState.lastActiveWindow && serializeWindowState(windowsState.lastActiveWindow),\n\t\tlastPluginDevelopmentHostWindow: windowsState.lastPluginDevelopmentHostWindow && serializeWindowState(windowsState.lastPluginDevelopmentHostWindow),\n\t\topenedWindows: windowsState.openedWindows.map(ws => serializeWindowState(ws))\n\t};\n}\n\nfunction serializeWindowState(windowState: IWindowState): ISerializedWindowState {\n\treturn {\n\t\tworkspaceIdentifier: windowState.workspace && { id: windowState.workspace.id, configURIPath: windowState.workspace.configPath.toString() },\n\t\tfolder: windowState.folderUri?.toString(),\n\t\tbackupPath: windowState.backupPath,\n\t\tremoteAuthority: windowState.remoteAuthority,\n\t\tuiState: windowState.uiState\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from 'electron';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../base/common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { INativeWindowConfiguration, IWindowSettings } from '../../window/common/window.js';\nimport { IWindowsMainService } from './windows.js';\nimport { defaultWindowState, ICodeWindow, IWindowState as IWindowUIState, WindowMode } from '../../window/electron-main/window.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IWorkspaceIdentifier } from '../../workspace/common/workspace.js';\n\nexport interface IWindowState {\n\treadonly windowId?: number;\n\tworkspace?: IWorkspaceIdentifier;\n\tfolderUri?: URI;\n\tbackupPath?: string;\n\tremoteAuthority?: string;\n\tuiState: IWindowUIState;\n}\n\nexport interface IWindowsState {\n\tlastActiveWindow?: IWindowState;\n\tlastPluginDevelopmentHostWindow?: IWindowState;\n\topenedWindows: IWindowState[];\n}\n\ninterface INewWindowState extends IWindowUIState {\n\thasDefaultState?: boolean;\n}\n\ninterface ISerializedWindowsState {\n\treadonly lastActiveWindow?: ISerializedWindowState;\n\treadonly lastPluginDevelopmentHostWindow?: ISerializedWindowState;\n\treadonly openedWindows: ISerializedWindowState[];\n}\n\ninterface ISerializedWindowState {\n\treadonly workspaceIdentifier?: { id: string; configURIPath: string };\n\treadonly folder?: string;\n\treadonly backupPath?: string;\n\treadonly remoteAuthority?: string;\n\treadonly uiState: IWindowUIState;\n}\n\nexport class WindowsStateHandler extends Disposable {\n\n\tprivate static readonly windowsStateStorageKey = 'windowsState';\n\n\tget state() { return this._state; }\n\tprivate readonly _state: IWindowsState;\n\n\tprivate lastClosedState: IWindowState | undefined = undefined;\n\n\tprivate shuttingDown = false;\n\n\tconstructor(\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis._state = restoreWindowsState(this.stateService.getItem<ISerializedWindowsState>(WindowsStateHandler.windowsStateStorageKey));\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// When a window looses focus, save all windows state. This allows to\n\t\t// prevent loss of window-state data when OS is restarted without properly\n\t\t// shutting down the application (https://github.com/microsoft/vscode/issues/87171)\n\t\telectron.app.on('browser-window-blur', () => {\n\t\t\tif (!this.shuttingDown) {\n\t\t\t\tthis.saveWindowsState();\n\t\t\t}\n\t\t});\n\n\t\t// Handle various lifecycle events around windows\n\t\tthis._register(this.lifecycleMainService.onBeforeCloseWindow(window => this.onBeforeCloseWindow(window)));\n\t\tthis._register(this.lifecycleMainService.onBeforeShutdown(() => this.onBeforeShutdown()));\n\t\tthis._register(this.windowsMainService.onDidChangeWindowsCount(e => {\n\t\t\tif (e.newCount - e.oldCount > 0) {\n\t\t\t\t// clear last closed window state when a new window opens. this helps on macOS where\n\t\t\t\t// otherwise closing the last window, opening a new window and then quitting would\n\t\t\t\t// use the state of the previously closed window when restarting.\n\t\t\t\tthis.lastClosedState = undefined;\n\t\t\t}\n\t\t}));\n\n\t\t// try to save state before destroy because close will not fire\n\t\tthis._register(this.windowsMainService.onDidDestroyWindow(window => this.onBeforeCloseWindow(window)));\n\t}\n\n\t// Note that onBeforeShutdown() and onBeforeCloseWindow() are fired in different order depending on the OS:\n\t// - macOS: since the app will not quit when closing the last window, you will always first get\n\t//          the onBeforeShutdown() event followed by N onBeforeCloseWindow() events for each window\n\t// - other: on other OS, closing the last window will quit the app so the order depends on the\n\t//          user interaction: closing the last window will first trigger onBeforeCloseWindow()\n\t//          and then onBeforeShutdown(). Using the quit action however will first issue onBeforeShutdown()\n\t//          and then onBeforeCloseWindow().\n\t//\n\t// Here is the behavior on different OS depending on action taken (Electron 1.7.x):\n\t//\n\t// Legend\n\t// -  quit(N): quit application with N windows opened\n\t// - close(1): close one window via the window close button\n\t// - closeAll: close all windows via the taskbar command\n\t// - onBeforeShutdown(N): number of windows reported in this event handler\n\t// - onBeforeCloseWindow(N, M): number of windows reported and quitRequested boolean in this event handler\n\t//\n\t// macOS\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-     quit(0): onBeforeShutdown(0)\n\t// \t-    close(1): onBeforeCloseWindow(1, false)\n\t//\n\t// Windows\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-    close(1): onBeforeCloseWindow(2, false)[not last window]\n\t// \t-    close(1): onBeforeCloseWindow(1, false), onBeforeShutdown(0)[last window]\n\t// \t- closeAll(2): onBeforeCloseWindow(2, false), onBeforeCloseWindow(2, false), onBeforeShutdown(0)\n\t//\n\t// Linux\n\t// \t-     quit(1): onBeforeShutdown(1), onBeforeCloseWindow(1, true)\n\t// \t-     quit(2): onBeforeShutdown(2), onBeforeCloseWindow(2, true), onBeforeCloseWindow(2, true)\n\t// \t-    close(1): onBeforeCloseWindow(2, false)[not last window]\n\t// \t-    close(1): onBeforeCloseWindow(1, false), onBeforeShutdown(0)[last window]\n\t// \t- closeAll(2): onBeforeCloseWindow(2, false), onBeforeCloseWindow(2, false), onBeforeShutdown(0)\n\t//\n\tprivate onBeforeShutdown(): void {\n\t\tthis.shuttingDown = true;\n\n\t\tthis.saveWindowsState();\n\t}\n\n\tprivate saveWindowsState(): void {\n\n\t\t// TODO@electron workaround for Electron not being able to restore\n\t\t// multiple (native) fullscreen windows on the same display at once\n\t\t// on macOS.\n\t\t// https://github.com/electron/electron/issues/34367\n\t\tconst displaysWithFullScreenWindow = new Set<number | undefined>();\n\n\t\tconst currentWindowsState: IWindowsState = {\n\t\t\topenedWindows: [],\n\t\t\tlastPluginDevelopmentHostWindow: this._state.lastPluginDevelopmentHostWindow,\n\t\t\tlastActiveWindow: this.lastClosedState\n\t\t};\n\n\t\t// 1.) Find a last active window (pick any other first window otherwise)\n\t\tif (!currentWindowsState.lastActiveWindow) {\n\t\t\tlet activeWindow = this.windowsMainService.getLastActiveWindow();\n\t\t\tif (!activeWindow || activeWindow.isExtensionDevelopmentHost) {\n\t\t\t\tactiveWindow = this.windowsMainService.getWindows().find(window => !window.isExtensionDevelopmentHost);\n\t\t\t}\n\n\t\t\tif (activeWindow) {\n\t\t\t\tcurrentWindowsState.lastActiveWindow = this.toWindowState(activeWindow);\n\n\t\t\t\tif (currentWindowsState.lastActiveWindow.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tdisplaysWithFullScreenWindow.add(currentWindowsState.lastActiveWindow.uiState.display); // always allow fullscreen for active window\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2.) Find extension host window\n\t\tconst extensionHostWindow = this.windowsMainService.getWindows().find(window => window.isExtensionDevelopmentHost && !window.isExtensionTestHost);\n\t\tif (extensionHostWindow) {\n\t\t\tcurrentWindowsState.lastPluginDevelopmentHostWindow = this.toWindowState(extensionHostWindow);\n\n\t\t\tif (currentWindowsState.lastPluginDevelopmentHostWindow.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\tif (displaysWithFullScreenWindow.has(currentWindowsState.lastPluginDevelopmentHostWindow.uiState.display)) {\n\t\t\t\t\tif (isMacintosh && !extensionHostWindow.win?.isSimpleFullScreen()) {\n\t\t\t\t\t\tcurrentWindowsState.lastPluginDevelopmentHostWindow.uiState.mode = WindowMode.Normal;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdisplaysWithFullScreenWindow.add(currentWindowsState.lastPluginDevelopmentHostWindow.uiState.display);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 3.) All windows (except extension host) for N >= 2 to support `restoreWindows: all` or for auto update\n\t\t//\n\t\t// Careful here: asking a window for its window state after it has been closed returns bogus values (width: 0, height: 0)\n\t\t// so if we ever want to persist the UI state of the last closed window (window count === 1), it has\n\t\t// to come from the stored lastClosedWindowState on Win/Linux at least\n\t\tif (this.windowsMainService.getWindowCount() > 1) {\n\t\t\tcurrentWindowsState.openedWindows = this.windowsMainService.getWindows().filter(window => !window.isExtensionDevelopmentHost).map(window => {\n\t\t\t\tconst windowState = this.toWindowState(window);\n\n\t\t\t\tif (windowState.uiState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tif (displaysWithFullScreenWindow.has(windowState.uiState.display)) {\n\t\t\t\t\t\tif (isMacintosh && windowState.windowId !== currentWindowsState.lastActiveWindow?.windowId && !window.win?.isSimpleFullScreen()) {\n\t\t\t\t\t\t\twindowState.uiState.mode = WindowMode.Normal;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplaysWithFullScreenWindow.add(windowState.uiState.display);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn windowState;\n\t\t\t});\n\t\t}\n\n\t\t// Persist\n\t\tconst state = getWindowsStateStoreData(currentWindowsState);\n\t\tthis.stateService.setItem(WindowsStateHandler.windowsStateStorageKey, state);\n\n\t\tif (this.shuttingDown) {\n\t\t\tthis.logService.trace('[WindowsStateHandler] onBeforeShutdown', state);\n\t\t}\n\t}\n\n\t// See note on #onBeforeShutdown() for details how these events are flowing\n\tprivate onBeforeCloseWindow(window: ICodeWindow): void {\n\t\tif (this.lifecycleMainService.quitRequested) {\n\t\t\treturn; // during quit, many windows close in parallel so let it be handled in the before-quit handler\n\t\t}\n\n\t\t// On Window close, update our stored UI state of this window\n\t\tconst state: IWindowState = this.toWindowState(window);\n\t\tif (window.isExtensionDevelopmentHost && !window.isExtensionTestHost) {\n\t\t\tthis._state.lastPluginDevelopmentHostWindow = state; // do not let test run window state overwrite our extension development state\n\t\t}\n\n\t\t// Any non extension host window with same workspace or folder\n\t\telse if (!window.isExtensionDevelopmentHost && window.openedWorkspace) {\n\t\t\tthis._state.openedWindows.forEach(openedWindow => {\n\t\t\t\tconst sameWorkspace = isWorkspaceIdentifier(window.openedWorkspace) && openedWindow.workspace?.id === window.openedWorkspace.id;\n\t\t\t\tconst sameFolder = isSingleFolderWorkspaceIdentifier(window.openedWorkspace) && openedWindow.folderUri && extUriBiasedIgnorePathCase.isEqual(openedWindow.folderUri, window.openedWorkspace.uri);\n\n\t\t\t\tif (sameWorkspace || sameFolder) {\n\t\t\t\t\topenedWindow.uiState = state.uiState;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// On Windows and Linux closing the last window will trigger quit. Since we are storing all UI state\n\t\t// before quitting, we need to remember the UI state of this window to be able to persist it.\n\t\t// On macOS we keep the last closed window state ready in case the user wants to quit right after or\n\t\t// wants to open another window, in which case we use this state over the persisted one.\n\t\tif (this.windowsMainService.getWindowCount() === 1) {\n\t\t\tthis.lastClosedState = state;\n\t\t}\n\t}\n\n\tprivate toWindowState(window: ICodeWindow): IWindowState {\n\t\treturn {\n\t\t\twindowId: window.id,\n\t\t\tworkspace: isWorkspaceIdentifier(window.openedWorkspace) ? window.openedWorkspace : undefined,\n\t\t\tfolderUri: isSingleFolderWorkspaceIdentifier(window.openedWorkspace) ? window.openedWorkspace.uri : undefined,\n\t\t\tbackupPath: window.backupPath,\n\t\t\tremoteAuthority: window.remoteAuthority,\n\t\t\tuiState: window.serializeWindowState()\n\t\t};\n\t}\n\n\tgetNewWindowState(configuration: INativeWindowConfiguration): INewWindowState {\n\t\tconst state = this.doGetNewWindowState(configuration);\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\n\t\t// Fullscreen state gets special treatment\n\t\tif (state.mode === WindowMode.Fullscreen) {\n\n\t\t\t// Window state is not from a previous session: only allow fullscreen if we inherit it or user wants fullscreen\n\t\t\tlet allowFullscreen: boolean;\n\t\t\tif (state.hasDefaultState) {\n\t\t\t\tallowFullscreen = !!(windowConfig?.newWindowDimensions && ['fullscreen', 'inherit', 'offset'].indexOf(windowConfig.newWindowDimensions) >= 0);\n\t\t\t}\n\n\t\t\t// Window state is from a previous session: only allow fullscreen when we got updated or user wants to restore\n\t\t\telse {\n\t\t\t\tallowFullscreen = !!(this.lifecycleMainService.wasRestarted || windowConfig?.restoreFullscreen);\n\t\t\t}\n\n\t\t\tif (!allowFullscreen) {\n\t\t\t\tstate.mode = WindowMode.Normal;\n\t\t\t}\n\t\t}\n\n\t\treturn state;\n\t}\n\n\tprivate doGetNewWindowState(configuration: INativeWindowConfiguration): INewWindowState {\n\t\tconst lastActive = this.windowsMainService.getLastActiveWindow();\n\n\t\t// Restore state unless we are running extension tests\n\t\tif (!configuration.extensionTestsPath) {\n\n\t\t\t// extension development host Window - load from stored settings if any\n\t\t\tif (!!configuration.extensionDevelopmentPath && this.state.lastPluginDevelopmentHostWindow) {\n\t\t\t\treturn this.state.lastPluginDevelopmentHostWindow.uiState;\n\t\t\t}\n\n\t\t\t// Known Workspace - load from stored settings\n\t\t\tconst workspace = configuration.workspace;\n\t\t\tif (isWorkspaceIdentifier(workspace)) {\n\t\t\t\tconst stateForWorkspace = this.state.openedWindows.filter(openedWindow => openedWindow.workspace && openedWindow.workspace.id === workspace.id).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForWorkspace.length) {\n\t\t\t\t\treturn stateForWorkspace[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Known Folder - load from stored settings\n\t\t\tif (isSingleFolderWorkspaceIdentifier(workspace)) {\n\t\t\t\tconst stateForFolder = this.state.openedWindows.filter(openedWindow => openedWindow.folderUri && extUriBiasedIgnorePathCase.isEqual(openedWindow.folderUri, workspace.uri)).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForFolder.length) {\n\t\t\t\t\treturn stateForFolder[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Empty windows with backups\n\t\t\telse if (configuration.backupPath) {\n\t\t\t\tconst stateForEmptyWindow = this.state.openedWindows.filter(openedWindow => openedWindow.backupPath === configuration.backupPath).map(openedWindow => openedWindow.uiState);\n\t\t\t\tif (stateForEmptyWindow.length) {\n\t\t\t\t\treturn stateForEmptyWindow[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First Window\n\t\t\tconst lastActiveState = this.lastClosedState || this.state.lastActiveWindow;\n\t\t\tif (!lastActive && lastActiveState) {\n\t\t\t\treturn lastActiveState.uiState;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// In any other case, we do not have any stored settings for the window state, so we come up with something smart\n\t\t//\n\n\t\t// We want the new window to open on the same display that the last active one is in\n\t\tlet displayToUse: electron.Display | undefined;\n\t\tconst displays = electron.screen.getAllDisplays();\n\n\t\t// Single Display\n\t\tif (displays.length === 1) {\n\t\t\tdisplayToUse = displays[0];\n\t\t}\n\n\t\t// Multi Display\n\t\telse {\n\n\t\t\t// on mac there is 1 menu per window so we need to use the monitor where the cursor currently is\n\t\t\tif (isMacintosh) {\n\t\t\t\tconst cursorPoint = electron.screen.getCursorScreenPoint();\n\t\t\t\tdisplayToUse = electron.screen.getDisplayNearestPoint(cursorPoint);\n\t\t\t}\n\n\t\t\t// if we have a last active window, use that display for the new window\n\t\t\tif (!displayToUse && lastActive) {\n\t\t\t\tdisplayToUse = electron.screen.getDisplayMatching(lastActive.getBounds());\n\t\t\t}\n\n\t\t\t// fallback to primary display or first display\n\t\t\tif (!displayToUse) {\n\t\t\t\tdisplayToUse = electron.screen.getPrimaryDisplay() || displays[0];\n\t\t\t}\n\t\t}\n\n\t\t// Compute x/y based on display bounds\n\t\t// Note: important to use Math.round() because Electron does not seem to be too happy about\n\t\t// display coordinates that are not absolute numbers.\n\t\tlet state = defaultWindowState(undefined, isWorkspaceIdentifier(configuration.workspace) || isSingleFolderWorkspaceIdentifier(configuration.workspace));\n\t\tstate.x = Math.round(displayToUse.bounds.x + (displayToUse.bounds.width / 2) - (state.width! / 2));\n\t\tstate.y = Math.round(displayToUse.bounds.y + (displayToUse.bounds.height / 2) - (state.height! / 2));\n\n\t\t// Check for newWindowDimensions setting and adjust accordingly\n\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\t\tlet ensureNoOverlap = true;\n\t\tif (windowConfig?.newWindowDimensions) {\n\t\t\tif (windowConfig.newWindowDimensions === 'maximized') {\n\t\t\t\tstate.mode = WindowMode.Maximized;\n\t\t\t\tensureNoOverlap = false;\n\t\t\t} else if (windowConfig.newWindowDimensions === 'fullscreen') {\n\t\t\t\tstate.mode = WindowMode.Fullscreen;\n\t\t\t\tensureNoOverlap = false;\n\t\t\t} else if ((windowConfig.newWindowDimensions === 'inherit' || windowConfig.newWindowDimensions === 'offset') && lastActive) {\n\t\t\t\tconst lastActiveState = lastActive.serializeWindowState();\n\t\t\t\tif (lastActiveState.mode === WindowMode.Fullscreen) {\n\t\t\t\t\tstate.mode = WindowMode.Fullscreen; // only take mode (fixes https://github.com/microsoft/vscode/issues/19331)\n\t\t\t\t} else {\n\t\t\t\t\tstate = {\n\t\t\t\t\t\t...lastActiveState,\n\t\t\t\t\t\tzoomLevel: undefined // do not inherit zoom level\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tensureNoOverlap = state.mode !== WindowMode.Fullscreen && windowConfig.newWindowDimensions === 'offset';\n\t\t\t}\n\t\t}\n\n\t\tif (ensureNoOverlap) {\n\t\t\tstate = this.ensureNoOverlap(state);\n\t\t}\n\n\t\t(state as INewWindowState).hasDefaultState = true; // flag as default state\n\n\t\treturn state;\n\t}\n\n\tprivate ensureNoOverlap(state: IWindowUIState): IWindowUIState {\n\t\tif (this.windowsMainService.getWindows().length === 0) {\n\t\t\treturn state;\n\t\t}\n\n\t\tstate.x = typeof state.x === 'number' ? state.x : 0;\n\t\tstate.y = typeof state.y === 'number' ? state.y : 0;\n\n\t\tconst existingWindowBounds = this.windowsMainService.getWindows().map(window => window.getBounds());\n\t\twhile (existingWindowBounds.some(bounds => bounds.x === state.x || bounds.y === state.y)) {\n\t\t\tstate.x += 30;\n\t\t\tstate.y += 30;\n\t\t}\n\n\t\treturn state;\n\t}\n}\n\nexport function restoreWindowsState(data: ISerializedWindowsState | undefined): IWindowsState {\n\tconst result: IWindowsState = { openedWindows: [] };\n\tconst windowsState = data || { openedWindows: [] };\n\n\tif (windowsState.lastActiveWindow) {\n\t\tresult.lastActiveWindow = restoreWindowState(windowsState.lastActiveWindow);\n\t}\n\n\tif (windowsState.lastPluginDevelopmentHostWindow) {\n\t\tresult.lastPluginDevelopmentHostWindow = restoreWindowState(windowsState.lastPluginDevelopmentHostWindow);\n\t}\n\n\tif (Array.isArray(windowsState.openedWindows)) {\n\t\tresult.openedWindows = windowsState.openedWindows.map(windowState => restoreWindowState(windowState));\n\t}\n\n\treturn result;\n}\n\nfunction restoreWindowState(windowState: ISerializedWindowState): IWindowState {\n\tconst result: IWindowState = { uiState: windowState.uiState };\n\tif (windowState.backupPath) {\n\t\tresult.backupPath = windowState.backupPath;\n\t}\n\n\tif (windowState.remoteAuthority) {\n\t\tresult.remoteAuthority = windowState.remoteAuthority;\n\t}\n\n\tif (windowState.folder) {\n\t\tresult.folderUri = URI.parse(windowState.folder);\n\t}\n\n\tif (windowState.workspaceIdentifier) {\n\t\tresult.workspace = { id: windowState.workspaceIdentifier.id, configPath: URI.parse(windowState.workspaceIdentifier.configURIPath) };\n\t}\n\n\treturn result;\n}\n\nexport function getWindowsStateStoreData(windowsState: IWindowsState): IWindowsState {\n\treturn {\n\t\tlastActiveWindow: windowsState.lastActiveWindow && serializeWindowState(windowsState.lastActiveWindow),\n\t\tlastPluginDevelopmentHostWindow: windowsState.lastPluginDevelopmentHostWindow && serializeWindowState(windowsState.lastPluginDevelopmentHostWindow),\n\t\topenedWindows: windowsState.openedWindows.map(ws => serializeWindowState(ws))\n\t};\n}\n\nfunction serializeWindowState(windowState: IWindowState): ISerializedWindowState {\n\treturn {\n\t\tworkspaceIdentifier: windowState.workspace && { id: windowState.workspace.id, configURIPath: windowState.workspace.configPath.toString() },\n\t\tfolder: windowState.folderUri?.toString(),\n\t\tbackupPath: windowState.backupPath,\n\t\tremoteAuthority: windowState.remoteAuthority,\n\t\tuiState: windowState.uiState\n\t};\n}\n"]}