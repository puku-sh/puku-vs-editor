{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/userDataProfile/common/userDataProfileStorageService.ts","vs/platform/userDataProfile/common/userDataProfileStorageService.ts"],"names":[],"mappings":"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","file":"userDataProfileStorageService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableMap, MutableDisposable, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { IStorage, IStorageDatabase, Storage } from '../../../base/parts/storage/common/storage.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { AbstractStorageService, IStorageService, IStorageValueChangeEvent, StorageScope, StorageTarget, isProfileUsingDefaultStorage } from '../../storage/common/storage.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IRemoteService } from '../../ipc/common/services.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ApplicationStorageDatabaseClient, ProfileStorageDatabaseClient } from '../../storage/common/storageIpc.js';\nimport { IUserDataProfile, IUserDataProfilesService, reviveProfile } from './userDataProfile.js';\n\nexport interface IProfileStorageValueChanges {\n\treadonly profile: IUserDataProfile;\n\treadonly changes: IStorageValueChangeEvent[];\n}\n\nexport interface IProfileStorageChanges {\n\treadonly targetChanges: IUserDataProfile[];\n\treadonly valueChanges: IProfileStorageValueChanges[];\n}\n\nexport interface IStorageValue {\n\treadonly value: string | undefined;\n\treadonly target: StorageTarget;\n}\n\nexport const IUserDataProfileStorageService = createDecorator<IUserDataProfileStorageService>('IUserDataProfileStorageService');\nexport interface IUserDataProfileStorageService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted whenever data is updated or deleted in a profile storage or target of a profile storage entry changes\n\t */\n\treadonly onDidChange: Event<IProfileStorageChanges>;\n\n\t/**\n\t * Return the requested profile storage data\n\t * @param profile The profile from which the data has to be read from\n\t */\n\treadStorageData(profile: IUserDataProfile): Promise<Map<string, IStorageValue>>;\n\n\t/**\n\t * Update the given profile storage data in the profile storage\n\t * @param profile The profile to which the data has to be written to\n\t * @param data Data that has to be updated\n\t * @param target Storage target of the data\n\t */\n\tupdateStorageData(profile: IUserDataProfile, data: Map<string, string | undefined | null>, target: StorageTarget): Promise<void>;\n\n\t/**\n\t * Calls a function with a storage service scoped to given profile.\n\t */\n\twithProfileScopedStorageService<T>(profile: IUserDataProfile, fn: (storageService: IStorageService) => Promise<T>): Promise<T>;\n}\n\nexport abstract class AbstractUserDataProfileStorageService extends Disposable implements IUserDataProfileStorageService {\n\n\t_serviceBrand: undefined;\n\n\treadonly abstract onDidChange: Event<IProfileStorageChanges>;\n\n\tprivate readonly storageServicesMap: DisposableMap<string, StorageService> | undefined;\n\n\tconstructor(\n\t\tpersistStorages: boolean,\n\t\t@IStorageService protected readonly storageService: IStorageService\n\t) {\n\t\tsuper();\n\t\tif (persistStorages) {\n\t\t\tthis.storageServicesMap = this._register(new DisposableMap<string, StorageService>());\n\t\t}\n\t}\n\n\tasync readStorageData(profile: IUserDataProfile): Promise<Map<string, IStorageValue>> {\n\t\treturn this.withProfileScopedStorageService(profile, async storageService => this.getItems(storageService));\n\t}\n\n\tasync updateStorageData(profile: IUserDataProfile, data: Map<string, string | undefined | null>, target: StorageTarget): Promise<void> {\n\t\treturn this.withProfileScopedStorageService(profile, async storageService => this.writeItems(storageService, data, target));\n\t}\n\n\tasync withProfileScopedStorageService<T>(profile: IUserDataProfile, fn: (storageService: IStorageService) => Promise<T>): Promise<T> {\n\t\tif (this.storageService.hasScope(profile)) {\n\t\t\treturn fn(this.storageService);\n\t\t}\n\n\t\tlet storageService = this.storageServicesMap?.get(profile.id);\n\t\tif (!storageService) {\n\t\t\tstorageService = new StorageService(this.createStorageDatabase(profile));\n\t\t\tthis.storageServicesMap?.set(profile.id, storageService);\n\n\t\t\ttry {\n\t\t\t\tawait storageService.initialize();\n\t\t\t} catch (error) {\n\t\t\t\tif (this.storageServicesMap?.has(profile.id)) {\n\t\t\t\t\tthis.storageServicesMap.deleteAndDispose(profile.id);\n\t\t\t\t} else {\n\t\t\t\t\tstorageService.dispose();\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tconst result = await fn(storageService);\n\t\t\tawait storageService.flush();\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tif (!this.storageServicesMap?.has(profile.id)) {\n\t\t\t\tstorageService.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getItems(storageService: IStorageService): Map<string, IStorageValue> {\n\t\tconst result = new Map<string, IStorageValue>();\n\t\tconst populate = (target: StorageTarget) => {\n\t\t\tfor (const key of storageService.keys(StorageScope.PROFILE, target)) {\n\t\t\t\tresult.set(key, { value: storageService.get(key, StorageScope.PROFILE), target });\n\t\t\t}\n\t\t};\n\t\tpopulate(StorageTarget.USER);\n\t\tpopulate(StorageTarget.MACHINE);\n\t\treturn result;\n\t}\n\n\tprivate writeItems(storageService: IStorageService, items: Map<string, string | undefined | null>, target: StorageTarget): void {\n\t\tstorageService.storeAll(Array.from(items.entries()).map(([key, value]) => ({ key, value, scope: StorageScope.PROFILE, target })), true);\n\t}\n\n\tprotected abstract createStorageDatabase(profile: IUserDataProfile): Promise<IStorageDatabase>;\n}\n\nexport class RemoteUserDataProfileStorageService extends AbstractUserDataProfileStorageService implements IUserDataProfileStorageService {\n\n\tprivate readonly _onDidChange: Emitter<IProfileStorageChanges>;\n\treadonly onDidChange: Event<IProfileStorageChanges>;\n\n\tconstructor(\n\t\tpersistStorages: boolean,\n\t\tprivate readonly remoteService: IRemoteService,\n\t\tuserDataProfilesService: IUserDataProfilesService,\n\t\tstorageService: IStorageService,\n\t\tlogService: ILogService,\n\t) {\n\t\tsuper(persistStorages, storageService);\n\n\t\tconst channel = remoteService.getChannel('profileStorageListener');\n\t\tconst disposable = this._register(new MutableDisposable());\n\t\tthis._onDidChange = this._register(new Emitter<IProfileStorageChanges>({\n\t\t\t// Start listening to profile storage changes only when someone is listening\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tdisposable.value = channel.listen<IProfileStorageChanges>('onDidChange')(e => {\n\t\t\t\t\tlogService.trace('profile storage changes', e);\n\t\t\t\t\tthis._onDidChange.fire({\n\t\t\t\t\t\ttargetChanges: e.targetChanges.map(profile => reviveProfile(profile, userDataProfilesService.profilesHome.scheme)),\n\t\t\t\t\t\tvalueChanges: e.valueChanges.map(e => ({ ...e, profile: reviveProfile(e.profile, userDataProfilesService.profilesHome.scheme) }))\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\t// Stop listening to profile storage changes when no one is listening\n\t\t\tonDidRemoveLastListener: () => disposable.value = undefined\n\t\t}));\n\t\tthis.onDidChange = this._onDidChange.event;\n\t}\n\n\tprotected async createStorageDatabase(profile: IUserDataProfile): Promise<IStorageDatabase> {\n\t\tconst storageChannel = this.remoteService.getChannel('storage');\n\t\treturn isProfileUsingDefaultStorage(profile) ? new ApplicationStorageDatabaseClient(storageChannel) : new ProfileStorageDatabaseClient(storageChannel, profile);\n\t}\n}\n\nclass StorageService extends AbstractStorageService {\n\n\tprivate profileStorage: IStorage | undefined;\n\n\tconstructor(private readonly profileStorageDatabase: Promise<IStorageDatabase>) {\n\t\tsuper({ flushInterval: 100 });\n\t}\n\n\tprotected async doInitialize(): Promise<void> {\n\t\tconst profileStorageDatabase = await this.profileStorageDatabase;\n\t\tconst profileStorage = new Storage(profileStorageDatabase);\n\t\tthis._register(profileStorage.onDidChangeStorage(e => {\n\t\t\tthis.emitDidChangeValue(StorageScope.PROFILE, e);\n\t\t}));\n\t\tthis._register(toDisposable(() => {\n\t\t\tprofileStorage.close();\n\t\t\tprofileStorage.dispose();\n\t\t\tif (isDisposable(profileStorageDatabase)) {\n\t\t\t\tprofileStorageDatabase.dispose();\n\t\t\t}\n\t\t}));\n\t\tthis.profileStorage = profileStorage;\n\t\treturn this.profileStorage.init();\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage | undefined {\n\t\treturn scope === StorageScope.PROFILE ? this.profileStorage : undefined;\n\t}\n\n\tprotected getLogDetails(): string | undefined { return undefined; }\n\tprotected async switchToProfile(): Promise<void> { }\n\tprotected async switchToWorkspace(): Promise<void> { }\n\thasScope() { return false; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableMap, MutableDisposable, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { IStorage, IStorageDatabase, Storage } from '../../../base/parts/storage/common/storage.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { AbstractStorageService, IStorageService, IStorageValueChangeEvent, StorageScope, StorageTarget, isProfileUsingDefaultStorage } from '../../storage/common/storage.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IRemoteService } from '../../ipc/common/services.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ApplicationStorageDatabaseClient, ProfileStorageDatabaseClient } from '../../storage/common/storageIpc.js';\nimport { IUserDataProfile, IUserDataProfilesService, reviveProfile } from './userDataProfile.js';\n\nexport interface IProfileStorageValueChanges {\n\treadonly profile: IUserDataProfile;\n\treadonly changes: IStorageValueChangeEvent[];\n}\n\nexport interface IProfileStorageChanges {\n\treadonly targetChanges: IUserDataProfile[];\n\treadonly valueChanges: IProfileStorageValueChanges[];\n}\n\nexport interface IStorageValue {\n\treadonly value: string | undefined;\n\treadonly target: StorageTarget;\n}\n\nexport const IUserDataProfileStorageService = createDecorator<IUserDataProfileStorageService>('IUserDataProfileStorageService');\nexport interface IUserDataProfileStorageService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted whenever data is updated or deleted in a profile storage or target of a profile storage entry changes\n\t */\n\treadonly onDidChange: Event<IProfileStorageChanges>;\n\n\t/**\n\t * Return the requested profile storage data\n\t * @param profile The profile from which the data has to be read from\n\t */\n\treadStorageData(profile: IUserDataProfile): Promise<Map<string, IStorageValue>>;\n\n\t/**\n\t * Update the given profile storage data in the profile storage\n\t * @param profile The profile to which the data has to be written to\n\t * @param data Data that has to be updated\n\t * @param target Storage target of the data\n\t */\n\tupdateStorageData(profile: IUserDataProfile, data: Map<string, string | undefined | null>, target: StorageTarget): Promise<void>;\n\n\t/**\n\t * Calls a function with a storage service scoped to given profile.\n\t */\n\twithProfileScopedStorageService<T>(profile: IUserDataProfile, fn: (storageService: IStorageService) => Promise<T>): Promise<T>;\n}\n\nexport abstract class AbstractUserDataProfileStorageService extends Disposable implements IUserDataProfileStorageService {\n\n\t_serviceBrand: undefined;\n\n\treadonly abstract onDidChange: Event<IProfileStorageChanges>;\n\n\tprivate readonly storageServicesMap: DisposableMap<string, StorageService> | undefined;\n\n\tconstructor(\n\t\tpersistStorages: boolean,\n\t\t@IStorageService protected readonly storageService: IStorageService\n\t) {\n\t\tsuper();\n\t\tif (persistStorages) {\n\t\t\tthis.storageServicesMap = this._register(new DisposableMap<string, StorageService>());\n\t\t}\n\t}\n\n\tasync readStorageData(profile: IUserDataProfile): Promise<Map<string, IStorageValue>> {\n\t\treturn this.withProfileScopedStorageService(profile, async storageService => this.getItems(storageService));\n\t}\n\n\tasync updateStorageData(profile: IUserDataProfile, data: Map<string, string | undefined | null>, target: StorageTarget): Promise<void> {\n\t\treturn this.withProfileScopedStorageService(profile, async storageService => this.writeItems(storageService, data, target));\n\t}\n\n\tasync withProfileScopedStorageService<T>(profile: IUserDataProfile, fn: (storageService: IStorageService) => Promise<T>): Promise<T> {\n\t\tif (this.storageService.hasScope(profile)) {\n\t\t\treturn fn(this.storageService);\n\t\t}\n\n\t\tlet storageService = this.storageServicesMap?.get(profile.id);\n\t\tif (!storageService) {\n\t\t\tstorageService = new StorageService(this.createStorageDatabase(profile));\n\t\t\tthis.storageServicesMap?.set(profile.id, storageService);\n\n\t\t\ttry {\n\t\t\t\tawait storageService.initialize();\n\t\t\t} catch (error) {\n\t\t\t\tif (this.storageServicesMap?.has(profile.id)) {\n\t\t\t\t\tthis.storageServicesMap.deleteAndDispose(profile.id);\n\t\t\t\t} else {\n\t\t\t\t\tstorageService.dispose();\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tconst result = await fn(storageService);\n\t\t\tawait storageService.flush();\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tif (!this.storageServicesMap?.has(profile.id)) {\n\t\t\t\tstorageService.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getItems(storageService: IStorageService): Map<string, IStorageValue> {\n\t\tconst result = new Map<string, IStorageValue>();\n\t\tconst populate = (target: StorageTarget) => {\n\t\t\tfor (const key of storageService.keys(StorageScope.PROFILE, target)) {\n\t\t\t\tresult.set(key, { value: storageService.get(key, StorageScope.PROFILE), target });\n\t\t\t}\n\t\t};\n\t\tpopulate(StorageTarget.USER);\n\t\tpopulate(StorageTarget.MACHINE);\n\t\treturn result;\n\t}\n\n\tprivate writeItems(storageService: IStorageService, items: Map<string, string | undefined | null>, target: StorageTarget): void {\n\t\tstorageService.storeAll(Array.from(items.entries()).map(([key, value]) => ({ key, value, scope: StorageScope.PROFILE, target })), true);\n\t}\n\n\tprotected abstract createStorageDatabase(profile: IUserDataProfile): Promise<IStorageDatabase>;\n}\n\nexport class RemoteUserDataProfileStorageService extends AbstractUserDataProfileStorageService implements IUserDataProfileStorageService {\n\n\tprivate readonly _onDidChange: Emitter<IProfileStorageChanges>;\n\treadonly onDidChange: Event<IProfileStorageChanges>;\n\n\tconstructor(\n\t\tpersistStorages: boolean,\n\t\tprivate readonly remoteService: IRemoteService,\n\t\tuserDataProfilesService: IUserDataProfilesService,\n\t\tstorageService: IStorageService,\n\t\tlogService: ILogService,\n\t) {\n\t\tsuper(persistStorages, storageService);\n\n\t\tconst channel = remoteService.getChannel('profileStorageListener');\n\t\tconst disposable = this._register(new MutableDisposable());\n\t\tthis._onDidChange = this._register(new Emitter<IProfileStorageChanges>({\n\t\t\t// Start listening to profile storage changes only when someone is listening\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tdisposable.value = channel.listen<IProfileStorageChanges>('onDidChange')(e => {\n\t\t\t\t\tlogService.trace('profile storage changes', e);\n\t\t\t\t\tthis._onDidChange.fire({\n\t\t\t\t\t\ttargetChanges: e.targetChanges.map(profile => reviveProfile(profile, userDataProfilesService.profilesHome.scheme)),\n\t\t\t\t\t\tvalueChanges: e.valueChanges.map(e => ({ ...e, profile: reviveProfile(e.profile, userDataProfilesService.profilesHome.scheme) }))\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\t// Stop listening to profile storage changes when no one is listening\n\t\t\tonDidRemoveLastListener: () => disposable.value = undefined\n\t\t}));\n\t\tthis.onDidChange = this._onDidChange.event;\n\t}\n\n\tprotected async createStorageDatabase(profile: IUserDataProfile): Promise<IStorageDatabase> {\n\t\tconst storageChannel = this.remoteService.getChannel('storage');\n\t\treturn isProfileUsingDefaultStorage(profile) ? new ApplicationStorageDatabaseClient(storageChannel) : new ProfileStorageDatabaseClient(storageChannel, profile);\n\t}\n}\n\nclass StorageService extends AbstractStorageService {\n\n\tprivate profileStorage: IStorage | undefined;\n\n\tconstructor(private readonly profileStorageDatabase: Promise<IStorageDatabase>) {\n\t\tsuper({ flushInterval: 100 });\n\t}\n\n\tprotected async doInitialize(): Promise<void> {\n\t\tconst profileStorageDatabase = await this.profileStorageDatabase;\n\t\tconst profileStorage = new Storage(profileStorageDatabase);\n\t\tthis._register(profileStorage.onDidChangeStorage(e => {\n\t\t\tthis.emitDidChangeValue(StorageScope.PROFILE, e);\n\t\t}));\n\t\tthis._register(toDisposable(() => {\n\t\t\tprofileStorage.close();\n\t\t\tprofileStorage.dispose();\n\t\t\tif (isDisposable(profileStorageDatabase)) {\n\t\t\t\tprofileStorageDatabase.dispose();\n\t\t\t}\n\t\t}));\n\t\tthis.profileStorage = profileStorage;\n\t\treturn this.profileStorage.init();\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage | undefined {\n\t\treturn scope === StorageScope.PROFILE ? this.profileStorage : undefined;\n\t}\n\n\tprotected getLogDetails(): string | undefined { return undefined; }\n\tprotected async switchToProfile(): Promise<void> { }\n\tprotected async switchToWorkspace(): Promise<void> { }\n\thasScope() { return false; }\n}\n"]}