{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/storage/electron-main/storageMain.ts","vs/platform/storage/electron-main/storageMain.ts"],"names":[],"mappings":"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","file":"storageMain.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { top } from '../../../base/common/arrays.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { join } from '../../../base/common/path.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Promises } from '../../../base/node/pfs.js';\nimport { InMemoryStorageDatabase, IStorage, Storage, StorageHint, StorageState } from '../../../base/parts/storage/common/storage.js';\nimport { ISQLiteStorageDatabaseLoggingOptions, SQLiteStorageDatabase } from '../../../base/parts/storage/node/storage.js';\nimport { IEnvironmentService } from '../../environment/common/environment.js';\nimport { IFileService } from '../../files/common/files.js';\nimport { ILogService, LogLevel } from '../../log/common/log.js';\nimport { IS_NEW_KEY } from '../common/storage.js';\nimport { IUserDataProfile, IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\nimport { currentSessionDateStorageKey, firstSessionDateStorageKey, lastSessionDateStorageKey } from '../../telemetry/common/telemetry.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IAnyWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { Schemas } from '../../../base/common/network.js';\n\nexport interface IStorageMainOptions {\n\n\t/**\n\t * If enabled, storage will not persist to disk\n\t * but into memory.\n\t */\n\treadonly useInMemoryStorage?: boolean;\n}\n\n/**\n * Provides access to application, profile and workspace storage from\n * the electron-main side that is the owner of all storage connections.\n */\nexport interface IStorageMain extends IDisposable {\n\n\t/**\n\t * Emitted whenever data is updated or deleted.\n\t */\n\treadonly onDidChangeStorage: Event<IStorageChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is closed.\n\t */\n\treadonly onDidCloseStorage: Event<void>;\n\n\t/**\n\t * Access to all cached items of this storage service.\n\t */\n\treadonly items: Map<string, string>;\n\n\t/**\n\t * Allows to join on the `init` call having completed\n\t * to be able to safely use the storage.\n\t */\n\treadonly whenInit: Promise<void>;\n\n\t/**\n\t * Provides access to the `IStorage` implementation which will be\n\t * in-memory for as long as the storage has not been initialized.\n\t */\n\treadonly storage: IStorage;\n\n\t/**\n\t * The file path of the underlying storage file if any.\n\t */\n\treadonly path: string | undefined;\n\n\t/**\n\t * Required call to ensure the service can be used.\n\t */\n\tinit(): Promise<void>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided defaultValue if the element is null or undefined.\n\t */\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Store a string value under the given key to storage. The value will\n\t * be converted to a string.\n\t */\n\tset(key: string, value: string | boolean | number | undefined | null): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t */\n\tdelete(key: string): void;\n\n\t/**\n\t * Whether the storage is using in-memory persistence or not.\n\t */\n\tisInMemory(): boolean;\n\n\t/**\n\t * Attempts to reduce the DB size via optimization commands if supported.\n\t */\n\toptimize(): Promise<void>;\n\n\t/**\n\t * Close the storage connection.\n\t */\n\tclose(): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\treadonly key: string;\n}\n\nabstract class BaseStorageMain extends Disposable implements IStorageMain {\n\n\tprivate static readonly LOG_SLOW_CLOSE_THRESHOLD = 2000;\n\n\tprotected readonly _onDidChangeStorage = this._register(new Emitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate readonly _onDidCloseStorage = this._register(new Emitter<void>());\n\treadonly onDidCloseStorage = this._onDidCloseStorage.event;\n\n\tprivate _storage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY })); // storage is in-memory until initialized\n\tget storage(): IStorage { return this._storage; }\n\n\tabstract get path(): string | undefined;\n\n\tprivate initializePromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenInitPromise = new DeferredPromise<void>();\n\treadonly whenInit = this.whenInitPromise.p;\n\n\tprivate state = StorageState.None;\n\n\tconstructor(\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly fileService: IFileService\n\t) {\n\t\tsuper();\n\t}\n\n\tisInMemory(): boolean {\n\t\treturn this._storage.isInMemory();\n\t}\n\n\tinit(): Promise<void> {\n\t\tif (!this.initializePromise) {\n\t\t\tthis.initializePromise = (async () => {\n\t\t\t\tif (this.state !== StorageState.None) {\n\t\t\t\t\treturn; // either closed or already initialized\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Create storage via subclasses\n\t\t\t\t\tconst storage = this._register(await this.doCreate());\n\n\t\t\t\t\t// Replace our in-memory storage with the real\n\t\t\t\t\t// once as soon as possible without awaiting\n\t\t\t\t\t// the init call.\n\t\t\t\t\tthis._storage.dispose();\n\t\t\t\t\tthis._storage = storage;\n\n\t\t\t\t\t// Re-emit storage changes via event\n\t\t\t\t\tthis._register(storage.onDidChangeStorage(e => this._onDidChangeStorage.fire(e)));\n\n\t\t\t\t\t// Await storage init\n\t\t\t\t\tawait this.doInit(storage);\n\n\t\t\t\t\t// Ensure we track whether storage is new or not\n\t\t\t\t\tconst isNewStorage = storage.getBoolean(IS_NEW_KEY);\n\t\t\t\t\tif (isNewStorage === undefined) {\n\t\t\t\t\t\tstorage.set(IS_NEW_KEY, true);\n\t\t\t\t\t} else if (isNewStorage) {\n\t\t\t\t\t\tstorage.set(IS_NEW_KEY, false);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(`[storage main] initialize(): Unable to init storage due to ${error}`);\n\t\t\t\t} finally {\n\n\t\t\t\t\t// Update state\n\t\t\t\t\tthis.state = StorageState.Initialized;\n\n\t\t\t\t\t// Mark init promise as completed\n\t\t\t\t\tthis.whenInitPromise.complete();\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this.initializePromise;\n\t}\n\n\tprotected createLoggingOptions(): ISQLiteStorageDatabaseLoggingOptions {\n\t\treturn {\n\t\t\tlogTrace: (this.logService.getLevel() === LogLevel.Trace) ? msg => this.logService.trace(msg) : undefined,\n\t\t\tlogError: error => this.logService.error(error)\n\t\t};\n\t}\n\n\tprotected doInit(storage: IStorage): Promise<void> {\n\t\treturn storage.init();\n\t}\n\n\tprotected abstract doCreate(): Promise<Storage>;\n\n\tget items(): Map<string, string> { return this._storage.items; }\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\treturn this._storage.get(key, fallbackValue);\n\t}\n\n\tset(key: string, value: string | boolean | number | undefined | null): Promise<void> {\n\t\treturn this._storage.set(key, value);\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\treturn this._storage.delete(key);\n\t}\n\n\toptimize(): Promise<void> {\n\t\treturn this._storage.optimize();\n\t}\n\n\tasync close(): Promise<void> {\n\n\t\t// Measure how long it takes to close storage\n\t\tconst watch = new StopWatch(false);\n\t\tawait this.doClose();\n\t\twatch.stop();\n\n\t\t// If close() is taking a long time, there is\n\t\t// a chance that the underlying DB is large\n\t\t// either on disk or in general. In that case\n\t\t// log some additional info to further diagnose\n\t\tif (watch.elapsed() > BaseStorageMain.LOG_SLOW_CLOSE_THRESHOLD) {\n\t\t\tawait this.logSlowClose(watch);\n\t\t}\n\n\t\t// Signal as event\n\t\tthis._onDidCloseStorage.fire();\n\t}\n\n\tprivate async logSlowClose(watch: StopWatch) {\n\t\tif (!this.path) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst largestEntries = top(Array.from(this._storage.items.entries())\n\t\t\t\t.map(([key, value]) => ({ key, length: value.length })), (entryA, entryB) => entryB.length - entryA.length, 5)\n\t\t\t\t.map(entry => `${entry.key}:${entry.length}`).join(', ');\n\t\t\tconst dbSize = (await this.fileService.stat(URI.file(this.path))).size;\n\n\t\t\tthis.logService.warn(`[storage main] detected slow close() operation: Time: ${watch.elapsed()}ms, DB size: ${dbSize}b, Large Keys: ${largestEntries}`);\n\t\t} catch (error) {\n\t\t\tthis.logService.error('[storage main] figuring out stats for slow DB on close() resulted in an error', error);\n\t\t}\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Ensure we are not accidentally leaving\n\t\t// a pending initialized storage behind in\n\t\t// case `close()` was called before `init()`\n\t\t// finishes.\n\t\tif (this.initializePromise) {\n\t\t\tawait this.initializePromise;\n\t\t}\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Propagate to storage lib\n\t\tawait this._storage.close();\n\t}\n}\n\nclass BaseProfileAwareStorageMain extends BaseStorageMain {\n\n\tprivate static readonly STORAGE_NAME = 'state.vscdb';\n\n\tget path(): string | undefined {\n\t\tif (!this.options.useInMemoryStorage) {\n\t\t\treturn join(this.profile.globalStorageHome.with({ scheme: Schemas.file }).fsPath, BaseProfileAwareStorageMain.STORAGE_NAME);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tconstructor(\n\t\tprivate readonly profile: IUserDataProfile,\n\t\tprivate readonly options: IStorageMainOptions,\n\t\tlogService: ILogService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(logService, fileService);\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\treturn new Storage(new SQLiteStorageDatabase(this.path ?? SQLiteStorageDatabase.IN_MEMORY_PATH, {\n\t\t\tlogging: this.createLoggingOptions()\n\t\t}), !this.path ? { hint: StorageHint.STORAGE_IN_MEMORY } : undefined);\n\t}\n}\n\nexport class ProfileStorageMain extends BaseProfileAwareStorageMain {\n\n}\n\nexport class ApplicationStorageMain extends BaseProfileAwareStorageMain {\n\n\tconstructor(\n\t\toptions: IStorageMainOptions,\n\t\tuserDataProfileService: IUserDataProfilesService,\n\t\tlogService: ILogService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(userDataProfileService.defaultProfile, options, logService, fileService);\n\t}\n\n\tprotected override async doInit(storage: IStorage): Promise<void> {\n\t\tawait super.doInit(storage);\n\n\t\t// Apply telemetry values as part of the application storage initialization\n\t\tthis.updateTelemetryState(storage);\n\t}\n\n\tprivate updateTelemetryState(storage: IStorage): void {\n\n\t\t// First session date (once)\n\t\tconst firstSessionDate = storage.get(firstSessionDateStorageKey, undefined);\n\t\tif (firstSessionDate === undefined) {\n\t\t\tstorage.set(firstSessionDateStorageKey, new Date().toUTCString());\n\t\t}\n\n\t\t// Last / current session (always)\n\t\t// previous session date was the \"current\" one at that time\n\t\t// current session date is \"now\"\n\t\tconst lastSessionDate = storage.get(currentSessionDateStorageKey, undefined);\n\t\tconst currentSessionDate = new Date().toUTCString();\n\t\tstorage.set(lastSessionDateStorageKey, typeof lastSessionDate === 'undefined' ? null : lastSessionDate);\n\t\tstorage.set(currentSessionDateStorageKey, currentSessionDate);\n\t}\n}\n\nexport class WorkspaceStorageMain extends BaseStorageMain {\n\n\tprivate static readonly WORKSPACE_STORAGE_NAME = 'state.vscdb';\n\tprivate static readonly WORKSPACE_META_NAME = 'workspace.json';\n\n\tget path(): string | undefined {\n\t\tif (!this.options.useInMemoryStorage) {\n\t\t\treturn join(this.environmentService.workspaceStorageHome.with({ scheme: Schemas.file }).fsPath, this.workspace.id, WorkspaceStorageMain.WORKSPACE_STORAGE_NAME);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tconstructor(\n\t\tprivate workspace: IAnyWorkspaceIdentifier,\n\t\tprivate readonly options: IStorageMainOptions,\n\t\tlogService: ILogService,\n\t\tprivate readonly environmentService: IEnvironmentService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(logService, fileService);\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\tconst { storageFilePath, wasCreated } = await this.prepareWorkspaceStorageFolder();\n\n\t\treturn new Storage(new SQLiteStorageDatabase(storageFilePath, {\n\t\t\tlogging: this.createLoggingOptions()\n\t\t}), { hint: this.options.useInMemoryStorage ? StorageHint.STORAGE_IN_MEMORY : wasCreated ? StorageHint.STORAGE_DOES_NOT_EXIST : undefined });\n\t}\n\n\tprivate async prepareWorkspaceStorageFolder(): Promise<{ storageFilePath: string; wasCreated: boolean }> {\n\n\t\t// Return early if using inMemory storage\n\t\tif (this.options.useInMemoryStorage) {\n\t\t\treturn { storageFilePath: SQLiteStorageDatabase.IN_MEMORY_PATH, wasCreated: true };\n\t\t}\n\n\t\t// Otherwise, ensure the storage folder exists on disk\n\t\tconst workspaceStorageFolderPath = join(this.environmentService.workspaceStorageHome.with({ scheme: Schemas.file }).fsPath, this.workspace.id);\n\t\tconst workspaceStorageDatabasePath = join(workspaceStorageFolderPath, WorkspaceStorageMain.WORKSPACE_STORAGE_NAME);\n\n\t\tconst storageExists = await Promises.exists(workspaceStorageFolderPath);\n\t\tif (storageExists) {\n\t\t\treturn { storageFilePath: workspaceStorageDatabasePath, wasCreated: false };\n\t\t}\n\n\t\t// Ensure storage folder exists\n\t\tawait fs.promises.mkdir(workspaceStorageFolderPath, { recursive: true });\n\n\t\t// Write metadata into folder (but do not await)\n\t\tthis.ensureWorkspaceStorageFolderMeta(workspaceStorageFolderPath);\n\n\t\treturn { storageFilePath: workspaceStorageDatabasePath, wasCreated: true };\n\t}\n\n\tprivate async ensureWorkspaceStorageFolderMeta(workspaceStorageFolderPath: string): Promise<void> {\n\t\tlet meta: object | undefined = undefined;\n\t\tif (isSingleFolderWorkspaceIdentifier(this.workspace)) {\n\t\t\tmeta = { folder: this.workspace.uri.toString() };\n\t\t} else if (isWorkspaceIdentifier(this.workspace)) {\n\t\t\tmeta = { workspace: this.workspace.configPath.toString() };\n\t\t}\n\n\t\tif (meta) {\n\t\t\ttry {\n\t\t\t\tconst workspaceStorageMetaPath = join(workspaceStorageFolderPath, WorkspaceStorageMain.WORKSPACE_META_NAME);\n\t\t\t\tconst storageExists = await Promises.exists(workspaceStorageMetaPath);\n\t\t\t\tif (!storageExists) {\n\t\t\t\t\tawait Promises.writeFile(workspaceStorageMetaPath, JSON.stringify(meta, undefined, 2));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[storage main] ensureWorkspaceStorageFolderMeta(): Unable to create workspace storage metadata due to ${error}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class InMemoryStorageMain extends BaseStorageMain {\n\n\tget path(): string | undefined {\n\t\treturn undefined; // in-memory has no path\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\treturn new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY });\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { top } from '../../../base/common/arrays.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { join } from '../../../base/common/path.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Promises } from '../../../base/node/pfs.js';\nimport { InMemoryStorageDatabase, IStorage, Storage, StorageHint, StorageState } from '../../../base/parts/storage/common/storage.js';\nimport { ISQLiteStorageDatabaseLoggingOptions, SQLiteStorageDatabase } from '../../../base/parts/storage/node/storage.js';\nimport { IEnvironmentService } from '../../environment/common/environment.js';\nimport { IFileService } from '../../files/common/files.js';\nimport { ILogService, LogLevel } from '../../log/common/log.js';\nimport { IS_NEW_KEY } from '../common/storage.js';\nimport { IUserDataProfile, IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\nimport { currentSessionDateStorageKey, firstSessionDateStorageKey, lastSessionDateStorageKey } from '../../telemetry/common/telemetry.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IAnyWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { Schemas } from '../../../base/common/network.js';\n\nexport interface IStorageMainOptions {\n\n\t/**\n\t * If enabled, storage will not persist to disk\n\t * but into memory.\n\t */\n\treadonly useInMemoryStorage?: boolean;\n}\n\n/**\n * Provides access to application, profile and workspace storage from\n * the electron-main side that is the owner of all storage connections.\n */\nexport interface IStorageMain extends IDisposable {\n\n\t/**\n\t * Emitted whenever data is updated or deleted.\n\t */\n\treadonly onDidChangeStorage: Event<IStorageChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is closed.\n\t */\n\treadonly onDidCloseStorage: Event<void>;\n\n\t/**\n\t * Access to all cached items of this storage service.\n\t */\n\treadonly items: Map<string, string>;\n\n\t/**\n\t * Allows to join on the `init` call having completed\n\t * to be able to safely use the storage.\n\t */\n\treadonly whenInit: Promise<void>;\n\n\t/**\n\t * Provides access to the `IStorage` implementation which will be\n\t * in-memory for as long as the storage has not been initialized.\n\t */\n\treadonly storage: IStorage;\n\n\t/**\n\t * The file path of the underlying storage file if any.\n\t */\n\treadonly path: string | undefined;\n\n\t/**\n\t * Required call to ensure the service can be used.\n\t */\n\tinit(): Promise<void>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided defaultValue if the element is null or undefined.\n\t */\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Store a string value under the given key to storage. The value will\n\t * be converted to a string.\n\t */\n\tset(key: string, value: string | boolean | number | undefined | null): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t */\n\tdelete(key: string): void;\n\n\t/**\n\t * Whether the storage is using in-memory persistence or not.\n\t */\n\tisInMemory(): boolean;\n\n\t/**\n\t * Attempts to reduce the DB size via optimization commands if supported.\n\t */\n\toptimize(): Promise<void>;\n\n\t/**\n\t * Close the storage connection.\n\t */\n\tclose(): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\treadonly key: string;\n}\n\nabstract class BaseStorageMain extends Disposable implements IStorageMain {\n\n\tprivate static readonly LOG_SLOW_CLOSE_THRESHOLD = 2000;\n\n\tprotected readonly _onDidChangeStorage = this._register(new Emitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate readonly _onDidCloseStorage = this._register(new Emitter<void>());\n\treadonly onDidCloseStorage = this._onDidCloseStorage.event;\n\n\tprivate _storage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY })); // storage is in-memory until initialized\n\tget storage(): IStorage { return this._storage; }\n\n\tabstract get path(): string | undefined;\n\n\tprivate initializePromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenInitPromise = new DeferredPromise<void>();\n\treadonly whenInit = this.whenInitPromise.p;\n\n\tprivate state = StorageState.None;\n\n\tconstructor(\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly fileService: IFileService\n\t) {\n\t\tsuper();\n\t}\n\n\tisInMemory(): boolean {\n\t\treturn this._storage.isInMemory();\n\t}\n\n\tinit(): Promise<void> {\n\t\tif (!this.initializePromise) {\n\t\t\tthis.initializePromise = (async () => {\n\t\t\t\tif (this.state !== StorageState.None) {\n\t\t\t\t\treturn; // either closed or already initialized\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Create storage via subclasses\n\t\t\t\t\tconst storage = this._register(await this.doCreate());\n\n\t\t\t\t\t// Replace our in-memory storage with the real\n\t\t\t\t\t// once as soon as possible without awaiting\n\t\t\t\t\t// the init call.\n\t\t\t\t\tthis._storage.dispose();\n\t\t\t\t\tthis._storage = storage;\n\n\t\t\t\t\t// Re-emit storage changes via event\n\t\t\t\t\tthis._register(storage.onDidChangeStorage(e => this._onDidChangeStorage.fire(e)));\n\n\t\t\t\t\t// Await storage init\n\t\t\t\t\tawait this.doInit(storage);\n\n\t\t\t\t\t// Ensure we track whether storage is new or not\n\t\t\t\t\tconst isNewStorage = storage.getBoolean(IS_NEW_KEY);\n\t\t\t\t\tif (isNewStorage === undefined) {\n\t\t\t\t\t\tstorage.set(IS_NEW_KEY, true);\n\t\t\t\t\t} else if (isNewStorage) {\n\t\t\t\t\t\tstorage.set(IS_NEW_KEY, false);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(`[storage main] initialize(): Unable to init storage due to ${error}`);\n\t\t\t\t} finally {\n\n\t\t\t\t\t// Update state\n\t\t\t\t\tthis.state = StorageState.Initialized;\n\n\t\t\t\t\t// Mark init promise as completed\n\t\t\t\t\tthis.whenInitPromise.complete();\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this.initializePromise;\n\t}\n\n\tprotected createLoggingOptions(): ISQLiteStorageDatabaseLoggingOptions {\n\t\treturn {\n\t\t\tlogTrace: (this.logService.getLevel() === LogLevel.Trace) ? msg => this.logService.trace(msg) : undefined,\n\t\t\tlogError: error => this.logService.error(error)\n\t\t};\n\t}\n\n\tprotected doInit(storage: IStorage): Promise<void> {\n\t\treturn storage.init();\n\t}\n\n\tprotected abstract doCreate(): Promise<Storage>;\n\n\tget items(): Map<string, string> { return this._storage.items; }\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\treturn this._storage.get(key, fallbackValue);\n\t}\n\n\tset(key: string, value: string | boolean | number | undefined | null): Promise<void> {\n\t\treturn this._storage.set(key, value);\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\treturn this._storage.delete(key);\n\t}\n\n\toptimize(): Promise<void> {\n\t\treturn this._storage.optimize();\n\t}\n\n\tasync close(): Promise<void> {\n\n\t\t// Measure how long it takes to close storage\n\t\tconst watch = new StopWatch(false);\n\t\tawait this.doClose();\n\t\twatch.stop();\n\n\t\t// If close() is taking a long time, there is\n\t\t// a chance that the underlying DB is large\n\t\t// either on disk or in general. In that case\n\t\t// log some additional info to further diagnose\n\t\tif (watch.elapsed() > BaseStorageMain.LOG_SLOW_CLOSE_THRESHOLD) {\n\t\t\tawait this.logSlowClose(watch);\n\t\t}\n\n\t\t// Signal as event\n\t\tthis._onDidCloseStorage.fire();\n\t}\n\n\tprivate async logSlowClose(watch: StopWatch) {\n\t\tif (!this.path) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst largestEntries = top(Array.from(this._storage.items.entries())\n\t\t\t\t.map(([key, value]) => ({ key, length: value.length })), (entryA, entryB) => entryB.length - entryA.length, 5)\n\t\t\t\t.map(entry => `${entry.key}:${entry.length}`).join(', ');\n\t\t\tconst dbSize = (await this.fileService.stat(URI.file(this.path))).size;\n\n\t\t\tthis.logService.warn(`[storage main] detected slow close() operation: Time: ${watch.elapsed()}ms, DB size: ${dbSize}b, Large Keys: ${largestEntries}`);\n\t\t} catch (error) {\n\t\t\tthis.logService.error('[storage main] figuring out stats for slow DB on close() resulted in an error', error);\n\t\t}\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Ensure we are not accidentally leaving\n\t\t// a pending initialized storage behind in\n\t\t// case `close()` was called before `init()`\n\t\t// finishes.\n\t\tif (this.initializePromise) {\n\t\t\tawait this.initializePromise;\n\t\t}\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Propagate to storage lib\n\t\tawait this._storage.close();\n\t}\n}\n\nclass BaseProfileAwareStorageMain extends BaseStorageMain {\n\n\tprivate static readonly STORAGE_NAME = 'state.vscdb';\n\n\tget path(): string | undefined {\n\t\tif (!this.options.useInMemoryStorage) {\n\t\t\treturn join(this.profile.globalStorageHome.with({ scheme: Schemas.file }).fsPath, BaseProfileAwareStorageMain.STORAGE_NAME);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tconstructor(\n\t\tprivate readonly profile: IUserDataProfile,\n\t\tprivate readonly options: IStorageMainOptions,\n\t\tlogService: ILogService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(logService, fileService);\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\treturn new Storage(new SQLiteStorageDatabase(this.path ?? SQLiteStorageDatabase.IN_MEMORY_PATH, {\n\t\t\tlogging: this.createLoggingOptions()\n\t\t}), !this.path ? { hint: StorageHint.STORAGE_IN_MEMORY } : undefined);\n\t}\n}\n\nexport class ProfileStorageMain extends BaseProfileAwareStorageMain {\n\n}\n\nexport class ApplicationStorageMain extends BaseProfileAwareStorageMain {\n\n\tconstructor(\n\t\toptions: IStorageMainOptions,\n\t\tuserDataProfileService: IUserDataProfilesService,\n\t\tlogService: ILogService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(userDataProfileService.defaultProfile, options, logService, fileService);\n\t}\n\n\tprotected override async doInit(storage: IStorage): Promise<void> {\n\t\tawait super.doInit(storage);\n\n\t\t// Apply telemetry values as part of the application storage initialization\n\t\tthis.updateTelemetryState(storage);\n\t}\n\n\tprivate updateTelemetryState(storage: IStorage): void {\n\n\t\t// First session date (once)\n\t\tconst firstSessionDate = storage.get(firstSessionDateStorageKey, undefined);\n\t\tif (firstSessionDate === undefined) {\n\t\t\tstorage.set(firstSessionDateStorageKey, new Date().toUTCString());\n\t\t}\n\n\t\t// Last / current session (always)\n\t\t// previous session date was the \"current\" one at that time\n\t\t// current session date is \"now\"\n\t\tconst lastSessionDate = storage.get(currentSessionDateStorageKey, undefined);\n\t\tconst currentSessionDate = new Date().toUTCString();\n\t\tstorage.set(lastSessionDateStorageKey, typeof lastSessionDate === 'undefined' ? null : lastSessionDate);\n\t\tstorage.set(currentSessionDateStorageKey, currentSessionDate);\n\t}\n}\n\nexport class WorkspaceStorageMain extends BaseStorageMain {\n\n\tprivate static readonly WORKSPACE_STORAGE_NAME = 'state.vscdb';\n\tprivate static readonly WORKSPACE_META_NAME = 'workspace.json';\n\n\tget path(): string | undefined {\n\t\tif (!this.options.useInMemoryStorage) {\n\t\t\treturn join(this.environmentService.workspaceStorageHome.with({ scheme: Schemas.file }).fsPath, this.workspace.id, WorkspaceStorageMain.WORKSPACE_STORAGE_NAME);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tconstructor(\n\t\tprivate workspace: IAnyWorkspaceIdentifier,\n\t\tprivate readonly options: IStorageMainOptions,\n\t\tlogService: ILogService,\n\t\tprivate readonly environmentService: IEnvironmentService,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper(logService, fileService);\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\tconst { storageFilePath, wasCreated } = await this.prepareWorkspaceStorageFolder();\n\n\t\treturn new Storage(new SQLiteStorageDatabase(storageFilePath, {\n\t\t\tlogging: this.createLoggingOptions()\n\t\t}), { hint: this.options.useInMemoryStorage ? StorageHint.STORAGE_IN_MEMORY : wasCreated ? StorageHint.STORAGE_DOES_NOT_EXIST : undefined });\n\t}\n\n\tprivate async prepareWorkspaceStorageFolder(): Promise<{ storageFilePath: string; wasCreated: boolean }> {\n\n\t\t// Return early if using inMemory storage\n\t\tif (this.options.useInMemoryStorage) {\n\t\t\treturn { storageFilePath: SQLiteStorageDatabase.IN_MEMORY_PATH, wasCreated: true };\n\t\t}\n\n\t\t// Otherwise, ensure the storage folder exists on disk\n\t\tconst workspaceStorageFolderPath = join(this.environmentService.workspaceStorageHome.with({ scheme: Schemas.file }).fsPath, this.workspace.id);\n\t\tconst workspaceStorageDatabasePath = join(workspaceStorageFolderPath, WorkspaceStorageMain.WORKSPACE_STORAGE_NAME);\n\n\t\tconst storageExists = await Promises.exists(workspaceStorageFolderPath);\n\t\tif (storageExists) {\n\t\t\treturn { storageFilePath: workspaceStorageDatabasePath, wasCreated: false };\n\t\t}\n\n\t\t// Ensure storage folder exists\n\t\tawait fs.promises.mkdir(workspaceStorageFolderPath, { recursive: true });\n\n\t\t// Write metadata into folder (but do not await)\n\t\tthis.ensureWorkspaceStorageFolderMeta(workspaceStorageFolderPath);\n\n\t\treturn { storageFilePath: workspaceStorageDatabasePath, wasCreated: true };\n\t}\n\n\tprivate async ensureWorkspaceStorageFolderMeta(workspaceStorageFolderPath: string): Promise<void> {\n\t\tlet meta: object | undefined = undefined;\n\t\tif (isSingleFolderWorkspaceIdentifier(this.workspace)) {\n\t\t\tmeta = { folder: this.workspace.uri.toString() };\n\t\t} else if (isWorkspaceIdentifier(this.workspace)) {\n\t\t\tmeta = { workspace: this.workspace.configPath.toString() };\n\t\t}\n\n\t\tif (meta) {\n\t\t\ttry {\n\t\t\t\tconst workspaceStorageMetaPath = join(workspaceStorageFolderPath, WorkspaceStorageMain.WORKSPACE_META_NAME);\n\t\t\t\tconst storageExists = await Promises.exists(workspaceStorageMetaPath);\n\t\t\t\tif (!storageExists) {\n\t\t\t\t\tawait Promises.writeFile(workspaceStorageMetaPath, JSON.stringify(meta, undefined, 2));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[storage main] ensureWorkspaceStorageFolderMeta(): Unable to create workspace storage metadata due to ${error}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class InMemoryStorageMain extends BaseStorageMain {\n\n\tget path(): string | undefined {\n\t\treturn undefined; // in-memory has no path\n\t}\n\n\tprotected async doCreate(): Promise<Storage> {\n\t\treturn new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY });\n\t}\n}\n"]}