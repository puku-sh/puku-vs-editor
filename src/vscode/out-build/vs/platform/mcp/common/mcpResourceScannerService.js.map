{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/mcp/common/mcpResourceScannerService.ts","vs/platform/mcp/common/mcpResourceScannerService.ts"],"names":[],"mappings":"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","file":"mcpResourceScannerService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../../base/common/assert.js';\nimport { Queue } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { parse, ParseError } from '../../../base/common/json.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Mutable } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ConfigurationTarget, ConfigurationTargetToString } from '../../configuration/common/configuration.js';\nimport { FileOperationResult, IFileService, toFileOperationResult } from '../../files/common/files.js';\nimport { InstantiationType, registerSingleton } from '../../instantiation/common/extensions.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IUriIdentityService } from '../../uriIdentity/common/uriIdentity.js';\nimport { IInstallableMcpServer } from './mcpManagement.js';\nimport { ICommonMcpServerConfiguration, IMcpServerConfiguration, IMcpServerVariable, IMcpStdioServerConfiguration, McpServerType } from './mcpPlatformTypes.js';\n\ninterface IScannedMcpServers {\n\tservers?: IStringDictionary<Mutable<IMcpServerConfiguration>>;\n\tinputs?: IMcpServerVariable[];\n}\n\ninterface IOldScannedMcpServer {\n\tid: string;\n\tname: string;\n\tversion?: string;\n\tgallery?: boolean;\n\tconfig: Mutable<IMcpServerConfiguration>;\n}\n\ninterface IScannedWorkspaceMcpServers {\n\tsettings?: {\n\t\tmcp?: IScannedMcpServers;\n\t};\n}\n\nexport type McpResourceTarget = ConfigurationTarget.USER | ConfigurationTarget.WORKSPACE | ConfigurationTarget.WORKSPACE_FOLDER;\n\nexport const IMcpResourceScannerService = createDecorator<IMcpResourceScannerService>('IMcpResourceScannerService');\nexport interface IMcpResourceScannerService {\n\treadonly _serviceBrand: undefined;\n\tscanMcpServers(mcpResource: URI, target?: McpResourceTarget): Promise<IScannedMcpServers>;\n\taddMcpServers(servers: IInstallableMcpServer[], mcpResource: URI, target?: McpResourceTarget): Promise<void>;\n\tremoveMcpServers(serverNames: string[], mcpResource: URI, target?: McpResourceTarget): Promise<void>;\n}\n\nexport class McpResourceScannerService extends Disposable implements IMcpResourceScannerService {\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly resourcesAccessQueueMap = new ResourceMap<Queue<IScannedMcpServers>>();\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IUriIdentityService protected readonly uriIdentityService: IUriIdentityService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync scanMcpServers(mcpResource: URI, target?: McpResourceTarget): Promise<IScannedMcpServers> {\n\t\treturn this.withProfileMcpServers(mcpResource, target);\n\t}\n\n\tasync addMcpServers(servers: IInstallableMcpServer[], mcpResource: URI, target?: McpResourceTarget): Promise<void> {\n\t\tawait this.withProfileMcpServers(mcpResource, target, scannedMcpServers => {\n\t\t\tlet updatedInputs = scannedMcpServers.inputs ?? [];\n\t\t\tconst existingServers = scannedMcpServers.servers ?? {};\n\t\t\tfor (const { name, config, inputs } of servers) {\n\t\t\t\texistingServers[name] = config;\n\t\t\t\tif (inputs) {\n\t\t\t\t\tconst existingInputIds = new Set(updatedInputs.map(input => input.id));\n\t\t\t\t\tconst newInputs = inputs.filter(input => !existingInputIds.has(input.id));\n\t\t\t\t\tupdatedInputs = [...updatedInputs, ...newInputs];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { servers: existingServers, inputs: updatedInputs };\n\t\t});\n\t}\n\n\tasync removeMcpServers(serverNames: string[], mcpResource: URI, target?: McpResourceTarget): Promise<void> {\n\t\tawait this.withProfileMcpServers(mcpResource, target, scannedMcpServers => {\n\t\t\tfor (const serverName of serverNames) {\n\t\t\t\tif (scannedMcpServers.servers?.[serverName]) {\n\t\t\t\t\tdelete scannedMcpServers.servers[serverName];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn scannedMcpServers;\n\t\t});\n\t}\n\n\tprivate async withProfileMcpServers(mcpResource: URI, target?: McpResourceTarget, updateFn?: (data: IScannedMcpServers) => IScannedMcpServers): Promise<IScannedMcpServers> {\n\t\treturn this.getResourceAccessQueue(mcpResource)\n\t\t\t.queue(async (): Promise<IScannedMcpServers> => {\n\t\t\t\ttarget = target ?? ConfigurationTarget.USER;\n\t\t\t\tlet scannedMcpServers: IScannedMcpServers = {};\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.fileService.readFile(mcpResource);\n\t\t\t\t\tconst errors: ParseError[] = [];\n\t\t\t\t\tconst result = parse(content.value.toString(), errors, { allowTrailingComma: true, allowEmptyContent: true }) || {};\n\t\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\t\tthrow new Error('Failed to parse scanned MCP servers: ' + errors.join(', '));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target === ConfigurationTarget.USER) {\n\t\t\t\t\t\tscannedMcpServers = this.fromUserMcpServers(result);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE_FOLDER) {\n\t\t\t\t\t\tscannedMcpServers = this.fromWorkspaceFolderMcpServers(result);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE) {\n\t\t\t\t\t\tconst workspaceScannedMcpServers: IScannedWorkspaceMcpServers = result;\n\t\t\t\t\t\tif (workspaceScannedMcpServers.settings?.mcp) {\n\t\t\t\t\t\t\tscannedMcpServers = this.fromWorkspaceFolderMcpServers(workspaceScannedMcpServers.settings?.mcp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (updateFn) {\n\t\t\t\t\tscannedMcpServers = updateFn(scannedMcpServers ?? {});\n\n\t\t\t\t\tif (target === ConfigurationTarget.USER) {\n\t\t\t\t\t\tawait this.writeScannedMcpServers(mcpResource, scannedMcpServers);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE_FOLDER) {\n\t\t\t\t\t\tawait this.writeScannedMcpServersToWorkspaceFolder(mcpResource, scannedMcpServers);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE) {\n\t\t\t\t\t\tawait this.writeScannedMcpServersToWorkspace(mcpResource, scannedMcpServers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertNever(target, `Invalid Target: ${ConfigurationTargetToString(target)}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn scannedMcpServers;\n\t\t\t});\n\t}\n\n\tprivate async writeScannedMcpServers(mcpResource: URI, scannedMcpServers: IScannedMcpServers): Promise<void> {\n\t\tif ((scannedMcpServers.servers && Object.keys(scannedMcpServers.servers).length > 0) || (scannedMcpServers.inputs && scannedMcpServers.inputs.length > 0)) {\n\t\t\tawait this.fileService.writeFile(mcpResource, VSBuffer.fromString(JSON.stringify(scannedMcpServers, null, '\\t')));\n\t\t} else {\n\t\t\tawait this.fileService.del(mcpResource);\n\t\t}\n\t}\n\n\tprivate async writeScannedMcpServersToWorkspaceFolder(mcpResource: URI, scannedMcpServers: IScannedMcpServers): Promise<void> {\n\t\tawait this.fileService.writeFile(mcpResource, VSBuffer.fromString(JSON.stringify(scannedMcpServers, null, '\\t')));\n\t}\n\n\tprivate async writeScannedMcpServersToWorkspace(mcpResource: URI, scannedMcpServers: IScannedMcpServers): Promise<void> {\n\t\tlet scannedWorkspaceMcpServers: IScannedWorkspaceMcpServers | undefined;\n\t\ttry {\n\t\t\tconst content = await this.fileService.readFile(mcpResource);\n\t\t\tconst errors: ParseError[] = [];\n\t\t\tscannedWorkspaceMcpServers = parse(content.value.toString(), errors, { allowTrailingComma: true, allowEmptyContent: true }) as IScannedWorkspaceMcpServers;\n\t\t\tif (errors.length > 0) {\n\t\t\t\tthrow new Error('Failed to parse scanned MCP servers: ' + errors.join(', '));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tscannedWorkspaceMcpServers = { settings: {} };\n\t\t}\n\t\tif (!scannedWorkspaceMcpServers.settings) {\n\t\t\tscannedWorkspaceMcpServers.settings = {};\n\t\t}\n\t\tscannedWorkspaceMcpServers.settings.mcp = scannedMcpServers;\n\t\tawait this.fileService.writeFile(mcpResource, VSBuffer.fromString(JSON.stringify(scannedWorkspaceMcpServers, null, '\\t')));\n\t}\n\n\tprivate fromUserMcpServers(scannedMcpServers: IScannedMcpServers): IScannedMcpServers {\n\t\tconst userMcpServers: IScannedMcpServers = {\n\t\t\tinputs: scannedMcpServers.inputs\n\t\t};\n\t\tconst servers = Object.entries(scannedMcpServers.servers ?? {});\n\t\tif (servers.length > 0) {\n\t\t\tuserMcpServers.servers = {};\n\t\t\tfor (const [serverName, server] of servers) {\n\t\t\t\tuserMcpServers.servers[serverName] = this.sanitizeServer(server);\n\t\t\t}\n\t\t}\n\t\treturn userMcpServers;\n\t}\n\n\tprivate fromWorkspaceFolderMcpServers(scannedWorkspaceFolderMcpServers: IScannedMcpServers): IScannedMcpServers {\n\t\tconst scannedMcpServers: IScannedMcpServers = {\n\t\t\tinputs: scannedWorkspaceFolderMcpServers.inputs\n\t\t};\n\t\tconst servers = Object.entries(scannedWorkspaceFolderMcpServers.servers ?? {});\n\t\tif (servers.length > 0) {\n\t\t\tscannedMcpServers.servers = {};\n\t\t\tfor (const [serverName, config] of servers) {\n\t\t\t\tscannedMcpServers.servers[serverName] = this.sanitizeServer(config);\n\t\t\t}\n\t\t}\n\t\treturn scannedMcpServers;\n\t}\n\n\tprivate sanitizeServer(serverOrConfig: IOldScannedMcpServer | Mutable<IMcpServerConfiguration>): IMcpServerConfiguration {\n\t\tlet server: IMcpServerConfiguration;\n\t\tif ((<IOldScannedMcpServer>serverOrConfig).config) {\n\t\t\tconst oldScannedMcpServer = <IOldScannedMcpServer>serverOrConfig;\n\t\t\tserver = {\n\t\t\t\t...oldScannedMcpServer.config,\n\t\t\t\tversion: oldScannedMcpServer.version,\n\t\t\t\tgallery: oldScannedMcpServer.gallery\n\t\t\t};\n\t\t} else {\n\t\t\tserver = serverOrConfig as IMcpServerConfiguration;\n\t\t}\n\n\t\tif (server.type === undefined || (server.type !== McpServerType.REMOTE && server.type !== McpServerType.LOCAL)) {\n\t\t\t(<Mutable<ICommonMcpServerConfiguration>>server).type = (<IMcpStdioServerConfiguration>server).command ? McpServerType.LOCAL : McpServerType.REMOTE;\n\t\t}\n\n\t\treturn server;\n\t}\n\n\tprivate getResourceAccessQueue(file: URI): Queue<IScannedMcpServers> {\n\t\tlet resourceQueue = this.resourcesAccessQueueMap.get(file);\n\t\tif (!resourceQueue) {\n\t\t\tresourceQueue = new Queue<IScannedMcpServers>();\n\t\t\tthis.resourcesAccessQueueMap.set(file, resourceQueue);\n\t\t}\n\t\treturn resourceQueue;\n\t}\n}\n\nregisterSingleton(IMcpResourceScannerService, McpResourceScannerService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../../base/common/assert.js';\nimport { Queue } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { parse, ParseError } from '../../../base/common/json.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Mutable } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ConfigurationTarget, ConfigurationTargetToString } from '../../configuration/common/configuration.js';\nimport { FileOperationResult, IFileService, toFileOperationResult } from '../../files/common/files.js';\nimport { InstantiationType, registerSingleton } from '../../instantiation/common/extensions.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IUriIdentityService } from '../../uriIdentity/common/uriIdentity.js';\nimport { IInstallableMcpServer } from './mcpManagement.js';\nimport { ICommonMcpServerConfiguration, IMcpServerConfiguration, IMcpServerVariable, IMcpStdioServerConfiguration, McpServerType } from './mcpPlatformTypes.js';\n\ninterface IScannedMcpServers {\n\tservers?: IStringDictionary<Mutable<IMcpServerConfiguration>>;\n\tinputs?: IMcpServerVariable[];\n}\n\ninterface IOldScannedMcpServer {\n\tid: string;\n\tname: string;\n\tversion?: string;\n\tgallery?: boolean;\n\tconfig: Mutable<IMcpServerConfiguration>;\n}\n\ninterface IScannedWorkspaceMcpServers {\n\tsettings?: {\n\t\tmcp?: IScannedMcpServers;\n\t};\n}\n\nexport type McpResourceTarget = ConfigurationTarget.USER | ConfigurationTarget.WORKSPACE | ConfigurationTarget.WORKSPACE_FOLDER;\n\nexport const IMcpResourceScannerService = createDecorator<IMcpResourceScannerService>('IMcpResourceScannerService');\nexport interface IMcpResourceScannerService {\n\treadonly _serviceBrand: undefined;\n\tscanMcpServers(mcpResource: URI, target?: McpResourceTarget): Promise<IScannedMcpServers>;\n\taddMcpServers(servers: IInstallableMcpServer[], mcpResource: URI, target?: McpResourceTarget): Promise<void>;\n\tremoveMcpServers(serverNames: string[], mcpResource: URI, target?: McpResourceTarget): Promise<void>;\n}\n\nexport class McpResourceScannerService extends Disposable implements IMcpResourceScannerService {\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly resourcesAccessQueueMap = new ResourceMap<Queue<IScannedMcpServers>>();\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IUriIdentityService protected readonly uriIdentityService: IUriIdentityService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync scanMcpServers(mcpResource: URI, target?: McpResourceTarget): Promise<IScannedMcpServers> {\n\t\treturn this.withProfileMcpServers(mcpResource, target);\n\t}\n\n\tasync addMcpServers(servers: IInstallableMcpServer[], mcpResource: URI, target?: McpResourceTarget): Promise<void> {\n\t\tawait this.withProfileMcpServers(mcpResource, target, scannedMcpServers => {\n\t\t\tlet updatedInputs = scannedMcpServers.inputs ?? [];\n\t\t\tconst existingServers = scannedMcpServers.servers ?? {};\n\t\t\tfor (const { name, config, inputs } of servers) {\n\t\t\t\texistingServers[name] = config;\n\t\t\t\tif (inputs) {\n\t\t\t\t\tconst existingInputIds = new Set(updatedInputs.map(input => input.id));\n\t\t\t\t\tconst newInputs = inputs.filter(input => !existingInputIds.has(input.id));\n\t\t\t\t\tupdatedInputs = [...updatedInputs, ...newInputs];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { servers: existingServers, inputs: updatedInputs };\n\t\t});\n\t}\n\n\tasync removeMcpServers(serverNames: string[], mcpResource: URI, target?: McpResourceTarget): Promise<void> {\n\t\tawait this.withProfileMcpServers(mcpResource, target, scannedMcpServers => {\n\t\t\tfor (const serverName of serverNames) {\n\t\t\t\tif (scannedMcpServers.servers?.[serverName]) {\n\t\t\t\t\tdelete scannedMcpServers.servers[serverName];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn scannedMcpServers;\n\t\t});\n\t}\n\n\tprivate async withProfileMcpServers(mcpResource: URI, target?: McpResourceTarget, updateFn?: (data: IScannedMcpServers) => IScannedMcpServers): Promise<IScannedMcpServers> {\n\t\treturn this.getResourceAccessQueue(mcpResource)\n\t\t\t.queue(async (): Promise<IScannedMcpServers> => {\n\t\t\t\ttarget = target ?? ConfigurationTarget.USER;\n\t\t\t\tlet scannedMcpServers: IScannedMcpServers = {};\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.fileService.readFile(mcpResource);\n\t\t\t\t\tconst errors: ParseError[] = [];\n\t\t\t\t\tconst result = parse(content.value.toString(), errors, { allowTrailingComma: true, allowEmptyContent: true }) || {};\n\t\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\t\tthrow new Error('Failed to parse scanned MCP servers: ' + errors.join(', '));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target === ConfigurationTarget.USER) {\n\t\t\t\t\t\tscannedMcpServers = this.fromUserMcpServers(result);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE_FOLDER) {\n\t\t\t\t\t\tscannedMcpServers = this.fromWorkspaceFolderMcpServers(result);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE) {\n\t\t\t\t\t\tconst workspaceScannedMcpServers: IScannedWorkspaceMcpServers = result;\n\t\t\t\t\t\tif (workspaceScannedMcpServers.settings?.mcp) {\n\t\t\t\t\t\t\tscannedMcpServers = this.fromWorkspaceFolderMcpServers(workspaceScannedMcpServers.settings?.mcp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (updateFn) {\n\t\t\t\t\tscannedMcpServers = updateFn(scannedMcpServers ?? {});\n\n\t\t\t\t\tif (target === ConfigurationTarget.USER) {\n\t\t\t\t\t\tawait this.writeScannedMcpServers(mcpResource, scannedMcpServers);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE_FOLDER) {\n\t\t\t\t\t\tawait this.writeScannedMcpServersToWorkspaceFolder(mcpResource, scannedMcpServers);\n\t\t\t\t\t} else if (target === ConfigurationTarget.WORKSPACE) {\n\t\t\t\t\t\tawait this.writeScannedMcpServersToWorkspace(mcpResource, scannedMcpServers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertNever(target, `Invalid Target: ${ConfigurationTargetToString(target)}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn scannedMcpServers;\n\t\t\t});\n\t}\n\n\tprivate async writeScannedMcpServers(mcpResource: URI, scannedMcpServers: IScannedMcpServers): Promise<void> {\n\t\tif ((scannedMcpServers.servers && Object.keys(scannedMcpServers.servers).length > 0) || (scannedMcpServers.inputs && scannedMcpServers.inputs.length > 0)) {\n\t\t\tawait this.fileService.writeFile(mcpResource, VSBuffer.fromString(JSON.stringify(scannedMcpServers, null, '\\t')));\n\t\t} else {\n\t\t\tawait this.fileService.del(mcpResource);\n\t\t}\n\t}\n\n\tprivate async writeScannedMcpServersToWorkspaceFolder(mcpResource: URI, scannedMcpServers: IScannedMcpServers): Promise<void> {\n\t\tawait this.fileService.writeFile(mcpResource, VSBuffer.fromString(JSON.stringify(scannedMcpServers, null, '\\t')));\n\t}\n\n\tprivate async writeScannedMcpServersToWorkspace(mcpResource: URI, scannedMcpServers: IScannedMcpServers): Promise<void> {\n\t\tlet scannedWorkspaceMcpServers: IScannedWorkspaceMcpServers | undefined;\n\t\ttry {\n\t\t\tconst content = await this.fileService.readFile(mcpResource);\n\t\t\tconst errors: ParseError[] = [];\n\t\t\tscannedWorkspaceMcpServers = parse(content.value.toString(), errors, { allowTrailingComma: true, allowEmptyContent: true }) as IScannedWorkspaceMcpServers;\n\t\t\tif (errors.length > 0) {\n\t\t\t\tthrow new Error('Failed to parse scanned MCP servers: ' + errors.join(', '));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tscannedWorkspaceMcpServers = { settings: {} };\n\t\t}\n\t\tif (!scannedWorkspaceMcpServers.settings) {\n\t\t\tscannedWorkspaceMcpServers.settings = {};\n\t\t}\n\t\tscannedWorkspaceMcpServers.settings.mcp = scannedMcpServers;\n\t\tawait this.fileService.writeFile(mcpResource, VSBuffer.fromString(JSON.stringify(scannedWorkspaceMcpServers, null, '\\t')));\n\t}\n\n\tprivate fromUserMcpServers(scannedMcpServers: IScannedMcpServers): IScannedMcpServers {\n\t\tconst userMcpServers: IScannedMcpServers = {\n\t\t\tinputs: scannedMcpServers.inputs\n\t\t};\n\t\tconst servers = Object.entries(scannedMcpServers.servers ?? {});\n\t\tif (servers.length > 0) {\n\t\t\tuserMcpServers.servers = {};\n\t\t\tfor (const [serverName, server] of servers) {\n\t\t\t\tuserMcpServers.servers[serverName] = this.sanitizeServer(server);\n\t\t\t}\n\t\t}\n\t\treturn userMcpServers;\n\t}\n\n\tprivate fromWorkspaceFolderMcpServers(scannedWorkspaceFolderMcpServers: IScannedMcpServers): IScannedMcpServers {\n\t\tconst scannedMcpServers: IScannedMcpServers = {\n\t\t\tinputs: scannedWorkspaceFolderMcpServers.inputs\n\t\t};\n\t\tconst servers = Object.entries(scannedWorkspaceFolderMcpServers.servers ?? {});\n\t\tif (servers.length > 0) {\n\t\t\tscannedMcpServers.servers = {};\n\t\t\tfor (const [serverName, config] of servers) {\n\t\t\t\tscannedMcpServers.servers[serverName] = this.sanitizeServer(config);\n\t\t\t}\n\t\t}\n\t\treturn scannedMcpServers;\n\t}\n\n\tprivate sanitizeServer(serverOrConfig: IOldScannedMcpServer | Mutable<IMcpServerConfiguration>): IMcpServerConfiguration {\n\t\tlet server: IMcpServerConfiguration;\n\t\tif ((<IOldScannedMcpServer>serverOrConfig).config) {\n\t\t\tconst oldScannedMcpServer = <IOldScannedMcpServer>serverOrConfig;\n\t\t\tserver = {\n\t\t\t\t...oldScannedMcpServer.config,\n\t\t\t\tversion: oldScannedMcpServer.version,\n\t\t\t\tgallery: oldScannedMcpServer.gallery\n\t\t\t};\n\t\t} else {\n\t\t\tserver = serverOrConfig as IMcpServerConfiguration;\n\t\t}\n\n\t\tif (server.type === undefined || (server.type !== McpServerType.REMOTE && server.type !== McpServerType.LOCAL)) {\n\t\t\t(<Mutable<ICommonMcpServerConfiguration>>server).type = (<IMcpStdioServerConfiguration>server).command ? McpServerType.LOCAL : McpServerType.REMOTE;\n\t\t}\n\n\t\treturn server;\n\t}\n\n\tprivate getResourceAccessQueue(file: URI): Queue<IScannedMcpServers> {\n\t\tlet resourceQueue = this.resourcesAccessQueueMap.get(file);\n\t\tif (!resourceQueue) {\n\t\t\tresourceQueue = new Queue<IScannedMcpServers>();\n\t\t\tthis.resourcesAccessQueueMap.set(file, resourceQueue);\n\t\t}\n\t\treturn resourceQueue;\n\t}\n}\n\nregisterSingleton(IMcpResourceScannerService, McpResourceScannerService, InstantiationType.Delayed);\n"]}