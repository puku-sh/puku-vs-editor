{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/terminal.ts","vs/platform/terminal/common/terminal.ts"],"names":[],"mappings":"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","file":"terminal.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { IProcessEnvironment, OperatingSystem } from '../../../base/common/platform.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IPtyHostProcessReplayEvent, ISerializedCommandDetectionCapability, ITerminalCapabilityStore, type ITerminalCommand } from './capabilities/capabilities.js';\nimport { IGetTerminalLayoutInfoArgs, IProcessDetails, ISetTerminalLayoutInfoArgs } from './terminalProcess.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { ISerializableEnvironmentVariableCollections } from './environmentVariable.js';\nimport { IWorkspaceFolder } from '../../workspace/common/workspace.js';\nimport { Registry } from '../../registry/common/platform.js';\nimport type * as performance from '../../../base/common/performance.js';\nimport { ILogService } from '../../log/common/log.js';\nimport type { IAction } from '../../../base/common/actions.js';\nimport type { IDisposable } from '../../../base/common/lifecycle.js';\nimport type { SingleOrMany } from '../../../base/common/types.js';\n\nexport const enum TerminalSettingPrefix {\n\tAutomationProfile = 'terminal.integrated.automationProfile.',\n\tDefaultProfile = 'terminal.integrated.defaultProfile.',\n\tProfiles = 'terminal.integrated.profiles.'\n}\n\nexport const enum TerminalSettingId {\n\tSendKeybindingsToShell = 'terminal.integrated.sendKeybindingsToShell',\n\tAutomationProfileLinux = 'terminal.integrated.automationProfile.linux',\n\tAutomationProfileMacOs = 'terminal.integrated.automationProfile.osx',\n\tAutomationProfileWindows = 'terminal.integrated.automationProfile.windows',\n\tProfilesWindows = 'terminal.integrated.profiles.windows',\n\tProfilesMacOs = 'terminal.integrated.profiles.osx',\n\tProfilesLinux = 'terminal.integrated.profiles.linux',\n\tDefaultProfileLinux = 'terminal.integrated.defaultProfile.linux',\n\tDefaultProfileMacOs = 'terminal.integrated.defaultProfile.osx',\n\tDefaultProfileWindows = 'terminal.integrated.defaultProfile.windows',\n\tUseWslProfiles = 'terminal.integrated.useWslProfiles',\n\tTabsDefaultColor = 'terminal.integrated.tabs.defaultColor',\n\tTabsDefaultIcon = 'terminal.integrated.tabs.defaultIcon',\n\tTabsEnabled = 'terminal.integrated.tabs.enabled',\n\tTabsEnableAnimation = 'terminal.integrated.tabs.enableAnimation',\n\tTabsHideCondition = 'terminal.integrated.tabs.hideCondition',\n\tTabsShowActiveTerminal = 'terminal.integrated.tabs.showActiveTerminal',\n\tTabsShowActions = 'terminal.integrated.tabs.showActions',\n\tTabsLocation = 'terminal.integrated.tabs.location',\n\tTabsFocusMode = 'terminal.integrated.tabs.focusMode',\n\tMacOptionIsMeta = 'terminal.integrated.macOptionIsMeta',\n\tMacOptionClickForcesSelection = 'terminal.integrated.macOptionClickForcesSelection',\n\tAltClickMovesCursor = 'terminal.integrated.altClickMovesCursor',\n\tCopyOnSelection = 'terminal.integrated.copyOnSelection',\n\tEnableMultiLinePasteWarning = 'terminal.integrated.enableMultiLinePasteWarning',\n\tDrawBoldTextInBrightColors = 'terminal.integrated.drawBoldTextInBrightColors',\n\tFontFamily = 'terminal.integrated.fontFamily',\n\tFontSize = 'terminal.integrated.fontSize',\n\tLetterSpacing = 'terminal.integrated.letterSpacing',\n\tLineHeight = 'terminal.integrated.lineHeight',\n\tMinimumContrastRatio = 'terminal.integrated.minimumContrastRatio',\n\tTabStopWidth = 'terminal.integrated.tabStopWidth',\n\tFastScrollSensitivity = 'terminal.integrated.fastScrollSensitivity',\n\tMouseWheelScrollSensitivity = 'terminal.integrated.mouseWheelScrollSensitivity',\n\tBellDuration = 'terminal.integrated.bellDuration',\n\tFontWeight = 'terminal.integrated.fontWeight',\n\tFontWeightBold = 'terminal.integrated.fontWeightBold',\n\tCursorBlinking = 'terminal.integrated.cursorBlinking',\n\tCursorStyle = 'terminal.integrated.cursorStyle',\n\tCursorStyleInactive = 'terminal.integrated.cursorStyleInactive',\n\tCursorWidth = 'terminal.integrated.cursorWidth',\n\tScrollback = 'terminal.integrated.scrollback',\n\tDetectLocale = 'terminal.integrated.detectLocale',\n\tDefaultLocation = 'terminal.integrated.defaultLocation',\n\tGpuAcceleration = 'terminal.integrated.gpuAcceleration',\n\tTerminalTitleSeparator = 'terminal.integrated.tabs.separator',\n\tTerminalTitle = 'terminal.integrated.tabs.title',\n\tTerminalDescription = 'terminal.integrated.tabs.description',\n\tRightClickBehavior = 'terminal.integrated.rightClickBehavior',\n\tMiddleClickBehavior = 'terminal.integrated.middleClickBehavior',\n\tCwd = 'terminal.integrated.cwd',\n\tConfirmOnExit = 'terminal.integrated.confirmOnExit',\n\tConfirmOnKill = 'terminal.integrated.confirmOnKill',\n\tEnableBell = 'terminal.integrated.enableBell',\n\tEnableVisualBell = 'terminal.integrated.enableVisualBell',\n\tCommandsToSkipShell = 'terminal.integrated.commandsToSkipShell',\n\tAllowChords = 'terminal.integrated.allowChords',\n\tAllowMnemonics = 'terminal.integrated.allowMnemonics',\n\tTabFocusMode = 'terminal.integrated.tabFocusMode',\n\tEnvMacOs = 'terminal.integrated.env.osx',\n\tEnvLinux = 'terminal.integrated.env.linux',\n\tEnvWindows = 'terminal.integrated.env.windows',\n\tEnvironmentChangesRelaunch = 'terminal.integrated.environmentChangesRelaunch',\n\tShowExitAlert = 'terminal.integrated.showExitAlert',\n\tSplitCwd = 'terminal.integrated.splitCwd',\n\tWindowsEnableConpty = 'terminal.integrated.windowsEnableConpty',\n\tWindowsUseConptyDll = 'terminal.integrated.windowsUseConptyDll',\n\tWordSeparators = 'terminal.integrated.wordSeparators',\n\tEnableFileLinks = 'terminal.integrated.enableFileLinks',\n\tAllowedLinkSchemes = 'terminal.integrated.allowedLinkSchemes',\n\tUnicodeVersion = 'terminal.integrated.unicodeVersion',\n\tEnablePersistentSessions = 'terminal.integrated.enablePersistentSessions',\n\tPersistentSessionReviveProcess = 'terminal.integrated.persistentSessionReviveProcess',\n\tHideOnStartup = 'terminal.integrated.hideOnStartup',\n\tHideOnLastClosed = 'terminal.integrated.hideOnLastClosed',\n\tCustomGlyphs = 'terminal.integrated.customGlyphs',\n\tRescaleOverlappingGlyphs = 'terminal.integrated.rescaleOverlappingGlyphs',\n\tPersistentSessionScrollback = 'terminal.integrated.persistentSessionScrollback',\n\tInheritEnv = 'terminal.integrated.inheritEnv',\n\tShowLinkHover = 'terminal.integrated.showLinkHover',\n\tIgnoreProcessNames = 'terminal.integrated.ignoreProcessNames',\n\tShellIntegrationEnabled = 'terminal.integrated.shellIntegration.enabled',\n\tShellIntegrationShowWelcome = 'terminal.integrated.shellIntegration.showWelcome',\n\tShellIntegrationDecorationsEnabled = 'terminal.integrated.shellIntegration.decorationsEnabled',\n\tShellIntegrationTimeout = 'terminal.integrated.shellIntegration.timeout',\n\tShellIntegrationQuickFixEnabled = 'terminal.integrated.shellIntegration.quickFixEnabled',\n\tShellIntegrationEnvironmentReporting = 'terminal.integrated.shellIntegration.environmentReporting',\n\tEnableImages = 'terminal.integrated.enableImages',\n\tSmoothScrolling = 'terminal.integrated.smoothScrolling',\n\tIgnoreBracketedPasteMode = 'terminal.integrated.ignoreBracketedPasteMode',\n\tFocusAfterRun = 'terminal.integrated.focusAfterRun',\n\tFontLigaturesEnabled = 'terminal.integrated.fontLigatures.enabled',\n\tFontLigaturesFeatureSettings = 'terminal.integrated.fontLigatures.featureSettings',\n\tFontLigaturesFallbackLigatures = 'terminal.integrated.fontLigatures.fallbackLigatures',\n\n\t// Developer/debug settings\n\n\t/** Simulated latency applied to all calls made to the pty host */\n\tDeveloperPtyHostLatency = 'terminal.integrated.developer.ptyHost.latency',\n\t/** Simulated startup delay of the pty host process */\n\tDeveloperPtyHostStartupDelay = 'terminal.integrated.developer.ptyHost.startupDelay',\n\t/** Shows the textarea element */\n\tDevMode = 'terminal.integrated.developer.devMode'\n}\n\nexport const enum PosixShellType {\n\tBash = 'bash',\n\tFish = 'fish',\n\tSh = 'sh',\n\tCsh = 'csh',\n\tKsh = 'ksh',\n\tZsh = 'zsh',\n\n}\nexport const enum WindowsShellType {\n\tCommandPrompt = 'cmd',\n\tWsl = 'wsl',\n\tGitBash = 'gitbash',\n}\n\nexport const enum GeneralShellType {\n\tPowerShell = 'pwsh',\n\tPython = 'python',\n\tJulia = 'julia',\n\tNuShell = 'nu',\n\tNode = 'node',\n}\nexport type TerminalShellType = PosixShellType | WindowsShellType | GeneralShellType | undefined;\n\nexport interface IRawTerminalInstanceLayoutInfo<T> {\n\trelativeSize: number;\n\tterminal: T;\n}\nexport type ITerminalInstanceLayoutInfoById = IRawTerminalInstanceLayoutInfo<number>;\nexport type ITerminalInstanceLayoutInfo = IRawTerminalInstanceLayoutInfo<IPtyHostAttachTarget>;\n\nexport interface IRawTerminalTabLayoutInfo<T> {\n\tisActive: boolean;\n\tactivePersistentProcessId: number | undefined;\n\tterminals: IRawTerminalInstanceLayoutInfo<T>[];\n}\n\nexport type ITerminalTabLayoutInfoById = IRawTerminalTabLayoutInfo<number>;\n\nexport interface IRawTerminalsLayoutInfo<T> {\n\ttabs: IRawTerminalTabLayoutInfo<T>[];\n\tbackground: T[] | null;\n}\n\nexport interface IPtyHostAttachTarget {\n\tid: number;\n\tpid: number;\n\ttitle: string;\n\ttitleSource: TitleEventSource;\n\tcwd: string;\n\tworkspaceId: string;\n\tworkspaceName: string;\n\tisOrphan: boolean;\n\ticon: TerminalIcon | undefined;\n\tfixedDimensions: IFixedTerminalDimensions | undefined;\n\tenvironmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;\n\treconnectionProperties?: IReconnectionProperties;\n\twaitOnExit?: WaitOnExitValue;\n\thideFromUser?: boolean;\n\tisFeatureTerminal?: boolean;\n\ttype?: TerminalType;\n\thasChildProcesses: boolean;\n\tshellIntegrationNonce: string;\n\ttabActions?: ITerminalTabAction[];\n}\n\nexport interface IReconnectionProperties {\n\townerId: string;\n\tdata?: unknown;\n}\n\nexport type TerminalType = 'Task' | 'Local' | undefined;\n\nexport enum TitleEventSource {\n\t/** From the API or the rename command that overrides any other type */\n\tApi,\n\t/** From the process name property*/\n\tProcess,\n\t/** From the VT sequence */\n\tSequence,\n\t/** Config changed */\n\tConfig\n}\n\nexport type ITerminalsLayoutInfo = IRawTerminalsLayoutInfo<IPtyHostAttachTarget | null>;\nexport type ITerminalsLayoutInfoById = IRawTerminalsLayoutInfo<number>;\n\nexport enum TerminalIpcChannels {\n\t/**\n\t * Communicates between the renderer process and shared process.\n\t */\n\tLocalPty = 'localPty',\n\t/**\n\t * Communicates between the shared process and the pty host process.\n\t */\n\tPtyHost = 'ptyHost',\n\t/**\n\t * Communicates between the renderer process and the pty host process.\n\t */\n\tPtyHostWindow = 'ptyHostWindow',\n\t/**\n\t * Deals with logging from the pty host process.\n\t */\n\tLogger = 'logger',\n\t/**\n\t * Enables the detection of unresponsive pty hosts.\n\t */\n\tHeartbeat = 'heartbeat'\n}\n\nexport const enum ProcessPropertyType {\n\tCwd = 'cwd',\n\tInitialCwd = 'initialCwd',\n\tFixedDimensions = 'fixedDimensions',\n\tTitle = 'title',\n\tShellType = 'shellType',\n\tHasChildProcesses = 'hasChildProcesses',\n\tResolvedShellLaunchConfig = 'resolvedShellLaunchConfig',\n\tOverrideDimensions = 'overrideDimensions',\n\tFailedShellIntegrationActivation = 'failedShellIntegrationActivation',\n\tUsedShellIntegrationInjection = 'usedShellIntegrationInjection',\n\tShellIntegrationInjectionFailureReason = 'shellIntegrationInjectionFailureReason',\n}\n\nexport interface IProcessProperty<T extends ProcessPropertyType = ProcessPropertyType> {\n\ttype: T;\n\tvalue: IProcessPropertyMap[T];\n}\n\nexport interface IProcessPropertyMap {\n\t[ProcessPropertyType.Cwd]: string;\n\t[ProcessPropertyType.InitialCwd]: string;\n\t[ProcessPropertyType.FixedDimensions]: IFixedTerminalDimensions;\n\t[ProcessPropertyType.Title]: string;\n\t[ProcessPropertyType.ShellType]: TerminalShellType | undefined;\n\t[ProcessPropertyType.HasChildProcesses]: boolean;\n\t[ProcessPropertyType.ResolvedShellLaunchConfig]: IShellLaunchConfig;\n\t[ProcessPropertyType.OverrideDimensions]: ITerminalDimensionsOverride | undefined;\n\t[ProcessPropertyType.FailedShellIntegrationActivation]: boolean | undefined;\n\t[ProcessPropertyType.UsedShellIntegrationInjection]: boolean | undefined;\n\t[ProcessPropertyType.ShellIntegrationInjectionFailureReason]: ShellIntegrationInjectionFailureReason | undefined;\n}\n\nexport interface IFixedTerminalDimensions {\n\t/**\n\t * The fixed columns of the terminal.\n\t */\n\tcols?: number;\n\n\t/**\n\t * The fixed rows of the terminal.\n\t */\n\trows?: number;\n}\n\nexport interface ITerminalLaunchResult {\n\tinjectedArgs: string[];\n}\n\n/**\n * A service that communicates with a pty host.\n*/\nexport interface IPtyService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onProcessData: Event<{ id: number; event: IProcessDataEvent | string }>;\n\treadonly onProcessReady: Event<{ id: number; event: IProcessReadyEvent }>;\n\treadonly onProcessReplay: Event<{ id: number; event: IPtyHostProcessReplayEvent }>;\n\treadonly onProcessOrphanQuestion: Event<{ id: number }>;\n\treadonly onDidRequestDetach: Event<{ requestId: number; workspaceId: string; instanceId: number }>;\n\treadonly onDidChangeProperty: Event<{ id: number; property: IProcessProperty }>;\n\treadonly onProcessExit: Event<{ id: number; event: number | undefined }>;\n\n\tcreateProcess(\n\t\tshellLaunchConfig: IShellLaunchConfig,\n\t\tcwd: string,\n\t\tcols: number,\n\t\trows: number,\n\t\tunicodeVersion: '6' | '11',\n\t\tenv: IProcessEnvironment,\n\t\texecutableEnv: IProcessEnvironment,\n\t\toptions: ITerminalProcessOptions,\n\t\tshouldPersist: boolean,\n\t\tworkspaceId: string,\n\t\tworkspaceName: string\n\t): Promise<number>;\n\tattachToProcess(id: number): Promise<void>;\n\tdetachFromProcess(id: number, forcePersist?: boolean): Promise<void>;\n\tshutdownAll(): Promise<void>;\n\n\t/**\n\t * Lists all orphaned processes, ie. those without a connected frontend.\n\t */\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\tgetPerformanceMarks(): Promise<performance.PerformanceMark[]>;\n\t/**\n\t * Measures and returns the latency of the current and all other processes to the pty host.\n\t */\n\tgetLatency(): Promise<IPtyHostLatencyMeasurement[]>;\n\n\tstart(id: number): Promise<ITerminalLaunchError | ITerminalLaunchResult | undefined>;\n\tshutdown(id: number, immediate: boolean): Promise<void>;\n\tinput(id: number, data: string): Promise<void>;\n\tsendSignal(id: number, signal: string): Promise<void>;\n\tresize(id: number, cols: number, rows: number): Promise<void>;\n\tclearBuffer(id: number): Promise<void>;\n\tgetInitialCwd(id: number): Promise<string>;\n\tgetCwd(id: number): Promise<string>;\n\tacknowledgeDataEvent(id: number, charCount: number): Promise<void>;\n\tsetNextCommandId(id: number, commandLine: string, commandId: string): Promise<void>;\n\tsetUnicodeVersion(id: number, version: '6' | '11'): Promise<void>;\n\tprocessBinary(id: number, data: string): Promise<void>;\n\t/** Confirm the process is _not_ an orphan. */\n\torphanQuestionReply(id: number): Promise<void>;\n\tupdateTitle(id: number, title: string, titleSource: TitleEventSource): Promise<void>;\n\tupdateIcon(id: number, userInitiated: boolean, icon: TerminalIcon, color?: string): Promise<void>;\n\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetEnvironment(): Promise<IProcessEnvironment>;\n\tgetWslPath(original: string, direction: 'unix-to-win' | 'win-to-unix'): Promise<string>;\n\tgetRevivedPtyNewId(workspaceId: string, id: number): Promise<number | undefined>;\n\tsetTerminalLayoutInfo(args: ISetTerminalLayoutInfoArgs): Promise<void>;\n\tgetTerminalLayoutInfo(args: IGetTerminalLayoutInfoArgs): Promise<ITerminalsLayoutInfo | undefined>;\n\treduceConnectionGraceTime(): Promise<void>;\n\trequestDetachInstance(workspaceId: string, instanceId: number): Promise<IProcessDetails | undefined>;\n\tacceptDetachInstanceReply(requestId: number, persistentProcessId?: number): Promise<void>;\n\tfreePortKillProcess(port: string): Promise<{ port: string; processId: string }>;\n\t/**\n\t * Serializes and returns terminal state.\n\t * @param ids The persistent terminal IDs to serialize.\n\t */\n\tserializeTerminalState(ids: number[]): Promise<string>;\n\t/**\n\t * Revives a workspaces terminal processes, these can then be reconnected to using the normal\n\t * flow for restoring terminals after reloading.\n\t */\n\treviveTerminalProcesses(workspaceId: string, state: ISerializedTerminalState[], dateTimeFormatLocate: string): Promise<void>;\n\trefreshProperty<T extends ProcessPropertyType>(id: number, property: T): Promise<IProcessPropertyMap[T]>;\n\tupdateProperty<T extends ProcessPropertyType>(id: number, property: T, value: IProcessPropertyMap[T]): Promise<void>;\n\n\t// TODO: Make mandatory and remove impl from pty host service\n\trefreshIgnoreProcessNames?(names: string[]): Promise<void>;\n\n\t// #region Pty service contribution RPC calls\n\n\tinstallAutoReply(match: string, reply: string): Promise<void>;\n\tuninstallAllAutoReplies(): Promise<void>;\n\n\t// #endregion\n}\nexport const IPtyService = createDecorator<IPtyService>('ptyService');\n\nexport interface IPtyServiceContribution {\n\thandleProcessReady(persistentProcessId: number, process: ITerminalChildProcess): void;\n\thandleProcessDispose(persistentProcessId: number): void;\n\thandleProcessInput(persistentProcessId: number, data: string): void;\n\thandleProcessResize(persistentProcessId: number, cols: number, rows: number): void;\n}\n\nexport interface IPtyHostController {\n\treadonly onPtyHostExit: Event<number>;\n\treadonly onPtyHostStart: Event<void>;\n\treadonly onPtyHostUnresponsive: Event<void>;\n\treadonly onPtyHostResponsive: Event<void>;\n\treadonly onPtyHostRequestResolveVariables: Event<IRequestResolveVariablesEvent>;\n\n\trestartPtyHost(): Promise<void>;\n\tacceptPtyHostResolvedVariables(requestId: number, resolved: string[]): Promise<void>;\n\tgetProfiles(workspaceId: string, profiles: unknown, defaultProfile: unknown, includeDetectedProfiles?: boolean): Promise<ITerminalProfile[]>;\n}\n\n/**\n * A service that communicates with a pty host controller (eg. main or server\n * process) and is able to launch and forward requests to the pty host.\n*/\nexport interface IPtyHostService extends IPtyService, IPtyHostController {\n}\n\nexport interface IPtyHostLatencyMeasurement {\n\tlabel: string;\n\tlatency: number;\n}\n\n/**\n * Serialized terminal state matching the interface that can be used across versions, the version\n * should be verified before using the state payload.\n */\nexport interface ICrossVersionSerializedTerminalState {\n\tversion: number;\n\tstate: unknown;\n}\n\nexport interface ISerializedTerminalState {\n\tid: number;\n\tshellLaunchConfig: IShellLaunchConfig;\n\tprocessDetails: IProcessDetails;\n\tprocessLaunchConfig: IPersistentTerminalProcessLaunchConfig;\n\tunicodeVersion: '6' | '11';\n\treplayEvent: IPtyHostProcessReplayEvent;\n\ttimestamp: number;\n}\n\nexport interface IPersistentTerminalProcessLaunchConfig {\n\tenv: IProcessEnvironment;\n\texecutableEnv: IProcessEnvironment;\n\toptions: ITerminalProcessOptions;\n}\n\nexport interface IRequestResolveVariablesEvent {\n\trequestId: number;\n\tworkspaceId: string;\n\toriginalText: string[];\n}\n\nexport enum HeartbeatConstants {\n\t/**\n\t * The duration between heartbeats\n\t */\n\tBeatInterval = 5000,\n\t/**\n\t * The duration of the first heartbeat while the pty host is starting up. This is much larger\n\t * than the regular BeatInterval to accommodate slow machines, we still want to warn about the\n\t * pty host's unresponsiveness eventually though.\n\t */\n\tConnectingBeatInterval = 20000,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before starting the second wait\n\t * timer.\n\t */\n\tFirstWaitMultiplier = 1.2,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before telling the user about\n\t * non-responsiveness. The second timer is to avoid informing the user incorrectly when waking\n\t * the computer up from sleep\n\t */\n\tSecondWaitMultiplier = 1,\n\t/**\n\t * How long to wait before telling the user about non-responsiveness when they try to create a\n\t * process. This short circuits the standard wait timeouts to tell the user sooner and only\n\t * create process is handled to avoid additional perf overhead.\n\t */\n\tCreateProcessTimeout = 5000\n}\n\nexport interface IHeartbeatService {\n\treadonly onBeat: Event<void>;\n}\n\n\nexport interface IShellLaunchConfig {\n\t/**\n\t * The name of the terminal, if this is not set the name of the process will be used.\n\t */\n\tname?: string;\n\n\t/**\n\t * A string to follow the name of the terminal with, indicating the type of terminal\n\t */\n\ttype?: 'Task' | 'Local';\n\n\t/**\n\t * The shell executable (bash, cmd, etc.).\n\t */\n\texecutable?: string;\n\n\t/**\n\t * The CLI arguments to use with executable, a string[] is in argv format and will be escaped,\n\t * a string is in \"CommandLine\" pre-escaped format and will be used as is. The string option is\n\t * only supported on Windows and will throw an exception if used on macOS or Linux.\n\t */\n\targs?: string[] | string;\n\n\t/**\n\t * The current working directory of the terminal, this overrides the `terminal.integrated.cwd`\n\t * settings key.\n\t */\n\tcwd?: string | URI;\n\n\t/**\n\t * A custom environment for the terminal, if this is not set the environment will be inherited\n\t * from the VS Code process.\n\t */\n\tenv?: ITerminalEnvironment;\n\n\t/**\n\t * Whether to ignore a custom cwd from the `terminal.integrated.cwd` settings key (e.g. if the\n\t * shell is being launched by an extension).\n\t */\n\tignoreConfigurationCwd?: boolean;\n\n\t/**\n\t * The reconnection properties for this terminal\n\t */\n\treconnectionProperties?: IReconnectionProperties;\n\n\t/** Whether to wait for a key press before closing the terminal. */\n\twaitOnExit?: WaitOnExitValue;\n\n\t/**\n\t * A string including ANSI escape sequences that will be written to the terminal emulator\n\t * _before_ the terminal process has launched, when a string is specified, a trailing \\n is\n\t * added at the end. This allows for example the terminal instance to display a styled message\n\t * as the first line of the terminal. Use \\x1b over \\033 or \\e for the escape control character.\n\t */\n\tinitialText?: string | { text: string; trailingNewLine: boolean };\n\n\t/**\n\t * Custom PTY/pseudoterminal process to use.\n\t */\n\tcustomPtyImplementation?: (terminalId: number, cols: number, rows: number) => ITerminalChildProcess;\n\n\t/**\n\t * A UUID generated by the extension host process for terminals created on the extension host process.\n\t */\n\textHostTerminalId?: string;\n\n\t/**\n\t * This is a terminal that attaches to an already running terminal.\n\t */\n\tattachPersistentProcess?: {\n\t\tid: number;\n\t\tfindRevivedId?: boolean;\n\t\tpid: number;\n\t\ttitle: string;\n\t\ttitleSource: TitleEventSource;\n\t\tcwd: string;\n\t\ticon?: TerminalIcon;\n\t\tcolor?: string;\n\t\thasChildProcesses?: boolean;\n\t\tfixedDimensions?: IFixedTerminalDimensions;\n\t\tenvironmentVariableCollections?: ISerializableEnvironmentVariableCollections;\n\t\treconnectionProperties?: IReconnectionProperties;\n\t\ttype?: TerminalType;\n\t\twaitOnExit?: WaitOnExitValue;\n\t\thideFromUser?: boolean;\n\t\tisFeatureTerminal?: boolean;\n\t\tshellIntegrationNonce: string;\n\t\ttabActions?: ITerminalTabAction[];\n\t};\n\n\t/**\n\t * Whether the terminal process environment should be exactly as provided in\n\t * `TerminalOptions.env`. When this is false (default), the environment will be based on the\n\t * window's environment and also apply configured platform settings like\n\t * `terminal.integrated.env.windows` on top. When this is true, the complete environment must be\n\t * provided as nothing will be inherited from the process or any configuration.\n\t */\n\tstrictEnv?: boolean;\n\n\t/**\n\t * Whether the terminal process environment will inherit VS Code's \"shell environment\" that may\n\t * get sourced from running a login shell depnding on how the application was launched.\n\t * Consumers that rely on development tools being present in the $PATH should set this to true.\n\t * This will overwrite the value of the inheritEnv setting.\n\t */\n\tuseShellEnvironment?: boolean;\n\n\t/**\n\t * When enabled the terminal will run the process as normal but not be surfaced to the user\n\t * until `Terminal.show` is called. The typical usage for this is when you need to run\n\t * something that may need interactivity but only want to tell the user about it when\n\t * interaction is needed. Note that the terminals will still be exposed to all extensions\n\t * as normal. The hidden terminals will not be restored when the workspace is next opened.\n\t */\n\thideFromUser?: boolean;\n\n\t/**\n\t * Whether to force the terminal to persist across sessions regardless of the other\n\t * launch config, like `hideFromUser`.\n\t */\n\tforcePersist?: boolean;\n\n\t/**\n\t * Whether this terminal is not a terminal that the user directly created and uses, but rather\n\t * a terminal used to drive some VS Code feature.\n\t */\n\tisFeatureTerminal?: boolean;\n\n\t/**\n\t * Whether this terminal was created by an extension.\n\t */\n\tisExtensionOwnedTerminal?: boolean;\n\n\t/**\n\t * The icon for the terminal, used primarily in the terminal tab.\n\t */\n\ticon?: TerminalIcon;\n\n\t/**\n\t * The color ID to use for this terminal. If not specified it will use the default fallback\n\t */\n\tcolor?: string;\n\n\t/**\n\t * When a parent terminal is provided via API, the group needs\n\t * to find the index in order to place the child\n\t * directly to the right of its parent.\n\t */\n\tparentTerminalId?: number;\n\n\t/**\n\t * The dimensions for the instance as set by the user\n\t * or via Size to Content Width\n\t */\n\tfixedDimensions?: IFixedTerminalDimensions;\n\n\t/**\n\t * Opt-out of the default terminal persistence on restart and reload\n\t */\n\tisTransient?: boolean;\n\n\t/**\n\t * Attempt to force shell integration to be enabled by bypassing the {@link isFeatureTerminal}\n\t * equals false requirement.\n\t */\n\tforceShellIntegration?: boolean;\n\n\t/**\n\t * Create a terminal without shell integration even when it's enabled\n\t */\n\tignoreShellIntegration?: boolean;\n\n\t/**\n\t * Actions to include inline on hover of the terminal tab. E.g. the \"Rerun task\" action\n\t */\n\ttabActions?: ITerminalTabAction[];\n\t/**\n\t * Report terminal's shell environment variables to VS Code and extensions\n\t */\n\tshellIntegrationEnvironmentReporting?: boolean;\n\n\t/**\n\t * A custom nonce to use for shell integration when provided by an extension.\n\t * This allows extensions to control shell integration for terminals they create.\n\t */\n\tshellIntegrationNonce?: string;\n}\n\nexport interface ITerminalTabAction {\n\tid: string;\n\tlabel: string;\n\ticon?: ThemeIcon;\n}\n\nexport type WaitOnExitValue = boolean | string | ((exitCode: number) => string);\n\nexport interface ICreateContributedTerminalProfileOptions {\n\ticon?: URI | string | { light: URI; dark: URI };\n\tcolor?: string;\n\tlocation?: TerminalLocation | { viewColumn: number; preserveState?: boolean } | { splitActiveTerminal: boolean };\n\tcwd?: string | URI;\n}\n\nexport enum TerminalLocation {\n\tPanel = 1,\n\tEditor = 2\n}\n\nexport const enum TerminalLocationConfigValue {\n\tTerminalView = 'view',\n\tEditor = 'editor'\n}\n\nexport type TerminalIcon = ThemeIcon | URI | { light: URI; dark: URI };\n\nexport interface IShellLaunchConfigDto {\n\tname?: string;\n\texecutable?: string;\n\targs?: string[] | string;\n\tcwd?: string | UriComponents;\n\tenv?: ITerminalEnvironment;\n\tuseShellEnvironment?: boolean;\n\thideFromUser?: boolean;\n\treconnectionProperties?: IReconnectionProperties;\n\ttype?: 'Task' | 'Local';\n\tisFeatureTerminal?: boolean;\n\ttabActions?: ITerminalTabAction[];\n\tshellIntegrationEnvironmentReporting?: boolean;\n}\n\n/**\n * A set of options for the terminal process. These differ from the shell launch config in that they\n * are set internally to the terminal component, not from the outside.\n */\nexport interface ITerminalProcessOptions {\n\tshellIntegration: {\n\t\tenabled: boolean;\n\t\tsuggestEnabled: boolean;\n\t\tnonce: string;\n\t};\n\twindowsEnableConpty: boolean;\n\twindowsUseConptyDll: boolean;\n\tenvironmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;\n\tworkspaceFolder: IWorkspaceFolder | undefined;\n\tisScreenReaderOptimized: boolean;\n}\n\nexport interface ITerminalEnvironment {\n\t[key: string]: string | null | undefined;\n}\n\nexport interface ITerminalLaunchError {\n\tmessage: string;\n\tcode?: number;\n}\n\nexport interface IProcessReadyEvent {\n\tpid: number;\n\tcwd: string;\n\twindowsPty: IProcessReadyWindowsPty | undefined;\n}\n\nexport interface IProcessReadyWindowsPty {\n\t/**\n\t * What pty emulation backend is being used.\n\t */\n\tbackend: 'conpty' | 'winpty';\n\t/**\n\t * The Windows build version (eg. 19045)\n\t */\n\tbuildNumber: number;\n}\n\n/**\n * An interface representing a raw terminal child process, this contains a subset of the\n * child_process.ChildProcess node.js interface.\n */\nexport interface ITerminalChildProcess {\n\t/**\n\t * A unique identifier for the terminal process. Note that the uniqueness only applies to a\n\t * given pty service connection, IDs will be duplicated for remote and local terminals for\n\t * example. The ID will be 0 if it does not support reconnection.\n\t */\n\tid: number;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\tshouldPersist: boolean;\n\n\treadonly onProcessData: Event<IProcessDataEvent | string>;\n\treadonly onProcessReady: Event<IProcessReadyEvent>;\n\treadonly onProcessReplayComplete?: Event<void>;\n\treadonly onDidChangeProperty: Event<IProcessProperty>;\n\treadonly onProcessExit: Event<number | undefined>;\n\treadonly onRestoreCommands?: Event<ISerializedCommandDetectionCapability>;\n\n\t/**\n\t * Starts the process.\n\t *\n\t * @returns undefined when the process was successfully started, otherwise an object containing\n\t * information on what went wrong.\n\t */\n\tstart(): Promise<ITerminalLaunchError | ITerminalLaunchResult | undefined>;\n\n\t/**\n\t * Detach the process from the UI and await reconnect.\n\t * @param forcePersist Whether to force the process to persist if it supports persistence.\n\t */\n\tdetach?(forcePersist?: boolean): Promise<void>;\n\n\t/**\n\t * Frees the port and kills the process\n\t */\n\tfreePortKillProcess?(port: string): Promise<{ port: string; processId: string }>;\n\n\t/**\n\t * Shutdown the terminal process.\n\t *\n\t * @param immediate When true the process will be killed immediately, otherwise the process will\n\t * be given some time to make sure no additional data comes through.\n\t */\n\tshutdown(immediate: boolean): void;\n\tinput(data: string): void;\n\tsendSignal(signal: string): void;\n\tprocessBinary(data: string): Promise<void>;\n\tresize(cols: number, rows: number): void;\n\tclearBuffer(): void | Promise<void>;\n\n\t/**\n\t * Acknowledge a data event has been parsed by the terminal, this is used to implement flow\n\t * control to ensure remote processes to not get too far ahead of the client and flood the\n\t * connection.\n\t * @param charCount The number of characters being acknowledged.\n\t */\n\tacknowledgeDataEvent(charCount: number): void;\n\n\t/**\n\t * Sets the unicode version for the process, this drives the size of some characters in the\n\t * xterm-headless instance.\n\t */\n\tsetUnicodeVersion(version: '6' | '11'): Promise<void>;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n\trefreshProperty<T extends ProcessPropertyType>(property: T): Promise<IProcessPropertyMap[T]>;\n\tupdateProperty<T extends ProcessPropertyType>(property: T, value: IProcessPropertyMap[T]): Promise<void>;\n}\n\nexport interface IReconnectConstants {\n\tgraceTime: number;\n\tshortGraceTime: number;\n\tscrollback: number;\n}\n\nexport const enum LocalReconnectConstants {\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t*/\n\tGraceTime = 60000, // 60 seconds\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t*/\n\tShortGraceTime = 6000, // 6 seconds\n}\n\nexport const enum FlowControlConstants {\n\t/**\n\t * The number of _unacknowledged_ chars to have been sent before the pty is paused in order for\n\t * the client to catch up.\n\t */\n\tHighWatermarkChars = 100000,\n\t/**\n\t * After flow control pauses the pty for the client the catch up, this is the number of\n\t * _unacknowledged_ chars to have been caught up to on the client before resuming the pty again.\n\t * This is used to attempt to prevent pauses in the flowing data; ideally while the pty is\n\t * paused the number of unacknowledged chars would always be greater than 0 or the client will\n\t * appear to stutter. In reality this balance is hard to accomplish though so heavy commands\n\t * will likely pause as latency grows, not flooding the connection is the important thing as\n\t * it's shared with other core functionality.\n\t */\n\tLowWatermarkChars = 5000,\n\t/**\n\t * The number characters that are accumulated on the client side before sending an ack event.\n\t * This must be less than or equal to LowWatermarkChars or the terminal max never unpause.\n\t */\n\tCharCountAckSize = 5000\n}\n\nexport interface IProcessDataEvent {\n\tdata: string;\n\ttrackCommit: boolean;\n\t/**\n\t * When trackCommit is set, this will be set to a promise that resolves when the data is parsed.\n\t */\n\twritePromise?: Promise<void>;\n}\n\nexport interface ITerminalDimensions {\n\t/**\n\t * The columns of the terminal.\n\t */\n\tcols: number;\n\n\t/**\n\t * The rows of the terminal.\n\t */\n\trows: number;\n}\n\nexport interface ITerminalProfile {\n\tprofileName: string;\n\tpath: string;\n\tisDefault: boolean;\n\t/**\n\t * Whether the terminal profile contains a potentially unsafe {@link path}. For example, the path\n\t * `C:\\Cygwin` is the default install for Cygwin on Windows, but it could be created by any\n\t * user in a multi-user environment. As such, we don't want to blindly present it as a profile\n\t * without a warning.\n\t */\n\tisUnsafePath?: boolean;\n\t/**\n\t * An additional unsafe path that must exist, for example a script that appears in {@link args}.\n\t */\n\trequiresUnsafePath?: string;\n\tisAutoDetected?: boolean;\n\t/**\n\t * Whether the profile path was found on the `$PATH` environment variable, if so it will be\n\t * cleaner to display this profile in the UI using only `basename(path)`.\n\t */\n\tisFromPath?: boolean;\n\targs?: SingleOrMany<string> | undefined;\n\tenv?: ITerminalEnvironment;\n\toverrideName?: boolean;\n\tcolor?: string;\n\ticon?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport interface ITerminalDimensionsOverride extends Readonly<ITerminalDimensions> {\n\t/**\n\t * indicate that xterm must receive these exact dimensions, even if they overflow the ui!\n\t */\n\tforceExactSize?: boolean;\n}\n\nexport const enum ProfileSource {\n\tGitBash = 'Git Bash',\n\tPwsh = 'PowerShell'\n}\n\nexport interface IBaseUnresolvedTerminalProfile {\n\targs?: SingleOrMany<string> | undefined;\n\tisAutoDetected?: boolean;\n\toverrideName?: boolean;\n\ticon?: string | ThemeIcon | URI | { light: URI; dark: URI };\n\tcolor?: string;\n\tenv?: ITerminalEnvironment;\n\trequiresPath?: string | ITerminalUnsafePath;\n}\n\nexport interface ITerminalUnsafePath {\n\tpath: string;\n\tisUnsafe: true;\n}\n\nexport interface ITerminalExecutable extends IBaseUnresolvedTerminalProfile {\n\tpath: SingleOrMany<string | ITerminalUnsafePath>;\n}\n\nexport interface ITerminalProfileSource extends IBaseUnresolvedTerminalProfile {\n\tsource: ProfileSource;\n}\n\nexport interface ITerminalProfileContribution {\n\ttitle: string;\n\tid: string;\n\ticon?: URI | { light: URI; dark: URI } | string;\n\tcolor?: string;\n}\n\nexport interface IExtensionTerminalProfile extends ITerminalProfileContribution {\n\textensionIdentifier: string;\n}\n\nexport type ITerminalProfileObject = ITerminalExecutable | ITerminalProfileSource | IExtensionTerminalProfile | null;\n\nexport interface IShellIntegration {\n\treadonly capabilities: ITerminalCapabilityStore;\n\treadonly seenSequences: ReadonlySet<string>;\n\treadonly status: ShellIntegrationStatus;\n\n\treadonly onDidChangeStatus: Event<ShellIntegrationStatus>;\n\treadonly onDidChangeSeenSequences: Event<ReadonlySet<string>>;\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n\n\tsetNextCommandId(command: string, commandId: string): void;\n}\n\nexport interface IDecorationAddon {\n\tregisterMenuItems(command: ITerminalCommand, items: IAction[]): IDisposable;\n}\n\nexport interface ITerminalCompletionProviderContribution {\n\tdescription?: string;\n}\n\nexport interface ITerminalContributions {\n\tprofiles?: ITerminalProfileContribution[];\n\tcompletionProviders?: ITerminalCompletionProviderContribution[];\n}\n\nexport const enum ShellIntegrationStatus {\n\t/** No shell integration sequences have been encountered. */\n\tOff,\n\t/** Final term shell integration sequences have been encountered. */\n\tFinalTerm,\n\t/** VS Code shell integration sequences have been encountered. Supercedes FinalTerm. */\n\tVSCode\n}\n\n\nexport const enum ShellIntegrationInjectionFailureReason {\n\t/**\n\t * The setting is disabled.\n\t */\n\tInjectionSettingDisabled = 'injectionSettingDisabled',\n\t/**\n\t * There is no executable (so there's no way to determine how to inject).\n\t */\n\tNoExecutable = 'noExecutable',\n\t/**\n\t * It's a feature terminal (tasks, debug), unless it's explicitly being forced.\n\t */\n\tFeatureTerminal = 'featureTerminal',\n\t/**\n\t * The ignoreShellIntegration flag is passed (eg. relaunching without shell integration).\n\t */\n\tIgnoreShellIntegrationFlag = 'ignoreShellIntegrationFlag',\n\t/**\n\t * Shell integration doesn't work with winpty.\n\t */\n\tWinpty = 'winpty',\n\t/**\n\t * We're conservative whether we inject when we don't recognize the arguments used for the\n\t * shell as we would prefer launching one without shell integration than breaking their profile.\n\t */\n\tUnsupportedArgs = 'unsupportedArgs',\n\t/**\n\t * The shell doesn't have built-in shell integration. Note that this doesn't mean the shell\n\t * won't have shell integration in the end.\n\t */\n\tUnsupportedShell = 'unsupportedShell',\n\n\n\t/**\n\t * For zsh, we failed to set the sticky bit on the shell integration script folder.\n\t */\n\tFailedToSetStickyBit = 'failedToSetStickyBit',\n\n\t/**\n\t * For zsh, we failed to create a temp directory for the shell integration script.\n\t */\n\tFailedToCreateTmpDir = 'failedToCreateTmpDir',\n}\n\nexport enum TerminalExitReason {\n\tUnknown = 0,\n\tShutdown = 1,\n\tProcess = 2,\n\tUser = 3,\n\tExtension = 4,\n}\n\nexport interface ITerminalOutputMatch {\n\tregexMatch: RegExpMatchArray;\n\toutputLines: string[];\n}\n\n/**\n * A matcher that runs on a sub-section of a terminal command's output\n */\nexport interface ITerminalOutputMatcher {\n\t/**\n\t * A string or regex to match against the unwrapped line. If this is a regex with the multiline\n\t * flag, it will scan an amount of lines equal to `\\n` instances in the regex + 1.\n\t */\n\tlineMatcher: string | RegExp;\n\t/**\n\t * Which side of the output to anchor the {@link offset} and {@link length} against.\n\t */\n\tanchor: 'top' | 'bottom';\n\t/**\n\t * The number of rows above or below the {@link anchor} to start matching against.\n\t */\n\toffset: number;\n\t/**\n\t * The number of rows to match against, this should be as small as possible for performance\n\t * reasons. This is capped at 40.\n\t */\n\tlength: number;\n\n\t/**\n\t * If multiple matches are expected - this will result in {@link outputLines} being returned\n\t * when there's a {@link regexMatch} from {@link offset} to {@link length}\n\t */\n\tmultipleMatches?: boolean;\n}\n\nexport interface ITerminalCommandSelector {\n\tid: string;\n\tcommandLineMatcher: string | RegExp;\n\toutputMatcher?: ITerminalOutputMatcher;\n\texitStatus: boolean;\n\tcommandExitResult: 'success' | 'error';\n\tkind?: 'fix' | 'explain';\n}\n\nexport interface ITerminalBackend extends ITerminalBackendPtyServiceContributions {\n\treadonly remoteAuthority: string | undefined;\n\n\treadonly isResponsive: boolean;\n\n\t/**\n\t * A promise that resolves when the backend is ready to be used, ie. after terminal persistence\n\t * has been actioned.\n\t */\n\treadonly whenReady: Promise<void>;\n\n\t/**\n\t * Signal to the backend that persistence has been actioned and is ready for use.\n\t */\n\tsetReady(): void;\n\n\t/**\n\t * Fired when the ptyHost process becomes non-responsive, this should disable stdin for all\n\t * terminals using this pty host connection and mark them as disconnected.\n\t */\n\treadonly onPtyHostUnresponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost process becomes responsive after being non-responsive. Allowing\n\t * previously disconnected terminals to reconnect.\n\t */\n\treadonly onPtyHostResponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost has been restarted, this is used as a signal for listening terminals\n\t * that its pty has been lost and will remain disconnected.\n\t */\n\treadonly onPtyHostRestart: Event<void>;\n\n\treadonly onDidRequestDetach: Event<{ requestId: number; workspaceId: string; instanceId: number }>;\n\n\tattachToProcess(id: number): Promise<ITerminalChildProcess | undefined>;\n\tattachToRevivedProcess(id: number): Promise<ITerminalChildProcess | undefined>;\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\tgetLatency(): Promise<IPtyHostLatencyMeasurement[]>;\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetProfiles(profiles: unknown, defaultProfile: unknown, includeDetectedProfiles?: boolean): Promise<ITerminalProfile[]>;\n\tgetWslPath(original: string, direction: 'unix-to-win' | 'win-to-unix'): Promise<string>;\n\tgetEnvironment(): Promise<IProcessEnvironment>;\n\tgetShellEnvironment(): Promise<IProcessEnvironment | undefined>;\n\tsetTerminalLayoutInfo(layoutInfo?: ITerminalsLayoutInfoById): Promise<void>;\n\tupdateTitle(id: number, title: string, titleSource: TitleEventSource): Promise<void>;\n\tupdateIcon(id: number, userInitiated: boolean, icon: TerminalIcon, color?: string): Promise<void>;\n\tsetNextCommandId(id: number, commandLine: string, commandId: string): Promise<void>;\n\tgetTerminalLayoutInfo(): Promise<ITerminalsLayoutInfo | undefined>;\n\tgetPerformanceMarks(): Promise<performance.PerformanceMark[]>;\n\treduceConnectionGraceTime(): Promise<void>;\n\trequestDetachInstance(workspaceId: string, instanceId: number): Promise<IProcessDetails | undefined>;\n\tacceptDetachInstanceReply(requestId: number, persistentProcessId?: number): Promise<void>;\n\tpersistTerminalState(): Promise<void>;\n\n\tcreateProcess(\n\t\tshellLaunchConfig: IShellLaunchConfig,\n\t\tcwd: string,\n\t\tcols: number,\n\t\trows: number,\n\t\tunicodeVersion: '6' | '11',\n\t\tenv: IProcessEnvironment,\n\t\toptions: ITerminalProcessOptions,\n\t\tshouldPersist: boolean\n\t): Promise<ITerminalChildProcess>;\n\n\trestartPtyHost(): void;\n}\n\nexport interface ITerminalBackendPtyServiceContributions {\n\tinstallAutoReply(match: string, reply: string): Promise<void>;\n\tuninstallAllAutoReplies(): Promise<void>;\n}\n\nexport const TerminalExtensions = {\n\tBackend: 'workbench.contributions.terminal.processBackend'\n};\n\nexport interface ITerminalBackendRegistry {\n\t/**\n\t * Gets all backends in the registry.\n\t */\n\tbackends: ReadonlyMap<string, ITerminalBackend>;\n\n\t/**\n\t * Registers a terminal backend for a remote authority.\n\t */\n\tregisterTerminalBackend(backend: ITerminalBackend): void;\n\n\t/**\n\t * Returns the registered terminal backend for a remote authority.\n\t */\n\tgetTerminalBackend(remoteAuthority?: string): ITerminalBackend | undefined;\n}\n\nclass TerminalBackendRegistry implements ITerminalBackendRegistry {\n\tprivate readonly _backends = new Map<string, ITerminalBackend>();\n\n\tget backends(): ReadonlyMap<string, ITerminalBackend> { return this._backends; }\n\n\tregisterTerminalBackend(backend: ITerminalBackend): void {\n\t\tconst key = this._sanitizeRemoteAuthority(backend.remoteAuthority);\n\t\tif (this._backends.has(key)) {\n\t\t\tthrow new Error(`A terminal backend with remote authority '${key}' was already registered.`);\n\t\t}\n\t\tthis._backends.set(key, backend);\n\t}\n\n\tgetTerminalBackend(remoteAuthority: string | undefined): ITerminalBackend | undefined {\n\t\treturn this._backends.get(this._sanitizeRemoteAuthority(remoteAuthority));\n\t}\n\n\tprivate _sanitizeRemoteAuthority(remoteAuthority: string | undefined) {\n\t\t// Normalize the key to lowercase as the authority is case-insensitive\n\t\treturn remoteAuthority?.toLowerCase() ?? '';\n\t}\n}\nRegistry.add(TerminalExtensions.Backend, new TerminalBackendRegistry());\n\nexport const ILocalPtyService = createDecorator<ILocalPtyService>('localPtyService');\n\n/**\n * A service responsible for communicating with the pty host process on Electron.\n *\n * **This service should only be used within the terminal component.**\n */\nexport interface ILocalPtyService extends IPtyHostService { }\n\nexport const ITerminalLogService = createDecorator<ITerminalLogService>('terminalLogService');\nexport interface ITerminalLogService extends ILogService {\n\t/**\n\t * Similar to _serviceBrand but used to differentiate this service at compile time from\n\t * ILogService; ITerminalLogService is an ILogService, but ILogService is not an\n\t * ITerminalLogService.\n\t */\n\treadonly _logBrand: undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { IProcessEnvironment, OperatingSystem } from '../../../base/common/platform.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IPtyHostProcessReplayEvent, ISerializedCommandDetectionCapability, ITerminalCapabilityStore, type ITerminalCommand } from './capabilities/capabilities.js';\nimport { IGetTerminalLayoutInfoArgs, IProcessDetails, ISetTerminalLayoutInfoArgs } from './terminalProcess.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { ISerializableEnvironmentVariableCollections } from './environmentVariable.js';\nimport { IWorkspaceFolder } from '../../workspace/common/workspace.js';\nimport { Registry } from '../../registry/common/platform.js';\nimport type * as performance from '../../../base/common/performance.js';\nimport { ILogService } from '../../log/common/log.js';\nimport type { IAction } from '../../../base/common/actions.js';\nimport type { IDisposable } from '../../../base/common/lifecycle.js';\nimport type { SingleOrMany } from '../../../base/common/types.js';\n\nexport const enum TerminalSettingPrefix {\n\tAutomationProfile = 'terminal.integrated.automationProfile.',\n\tDefaultProfile = 'terminal.integrated.defaultProfile.',\n\tProfiles = 'terminal.integrated.profiles.'\n}\n\nexport const enum TerminalSettingId {\n\tSendKeybindingsToShell = 'terminal.integrated.sendKeybindingsToShell',\n\tAutomationProfileLinux = 'terminal.integrated.automationProfile.linux',\n\tAutomationProfileMacOs = 'terminal.integrated.automationProfile.osx',\n\tAutomationProfileWindows = 'terminal.integrated.automationProfile.windows',\n\tProfilesWindows = 'terminal.integrated.profiles.windows',\n\tProfilesMacOs = 'terminal.integrated.profiles.osx',\n\tProfilesLinux = 'terminal.integrated.profiles.linux',\n\tDefaultProfileLinux = 'terminal.integrated.defaultProfile.linux',\n\tDefaultProfileMacOs = 'terminal.integrated.defaultProfile.osx',\n\tDefaultProfileWindows = 'terminal.integrated.defaultProfile.windows',\n\tUseWslProfiles = 'terminal.integrated.useWslProfiles',\n\tTabsDefaultColor = 'terminal.integrated.tabs.defaultColor',\n\tTabsDefaultIcon = 'terminal.integrated.tabs.defaultIcon',\n\tTabsEnabled = 'terminal.integrated.tabs.enabled',\n\tTabsEnableAnimation = 'terminal.integrated.tabs.enableAnimation',\n\tTabsHideCondition = 'terminal.integrated.tabs.hideCondition',\n\tTabsShowActiveTerminal = 'terminal.integrated.tabs.showActiveTerminal',\n\tTabsShowActions = 'terminal.integrated.tabs.showActions',\n\tTabsLocation = 'terminal.integrated.tabs.location',\n\tTabsFocusMode = 'terminal.integrated.tabs.focusMode',\n\tMacOptionIsMeta = 'terminal.integrated.macOptionIsMeta',\n\tMacOptionClickForcesSelection = 'terminal.integrated.macOptionClickForcesSelection',\n\tAltClickMovesCursor = 'terminal.integrated.altClickMovesCursor',\n\tCopyOnSelection = 'terminal.integrated.copyOnSelection',\n\tEnableMultiLinePasteWarning = 'terminal.integrated.enableMultiLinePasteWarning',\n\tDrawBoldTextInBrightColors = 'terminal.integrated.drawBoldTextInBrightColors',\n\tFontFamily = 'terminal.integrated.fontFamily',\n\tFontSize = 'terminal.integrated.fontSize',\n\tLetterSpacing = 'terminal.integrated.letterSpacing',\n\tLineHeight = 'terminal.integrated.lineHeight',\n\tMinimumContrastRatio = 'terminal.integrated.minimumContrastRatio',\n\tTabStopWidth = 'terminal.integrated.tabStopWidth',\n\tFastScrollSensitivity = 'terminal.integrated.fastScrollSensitivity',\n\tMouseWheelScrollSensitivity = 'terminal.integrated.mouseWheelScrollSensitivity',\n\tBellDuration = 'terminal.integrated.bellDuration',\n\tFontWeight = 'terminal.integrated.fontWeight',\n\tFontWeightBold = 'terminal.integrated.fontWeightBold',\n\tCursorBlinking = 'terminal.integrated.cursorBlinking',\n\tCursorStyle = 'terminal.integrated.cursorStyle',\n\tCursorStyleInactive = 'terminal.integrated.cursorStyleInactive',\n\tCursorWidth = 'terminal.integrated.cursorWidth',\n\tScrollback = 'terminal.integrated.scrollback',\n\tDetectLocale = 'terminal.integrated.detectLocale',\n\tDefaultLocation = 'terminal.integrated.defaultLocation',\n\tGpuAcceleration = 'terminal.integrated.gpuAcceleration',\n\tTerminalTitleSeparator = 'terminal.integrated.tabs.separator',\n\tTerminalTitle = 'terminal.integrated.tabs.title',\n\tTerminalDescription = 'terminal.integrated.tabs.description',\n\tRightClickBehavior = 'terminal.integrated.rightClickBehavior',\n\tMiddleClickBehavior = 'terminal.integrated.middleClickBehavior',\n\tCwd = 'terminal.integrated.cwd',\n\tConfirmOnExit = 'terminal.integrated.confirmOnExit',\n\tConfirmOnKill = 'terminal.integrated.confirmOnKill',\n\tEnableBell = 'terminal.integrated.enableBell',\n\tEnableVisualBell = 'terminal.integrated.enableVisualBell',\n\tCommandsToSkipShell = 'terminal.integrated.commandsToSkipShell',\n\tAllowChords = 'terminal.integrated.allowChords',\n\tAllowMnemonics = 'terminal.integrated.allowMnemonics',\n\tTabFocusMode = 'terminal.integrated.tabFocusMode',\n\tEnvMacOs = 'terminal.integrated.env.osx',\n\tEnvLinux = 'terminal.integrated.env.linux',\n\tEnvWindows = 'terminal.integrated.env.windows',\n\tEnvironmentChangesRelaunch = 'terminal.integrated.environmentChangesRelaunch',\n\tShowExitAlert = 'terminal.integrated.showExitAlert',\n\tSplitCwd = 'terminal.integrated.splitCwd',\n\tWindowsEnableConpty = 'terminal.integrated.windowsEnableConpty',\n\tWindowsUseConptyDll = 'terminal.integrated.windowsUseConptyDll',\n\tWordSeparators = 'terminal.integrated.wordSeparators',\n\tEnableFileLinks = 'terminal.integrated.enableFileLinks',\n\tAllowedLinkSchemes = 'terminal.integrated.allowedLinkSchemes',\n\tUnicodeVersion = 'terminal.integrated.unicodeVersion',\n\tEnablePersistentSessions = 'terminal.integrated.enablePersistentSessions',\n\tPersistentSessionReviveProcess = 'terminal.integrated.persistentSessionReviveProcess',\n\tHideOnStartup = 'terminal.integrated.hideOnStartup',\n\tHideOnLastClosed = 'terminal.integrated.hideOnLastClosed',\n\tCustomGlyphs = 'terminal.integrated.customGlyphs',\n\tRescaleOverlappingGlyphs = 'terminal.integrated.rescaleOverlappingGlyphs',\n\tPersistentSessionScrollback = 'terminal.integrated.persistentSessionScrollback',\n\tInheritEnv = 'terminal.integrated.inheritEnv',\n\tShowLinkHover = 'terminal.integrated.showLinkHover',\n\tIgnoreProcessNames = 'terminal.integrated.ignoreProcessNames',\n\tShellIntegrationEnabled = 'terminal.integrated.shellIntegration.enabled',\n\tShellIntegrationShowWelcome = 'terminal.integrated.shellIntegration.showWelcome',\n\tShellIntegrationDecorationsEnabled = 'terminal.integrated.shellIntegration.decorationsEnabled',\n\tShellIntegrationTimeout = 'terminal.integrated.shellIntegration.timeout',\n\tShellIntegrationQuickFixEnabled = 'terminal.integrated.shellIntegration.quickFixEnabled',\n\tShellIntegrationEnvironmentReporting = 'terminal.integrated.shellIntegration.environmentReporting',\n\tEnableImages = 'terminal.integrated.enableImages',\n\tSmoothScrolling = 'terminal.integrated.smoothScrolling',\n\tIgnoreBracketedPasteMode = 'terminal.integrated.ignoreBracketedPasteMode',\n\tFocusAfterRun = 'terminal.integrated.focusAfterRun',\n\tFontLigaturesEnabled = 'terminal.integrated.fontLigatures.enabled',\n\tFontLigaturesFeatureSettings = 'terminal.integrated.fontLigatures.featureSettings',\n\tFontLigaturesFallbackLigatures = 'terminal.integrated.fontLigatures.fallbackLigatures',\n\n\t// Developer/debug settings\n\n\t/** Simulated latency applied to all calls made to the pty host */\n\tDeveloperPtyHostLatency = 'terminal.integrated.developer.ptyHost.latency',\n\t/** Simulated startup delay of the pty host process */\n\tDeveloperPtyHostStartupDelay = 'terminal.integrated.developer.ptyHost.startupDelay',\n\t/** Shows the textarea element */\n\tDevMode = 'terminal.integrated.developer.devMode'\n}\n\nexport const enum PosixShellType {\n\tBash = 'bash',\n\tFish = 'fish',\n\tSh = 'sh',\n\tCsh = 'csh',\n\tKsh = 'ksh',\n\tZsh = 'zsh',\n\n}\nexport const enum WindowsShellType {\n\tCommandPrompt = 'cmd',\n\tWsl = 'wsl',\n\tGitBash = 'gitbash',\n}\n\nexport const enum GeneralShellType {\n\tPowerShell = 'pwsh',\n\tPython = 'python',\n\tJulia = 'julia',\n\tNuShell = 'nu',\n\tNode = 'node',\n}\nexport type TerminalShellType = PosixShellType | WindowsShellType | GeneralShellType | undefined;\n\nexport interface IRawTerminalInstanceLayoutInfo<T> {\n\trelativeSize: number;\n\tterminal: T;\n}\nexport type ITerminalInstanceLayoutInfoById = IRawTerminalInstanceLayoutInfo<number>;\nexport type ITerminalInstanceLayoutInfo = IRawTerminalInstanceLayoutInfo<IPtyHostAttachTarget>;\n\nexport interface IRawTerminalTabLayoutInfo<T> {\n\tisActive: boolean;\n\tactivePersistentProcessId: number | undefined;\n\tterminals: IRawTerminalInstanceLayoutInfo<T>[];\n}\n\nexport type ITerminalTabLayoutInfoById = IRawTerminalTabLayoutInfo<number>;\n\nexport interface IRawTerminalsLayoutInfo<T> {\n\ttabs: IRawTerminalTabLayoutInfo<T>[];\n\tbackground: T[] | null;\n}\n\nexport interface IPtyHostAttachTarget {\n\tid: number;\n\tpid: number;\n\ttitle: string;\n\ttitleSource: TitleEventSource;\n\tcwd: string;\n\tworkspaceId: string;\n\tworkspaceName: string;\n\tisOrphan: boolean;\n\ticon: TerminalIcon | undefined;\n\tfixedDimensions: IFixedTerminalDimensions | undefined;\n\tenvironmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;\n\treconnectionProperties?: IReconnectionProperties;\n\twaitOnExit?: WaitOnExitValue;\n\thideFromUser?: boolean;\n\tisFeatureTerminal?: boolean;\n\ttype?: TerminalType;\n\thasChildProcesses: boolean;\n\tshellIntegrationNonce: string;\n\ttabActions?: ITerminalTabAction[];\n}\n\nexport interface IReconnectionProperties {\n\townerId: string;\n\tdata?: unknown;\n}\n\nexport type TerminalType = 'Task' | 'Local' | undefined;\n\nexport enum TitleEventSource {\n\t/** From the API or the rename command that overrides any other type */\n\tApi,\n\t/** From the process name property*/\n\tProcess,\n\t/** From the VT sequence */\n\tSequence,\n\t/** Config changed */\n\tConfig\n}\n\nexport type ITerminalsLayoutInfo = IRawTerminalsLayoutInfo<IPtyHostAttachTarget | null>;\nexport type ITerminalsLayoutInfoById = IRawTerminalsLayoutInfo<number>;\n\nexport enum TerminalIpcChannels {\n\t/**\n\t * Communicates between the renderer process and shared process.\n\t */\n\tLocalPty = 'localPty',\n\t/**\n\t * Communicates between the shared process and the pty host process.\n\t */\n\tPtyHost = 'ptyHost',\n\t/**\n\t * Communicates between the renderer process and the pty host process.\n\t */\n\tPtyHostWindow = 'ptyHostWindow',\n\t/**\n\t * Deals with logging from the pty host process.\n\t */\n\tLogger = 'logger',\n\t/**\n\t * Enables the detection of unresponsive pty hosts.\n\t */\n\tHeartbeat = 'heartbeat'\n}\n\nexport const enum ProcessPropertyType {\n\tCwd = 'cwd',\n\tInitialCwd = 'initialCwd',\n\tFixedDimensions = 'fixedDimensions',\n\tTitle = 'title',\n\tShellType = 'shellType',\n\tHasChildProcesses = 'hasChildProcesses',\n\tResolvedShellLaunchConfig = 'resolvedShellLaunchConfig',\n\tOverrideDimensions = 'overrideDimensions',\n\tFailedShellIntegrationActivation = 'failedShellIntegrationActivation',\n\tUsedShellIntegrationInjection = 'usedShellIntegrationInjection',\n\tShellIntegrationInjectionFailureReason = 'shellIntegrationInjectionFailureReason',\n}\n\nexport interface IProcessProperty<T extends ProcessPropertyType = ProcessPropertyType> {\n\ttype: T;\n\tvalue: IProcessPropertyMap[T];\n}\n\nexport interface IProcessPropertyMap {\n\t[ProcessPropertyType.Cwd]: string;\n\t[ProcessPropertyType.InitialCwd]: string;\n\t[ProcessPropertyType.FixedDimensions]: IFixedTerminalDimensions;\n\t[ProcessPropertyType.Title]: string;\n\t[ProcessPropertyType.ShellType]: TerminalShellType | undefined;\n\t[ProcessPropertyType.HasChildProcesses]: boolean;\n\t[ProcessPropertyType.ResolvedShellLaunchConfig]: IShellLaunchConfig;\n\t[ProcessPropertyType.OverrideDimensions]: ITerminalDimensionsOverride | undefined;\n\t[ProcessPropertyType.FailedShellIntegrationActivation]: boolean | undefined;\n\t[ProcessPropertyType.UsedShellIntegrationInjection]: boolean | undefined;\n\t[ProcessPropertyType.ShellIntegrationInjectionFailureReason]: ShellIntegrationInjectionFailureReason | undefined;\n}\n\nexport interface IFixedTerminalDimensions {\n\t/**\n\t * The fixed columns of the terminal.\n\t */\n\tcols?: number;\n\n\t/**\n\t * The fixed rows of the terminal.\n\t */\n\trows?: number;\n}\n\nexport interface ITerminalLaunchResult {\n\tinjectedArgs: string[];\n}\n\n/**\n * A service that communicates with a pty host.\n*/\nexport interface IPtyService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onProcessData: Event<{ id: number; event: IProcessDataEvent | string }>;\n\treadonly onProcessReady: Event<{ id: number; event: IProcessReadyEvent }>;\n\treadonly onProcessReplay: Event<{ id: number; event: IPtyHostProcessReplayEvent }>;\n\treadonly onProcessOrphanQuestion: Event<{ id: number }>;\n\treadonly onDidRequestDetach: Event<{ requestId: number; workspaceId: string; instanceId: number }>;\n\treadonly onDidChangeProperty: Event<{ id: number; property: IProcessProperty }>;\n\treadonly onProcessExit: Event<{ id: number; event: number | undefined }>;\n\n\tcreateProcess(\n\t\tshellLaunchConfig: IShellLaunchConfig,\n\t\tcwd: string,\n\t\tcols: number,\n\t\trows: number,\n\t\tunicodeVersion: '6' | '11',\n\t\tenv: IProcessEnvironment,\n\t\texecutableEnv: IProcessEnvironment,\n\t\toptions: ITerminalProcessOptions,\n\t\tshouldPersist: boolean,\n\t\tworkspaceId: string,\n\t\tworkspaceName: string\n\t): Promise<number>;\n\tattachToProcess(id: number): Promise<void>;\n\tdetachFromProcess(id: number, forcePersist?: boolean): Promise<void>;\n\tshutdownAll(): Promise<void>;\n\n\t/**\n\t * Lists all orphaned processes, ie. those without a connected frontend.\n\t */\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\tgetPerformanceMarks(): Promise<performance.PerformanceMark[]>;\n\t/**\n\t * Measures and returns the latency of the current and all other processes to the pty host.\n\t */\n\tgetLatency(): Promise<IPtyHostLatencyMeasurement[]>;\n\n\tstart(id: number): Promise<ITerminalLaunchError | ITerminalLaunchResult | undefined>;\n\tshutdown(id: number, immediate: boolean): Promise<void>;\n\tinput(id: number, data: string): Promise<void>;\n\tsendSignal(id: number, signal: string): Promise<void>;\n\tresize(id: number, cols: number, rows: number): Promise<void>;\n\tclearBuffer(id: number): Promise<void>;\n\tgetInitialCwd(id: number): Promise<string>;\n\tgetCwd(id: number): Promise<string>;\n\tacknowledgeDataEvent(id: number, charCount: number): Promise<void>;\n\tsetNextCommandId(id: number, commandLine: string, commandId: string): Promise<void>;\n\tsetUnicodeVersion(id: number, version: '6' | '11'): Promise<void>;\n\tprocessBinary(id: number, data: string): Promise<void>;\n\t/** Confirm the process is _not_ an orphan. */\n\torphanQuestionReply(id: number): Promise<void>;\n\tupdateTitle(id: number, title: string, titleSource: TitleEventSource): Promise<void>;\n\tupdateIcon(id: number, userInitiated: boolean, icon: TerminalIcon, color?: string): Promise<void>;\n\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetEnvironment(): Promise<IProcessEnvironment>;\n\tgetWslPath(original: string, direction: 'unix-to-win' | 'win-to-unix'): Promise<string>;\n\tgetRevivedPtyNewId(workspaceId: string, id: number): Promise<number | undefined>;\n\tsetTerminalLayoutInfo(args: ISetTerminalLayoutInfoArgs): Promise<void>;\n\tgetTerminalLayoutInfo(args: IGetTerminalLayoutInfoArgs): Promise<ITerminalsLayoutInfo | undefined>;\n\treduceConnectionGraceTime(): Promise<void>;\n\trequestDetachInstance(workspaceId: string, instanceId: number): Promise<IProcessDetails | undefined>;\n\tacceptDetachInstanceReply(requestId: number, persistentProcessId?: number): Promise<void>;\n\tfreePortKillProcess(port: string): Promise<{ port: string; processId: string }>;\n\t/**\n\t * Serializes and returns terminal state.\n\t * @param ids The persistent terminal IDs to serialize.\n\t */\n\tserializeTerminalState(ids: number[]): Promise<string>;\n\t/**\n\t * Revives a workspaces terminal processes, these can then be reconnected to using the normal\n\t * flow for restoring terminals after reloading.\n\t */\n\treviveTerminalProcesses(workspaceId: string, state: ISerializedTerminalState[], dateTimeFormatLocate: string): Promise<void>;\n\trefreshProperty<T extends ProcessPropertyType>(id: number, property: T): Promise<IProcessPropertyMap[T]>;\n\tupdateProperty<T extends ProcessPropertyType>(id: number, property: T, value: IProcessPropertyMap[T]): Promise<void>;\n\n\t// TODO: Make mandatory and remove impl from pty host service\n\trefreshIgnoreProcessNames?(names: string[]): Promise<void>;\n\n\t// #region Pty service contribution RPC calls\n\n\tinstallAutoReply(match: string, reply: string): Promise<void>;\n\tuninstallAllAutoReplies(): Promise<void>;\n\n\t// #endregion\n}\nexport const IPtyService = createDecorator<IPtyService>('ptyService');\n\nexport interface IPtyServiceContribution {\n\thandleProcessReady(persistentProcessId: number, process: ITerminalChildProcess): void;\n\thandleProcessDispose(persistentProcessId: number): void;\n\thandleProcessInput(persistentProcessId: number, data: string): void;\n\thandleProcessResize(persistentProcessId: number, cols: number, rows: number): void;\n}\n\nexport interface IPtyHostController {\n\treadonly onPtyHostExit: Event<number>;\n\treadonly onPtyHostStart: Event<void>;\n\treadonly onPtyHostUnresponsive: Event<void>;\n\treadonly onPtyHostResponsive: Event<void>;\n\treadonly onPtyHostRequestResolveVariables: Event<IRequestResolveVariablesEvent>;\n\n\trestartPtyHost(): Promise<void>;\n\tacceptPtyHostResolvedVariables(requestId: number, resolved: string[]): Promise<void>;\n\tgetProfiles(workspaceId: string, profiles: unknown, defaultProfile: unknown, includeDetectedProfiles?: boolean): Promise<ITerminalProfile[]>;\n}\n\n/**\n * A service that communicates with a pty host controller (eg. main or server\n * process) and is able to launch and forward requests to the pty host.\n*/\nexport interface IPtyHostService extends IPtyService, IPtyHostController {\n}\n\nexport interface IPtyHostLatencyMeasurement {\n\tlabel: string;\n\tlatency: number;\n}\n\n/**\n * Serialized terminal state matching the interface that can be used across versions, the version\n * should be verified before using the state payload.\n */\nexport interface ICrossVersionSerializedTerminalState {\n\tversion: number;\n\tstate: unknown;\n}\n\nexport interface ISerializedTerminalState {\n\tid: number;\n\tshellLaunchConfig: IShellLaunchConfig;\n\tprocessDetails: IProcessDetails;\n\tprocessLaunchConfig: IPersistentTerminalProcessLaunchConfig;\n\tunicodeVersion: '6' | '11';\n\treplayEvent: IPtyHostProcessReplayEvent;\n\ttimestamp: number;\n}\n\nexport interface IPersistentTerminalProcessLaunchConfig {\n\tenv: IProcessEnvironment;\n\texecutableEnv: IProcessEnvironment;\n\toptions: ITerminalProcessOptions;\n}\n\nexport interface IRequestResolveVariablesEvent {\n\trequestId: number;\n\tworkspaceId: string;\n\toriginalText: string[];\n}\n\nexport enum HeartbeatConstants {\n\t/**\n\t * The duration between heartbeats\n\t */\n\tBeatInterval = 5000,\n\t/**\n\t * The duration of the first heartbeat while the pty host is starting up. This is much larger\n\t * than the regular BeatInterval to accommodate slow machines, we still want to warn about the\n\t * pty host's unresponsiveness eventually though.\n\t */\n\tConnectingBeatInterval = 20000,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before starting the second wait\n\t * timer.\n\t */\n\tFirstWaitMultiplier = 1.2,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before telling the user about\n\t * non-responsiveness. The second timer is to avoid informing the user incorrectly when waking\n\t * the computer up from sleep\n\t */\n\tSecondWaitMultiplier = 1,\n\t/**\n\t * How long to wait before telling the user about non-responsiveness when they try to create a\n\t * process. This short circuits the standard wait timeouts to tell the user sooner and only\n\t * create process is handled to avoid additional perf overhead.\n\t */\n\tCreateProcessTimeout = 5000\n}\n\nexport interface IHeartbeatService {\n\treadonly onBeat: Event<void>;\n}\n\n\nexport interface IShellLaunchConfig {\n\t/**\n\t * The name of the terminal, if this is not set the name of the process will be used.\n\t */\n\tname?: string;\n\n\t/**\n\t * A string to follow the name of the terminal with, indicating the type of terminal\n\t */\n\ttype?: 'Task' | 'Local';\n\n\t/**\n\t * The shell executable (bash, cmd, etc.).\n\t */\n\texecutable?: string;\n\n\t/**\n\t * The CLI arguments to use with executable, a string[] is in argv format and will be escaped,\n\t * a string is in \"CommandLine\" pre-escaped format and will be used as is. The string option is\n\t * only supported on Windows and will throw an exception if used on macOS or Linux.\n\t */\n\targs?: string[] | string;\n\n\t/**\n\t * The current working directory of the terminal, this overrides the `terminal.integrated.cwd`\n\t * settings key.\n\t */\n\tcwd?: string | URI;\n\n\t/**\n\t * A custom environment for the terminal, if this is not set the environment will be inherited\n\t * from the VS Code process.\n\t */\n\tenv?: ITerminalEnvironment;\n\n\t/**\n\t * Whether to ignore a custom cwd from the `terminal.integrated.cwd` settings key (e.g. if the\n\t * shell is being launched by an extension).\n\t */\n\tignoreConfigurationCwd?: boolean;\n\n\t/**\n\t * The reconnection properties for this terminal\n\t */\n\treconnectionProperties?: IReconnectionProperties;\n\n\t/** Whether to wait for a key press before closing the terminal. */\n\twaitOnExit?: WaitOnExitValue;\n\n\t/**\n\t * A string including ANSI escape sequences that will be written to the terminal emulator\n\t * _before_ the terminal process has launched, when a string is specified, a trailing \\n is\n\t * added at the end. This allows for example the terminal instance to display a styled message\n\t * as the first line of the terminal. Use \\x1b over \\033 or \\e for the escape control character.\n\t */\n\tinitialText?: string | { text: string; trailingNewLine: boolean };\n\n\t/**\n\t * Custom PTY/pseudoterminal process to use.\n\t */\n\tcustomPtyImplementation?: (terminalId: number, cols: number, rows: number) => ITerminalChildProcess;\n\n\t/**\n\t * A UUID generated by the extension host process for terminals created on the extension host process.\n\t */\n\textHostTerminalId?: string;\n\n\t/**\n\t * This is a terminal that attaches to an already running terminal.\n\t */\n\tattachPersistentProcess?: {\n\t\tid: number;\n\t\tfindRevivedId?: boolean;\n\t\tpid: number;\n\t\ttitle: string;\n\t\ttitleSource: TitleEventSource;\n\t\tcwd: string;\n\t\ticon?: TerminalIcon;\n\t\tcolor?: string;\n\t\thasChildProcesses?: boolean;\n\t\tfixedDimensions?: IFixedTerminalDimensions;\n\t\tenvironmentVariableCollections?: ISerializableEnvironmentVariableCollections;\n\t\treconnectionProperties?: IReconnectionProperties;\n\t\ttype?: TerminalType;\n\t\twaitOnExit?: WaitOnExitValue;\n\t\thideFromUser?: boolean;\n\t\tisFeatureTerminal?: boolean;\n\t\tshellIntegrationNonce: string;\n\t\ttabActions?: ITerminalTabAction[];\n\t};\n\n\t/**\n\t * Whether the terminal process environment should be exactly as provided in\n\t * `TerminalOptions.env`. When this is false (default), the environment will be based on the\n\t * window's environment and also apply configured platform settings like\n\t * `terminal.integrated.env.windows` on top. When this is true, the complete environment must be\n\t * provided as nothing will be inherited from the process or any configuration.\n\t */\n\tstrictEnv?: boolean;\n\n\t/**\n\t * Whether the terminal process environment will inherit VS Code's \"shell environment\" that may\n\t * get sourced from running a login shell depnding on how the application was launched.\n\t * Consumers that rely on development tools being present in the $PATH should set this to true.\n\t * This will overwrite the value of the inheritEnv setting.\n\t */\n\tuseShellEnvironment?: boolean;\n\n\t/**\n\t * When enabled the terminal will run the process as normal but not be surfaced to the user\n\t * until `Terminal.show` is called. The typical usage for this is when you need to run\n\t * something that may need interactivity but only want to tell the user about it when\n\t * interaction is needed. Note that the terminals will still be exposed to all extensions\n\t * as normal. The hidden terminals will not be restored when the workspace is next opened.\n\t */\n\thideFromUser?: boolean;\n\n\t/**\n\t * Whether to force the terminal to persist across sessions regardless of the other\n\t * launch config, like `hideFromUser`.\n\t */\n\tforcePersist?: boolean;\n\n\t/**\n\t * Whether this terminal is not a terminal that the user directly created and uses, but rather\n\t * a terminal used to drive some VS Code feature.\n\t */\n\tisFeatureTerminal?: boolean;\n\n\t/**\n\t * Whether this terminal was created by an extension.\n\t */\n\tisExtensionOwnedTerminal?: boolean;\n\n\t/**\n\t * The icon for the terminal, used primarily in the terminal tab.\n\t */\n\ticon?: TerminalIcon;\n\n\t/**\n\t * The color ID to use for this terminal. If not specified it will use the default fallback\n\t */\n\tcolor?: string;\n\n\t/**\n\t * When a parent terminal is provided via API, the group needs\n\t * to find the index in order to place the child\n\t * directly to the right of its parent.\n\t */\n\tparentTerminalId?: number;\n\n\t/**\n\t * The dimensions for the instance as set by the user\n\t * or via Size to Content Width\n\t */\n\tfixedDimensions?: IFixedTerminalDimensions;\n\n\t/**\n\t * Opt-out of the default terminal persistence on restart and reload\n\t */\n\tisTransient?: boolean;\n\n\t/**\n\t * Attempt to force shell integration to be enabled by bypassing the {@link isFeatureTerminal}\n\t * equals false requirement.\n\t */\n\tforceShellIntegration?: boolean;\n\n\t/**\n\t * Create a terminal without shell integration even when it's enabled\n\t */\n\tignoreShellIntegration?: boolean;\n\n\t/**\n\t * Actions to include inline on hover of the terminal tab. E.g. the \"Rerun task\" action\n\t */\n\ttabActions?: ITerminalTabAction[];\n\t/**\n\t * Report terminal's shell environment variables to VS Code and extensions\n\t */\n\tshellIntegrationEnvironmentReporting?: boolean;\n\n\t/**\n\t * A custom nonce to use for shell integration when provided by an extension.\n\t * This allows extensions to control shell integration for terminals they create.\n\t */\n\tshellIntegrationNonce?: string;\n}\n\nexport interface ITerminalTabAction {\n\tid: string;\n\tlabel: string;\n\ticon?: ThemeIcon;\n}\n\nexport type WaitOnExitValue = boolean | string | ((exitCode: number) => string);\n\nexport interface ICreateContributedTerminalProfileOptions {\n\ticon?: URI | string | { light: URI; dark: URI };\n\tcolor?: string;\n\tlocation?: TerminalLocation | { viewColumn: number; preserveState?: boolean } | { splitActiveTerminal: boolean };\n\tcwd?: string | URI;\n}\n\nexport enum TerminalLocation {\n\tPanel = 1,\n\tEditor = 2\n}\n\nexport const enum TerminalLocationConfigValue {\n\tTerminalView = 'view',\n\tEditor = 'editor'\n}\n\nexport type TerminalIcon = ThemeIcon | URI | { light: URI; dark: URI };\n\nexport interface IShellLaunchConfigDto {\n\tname?: string;\n\texecutable?: string;\n\targs?: string[] | string;\n\tcwd?: string | UriComponents;\n\tenv?: ITerminalEnvironment;\n\tuseShellEnvironment?: boolean;\n\thideFromUser?: boolean;\n\treconnectionProperties?: IReconnectionProperties;\n\ttype?: 'Task' | 'Local';\n\tisFeatureTerminal?: boolean;\n\ttabActions?: ITerminalTabAction[];\n\tshellIntegrationEnvironmentReporting?: boolean;\n}\n\n/**\n * A set of options for the terminal process. These differ from the shell launch config in that they\n * are set internally to the terminal component, not from the outside.\n */\nexport interface ITerminalProcessOptions {\n\tshellIntegration: {\n\t\tenabled: boolean;\n\t\tsuggestEnabled: boolean;\n\t\tnonce: string;\n\t};\n\twindowsEnableConpty: boolean;\n\twindowsUseConptyDll: boolean;\n\tenvironmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;\n\tworkspaceFolder: IWorkspaceFolder | undefined;\n\tisScreenReaderOptimized: boolean;\n}\n\nexport interface ITerminalEnvironment {\n\t[key: string]: string | null | undefined;\n}\n\nexport interface ITerminalLaunchError {\n\tmessage: string;\n\tcode?: number;\n}\n\nexport interface IProcessReadyEvent {\n\tpid: number;\n\tcwd: string;\n\twindowsPty: IProcessReadyWindowsPty | undefined;\n}\n\nexport interface IProcessReadyWindowsPty {\n\t/**\n\t * What pty emulation backend is being used.\n\t */\n\tbackend: 'conpty' | 'winpty';\n\t/**\n\t * The Windows build version (eg. 19045)\n\t */\n\tbuildNumber: number;\n}\n\n/**\n * An interface representing a raw terminal child process, this contains a subset of the\n * child_process.ChildProcess node.js interface.\n */\nexport interface ITerminalChildProcess {\n\t/**\n\t * A unique identifier for the terminal process. Note that the uniqueness only applies to a\n\t * given pty service connection, IDs will be duplicated for remote and local terminals for\n\t * example. The ID will be 0 if it does not support reconnection.\n\t */\n\tid: number;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\tshouldPersist: boolean;\n\n\treadonly onProcessData: Event<IProcessDataEvent | string>;\n\treadonly onProcessReady: Event<IProcessReadyEvent>;\n\treadonly onProcessReplayComplete?: Event<void>;\n\treadonly onDidChangeProperty: Event<IProcessProperty>;\n\treadonly onProcessExit: Event<number | undefined>;\n\treadonly onRestoreCommands?: Event<ISerializedCommandDetectionCapability>;\n\n\t/**\n\t * Starts the process.\n\t *\n\t * @returns undefined when the process was successfully started, otherwise an object containing\n\t * information on what went wrong.\n\t */\n\tstart(): Promise<ITerminalLaunchError | ITerminalLaunchResult | undefined>;\n\n\t/**\n\t * Detach the process from the UI and await reconnect.\n\t * @param forcePersist Whether to force the process to persist if it supports persistence.\n\t */\n\tdetach?(forcePersist?: boolean): Promise<void>;\n\n\t/**\n\t * Frees the port and kills the process\n\t */\n\tfreePortKillProcess?(port: string): Promise<{ port: string; processId: string }>;\n\n\t/**\n\t * Shutdown the terminal process.\n\t *\n\t * @param immediate When true the process will be killed immediately, otherwise the process will\n\t * be given some time to make sure no additional data comes through.\n\t */\n\tshutdown(immediate: boolean): void;\n\tinput(data: string): void;\n\tsendSignal(signal: string): void;\n\tprocessBinary(data: string): Promise<void>;\n\tresize(cols: number, rows: number): void;\n\tclearBuffer(): void | Promise<void>;\n\n\t/**\n\t * Acknowledge a data event has been parsed by the terminal, this is used to implement flow\n\t * control to ensure remote processes to not get too far ahead of the client and flood the\n\t * connection.\n\t * @param charCount The number of characters being acknowledged.\n\t */\n\tacknowledgeDataEvent(charCount: number): void;\n\n\t/**\n\t * Sets the unicode version for the process, this drives the size of some characters in the\n\t * xterm-headless instance.\n\t */\n\tsetUnicodeVersion(version: '6' | '11'): Promise<void>;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n\trefreshProperty<T extends ProcessPropertyType>(property: T): Promise<IProcessPropertyMap[T]>;\n\tupdateProperty<T extends ProcessPropertyType>(property: T, value: IProcessPropertyMap[T]): Promise<void>;\n}\n\nexport interface IReconnectConstants {\n\tgraceTime: number;\n\tshortGraceTime: number;\n\tscrollback: number;\n}\n\nexport const enum LocalReconnectConstants {\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t*/\n\tGraceTime = 60000, // 60 seconds\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t*/\n\tShortGraceTime = 6000, // 6 seconds\n}\n\nexport const enum FlowControlConstants {\n\t/**\n\t * The number of _unacknowledged_ chars to have been sent before the pty is paused in order for\n\t * the client to catch up.\n\t */\n\tHighWatermarkChars = 100000,\n\t/**\n\t * After flow control pauses the pty for the client the catch up, this is the number of\n\t * _unacknowledged_ chars to have been caught up to on the client before resuming the pty again.\n\t * This is used to attempt to prevent pauses in the flowing data; ideally while the pty is\n\t * paused the number of unacknowledged chars would always be greater than 0 or the client will\n\t * appear to stutter. In reality this balance is hard to accomplish though so heavy commands\n\t * will likely pause as latency grows, not flooding the connection is the important thing as\n\t * it's shared with other core functionality.\n\t */\n\tLowWatermarkChars = 5000,\n\t/**\n\t * The number characters that are accumulated on the client side before sending an ack event.\n\t * This must be less than or equal to LowWatermarkChars or the terminal max never unpause.\n\t */\n\tCharCountAckSize = 5000\n}\n\nexport interface IProcessDataEvent {\n\tdata: string;\n\ttrackCommit: boolean;\n\t/**\n\t * When trackCommit is set, this will be set to a promise that resolves when the data is parsed.\n\t */\n\twritePromise?: Promise<void>;\n}\n\nexport interface ITerminalDimensions {\n\t/**\n\t * The columns of the terminal.\n\t */\n\tcols: number;\n\n\t/**\n\t * The rows of the terminal.\n\t */\n\trows: number;\n}\n\nexport interface ITerminalProfile {\n\tprofileName: string;\n\tpath: string;\n\tisDefault: boolean;\n\t/**\n\t * Whether the terminal profile contains a potentially unsafe {@link path}. For example, the path\n\t * `C:\\Cygwin` is the default install for Cygwin on Windows, but it could be created by any\n\t * user in a multi-user environment. As such, we don't want to blindly present it as a profile\n\t * without a warning.\n\t */\n\tisUnsafePath?: boolean;\n\t/**\n\t * An additional unsafe path that must exist, for example a script that appears in {@link args}.\n\t */\n\trequiresUnsafePath?: string;\n\tisAutoDetected?: boolean;\n\t/**\n\t * Whether the profile path was found on the `$PATH` environment variable, if so it will be\n\t * cleaner to display this profile in the UI using only `basename(path)`.\n\t */\n\tisFromPath?: boolean;\n\targs?: SingleOrMany<string> | undefined;\n\tenv?: ITerminalEnvironment;\n\toverrideName?: boolean;\n\tcolor?: string;\n\ticon?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport interface ITerminalDimensionsOverride extends Readonly<ITerminalDimensions> {\n\t/**\n\t * indicate that xterm must receive these exact dimensions, even if they overflow the ui!\n\t */\n\tforceExactSize?: boolean;\n}\n\nexport const enum ProfileSource {\n\tGitBash = 'Git Bash',\n\tPwsh = 'PowerShell'\n}\n\nexport interface IBaseUnresolvedTerminalProfile {\n\targs?: SingleOrMany<string> | undefined;\n\tisAutoDetected?: boolean;\n\toverrideName?: boolean;\n\ticon?: string | ThemeIcon | URI | { light: URI; dark: URI };\n\tcolor?: string;\n\tenv?: ITerminalEnvironment;\n\trequiresPath?: string | ITerminalUnsafePath;\n}\n\nexport interface ITerminalUnsafePath {\n\tpath: string;\n\tisUnsafe: true;\n}\n\nexport interface ITerminalExecutable extends IBaseUnresolvedTerminalProfile {\n\tpath: SingleOrMany<string | ITerminalUnsafePath>;\n}\n\nexport interface ITerminalProfileSource extends IBaseUnresolvedTerminalProfile {\n\tsource: ProfileSource;\n}\n\nexport interface ITerminalProfileContribution {\n\ttitle: string;\n\tid: string;\n\ticon?: URI | { light: URI; dark: URI } | string;\n\tcolor?: string;\n}\n\nexport interface IExtensionTerminalProfile extends ITerminalProfileContribution {\n\textensionIdentifier: string;\n}\n\nexport type ITerminalProfileObject = ITerminalExecutable | ITerminalProfileSource | IExtensionTerminalProfile | null;\n\nexport interface IShellIntegration {\n\treadonly capabilities: ITerminalCapabilityStore;\n\treadonly seenSequences: ReadonlySet<string>;\n\treadonly status: ShellIntegrationStatus;\n\n\treadonly onDidChangeStatus: Event<ShellIntegrationStatus>;\n\treadonly onDidChangeSeenSequences: Event<ReadonlySet<string>>;\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n\n\tsetNextCommandId(command: string, commandId: string): void;\n}\n\nexport interface IDecorationAddon {\n\tregisterMenuItems(command: ITerminalCommand, items: IAction[]): IDisposable;\n}\n\nexport interface ITerminalCompletionProviderContribution {\n\tdescription?: string;\n}\n\nexport interface ITerminalContributions {\n\tprofiles?: ITerminalProfileContribution[];\n\tcompletionProviders?: ITerminalCompletionProviderContribution[];\n}\n\nexport const enum ShellIntegrationStatus {\n\t/** No shell integration sequences have been encountered. */\n\tOff,\n\t/** Final term shell integration sequences have been encountered. */\n\tFinalTerm,\n\t/** VS Code shell integration sequences have been encountered. Supercedes FinalTerm. */\n\tVSCode\n}\n\n\nexport const enum ShellIntegrationInjectionFailureReason {\n\t/**\n\t * The setting is disabled.\n\t */\n\tInjectionSettingDisabled = 'injectionSettingDisabled',\n\t/**\n\t * There is no executable (so there's no way to determine how to inject).\n\t */\n\tNoExecutable = 'noExecutable',\n\t/**\n\t * It's a feature terminal (tasks, debug), unless it's explicitly being forced.\n\t */\n\tFeatureTerminal = 'featureTerminal',\n\t/**\n\t * The ignoreShellIntegration flag is passed (eg. relaunching without shell integration).\n\t */\n\tIgnoreShellIntegrationFlag = 'ignoreShellIntegrationFlag',\n\t/**\n\t * Shell integration doesn't work with winpty.\n\t */\n\tWinpty = 'winpty',\n\t/**\n\t * We're conservative whether we inject when we don't recognize the arguments used for the\n\t * shell as we would prefer launching one without shell integration than breaking their profile.\n\t */\n\tUnsupportedArgs = 'unsupportedArgs',\n\t/**\n\t * The shell doesn't have built-in shell integration. Note that this doesn't mean the shell\n\t * won't have shell integration in the end.\n\t */\n\tUnsupportedShell = 'unsupportedShell',\n\n\n\t/**\n\t * For zsh, we failed to set the sticky bit on the shell integration script folder.\n\t */\n\tFailedToSetStickyBit = 'failedToSetStickyBit',\n\n\t/**\n\t * For zsh, we failed to create a temp directory for the shell integration script.\n\t */\n\tFailedToCreateTmpDir = 'failedToCreateTmpDir',\n}\n\nexport enum TerminalExitReason {\n\tUnknown = 0,\n\tShutdown = 1,\n\tProcess = 2,\n\tUser = 3,\n\tExtension = 4,\n}\n\nexport interface ITerminalOutputMatch {\n\tregexMatch: RegExpMatchArray;\n\toutputLines: string[];\n}\n\n/**\n * A matcher that runs on a sub-section of a terminal command's output\n */\nexport interface ITerminalOutputMatcher {\n\t/**\n\t * A string or regex to match against the unwrapped line. If this is a regex with the multiline\n\t * flag, it will scan an amount of lines equal to `\\n` instances in the regex + 1.\n\t */\n\tlineMatcher: string | RegExp;\n\t/**\n\t * Which side of the output to anchor the {@link offset} and {@link length} against.\n\t */\n\tanchor: 'top' | 'bottom';\n\t/**\n\t * The number of rows above or below the {@link anchor} to start matching against.\n\t */\n\toffset: number;\n\t/**\n\t * The number of rows to match against, this should be as small as possible for performance\n\t * reasons. This is capped at 40.\n\t */\n\tlength: number;\n\n\t/**\n\t * If multiple matches are expected - this will result in {@link outputLines} being returned\n\t * when there's a {@link regexMatch} from {@link offset} to {@link length}\n\t */\n\tmultipleMatches?: boolean;\n}\n\nexport interface ITerminalCommandSelector {\n\tid: string;\n\tcommandLineMatcher: string | RegExp;\n\toutputMatcher?: ITerminalOutputMatcher;\n\texitStatus: boolean;\n\tcommandExitResult: 'success' | 'error';\n\tkind?: 'fix' | 'explain';\n}\n\nexport interface ITerminalBackend extends ITerminalBackendPtyServiceContributions {\n\treadonly remoteAuthority: string | undefined;\n\n\treadonly isResponsive: boolean;\n\n\t/**\n\t * A promise that resolves when the backend is ready to be used, ie. after terminal persistence\n\t * has been actioned.\n\t */\n\treadonly whenReady: Promise<void>;\n\n\t/**\n\t * Signal to the backend that persistence has been actioned and is ready for use.\n\t */\n\tsetReady(): void;\n\n\t/**\n\t * Fired when the ptyHost process becomes non-responsive, this should disable stdin for all\n\t * terminals using this pty host connection and mark them as disconnected.\n\t */\n\treadonly onPtyHostUnresponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost process becomes responsive after being non-responsive. Allowing\n\t * previously disconnected terminals to reconnect.\n\t */\n\treadonly onPtyHostResponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost has been restarted, this is used as a signal for listening terminals\n\t * that its pty has been lost and will remain disconnected.\n\t */\n\treadonly onPtyHostRestart: Event<void>;\n\n\treadonly onDidRequestDetach: Event<{ requestId: number; workspaceId: string; instanceId: number }>;\n\n\tattachToProcess(id: number): Promise<ITerminalChildProcess | undefined>;\n\tattachToRevivedProcess(id: number): Promise<ITerminalChildProcess | undefined>;\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\tgetLatency(): Promise<IPtyHostLatencyMeasurement[]>;\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetProfiles(profiles: unknown, defaultProfile: unknown, includeDetectedProfiles?: boolean): Promise<ITerminalProfile[]>;\n\tgetWslPath(original: string, direction: 'unix-to-win' | 'win-to-unix'): Promise<string>;\n\tgetEnvironment(): Promise<IProcessEnvironment>;\n\tgetShellEnvironment(): Promise<IProcessEnvironment | undefined>;\n\tsetTerminalLayoutInfo(layoutInfo?: ITerminalsLayoutInfoById): Promise<void>;\n\tupdateTitle(id: number, title: string, titleSource: TitleEventSource): Promise<void>;\n\tupdateIcon(id: number, userInitiated: boolean, icon: TerminalIcon, color?: string): Promise<void>;\n\tsetNextCommandId(id: number, commandLine: string, commandId: string): Promise<void>;\n\tgetTerminalLayoutInfo(): Promise<ITerminalsLayoutInfo | undefined>;\n\tgetPerformanceMarks(): Promise<performance.PerformanceMark[]>;\n\treduceConnectionGraceTime(): Promise<void>;\n\trequestDetachInstance(workspaceId: string, instanceId: number): Promise<IProcessDetails | undefined>;\n\tacceptDetachInstanceReply(requestId: number, persistentProcessId?: number): Promise<void>;\n\tpersistTerminalState(): Promise<void>;\n\n\tcreateProcess(\n\t\tshellLaunchConfig: IShellLaunchConfig,\n\t\tcwd: string,\n\t\tcols: number,\n\t\trows: number,\n\t\tunicodeVersion: '6' | '11',\n\t\tenv: IProcessEnvironment,\n\t\toptions: ITerminalProcessOptions,\n\t\tshouldPersist: boolean\n\t): Promise<ITerminalChildProcess>;\n\n\trestartPtyHost(): void;\n}\n\nexport interface ITerminalBackendPtyServiceContributions {\n\tinstallAutoReply(match: string, reply: string): Promise<void>;\n\tuninstallAllAutoReplies(): Promise<void>;\n}\n\nexport const TerminalExtensions = {\n\tBackend: 'workbench.contributions.terminal.processBackend'\n};\n\nexport interface ITerminalBackendRegistry {\n\t/**\n\t * Gets all backends in the registry.\n\t */\n\tbackends: ReadonlyMap<string, ITerminalBackend>;\n\n\t/**\n\t * Registers a terminal backend for a remote authority.\n\t */\n\tregisterTerminalBackend(backend: ITerminalBackend): void;\n\n\t/**\n\t * Returns the registered terminal backend for a remote authority.\n\t */\n\tgetTerminalBackend(remoteAuthority?: string): ITerminalBackend | undefined;\n}\n\nclass TerminalBackendRegistry implements ITerminalBackendRegistry {\n\tprivate readonly _backends = new Map<string, ITerminalBackend>();\n\n\tget backends(): ReadonlyMap<string, ITerminalBackend> { return this._backends; }\n\n\tregisterTerminalBackend(backend: ITerminalBackend): void {\n\t\tconst key = this._sanitizeRemoteAuthority(backend.remoteAuthority);\n\t\tif (this._backends.has(key)) {\n\t\t\tthrow new Error(`A terminal backend with remote authority '${key}' was already registered.`);\n\t\t}\n\t\tthis._backends.set(key, backend);\n\t}\n\n\tgetTerminalBackend(remoteAuthority: string | undefined): ITerminalBackend | undefined {\n\t\treturn this._backends.get(this._sanitizeRemoteAuthority(remoteAuthority));\n\t}\n\n\tprivate _sanitizeRemoteAuthority(remoteAuthority: string | undefined) {\n\t\t// Normalize the key to lowercase as the authority is case-insensitive\n\t\treturn remoteAuthority?.toLowerCase() ?? '';\n\t}\n}\nRegistry.add(TerminalExtensions.Backend, new TerminalBackendRegistry());\n\nexport const ILocalPtyService = createDecorator<ILocalPtyService>('localPtyService');\n\n/**\n * A service responsible for communicating with the pty host process on Electron.\n *\n * **This service should only be used within the terminal component.**\n */\nexport interface ILocalPtyService extends IPtyHostService { }\n\nexport const ITerminalLogService = createDecorator<ITerminalLogService>('terminalLogService');\nexport interface ITerminalLogService extends ILogService {\n\t/**\n\t * Similar to _serviceBrand but used to differentiate this service at compile time from\n\t * ILogService; ITerminalLogService is an ILogService, but ILogService is not an\n\t * ITerminalLogService.\n\t */\n\treadonly _logBrand: undefined;\n}\n"]}