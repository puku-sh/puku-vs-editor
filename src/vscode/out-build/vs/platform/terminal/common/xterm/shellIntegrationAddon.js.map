{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/xterm/shellIntegrationAddon.ts","vs/platform/terminal/common/xterm/shellIntegrationAddon.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,UAAU,EAAE,OAAO,EAAe,YAAY,EAAE,MAAM,sCAAsC,CAAC;AACtG,OAAO,EAAE,uBAAuB,EAAE,MAAM,4CAA4C,CAAC;AACrF,OAAO,EAAE,0BAA0B,EAAE,MAAM,+CAA+C,CAAC;AAC3F,OAAO,EAAE,sBAAsB,EAAE,MAAM,2CAA2C,CAAC;AAEnF,OAAO,EAAE,iCAAiC,EAAE,MAAM,sDAAsD,CAAC;AAGzG,OAAO,EAAE,OAAO,EAAS,MAAM,kCAAkC,CAAC;AAClE,OAAO,EAAE,oBAAoB,EAAE,MAAM,yCAAyC,CAAC;AAE/E,OAAO,EAAE,GAAG,EAAE,MAAM,gCAAgC,CAAC;AACrD,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AACxD,OAAO,EAAE,+BAA+B,EAAE,MAAM,oCAAoC,CAAC;AACrF,OAAO,EAAE,2BAA2B,EAAE,MAAM,gDAAgD,CAAC;AAC7F,OAAO,EAAE,6BAA6B,EAAE,MAAM,kDAAkD,CAAC;AAGjG;;;;;;;;;;;;GAYG;AAEH;;GAEG;AACH,MAAM,CAAN,IAAkB,qBAgBjB;AAhBD,WAAkB,qBAAqB;IACtC;;OAEG;IACH,6EAAe,CAAA;IACf;;;OAGG;IACH,uEAAY,CAAA;IACZ;;OAEG;IACH,sEAAY,CAAA;IACZ,qEAAU,CAAA;IACV,mGAAyB,CAAA;AAC1B,CAAC,EAhBiB,qBAAqB,KAArB,qBAAqB,QAgBtC;AAED;;GAEG;AACH,IAAW,cA6BV;AA7BD,WAAW,cAAc;IACxB;;;;OAIG;IACH,mCAAiB,CAAA;IAEjB;;;;OAIG;IACH,oCAAkB,CAAA;IAElB;;;;OAIG;IACH,uCAAqB,CAAA;IAErB;;;;;OAKG;IACH,uCAAqB,CAAA;AACtB,CAAC,EA7BU,cAAc,KAAd,cAAc,QA6BxB;AAED;;;;;;;;;;;GAWG;AACH,IAAW,WAiMV;AAjMD,WAAW,WAAW;IACrB;;;;;;OAMG;IACH,gCAAiB,CAAA;IAEjB;;;;;;OAMG;IACH,iCAAkB,CAAA;IAElB;;;;;;OAMG;IACH,oCAAqB,CAAA;IAErB;;;;;;;;;OASG;IACH,oCAAqB,CAAA;IAErB;;;;;;;;;;;;;;;;;;;;;;;;;OAyBG;IACH,gCAAiB,CAAA;IAEjB;;;;OAIG;IACH,sCAAuB,CAAA;IAEvB;;;;OAIG;IACH,oCAAqB,CAAA;IAErB;;;;OAIG;IACH,qCAAsB,CAAA;IAEtB;;;;OAIG;IACH,mCAAoB,CAAA;IAEpB;;;;;;;;;;;;;;;;;;;OAmBG;IACH,6BAAc,CAAA;IAEd;;;;;;;;;OASG;IACH,kCAAmB,CAAA;IAEnB;;;;;;;;;;;OAWG;IACH,kCAAmB,CAAA;IAEnB;;;;;;;;;OASG;IACH,kDAAmC,CAAA;IAEnC;;;;;;;;;;OAUG;IACH,gDAAiC,CAAA;IAEjC;;;;;;;;;OASG;IACH,gDAAiC,CAAA;IAEjC;;;;;;;;;;OAUG;IACH,4CAA6B,CAAA;AAC9B,CAAC,EAjMU,WAAW,KAAX,WAAW,QAiMrB;AAED;;GAEG;AACH,IAAW,UAcV;AAdD,WAAW,UAAU;IACpB;;;;OAIG;IACH,iCAAmB,CAAA;IAEnB;;;;OAIG;IACH,uCAAyB,CAAA;AAC1B,CAAC,EAdU,UAAU,KAAV,UAAU,QAcpB;AAED;;;;GAIG;AACH,MAAM,OAAO,qBAAsB,SAAQ,UAAU;IAQpD,IAAI,aAAa,KAA0B,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IAGxE,IAAI,MAAM,KAA6B,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAO7D,YACS,MAAc,EACL,iBAAsC,EAC/C,iBAA0C,EACjC,iBAAgD,EAChD,WAAwB;QAEzC,KAAK,EAAE,CAAC;QANA,WAAM,GAAN,MAAM,CAAQ;QACL,sBAAiB,GAAjB,iBAAiB,CAAqB;QAC/C,sBAAiB,GAAjB,iBAAiB,CAAyB;QACjC,sBAAiB,GAAjB,iBAAiB,CAA+B;QAChD,gBAAW,GAAX,WAAW,CAAa;QArBjC,iBAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,uBAAuB,EAAE,CAAC,CAAC;QAC9D,yBAAoB,GAAY,KAAK,CAAC;QAEtC,+BAA0B,GAAkB,EAAE,CAAC;QAE/C,mBAAc,GAAgB,IAAI,GAAG,EAAE,CAAC;QAGxC,YAAO,sCAAsD;QAGpD,uBAAkB,GAAG,IAAI,OAAO,EAA0B,CAAC;QACnE,sBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC;QAC1C,8BAAyB,GAAG,IAAI,OAAO,EAAuB,CAAC;QACvE,6BAAwB,GAAG,IAAI,CAAC,yBAAyB,CAAC,KAAK,CAAC;QAUxE,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE;YAChC,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAC/B,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC/B,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,sBAAsB;QAC7B,OAAO,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;QACzC,IAAI,CAAC,0BAA0B,CAAC,MAAM,GAAG,CAAC,CAAC;IAC5C,CAAC;IAED,QAAQ,CAAC,KAAe;QACvB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,YAAY,CAAC,GAAG,qDAA6C,IAAI,CAAC,SAAS,CAAC,IAAI,iCAAiC,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;QACjK,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAkB,yCAA+B,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACxH,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAkB,yCAA8B,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACxH,IAAI,CAAC,0BAA0B,CAAC,IAAI,CACnC,KAAK,CAAC,MAAM,CAAC,kBAAkB,4CAAkC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC,CAC7G,CAAC;QACF,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAkB,uCAA+B,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAClH,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAkB,sDAA8C,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAChJ,IAAI,CAAC,wCAAwC,EAAE,CAAC;IACjD,CAAC;IAED,WAAW,CAAC,QAAkB,EAAE,cAAsB;QACrD,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;IACxE,CAAC;IAED,gBAAgB,CAAC,OAAe,EAAE,SAAiB;QAClD,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACpB,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,gBAAgB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACxF,CAAC;IACF,CAAC;IAEO,iBAAiB,CAAC,QAAgB;QACzC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAClC,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC1D,CAAC;IACF,CAAC;IAEO,wBAAwB,CAAC,IAAY;QAC5C,MAAM,SAAS,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;QACxD,IAAI,IAAI,CAAC,OAAO,uCAA+B,EAAE,CAAC;YACjD,IAAI,CAAC,OAAO,2CAAmC,CAAC;YAChD,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC5C,CAAC;QACD,OAAO,SAAS,CAAC;IAClB,CAAC;IAEO,0BAA0B,CAAC,IAAY;QAC9C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC;QACd,CAAC;QAED,4CAA4C;QAC5C,uFAAuF;QACvF,wFAAwF;QACxF,2FAA2F;QAC3F,2CAA2C;QAC3C,MAAM,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC3C,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QAChC,QAAQ,OAAO,EAAE,CAAC;YACjB;gBACC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,iBAAiB,EAAE,CAAC;gBACtE,OAAO,IAAI,CAAC;YACb;gBACC,8FAA8F;gBAC9F,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,kBAAkB,CAAC,EAAE,iBAAiB,EAAE,IAAI,EAAE,CAAC,CAAC;gBAClG,OAAO,IAAI,CAAC;YACb;gBACC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,qBAAqB,EAAE,CAAC;gBAC1E,OAAO,IAAI,CAAC;YACb,6CAAmC,CAAC,CAAC,CAAC;gBACrC,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBACnE,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;gBAClF,OAAO,IAAI,CAAC;YACb,CAAC;QACF,CAAC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAEO,qBAAqB,CAAC,IAAY;QACzC,MAAM,SAAS,GAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;QACrD,IAAI,CAAC,IAAI,CAAC,oBAAoB,IAAI,SAAS,EAAE,CAAC;YAC7C,IAAI,CAAC,iBAAiB,EAAE,UAAU,CAAoF,8CAA8C,CAAC,CAAC;YACtK,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;YACjC,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAChC,CAAC;QACD,IAAI,IAAI,CAAC,OAAO,0CAAkC,EAAE,CAAC;YACpD,IAAI,CAAC,OAAO,wCAAgC,CAAC;YAC7C,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC5C,CAAC;QACD,OAAO,SAAS,CAAC;IAClB,CAAC;IAEO,KAAK,CAAC,wCAAwC;QACrD,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACvD,OAAO;QACR,CAAC;QACD,IAAI,CAAC,kBAAkB,GAAG,UAAU,CAAC,GAAG,EAAE;YACzC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,6CAAqC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,yCAAiC,EAAE,CAAC;gBAC5H,IAAI,CAAC,iBAAiB,EAAE,UAAU,CAAyF,4CAA4C,CAAC,CAAC;gBACzK,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,gEAAgE,CAAC,CAAC;YACzF,CAAC;YACD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;QAClC,CAAC,EAAE,KAAK,CAAC,CAAC;IACX,CAAC;IAEO,uBAAuB;QAC9B,IAAI,IAAI,CAAC,kBAAkB,KAAK,SAAS,EAAE,CAAC;YAC3C,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YACtC,IAAI,CAAC,kBAAkB,GAAG,SAAS,CAAC;QACrC,CAAC;IACF,CAAC;IAEO,uBAAuB,CAAC,IAAY;QAC3C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC;QACd,CAAC;QAED,4CAA4C;QAC5C,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACpC,MAAM,OAAO,GAAG,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;QACvE,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QAChC,sCAAsC;QACtC,MAAM,IAAI,GAA2B,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACtG,QAAQ,OAAO,EAAE,CAAC;YACjB;gBACC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,iBAAiB,EAAE,CAAC;gBACtE,OAAO,IAAI,CAAC;YACb;gBACC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,kBAAkB,EAAE,CAAC;gBACvE,OAAO,IAAI,CAAC;YACb;gBACC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,qBAAqB,EAAE,CAAC;gBAC1E,OAAO,IAAI,CAAC;YACb,0CAAgC,CAAC,CAAC,CAAC;gBAClC,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,MAAM,QAAQ,GAAG,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBACjE,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;gBAClF,OAAO,IAAI,CAAC;YACb,CAAC;YACD,sCAA4B,CAAC,CAAC,CAAC;gBAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,WAAmB,CAAC;gBACxB,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;oBACxB,WAAW,GAAG,2BAA2B,CAAC,IAAI,CAAC,CAAC;gBACjD,CAAC;qBAAM,CAAC;oBACP,WAAW,GAAG,EAAE,CAAC;gBAClB,CAAC;gBACD,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,cAAc,CAAC,WAAW,EAAE,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;gBACpG,OAAO,IAAI,CAAC;YACb,CAAC;YACD,4CAAkC,CAAC,CAAC,CAAC;gBACpC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,uBAAuB,EAAE,CAAC;gBAC5E,OAAO,IAAI,CAAC;YACb,CAAC;YACD,0CAAgC,CAAC,CAAC,CAAC;gBAClC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,qBAAqB,EAAE,CAAC;gBAC1E,OAAO,IAAI,CAAC;YACb,CAAC;YACD,wCAAwB,CAAC,CAAC,CAAC;gBAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;oBACxB,IAAI,CAAC;wBACJ,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC,CAAC;wBAC1D,IAAI,CAAC,6BAA6B,EAAE,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;oBAChF,CAAC;oBAAC,OAAO,CAAC,EAAE,CAAC;wBACZ,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,6DAA6D,EAAE,IAAI,CAAC,CAAC;oBAC5F,CAAC;gBACF,CAAC;gBACD,OAAO,IAAI,CAAC;YACb,CAAC;YACD,sDAA+B,CAAC,CAAC,CAAC;gBACjC,IAAI,CAAC,6BAA6B,EAAE,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;gBACzG,OAAO,IAAI,CAAC;YACb,CAAC;YACD,wDAAgC,CAAC,CAAC,CAAC;gBAClC,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBAErB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;oBAC9C,MAAM,GAAG,GAAG,2BAA2B,CAAC,IAAI,CAAC,CAAC;oBAC9C,IAAI,CAAC,6BAA6B,EAAE,CAAC,0BAA0B,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;gBAClG,CAAC;gBACD,OAAO,IAAI,CAAC;YACb,CAAC;YACD,sDAA+B,CAAC,CAAC,CAAC;gBACjC,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;oBAC9C,MAAM,GAAG,GAAG,2BAA2B,CAAC,IAAI,CAAC,CAAC;oBAC9C,IAAI,CAAC,6BAA6B,EAAE,CAAC,uBAAuB,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC/F,CAAC;gBACD,OAAO,IAAI,CAAC;YACb,CAAC;YACD,kDAA6B,CAAC,CAAC,CAAC;gBAC/B,IAAI,CAAC,6BAA6B,EAAE,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;gBACtF,OAAO,IAAI,CAAC;YACb,CAAC;YACD,2CAAiC,CAAC,CAAC,CAAC;gBACnC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,sBAAsB,EAAE,CAAC;gBAC3E,OAAO,IAAI,CAAC;YACb,CAAC;YACD,yCAA+B,CAAC,CAAC,CAAC;gBACjC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,oBAAoB,EAAE,CAAC;gBACzE,OAAO,IAAI,CAAC;YACb,CAAC;YACD,mCAAyB,CAAC,CAAC,CAAC;gBAC3B,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,MAAM,YAAY,GAAG,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBACjF,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,uBAAuB,CAAC,YAAY,CAAC,CAAC;gBAC7D,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;oBACzB,OAAO,IAAI,CAAC;gBACb,CAAC;gBACD,QAAQ,GAAG,EAAE,CAAC;oBACb,KAAK,oBAAoB,CAAC,CAAC,CAAC;wBAC3B,IAAI,CAAC,yBAAyB,CAAC,+BAA+B,CAAC,KAAK,CAAC,CAAC,CAAC;wBACvE,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,KAAK,KAAK,CAAC,CAAC,CAAC;wBACZ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;wBACvB,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,KAAK,WAAW,CAAC,CAAC,CAAC;wBAClB,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,eAAe,CAAC,KAAK,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;wBACnG,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,KAAK,yBAAyB,CAAC,CAAC,CAAC;wBAChC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,0BAA0B,CAAC,KAAK,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;wBAC9G,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,KAAK,QAAQ,CAAC,CAAC,CAAC;wBACf,iDAAiD;wBACjD,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAC;wBAC5D,IAAI,CAAC,uBAAuB,CAAC,cAAc,CAAC,CAAC;wBAC7C,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,KAAK,YAAY,CAAC,CAAC,CAAC;wBACnB,IAAI,CAAC,+BAA+B,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;wBAC5D,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,KAAK,MAAM,CAAC,CAAC,CAAC;wBACb,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;wBACrD,IAAI,CAAC,YAAY,CAAC,GAAG,6CAAqC,EAAE,2BAA2B,EAAE,CAAC;wBAC1F,OAAO,IAAI,CAAC;oBACb,CAAC;gBACF,CAAC;YACF,CAAC;YACD,wCAAwB,CAAC,CAAC,CAAC;gBAC1B,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;gBACtF,OAAO,IAAI,CAAC;YACb,CAAC;QACF,CAAC;QAED,wBAAwB;QACxB,OAAO,KAAK,CAAC;IACd,CAAC;IAEO,yBAAyB,CAAC,KAAa;QAC9C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO;QACR,CAAC;QACD,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;IAChF,CAAC;IAEO,uBAAuB,CAAC,MAAc;QAC7C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO;QACR,CAAC;QACD,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACtE,MAAM,qBAAqB,GAAG,cAAc,CAAC,IAAI,EAAE,CAAC;QACpD,MAAM,gBAAgB,GAAG,CACxB,qBAAqB,CAAC,MAAM,KAAK,CAAC;YACjC,0EAA0E;YAC1E,mCAAmC;YACnC,CAAC,CAAC,cAAc;YAChB,CAAC,CAAC,cAAc,CAAC,SAAS,CAAC,cAAc,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAC5D,CAAC;QACF,IAAI,gBAAgB,EAAE,CAAC;YACtB,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,mBAAmB,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC;QACzG,CAAC;IACF,CAAC;IAEO,UAAU,CAAC,KAAa;QAC/B,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;QAC3B,IAAI,CAAC,wBAAwB,EAAE,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACjD,MAAM,gBAAgB,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,6CAAqC,CAAC;QACpF,gBAAgB,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;IACjC,CAAC;IAEO,sBAAsB,CAAC,IAAY;QAC1C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC;QACd,CAAC;QAED,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,iBAAiB,CAAC,GAAG,sCAA2B,IAAI,OAAO,EAAE,CAAC,CAAC;QACpE,QAAQ,OAAO,EAAE,CAAC;YACjB,uCAAuB,CAAC,CAAC,CAAC;gBACzB,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;YAChE,CAAC;YACD,OAAO,CAAC,CAAC,CAAC;gBACT,4CAA4C;gBAC5C,wGAAwG;gBACxG,4HAA4H;gBAC5H,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;gBAExD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;oBACzB,uDAAuD;oBACvD,OAAO,IAAI,CAAC;gBACb,CAAC;gBAED,QAAQ,GAAG,EAAE,CAAC;oBACb;wBACC,gDAAgD;wBAChD,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;wBACvB,OAAO,IAAI,CAAC;gBACd,CAAC;YACF,CAAC;QACF,CAAC;QAED,wBAAwB;QACxB,OAAO,KAAK,CAAC;IACd,CAAC;IAEO,8BAA8B,CAAC,IAAY;QAClD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC;QACd,CAAC;QAED,MAAM,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC3C,IAAI,CAAC,iBAAiB,CAAC,GAAG,mDAA2C,IAAI,OAAO,EAAE,CAAC,CAAC;QACpF,QAAQ,OAAO,EAAE,CAAC;YACjB,KAAK,GAAG;gBACP,qCAAqC;gBACrC,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;oBACjB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1B,CAAC;gBACD,OAAO,IAAI,CAAC;QACd,CAAC;QAED,wBAAwB;QACxB,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;OAEG;IACK,eAAe,CAAC,IAAY;QACnC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC;QACd,CAAC;QAED,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,iBAAiB,CAAC,GAAG,oCAA4B,IAAI,OAAO,EAAE,CAAC,CAAC;QAErE,IAAI,OAAO,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE,CAAC;YACrC,MAAM,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YAC/B,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACrC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAC1B,OAAO,IAAI,CAAC;YACb,CAAC;QACF,CAAC;QAED,wBAAwB;QACxB,OAAO,KAAK,CAAC;IACd,CAAC;IAED,SAAS;QACR,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,6CAAqC,EAAE,CAAC;YACpF,OAAO;gBACN,YAAY,EAAE,KAAK;gBACnB,uBAAuB,EAAE,KAAK;gBAC9B,QAAQ,EAAE,EAAE;gBACZ,gBAAgB,EAAE,SAAS;aAC3B,CAAC;QACH,CAAC;QACD,MAAM,MAAM,GAAG,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,SAAS,EAAE,CAAC;QAC7E,OAAO,MAAM,CAAC;IACf,CAAC;IAED,WAAW,CAAC,UAAiD;QAC5D,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;QACtE,CAAC;QACD,MAAM,gBAAgB,GAAG,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC3E,gBAAgB,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QACzC,IAAI,gBAAgB,CAAC,GAAG,EAAE,CAAC;YAC1B,8EAA8E;YAC9E,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;QACvC,CAAC;IACF,CAAC;IAES,wBAAwB;QACjC,IAAI,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,yCAAiC,CAAC;QAC1E,IAAI,CAAC,YAAY,EAAE,CAAC;YACnB,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,sBAAsB,EAAE,CAAC,CAAC;YAC5D,IAAI,CAAC,YAAY,CAAC,GAAG,0CAAkC,YAAY,CAAC,CAAC;QACtE,CAAC;QACD,OAAO,YAAY,CAAC;IACrB,CAAC;IAES,4BAA4B,CAAC,QAAkB;QACxD,IAAI,gBAAgB,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,6CAAqC,CAAC;QAClF,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvB,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,0BAA0B,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC9F,IAAI,CAAC,YAAY,CAAC,GAAG,8CAAsC,gBAAgB,CAAC,CAAC;QAC9E,CAAC;QACD,OAAO,gBAAgB,CAAC;IACzB,CAAC;IAES,+BAA+B,CAAC,QAAkB;QAC3D,IAAI,mBAAmB,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,gDAAwC,CAAC;QACxF,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC1B,mBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;YACzE,IAAI,CAAC,YAAY,CAAC,GAAG,iDAAyC,mBAAmB,CAAC,CAAC;QACpF,CAAC;QACD,OAAO,mBAAmB,CAAC;IAC5B,CAAC;IAES,6BAA6B;QACtC,IAAI,iBAAiB,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,8CAAsC,CAAC;QACpF,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACxB,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,2BAA2B,EAAE,CAAC,CAAC;YACtE,IAAI,CAAC,YAAY,CAAC,GAAG,+CAAuC,iBAAiB,CAAC,CAAC;QAChF,CAAC;QACD,OAAO,iBAAiB,CAAC;IAC1B,CAAC;IAES,+BAA+B;QACxC,IAAI,mBAAmB,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,gDAAwC,CAAC;QACxF,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC1B,mBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,6BAA6B,EAAE,CAAC,CAAC;YAC1E,IAAI,CAAC,YAAY,CAAC,GAAG,iDAAyC,mBAAmB,CAAC,CAAC;QACpF,CAAC;QACD,OAAO,mBAAmB,CAAC;IAC5B,CAAC;CACD;AAED,MAAM,UAAU,2BAA2B,CAAC,OAAe;IAC1D,OAAO,OAAO,CAAC,UAAU;IACxB,gGAAgG;IAChG,yBAAyB;IACzB,gDAAgD;IAChD,2EAA2E;IAC3E,CAAC,MAAc,EAAE,EAAU,EAAE,GAAY,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;AACnG,CAAC;AAED,MAAM,UAAU,yBAAyB,CAAC,OAAe;IACxD,OAAO,OAAO,CAAC,OAAO;IACrB,uEAAuE;IACvE,iBAAiB,EACjB,CAAC,IAAY,EAAE,EAAE;QAChB,2BAA2B;QAC3B,IAAI,IAAI,KAAK,IAAI,EAAE,CAAC;YACnB,OAAO,MAAM,CAAC;QACf,CAAC;QACD,uEAAuE;QACvE,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QACpC,OAAO,MAAM,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC;IACvD,CAAC,CACD,CAAC;AACH,CAAC;AAED,MAAM,UAAU,uBAAuB,CAAC,OAAe;IACtD,MAAM,cAAc,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAC5C,IAAI,cAAc,KAAK,CAAC,CAAC,EAAE,CAAC;QAC3B,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,CAAC,CAAC,oBAAoB;IAChE,CAAC;IACD,OAAO;QACN,GAAG,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,cAAc,CAAC;QACzC,KAAK,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,cAAc,CAAC;KAC5C,CAAC;AACH,CAAC;AAGD,MAAM,UAAU,iBAAiB,CAAC,QAAgC;IACjE,IAAI,EAAE,GAAG,SAAS,CAAC;IACnB,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,KAAK,MAAM,QAAQ,IAAI,QAAQ,EAAE,CAAC;QACjC,kDAAkD;QAClD,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;YAC5B,SAAS;QACV,CAAC;QACD,IAAI,QAAQ,KAAK,QAAQ,EAAE,CAAC;YAC3B,MAAM,GAAG,IAAI,CAAC;QACf,CAAC;QACD,IAAI,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;YAChC,EAAE,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,CAAC;IACF,CAAC;IACD,OAAO,EAAE,EAAE,EAAE,MAAM,EAAE,CAAC;AACvB,CAAC","file":"shellIntegrationAddon.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IShellIntegration, ShellIntegrationStatus } from '../terminal.js';\nimport { Disposable, dispose, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { TerminalCapabilityStore } from '../capabilities/terminalCapabilityStore.js';\nimport { CommandDetectionCapability } from '../capabilities/commandDetectionCapability.js';\nimport { CwdDetectionCapability } from '../capabilities/cwdDetectionCapability.js';\nimport { IBufferMarkCapability, ICommandDetectionCapability, ICwdDetectionCapability, IPromptTypeDetectionCapability, ISerializedCommandDetectionCapability, IShellEnvDetectionCapability, TerminalCapability } from '../capabilities/capabilities.js';\nimport { PartialCommandDetectionCapability } from '../capabilities/partialCommandDetectionCapability.js';\nimport { ILogService } from '../../../log/common/log.js';\nimport { ITelemetryService } from '../../../telemetry/common/telemetry.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { BufferMarkCapability } from '../capabilities/bufferMarkCapability.js';\nimport type { ITerminalAddon, Terminal } from '@xterm/headless';\nimport { URI } from '../../../../base/common/uri.js';\nimport { sanitizeCwd } from '../terminalEnvironment.js';\nimport { removeAnsiEscapeCodesFromPrompt } from '../../../../base/common/strings.js';\nimport { ShellEnvDetectionCapability } from '../capabilities/shellEnvDetectionCapability.js';\nimport { PromptTypeDetectionCapability } from '../capabilities/promptTypeDetectionCapability.js';\n\n\n/**\n * Shell integration is a feature that enhances the terminal's understanding of what's happening\n * in the shell by injecting special sequences into the shell's prompt using the \"Set Text\n * Parameters\" sequence (`OSC Ps ; Pt ST`).\n *\n * Definitions:\n * - OSC: `\\x1b]`\n * - Ps:  A single (usually optional) numeric parameter, composed of one or more digits.\n * - Pt:  A text parameter composed of printable characters.\n * - ST: `\\x7`\n *\n * This is inspired by a feature of the same name in the FinalTerm, iTerm2 and kitty terminals.\n */\n\n/**\n * The identifier for the first numeric parameter (`Ps`) for OSC commands used by shell integration.\n */\nexport const enum ShellIntegrationOscPs {\n\t/**\n\t * Sequences pioneered by FinalTerm.\n\t */\n\tFinalTerm = 133,\n\t/**\n\t * Sequences pioneered by VS Code. The number is derived from the least significant digit of\n\t * \"VSC\" when encoded in hex (\"VSC\" = 0x56, 0x53, 0x43).\n\t */\n\tVSCode = 633,\n\t/**\n\t * Sequences pioneered by iTerm.\n\t */\n\tITerm = 1337,\n\tSetCwd = 7,\n\tSetWindowsFriendlyCwd = 9\n}\n\n/**\n * Sequences pioneered by FinalTerm.\n */\nconst enum FinalTermOscPt {\n\t/**\n\t * The start of the prompt, this is expected to always appear at the start of a line.\n\t *\n\t * Format: `OSC 133 ; A ST`\n\t */\n\tPromptStart = 'A',\n\n\t/**\n\t * The start of a command, ie. where the user inputs their command.\n\t *\n\t * Format: `OSC 133 ; B ST`\n\t */\n\tCommandStart = 'B',\n\n\t/**\n\t * Sent just before the command output begins.\n\t *\n\t * Format: `OSC 133 ; C ST`\n\t */\n\tCommandExecuted = 'C',\n\n\t/**\n\t * Sent just after a command has finished. The exit code is optional, when not specified it\n\t * means no command was run (ie. enter on empty prompt or ctrl+c).\n\t *\n\t * Format: `OSC 133 ; D [; <ExitCode>] ST`\n\t */\n\tCommandFinished = 'D',\n}\n\n/**\n * VS Code-specific shell integration sequences. Some of these are based on more common alternatives\n * like those pioneered in {@link FinalTermOscPt FinalTerm}. The decision to move to entirely custom\n * sequences was to try to improve reliability and prevent the possibility of applications confusing\n * the terminal. If multiple shell integration scripts run, VS Code will prioritize the VS\n * Code-specific ones.\n *\n * It's recommended that authors of shell integration scripts use the common sequences (`133`)\n * when building general purpose scripts and the VS Code-specific (`633`) when targeting only VS\n * Code or when there are no other alternatives (eg. {@link CommandLine `633 ; E`}). These sequences\n * support mix-and-matching.\n */\nconst enum VSCodeOscPt {\n\t/**\n\t * The start of the prompt, this is expected to always appear at the start of a line.\n\t *\n\t * Format: `OSC 633 ; A ST`\n\t *\n\t * Based on {@link FinalTermOscPt.PromptStart}.\n\t */\n\tPromptStart = 'A',\n\n\t/**\n\t * The start of a command, ie. where the user inputs their command.\n\t *\n\t * Format: `OSC 633 ; B ST`\n\t *\n\t * Based on  {@link FinalTermOscPt.CommandStart}.\n\t */\n\tCommandStart = 'B',\n\n\t/**\n\t * Sent just before the command output begins.\n\t *\n\t * Format: `OSC 633 ; C ST`\n\t *\n\t * Based on {@link FinalTermOscPt.CommandExecuted}.\n\t */\n\tCommandExecuted = 'C',\n\n\t/**\n\t * Sent just after a command has finished. This should generally be used on the new line\n\t * following the end of a command's output, just before {@link PromptStart}. The exit code is\n\t * optional, when not specified it means no command was run (ie. enter on empty prompt or\n\t * ctrl+c).\n\t *\n\t * Format: `OSC 633 ; D [; <ExitCode>] ST`\n\t *\n\t * Based on {@link FinalTermOscPt.CommandFinished}.\n\t */\n\tCommandFinished = 'D',\n\n\t/**\n\t * Explicitly set the command line. This helps workaround performance and reliability problems\n\t * with parsing out the command, such as conpty not guaranteeing the position of the sequence or\n\t * the shell not guaranteeing that the entire command is even visible. Ideally this is called\n\t * immediately before {@link CommandExecuted}, immediately before {@link CommandFinished} will\n\t * also work but that means terminal will only know the accurate command line when the command is\n\t * finished.\n\t *\n\t * The command line can escape ascii characters using the `\\xAB` format, where AB are the\n\t * hexadecimal representation of the character code (case insensitive), and escape the `\\`\n\t * character using `\\\\`. It's required to escape semi-colon (`0x3b`) and characters 0x20 and\n\t * below, this is particularly important for new line and semi-colon.\n\t *\n\t * Some examples:\n\t *\n\t * ```\n\t * \"\\\"  -> \"\\\\\"\n\t * \"\\n\" -> \"\\x0a\"\n\t * \";\"  -> \"\\x3b\"\n\t * ```\n\t *\n\t * An optional nonce can be provided which is may be required by the terminal in order enable\n\t * some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * Format: `OSC 633 ; E [; <CommandLine> [; <Nonce>]] ST`\n\t */\n\tCommandLine = 'E',\n\n\t/**\n\t * Similar to prompt start but for line continuations.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tContinuationStart = 'F',\n\n\t/**\n\t * Similar to command start but for line continuations.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tContinuationEnd = 'G',\n\n\t/**\n\t * The start of the right prompt.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tRightPromptStart = 'H',\n\n\t/**\n\t * The end of the right prompt.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tRightPromptEnd = 'I',\n\n\t/**\n\t * Set the value of an arbitrary property, only known properties will be handled by VS Code.\n\t *\n\t * Format: `OSC 633 ; P ; <Property>=<Value> ST`\n\t *\n\t * Known properties:\n\t *\n\t * - `Cwd` - Reports the current working directory to the terminal.\n\t * - `IsWindows` - Reports whether the shell is using a Windows backend like winpty or conpty.\n\t *   This may be used to enable additional heuristics as the positioning of the shell\n\t *   integration sequences are not guaranteed to be correct. Valid values: `True`, `False`.\n\t * - `ContinuationPrompt` - Reports the continuation prompt that is printed at the start of\n\t *   multi-line inputs.\n\t * - `HasRichCommandDetection` - Reports whether the shell has rich command line detection,\n\t *   meaning that sequences A, B, C, D and E are exactly where they're meant to be. In\n\t *   particular, {@link CommandLine} must happen immediately before {@link CommandExecuted} so\n\t *   VS Code knows the command line when the execution begins.\n\t *\n\t * WARNING: Any other properties may be changed and are not guaranteed to work in the future.\n\t */\n\tProperty = 'P',\n\n\t/**\n\t * Sets a mark/point-of-interest in the buffer.\n\t *\n\t * Format: `OSC 633 ; SetMark [; Id=<string>] [; Hidden]`\n\t *\n\t * `Id` - The identifier of the mark that can be used to reference it\n\t * `Hidden` - When set, the mark will be available to reference internally but will not visible\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tSetMark = 'SetMark',\n\n\t/**\n\t * Sends the shell's complete environment in JSON format.\n\t *\n\t * Format: `OSC 633 ; EnvJson ; <Environment> ; <Nonce>`\n\t *\n\t * - `Environment` - A stringified JSON object containing the shell's complete environment. The\n\t *    variables and values use the same encoding rules as the {@link CommandLine} sequence.\n\t * - `Nonce` - An _mandatory_ nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvJson = 'EnvJson',\n\n\t/**\n\t * Delete a single environment variable from cached environment.\n\t *\n\t * Format: `OSC 633 ; EnvSingleDelete ; <EnvironmentKey> ; <EnvironmentValue> [; <Nonce>]`\n\t *\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleDelete = 'EnvSingleDelete',\n\n\t/**\n\t * The start of the collecting user's environment variables individually.\n\t *\n\t * Format: `OSC 633 ; EnvSingleStart ; <Clear> [; <Nonce>]`\n\t *\n\t * - `Clear` - An _mandatory_ flag indicating any cached environment variables will be cleared.\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleStart = 'EnvSingleStart',\n\n\t/**\n\t * Sets an entry of single environment variable to transactional pending map of environment variables.\n\t *\n\t * Format: `OSC 633 ; EnvSingleEntry ; <EnvironmentKey> ; <EnvironmentValue> [; <Nonce>]`\n\t *\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleEntry = 'EnvSingleEntry',\n\n\t/**\n\t * The end of the collecting user's environment variables individually.\n\t * Clears any pending environment variables and fires an event that contains user's environment.\n\t *\n\t * Format: `OSC 633 ; EnvSingleEnd [; <Nonce>]`\n\t *\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleEnd = 'EnvSingleEnd'\n}\n\n/**\n * ITerm sequences\n */\nconst enum ITermOscPt {\n\t/**\n\t * Sets a mark/point-of-interest in the buffer.\n\t *\n\t * Format: `OSC 1337 ; SetMark`\n\t */\n\tSetMark = 'SetMark',\n\n\t/**\n\t * Reports current working directory (CWD).\n\t *\n\t * Format: `OSC 1337 ; CurrentDir=<Cwd> ST`\n\t */\n\tCurrentDir = 'CurrentDir'\n}\n\n/**\n * The shell integration addon extends xterm by reading shell integration sequences and creating\n * capabilities and passing along relevant sequences to the capabilities. This is meant to\n * encapsulate all handling/parsing of sequences so the capabilities don't need to.\n */\nexport class ShellIntegrationAddon extends Disposable implements IShellIntegration, ITerminalAddon {\n\tprivate _terminal?: Terminal;\n\treadonly capabilities = this._register(new TerminalCapabilityStore());\n\tprivate _hasUpdatedTelemetry: boolean = false;\n\tprivate _activationTimeout: Timeout | undefined;\n\tprivate _commonProtocolDisposables: IDisposable[] = [];\n\n\tprivate _seenSequences: Set<string> = new Set();\n\tget seenSequences(): ReadonlySet<string> { return this._seenSequences; }\n\n\tprivate _status: ShellIntegrationStatus = ShellIntegrationStatus.Off;\n\tget status(): ShellIntegrationStatus { return this._status; }\n\n\tprivate readonly _onDidChangeStatus = new Emitter<ShellIntegrationStatus>();\n\treadonly onDidChangeStatus = this._onDidChangeStatus.event;\n\tprivate readonly _onDidChangeSeenSequences = new Emitter<ReadonlySet<string>>();\n\treadonly onDidChangeSeenSequences = this._onDidChangeSeenSequences.event;\n\n\tconstructor(\n\t\tprivate _nonce: string,\n\t\tprivate readonly _disableTelemetry: boolean | undefined,\n\t\tprivate _onDidExecuteText: Event<void> | undefined,\n\t\tprivate readonly _telemetryService: ITelemetryService | undefined,\n\t\tprivate readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._clearActivationTimeout();\n\t\t\tthis._disposeCommonProtocol();\n\t\t}));\n\t}\n\n\tprivate _disposeCommonProtocol(): void {\n\t\tdispose(this._commonProtocolDisposables);\n\t\tthis._commonProtocolDisposables.length = 0;\n\t}\n\n\tactivate(xterm: Terminal) {\n\t\tthis._terminal = xterm;\n\t\tthis.capabilities.add(TerminalCapability.PartialCommandDetection, this._register(new PartialCommandDetectionCapability(this._terminal, this._onDidExecuteText)));\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.VSCode, data => this._handleVSCodeSequence(data)));\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.ITerm, data => this._doHandleITermSequence(data)));\n\t\tthis._commonProtocolDisposables.push(\n\t\t\txterm.parser.registerOscHandler(ShellIntegrationOscPs.FinalTerm, data => this._handleFinalTermSequence(data))\n\t\t);\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.SetCwd, data => this._doHandleSetCwd(data)));\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.SetWindowsFriendlyCwd, data => this._doHandleSetWindowsFriendlyCwd(data)));\n\t\tthis._ensureCapabilitiesOrAddFailureTelemetry();\n\t}\n\n\tgetMarkerId(terminal: Terminal, vscodeMarkerId: string) {\n\t\tthis._createOrGetBufferMarkDetection(terminal).getMark(vscodeMarkerId);\n\t}\n\n\tsetNextCommandId(command: string, commandId: string): void {\n\t\tif (this._terminal) {\n\t\t\tthis._createOrGetCommandDetection(this._terminal).setNextCommandId(command, commandId);\n\t\t}\n\t}\n\n\tprivate _markSequenceSeen(sequence: string) {\n\t\tif (!this._seenSequences.has(sequence)) {\n\t\t\tthis._seenSequences.add(sequence);\n\t\t\tthis._onDidChangeSeenSequences.fire(this._seenSequences);\n\t\t}\n\t}\n\n\tprivate _handleFinalTermSequence(data: string): boolean {\n\t\tconst didHandle = this._doHandleFinalTermSequence(data);\n\t\tif (this._status === ShellIntegrationStatus.Off) {\n\t\t\tthis._status = ShellIntegrationStatus.FinalTerm;\n\t\t\tthis._onDidChangeStatus.fire(this._status);\n\t\t}\n\t\treturn didHandle;\n\t}\n\n\tprivate _doHandleFinalTermSequence(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Pass the sequence along to the capability\n\t\t// It was considered to disable the common protocol in order to not confuse the VS Code\n\t\t// shell integration if both happen for some reason. This doesn't work for powerlevel10k\n\t\t// when instant prompt is enabled though. If this does end up being a problem we could pass\n\t\t// a type flag through the capability calls\n\t\tconst [command, ...args] = data.split(';');\n\t\tthis._markSequenceSeen(command);\n\t\tswitch (command) {\n\t\t\tcase FinalTermOscPt.PromptStart:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handlePromptStart();\n\t\t\t\treturn true;\n\t\t\tcase FinalTermOscPt.CommandStart:\n\t\t\t\t// Ignore the command line for these sequences as it's unreliable for example in powerlevel10k\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandStart({ ignoreCommandLine: true });\n\t\t\t\treturn true;\n\t\t\tcase FinalTermOscPt.CommandExecuted:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandExecuted();\n\t\t\t\treturn true;\n\t\t\tcase FinalTermOscPt.CommandFinished: {\n\t\t\t\tconst exitCode = args.length === 1 ? parseInt(args[0]) : undefined;\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandFinished(exitCode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _handleVSCodeSequence(data: string): boolean {\n\t\tconst didHandle = this._doHandleVSCodeSequence(data);\n\t\tif (!this._hasUpdatedTelemetry && didHandle) {\n\t\t\tthis._telemetryService?.publicLog2<{}, { owner: 'meganrogge'; comment: 'Indicates shell integration was activated' }>('terminal/shellIntegrationActivationSucceeded');\n\t\t\tthis._hasUpdatedTelemetry = true;\n\t\t\tthis._clearActivationTimeout();\n\t\t}\n\t\tif (this._status !== ShellIntegrationStatus.VSCode) {\n\t\t\tthis._status = ShellIntegrationStatus.VSCode;\n\t\t\tthis._onDidChangeStatus.fire(this._status);\n\t\t}\n\t\treturn didHandle;\n\t}\n\n\tprivate async _ensureCapabilitiesOrAddFailureTelemetry(): Promise<void> {\n\t\tif (!this._telemetryService || this._disableTelemetry) {\n\t\t\treturn;\n\t\t}\n\t\tthis._activationTimeout = setTimeout(() => {\n\t\t\tif (!this.capabilities.get(TerminalCapability.CommandDetection) && !this.capabilities.get(TerminalCapability.CwdDetection)) {\n\t\t\t\tthis._telemetryService?.publicLog2<{}, { owner: 'meganrogge'; comment: 'Indicates shell integration activation timeout' }>('terminal/shellIntegrationActivationTimeout');\n\t\t\t\tthis._logService.warn('Shell integration failed to add capabilities within 10 seconds');\n\t\t\t}\n\t\t\tthis._hasUpdatedTelemetry = true;\n\t\t}, 10000);\n\t}\n\n\tprivate _clearActivationTimeout(): void {\n\t\tif (this._activationTimeout !== undefined) {\n\t\t\tclearTimeout(this._activationTimeout);\n\t\t\tthis._activationTimeout = undefined;\n\t\t}\n\t}\n\n\tprivate _doHandleVSCodeSequence(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Pass the sequence along to the capability\n\t\tconst argsIndex = data.indexOf(';');\n\t\tconst command = argsIndex === -1 ? data : data.substring(0, argsIndex);\n\t\tthis._markSequenceSeen(command);\n\t\t// Cast to strict checked index access\n\t\tconst args: (string | undefined)[] = argsIndex === -1 ? [] : data.substring(argsIndex + 1).split(';');\n\t\tswitch (command) {\n\t\t\tcase VSCodeOscPt.PromptStart:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handlePromptStart();\n\t\t\t\treturn true;\n\t\t\tcase VSCodeOscPt.CommandStart:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandStart();\n\t\t\t\treturn true;\n\t\t\tcase VSCodeOscPt.CommandExecuted:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandExecuted();\n\t\t\t\treturn true;\n\t\t\tcase VSCodeOscPt.CommandFinished: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst exitCode = arg0 !== undefined ? parseInt(arg0) : undefined;\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandFinished(exitCode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.CommandLine: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tlet commandLine: string;\n\t\t\t\tif (arg0 !== undefined) {\n\t\t\t\t\tcommandLine = deserializeVSCodeOscMessage(arg0);\n\t\t\t\t} else {\n\t\t\t\t\tcommandLine = '';\n\t\t\t\t}\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).setCommandLine(commandLine, arg1 === this._nonce);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.ContinuationStart: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleContinuationStart();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.ContinuationEnd: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleContinuationEnd();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvJson: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tif (arg0 !== undefined) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst env = JSON.parse(deserializeVSCodeOscMessage(arg0));\n\t\t\t\t\t\tthis._createOrGetShellEnvDetection().setEnvironment(env, arg1 === this._nonce);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis._logService.warn('Failed to parse environment from shell integration sequence', arg0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleStart: {\n\t\t\t\tthis._createOrGetShellEnvDetection().startEnvironmentSingleVar(args[0] === '1', args[1] === this._nonce);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleDelete: {\n\t\t\t\tconst arg0 = args[0];\n\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tconst arg2 = args[2];\n\t\t\t\tif (arg0 !== undefined && arg1 !== undefined) {\n\t\t\t\t\tconst env = deserializeVSCodeOscMessage(arg1);\n\t\t\t\t\tthis._createOrGetShellEnvDetection().deleteEnvironmentSingleVar(arg0, env, arg2 === this._nonce);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleEntry: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tconst arg2 = args[2];\n\t\t\t\tif (arg0 !== undefined && arg1 !== undefined) {\n\t\t\t\t\tconst env = deserializeVSCodeOscMessage(arg1);\n\t\t\t\t\tthis._createOrGetShellEnvDetection().setEnvironmentSingleVar(arg0, env, arg2 === this._nonce);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleEnd: {\n\t\t\t\tthis._createOrGetShellEnvDetection().endEnvironmentSingleVar(args[0] === this._nonce);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.RightPromptStart: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleRightPromptStart();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.RightPromptEnd: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleRightPromptEnd();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.Property: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst deserialized = arg0 !== undefined ? deserializeVSCodeOscMessage(arg0) : '';\n\t\t\t\tconst { key, value } = parseKeyValueAssignment(deserialized);\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase 'ContinuationPrompt': {\n\t\t\t\t\t\tthis._updateContinuationPrompt(removeAnsiEscapeCodesFromPrompt(value));\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'Cwd': {\n\t\t\t\t\t\tthis._updateCwd(value);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'IsWindows': {\n\t\t\t\t\t\tthis._createOrGetCommandDetection(this._terminal).setIsWindowsPty(value === 'True' ? true : false);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'HasRichCommandDetection': {\n\t\t\t\t\t\tthis._createOrGetCommandDetection(this._terminal).setHasRichCommandDetection(value === 'True' ? true : false);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'Prompt': {\n\t\t\t\t\t\t// Remove escape sequences from the user's prompt\n\t\t\t\t\t\tconst sanitizedValue = value.replace(/\\x1b\\[[0-9;]*m/g, '');\n\t\t\t\t\t\tthis._updatePromptTerminator(sanitizedValue);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'PromptType': {\n\t\t\t\t\t\tthis._createOrGetPromptTypeDetection().setPromptType(value);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'Task': {\n\t\t\t\t\t\tthis._createOrGetBufferMarkDetection(this._terminal);\n\t\t\t\t\t\tthis.capabilities.get(TerminalCapability.CommandDetection)?.setIsCommandStorageDisabled();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase VSCodeOscPt.SetMark: {\n\t\t\t\tthis._createOrGetBufferMarkDetection(this._terminal).addMark(parseMarkSequence(args));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\tprivate _updateContinuationPrompt(value: string) {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tthis._createOrGetCommandDetection(this._terminal).setContinuationPrompt(value);\n\t}\n\n\tprivate _updatePromptTerminator(prompt: string) {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tconst lastPromptLine = prompt.substring(prompt.lastIndexOf('\\n') + 1);\n\t\tconst lastPromptLineTrimmed = lastPromptLine.trim();\n\t\tconst promptTerminator = (\n\t\t\tlastPromptLineTrimmed.length === 1\n\t\t\t\t// The prompt line contains a single character, treat the full line as the\n\t\t\t\t// terminator for example \"\\u2b9e \"\n\t\t\t\t? lastPromptLine\n\t\t\t\t: lastPromptLine.substring(lastPromptLine.lastIndexOf(' '))\n\t\t);\n\t\tif (promptTerminator) {\n\t\t\tthis._createOrGetCommandDetection(this._terminal).setPromptTerminator(promptTerminator, lastPromptLine);\n\t\t}\n\t}\n\n\tprivate _updateCwd(value: string) {\n\t\tvalue = sanitizeCwd(value);\n\t\tthis._createOrGetCwdDetection().updateCwd(value);\n\t\tconst commandDetection = this.capabilities.get(TerminalCapability.CommandDetection);\n\t\tcommandDetection?.setCwd(value);\n\t}\n\n\tprivate _doHandleITermSequence(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [command] = data.split(';');\n\t\tthis._markSequenceSeen(`${ShellIntegrationOscPs.ITerm};${command}`);\n\t\tswitch (command) {\n\t\t\tcase ITermOscPt.SetMark: {\n\t\t\t\tthis._createOrGetBufferMarkDetection(this._terminal).addMark();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t// Checking for known `<key>=<value>` pairs.\n\t\t\t\t// Note that unlike `VSCodeOscPt.Property`, iTerm2 does not interpret backslash or hex-escape sequences.\n\t\t\t\t// See: https://github.com/gnachman/iTerm2/blob/bb0882332cec5196e4de4a4225978d746e935279/sources/VT100Terminal.m#L2089-L2105\n\t\t\t\tconst { key, value } = parseKeyValueAssignment(command);\n\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\t// No '=' was found, so it's not a property assignment.\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase ITermOscPt.CurrentDir:\n\t\t\t\t\t\t// Encountered: `OSC 1337 ; CurrentDir=<Cwd> ST`\n\t\t\t\t\t\tthis._updateCwd(value);\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\tprivate _doHandleSetWindowsFriendlyCwd(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [command, ...args] = data.split(';');\n\t\tthis._markSequenceSeen(`${ShellIntegrationOscPs.SetWindowsFriendlyCwd};${command}`);\n\t\tswitch (command) {\n\t\t\tcase '9':\n\t\t\t\t// Encountered `OSC 9 ; 9 ; <cwd> ST`\n\t\t\t\tif (args.length) {\n\t\t\t\t\tthis._updateCwd(args[0]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handles the sequence: `OSC 7 ; scheme://cwd ST`\n\t */\n\tprivate _doHandleSetCwd(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [command] = data.split(';');\n\t\tthis._markSequenceSeen(`${ShellIntegrationOscPs.SetCwd};${command}`);\n\n\t\tif (command.match(/^file:\\/\\/.*\\//)) {\n\t\t\tconst uri = URI.parse(command);\n\t\t\tif (uri.path && uri.path.length > 0) {\n\t\t\t\tthis._updateCwd(uri.path);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\tserialize(): ISerializedCommandDetectionCapability {\n\t\tif (!this._terminal || !this.capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\treturn {\n\t\t\t\tisWindowsPty: false,\n\t\t\t\thasRichCommandDetection: false,\n\t\t\t\tcommands: [],\n\t\t\t\tpromptInputModel: undefined,\n\t\t\t};\n\t\t}\n\t\tconst result = this._createOrGetCommandDetection(this._terminal).serialize();\n\t\treturn result;\n\t}\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void {\n\t\tif (!this._terminal) {\n\t\t\tthrow new Error('Cannot restore commands before addon is activated');\n\t\t}\n\t\tconst commandDetection = this._createOrGetCommandDetection(this._terminal);\n\t\tcommandDetection.deserialize(serialized);\n\t\tif (commandDetection.cwd) {\n\t\t\t// Cwd gets set when the command is deserialized, so we need to update it here\n\t\t\tthis._updateCwd(commandDetection.cwd);\n\t\t}\n\t}\n\n\tprotected _createOrGetCwdDetection(): ICwdDetectionCapability {\n\t\tlet cwdDetection = this.capabilities.get(TerminalCapability.CwdDetection);\n\t\tif (!cwdDetection) {\n\t\t\tcwdDetection = this._register(new CwdDetectionCapability());\n\t\t\tthis.capabilities.add(TerminalCapability.CwdDetection, cwdDetection);\n\t\t}\n\t\treturn cwdDetection;\n\t}\n\n\tprotected _createOrGetCommandDetection(terminal: Terminal): ICommandDetectionCapability {\n\t\tlet commandDetection = this.capabilities.get(TerminalCapability.CommandDetection);\n\t\tif (!commandDetection) {\n\t\t\tcommandDetection = this._register(new CommandDetectionCapability(terminal, this._logService));\n\t\t\tthis.capabilities.add(TerminalCapability.CommandDetection, commandDetection);\n\t\t}\n\t\treturn commandDetection;\n\t}\n\n\tprotected _createOrGetBufferMarkDetection(terminal: Terminal): IBufferMarkCapability {\n\t\tlet bufferMarkDetection = this.capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tif (!bufferMarkDetection) {\n\t\t\tbufferMarkDetection = this._register(new BufferMarkCapability(terminal));\n\t\t\tthis.capabilities.add(TerminalCapability.BufferMarkDetection, bufferMarkDetection);\n\t\t}\n\t\treturn bufferMarkDetection;\n\t}\n\n\tprotected _createOrGetShellEnvDetection(): IShellEnvDetectionCapability {\n\t\tlet shellEnvDetection = this.capabilities.get(TerminalCapability.ShellEnvDetection);\n\t\tif (!shellEnvDetection) {\n\t\t\tshellEnvDetection = this._register(new ShellEnvDetectionCapability());\n\t\t\tthis.capabilities.add(TerminalCapability.ShellEnvDetection, shellEnvDetection);\n\t\t}\n\t\treturn shellEnvDetection;\n\t}\n\n\tprotected _createOrGetPromptTypeDetection(): IPromptTypeDetectionCapability {\n\t\tlet promptTypeDetection = this.capabilities.get(TerminalCapability.PromptTypeDetection);\n\t\tif (!promptTypeDetection) {\n\t\t\tpromptTypeDetection = this._register(new PromptTypeDetectionCapability());\n\t\t\tthis.capabilities.add(TerminalCapability.PromptTypeDetection, promptTypeDetection);\n\t\t}\n\t\treturn promptTypeDetection;\n\t}\n}\n\nexport function deserializeVSCodeOscMessage(message: string): string {\n\treturn message.replaceAll(\n\t\t// Backslash ('\\') followed by an escape operator: either another '\\', or 'x' and two hex chars.\n\t\t/\\\\(\\\\|x([0-9a-f]{2}))/gi,\n\t\t// If it's a hex value, parse it to a character.\n\t\t// Otherwise the operator is '\\', which we return literally, now unescaped.\n\t\t(_match: string, op: string, hex?: string) => hex ? String.fromCharCode(parseInt(hex, 16)) : op);\n}\n\nexport function serializeVSCodeOscMessage(message: string): string {\n\treturn message.replace(\n\t\t// Match backslash ('\\'), semicolon (';'), or characters 0x20 and below\n\t\t/[\\\\;\\x00-\\x20]/g,\n\t\t(char: string) => {\n\t\t\t// Escape backslash as '\\\\'\n\t\t\tif (char === '\\\\') {\n\t\t\t\treturn '\\\\\\\\';\n\t\t\t}\n\t\t\t// Escape other characters as '\\xAB' where AB is the hex representation\n\t\t\tconst charCode = char.charCodeAt(0);\n\t\t\treturn `\\\\x${charCode.toString(16).padStart(2, '0')}`;\n\t\t}\n\t);\n}\n\nexport function parseKeyValueAssignment(message: string): { key: string; value: string | undefined } {\n\tconst separatorIndex = message.indexOf('=');\n\tif (separatorIndex === -1) {\n\t\treturn { key: message, value: undefined }; // No '=' was found.\n\t}\n\treturn {\n\t\tkey: message.substring(0, separatorIndex),\n\t\tvalue: message.substring(1 + separatorIndex)\n\t};\n}\n\n\nexport function parseMarkSequence(sequence: (string | undefined)[]): { id?: string; hidden?: boolean } {\n\tlet id = undefined;\n\tlet hidden = false;\n\tfor (const property of sequence) {\n\t\t// Sanity check, this shouldn't happen in practice\n\t\tif (property === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (property === 'Hidden') {\n\t\t\thidden = true;\n\t\t}\n\t\tif (property.startsWith('Id=')) {\n\t\t\tid = property.substring(3);\n\t\t}\n\t}\n\treturn { id, hidden };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IShellIntegration, ShellIntegrationStatus } from '../terminal.js';\nimport { Disposable, dispose, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { TerminalCapabilityStore } from '../capabilities/terminalCapabilityStore.js';\nimport { CommandDetectionCapability } from '../capabilities/commandDetectionCapability.js';\nimport { CwdDetectionCapability } from '../capabilities/cwdDetectionCapability.js';\nimport { IBufferMarkCapability, ICommandDetectionCapability, ICwdDetectionCapability, IPromptTypeDetectionCapability, ISerializedCommandDetectionCapability, IShellEnvDetectionCapability, TerminalCapability } from '../capabilities/capabilities.js';\nimport { PartialCommandDetectionCapability } from '../capabilities/partialCommandDetectionCapability.js';\nimport { ILogService } from '../../../log/common/log.js';\nimport { ITelemetryService } from '../../../telemetry/common/telemetry.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { BufferMarkCapability } from '../capabilities/bufferMarkCapability.js';\nimport type { ITerminalAddon, Terminal } from '@xterm/headless';\nimport { URI } from '../../../../base/common/uri.js';\nimport { sanitizeCwd } from '../terminalEnvironment.js';\nimport { removeAnsiEscapeCodesFromPrompt } from '../../../../base/common/strings.js';\nimport { ShellEnvDetectionCapability } from '../capabilities/shellEnvDetectionCapability.js';\nimport { PromptTypeDetectionCapability } from '../capabilities/promptTypeDetectionCapability.js';\n\n\n/**\n * Shell integration is a feature that enhances the terminal's understanding of what's happening\n * in the shell by injecting special sequences into the shell's prompt using the \"Set Text\n * Parameters\" sequence (`OSC Ps ; Pt ST`).\n *\n * Definitions:\n * - OSC: `\\x1b]`\n * - Ps:  A single (usually optional) numeric parameter, composed of one or more digits.\n * - Pt:  A text parameter composed of printable characters.\n * - ST: `\\x7`\n *\n * This is inspired by a feature of the same name in the FinalTerm, iTerm2 and kitty terminals.\n */\n\n/**\n * The identifier for the first numeric parameter (`Ps`) for OSC commands used by shell integration.\n */\nexport const enum ShellIntegrationOscPs {\n\t/**\n\t * Sequences pioneered by FinalTerm.\n\t */\n\tFinalTerm = 133,\n\t/**\n\t * Sequences pioneered by VS Code. The number is derived from the least significant digit of\n\t * \"VSC\" when encoded in hex (\"VSC\" = 0x56, 0x53, 0x43).\n\t */\n\tVSCode = 633,\n\t/**\n\t * Sequences pioneered by iTerm.\n\t */\n\tITerm = 1337,\n\tSetCwd = 7,\n\tSetWindowsFriendlyCwd = 9\n}\n\n/**\n * Sequences pioneered by FinalTerm.\n */\nconst enum FinalTermOscPt {\n\t/**\n\t * The start of the prompt, this is expected to always appear at the start of a line.\n\t *\n\t * Format: `OSC 133 ; A ST`\n\t */\n\tPromptStart = 'A',\n\n\t/**\n\t * The start of a command, ie. where the user inputs their command.\n\t *\n\t * Format: `OSC 133 ; B ST`\n\t */\n\tCommandStart = 'B',\n\n\t/**\n\t * Sent just before the command output begins.\n\t *\n\t * Format: `OSC 133 ; C ST`\n\t */\n\tCommandExecuted = 'C',\n\n\t/**\n\t * Sent just after a command has finished. The exit code is optional, when not specified it\n\t * means no command was run (ie. enter on empty prompt or ctrl+c).\n\t *\n\t * Format: `OSC 133 ; D [; <ExitCode>] ST`\n\t */\n\tCommandFinished = 'D',\n}\n\n/**\n * VS Code-specific shell integration sequences. Some of these are based on more common alternatives\n * like those pioneered in {@link FinalTermOscPt FinalTerm}. The decision to move to entirely custom\n * sequences was to try to improve reliability and prevent the possibility of applications confusing\n * the terminal. If multiple shell integration scripts run, VS Code will prioritize the VS\n * Code-specific ones.\n *\n * It's recommended that authors of shell integration scripts use the common sequences (`133`)\n * when building general purpose scripts and the VS Code-specific (`633`) when targeting only VS\n * Code or when there are no other alternatives (eg. {@link CommandLine `633 ; E`}). These sequences\n * support mix-and-matching.\n */\nconst enum VSCodeOscPt {\n\t/**\n\t * The start of the prompt, this is expected to always appear at the start of a line.\n\t *\n\t * Format: `OSC 633 ; A ST`\n\t *\n\t * Based on {@link FinalTermOscPt.PromptStart}.\n\t */\n\tPromptStart = 'A',\n\n\t/**\n\t * The start of a command, ie. where the user inputs their command.\n\t *\n\t * Format: `OSC 633 ; B ST`\n\t *\n\t * Based on  {@link FinalTermOscPt.CommandStart}.\n\t */\n\tCommandStart = 'B',\n\n\t/**\n\t * Sent just before the command output begins.\n\t *\n\t * Format: `OSC 633 ; C ST`\n\t *\n\t * Based on {@link FinalTermOscPt.CommandExecuted}.\n\t */\n\tCommandExecuted = 'C',\n\n\t/**\n\t * Sent just after a command has finished. This should generally be used on the new line\n\t * following the end of a command's output, just before {@link PromptStart}. The exit code is\n\t * optional, when not specified it means no command was run (ie. enter on empty prompt or\n\t * ctrl+c).\n\t *\n\t * Format: `OSC 633 ; D [; <ExitCode>] ST`\n\t *\n\t * Based on {@link FinalTermOscPt.CommandFinished}.\n\t */\n\tCommandFinished = 'D',\n\n\t/**\n\t * Explicitly set the command line. This helps workaround performance and reliability problems\n\t * with parsing out the command, such as conpty not guaranteeing the position of the sequence or\n\t * the shell not guaranteeing that the entire command is even visible. Ideally this is called\n\t * immediately before {@link CommandExecuted}, immediately before {@link CommandFinished} will\n\t * also work but that means terminal will only know the accurate command line when the command is\n\t * finished.\n\t *\n\t * The command line can escape ascii characters using the `\\xAB` format, where AB are the\n\t * hexadecimal representation of the character code (case insensitive), and escape the `\\`\n\t * character using `\\\\`. It's required to escape semi-colon (`0x3b`) and characters 0x20 and\n\t * below, this is particularly important for new line and semi-colon.\n\t *\n\t * Some examples:\n\t *\n\t * ```\n\t * \"\\\"  -> \"\\\\\"\n\t * \"\\n\" -> \"\\x0a\"\n\t * \";\"  -> \"\\x3b\"\n\t * ```\n\t *\n\t * An optional nonce can be provided which is may be required by the terminal in order enable\n\t * some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * Format: `OSC 633 ; E [; <CommandLine> [; <Nonce>]] ST`\n\t */\n\tCommandLine = 'E',\n\n\t/**\n\t * Similar to prompt start but for line continuations.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tContinuationStart = 'F',\n\n\t/**\n\t * Similar to command start but for line continuations.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tContinuationEnd = 'G',\n\n\t/**\n\t * The start of the right prompt.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tRightPromptStart = 'H',\n\n\t/**\n\t * The end of the right prompt.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tRightPromptEnd = 'I',\n\n\t/**\n\t * Set the value of an arbitrary property, only known properties will be handled by VS Code.\n\t *\n\t * Format: `OSC 633 ; P ; <Property>=<Value> ST`\n\t *\n\t * Known properties:\n\t *\n\t * - `Cwd` - Reports the current working directory to the terminal.\n\t * - `IsWindows` - Reports whether the shell is using a Windows backend like winpty or conpty.\n\t *   This may be used to enable additional heuristics as the positioning of the shell\n\t *   integration sequences are not guaranteed to be correct. Valid values: `True`, `False`.\n\t * - `ContinuationPrompt` - Reports the continuation prompt that is printed at the start of\n\t *   multi-line inputs.\n\t * - `HasRichCommandDetection` - Reports whether the shell has rich command line detection,\n\t *   meaning that sequences A, B, C, D and E are exactly where they're meant to be. In\n\t *   particular, {@link CommandLine} must happen immediately before {@link CommandExecuted} so\n\t *   VS Code knows the command line when the execution begins.\n\t *\n\t * WARNING: Any other properties may be changed and are not guaranteed to work in the future.\n\t */\n\tProperty = 'P',\n\n\t/**\n\t * Sets a mark/point-of-interest in the buffer.\n\t *\n\t * Format: `OSC 633 ; SetMark [; Id=<string>] [; Hidden]`\n\t *\n\t * `Id` - The identifier of the mark that can be used to reference it\n\t * `Hidden` - When set, the mark will be available to reference internally but will not visible\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tSetMark = 'SetMark',\n\n\t/**\n\t * Sends the shell's complete environment in JSON format.\n\t *\n\t * Format: `OSC 633 ; EnvJson ; <Environment> ; <Nonce>`\n\t *\n\t * - `Environment` - A stringified JSON object containing the shell's complete environment. The\n\t *    variables and values use the same encoding rules as the {@link CommandLine} sequence.\n\t * - `Nonce` - An _mandatory_ nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvJson = 'EnvJson',\n\n\t/**\n\t * Delete a single environment variable from cached environment.\n\t *\n\t * Format: `OSC 633 ; EnvSingleDelete ; <EnvironmentKey> ; <EnvironmentValue> [; <Nonce>]`\n\t *\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleDelete = 'EnvSingleDelete',\n\n\t/**\n\t * The start of the collecting user's environment variables individually.\n\t *\n\t * Format: `OSC 633 ; EnvSingleStart ; <Clear> [; <Nonce>]`\n\t *\n\t * - `Clear` - An _mandatory_ flag indicating any cached environment variables will be cleared.\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleStart = 'EnvSingleStart',\n\n\t/**\n\t * Sets an entry of single environment variable to transactional pending map of environment variables.\n\t *\n\t * Format: `OSC 633 ; EnvSingleEntry ; <EnvironmentKey> ; <EnvironmentValue> [; <Nonce>]`\n\t *\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleEntry = 'EnvSingleEntry',\n\n\t/**\n\t * The end of the collecting user's environment variables individually.\n\t * Clears any pending environment variables and fires an event that contains user's environment.\n\t *\n\t * Format: `OSC 633 ; EnvSingleEnd [; <Nonce>]`\n\t *\n\t * - `Nonce` - An optional nonce can be provided which may be required by the terminal in order\n\t *   to enable some features. This helps ensure no malicious command injection has occurred.\n\t *\n\t * WARNING: This sequence is unfinalized, DO NOT use this in your shell integration script.\n\t */\n\tEnvSingleEnd = 'EnvSingleEnd'\n}\n\n/**\n * ITerm sequences\n */\nconst enum ITermOscPt {\n\t/**\n\t * Sets a mark/point-of-interest in the buffer.\n\t *\n\t * Format: `OSC 1337 ; SetMark`\n\t */\n\tSetMark = 'SetMark',\n\n\t/**\n\t * Reports current working directory (CWD).\n\t *\n\t * Format: `OSC 1337 ; CurrentDir=<Cwd> ST`\n\t */\n\tCurrentDir = 'CurrentDir'\n}\n\n/**\n * The shell integration addon extends xterm by reading shell integration sequences and creating\n * capabilities and passing along relevant sequences to the capabilities. This is meant to\n * encapsulate all handling/parsing of sequences so the capabilities don't need to.\n */\nexport class ShellIntegrationAddon extends Disposable implements IShellIntegration, ITerminalAddon {\n\tprivate _terminal?: Terminal;\n\treadonly capabilities = this._register(new TerminalCapabilityStore());\n\tprivate _hasUpdatedTelemetry: boolean = false;\n\tprivate _activationTimeout: Timeout | undefined;\n\tprivate _commonProtocolDisposables: IDisposable[] = [];\n\n\tprivate _seenSequences: Set<string> = new Set();\n\tget seenSequences(): ReadonlySet<string> { return this._seenSequences; }\n\n\tprivate _status: ShellIntegrationStatus = ShellIntegrationStatus.Off;\n\tget status(): ShellIntegrationStatus { return this._status; }\n\n\tprivate readonly _onDidChangeStatus = new Emitter<ShellIntegrationStatus>();\n\treadonly onDidChangeStatus = this._onDidChangeStatus.event;\n\tprivate readonly _onDidChangeSeenSequences = new Emitter<ReadonlySet<string>>();\n\treadonly onDidChangeSeenSequences = this._onDidChangeSeenSequences.event;\n\n\tconstructor(\n\t\tprivate _nonce: string,\n\t\tprivate readonly _disableTelemetry: boolean | undefined,\n\t\tprivate _onDidExecuteText: Event<void> | undefined,\n\t\tprivate readonly _telemetryService: ITelemetryService | undefined,\n\t\tprivate readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._clearActivationTimeout();\n\t\t\tthis._disposeCommonProtocol();\n\t\t}));\n\t}\n\n\tprivate _disposeCommonProtocol(): void {\n\t\tdispose(this._commonProtocolDisposables);\n\t\tthis._commonProtocolDisposables.length = 0;\n\t}\n\n\tactivate(xterm: Terminal) {\n\t\tthis._terminal = xterm;\n\t\tthis.capabilities.add(TerminalCapability.PartialCommandDetection, this._register(new PartialCommandDetectionCapability(this._terminal, this._onDidExecuteText)));\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.VSCode, data => this._handleVSCodeSequence(data)));\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.ITerm, data => this._doHandleITermSequence(data)));\n\t\tthis._commonProtocolDisposables.push(\n\t\t\txterm.parser.registerOscHandler(ShellIntegrationOscPs.FinalTerm, data => this._handleFinalTermSequence(data))\n\t\t);\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.SetCwd, data => this._doHandleSetCwd(data)));\n\t\tthis._register(xterm.parser.registerOscHandler(ShellIntegrationOscPs.SetWindowsFriendlyCwd, data => this._doHandleSetWindowsFriendlyCwd(data)));\n\t\tthis._ensureCapabilitiesOrAddFailureTelemetry();\n\t}\n\n\tgetMarkerId(terminal: Terminal, vscodeMarkerId: string) {\n\t\tthis._createOrGetBufferMarkDetection(terminal).getMark(vscodeMarkerId);\n\t}\n\n\tsetNextCommandId(command: string, commandId: string): void {\n\t\tif (this._terminal) {\n\t\t\tthis._createOrGetCommandDetection(this._terminal).setNextCommandId(command, commandId);\n\t\t}\n\t}\n\n\tprivate _markSequenceSeen(sequence: string) {\n\t\tif (!this._seenSequences.has(sequence)) {\n\t\t\tthis._seenSequences.add(sequence);\n\t\t\tthis._onDidChangeSeenSequences.fire(this._seenSequences);\n\t\t}\n\t}\n\n\tprivate _handleFinalTermSequence(data: string): boolean {\n\t\tconst didHandle = this._doHandleFinalTermSequence(data);\n\t\tif (this._status === ShellIntegrationStatus.Off) {\n\t\t\tthis._status = ShellIntegrationStatus.FinalTerm;\n\t\t\tthis._onDidChangeStatus.fire(this._status);\n\t\t}\n\t\treturn didHandle;\n\t}\n\n\tprivate _doHandleFinalTermSequence(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Pass the sequence along to the capability\n\t\t// It was considered to disable the common protocol in order to not confuse the VS Code\n\t\t// shell integration if both happen for some reason. This doesn't work for powerlevel10k\n\t\t// when instant prompt is enabled though. If this does end up being a problem we could pass\n\t\t// a type flag through the capability calls\n\t\tconst [command, ...args] = data.split(';');\n\t\tthis._markSequenceSeen(command);\n\t\tswitch (command) {\n\t\t\tcase FinalTermOscPt.PromptStart:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handlePromptStart();\n\t\t\t\treturn true;\n\t\t\tcase FinalTermOscPt.CommandStart:\n\t\t\t\t// Ignore the command line for these sequences as it's unreliable for example in powerlevel10k\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandStart({ ignoreCommandLine: true });\n\t\t\t\treturn true;\n\t\t\tcase FinalTermOscPt.CommandExecuted:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandExecuted();\n\t\t\t\treturn true;\n\t\t\tcase FinalTermOscPt.CommandFinished: {\n\t\t\t\tconst exitCode = args.length === 1 ? parseInt(args[0]) : undefined;\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandFinished(exitCode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _handleVSCodeSequence(data: string): boolean {\n\t\tconst didHandle = this._doHandleVSCodeSequence(data);\n\t\tif (!this._hasUpdatedTelemetry && didHandle) {\n\t\t\tthis._telemetryService?.publicLog2<{}, { owner: 'meganrogge'; comment: 'Indicates shell integration was activated' }>('terminal/shellIntegrationActivationSucceeded');\n\t\t\tthis._hasUpdatedTelemetry = true;\n\t\t\tthis._clearActivationTimeout();\n\t\t}\n\t\tif (this._status !== ShellIntegrationStatus.VSCode) {\n\t\t\tthis._status = ShellIntegrationStatus.VSCode;\n\t\t\tthis._onDidChangeStatus.fire(this._status);\n\t\t}\n\t\treturn didHandle;\n\t}\n\n\tprivate async _ensureCapabilitiesOrAddFailureTelemetry(): Promise<void> {\n\t\tif (!this._telemetryService || this._disableTelemetry) {\n\t\t\treturn;\n\t\t}\n\t\tthis._activationTimeout = setTimeout(() => {\n\t\t\tif (!this.capabilities.get(TerminalCapability.CommandDetection) && !this.capabilities.get(TerminalCapability.CwdDetection)) {\n\t\t\t\tthis._telemetryService?.publicLog2<{}, { owner: 'meganrogge'; comment: 'Indicates shell integration activation timeout' }>('terminal/shellIntegrationActivationTimeout');\n\t\t\t\tthis._logService.warn('Shell integration failed to add capabilities within 10 seconds');\n\t\t\t}\n\t\t\tthis._hasUpdatedTelemetry = true;\n\t\t}, 10000);\n\t}\n\n\tprivate _clearActivationTimeout(): void {\n\t\tif (this._activationTimeout !== undefined) {\n\t\t\tclearTimeout(this._activationTimeout);\n\t\t\tthis._activationTimeout = undefined;\n\t\t}\n\t}\n\n\tprivate _doHandleVSCodeSequence(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Pass the sequence along to the capability\n\t\tconst argsIndex = data.indexOf(';');\n\t\tconst command = argsIndex === -1 ? data : data.substring(0, argsIndex);\n\t\tthis._markSequenceSeen(command);\n\t\t// Cast to strict checked index access\n\t\tconst args: (string | undefined)[] = argsIndex === -1 ? [] : data.substring(argsIndex + 1).split(';');\n\t\tswitch (command) {\n\t\t\tcase VSCodeOscPt.PromptStart:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handlePromptStart();\n\t\t\t\treturn true;\n\t\t\tcase VSCodeOscPt.CommandStart:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandStart();\n\t\t\t\treturn true;\n\t\t\tcase VSCodeOscPt.CommandExecuted:\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandExecuted();\n\t\t\t\treturn true;\n\t\t\tcase VSCodeOscPt.CommandFinished: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst exitCode = arg0 !== undefined ? parseInt(arg0) : undefined;\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleCommandFinished(exitCode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.CommandLine: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tlet commandLine: string;\n\t\t\t\tif (arg0 !== undefined) {\n\t\t\t\t\tcommandLine = deserializeVSCodeOscMessage(arg0);\n\t\t\t\t} else {\n\t\t\t\t\tcommandLine = '';\n\t\t\t\t}\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).setCommandLine(commandLine, arg1 === this._nonce);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.ContinuationStart: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleContinuationStart();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.ContinuationEnd: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleContinuationEnd();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvJson: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tif (arg0 !== undefined) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst env = JSON.parse(deserializeVSCodeOscMessage(arg0));\n\t\t\t\t\t\tthis._createOrGetShellEnvDetection().setEnvironment(env, arg1 === this._nonce);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis._logService.warn('Failed to parse environment from shell integration sequence', arg0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleStart: {\n\t\t\t\tthis._createOrGetShellEnvDetection().startEnvironmentSingleVar(args[0] === '1', args[1] === this._nonce);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleDelete: {\n\t\t\t\tconst arg0 = args[0];\n\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tconst arg2 = args[2];\n\t\t\t\tif (arg0 !== undefined && arg1 !== undefined) {\n\t\t\t\t\tconst env = deserializeVSCodeOscMessage(arg1);\n\t\t\t\t\tthis._createOrGetShellEnvDetection().deleteEnvironmentSingleVar(arg0, env, arg2 === this._nonce);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleEntry: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst arg1 = args[1];\n\t\t\t\tconst arg2 = args[2];\n\t\t\t\tif (arg0 !== undefined && arg1 !== undefined) {\n\t\t\t\t\tconst env = deserializeVSCodeOscMessage(arg1);\n\t\t\t\t\tthis._createOrGetShellEnvDetection().setEnvironmentSingleVar(arg0, env, arg2 === this._nonce);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.EnvSingleEnd: {\n\t\t\t\tthis._createOrGetShellEnvDetection().endEnvironmentSingleVar(args[0] === this._nonce);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.RightPromptStart: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleRightPromptStart();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.RightPromptEnd: {\n\t\t\t\tthis._createOrGetCommandDetection(this._terminal).handleRightPromptEnd();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase VSCodeOscPt.Property: {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tconst deserialized = arg0 !== undefined ? deserializeVSCodeOscMessage(arg0) : '';\n\t\t\t\tconst { key, value } = parseKeyValueAssignment(deserialized);\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase 'ContinuationPrompt': {\n\t\t\t\t\t\tthis._updateContinuationPrompt(removeAnsiEscapeCodesFromPrompt(value));\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'Cwd': {\n\t\t\t\t\t\tthis._updateCwd(value);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'IsWindows': {\n\t\t\t\t\t\tthis._createOrGetCommandDetection(this._terminal).setIsWindowsPty(value === 'True' ? true : false);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'HasRichCommandDetection': {\n\t\t\t\t\t\tthis._createOrGetCommandDetection(this._terminal).setHasRichCommandDetection(value === 'True' ? true : false);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'Prompt': {\n\t\t\t\t\t\t// Remove escape sequences from the user's prompt\n\t\t\t\t\t\tconst sanitizedValue = value.replace(/\\x1b\\[[0-9;]*m/g, '');\n\t\t\t\t\t\tthis._updatePromptTerminator(sanitizedValue);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'PromptType': {\n\t\t\t\t\t\tthis._createOrGetPromptTypeDetection().setPromptType(value);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'Task': {\n\t\t\t\t\t\tthis._createOrGetBufferMarkDetection(this._terminal);\n\t\t\t\t\t\tthis.capabilities.get(TerminalCapability.CommandDetection)?.setIsCommandStorageDisabled();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase VSCodeOscPt.SetMark: {\n\t\t\t\tthis._createOrGetBufferMarkDetection(this._terminal).addMark(parseMarkSequence(args));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\tprivate _updateContinuationPrompt(value: string) {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tthis._createOrGetCommandDetection(this._terminal).setContinuationPrompt(value);\n\t}\n\n\tprivate _updatePromptTerminator(prompt: string) {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tconst lastPromptLine = prompt.substring(prompt.lastIndexOf('\\n') + 1);\n\t\tconst lastPromptLineTrimmed = lastPromptLine.trim();\n\t\tconst promptTerminator = (\n\t\t\tlastPromptLineTrimmed.length === 1\n\t\t\t\t// The prompt line contains a single character, treat the full line as the\n\t\t\t\t// terminator for example \"\\u2b9e \"\n\t\t\t\t? lastPromptLine\n\t\t\t\t: lastPromptLine.substring(lastPromptLine.lastIndexOf(' '))\n\t\t);\n\t\tif (promptTerminator) {\n\t\t\tthis._createOrGetCommandDetection(this._terminal).setPromptTerminator(promptTerminator, lastPromptLine);\n\t\t}\n\t}\n\n\tprivate _updateCwd(value: string) {\n\t\tvalue = sanitizeCwd(value);\n\t\tthis._createOrGetCwdDetection().updateCwd(value);\n\t\tconst commandDetection = this.capabilities.get(TerminalCapability.CommandDetection);\n\t\tcommandDetection?.setCwd(value);\n\t}\n\n\tprivate _doHandleITermSequence(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [command] = data.split(';');\n\t\tthis._markSequenceSeen(`${ShellIntegrationOscPs.ITerm};${command}`);\n\t\tswitch (command) {\n\t\t\tcase ITermOscPt.SetMark: {\n\t\t\t\tthis._createOrGetBufferMarkDetection(this._terminal).addMark();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t// Checking for known `<key>=<value>` pairs.\n\t\t\t\t// Note that unlike `VSCodeOscPt.Property`, iTerm2 does not interpret backslash or hex-escape sequences.\n\t\t\t\t// See: https://github.com/gnachman/iTerm2/blob/bb0882332cec5196e4de4a4225978d746e935279/sources/VT100Terminal.m#L2089-L2105\n\t\t\t\tconst { key, value } = parseKeyValueAssignment(command);\n\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\t// No '=' was found, so it's not a property assignment.\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase ITermOscPt.CurrentDir:\n\t\t\t\t\t\t// Encountered: `OSC 1337 ; CurrentDir=<Cwd> ST`\n\t\t\t\t\t\tthis._updateCwd(value);\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\tprivate _doHandleSetWindowsFriendlyCwd(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [command, ...args] = data.split(';');\n\t\tthis._markSequenceSeen(`${ShellIntegrationOscPs.SetWindowsFriendlyCwd};${command}`);\n\t\tswitch (command) {\n\t\t\tcase '9':\n\t\t\t\t// Encountered `OSC 9 ; 9 ; <cwd> ST`\n\t\t\t\tif (args.length) {\n\t\t\t\t\tthis._updateCwd(args[0]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handles the sequence: `OSC 7 ; scheme://cwd ST`\n\t */\n\tprivate _doHandleSetCwd(data: string): boolean {\n\t\tif (!this._terminal) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [command] = data.split(';');\n\t\tthis._markSequenceSeen(`${ShellIntegrationOscPs.SetCwd};${command}`);\n\n\t\tif (command.match(/^file:\\/\\/.*\\//)) {\n\t\t\tconst uri = URI.parse(command);\n\t\t\tif (uri.path && uri.path.length > 0) {\n\t\t\t\tthis._updateCwd(uri.path);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Unrecognized sequence\n\t\treturn false;\n\t}\n\n\tserialize(): ISerializedCommandDetectionCapability {\n\t\tif (!this._terminal || !this.capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\treturn {\n\t\t\t\tisWindowsPty: false,\n\t\t\t\thasRichCommandDetection: false,\n\t\t\t\tcommands: [],\n\t\t\t\tpromptInputModel: undefined,\n\t\t\t};\n\t\t}\n\t\tconst result = this._createOrGetCommandDetection(this._terminal).serialize();\n\t\treturn result;\n\t}\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void {\n\t\tif (!this._terminal) {\n\t\t\tthrow new Error('Cannot restore commands before addon is activated');\n\t\t}\n\t\tconst commandDetection = this._createOrGetCommandDetection(this._terminal);\n\t\tcommandDetection.deserialize(serialized);\n\t\tif (commandDetection.cwd) {\n\t\t\t// Cwd gets set when the command is deserialized, so we need to update it here\n\t\t\tthis._updateCwd(commandDetection.cwd);\n\t\t}\n\t}\n\n\tprotected _createOrGetCwdDetection(): ICwdDetectionCapability {\n\t\tlet cwdDetection = this.capabilities.get(TerminalCapability.CwdDetection);\n\t\tif (!cwdDetection) {\n\t\t\tcwdDetection = this._register(new CwdDetectionCapability());\n\t\t\tthis.capabilities.add(TerminalCapability.CwdDetection, cwdDetection);\n\t\t}\n\t\treturn cwdDetection;\n\t}\n\n\tprotected _createOrGetCommandDetection(terminal: Terminal): ICommandDetectionCapability {\n\t\tlet commandDetection = this.capabilities.get(TerminalCapability.CommandDetection);\n\t\tif (!commandDetection) {\n\t\t\tcommandDetection = this._register(new CommandDetectionCapability(terminal, this._logService));\n\t\t\tthis.capabilities.add(TerminalCapability.CommandDetection, commandDetection);\n\t\t}\n\t\treturn commandDetection;\n\t}\n\n\tprotected _createOrGetBufferMarkDetection(terminal: Terminal): IBufferMarkCapability {\n\t\tlet bufferMarkDetection = this.capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tif (!bufferMarkDetection) {\n\t\t\tbufferMarkDetection = this._register(new BufferMarkCapability(terminal));\n\t\t\tthis.capabilities.add(TerminalCapability.BufferMarkDetection, bufferMarkDetection);\n\t\t}\n\t\treturn bufferMarkDetection;\n\t}\n\n\tprotected _createOrGetShellEnvDetection(): IShellEnvDetectionCapability {\n\t\tlet shellEnvDetection = this.capabilities.get(TerminalCapability.ShellEnvDetection);\n\t\tif (!shellEnvDetection) {\n\t\t\tshellEnvDetection = this._register(new ShellEnvDetectionCapability());\n\t\t\tthis.capabilities.add(TerminalCapability.ShellEnvDetection, shellEnvDetection);\n\t\t}\n\t\treturn shellEnvDetection;\n\t}\n\n\tprotected _createOrGetPromptTypeDetection(): IPromptTypeDetectionCapability {\n\t\tlet promptTypeDetection = this.capabilities.get(TerminalCapability.PromptTypeDetection);\n\t\tif (!promptTypeDetection) {\n\t\t\tpromptTypeDetection = this._register(new PromptTypeDetectionCapability());\n\t\t\tthis.capabilities.add(TerminalCapability.PromptTypeDetection, promptTypeDetection);\n\t\t}\n\t\treturn promptTypeDetection;\n\t}\n}\n\nexport function deserializeVSCodeOscMessage(message: string): string {\n\treturn message.replaceAll(\n\t\t// Backslash ('\\') followed by an escape operator: either another '\\', or 'x' and two hex chars.\n\t\t/\\\\(\\\\|x([0-9a-f]{2}))/gi,\n\t\t// If it's a hex value, parse it to a character.\n\t\t// Otherwise the operator is '\\', which we return literally, now unescaped.\n\t\t(_match: string, op: string, hex?: string) => hex ? String.fromCharCode(parseInt(hex, 16)) : op);\n}\n\nexport function serializeVSCodeOscMessage(message: string): string {\n\treturn message.replace(\n\t\t// Match backslash ('\\'), semicolon (';'), or characters 0x20 and below\n\t\t/[\\\\;\\x00-\\x20]/g,\n\t\t(char: string) => {\n\t\t\t// Escape backslash as '\\\\'\n\t\t\tif (char === '\\\\') {\n\t\t\t\treturn '\\\\\\\\';\n\t\t\t}\n\t\t\t// Escape other characters as '\\xAB' where AB is the hex representation\n\t\t\tconst charCode = char.charCodeAt(0);\n\t\t\treturn `\\\\x${charCode.toString(16).padStart(2, '0')}`;\n\t\t}\n\t);\n}\n\nexport function parseKeyValueAssignment(message: string): { key: string; value: string | undefined } {\n\tconst separatorIndex = message.indexOf('=');\n\tif (separatorIndex === -1) {\n\t\treturn { key: message, value: undefined }; // No '=' was found.\n\t}\n\treturn {\n\t\tkey: message.substring(0, separatorIndex),\n\t\tvalue: message.substring(1 + separatorIndex)\n\t};\n}\n\n\nexport function parseMarkSequence(sequence: (string | undefined)[]): { id?: string; hidden?: boolean } {\n\tlet id = undefined;\n\tlet hidden = false;\n\tfor (const property of sequence) {\n\t\t// Sanity check, this shouldn't happen in practice\n\t\tif (property === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (property === 'Hidden') {\n\t\t\thidden = true;\n\t\t}\n\t\tif (property.startsWith('Id=')) {\n\t\t\tid = property.substring(3);\n\t\t}\n\t}\n\treturn { id, hidden };\n}\n"]}