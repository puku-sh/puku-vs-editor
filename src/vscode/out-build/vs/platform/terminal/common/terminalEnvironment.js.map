{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/terminalEnvironment.ts","vs/platform/terminal/common/terminalEnvironment.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAmB,EAAE,EAAE,MAAM,kCAAkC,CAAC;AAGvE;;;;GAIG;AACH,MAAM,UAAU,oBAAoB,CAAC,IAAY,EAAE,SAA6B;IAC/E,IAAI,OAAO,GAAG,IAAI,CAAC;IACnB,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;QAC5B,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IAC1C,CAAC;IAYD,IAAI,YAA+B,CAAC;IACpC,QAAQ,SAAS,EAAE,CAAC;QACnB,sCAAyB;QACzB,kCAAuB;QACvB,oCAAwB;QACxB;YACC,YAAY,GAAG;gBACd,UAAU,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG;gBACxD,YAAY,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG;gBACzD,cAAc,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,GAAG;aACrC,CAAC;YACF,MAAM;QACP;YACC,YAAY,GAAG;gBACd,UAAU,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG;gBACtD,YAAY,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG;gBACzD,cAAc,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,GAAG;aACrC,CAAC;YACF,MAAM;QACP;YACC,iEAAiE;YACjE,8CAA8C;YAC9C,YAAY,GAAG;gBACd,UAAU,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG;gBACrD,YAAY,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG;gBACzD,cAAc,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,GAAG;aACrC,CAAC;YACF,MAAM;QACP;YACC,qDAAqD;YACrD,YAAY,GAAG;gBACd,UAAU,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG;gBACxD,YAAY,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG;gBACzD,cAAc,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,GAAG;aACrC,CAAC;YACF,MAAM;IACR,CAAC;IAED,2FAA2F;IAC3F,MAAM,WAAW,GAAG,6BAA6B,CAAC;IAClD,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;IAE3C,uDAAuD;IACvD,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;QACrD,OAAO,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC;SAAM,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;QACnC,OAAO,YAAY,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;IAC3C,CAAC;SAAM,CAAC;QACP,OAAO,YAAY,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IAC7C,CAAC;AACF,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,iBAAiB,CAAC,IAAwB,EAAE,QAA4B,EAAE,SAAiB;IAC1G,IAAI,CAAC,IAAI,EAAE,CAAC;QACX,OAAO,EAAE,CAAC;IACX,CAAC;IACD,IAAI,CAAC,QAAQ,EAAE,CAAC;QACf,OAAO,IAAI,CAAC;IACb,CAAC;IACD,wDAAwD;IACxD,IAAI,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC;QAC/B,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACnD,CAAC;IACD,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;IAC9D,MAAM,kBAAkB,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;IACtE,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,kBAAkB,CAAC,EAAE,CAAC;QAClD,OAAO,IAAI,CAAC;IACb,CAAC;IACD,OAAO,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC;AAC1D,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,WAAW,CAAC,GAAW;IACtC,mEAAmE;IACnE,IAAI,GAAG,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE,CAAC;QAC/B,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACxC,CAAC;IACD,yDAAyD;IACzD,IAAI,EAAE,oCAA4B,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;QAC7D,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAChD,CAAC;IACD,OAAO,GAAG,CAAC;AACZ,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,sCAAsC,CAAC,GAAuB;IAC7E,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC;AACvB,CAAC","file":"terminalEnvironment.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OperatingSystem, OS } from '../../../base/common/platform.js';\nimport { IShellLaunchConfig, TerminalShellType, PosixShellType, WindowsShellType, GeneralShellType } from './terminal.js';\n\n/**\n * Aggressively escape non-windows paths to prepare for being sent to a shell. This will do some\n * escaping inaccurately to be careful about possible script injection via the file path. For\n * example, we're trying to prevent this sort of attack: `/foo/file$(echo evil)`.\n */\nexport function escapeNonWindowsPath(path: string, shellType?: TerminalShellType): string {\n\tlet newPath = path;\n\tif (newPath.includes('\\\\')) {\n\t\tnewPath = newPath.replace(/\\\\/g, '\\\\\\\\');\n\t}\n\n\t// Define shell-specific escaping rules\n\tinterface ShellEscapeConfig {\n\t\t// How to handle paths with both single and double quotes\n\t\tbothQuotes: (path: string) => string;\n\t\t// How to handle paths with only single quotes\n\t\tsingleQuotes: (path: string) => string;\n\t\t// How to handle paths with no single quotes (may have double quotes)\n\t\tnoSingleQuotes: (path: string) => string;\n\t}\n\n\tlet escapeConfig: ShellEscapeConfig;\n\tswitch (shellType) {\n\t\tcase PosixShellType.Bash:\n\t\tcase PosixShellType.Sh:\n\t\tcase PosixShellType.Zsh:\n\t\tcase WindowsShellType.GitBash:\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `$'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t\tcase PosixShellType.Fish:\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `\"${path.replace(/\"/g, '\\\\\"')}\"`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t\tcase GeneralShellType.PowerShell:\n\t\t\t// PowerShell should be handled separately in preparePathForShell\n\t\t\t// but if we get here, use PowerShell escaping\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `\"${path.replace(/\"/g, '`\"')}\"`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\'\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to POSIX shell escaping for unknown shells\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `$'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t}\n\n\t// Remove dangerous characters except single and double quotes, which we'll escape properly\n\tconst bannedChars = /[\\`\\$\\|\\&\\>\\~\\#\\!\\^\\*\\;\\<]/g;\n\tnewPath = newPath.replace(bannedChars, '');\n\n\t// Apply shell-specific escaping based on quote content\n\tif (newPath.includes('\\'') && newPath.includes('\"')) {\n\t\treturn escapeConfig.bothQuotes(newPath);\n\t} else if (newPath.includes('\\'')) {\n\t\treturn escapeConfig.singleQuotes(newPath);\n\t} else {\n\t\treturn escapeConfig.noSingleQuotes(newPath);\n\t}\n}\n\n/**\n * Collapses the user's home directory into `~` if it exists within the path, this gives a shorter\n * path that is more suitable within the context of a terminal.\n */\nexport function collapseTildePath(path: string | undefined, userHome: string | undefined, separator: string): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\tif (!userHome) {\n\t\treturn path;\n\t}\n\t// Trim the trailing separator from the end if it exists\n\tif (userHome.match(/[\\/\\\\]$/)) {\n\t\tuserHome = userHome.slice(0, userHome.length - 1);\n\t}\n\tconst normalizedPath = path.replace(/\\\\/g, '/').toLowerCase();\n\tconst normalizedUserHome = userHome.replace(/\\\\/g, '/').toLowerCase();\n\tif (!normalizedPath.includes(normalizedUserHome)) {\n\t\treturn path;\n\t}\n\treturn `~${separator}${path.slice(userHome.length + 1)}`;\n}\n\n/**\n * Sanitizes a cwd string, removing any wrapping quotes and making the Windows drive letter\n * uppercase.\n * @param cwd The directory to sanitize.\n */\nexport function sanitizeCwd(cwd: string): string {\n\t// Sanity check that the cwd is not wrapped in quotes (see #160109)\n\tif (cwd.match(/^['\"].*['\"]$/)) {\n\t\tcwd = cwd.substring(1, cwd.length - 1);\n\t}\n\t// Make the drive letter uppercase on Windows (see #9448)\n\tif (OS === OperatingSystem.Windows && cwd && cwd[1] === ':') {\n\t\treturn cwd[0].toUpperCase() + cwd.substring(1);\n\t}\n\treturn cwd;\n}\n\n/**\n * Determines whether the given shell launch config should use the environment variable collection.\n * @param slc The shell launch config to check.\n */\nexport function shouldUseEnvironmentVariableCollection(slc: IShellLaunchConfig): boolean {\n\treturn !slc.strictEnv;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OperatingSystem, OS } from '../../../base/common/platform.js';\nimport { IShellLaunchConfig, TerminalShellType, PosixShellType, WindowsShellType, GeneralShellType } from './terminal.js';\n\n/**\n * Aggressively escape non-windows paths to prepare for being sent to a shell. This will do some\n * escaping inaccurately to be careful about possible script injection via the file path. For\n * example, we're trying to prevent this sort of attack: `/foo/file$(echo evil)`.\n */\nexport function escapeNonWindowsPath(path: string, shellType?: TerminalShellType): string {\n\tlet newPath = path;\n\tif (newPath.includes('\\\\')) {\n\t\tnewPath = newPath.replace(/\\\\/g, '\\\\\\\\');\n\t}\n\n\t// Define shell-specific escaping rules\n\tinterface ShellEscapeConfig {\n\t\t// How to handle paths with both single and double quotes\n\t\tbothQuotes: (path: string) => string;\n\t\t// How to handle paths with only single quotes\n\t\tsingleQuotes: (path: string) => string;\n\t\t// How to handle paths with no single quotes (may have double quotes)\n\t\tnoSingleQuotes: (path: string) => string;\n\t}\n\n\tlet escapeConfig: ShellEscapeConfig;\n\tswitch (shellType) {\n\t\tcase PosixShellType.Bash:\n\t\tcase PosixShellType.Sh:\n\t\tcase PosixShellType.Zsh:\n\t\tcase WindowsShellType.GitBash:\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `$'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t\tcase PosixShellType.Fish:\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `\"${path.replace(/\"/g, '\\\\\"')}\"`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t\tcase GeneralShellType.PowerShell:\n\t\t\t// PowerShell should be handled separately in preparePathForShell\n\t\t\t// but if we get here, use PowerShell escaping\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `\"${path.replace(/\"/g, '`\"')}\"`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\'\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to POSIX shell escaping for unknown shells\n\t\t\tescapeConfig = {\n\t\t\t\tbothQuotes: (path) => `$'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tsingleQuotes: (path) => `'${path.replace(/'/g, '\\\\\\'')}'`,\n\t\t\t\tnoSingleQuotes: (path) => `'${path}'`\n\t\t\t};\n\t\t\tbreak;\n\t}\n\n\t// Remove dangerous characters except single and double quotes, which we'll escape properly\n\tconst bannedChars = /[\\`\\$\\|\\&\\>\\~\\#\\!\\^\\*\\;\\<]/g;\n\tnewPath = newPath.replace(bannedChars, '');\n\n\t// Apply shell-specific escaping based on quote content\n\tif (newPath.includes('\\'') && newPath.includes('\"')) {\n\t\treturn escapeConfig.bothQuotes(newPath);\n\t} else if (newPath.includes('\\'')) {\n\t\treturn escapeConfig.singleQuotes(newPath);\n\t} else {\n\t\treturn escapeConfig.noSingleQuotes(newPath);\n\t}\n}\n\n/**\n * Collapses the user's home directory into `~` if it exists within the path, this gives a shorter\n * path that is more suitable within the context of a terminal.\n */\nexport function collapseTildePath(path: string | undefined, userHome: string | undefined, separator: string): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\tif (!userHome) {\n\t\treturn path;\n\t}\n\t// Trim the trailing separator from the end if it exists\n\tif (userHome.match(/[\\/\\\\]$/)) {\n\t\tuserHome = userHome.slice(0, userHome.length - 1);\n\t}\n\tconst normalizedPath = path.replace(/\\\\/g, '/').toLowerCase();\n\tconst normalizedUserHome = userHome.replace(/\\\\/g, '/').toLowerCase();\n\tif (!normalizedPath.includes(normalizedUserHome)) {\n\t\treturn path;\n\t}\n\treturn `~${separator}${path.slice(userHome.length + 1)}`;\n}\n\n/**\n * Sanitizes a cwd string, removing any wrapping quotes and making the Windows drive letter\n * uppercase.\n * @param cwd The directory to sanitize.\n */\nexport function sanitizeCwd(cwd: string): string {\n\t// Sanity check that the cwd is not wrapped in quotes (see #160109)\n\tif (cwd.match(/^['\"].*['\"]$/)) {\n\t\tcwd = cwd.substring(1, cwd.length - 1);\n\t}\n\t// Make the drive letter uppercase on Windows (see #9448)\n\tif (OS === OperatingSystem.Windows && cwd && cwd[1] === ':') {\n\t\treturn cwd[0].toUpperCase() + cwd.substring(1);\n\t}\n\treturn cwd;\n}\n\n/**\n * Determines whether the given shell launch config should use the environment variable collection.\n * @param slc The shell launch config to check.\n */\nexport function shouldUseEnvironmentVariableCollection(slc: IShellLaunchConfig): boolean {\n\treturn !slc.strictEnv;\n}\n"]}