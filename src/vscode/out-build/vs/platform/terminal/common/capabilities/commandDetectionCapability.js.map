{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/capabilities/commandDetectionCapability.ts","vs/platform/terminal/common/capabilities/commandDetectionCapability.ts"],"names":[],"mappings":"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","file":"commandDetectionCapability.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { debounce } from '../../../../base/common/decorators.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, MandatoryMutableDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../log/common/log.js';\nimport { isString } from '../../../../base/common/types.js';\nimport { CommandInvalidationReason, ICommandDetectionCapability, ICommandInvalidationRequest, IHandleCommandOptions, ISerializedCommandDetectionCapability, ISerializedTerminalCommand, ITerminalCommand, TerminalCapability } from './capabilities.js';\nimport { ITerminalOutputMatcher } from '../terminal.js';\nimport { ICurrentPartialCommand, isFullTerminalCommand, PartialTerminalCommand, TerminalCommand } from './commandDetection/terminalCommand.js';\nimport { PromptInputModel, type IPromptInputModel } from './commandDetection/promptInputModel.js';\nimport type { IBuffer, IDisposable, IMarker, Terminal } from '@xterm/headless';\n\ninterface ITerminalDimensions {\n\tcols: number;\n\trows: number;\n}\n\nexport class CommandDetectionCapability extends Disposable implements ICommandDetectionCapability {\n\treadonly type = TerminalCapability.CommandDetection;\n\n\tprivate readonly _promptInputModel: PromptInputModel;\n\tget promptInputModel(): IPromptInputModel { return this._promptInputModel; }\n\n\tprotected _commands: TerminalCommand[] = [];\n\tprivate _cwd: string | undefined;\n\tprivate _promptTerminator: string | undefined;\n\tprivate _currentCommand: PartialTerminalCommand;\n\tprivate _commandMarkers: IMarker[] = [];\n\tprivate _dimensions: ITerminalDimensions;\n\tprivate __isCommandStorageDisabled: boolean = false;\n\tprivate _handleCommandStartOptions?: IHandleCommandOptions;\n\tprivate _hasRichCommandDetection: boolean = false;\n\tget hasRichCommandDetection() { return this._hasRichCommandDetection; }\n\tprivate _nextCommandId: { command: string; commandId: string | undefined } | undefined;\n\n\tprivate _ptyHeuristicsHooks: ICommandDetectionHeuristicsHooks;\n\tprivate readonly _ptyHeuristics: MandatoryMutableDisposable<IPtyHeuristics>;\n\n\tget commands(): readonly TerminalCommand[] { return this._commands; }\n\tget executingCommand(): string | undefined { return this._currentCommand.command; }\n\tget executingCommandObject(): ITerminalCommand | undefined {\n\t\tif (this._currentCommand.commandStartMarker) {\n\t\t\t// HACK: This does a lot more than the consumer of the API needs. It's also a little\n\t\t\t//       misleading since it's not promoting the current command yet.\n\t\t\treturn this._currentCommand.promoteToFullCommand(this._cwd, undefined, this._handleCommandStartOptions?.ignoreCommandLine ?? false, undefined);\n\t\t}\n\t\treturn undefined;\n\t}\n\tget executingCommandConfidence(): 'low' | 'medium' | 'high' | undefined {\n\t\tconst casted = this._currentCommand as PartialTerminalCommand | ITerminalCommand;\n\t\treturn isFullTerminalCommand(casted) ? casted.commandLineConfidence : undefined;\n\t}\n\tget currentCommand(): ICurrentPartialCommand {\n\t\treturn this._currentCommand;\n\t}\n\tget cwd(): string | undefined { return this._cwd; }\n\tget promptTerminator(): string | undefined { return this._promptTerminator; }\n\n\tprivate readonly _onCommandStarted = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandStarted = this._onCommandStarted.event;\n\tprivate readonly _onCommandStartChanged = this._register(new Emitter<void>());\n\treadonly onCommandStartChanged = this._onCommandStartChanged.event;\n\tprivate readonly _onBeforeCommandFinished = this._register(new Emitter<ITerminalCommand>());\n\treadonly onBeforeCommandFinished = this._onBeforeCommandFinished.event;\n\tprivate readonly _onCommandFinished = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandFinished = this._onCommandFinished.event;\n\tprivate readonly _onCommandExecuted = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandExecuted = this._onCommandExecuted.event;\n\tprivate readonly _onCommandInvalidated = this._register(new Emitter<ITerminalCommand[]>());\n\treadonly onCommandInvalidated = this._onCommandInvalidated.event;\n\tprivate readonly _onCurrentCommandInvalidated = this._register(new Emitter<ICommandInvalidationRequest>());\n\treadonly onCurrentCommandInvalidated = this._onCurrentCommandInvalidated.event;\n\tprivate readonly _onSetRichCommandDetection = this._register(new Emitter<boolean>());\n\treadonly onSetRichCommandDetection = this._onSetRichCommandDetection.event;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._currentCommand = new PartialTerminalCommand(this._terminal);\n\t\tthis._promptInputModel = this._register(new PromptInputModel(this._terminal, this.onCommandStarted, this.onCommandStartChanged, this.onCommandExecuted, this._logService));\n\n\t\t// Pull command line from the buffer if it was not set explicitly\n\t\tthis._register(this.onCommandExecuted(command => {\n\t\t\tif (command.commandLineConfidence !== 'high') {\n\t\t\t\t// HACK: onCommandExecuted actually fired with PartialTerminalCommand\n\t\t\t\tconst typedCommand = (command as ITerminalCommand | PartialTerminalCommand);\n\t\t\t\tcommand.command = typedCommand.extractCommandLine();\n\t\t\t\tcommand.commandLineConfidence = 'low';\n\n\t\t\t\t// ITerminalCommand\n\t\t\t\tif (isFullTerminalCommand(typedCommand)) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.marker && typedCommand.executedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.startX !== undefined && typedCommand.startX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// PartialTerminalCommand\n\t\t\t\telse {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.commandStartMarker && typedCommand.commandExecutedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.commandStartX !== undefined && typedCommand.commandStartX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._terminal.parser.registerCsiHandler({ final: 'J' }, params => {\n\t\t\tif (params.length >= 1 && params[0] === 2) {\n\t\t\t\tif (!this._terminal.options.scrollOnEraseInDisplay) {\n\t\t\t\t\tthis._clearCommandsInViewport();\n\t\t\t\t}\n\t\t\t\tthis._currentCommand.wasCleared = true;\n\t\t\t}\n\t\t\t// We don't want to override xterm.js' default behavior, just augment it\n\t\t\treturn false;\n\t\t}));\n\n\t\t// Set up platform-specific behaviors\n\t\tconst that = this;\n\t\tthis._ptyHeuristicsHooks = new class implements ICommandDetectionHeuristicsHooks {\n\t\t\tget onCurrentCommandInvalidatedEmitter() { return that._onCurrentCommandInvalidated; }\n\t\t\tget onCommandStartedEmitter() { return that._onCommandStarted; }\n\t\t\tget onCommandExecutedEmitter() { return that._onCommandExecuted; }\n\t\t\tget dimensions() { return that._dimensions; }\n\t\t\tget isCommandStorageDisabled() { return that.__isCommandStorageDisabled; }\n\t\t\tget commandMarkers() { return that._commandMarkers; }\n\t\t\tset commandMarkers(value) { that._commandMarkers = value; }\n\t\t\tget clearCommandsInViewport() { return that._clearCommandsInViewport.bind(that); }\n\t\t};\n\t\tthis._ptyHeuristics = this._register(new MandatoryMutableDisposable(new UnixPtyHeuristics(this._terminal, this, this._ptyHeuristicsHooks, this._logService)));\n\n\t\tthis._dimensions = {\n\t\t\tcols: this._terminal.cols,\n\t\t\trows: this._terminal.rows\n\t\t};\n\t\tthis._register(this._terminal.onResize(e => this._handleResize(e)));\n\t\tthis._register(this._terminal.onCursorMove(() => this._handleCursorMove()));\n\t}\n\n\tprivate _handleResize(e: { cols: number; rows: number }) {\n\t\tthis._ptyHeuristics.value.preHandleResize?.(e);\n\t\tthis._dimensions.cols = e.cols;\n\t\tthis._dimensions.rows = e.rows;\n\t}\n\n\t@debounce(500)\n\tprivate _handleCursorMove() {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\t// Early versions of conpty do not have real support for an alt buffer, in addition certain\n\t\t// commands such as tsc watch will write to the top of the normal buffer. The following\n\t\t// checks when the cursor has moved while the normal buffer is empty and if it is above the\n\t\t// current command, all decorations within the viewport will be invalidated.\n\t\t//\n\t\t// This function is debounced so that the cursor is only checked when it is stable so\n\t\t// conpty's screen reprinting will not trigger decoration clearing.\n\t\t//\n\t\t// This is mostly a workaround for Windows but applies to all OS' because of the tsc watch\n\t\t// case.\n\t\tif (this._terminal.buffer.active === this._terminal.buffer.normal && this._currentCommand.commandStartMarker) {\n\t\t\tif (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY < this._currentCommand.commandStartMarker.line) {\n\t\t\t\tthis._clearCommandsInViewport();\n\t\t\t\tthis._currentCommand.isInvalid = true;\n\t\t\t\tthis._onCurrentCommandInvalidated.fire({ reason: CommandInvalidationReason.Windows });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _clearCommandsInViewport(): void {\n\t\t// Find the number of commands on the tail end of the array that are within the viewport\n\t\tlet count = 0;\n\t\tfor (let i = this._commands.length - 1; i >= 0; i--) {\n\t\t\tconst line = this._commands[i].marker?.line;\n\t\t\tif (line && line < this._terminal.buffer.active.baseY) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\t// Remove them\n\t\tif (count > 0) {\n\t\t\tthis._onCommandInvalidated.fire(this._commands.splice(this._commands.length - count, count));\n\t\t}\n\t}\n\n\tsetContinuationPrompt(value: string): void {\n\t\tthis._promptInputModel.setContinuationPrompt(value);\n\t}\n\n\t// TODO: Simplify this, can everything work off the last line?\n\tsetPromptTerminator(promptTerminator: string, lastPromptLine: string) {\n\t\tthis._logService.debug('CommandDetectionCapability#setPromptTerminator', promptTerminator);\n\t\tthis._promptTerminator = promptTerminator;\n\t\tthis._promptInputModel.setLastPromptLine(lastPromptLine);\n\t}\n\n\tsetCwd(value: string) {\n\t\tthis._cwd = value;\n\t}\n\n\tsetIsWindowsPty(value: boolean) {\n\t\tif (value && !(this._ptyHeuristics.value instanceof WindowsPtyHeuristics)) {\n\t\t\tconst that = this;\n\t\t\tthis._ptyHeuristics.value = new WindowsPtyHeuristics(\n\t\t\t\tthis._terminal,\n\t\t\t\tthis,\n\t\t\t\tnew class {\n\t\t\t\t\tget onCurrentCommandInvalidatedEmitter() { return that._onCurrentCommandInvalidated; }\n\t\t\t\t\tget onCommandStartedEmitter() { return that._onCommandStarted; }\n\t\t\t\t\tget onCommandExecutedEmitter() { return that._onCommandExecuted; }\n\t\t\t\t\tget dimensions() { return that._dimensions; }\n\t\t\t\t\tget isCommandStorageDisabled() { return that.__isCommandStorageDisabled; }\n\t\t\t\t\tget commandMarkers() { return that._commandMarkers; }\n\t\t\t\t\tset commandMarkers(value) { that._commandMarkers = value; }\n\t\t\t\t\tget clearCommandsInViewport() { return that._clearCommandsInViewport.bind(that); }\n\t\t\t\t},\n\t\t\t\tthis._logService\n\t\t\t);\n\t\t} else if (!value && !(this._ptyHeuristics.value instanceof UnixPtyHeuristics)) {\n\t\t\tthis._ptyHeuristics.value = new UnixPtyHeuristics(this._terminal, this, this._ptyHeuristicsHooks, this._logService);\n\t\t}\n\t}\n\n\tsetHasRichCommandDetection(value: boolean): void {\n\t\tthis._hasRichCommandDetection = value;\n\t\tthis._onSetRichCommandDetection.fire(value);\n\t}\n\n\tsetIsCommandStorageDisabled(): void {\n\t\tthis.__isCommandStorageDisabled = true;\n\t}\n\n\tgetCommandForLine(line: number): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (this._currentCommand.promptStartMarker && line >= this._currentCommand.promptStartMarker?.line) {\n\t\t\treturn this._currentCommand;\n\t\t}\n\n\t\t// No commands\n\t\tif (this._commands.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Line is before any registered commands\n\t\tif ((this._commands[0].promptStartMarker ?? this._commands[0].marker!).line > line) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Iterate backwards through commands to find the right one\n\t\tfor (let i = this.commands.length - 1; i >= 0; i--) {\n\t\t\tif ((this.commands[i].promptStartMarker ?? this.commands[i].marker!).line <= line) {\n\t\t\t\treturn this.commands[i];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetCwdForLine(line: number): string | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (this._currentCommand.promptStartMarker && line >= this._currentCommand.promptStartMarker?.line) {\n\t\t\treturn this._cwd;\n\t\t}\n\n\t\tconst command = this.getCommandForLine(line);\n\t\tif (command && isFullTerminalCommand(command)) {\n\t\t\treturn command.cwd;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\thandlePromptStart(options?: IHandleCommandOptions): void {\n\t\t// Adjust the last command's finished marker when needed. The standard position for the\n\t\t// finished marker `D` to appear is at the same position as the following prompt started\n\t\t// `A`. Only do this when it would not extend past the current cursor position.\n\t\tconst lastCommand = this.commands.at(-1);\n\t\tif (\n\t\t\tlastCommand?.endMarker &&\n\t\t\tlastCommand?.executedMarker &&\n\t\t\tlastCommand.endMarker.line === lastCommand.executedMarker.line &&\n\t\t\tlastCommand.executedMarker.line < this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY\n\t\t) {\n\t\t\tthis._logService.debug('CommandDetectionCapability#handlePromptStart adjusted commandFinished', `${lastCommand.endMarker.line} -> ${lastCommand.executedMarker.line + 1}`);\n\t\t\tlastCommand.endMarker = cloneMarker(this._terminal, lastCommand.executedMarker, 1);\n\t\t}\n\n\t\tthis._currentCommand.promptStartMarker = (\n\t\t\toptions?.marker ||\n\t\t\t// Generally the prompt start should happen at the exact place the endmarker happened.\n\t\t\t// However, after ctrl+l is used to clear the display, we want to ensure the actual\n\t\t\t// prompt start marker position is used. This is mostly a workaround for Windows but we\n\t\t\t// apply it generally.\n\t\t\t(!this._currentCommand.wasCleared && lastCommand?.endMarker\n\t\t\t\t? cloneMarker(this._terminal, lastCommand.endMarker)\n\t\t\t\t: this._terminal.registerMarker(0))\n\t\t);\n\t\tthis._currentCommand.wasCleared = false;\n\t}\n\n\thandleContinuationStart(): void {\n\t\tthis._currentCommand.currentContinuationMarker = this._terminal.registerMarker(0);\n\t\tthis._logService.debug('CommandDetectionCapability#handleContinuationStart', this._currentCommand.currentContinuationMarker);\n\t}\n\n\thandleContinuationEnd(): void {\n\t\tif (!this._currentCommand.currentContinuationMarker) {\n\t\t\tthis._logService.warn('CommandDetectionCapability#handleContinuationEnd Received continuation end without start');\n\t\t\treturn;\n\t\t}\n\t\tif (!this._currentCommand.continuations) {\n\t\t\tthis._currentCommand.continuations = [];\n\t\t}\n\t\tthis._currentCommand.continuations.push({\n\t\t\tmarker: this._currentCommand.currentContinuationMarker,\n\t\t\tend: this._terminal.buffer.active.cursorX\n\t\t});\n\t\tthis._currentCommand.currentContinuationMarker = undefined;\n\t\tthis._logService.debug('CommandDetectionCapability#handleContinuationEnd', this._currentCommand.continuations[this._currentCommand.continuations.length - 1]);\n\t}\n\n\thandleRightPromptStart(): void {\n\t\tthis._currentCommand.commandRightPromptStartX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleRightPromptStart', this._currentCommand.commandRightPromptStartX);\n\t}\n\n\thandleRightPromptEnd(): void {\n\t\tthis._currentCommand.commandRightPromptEndX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleRightPromptEnd', this._currentCommand.commandRightPromptEndX);\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions): void {\n\t\tthis._handleCommandStartOptions = options;\n\t\tthis._currentCommand.cwd = this._cwd;\n\t\t// Only update the column if the line has already been set\n\t\tthis._currentCommand.commandStartMarker = options?.marker || this._currentCommand.commandStartMarker;\n\t\tif (this._currentCommand.commandStartMarker?.line === this._terminal.buffer.active.cursorY) {\n\t\t\tthis._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\t\t\tthis._onCommandStartChanged.fire();\n\t\t\tthis._logService.debug('CommandDetectionCapability#handleCommandStart', this._currentCommand.commandStartX, this._currentCommand.commandStartMarker?.line);\n\t\t\treturn;\n\t\t}\n\t\tthis._ptyHeuristics.value.handleCommandStart(options);\n\t}\n\n\t/**\n\t * Sets the command ID to use for the next command that starts.\n\t * This is useful when you want to pre-assign an ID before the shell sends the command start sequence.\n\t */\n\tsetNextCommandId(command: string, commandId: string): void {\n\t\tthis._nextCommandId = { command, commandId };\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions): void {\n\t\tthis._ensureCurrentCommandId(this._currentCommand.command ?? this._currentCommand.extractCommandLine());\n\t\tthis._ptyHeuristics.value.handleCommandExecuted(options);\n\t\tthis._currentCommand.markExecutedTime();\n\t}\n\n\thandleCommandFinished(exitCode: number | undefined, options?: IHandleCommandOptions): void {\n\t\t// Command executed may not have happened yet, if not handle it now so the expected events\n\t\t// properly propagate. This may cause the output to show up in the computed command line,\n\t\t// but the command line confidence will be low in the extension host for example and\n\t\t// therefore cannot be trusted anyway.\n\t\tif (!this._currentCommand.commandExecutedMarker) {\n\t\t\tthis.handleCommandExecuted();\n\t\t}\n\t\tthis._currentCommand.markFinishedTime();\n\t\tthis._ptyHeuristics.value.preHandleCommandFinished?.();\n\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandFinished', this._terminal.buffer.active.cursorX, options?.marker?.line, this._currentCommand.command, this._currentCommand);\n\n\t\t// HACK: Handle a special case on some versions of bash where identical commands get merged\n\t\t// in the output of `history`, this detects that case and sets the exit code to the last\n\t\t// command's exit code. This covered the majority of cases but will fail if the same command\n\t\t// runs with a different exit code, that will need a more robust fix where we send the\n\t\t// command ID and exit code over to the capability to adjust there.\n\t\tif (exitCode === undefined) {\n\t\t\tconst lastCommand = this.commands.length > 0 ? this.commands[this.commands.length - 1] : undefined;\n\t\t\tif (this._currentCommand.command && this._currentCommand.command.length > 0 && lastCommand?.command === this._currentCommand.command) {\n\t\t\t\texitCode = lastCommand.exitCode;\n\t\t\t}\n\t\t}\n\n\t\tif (this._currentCommand.commandStartMarker === undefined || !this._terminal.buffer.active) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentCommand.commandFinishedMarker = options?.marker || this._terminal.registerMarker(0);\n\n\t\tthis._ptyHeuristics.value.postHandleCommandFinished?.();\n\n\t\tconst newCommand = this._currentCommand.promoteToFullCommand(this._cwd, exitCode, this._handleCommandStartOptions?.ignoreCommandLine ?? false, options?.markProperties);\n\n\t\tif (newCommand) {\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._onBeforeCommandFinished.fire(newCommand);\n\t\t\t// NOTE: onCommandFinished used to not fire if the command was invalid, but this causes\n\t\t\t// problems especially with the associated execution event never firing in the extension\n\t\t\t// API. See https://github.com/microsoft/vscode/issues/252489\n\t\t\tthis._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);\n\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t}\n\t\t// Create new command for next execution\n\t\tthis._currentCommand = new PartialTerminalCommand(this._terminal);\n\t\tthis._handleCommandStartOptions = undefined;\n\t}\n\n\tprivate _ensureCurrentCommandId(commandLine: string | undefined): void {\n\t\tif (this._nextCommandId?.commandId && isString(commandLine) && commandLine.trim() === this._nextCommandId.command.trim()) {\n\t\t\tif (this._currentCommand.id !== this._nextCommandId.commandId) {\n\t\t\t\tthis._currentCommand.id = this._nextCommandId.commandId;\n\t\t\t}\n\t\t\tthis._nextCommandId = undefined;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsetCommandLine(commandLine: string, isTrusted: boolean) {\n\t\tthis._logService.debug('CommandDetectionCapability#setCommandLine', commandLine, isTrusted);\n\t\tthis._currentCommand.command = commandLine;\n\t\tthis._currentCommand.commandLineConfidence = 'high';\n\t\tthis._currentCommand.isTrusted = isTrusted;\n\n\t\tif (isTrusted) {\n\t\t\tthis._promptInputModel.setConfidentCommandLine(commandLine);\n\t\t}\n\t}\n\n\tserialize(): ISerializedCommandDetectionCapability {\n\t\tconst commands: ISerializedTerminalCommand[] = this.commands.map(e => e.serialize(this.__isCommandStorageDisabled));\n\t\tconst partialCommand = this._currentCommand.serialize(this._cwd);\n\t\tif (partialCommand) {\n\t\t\tcommands.push(partialCommand);\n\t\t}\n\t\treturn {\n\t\t\tisWindowsPty: this._ptyHeuristics.value instanceof WindowsPtyHeuristics,\n\t\t\thasRichCommandDetection: this._hasRichCommandDetection,\n\t\t\tcommands,\n\t\t\tpromptInputModel: this._promptInputModel.serialize(),\n\t\t};\n\t}\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void {\n\t\tif (serialized.isWindowsPty) {\n\t\t\tthis.setIsWindowsPty(serialized.isWindowsPty);\n\t\t}\n\t\tif (serialized.hasRichCommandDetection) {\n\t\t\tthis.setHasRichCommandDetection(serialized.hasRichCommandDetection);\n\t\t}\n\t\tconst buffer = this._terminal.buffer.normal;\n\t\tfor (const e of serialized.commands) {\n\t\t\t// Partial command\n\t\t\tif (!e.endLine) {\n\t\t\t\t// Check for invalid command\n\t\t\t\tconst marker = e.startLine !== undefined ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tif (!marker) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._currentCommand.commandStartMarker = e.startLine !== undefined ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tthis._currentCommand.commandStartX = e.startX;\n\t\t\t\tthis._currentCommand.promptStartMarker = e.promptStartLine !== undefined ? this._terminal.registerMarker(e.promptStartLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tthis._cwd = e.cwd;\n\t\t\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\t\t\tthis._onCommandStarted.fire({ marker } as ITerminalCommand);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Full command\n\t\t\tconst newCommand = TerminalCommand.deserialize(this._terminal, e, this.__isCommandStorageDisabled);\n\t\t\tif (!newCommand) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);\n\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t}\n\t\tif (serialized.promptInputModel) {\n\t\t\tthis._promptInputModel.deserialize(serialized.promptInputModel);\n\t\t}\n\t}\n}\n\n/**\n * Additional hooks to private methods on {@link CommandDetectionCapability} that are needed by the\n * heuristics objects.\n */\ninterface ICommandDetectionHeuristicsHooks {\n\treadonly onCurrentCommandInvalidatedEmitter: Emitter<ICommandInvalidationRequest>;\n\treadonly onCommandStartedEmitter: Emitter<ITerminalCommand>;\n\treadonly onCommandExecutedEmitter: Emitter<ITerminalCommand>;\n\treadonly dimensions: ITerminalDimensions;\n\treadonly isCommandStorageDisabled: boolean;\n\n\tcommandMarkers: IMarker[];\n\n\tclearCommandsInViewport(): void;\n}\n\ntype IPtyHeuristics = (\n\t// All optional methods\n\tPartial<UnixPtyHeuristics> & Partial<WindowsPtyHeuristics> &\n\t// All common methods\n\t(UnixPtyHeuristics | WindowsPtyHeuristics) &\n\tIDisposable\n);\n\n/**\n * Non-Windows-specific behavior.\n */\nclass UnixPtyHeuristics extends Disposable {\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\tprivate readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions) {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\t\tcurrentCommand.commandStartMarker = options?.marker || this._terminal.registerMarker(0);\n\n\t\t// Clear executed as it must happen after command start\n\t\tcurrentCommand.commandExecutedMarker?.dispose();\n\t\tcurrentCommand.commandExecutedMarker = undefined;\n\t\tcurrentCommand.commandExecutedX = undefined;\n\t\tfor (const m of this._hooks.commandMarkers) {\n\t\t\tm.dispose();\n\t\t}\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tthis._hooks.onCommandStartedEmitter.fire({ marker: options?.marker || currentCommand.commandStartMarker, markProperties: options?.markProperties } as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandStart', currentCommand.commandStartX, currentCommand.commandStartMarker?.line);\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions) {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandExecutedMarker = options?.marker || this._terminal.registerMarker(0);\n\t\tcurrentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandExecuted', currentCommand.commandExecutedX, currentCommand.commandExecutedMarker?.line);\n\n\t\t// Sanity check optional props\n\t\tif (!currentCommand.commandStartMarker || !currentCommand.commandExecutedMarker || currentCommand.commandStartX === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tcurrentCommand.command = this._capability.promptInputModel.ghostTextIndex > -1 ? this._capability.promptInputModel.value.substring(0, this._capability.promptInputModel.ghostTextIndex) : this._capability.promptInputModel.value;\n\t\tthis._hooks.onCommandExecutedEmitter.fire(currentCommand as ITerminalCommand);\n\t}\n}\n\nconst enum AdjustCommandStartMarkerConstants {\n\tMaxCheckLineCount = 10,\n\tInterval = 20,\n\tMaximumPollCount = 10,\n}\n\n/**\n * An object that integrated with and decorates the command detection capability to add heuristics\n * that adjust various markers to work better with Windows and ConPTY. This isn't depended upon the\n * frontend OS, or even the backend OS, but the `IsWindows` property which technically a non-Windows\n * client can emit (for example in tests).\n */\nclass WindowsPtyHeuristics extends Disposable {\n\n\tprivate readonly _onCursorMoveListener = this._register(new MutableDisposable());\n\n\tprivate _tryAdjustCommandStartMarkerScheduler?: RunOnceScheduler;\n\tprivate _tryAdjustCommandStartMarkerScannedLineCount: number = 0;\n\tprivate _tryAdjustCommandStartMarkerPollCount: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this._capability.onBeforeCommandFinished(command => {\n\t\t\t// For older Windows backends we cannot listen to CSI J, instead we assume running clear\n\t\t\t// or cls will clear all commands in the viewport. This is not perfect but it's right\n\t\t\t// most of the time.\n\t\t\tif (command.command.trim().toLowerCase() === 'clear' || command.command.trim().toLowerCase() === 'cls') {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.cancel();\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t\t\tthis._hooks.clearCommandsInViewport();\n\t\t\t\tthis._capability.currentCommand.isInvalid = true;\n\t\t\t\tthis._hooks.onCurrentCommandInvalidatedEmitter.fire({ reason: CommandInvalidationReason.Windows });\n\t\t\t}\n\t\t}));\n\t}\n\n\tpreHandleResize(e: { cols: number; rows: number }) {\n\t\t// Resize behavior is different under conpty; instead of bringing parts of the scrollback\n\t\t// back into the viewport, new lines are inserted at the bottom (ie. the same behavior as if\n\t\t// there was no scrollback).\n\t\t//\n\t\t// On resize this workaround will wait for a conpty reprint to occur by waiting for the\n\t\t// cursor to move, it will then calculate the number of lines that the commands within the\n\t\t// viewport _may have_ shifted. After verifying the content of the current line is\n\t\t// incorrect, the line after shifting is checked and if that matches delete events are fired\n\t\t// on the xterm.js buffer to move the markers.\n\t\t//\n\t\t// While a bit hacky, this approach is quite safe and seems to work great at least for pwsh.\n\t\tconst baseY = this._terminal.buffer.active.baseY;\n\t\tconst rowsDifference = e.rows - this._hooks.dimensions.rows;\n\t\t// Only do when rows increase, do in the next frame as this needs to happen after\n\t\t// conpty reprints the screen\n\t\tif (rowsDifference > 0) {\n\t\t\tthis._waitForCursorMove().then(() => {\n\t\t\t\t// Calculate the number of lines the content may have shifted, this will max out at\n\t\t\t\t// scrollback count since the standard behavior will be used then\n\t\t\t\tconst potentialShiftedLineCount = Math.min(rowsDifference, baseY);\n\t\t\t\t// For each command within the viewport, assume commands are in the correct order\n\t\t\t\tfor (let i = this._capability.commands.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst command = this._capability.commands[i];\n\t\t\t\t\tif (!command.marker || command.marker.line < baseY || command.commandStartLineContent === undefined) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst line = this._terminal.buffer.active.getLine(command.marker.line);\n\t\t\t\t\tif (!line || line.translateToString(true) === command.commandStartLineContent) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst shiftedY = command.marker.line - potentialShiftedLineCount;\n\t\t\t\t\tconst shiftedLine = this._terminal.buffer.active.getLine(shiftedY);\n\t\t\t\t\tif (shiftedLine?.translateToString(true) !== command.commandStartLineContent) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// HACK: xterm.js doesn't expose this by design as it's an internal core\n\t\t\t\t\t// function an embedder could easily do damage with. Additionally, this\n\t\t\t\t\t// can't really be upstreamed since the event relies on shell integration to\n\t\t\t\t\t// verify the shifting is necessary.\n\t\t\t\t\tinterface IXtermWithCore extends Terminal {\n\t\t\t\t\t\t_core: {\n\t\t\t\t\t\t\t_bufferService: {\n\t\t\t\t\t\t\t\tbuffer: {\n\t\t\t\t\t\t\t\t\tlines: {\n\t\t\t\t\t\t\t\t\t\tonDeleteEmitter: {\n\t\t\t\t\t\t\t\t\t\t\tfire(data: { index: number; amount: number }): void;\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t(this._terminal as IXtermWithCore)._core._bufferService.buffer.lines.onDeleteEmitter.fire({\n\t\t\t\t\t\tindex: this._terminal.buffer.active.baseY,\n\t\t\t\t\t\tamount: potentialShiftedLineCount\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\thandleCommandStart() {\n\t\tthis._capability.currentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\n\t\t// On Windows track all cursor movements after the command start sequence\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\tconst initialCommandStartMarker = this._capability.currentCommand.commandStartMarker = (\n\t\t\tthis._capability.currentCommand.promptStartMarker\n\t\t\t\t? cloneMarker(this._terminal, this._capability.currentCommand.promptStartMarker)\n\t\t\t\t: this._terminal.registerMarker(0)\n\t\t)!;\n\t\tthis._capability.currentCommand.commandStartX = 0;\n\n\t\t// DEBUG: Add a decoration for the original unadjusted command start position\n\t\t// if ('registerDecoration' in this._terminal) {\n\t\t// \tconst d = (this._terminal as any).registerDecoration({\n\t\t// \t\tmarker: this._capability.currentCommand.commandStartMarker,\n\t\t// \t\tx: this._capability.currentCommand.commandStartX\n\t\t// \t});\n\t\t// \td?.onRender((e: HTMLElement) => {\n\t\t// \t\te.textContent = 'b';\n\t\t// \t\te.classList.add('xterm-sequence-decoration', 'top', 'right');\n\t\t// \t\te.title = 'Initial command start position';\n\t\t// \t});\n\t\t// }\n\n\t\t// The command started sequence may be printed before the actual prompt is, for example a\n\t\t// multi-line prompt will typically look like this where D, A and B signify the command\n\t\t// finished, prompt started and command started sequences respectively:\n\t\t//\n\t\t//     D/my/cwdB\n\t\t//     > C\n\t\t//\n\t\t// Due to this, it's likely that this will be called before the line has been parsed.\n\t\t// Unfortunately, it is also the case that the actual command start data may not be parsed\n\t\t// by the end of the task either, so a microtask cannot be used.\n\t\t//\n\t\t// The strategy used is to begin polling and scanning downwards for up to the next 5 lines.\n\t\t// If it looks like a prompt is found, the command started location is adjusted. If the\n\t\t// command executed sequences comes in before polling is done, polling is canceled and the\n\t\t// final polling task is executed synchronously.\n\t\tthis._tryAdjustCommandStartMarkerScannedLineCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerPollCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerScheduler = new RunOnceScheduler(() => this._tryAdjustCommandStartMarker(initialCommandStartMarker), AdjustCommandStartMarkerConstants.Interval);\n\t\tthis._tryAdjustCommandStartMarkerScheduler.schedule();\n\n\t\t// TODO: Cache details about polling for the future - eg. if it always fails, stop bothering\n\t}\n\n\tprivate _tryAdjustCommandStartMarker(start: IMarker) {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tconst buffer = this._terminal.buffer.active;\n\t\tlet scannedLineCount = this._tryAdjustCommandStartMarkerScannedLineCount;\n\t\twhile (scannedLineCount < AdjustCommandStartMarkerConstants.MaxCheckLineCount && start.line + scannedLineCount < buffer.baseY + this._terminal.rows) {\n\t\t\tif (this._cursorOnNextLine()) {\n\t\t\t\tconst prompt = this._getWindowsPrompt(start.line + scannedLineCount);\n\t\t\t\tif (prompt) {\n\t\t\t\t\tconst adjustedPrompt = isString(prompt) ? prompt : prompt.prompt;\n\t\t\t\t\tthis._capability.currentCommand.commandStartMarker = this._terminal.registerMarker(0)!;\n\t\t\t\t\tif (!isString(prompt) && prompt.likelySingleLine) {\n\t\t\t\t\t\tthis._logService.debug('CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted promptStart', `${this._capability.currentCommand.promptStartMarker?.line} -> ${this._capability.currentCommand.commandStartMarker.line}`);\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker?.dispose();\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker = cloneMarker(this._terminal, this._capability.currentCommand.commandStartMarker);\n\t\t\t\t\t\t// Adjust the last command if it's not in the same position as the following\n\t\t\t\t\t\t// prompt start marker\n\t\t\t\t\t\tconst lastCommand = this._capability.commands.at(-1);\n\t\t\t\t\t\tif (lastCommand && this._capability.currentCommand.commandStartMarker.line !== lastCommand.endMarker?.line) {\n\t\t\t\t\t\t\tlastCommand.endMarker?.dispose();\n\t\t\t\t\t\t\tlastCommand.endMarker = cloneMarker(this._terminal, this._capability.currentCommand.commandStartMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// use the regex to set the position as it's possible input has occurred\n\t\t\t\t\tthis._capability.currentCommand.commandStartX = adjustedPrompt.length;\n\t\t\t\t\tthis._logService.debug('CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted commandStart', `${start.line} -> ${this._capability.currentCommand.commandStartMarker.line}:${this._capability.currentCommand.commandStartX}`);\n\t\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscannedLineCount++;\n\t\t}\n\t\tif (scannedLineCount < AdjustCommandStartMarkerConstants.MaxCheckLineCount) {\n\t\t\tthis._tryAdjustCommandStartMarkerScannedLineCount = scannedLineCount;\n\t\t\tif (++this._tryAdjustCommandStartMarkerPollCount < AdjustCommandStartMarkerConstants.MaximumPollCount) {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.schedule();\n\t\t\t} else {\n\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t}\n\n\tprivate _flushPendingHandleCommandStartTask() {\n\t\t// Perform final try adjust if necessary\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\t// Max out poll count to ensure it's the last run\n\t\t\tthis._tryAdjustCommandStartMarkerPollCount = AdjustCommandStartMarkerConstants.MaximumPollCount;\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler.flush();\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t}\n\n\t\tif (!this._capability.currentCommand.commandExecutedMarker) {\n\t\t\tthis._onCursorMoveListener.value = this._terminal.onCursorMove(() => {\n\t\t\t\tif (this._hooks.commandMarkers.length === 0 || this._hooks.commandMarkers[this._hooks.commandMarkers.length - 1].line !== this._terminal.buffer.active.cursorY) {\n\t\t\t\t\tconst marker = this._terminal.registerMarker(0);\n\t\t\t\t\tif (marker) {\n\t\t\t\t\t\tthis._hooks.commandMarkers.push(marker);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(this._capability.currentCommand.commandStartMarker.line);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent = line.translateToString(true);\n\t\t\t}\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tthis._hooks.onCommandStartedEmitter.fire({ marker: this._capability.currentCommand.commandStartMarker } as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#_handleCommandStartWindows', this._capability.currentCommand.commandStartX, this._capability.currentCommand.commandStartMarker?.line);\n\t}\n\n\thandleCommandExecuted(options: IHandleCommandOptions | undefined) {\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t\t// Use the gathered cursor move markers to correct the command start and executed markers\n\t\tthis._onCursorMoveListener.clear();\n\t\tthis._evaluateCommandMarkers();\n\t\tthis._capability.currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;\n\t\tthis._hooks.onCommandExecutedEmitter.fire(this._capability.currentCommand as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandExecuted', this._capability.currentCommand.commandExecutedX, this._capability.currentCommand.commandExecutedMarker?.line);\n\t}\n\n\tpreHandleCommandFinished() {\n\t\tif (this._capability.currentCommand.commandExecutedMarker) {\n\t\t\treturn;\n\t\t}\n\t\t// This is done on command finished just in case command executed never happens (for example\n\t\t// PSReadLine tab completion)\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\t// If the command start timeout doesn't happen before command finished, just use the\n\t\t\t// current marker.\n\t\t\tif (!this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._capability.currentCommand.commandStartMarker = this._terminal.registerMarker(0);\n\t\t\t}\n\t\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._hooks.commandMarkers.push(this._capability.currentCommand.commandStartMarker);\n\t\t\t}\n\t\t}\n\t\tthis._evaluateCommandMarkers();\n\t}\n\n\tpostHandleCommandFinished(): void {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tconst commandText = currentCommand.command;\n\t\tconst commandLine = currentCommand.commandStartMarker?.line;\n\t\tconst executedLine = currentCommand.commandExecutedMarker?.line;\n\t\tif (\n\t\t\t!commandText || commandText.length === 0 ||\n\t\t\tcommandLine === undefined || commandLine === -1 ||\n\t\t\texecutedLine === undefined || executedLine === -1\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Scan downwards from the command start line and search for every character in the actual\n\t\t// command line. This may end up matching the wrong characters, but it shouldn't matter at\n\t\t// least in the typical case as the entire command will still get matched.\n\t\tlet current = 0;\n\t\tlet found = false;\n\t\tfor (let i = commandLine; i <= executedLine; i++) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst text = line.translateToString(true);\n\t\t\tfor (let j = 0; j < text.length; j++) {\n\t\t\t\t// Skip whitespace in case it was not actually rendered or could be trimmed from the\n\t\t\t\t// end of the line\n\t\t\t\twhile (commandText.length < current && commandText[current] === ' ') {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Character match\n\t\t\t\tif (text[j] === commandText[current]) {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Full command match\n\t\t\t\tif (current === commandText.length) {\n\t\t\t\t\t// It's ambiguous whether the command executed marker should ideally appear at\n\t\t\t\t\t// the end of the line or at the beginning of the next line. Since it's more\n\t\t\t\t\t// useful for extracting the command at the end of the current line we go with\n\t\t\t\t\t// that.\n\t\t\t\t\tconst wrapsToNextLine = j >= this._terminal.cols - 1;\n\t\t\t\t\tcurrentCommand.commandExecutedMarker = this._terminal.registerMarker(i - (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY) + (wrapsToNextLine ? 1 : 0));\n\t\t\t\t\tcurrentCommand.commandExecutedX = wrapsToNextLine ? 0 : j + 1;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _evaluateCommandMarkers(): void {\n\t\t// On Windows, use the gathered cursor move markers to correct the command start and\n\t\t// executed markers.\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._hooks.commandMarkers = this._hooks.commandMarkers.sort((a, b) => a.line - b.line);\n\t\tthis._capability.currentCommand.commandStartMarker = this._hooks.commandMarkers[0];\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(this._capability.currentCommand.commandStartMarker.line);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent = line.translateToString(true);\n\t\t\t}\n\t\t}\n\t\tthis._capability.currentCommand.commandExecutedMarker = this._hooks.commandMarkers[this._hooks.commandMarkers.length - 1];\n\t\t// Fire this now to prevent issues like #197409\n\t\tthis._hooks.onCommandExecutedEmitter.fire(this._capability.currentCommand as ITerminalCommand);\n\t}\n\n\tprivate _cursorOnNextLine(): boolean {\n\t\tconst lastCommand = this._capability.commands.at(-1);\n\n\t\t// There is only a single command, so this check is unnecessary\n\t\tif (!lastCommand) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst cursorYAbsolute = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY;\n\t\t// If the cursor position is within the last command, we should poll.\n\t\tconst lastCommandYAbsolute = (lastCommand.endMarker ? lastCommand.endMarker.line : lastCommand.marker?.line) ?? -1;\n\t\treturn cursorYAbsolute > lastCommandYAbsolute;\n\t}\n\n\tprivate _waitForCursorMove(): Promise<void> {\n\t\tconst cursorX = this._terminal.buffer.active.cursorX;\n\t\tconst cursorY = this._terminal.buffer.active.cursorY;\n\t\tlet totalDelay = 0;\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tif (cursorX !== this._terminal.buffer.active.cursorX || cursorY !== this._terminal.buffer.active.cursorY) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotalDelay += 10;\n\t\t\t\tif (totalDelay > 1000) {\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}, 10);\n\t\t});\n\t}\n\n\tprivate _getWindowsPrompt(y: number = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY): string | { prompt: string; likelySingleLine: true } | undefined {\n\t\tconst line = this._terminal.buffer.active.getLine(y);\n\t\tif (!line) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineText = line.translateToString(true);\n\t\tif (!lineText) {\n\t\t\treturn;\n\t\t}\n\n\t\t// PowerShell\n\t\tconst pwshPrompt = lineText.match(/(?<prompt>(\\(.+\\)\\s)?(?:PS.+>\\s?))/)?.groups?.prompt;\n\t\tif (pwshPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(pwshPrompt, lineText, '>');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn {\n\t\t\t\t\tprompt: adjustedPrompt,\n\t\t\t\t\tlikelySingleLine: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Custom prompts like starship end in the common \\u276f character\n\t\tconst customPrompt = lineText.match(/.*\\u276f(?=[^\\u276f]*$)/g)?.[0];\n\t\tif (customPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(customPrompt, lineText, '\\u276f');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Bash Prompt\n\t\tconst bashPrompt = lineText.match(/^(?<prompt>\\$)/)?.groups?.prompt;\n\t\tif (bashPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(bashPrompt, lineText, '$');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Python Prompt\n\t\tconst pythonPrompt = lineText.match(/^(?<prompt>>>> )/g)?.groups?.prompt;\n\t\tif (pythonPrompt) {\n\t\t\treturn {\n\t\t\t\tprompt: pythonPrompt,\n\t\t\t\tlikelySingleLine: true\n\t\t\t};\n\t\t}\n\n\t\t// Dynamic prompt detection\n\t\tif (this._capability.promptTerminator && (lineText === this._capability.promptTerminator || lineText.trim().endsWith(this._capability.promptTerminator))) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(lineText, lineText, this._capability.promptTerminator);\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Command Prompt\n\t\tconst cmdMatch = lineText.match(/^(?<prompt>(\\(.+\\)\\s)?(?:[A-Z]:\\\\.*>))/);\n\t\treturn cmdMatch?.groups?.prompt ? {\n\t\t\tprompt: cmdMatch.groups.prompt,\n\t\t\tlikelySingleLine: true\n\t\t} : undefined;\n\t}\n\n\tprivate _adjustPrompt(prompt: string | undefined, lineText: string, char: string): string | undefined {\n\t\tif (!prompt) {\n\t\t\treturn;\n\t\t}\n\t\t// Conpty may not 'render' the space at the end of the prompt\n\t\tif (lineText === prompt && prompt.endsWith(char)) {\n\t\t\tprompt += ' ';\n\t\t}\n\t\treturn prompt;\n\t}\n}\n\nexport function getLinesForCommand(buffer: IBuffer, command: ITerminalCommand, cols: number, outputMatcher?: ITerminalOutputMatcher): string[] | undefined {\n\tif (!outputMatcher) {\n\t\treturn undefined;\n\t}\n\tconst executedMarker = command.executedMarker;\n\tconst endMarker = command.endMarker;\n\tif (!executedMarker || !endMarker) {\n\t\treturn undefined;\n\t}\n\tconst startLine = executedMarker.line;\n\tconst endLine = endMarker.line;\n\n\tconst linesToCheck = outputMatcher.length;\n\tconst lines: string[] = [];\n\tif (outputMatcher.anchor === 'bottom') {\n\t\tfor (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {\n\t\t\tlet wrappedLineStart = i;\n\t\t\tconst wrappedLineEnd = i;\n\t\t\twhile (wrappedLineStart >= startLine && buffer.getLine(wrappedLineStart)?.isWrapped) {\n\t\t\t\twrappedLineStart--;\n\t\t\t}\n\t\t\ti = wrappedLineStart;\n\t\t\tlines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));\n\t\t\tif (lines.length > linesToCheck) {\n\t\t\t\tlines.pop();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {\n\t\t\tconst wrappedLineStart = i;\n\t\t\tlet wrappedLineEnd = i;\n\t\t\twhile (wrappedLineEnd + 1 < endLine && buffer.getLine(wrappedLineEnd + 1)?.isWrapped) {\n\t\t\t\twrappedLineEnd++;\n\t\t\t}\n\t\t\ti = wrappedLineEnd;\n\t\t\tlines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));\n\t\t\tif (lines.length === linesToCheck) {\n\t\t\t\tlines.shift();\n\t\t\t}\n\t\t}\n\t}\n\treturn lines;\n}\n\nfunction getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048 / cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction cloneMarker(xterm: Terminal, marker: IMarker, offset: number = 0): IMarker | undefined {\n\treturn xterm.registerMarker(marker.line - (xterm.buffer.active.baseY + xterm.buffer.active.cursorY) + offset);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { debounce } from '../../../../base/common/decorators.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, MandatoryMutableDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../log/common/log.js';\nimport { isString } from '../../../../base/common/types.js';\nimport { CommandInvalidationReason, ICommandDetectionCapability, ICommandInvalidationRequest, IHandleCommandOptions, ISerializedCommandDetectionCapability, ISerializedTerminalCommand, ITerminalCommand, TerminalCapability } from './capabilities.js';\nimport { ITerminalOutputMatcher } from '../terminal.js';\nimport { ICurrentPartialCommand, isFullTerminalCommand, PartialTerminalCommand, TerminalCommand } from './commandDetection/terminalCommand.js';\nimport { PromptInputModel, type IPromptInputModel } from './commandDetection/promptInputModel.js';\nimport type { IBuffer, IDisposable, IMarker, Terminal } from '@xterm/headless';\n\ninterface ITerminalDimensions {\n\tcols: number;\n\trows: number;\n}\n\nexport class CommandDetectionCapability extends Disposable implements ICommandDetectionCapability {\n\treadonly type = TerminalCapability.CommandDetection;\n\n\tprivate readonly _promptInputModel: PromptInputModel;\n\tget promptInputModel(): IPromptInputModel { return this._promptInputModel; }\n\n\tprotected _commands: TerminalCommand[] = [];\n\tprivate _cwd: string | undefined;\n\tprivate _promptTerminator: string | undefined;\n\tprivate _currentCommand: PartialTerminalCommand;\n\tprivate _commandMarkers: IMarker[] = [];\n\tprivate _dimensions: ITerminalDimensions;\n\tprivate __isCommandStorageDisabled: boolean = false;\n\tprivate _handleCommandStartOptions?: IHandleCommandOptions;\n\tprivate _hasRichCommandDetection: boolean = false;\n\tget hasRichCommandDetection() { return this._hasRichCommandDetection; }\n\tprivate _nextCommandId: { command: string; commandId: string | undefined } | undefined;\n\n\tprivate _ptyHeuristicsHooks: ICommandDetectionHeuristicsHooks;\n\tprivate readonly _ptyHeuristics: MandatoryMutableDisposable<IPtyHeuristics>;\n\n\tget commands(): readonly TerminalCommand[] { return this._commands; }\n\tget executingCommand(): string | undefined { return this._currentCommand.command; }\n\tget executingCommandObject(): ITerminalCommand | undefined {\n\t\tif (this._currentCommand.commandStartMarker) {\n\t\t\t// HACK: This does a lot more than the consumer of the API needs. It's also a little\n\t\t\t//       misleading since it's not promoting the current command yet.\n\t\t\treturn this._currentCommand.promoteToFullCommand(this._cwd, undefined, this._handleCommandStartOptions?.ignoreCommandLine ?? false, undefined);\n\t\t}\n\t\treturn undefined;\n\t}\n\tget executingCommandConfidence(): 'low' | 'medium' | 'high' | undefined {\n\t\tconst casted = this._currentCommand as PartialTerminalCommand | ITerminalCommand;\n\t\treturn isFullTerminalCommand(casted) ? casted.commandLineConfidence : undefined;\n\t}\n\tget currentCommand(): ICurrentPartialCommand {\n\t\treturn this._currentCommand;\n\t}\n\tget cwd(): string | undefined { return this._cwd; }\n\tget promptTerminator(): string | undefined { return this._promptTerminator; }\n\n\tprivate readonly _onCommandStarted = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandStarted = this._onCommandStarted.event;\n\tprivate readonly _onCommandStartChanged = this._register(new Emitter<void>());\n\treadonly onCommandStartChanged = this._onCommandStartChanged.event;\n\tprivate readonly _onBeforeCommandFinished = this._register(new Emitter<ITerminalCommand>());\n\treadonly onBeforeCommandFinished = this._onBeforeCommandFinished.event;\n\tprivate readonly _onCommandFinished = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandFinished = this._onCommandFinished.event;\n\tprivate readonly _onCommandExecuted = this._register(new Emitter<ITerminalCommand>());\n\treadonly onCommandExecuted = this._onCommandExecuted.event;\n\tprivate readonly _onCommandInvalidated = this._register(new Emitter<ITerminalCommand[]>());\n\treadonly onCommandInvalidated = this._onCommandInvalidated.event;\n\tprivate readonly _onCurrentCommandInvalidated = this._register(new Emitter<ICommandInvalidationRequest>());\n\treadonly onCurrentCommandInvalidated = this._onCurrentCommandInvalidated.event;\n\tprivate readonly _onSetRichCommandDetection = this._register(new Emitter<boolean>());\n\treadonly onSetRichCommandDetection = this._onSetRichCommandDetection.event;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._currentCommand = new PartialTerminalCommand(this._terminal);\n\t\tthis._promptInputModel = this._register(new PromptInputModel(this._terminal, this.onCommandStarted, this.onCommandStartChanged, this.onCommandExecuted, this._logService));\n\n\t\t// Pull command line from the buffer if it was not set explicitly\n\t\tthis._register(this.onCommandExecuted(command => {\n\t\t\tif (command.commandLineConfidence !== 'high') {\n\t\t\t\t// HACK: onCommandExecuted actually fired with PartialTerminalCommand\n\t\t\t\tconst typedCommand = (command as ITerminalCommand | PartialTerminalCommand);\n\t\t\t\tcommand.command = typedCommand.extractCommandLine();\n\t\t\t\tcommand.commandLineConfidence = 'low';\n\n\t\t\t\t// ITerminalCommand\n\t\t\t\tif (isFullTerminalCommand(typedCommand)) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.marker && typedCommand.executedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.startX !== undefined && typedCommand.startX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// PartialTerminalCommand\n\t\t\t\telse {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Markers exist\n\t\t\t\t\t\ttypedCommand.promptStartMarker && typedCommand.commandStartMarker && typedCommand.commandExecutedMarker &&\n\t\t\t\t\t\t// Single line command\n\t\t\t\t\t\tcommand.command.indexOf('\\n') === -1 &&\n\t\t\t\t\t\t// Start marker is not on the left-most column\n\t\t\t\t\t\ttypedCommand.commandStartX !== undefined && typedCommand.commandStartX > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommand.commandLineConfidence = 'medium';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._terminal.parser.registerCsiHandler({ final: 'J' }, params => {\n\t\t\tif (params.length >= 1 && params[0] === 2) {\n\t\t\t\tif (!this._terminal.options.scrollOnEraseInDisplay) {\n\t\t\t\t\tthis._clearCommandsInViewport();\n\t\t\t\t}\n\t\t\t\tthis._currentCommand.wasCleared = true;\n\t\t\t}\n\t\t\t// We don't want to override xterm.js' default behavior, just augment it\n\t\t\treturn false;\n\t\t}));\n\n\t\t// Set up platform-specific behaviors\n\t\tconst that = this;\n\t\tthis._ptyHeuristicsHooks = new class implements ICommandDetectionHeuristicsHooks {\n\t\t\tget onCurrentCommandInvalidatedEmitter() { return that._onCurrentCommandInvalidated; }\n\t\t\tget onCommandStartedEmitter() { return that._onCommandStarted; }\n\t\t\tget onCommandExecutedEmitter() { return that._onCommandExecuted; }\n\t\t\tget dimensions() { return that._dimensions; }\n\t\t\tget isCommandStorageDisabled() { return that.__isCommandStorageDisabled; }\n\t\t\tget commandMarkers() { return that._commandMarkers; }\n\t\t\tset commandMarkers(value) { that._commandMarkers = value; }\n\t\t\tget clearCommandsInViewport() { return that._clearCommandsInViewport.bind(that); }\n\t\t};\n\t\tthis._ptyHeuristics = this._register(new MandatoryMutableDisposable(new UnixPtyHeuristics(this._terminal, this, this._ptyHeuristicsHooks, this._logService)));\n\n\t\tthis._dimensions = {\n\t\t\tcols: this._terminal.cols,\n\t\t\trows: this._terminal.rows\n\t\t};\n\t\tthis._register(this._terminal.onResize(e => this._handleResize(e)));\n\t\tthis._register(this._terminal.onCursorMove(() => this._handleCursorMove()));\n\t}\n\n\tprivate _handleResize(e: { cols: number; rows: number }) {\n\t\tthis._ptyHeuristics.value.preHandleResize?.(e);\n\t\tthis._dimensions.cols = e.cols;\n\t\tthis._dimensions.rows = e.rows;\n\t}\n\n\t@debounce(500)\n\tprivate _handleCursorMove() {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\t// Early versions of conpty do not have real support for an alt buffer, in addition certain\n\t\t// commands such as tsc watch will write to the top of the normal buffer. The following\n\t\t// checks when the cursor has moved while the normal buffer is empty and if it is above the\n\t\t// current command, all decorations within the viewport will be invalidated.\n\t\t//\n\t\t// This function is debounced so that the cursor is only checked when it is stable so\n\t\t// conpty's screen reprinting will not trigger decoration clearing.\n\t\t//\n\t\t// This is mostly a workaround for Windows but applies to all OS' because of the tsc watch\n\t\t// case.\n\t\tif (this._terminal.buffer.active === this._terminal.buffer.normal && this._currentCommand.commandStartMarker) {\n\t\t\tif (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY < this._currentCommand.commandStartMarker.line) {\n\t\t\t\tthis._clearCommandsInViewport();\n\t\t\t\tthis._currentCommand.isInvalid = true;\n\t\t\t\tthis._onCurrentCommandInvalidated.fire({ reason: CommandInvalidationReason.Windows });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _clearCommandsInViewport(): void {\n\t\t// Find the number of commands on the tail end of the array that are within the viewport\n\t\tlet count = 0;\n\t\tfor (let i = this._commands.length - 1; i >= 0; i--) {\n\t\t\tconst line = this._commands[i].marker?.line;\n\t\t\tif (line && line < this._terminal.buffer.active.baseY) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\t// Remove them\n\t\tif (count > 0) {\n\t\t\tthis._onCommandInvalidated.fire(this._commands.splice(this._commands.length - count, count));\n\t\t}\n\t}\n\n\tsetContinuationPrompt(value: string): void {\n\t\tthis._promptInputModel.setContinuationPrompt(value);\n\t}\n\n\t// TODO: Simplify this, can everything work off the last line?\n\tsetPromptTerminator(promptTerminator: string, lastPromptLine: string) {\n\t\tthis._logService.debug('CommandDetectionCapability#setPromptTerminator', promptTerminator);\n\t\tthis._promptTerminator = promptTerminator;\n\t\tthis._promptInputModel.setLastPromptLine(lastPromptLine);\n\t}\n\n\tsetCwd(value: string) {\n\t\tthis._cwd = value;\n\t}\n\n\tsetIsWindowsPty(value: boolean) {\n\t\tif (value && !(this._ptyHeuristics.value instanceof WindowsPtyHeuristics)) {\n\t\t\tconst that = this;\n\t\t\tthis._ptyHeuristics.value = new WindowsPtyHeuristics(\n\t\t\t\tthis._terminal,\n\t\t\t\tthis,\n\t\t\t\tnew class {\n\t\t\t\t\tget onCurrentCommandInvalidatedEmitter() { return that._onCurrentCommandInvalidated; }\n\t\t\t\t\tget onCommandStartedEmitter() { return that._onCommandStarted; }\n\t\t\t\t\tget onCommandExecutedEmitter() { return that._onCommandExecuted; }\n\t\t\t\t\tget dimensions() { return that._dimensions; }\n\t\t\t\t\tget isCommandStorageDisabled() { return that.__isCommandStorageDisabled; }\n\t\t\t\t\tget commandMarkers() { return that._commandMarkers; }\n\t\t\t\t\tset commandMarkers(value) { that._commandMarkers = value; }\n\t\t\t\t\tget clearCommandsInViewport() { return that._clearCommandsInViewport.bind(that); }\n\t\t\t\t},\n\t\t\t\tthis._logService\n\t\t\t);\n\t\t} else if (!value && !(this._ptyHeuristics.value instanceof UnixPtyHeuristics)) {\n\t\t\tthis._ptyHeuristics.value = new UnixPtyHeuristics(this._terminal, this, this._ptyHeuristicsHooks, this._logService);\n\t\t}\n\t}\n\n\tsetHasRichCommandDetection(value: boolean): void {\n\t\tthis._hasRichCommandDetection = value;\n\t\tthis._onSetRichCommandDetection.fire(value);\n\t}\n\n\tsetIsCommandStorageDisabled(): void {\n\t\tthis.__isCommandStorageDisabled = true;\n\t}\n\n\tgetCommandForLine(line: number): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (this._currentCommand.promptStartMarker && line >= this._currentCommand.promptStartMarker?.line) {\n\t\t\treturn this._currentCommand;\n\t\t}\n\n\t\t// No commands\n\t\tif (this._commands.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Line is before any registered commands\n\t\tif ((this._commands[0].promptStartMarker ?? this._commands[0].marker!).line > line) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Iterate backwards through commands to find the right one\n\t\tfor (let i = this.commands.length - 1; i >= 0; i--) {\n\t\t\tif ((this.commands[i].promptStartMarker ?? this.commands[i].marker!).line <= line) {\n\t\t\t\treturn this.commands[i];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetCwdForLine(line: number): string | undefined {\n\t\t// Handle the current partial command first, anything below it's prompt is considered part\n\t\t// of the current command\n\t\tif (this._currentCommand.promptStartMarker && line >= this._currentCommand.promptStartMarker?.line) {\n\t\t\treturn this._cwd;\n\t\t}\n\n\t\tconst command = this.getCommandForLine(line);\n\t\tif (command && isFullTerminalCommand(command)) {\n\t\t\treturn command.cwd;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\thandlePromptStart(options?: IHandleCommandOptions): void {\n\t\t// Adjust the last command's finished marker when needed. The standard position for the\n\t\t// finished marker `D` to appear is at the same position as the following prompt started\n\t\t// `A`. Only do this when it would not extend past the current cursor position.\n\t\tconst lastCommand = this.commands.at(-1);\n\t\tif (\n\t\t\tlastCommand?.endMarker &&\n\t\t\tlastCommand?.executedMarker &&\n\t\t\tlastCommand.endMarker.line === lastCommand.executedMarker.line &&\n\t\t\tlastCommand.executedMarker.line < this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY\n\t\t) {\n\t\t\tthis._logService.debug('CommandDetectionCapability#handlePromptStart adjusted commandFinished', `${lastCommand.endMarker.line} -> ${lastCommand.executedMarker.line + 1}`);\n\t\t\tlastCommand.endMarker = cloneMarker(this._terminal, lastCommand.executedMarker, 1);\n\t\t}\n\n\t\tthis._currentCommand.promptStartMarker = (\n\t\t\toptions?.marker ||\n\t\t\t// Generally the prompt start should happen at the exact place the endmarker happened.\n\t\t\t// However, after ctrl+l is used to clear the display, we want to ensure the actual\n\t\t\t// prompt start marker position is used. This is mostly a workaround for Windows but we\n\t\t\t// apply it generally.\n\t\t\t(!this._currentCommand.wasCleared && lastCommand?.endMarker\n\t\t\t\t? cloneMarker(this._terminal, lastCommand.endMarker)\n\t\t\t\t: this._terminal.registerMarker(0))\n\t\t);\n\t\tthis._currentCommand.wasCleared = false;\n\t}\n\n\thandleContinuationStart(): void {\n\t\tthis._currentCommand.currentContinuationMarker = this._terminal.registerMarker(0);\n\t\tthis._logService.debug('CommandDetectionCapability#handleContinuationStart', this._currentCommand.currentContinuationMarker);\n\t}\n\n\thandleContinuationEnd(): void {\n\t\tif (!this._currentCommand.currentContinuationMarker) {\n\t\t\tthis._logService.warn('CommandDetectionCapability#handleContinuationEnd Received continuation end without start');\n\t\t\treturn;\n\t\t}\n\t\tif (!this._currentCommand.continuations) {\n\t\t\tthis._currentCommand.continuations = [];\n\t\t}\n\t\tthis._currentCommand.continuations.push({\n\t\t\tmarker: this._currentCommand.currentContinuationMarker,\n\t\t\tend: this._terminal.buffer.active.cursorX\n\t\t});\n\t\tthis._currentCommand.currentContinuationMarker = undefined;\n\t\tthis._logService.debug('CommandDetectionCapability#handleContinuationEnd', this._currentCommand.continuations[this._currentCommand.continuations.length - 1]);\n\t}\n\n\thandleRightPromptStart(): void {\n\t\tthis._currentCommand.commandRightPromptStartX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleRightPromptStart', this._currentCommand.commandRightPromptStartX);\n\t}\n\n\thandleRightPromptEnd(): void {\n\t\tthis._currentCommand.commandRightPromptEndX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleRightPromptEnd', this._currentCommand.commandRightPromptEndX);\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions): void {\n\t\tthis._handleCommandStartOptions = options;\n\t\tthis._currentCommand.cwd = this._cwd;\n\t\t// Only update the column if the line has already been set\n\t\tthis._currentCommand.commandStartMarker = options?.marker || this._currentCommand.commandStartMarker;\n\t\tif (this._currentCommand.commandStartMarker?.line === this._terminal.buffer.active.cursorY) {\n\t\t\tthis._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\t\t\tthis._onCommandStartChanged.fire();\n\t\t\tthis._logService.debug('CommandDetectionCapability#handleCommandStart', this._currentCommand.commandStartX, this._currentCommand.commandStartMarker?.line);\n\t\t\treturn;\n\t\t}\n\t\tthis._ptyHeuristics.value.handleCommandStart(options);\n\t}\n\n\t/**\n\t * Sets the command ID to use for the next command that starts.\n\t * This is useful when you want to pre-assign an ID before the shell sends the command start sequence.\n\t */\n\tsetNextCommandId(command: string, commandId: string): void {\n\t\tthis._nextCommandId = { command, commandId };\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions): void {\n\t\tthis._ensureCurrentCommandId(this._currentCommand.command ?? this._currentCommand.extractCommandLine());\n\t\tthis._ptyHeuristics.value.handleCommandExecuted(options);\n\t\tthis._currentCommand.markExecutedTime();\n\t}\n\n\thandleCommandFinished(exitCode: number | undefined, options?: IHandleCommandOptions): void {\n\t\t// Command executed may not have happened yet, if not handle it now so the expected events\n\t\t// properly propagate. This may cause the output to show up in the computed command line,\n\t\t// but the command line confidence will be low in the extension host for example and\n\t\t// therefore cannot be trusted anyway.\n\t\tif (!this._currentCommand.commandExecutedMarker) {\n\t\t\tthis.handleCommandExecuted();\n\t\t}\n\t\tthis._currentCommand.markFinishedTime();\n\t\tthis._ptyHeuristics.value.preHandleCommandFinished?.();\n\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandFinished', this._terminal.buffer.active.cursorX, options?.marker?.line, this._currentCommand.command, this._currentCommand);\n\n\t\t// HACK: Handle a special case on some versions of bash where identical commands get merged\n\t\t// in the output of `history`, this detects that case and sets the exit code to the last\n\t\t// command's exit code. This covered the majority of cases but will fail if the same command\n\t\t// runs with a different exit code, that will need a more robust fix where we send the\n\t\t// command ID and exit code over to the capability to adjust there.\n\t\tif (exitCode === undefined) {\n\t\t\tconst lastCommand = this.commands.length > 0 ? this.commands[this.commands.length - 1] : undefined;\n\t\t\tif (this._currentCommand.command && this._currentCommand.command.length > 0 && lastCommand?.command === this._currentCommand.command) {\n\t\t\t\texitCode = lastCommand.exitCode;\n\t\t\t}\n\t\t}\n\n\t\tif (this._currentCommand.commandStartMarker === undefined || !this._terminal.buffer.active) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentCommand.commandFinishedMarker = options?.marker || this._terminal.registerMarker(0);\n\n\t\tthis._ptyHeuristics.value.postHandleCommandFinished?.();\n\n\t\tconst newCommand = this._currentCommand.promoteToFullCommand(this._cwd, exitCode, this._handleCommandStartOptions?.ignoreCommandLine ?? false, options?.markProperties);\n\n\t\tif (newCommand) {\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._onBeforeCommandFinished.fire(newCommand);\n\t\t\t// NOTE: onCommandFinished used to not fire if the command was invalid, but this causes\n\t\t\t// problems especially with the associated execution event never firing in the extension\n\t\t\t// API. See https://github.com/microsoft/vscode/issues/252489\n\t\t\tthis._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);\n\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t}\n\t\t// Create new command for next execution\n\t\tthis._currentCommand = new PartialTerminalCommand(this._terminal);\n\t\tthis._handleCommandStartOptions = undefined;\n\t}\n\n\tprivate _ensureCurrentCommandId(commandLine: string | undefined): void {\n\t\tif (this._nextCommandId?.commandId && isString(commandLine) && commandLine.trim() === this._nextCommandId.command.trim()) {\n\t\t\tif (this._currentCommand.id !== this._nextCommandId.commandId) {\n\t\t\t\tthis._currentCommand.id = this._nextCommandId.commandId;\n\t\t\t}\n\t\t\tthis._nextCommandId = undefined;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsetCommandLine(commandLine: string, isTrusted: boolean) {\n\t\tthis._logService.debug('CommandDetectionCapability#setCommandLine', commandLine, isTrusted);\n\t\tthis._currentCommand.command = commandLine;\n\t\tthis._currentCommand.commandLineConfidence = 'high';\n\t\tthis._currentCommand.isTrusted = isTrusted;\n\n\t\tif (isTrusted) {\n\t\t\tthis._promptInputModel.setConfidentCommandLine(commandLine);\n\t\t}\n\t}\n\n\tserialize(): ISerializedCommandDetectionCapability {\n\t\tconst commands: ISerializedTerminalCommand[] = this.commands.map(e => e.serialize(this.__isCommandStorageDisabled));\n\t\tconst partialCommand = this._currentCommand.serialize(this._cwd);\n\t\tif (partialCommand) {\n\t\t\tcommands.push(partialCommand);\n\t\t}\n\t\treturn {\n\t\t\tisWindowsPty: this._ptyHeuristics.value instanceof WindowsPtyHeuristics,\n\t\t\thasRichCommandDetection: this._hasRichCommandDetection,\n\t\t\tcommands,\n\t\t\tpromptInputModel: this._promptInputModel.serialize(),\n\t\t};\n\t}\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void {\n\t\tif (serialized.isWindowsPty) {\n\t\t\tthis.setIsWindowsPty(serialized.isWindowsPty);\n\t\t}\n\t\tif (serialized.hasRichCommandDetection) {\n\t\t\tthis.setHasRichCommandDetection(serialized.hasRichCommandDetection);\n\t\t}\n\t\tconst buffer = this._terminal.buffer.normal;\n\t\tfor (const e of serialized.commands) {\n\t\t\t// Partial command\n\t\t\tif (!e.endLine) {\n\t\t\t\t// Check for invalid command\n\t\t\t\tconst marker = e.startLine !== undefined ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tif (!marker) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._currentCommand.commandStartMarker = e.startLine !== undefined ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tthis._currentCommand.commandStartX = e.startX;\n\t\t\t\tthis._currentCommand.promptStartMarker = e.promptStartLine !== undefined ? this._terminal.registerMarker(e.promptStartLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\t\t\tthis._cwd = e.cwd;\n\t\t\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\t\t\tthis._onCommandStarted.fire({ marker } as ITerminalCommand);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Full command\n\t\t\tconst newCommand = TerminalCommand.deserialize(this._terminal, e, this.__isCommandStorageDisabled);\n\t\t\tif (!newCommand) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._commands.push(newCommand);\n\t\t\tthis._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);\n\t\t\tthis._onCommandFinished.fire(newCommand);\n\t\t}\n\t\tif (serialized.promptInputModel) {\n\t\t\tthis._promptInputModel.deserialize(serialized.promptInputModel);\n\t\t}\n\t}\n}\n\n/**\n * Additional hooks to private methods on {@link CommandDetectionCapability} that are needed by the\n * heuristics objects.\n */\ninterface ICommandDetectionHeuristicsHooks {\n\treadonly onCurrentCommandInvalidatedEmitter: Emitter<ICommandInvalidationRequest>;\n\treadonly onCommandStartedEmitter: Emitter<ITerminalCommand>;\n\treadonly onCommandExecutedEmitter: Emitter<ITerminalCommand>;\n\treadonly dimensions: ITerminalDimensions;\n\treadonly isCommandStorageDisabled: boolean;\n\n\tcommandMarkers: IMarker[];\n\n\tclearCommandsInViewport(): void;\n}\n\ntype IPtyHeuristics = (\n\t// All optional methods\n\tPartial<UnixPtyHeuristics> & Partial<WindowsPtyHeuristics> &\n\t// All common methods\n\t(UnixPtyHeuristics | WindowsPtyHeuristics) &\n\tIDisposable\n);\n\n/**\n * Non-Windows-specific behavior.\n */\nclass UnixPtyHeuristics extends Disposable {\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\tprivate readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t}\n\n\thandleCommandStart(options?: IHandleCommandOptions) {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\t\tcurrentCommand.commandStartMarker = options?.marker || this._terminal.registerMarker(0);\n\n\t\t// Clear executed as it must happen after command start\n\t\tcurrentCommand.commandExecutedMarker?.dispose();\n\t\tcurrentCommand.commandExecutedMarker = undefined;\n\t\tcurrentCommand.commandExecutedX = undefined;\n\t\tfor (const m of this._hooks.commandMarkers) {\n\t\t\tm.dispose();\n\t\t}\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tthis._hooks.onCommandStartedEmitter.fire({ marker: options?.marker || currentCommand.commandStartMarker, markProperties: options?.markProperties } as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandStart', currentCommand.commandStartX, currentCommand.commandStartMarker?.line);\n\t}\n\n\thandleCommandExecuted(options?: IHandleCommandOptions) {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tcurrentCommand.commandExecutedMarker = options?.marker || this._terminal.registerMarker(0);\n\t\tcurrentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandExecuted', currentCommand.commandExecutedX, currentCommand.commandExecutedMarker?.line);\n\n\t\t// Sanity check optional props\n\t\tif (!currentCommand.commandStartMarker || !currentCommand.commandExecutedMarker || currentCommand.commandStartX === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tcurrentCommand.command = this._capability.promptInputModel.ghostTextIndex > -1 ? this._capability.promptInputModel.value.substring(0, this._capability.promptInputModel.ghostTextIndex) : this._capability.promptInputModel.value;\n\t\tthis._hooks.onCommandExecutedEmitter.fire(currentCommand as ITerminalCommand);\n\t}\n}\n\nconst enum AdjustCommandStartMarkerConstants {\n\tMaxCheckLineCount = 10,\n\tInterval = 20,\n\tMaximumPollCount = 10,\n}\n\n/**\n * An object that integrated with and decorates the command detection capability to add heuristics\n * that adjust various markers to work better with Windows and ConPTY. This isn't depended upon the\n * frontend OS, or even the backend OS, but the `IsWindows` property which technically a non-Windows\n * client can emit (for example in tests).\n */\nclass WindowsPtyHeuristics extends Disposable {\n\n\tprivate readonly _onCursorMoveListener = this._register(new MutableDisposable());\n\n\tprivate _tryAdjustCommandStartMarkerScheduler?: RunOnceScheduler;\n\tprivate _tryAdjustCommandStartMarkerScannedLineCount: number = 0;\n\tprivate _tryAdjustCommandStartMarkerPollCount: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _terminal: Terminal,\n\t\tprivate readonly _capability: CommandDetectionCapability,\n\t\tprivate readonly _hooks: ICommandDetectionHeuristicsHooks,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this._capability.onBeforeCommandFinished(command => {\n\t\t\t// For older Windows backends we cannot listen to CSI J, instead we assume running clear\n\t\t\t// or cls will clear all commands in the viewport. This is not perfect but it's right\n\t\t\t// most of the time.\n\t\t\tif (command.command.trim().toLowerCase() === 'clear' || command.command.trim().toLowerCase() === 'cls') {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.cancel();\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t\t\tthis._hooks.clearCommandsInViewport();\n\t\t\t\tthis._capability.currentCommand.isInvalid = true;\n\t\t\t\tthis._hooks.onCurrentCommandInvalidatedEmitter.fire({ reason: CommandInvalidationReason.Windows });\n\t\t\t}\n\t\t}));\n\t}\n\n\tpreHandleResize(e: { cols: number; rows: number }) {\n\t\t// Resize behavior is different under conpty; instead of bringing parts of the scrollback\n\t\t// back into the viewport, new lines are inserted at the bottom (ie. the same behavior as if\n\t\t// there was no scrollback).\n\t\t//\n\t\t// On resize this workaround will wait for a conpty reprint to occur by waiting for the\n\t\t// cursor to move, it will then calculate the number of lines that the commands within the\n\t\t// viewport _may have_ shifted. After verifying the content of the current line is\n\t\t// incorrect, the line after shifting is checked and if that matches delete events are fired\n\t\t// on the xterm.js buffer to move the markers.\n\t\t//\n\t\t// While a bit hacky, this approach is quite safe and seems to work great at least for pwsh.\n\t\tconst baseY = this._terminal.buffer.active.baseY;\n\t\tconst rowsDifference = e.rows - this._hooks.dimensions.rows;\n\t\t// Only do when rows increase, do in the next frame as this needs to happen after\n\t\t// conpty reprints the screen\n\t\tif (rowsDifference > 0) {\n\t\t\tthis._waitForCursorMove().then(() => {\n\t\t\t\t// Calculate the number of lines the content may have shifted, this will max out at\n\t\t\t\t// scrollback count since the standard behavior will be used then\n\t\t\t\tconst potentialShiftedLineCount = Math.min(rowsDifference, baseY);\n\t\t\t\t// For each command within the viewport, assume commands are in the correct order\n\t\t\t\tfor (let i = this._capability.commands.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst command = this._capability.commands[i];\n\t\t\t\t\tif (!command.marker || command.marker.line < baseY || command.commandStartLineContent === undefined) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst line = this._terminal.buffer.active.getLine(command.marker.line);\n\t\t\t\t\tif (!line || line.translateToString(true) === command.commandStartLineContent) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst shiftedY = command.marker.line - potentialShiftedLineCount;\n\t\t\t\t\tconst shiftedLine = this._terminal.buffer.active.getLine(shiftedY);\n\t\t\t\t\tif (shiftedLine?.translateToString(true) !== command.commandStartLineContent) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// HACK: xterm.js doesn't expose this by design as it's an internal core\n\t\t\t\t\t// function an embedder could easily do damage with. Additionally, this\n\t\t\t\t\t// can't really be upstreamed since the event relies on shell integration to\n\t\t\t\t\t// verify the shifting is necessary.\n\t\t\t\t\tinterface IXtermWithCore extends Terminal {\n\t\t\t\t\t\t_core: {\n\t\t\t\t\t\t\t_bufferService: {\n\t\t\t\t\t\t\t\tbuffer: {\n\t\t\t\t\t\t\t\t\tlines: {\n\t\t\t\t\t\t\t\t\t\tonDeleteEmitter: {\n\t\t\t\t\t\t\t\t\t\t\tfire(data: { index: number; amount: number }): void;\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t(this._terminal as IXtermWithCore)._core._bufferService.buffer.lines.onDeleteEmitter.fire({\n\t\t\t\t\t\tindex: this._terminal.buffer.active.baseY,\n\t\t\t\t\t\tamount: potentialShiftedLineCount\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\thandleCommandStart() {\n\t\tthis._capability.currentCommand.commandStartX = this._terminal.buffer.active.cursorX;\n\n\t\t// On Windows track all cursor movements after the command start sequence\n\t\tthis._hooks.commandMarkers.length = 0;\n\n\t\tconst initialCommandStartMarker = this._capability.currentCommand.commandStartMarker = (\n\t\t\tthis._capability.currentCommand.promptStartMarker\n\t\t\t\t? cloneMarker(this._terminal, this._capability.currentCommand.promptStartMarker)\n\t\t\t\t: this._terminal.registerMarker(0)\n\t\t)!;\n\t\tthis._capability.currentCommand.commandStartX = 0;\n\n\t\t// DEBUG: Add a decoration for the original unadjusted command start position\n\t\t// if ('registerDecoration' in this._terminal) {\n\t\t// \tconst d = (this._terminal as any).registerDecoration({\n\t\t// \t\tmarker: this._capability.currentCommand.commandStartMarker,\n\t\t// \t\tx: this._capability.currentCommand.commandStartX\n\t\t// \t});\n\t\t// \td?.onRender((e: HTMLElement) => {\n\t\t// \t\te.textContent = 'b';\n\t\t// \t\te.classList.add('xterm-sequence-decoration', 'top', 'right');\n\t\t// \t\te.title = 'Initial command start position';\n\t\t// \t});\n\t\t// }\n\n\t\t// The command started sequence may be printed before the actual prompt is, for example a\n\t\t// multi-line prompt will typically look like this where D, A and B signify the command\n\t\t// finished, prompt started and command started sequences respectively:\n\t\t//\n\t\t//     D/my/cwdB\n\t\t//     > C\n\t\t//\n\t\t// Due to this, it's likely that this will be called before the line has been parsed.\n\t\t// Unfortunately, it is also the case that the actual command start data may not be parsed\n\t\t// by the end of the task either, so a microtask cannot be used.\n\t\t//\n\t\t// The strategy used is to begin polling and scanning downwards for up to the next 5 lines.\n\t\t// If it looks like a prompt is found, the command started location is adjusted. If the\n\t\t// command executed sequences comes in before polling is done, polling is canceled and the\n\t\t// final polling task is executed synchronously.\n\t\tthis._tryAdjustCommandStartMarkerScannedLineCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerPollCount = 0;\n\t\tthis._tryAdjustCommandStartMarkerScheduler = new RunOnceScheduler(() => this._tryAdjustCommandStartMarker(initialCommandStartMarker), AdjustCommandStartMarkerConstants.Interval);\n\t\tthis._tryAdjustCommandStartMarkerScheduler.schedule();\n\n\t\t// TODO: Cache details about polling for the future - eg. if it always fails, stop bothering\n\t}\n\n\tprivate _tryAdjustCommandStartMarker(start: IMarker) {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tconst buffer = this._terminal.buffer.active;\n\t\tlet scannedLineCount = this._tryAdjustCommandStartMarkerScannedLineCount;\n\t\twhile (scannedLineCount < AdjustCommandStartMarkerConstants.MaxCheckLineCount && start.line + scannedLineCount < buffer.baseY + this._terminal.rows) {\n\t\t\tif (this._cursorOnNextLine()) {\n\t\t\t\tconst prompt = this._getWindowsPrompt(start.line + scannedLineCount);\n\t\t\t\tif (prompt) {\n\t\t\t\t\tconst adjustedPrompt = isString(prompt) ? prompt : prompt.prompt;\n\t\t\t\t\tthis._capability.currentCommand.commandStartMarker = this._terminal.registerMarker(0)!;\n\t\t\t\t\tif (!isString(prompt) && prompt.likelySingleLine) {\n\t\t\t\t\t\tthis._logService.debug('CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted promptStart', `${this._capability.currentCommand.promptStartMarker?.line} -> ${this._capability.currentCommand.commandStartMarker.line}`);\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker?.dispose();\n\t\t\t\t\t\tthis._capability.currentCommand.promptStartMarker = cloneMarker(this._terminal, this._capability.currentCommand.commandStartMarker);\n\t\t\t\t\t\t// Adjust the last command if it's not in the same position as the following\n\t\t\t\t\t\t// prompt start marker\n\t\t\t\t\t\tconst lastCommand = this._capability.commands.at(-1);\n\t\t\t\t\t\tif (lastCommand && this._capability.currentCommand.commandStartMarker.line !== lastCommand.endMarker?.line) {\n\t\t\t\t\t\t\tlastCommand.endMarker?.dispose();\n\t\t\t\t\t\t\tlastCommand.endMarker = cloneMarker(this._terminal, this._capability.currentCommand.commandStartMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// use the regex to set the position as it's possible input has occurred\n\t\t\t\t\tthis._capability.currentCommand.commandStartX = adjustedPrompt.length;\n\t\t\t\t\tthis._logService.debug('CommandDetectionCapability#_tryAdjustCommandStartMarker adjusted commandStart', `${start.line} -> ${this._capability.currentCommand.commandStartMarker.line}:${this._capability.currentCommand.commandStartX}`);\n\t\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscannedLineCount++;\n\t\t}\n\t\tif (scannedLineCount < AdjustCommandStartMarkerConstants.MaxCheckLineCount) {\n\t\t\tthis._tryAdjustCommandStartMarkerScannedLineCount = scannedLineCount;\n\t\t\tif (++this._tryAdjustCommandStartMarkerPollCount < AdjustCommandStartMarkerConstants.MaximumPollCount) {\n\t\t\t\tthis._tryAdjustCommandStartMarkerScheduler?.schedule();\n\t\t\t} else {\n\t\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t}\n\n\tprivate _flushPendingHandleCommandStartTask() {\n\t\t// Perform final try adjust if necessary\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\t// Max out poll count to ensure it's the last run\n\t\t\tthis._tryAdjustCommandStartMarkerPollCount = AdjustCommandStartMarkerConstants.MaximumPollCount;\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler.flush();\n\t\t\tthis._tryAdjustCommandStartMarkerScheduler = undefined;\n\t\t}\n\n\t\tif (!this._capability.currentCommand.commandExecutedMarker) {\n\t\t\tthis._onCursorMoveListener.value = this._terminal.onCursorMove(() => {\n\t\t\t\tif (this._hooks.commandMarkers.length === 0 || this._hooks.commandMarkers[this._hooks.commandMarkers.length - 1].line !== this._terminal.buffer.active.cursorY) {\n\t\t\t\t\tconst marker = this._terminal.registerMarker(0);\n\t\t\t\t\tif (marker) {\n\t\t\t\t\t\tthis._hooks.commandMarkers.push(marker);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(this._capability.currentCommand.commandStartMarker.line);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent = line.translateToString(true);\n\t\t\t}\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tthis._hooks.onCommandStartedEmitter.fire({ marker: this._capability.currentCommand.commandStartMarker } as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#_handleCommandStartWindows', this._capability.currentCommand.commandStartX, this._capability.currentCommand.commandStartMarker?.line);\n\t}\n\n\thandleCommandExecuted(options: IHandleCommandOptions | undefined) {\n\t\tif (this._tryAdjustCommandStartMarkerScheduler) {\n\t\t\tthis._flushPendingHandleCommandStartTask();\n\t\t}\n\t\t// Use the gathered cursor move markers to correct the command start and executed markers\n\t\tthis._onCursorMoveListener.clear();\n\t\tthis._evaluateCommandMarkers();\n\t\tthis._capability.currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;\n\t\tthis._hooks.onCommandExecutedEmitter.fire(this._capability.currentCommand as ITerminalCommand);\n\t\tthis._logService.debug('CommandDetectionCapability#handleCommandExecuted', this._capability.currentCommand.commandExecutedX, this._capability.currentCommand.commandExecutedMarker?.line);\n\t}\n\n\tpreHandleCommandFinished() {\n\t\tif (this._capability.currentCommand.commandExecutedMarker) {\n\t\t\treturn;\n\t\t}\n\t\t// This is done on command finished just in case command executed never happens (for example\n\t\t// PSReadLine tab completion)\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\t// If the command start timeout doesn't happen before command finished, just use the\n\t\t\t// current marker.\n\t\t\tif (!this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._capability.currentCommand.commandStartMarker = this._terminal.registerMarker(0);\n\t\t\t}\n\t\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\t\tthis._hooks.commandMarkers.push(this._capability.currentCommand.commandStartMarker);\n\t\t\t}\n\t\t}\n\t\tthis._evaluateCommandMarkers();\n\t}\n\n\tpostHandleCommandFinished(): void {\n\t\tconst currentCommand = this._capability.currentCommand;\n\t\tconst commandText = currentCommand.command;\n\t\tconst commandLine = currentCommand.commandStartMarker?.line;\n\t\tconst executedLine = currentCommand.commandExecutedMarker?.line;\n\t\tif (\n\t\t\t!commandText || commandText.length === 0 ||\n\t\t\tcommandLine === undefined || commandLine === -1 ||\n\t\t\texecutedLine === undefined || executedLine === -1\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Scan downwards from the command start line and search for every character in the actual\n\t\t// command line. This may end up matching the wrong characters, but it shouldn't matter at\n\t\t// least in the typical case as the entire command will still get matched.\n\t\tlet current = 0;\n\t\tlet found = false;\n\t\tfor (let i = commandLine; i <= executedLine; i++) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst text = line.translateToString(true);\n\t\t\tfor (let j = 0; j < text.length; j++) {\n\t\t\t\t// Skip whitespace in case it was not actually rendered or could be trimmed from the\n\t\t\t\t// end of the line\n\t\t\t\twhile (commandText.length < current && commandText[current] === ' ') {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Character match\n\t\t\t\tif (text[j] === commandText[current]) {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\n\t\t\t\t// Full command match\n\t\t\t\tif (current === commandText.length) {\n\t\t\t\t\t// It's ambiguous whether the command executed marker should ideally appear at\n\t\t\t\t\t// the end of the line or at the beginning of the next line. Since it's more\n\t\t\t\t\t// useful for extracting the command at the end of the current line we go with\n\t\t\t\t\t// that.\n\t\t\t\t\tconst wrapsToNextLine = j >= this._terminal.cols - 1;\n\t\t\t\t\tcurrentCommand.commandExecutedMarker = this._terminal.registerMarker(i - (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY) + (wrapsToNextLine ? 1 : 0));\n\t\t\t\t\tcurrentCommand.commandExecutedX = wrapsToNextLine ? 0 : j + 1;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _evaluateCommandMarkers(): void {\n\t\t// On Windows, use the gathered cursor move markers to correct the command start and\n\t\t// executed markers.\n\t\tif (this._hooks.commandMarkers.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._hooks.commandMarkers = this._hooks.commandMarkers.sort((a, b) => a.line - b.line);\n\t\tthis._capability.currentCommand.commandStartMarker = this._hooks.commandMarkers[0];\n\t\tif (this._capability.currentCommand.commandStartMarker) {\n\t\t\tconst line = this._terminal.buffer.active.getLine(this._capability.currentCommand.commandStartMarker.line);\n\t\t\tif (line) {\n\t\t\t\tthis._capability.currentCommand.commandStartLineContent = line.translateToString(true);\n\t\t\t}\n\t\t}\n\t\tthis._capability.currentCommand.commandExecutedMarker = this._hooks.commandMarkers[this._hooks.commandMarkers.length - 1];\n\t\t// Fire this now to prevent issues like #197409\n\t\tthis._hooks.onCommandExecutedEmitter.fire(this._capability.currentCommand as ITerminalCommand);\n\t}\n\n\tprivate _cursorOnNextLine(): boolean {\n\t\tconst lastCommand = this._capability.commands.at(-1);\n\n\t\t// There is only a single command, so this check is unnecessary\n\t\tif (!lastCommand) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst cursorYAbsolute = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY;\n\t\t// If the cursor position is within the last command, we should poll.\n\t\tconst lastCommandYAbsolute = (lastCommand.endMarker ? lastCommand.endMarker.line : lastCommand.marker?.line) ?? -1;\n\t\treturn cursorYAbsolute > lastCommandYAbsolute;\n\t}\n\n\tprivate _waitForCursorMove(): Promise<void> {\n\t\tconst cursorX = this._terminal.buffer.active.cursorX;\n\t\tconst cursorY = this._terminal.buffer.active.cursorY;\n\t\tlet totalDelay = 0;\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tif (cursorX !== this._terminal.buffer.active.cursorX || cursorY !== this._terminal.buffer.active.cursorY) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotalDelay += 10;\n\t\t\t\tif (totalDelay > 1000) {\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}, 10);\n\t\t});\n\t}\n\n\tprivate _getWindowsPrompt(y: number = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY): string | { prompt: string; likelySingleLine: true } | undefined {\n\t\tconst line = this._terminal.buffer.active.getLine(y);\n\t\tif (!line) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineText = line.translateToString(true);\n\t\tif (!lineText) {\n\t\t\treturn;\n\t\t}\n\n\t\t// PowerShell\n\t\tconst pwshPrompt = lineText.match(/(?<prompt>(\\(.+\\)\\s)?(?:PS.+>\\s?))/)?.groups?.prompt;\n\t\tif (pwshPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(pwshPrompt, lineText, '>');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn {\n\t\t\t\t\tprompt: adjustedPrompt,\n\t\t\t\t\tlikelySingleLine: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Custom prompts like starship end in the common \\u276f character\n\t\tconst customPrompt = lineText.match(/.*\\u276f(?=[^\\u276f]*$)/g)?.[0];\n\t\tif (customPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(customPrompt, lineText, '\\u276f');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Bash Prompt\n\t\tconst bashPrompt = lineText.match(/^(?<prompt>\\$)/)?.groups?.prompt;\n\t\tif (bashPrompt) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(bashPrompt, lineText, '$');\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Python Prompt\n\t\tconst pythonPrompt = lineText.match(/^(?<prompt>>>> )/g)?.groups?.prompt;\n\t\tif (pythonPrompt) {\n\t\t\treturn {\n\t\t\t\tprompt: pythonPrompt,\n\t\t\t\tlikelySingleLine: true\n\t\t\t};\n\t\t}\n\n\t\t// Dynamic prompt detection\n\t\tif (this._capability.promptTerminator && (lineText === this._capability.promptTerminator || lineText.trim().endsWith(this._capability.promptTerminator))) {\n\t\t\tconst adjustedPrompt = this._adjustPrompt(lineText, lineText, this._capability.promptTerminator);\n\t\t\tif (adjustedPrompt) {\n\t\t\t\treturn adjustedPrompt;\n\t\t\t}\n\t\t}\n\n\t\t// Command Prompt\n\t\tconst cmdMatch = lineText.match(/^(?<prompt>(\\(.+\\)\\s)?(?:[A-Z]:\\\\.*>))/);\n\t\treturn cmdMatch?.groups?.prompt ? {\n\t\t\tprompt: cmdMatch.groups.prompt,\n\t\t\tlikelySingleLine: true\n\t\t} : undefined;\n\t}\n\n\tprivate _adjustPrompt(prompt: string | undefined, lineText: string, char: string): string | undefined {\n\t\tif (!prompt) {\n\t\t\treturn;\n\t\t}\n\t\t// Conpty may not 'render' the space at the end of the prompt\n\t\tif (lineText === prompt && prompt.endsWith(char)) {\n\t\t\tprompt += ' ';\n\t\t}\n\t\treturn prompt;\n\t}\n}\n\nexport function getLinesForCommand(buffer: IBuffer, command: ITerminalCommand, cols: number, outputMatcher?: ITerminalOutputMatcher): string[] | undefined {\n\tif (!outputMatcher) {\n\t\treturn undefined;\n\t}\n\tconst executedMarker = command.executedMarker;\n\tconst endMarker = command.endMarker;\n\tif (!executedMarker || !endMarker) {\n\t\treturn undefined;\n\t}\n\tconst startLine = executedMarker.line;\n\tconst endLine = endMarker.line;\n\n\tconst linesToCheck = outputMatcher.length;\n\tconst lines: string[] = [];\n\tif (outputMatcher.anchor === 'bottom') {\n\t\tfor (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {\n\t\t\tlet wrappedLineStart = i;\n\t\t\tconst wrappedLineEnd = i;\n\t\t\twhile (wrappedLineStart >= startLine && buffer.getLine(wrappedLineStart)?.isWrapped) {\n\t\t\t\twrappedLineStart--;\n\t\t\t}\n\t\t\ti = wrappedLineStart;\n\t\t\tlines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));\n\t\t\tif (lines.length > linesToCheck) {\n\t\t\t\tlines.pop();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {\n\t\t\tconst wrappedLineStart = i;\n\t\t\tlet wrappedLineEnd = i;\n\t\t\twhile (wrappedLineEnd + 1 < endLine && buffer.getLine(wrappedLineEnd + 1)?.isWrapped) {\n\t\t\t\twrappedLineEnd++;\n\t\t\t}\n\t\t\ti = wrappedLineEnd;\n\t\t\tlines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));\n\t\t\tif (lines.length === linesToCheck) {\n\t\t\t\tlines.shift();\n\t\t\t}\n\t\t}\n\t}\n\treturn lines;\n}\n\nfunction getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048 / cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction cloneMarker(xterm: Terminal, marker: IMarker, offset: number = 0): IMarker | undefined {\n\treturn xterm.registerMarker(marker.line - (xterm.buffer.active.baseY + xterm.buffer.active.cursorY) + offset);\n}\n"]}