{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/capabilities/commandDetection/terminalCommand.ts","vs/platform/terminal/common/capabilities/commandDetection/terminalCommand.ts"],"names":[],"mappings":"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","file":"terminalCommand.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMarkProperties, ISerializedTerminalCommand, ITerminalCommand } from '../capabilities.js';\nimport { ITerminalOutputMatcher, ITerminalOutputMatch } from '../../terminal.js';\nimport type { IBuffer, IBufferLine, IMarker, Terminal } from '@xterm/headless';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { isString } from '../../../../../base/common/types.js';\n\nexport interface ITerminalCommandProperties {\n\tcommand: string;\n\tcommandLineConfidence: 'low' | 'medium' | 'high';\n\tisTrusted: boolean;\n\ttimestamp: number;\n\tduration: number;\n\tid: string | undefined;\n\tmarker: IMarker | undefined;\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n\texecutedX: number | undefined;\n\tstartX: number | undefined;\n\n\tpromptStartMarker?: IMarker | undefined;\n\tendMarker?: IMarker | undefined;\n\texecutedMarker?: IMarker | undefined;\n\taliases?: string[][] | undefined;\n\twasReplayed?: boolean | undefined;\n}\n\nexport class TerminalCommand implements ITerminalCommand {\n\n\tget command() { return this._properties.command; }\n\tget commandLineConfidence() { return this._properties.commandLineConfidence; }\n\tget isTrusted() { return this._properties.isTrusted; }\n\tget timestamp() { return this._properties.timestamp; }\n\tget duration() { return this._properties.duration; }\n\tget promptStartMarker() { return this._properties.promptStartMarker; }\n\tget marker() { return this._properties.marker; }\n\tget endMarker() { return this._properties.endMarker; }\n\tset endMarker(value: IMarker | undefined) { this._properties.endMarker = value; }\n\tget executedMarker() { return this._properties.executedMarker; }\n\tget aliases() { return this._properties.aliases; }\n\tget wasReplayed() { return this._properties.wasReplayed; }\n\tget cwd() { return this._properties.cwd; }\n\tget exitCode() { return this._properties.exitCode; }\n\tget commandStartLineContent() { return this._properties.commandStartLineContent; }\n\tget markProperties() { return this._properties.markProperties; }\n\tget executedX() { return this._properties.executedX; }\n\tget startX() { return this._properties.startX; }\n\tget id() { return this._properties.id; }\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tprivate readonly _properties: ITerminalCommandProperties,\n\t) {\n\t}\n\n\tstatic deserialize(xterm: Terminal, serialized: ISerializedTerminalCommand & Required<Pick<ISerializedTerminalCommand, 'endLine'>>, isCommandStorageDisabled: boolean): TerminalCommand | undefined {\n\t\tconst buffer = xterm.buffer.normal;\n\t\tconst marker = serialized.startLine !== undefined ? xterm.registerMarker(serialized.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\n\t\t// Check for invalid command\n\t\tif (!marker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst promptStartMarker = serialized.promptStartLine !== undefined ? xterm.registerMarker(serialized.promptStartLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\n\t\t// Valid full command\n\t\tconst endMarker = serialized.endLine !== undefined ? xterm.registerMarker(serialized.endLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\tconst executedMarker = serialized.executedLine !== undefined ? xterm.registerMarker(serialized.executedLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\tconst newCommand = new TerminalCommand(xterm, {\n\t\t\tcommand: isCommandStorageDisabled ? '' : serialized.command,\n\t\t\tcommandLineConfidence: serialized.commandLineConfidence ?? 'low',\n\t\t\tisTrusted: serialized.isTrusted,\n\t\t\tid: serialized.id,\n\t\t\tpromptStartMarker,\n\t\t\tmarker,\n\t\t\tstartX: serialized.startX,\n\t\t\tendMarker,\n\t\t\texecutedMarker,\n\t\t\texecutedX: serialized.executedX,\n\t\t\ttimestamp: serialized.timestamp,\n\t\t\tduration: serialized.duration,\n\t\t\tcwd: serialized.cwd,\n\t\t\tcommandStartLineContent: serialized.commandStartLineContent,\n\t\t\texitCode: serialized.exitCode,\n\t\t\tmarkProperties: serialized.markProperties,\n\t\t\taliases: undefined,\n\t\t\twasReplayed: true\n\t\t});\n\t\treturn newCommand;\n\t}\n\n\tserialize(isCommandStorageDisabled: boolean): ISerializedTerminalCommand {\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.marker?.line,\n\t\t\tstartX: undefined,\n\t\t\tendLine: this.endMarker?.line,\n\t\t\texecutedLine: this.executedMarker?.line,\n\t\t\texecutedX: this.executedX,\n\t\t\tcommand: isCommandStorageDisabled ? '' : this.command,\n\t\t\tcommandLineConfidence: isCommandStorageDisabled ? 'low' : this.commandLineConfidence,\n\t\t\tisTrusted: this.isTrusted,\n\t\t\tcwd: this.cwd,\n\t\t\texitCode: this.exitCode,\n\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\ttimestamp: this.timestamp,\n\t\t\tduration: this.duration,\n\t\t\tmarkProperties: this.markProperties,\n\t\t\tid: this.id,\n\t\t};\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(this._xterm.buffer.active, this._xterm.cols, this.marker, this.startX, this.executedMarker, this.executedX);\n\t}\n\n\tgetOutput(): string | undefined {\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst startLine = this.executedMarker.line;\n\t\tconst endLine = this.endMarker.line;\n\n\t\tif (startLine === endLine) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet output = '';\n\t\tlet line: IBufferLine | undefined;\n\t\tfor (let i = startLine; i < endLine; i++) {\n\t\t\tline = this._xterm.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toutput += line.translateToString(!line.isWrapped) + (line.isWrapped ? '' : '\\n');\n\t\t}\n\t\treturn output === '' ? undefined : output;\n\t}\n\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined {\n\t\t// TODO: Add back this check? this._ptyHeuristics.value instanceof WindowsPtyHeuristics && (executedMarker?.line === endMarker?.line) ? this._currentCommand.commandStartMarker : executedMarker\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst endLine = this.endMarker.line;\n\t\tif (endLine === -1) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst buffer = this._xterm.buffer.active;\n\t\tconst startLine = Math.max(this.executedMarker.line, 0);\n\t\tconst matcher = outputMatcher.lineMatcher;\n\t\tconst linesToCheck = isString(matcher) ? 1 : outputMatcher.length || countNewLines(matcher);\n\t\tconst lines: string[] = [];\n\t\tlet match: RegExpMatchArray | null | undefined;\n\t\tif (outputMatcher.anchor === 'bottom') {\n\t\t\tfor (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {\n\t\t\t\tlet wrappedLineStart = i;\n\t\t\t\tconst wrappedLineEnd = i;\n\t\t\t\twhile (wrappedLineStart >= startLine && buffer.getLine(wrappedLineStart)?.isWrapped) {\n\t\t\t\t\twrappedLineStart--;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineStart;\n\t\t\t\tlines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, this._xterm.cols));\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[0].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {\n\t\t\t\tconst wrappedLineStart = i;\n\t\t\t\tlet wrappedLineEnd = i;\n\t\t\t\twhile (wrappedLineEnd + 1 < endLine && buffer.getLine(wrappedLineEnd + 1)?.isWrapped) {\n\t\t\t\t\twrappedLineEnd++;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineEnd;\n\t\t\t\tlines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, this._xterm.cols));\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[lines.length - 1].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match ? { regexMatch: match, outputLines: lines } : undefined;\n\t}\n\n\thasOutput(): boolean {\n\t\treturn (\n\t\t\t!this.executedMarker?.isDisposed &&\n\t\t\t!this.endMarker?.isDisposed &&\n\t\t\t!!(\n\t\t\t\tthis.executedMarker &&\n\t\t\t\tthis.endMarker &&\n\t\t\t\tthis.executedMarker.line < this.endMarker.line\n\t\t\t)\n\t\t);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nexport interface ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcommand?: string;\n\n\t/**\n\t * Whether the command line is trusted via a nonce.\n\t */\n\tisTrusted?: boolean;\n\n\t/**\n\t * Something invalidated the command before it finished, this will prevent the onCommandFinished\n\t * event from firing.\n\t */\n\tisInvalid?: boolean;\n\n\tgetPromptRowCount(): number;\n\tgetCommandRowCount(): number;\n}\n\nexport class PartialTerminalCommand implements ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tprivate commandExecutedTimestamp?: number;\n\tprivate commandDuration?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcwd?: string;\n\tcommand?: string;\n\tcommandLineConfidence?: 'low' | 'medium' | 'high';\n\tid: string | undefined;\n\n\tisTrusted?: boolean;\n\tisInvalid?: boolean;\n\t/**\n\t * Track temporarily if the command was recently cleared, this can be used for marker\n\t * adjustments\n\t */\n\twasCleared?: boolean;\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tid?: string\n\t) {\n\t\tthis.id = id ?? generateUuid();\n\t}\n\n\tserialize(cwd: string | undefined): ISerializedTerminalCommand | undefined {\n\t\tif (!this.commandStartMarker) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.commandStartMarker.line,\n\t\t\tstartX: this.commandStartX,\n\t\t\tendLine: undefined,\n\t\t\texecutedLine: undefined,\n\t\t\texecutedX: undefined,\n\t\t\tcommand: '',\n\t\t\tcommandLineConfidence: 'low',\n\t\t\tisTrusted: true,\n\t\t\tcwd,\n\t\t\texitCode: undefined,\n\t\t\tcommandStartLineContent: undefined,\n\t\t\ttimestamp: 0,\n\t\t\tduration: 0,\n\t\t\tmarkProperties: undefined,\n\t\t\tid: this.id\n\t\t};\n\t}\n\n\tpromoteToFullCommand(cwd: string | undefined, exitCode: number | undefined, ignoreCommandLine: boolean, markProperties: IMarkProperties | undefined): TerminalCommand | undefined {\n\t\t// When the command finishes and executed never fires the placeholder selector should be used.\n\t\tif (exitCode === undefined && this.command === undefined) {\n\t\t\tthis.command = '';\n\t\t}\n\n\t\tif ((this.command !== undefined && !this.command.startsWith('\\\\')) || ignoreCommandLine) {\n\t\t\treturn new TerminalCommand(this._xterm, {\n\t\t\t\tcommand: ignoreCommandLine ? '' : (this.command || ''),\n\t\t\t\tcommandLineConfidence: ignoreCommandLine ? 'low' : (this.commandLineConfidence || 'low'),\n\t\t\t\tisTrusted: !!this.isTrusted,\n\t\t\t\tid: this.id,\n\t\t\t\tpromptStartMarker: this.promptStartMarker,\n\t\t\t\tmarker: this.commandStartMarker,\n\t\t\t\tstartX: this.commandStartX,\n\t\t\t\tendMarker: this.commandFinishedMarker,\n\t\t\t\texecutedMarker: this.commandExecutedMarker,\n\t\t\t\texecutedX: this.commandExecutedX,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tduration: this.commandDuration || 0,\n\t\t\t\tcwd,\n\t\t\t\texitCode,\n\t\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\t\tmarkProperties\n\t\t\t});\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tmarkExecutedTime() {\n\t\tif (this.commandExecutedTimestamp === undefined) {\n\t\t\tthis.commandExecutedTimestamp = Date.now();\n\t\t}\n\t}\n\n\tmarkFinishedTime() {\n\t\tif (this.commandDuration === undefined && this.commandExecutedTimestamp !== undefined) {\n\t\t\tthis.commandDuration = Date.now() - this.commandExecutedTimestamp;\n\t\t}\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(this._xterm.buffer.active, this._xterm.cols, this.commandStartMarker, this.commandStartX, this.commandExecutedMarker, this.commandExecutedX);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nfunction extractCommandLine(\n\tbuffer: IBuffer,\n\tcols: number,\n\tcommandStartMarker: IMarker | undefined,\n\tcommandStartX: number | undefined,\n\tcommandExecutedMarker: IMarker | undefined,\n\tcommandExecutedX: number | undefined\n): string {\n\tif (!commandStartMarker || !commandExecutedMarker || commandStartX === undefined || commandExecutedX === undefined) {\n\t\treturn '';\n\t}\n\tlet content = '';\n\tfor (let i = commandStartMarker.line; i <= commandExecutedMarker.line; i++) {\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, i === commandStartMarker.line ? commandStartX : 0, i === commandExecutedMarker.line ? commandExecutedX : cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048 / cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction countNewLines(regex: RegExp): number {\n\tif (!regex.multiline) {\n\t\treturn 1;\n\t}\n\tconst source = regex.source;\n\tlet count = 1;\n\tlet i = source.indexOf('\\\\n');\n\twhile (i !== -1) {\n\t\tcount++;\n\t\ti = source.indexOf('\\\\n', i + 1);\n\t}\n\treturn count;\n}\n\nfunction getPromptRowCount(command: ITerminalCommand | ICurrentPartialCommand, buffer: IBuffer): number {\n\tconst marker = isFullTerminalCommand(command) ? command.marker : command.commandStartMarker;\n\tif (!marker || !command.promptStartMarker) {\n\t\treturn 1;\n\t}\n\tlet promptRowCount = 1;\n\tlet promptStartLine = command.promptStartMarker.line;\n\t// Trim any leading whitespace-only lines to retain vertical space\n\twhile (promptStartLine < marker.line && (buffer.getLine(promptStartLine)?.translateToString(true) ?? '').length === 0) {\n\t\tpromptStartLine++;\n\t}\n\tpromptRowCount = marker.line - promptStartLine + 1;\n\treturn promptRowCount;\n}\n\nfunction getCommandRowCount(command: ITerminalCommand | ICurrentPartialCommand): number {\n\tconst marker = isFullTerminalCommand(command) ? command.marker : command.commandStartMarker;\n\tconst executedMarker = isFullTerminalCommand(command) ? command.executedMarker : command.commandExecutedMarker;\n\tif (!marker || !executedMarker) {\n\t\treturn 1;\n\t}\n\tconst commandExecutedLine = Math.max(executedMarker.line, marker.line);\n\tlet commandRowCount = commandExecutedLine - marker.line + 1;\n\t// Trim the last line if the cursor X is in the left-most cell\n\tconst executedX = isFullTerminalCommand(command) ? command.executedX : command.commandExecutedX;\n\tif (executedX === 0) {\n\t\tcommandRowCount--;\n\t}\n\treturn commandRowCount;\n}\n\nexport function isFullTerminalCommand(command: ITerminalCommand | ICurrentPartialCommand): command is ITerminalCommand {\n\treturn !!(command as ITerminalCommand).hasOutput;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMarkProperties, ISerializedTerminalCommand, ITerminalCommand } from '../capabilities.js';\nimport { ITerminalOutputMatcher, ITerminalOutputMatch } from '../../terminal.js';\nimport type { IBuffer, IBufferLine, IMarker, Terminal } from '@xterm/headless';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { isString } from '../../../../../base/common/types.js';\n\nexport interface ITerminalCommandProperties {\n\tcommand: string;\n\tcommandLineConfidence: 'low' | 'medium' | 'high';\n\tisTrusted: boolean;\n\ttimestamp: number;\n\tduration: number;\n\tid: string | undefined;\n\tmarker: IMarker | undefined;\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n\texecutedX: number | undefined;\n\tstartX: number | undefined;\n\n\tpromptStartMarker?: IMarker | undefined;\n\tendMarker?: IMarker | undefined;\n\texecutedMarker?: IMarker | undefined;\n\taliases?: string[][] | undefined;\n\twasReplayed?: boolean | undefined;\n}\n\nexport class TerminalCommand implements ITerminalCommand {\n\n\tget command() { return this._properties.command; }\n\tget commandLineConfidence() { return this._properties.commandLineConfidence; }\n\tget isTrusted() { return this._properties.isTrusted; }\n\tget timestamp() { return this._properties.timestamp; }\n\tget duration() { return this._properties.duration; }\n\tget promptStartMarker() { return this._properties.promptStartMarker; }\n\tget marker() { return this._properties.marker; }\n\tget endMarker() { return this._properties.endMarker; }\n\tset endMarker(value: IMarker | undefined) { this._properties.endMarker = value; }\n\tget executedMarker() { return this._properties.executedMarker; }\n\tget aliases() { return this._properties.aliases; }\n\tget wasReplayed() { return this._properties.wasReplayed; }\n\tget cwd() { return this._properties.cwd; }\n\tget exitCode() { return this._properties.exitCode; }\n\tget commandStartLineContent() { return this._properties.commandStartLineContent; }\n\tget markProperties() { return this._properties.markProperties; }\n\tget executedX() { return this._properties.executedX; }\n\tget startX() { return this._properties.startX; }\n\tget id() { return this._properties.id; }\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tprivate readonly _properties: ITerminalCommandProperties,\n\t) {\n\t}\n\n\tstatic deserialize(xterm: Terminal, serialized: ISerializedTerminalCommand & Required<Pick<ISerializedTerminalCommand, 'endLine'>>, isCommandStorageDisabled: boolean): TerminalCommand | undefined {\n\t\tconst buffer = xterm.buffer.normal;\n\t\tconst marker = serialized.startLine !== undefined ? xterm.registerMarker(serialized.startLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\n\t\t// Check for invalid command\n\t\tif (!marker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst promptStartMarker = serialized.promptStartLine !== undefined ? xterm.registerMarker(serialized.promptStartLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\n\t\t// Valid full command\n\t\tconst endMarker = serialized.endLine !== undefined ? xterm.registerMarker(serialized.endLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\tconst executedMarker = serialized.executedLine !== undefined ? xterm.registerMarker(serialized.executedLine - (buffer.baseY + buffer.cursorY)) : undefined;\n\t\tconst newCommand = new TerminalCommand(xterm, {\n\t\t\tcommand: isCommandStorageDisabled ? '' : serialized.command,\n\t\t\tcommandLineConfidence: serialized.commandLineConfidence ?? 'low',\n\t\t\tisTrusted: serialized.isTrusted,\n\t\t\tid: serialized.id,\n\t\t\tpromptStartMarker,\n\t\t\tmarker,\n\t\t\tstartX: serialized.startX,\n\t\t\tendMarker,\n\t\t\texecutedMarker,\n\t\t\texecutedX: serialized.executedX,\n\t\t\ttimestamp: serialized.timestamp,\n\t\t\tduration: serialized.duration,\n\t\t\tcwd: serialized.cwd,\n\t\t\tcommandStartLineContent: serialized.commandStartLineContent,\n\t\t\texitCode: serialized.exitCode,\n\t\t\tmarkProperties: serialized.markProperties,\n\t\t\taliases: undefined,\n\t\t\twasReplayed: true\n\t\t});\n\t\treturn newCommand;\n\t}\n\n\tserialize(isCommandStorageDisabled: boolean): ISerializedTerminalCommand {\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.marker?.line,\n\t\t\tstartX: undefined,\n\t\t\tendLine: this.endMarker?.line,\n\t\t\texecutedLine: this.executedMarker?.line,\n\t\t\texecutedX: this.executedX,\n\t\t\tcommand: isCommandStorageDisabled ? '' : this.command,\n\t\t\tcommandLineConfidence: isCommandStorageDisabled ? 'low' : this.commandLineConfidence,\n\t\t\tisTrusted: this.isTrusted,\n\t\t\tcwd: this.cwd,\n\t\t\texitCode: this.exitCode,\n\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\ttimestamp: this.timestamp,\n\t\t\tduration: this.duration,\n\t\t\tmarkProperties: this.markProperties,\n\t\t\tid: this.id,\n\t\t};\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(this._xterm.buffer.active, this._xterm.cols, this.marker, this.startX, this.executedMarker, this.executedX);\n\t}\n\n\tgetOutput(): string | undefined {\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst startLine = this.executedMarker.line;\n\t\tconst endLine = this.endMarker.line;\n\n\t\tif (startLine === endLine) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet output = '';\n\t\tlet line: IBufferLine | undefined;\n\t\tfor (let i = startLine; i < endLine; i++) {\n\t\t\tline = this._xterm.buffer.active.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toutput += line.translateToString(!line.isWrapped) + (line.isWrapped ? '' : '\\n');\n\t\t}\n\t\treturn output === '' ? undefined : output;\n\t}\n\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined {\n\t\t// TODO: Add back this check? this._ptyHeuristics.value instanceof WindowsPtyHeuristics && (executedMarker?.line === endMarker?.line) ? this._currentCommand.commandStartMarker : executedMarker\n\t\tif (!this.executedMarker || !this.endMarker) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst endLine = this.endMarker.line;\n\t\tif (endLine === -1) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst buffer = this._xterm.buffer.active;\n\t\tconst startLine = Math.max(this.executedMarker.line, 0);\n\t\tconst matcher = outputMatcher.lineMatcher;\n\t\tconst linesToCheck = isString(matcher) ? 1 : outputMatcher.length || countNewLines(matcher);\n\t\tconst lines: string[] = [];\n\t\tlet match: RegExpMatchArray | null | undefined;\n\t\tif (outputMatcher.anchor === 'bottom') {\n\t\t\tfor (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {\n\t\t\t\tlet wrappedLineStart = i;\n\t\t\t\tconst wrappedLineEnd = i;\n\t\t\t\twhile (wrappedLineStart >= startLine && buffer.getLine(wrappedLineStart)?.isWrapped) {\n\t\t\t\t\twrappedLineStart--;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineStart;\n\t\t\t\tlines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, this._xterm.cols));\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[0].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {\n\t\t\t\tconst wrappedLineStart = i;\n\t\t\t\tlet wrappedLineEnd = i;\n\t\t\t\twhile (wrappedLineEnd + 1 < endLine && buffer.getLine(wrappedLineEnd + 1)?.isWrapped) {\n\t\t\t\t\twrappedLineEnd++;\n\t\t\t\t}\n\t\t\t\ti = wrappedLineEnd;\n\t\t\t\tlines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, this._xterm.cols));\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = lines[lines.length - 1].match(matcher);\n\t\t\t\t}\n\t\t\t\tif (lines.length >= linesToCheck) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match ? { regexMatch: match, outputLines: lines } : undefined;\n\t}\n\n\thasOutput(): boolean {\n\t\treturn (\n\t\t\t!this.executedMarker?.isDisposed &&\n\t\t\t!this.endMarker?.isDisposed &&\n\t\t\t!!(\n\t\t\t\tthis.executedMarker &&\n\t\t\t\tthis.endMarker &&\n\t\t\t\tthis.executedMarker.line < this.endMarker.line\n\t\t\t)\n\t\t);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nexport interface ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcommand?: string;\n\n\t/**\n\t * Whether the command line is trusted via a nonce.\n\t */\n\tisTrusted?: boolean;\n\n\t/**\n\t * Something invalidated the command before it finished, this will prevent the onCommandFinished\n\t * event from firing.\n\t */\n\tisInvalid?: boolean;\n\n\tgetPromptRowCount(): number;\n\tgetCommandRowCount(): number;\n}\n\nexport class PartialTerminalCommand implements ICurrentPartialCommand {\n\tpromptStartMarker?: IMarker;\n\n\tcommandStartMarker?: IMarker;\n\tcommandStartX?: number;\n\tcommandStartLineContent?: string;\n\n\tcommandRightPromptStartX?: number;\n\tcommandRightPromptEndX?: number;\n\n\tcommandLines?: IMarker;\n\n\tcommandExecutedMarker?: IMarker;\n\tcommandExecutedX?: number;\n\n\tprivate commandExecutedTimestamp?: number;\n\tprivate commandDuration?: number;\n\n\tcommandFinishedMarker?: IMarker;\n\n\tcurrentContinuationMarker?: IMarker;\n\tcontinuations?: { marker: IMarker; end: number }[];\n\n\tcwd?: string;\n\tcommand?: string;\n\tcommandLineConfidence?: 'low' | 'medium' | 'high';\n\tid: string | undefined;\n\n\tisTrusted?: boolean;\n\tisInvalid?: boolean;\n\t/**\n\t * Track temporarily if the command was recently cleared, this can be used for marker\n\t * adjustments\n\t */\n\twasCleared?: boolean;\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tid?: string\n\t) {\n\t\tthis.id = id ?? generateUuid();\n\t}\n\n\tserialize(cwd: string | undefined): ISerializedTerminalCommand | undefined {\n\t\tif (!this.commandStartMarker) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpromptStartLine: this.promptStartMarker?.line,\n\t\t\tstartLine: this.commandStartMarker.line,\n\t\t\tstartX: this.commandStartX,\n\t\t\tendLine: undefined,\n\t\t\texecutedLine: undefined,\n\t\t\texecutedX: undefined,\n\t\t\tcommand: '',\n\t\t\tcommandLineConfidence: 'low',\n\t\t\tisTrusted: true,\n\t\t\tcwd,\n\t\t\texitCode: undefined,\n\t\t\tcommandStartLineContent: undefined,\n\t\t\ttimestamp: 0,\n\t\t\tduration: 0,\n\t\t\tmarkProperties: undefined,\n\t\t\tid: this.id\n\t\t};\n\t}\n\n\tpromoteToFullCommand(cwd: string | undefined, exitCode: number | undefined, ignoreCommandLine: boolean, markProperties: IMarkProperties | undefined): TerminalCommand | undefined {\n\t\t// When the command finishes and executed never fires the placeholder selector should be used.\n\t\tif (exitCode === undefined && this.command === undefined) {\n\t\t\tthis.command = '';\n\t\t}\n\n\t\tif ((this.command !== undefined && !this.command.startsWith('\\\\')) || ignoreCommandLine) {\n\t\t\treturn new TerminalCommand(this._xterm, {\n\t\t\t\tcommand: ignoreCommandLine ? '' : (this.command || ''),\n\t\t\t\tcommandLineConfidence: ignoreCommandLine ? 'low' : (this.commandLineConfidence || 'low'),\n\t\t\t\tisTrusted: !!this.isTrusted,\n\t\t\t\tid: this.id,\n\t\t\t\tpromptStartMarker: this.promptStartMarker,\n\t\t\t\tmarker: this.commandStartMarker,\n\t\t\t\tstartX: this.commandStartX,\n\t\t\t\tendMarker: this.commandFinishedMarker,\n\t\t\t\texecutedMarker: this.commandExecutedMarker,\n\t\t\t\texecutedX: this.commandExecutedX,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tduration: this.commandDuration || 0,\n\t\t\t\tcwd,\n\t\t\t\texitCode,\n\t\t\t\tcommandStartLineContent: this.commandStartLineContent,\n\t\t\t\tmarkProperties\n\t\t\t});\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tmarkExecutedTime() {\n\t\tif (this.commandExecutedTimestamp === undefined) {\n\t\t\tthis.commandExecutedTimestamp = Date.now();\n\t\t}\n\t}\n\n\tmarkFinishedTime() {\n\t\tif (this.commandDuration === undefined && this.commandExecutedTimestamp !== undefined) {\n\t\t\tthis.commandDuration = Date.now() - this.commandExecutedTimestamp;\n\t\t}\n\t}\n\n\textractCommandLine(): string {\n\t\treturn extractCommandLine(this._xterm.buffer.active, this._xterm.cols, this.commandStartMarker, this.commandStartX, this.commandExecutedMarker, this.commandExecutedX);\n\t}\n\n\tgetPromptRowCount(): number {\n\t\treturn getPromptRowCount(this, this._xterm.buffer.active);\n\t}\n\n\tgetCommandRowCount(): number {\n\t\treturn getCommandRowCount(this);\n\t}\n}\n\nfunction extractCommandLine(\n\tbuffer: IBuffer,\n\tcols: number,\n\tcommandStartMarker: IMarker | undefined,\n\tcommandStartX: number | undefined,\n\tcommandExecutedMarker: IMarker | undefined,\n\tcommandExecutedX: number | undefined\n): string {\n\tif (!commandStartMarker || !commandExecutedMarker || commandStartX === undefined || commandExecutedX === undefined) {\n\t\treturn '';\n\t}\n\tlet content = '';\n\tfor (let i = commandStartMarker.line; i <= commandExecutedMarker.line; i++) {\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, i === commandStartMarker.line ? commandStartX : 0, i === commandExecutedMarker.line ? commandExecutedX : cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048 / cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nfunction countNewLines(regex: RegExp): number {\n\tif (!regex.multiline) {\n\t\treturn 1;\n\t}\n\tconst source = regex.source;\n\tlet count = 1;\n\tlet i = source.indexOf('\\\\n');\n\twhile (i !== -1) {\n\t\tcount++;\n\t\ti = source.indexOf('\\\\n', i + 1);\n\t}\n\treturn count;\n}\n\nfunction getPromptRowCount(command: ITerminalCommand | ICurrentPartialCommand, buffer: IBuffer): number {\n\tconst marker = isFullTerminalCommand(command) ? command.marker : command.commandStartMarker;\n\tif (!marker || !command.promptStartMarker) {\n\t\treturn 1;\n\t}\n\tlet promptRowCount = 1;\n\tlet promptStartLine = command.promptStartMarker.line;\n\t// Trim any leading whitespace-only lines to retain vertical space\n\twhile (promptStartLine < marker.line && (buffer.getLine(promptStartLine)?.translateToString(true) ?? '').length === 0) {\n\t\tpromptStartLine++;\n\t}\n\tpromptRowCount = marker.line - promptStartLine + 1;\n\treturn promptRowCount;\n}\n\nfunction getCommandRowCount(command: ITerminalCommand | ICurrentPartialCommand): number {\n\tconst marker = isFullTerminalCommand(command) ? command.marker : command.commandStartMarker;\n\tconst executedMarker = isFullTerminalCommand(command) ? command.executedMarker : command.commandExecutedMarker;\n\tif (!marker || !executedMarker) {\n\t\treturn 1;\n\t}\n\tconst commandExecutedLine = Math.max(executedMarker.line, marker.line);\n\tlet commandRowCount = commandExecutedLine - marker.line + 1;\n\t// Trim the last line if the cursor X is in the left-most cell\n\tconst executedX = isFullTerminalCommand(command) ? command.executedX : command.commandExecutedX;\n\tif (executedX === 0) {\n\t\tcommandRowCount--;\n\t}\n\treturn commandRowCount;\n}\n\nexport function isFullTerminalCommand(command: ITerminalCommand | ICurrentPartialCommand): command is ITerminalCommand {\n\treturn !!(command as ITerminalCommand).hasOutput;\n}\n"]}