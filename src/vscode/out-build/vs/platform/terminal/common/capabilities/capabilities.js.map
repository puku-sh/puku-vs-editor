{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/capabilities/capabilities.ts","vs/platform/terminal/common/capabilities/capabilities.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAShG;;;GAGG;AACH,MAAM,CAAN,IAAkB,kBAqCjB;AArCD,WAAkB,kBAAkB;IACnC;;;OAGG;IACH,2EAAY,CAAA;IACZ;;OAEG;IACH,qFAAiB,CAAA;IACjB;;OAEG;IACH,mFAAgB,CAAA;IAChB;;;;OAIG;IACH,iGAAuB,CAAA;IAEvB;;;;OAIG;IACH,yFAAmB,CAAA;IAEnB;;OAEG;IACH,qFAAiB,CAAA;IAEjB;;OAEG;IACH,yFAAmB,CAAA;AACpB,CAAC,EArCiB,kBAAkB,KAAlB,kBAAkB,QAqCnC;AAwID,MAAM,CAAN,IAAkB,yBAGjB;AAHD,WAAkB,yBAAyB;IAC1C,gDAAmB,CAAA;IACnB,sEAAyC,CAAA;AAC1C,CAAC,EAHiB,yBAAyB,KAAzB,yBAAyB,QAG1C","file":"capabilities.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport type { IPromptInputModel, ISerializedPromptInputModel } from './commandDetection/promptInputModel.js';\nimport { ICurrentPartialCommand } from './commandDetection/terminalCommand.js';\nimport { ITerminalOutputMatch, ITerminalOutputMatcher } from '../terminal.js';\nimport { ReplayEntry } from '../terminalProcess.js';\nimport type { IMarker } from '@xterm/headless';\n\n/**\n * Primarily driven by the shell integration feature, a terminal capability is the mechanism for\n * progressively enhancing various features that may not be supported in all terminals/shells.\n */\nexport const enum TerminalCapability {\n\t/**\n\t * The terminal can reliably detect the current working directory as soon as the change happens\n\t * within the buffer.\n\t */\n\tCwdDetection,\n\t/**\n\t * The terminal can reliably detect the current working directory when requested.\n\t */\n\tNaiveCwdDetection,\n\t/**\n\t * The terminal can reliably identify prompts, commands and command outputs within the buffer.\n\t */\n\tCommandDetection,\n\t/**\n\t * The terminal can often identify prompts, commands and command outputs within the buffer. It\n\t * may not be so good at remembering the position of commands that ran in the past. This state\n\t * may be enabled when something goes wrong or when using conpty for example.\n\t */\n\tPartialCommandDetection,\n\n\t/**\n\t * Manages buffer marks that can be used for terminal navigation. The source of\n\t * the request (task, debug, etc) provides an ID, optional marker, hoverMessage, and hidden property. When\n\t * hidden is not provided, a generic decoration is added to the buffer and overview ruler.\n\t */\n\tBufferMarkDetection,\n\n\t/**\n\t * The terminal can detect the latest environment of user's current shell.\n\t */\n\tShellEnvDetection,\n\n\t/**\n\t * The terminal can detect the prompt type being used (e.g., p10k, posh-git).\n\t */\n\tPromptTypeDetection,\n}\n\n/**\n * An object that keeps track of additional capabilities and their implementations for features that\n * are not available for all terminals.\n */\nexport interface ITerminalCapabilityStore {\n\t/**\n\t * An iterable of all capabilities in the store.\n\t */\n\treadonly items: IterableIterator<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added.\n\t */\n\treadonly onDidAddCapability: Event<AnyTerminalCapabilityChangeEvent>;\n\n\t/**\n\t * Fired when a capability is removed.\n\t*/\n\treadonly onDidRemoveCapability: Event<AnyTerminalCapabilityChangeEvent>;\n\n\t/**\n\t * Fired when a capability if added or removed.\n\t */\n\treadonly onDidChangeCapabilities: Event<void>;\n\n\t/** Fired when the command detection capability is added. */\n\treadonly onDidAddCommandDetectionCapability: Event<ICommandDetectionCapability>;\n\t/** Fired when the command detection capability is removed. */\n\treadonly onDidRemoveCommandDetectionCapability: Event<void>;\n\t/** Fired when the cwd detection capability is added. */\n\treadonly onDidAddCwdDetectionCapability: Event<ICwdDetectionCapability>;\n\t/** Fired when the cwd detection capability is removed. */\n\treadonly onDidRemoveCwdDetectionCapability: Event<void>;\n\n\t/**\n\t * Create an event that's fired when a specific capability type is added. Use this over\n\t * {@link onDidAddCapability} when the generic type needs to be retained.\n\t * @param type The capability type.\n\t */\n\tcreateOnDidAddCapabilityOfTypeEvent<T extends TerminalCapability>(type: T): Event<ITerminalCapabilityImplMap[T]>;\n\n\t/**\n\t * Create an event that's fired when a specific capability type is removed. Use this over\n\t * {@link onDidRemoveCapability} when the generic type needs to be retained.\n\t * @param type The capability type.\n\t */\n\tcreateOnDidRemoveCapabilityOfTypeEvent<T extends TerminalCapability>(type: T): Event<ITerminalCapabilityImplMap[T]>;\n\n\t/**\n\t * Gets whether the capability exists in the store.\n\t */\n\thas(capability: TerminalCapability): boolean;\n\n\t/**\n\t * Gets the implementation of a capability if it has been added to the store.\n\t */\n\tget<T extends TerminalCapability>(capability: T): ITerminalCapabilityImplMap[T] | undefined;\n}\n\nexport interface TerminalCapabilityChangeEvent<T extends TerminalCapability> {\n\tid: T;\n\tcapability: ITerminalCapabilityImplMap[T];\n}\n\nexport type AnyTerminalCapabilityChangeEvent = {\n\t[K in TerminalCapability]: TerminalCapabilityChangeEvent<K>\n}[TerminalCapability];\n\n/**\n * Maps capability types to their implementation, enabling strongly typed fetching of\n * implementations.\n */\nexport interface ITerminalCapabilityImplMap {\n\t[TerminalCapability.CwdDetection]: ICwdDetectionCapability;\n\t[TerminalCapability.CommandDetection]: ICommandDetectionCapability;\n\t[TerminalCapability.NaiveCwdDetection]: INaiveCwdDetectionCapability;\n\t[TerminalCapability.PartialCommandDetection]: IPartialCommandDetectionCapability;\n\t[TerminalCapability.BufferMarkDetection]: IBufferMarkCapability;\n\t[TerminalCapability.ShellEnvDetection]: IShellEnvDetectionCapability;\n\t[TerminalCapability.PromptTypeDetection]: IPromptTypeDetectionCapability;\n}\n\nexport interface ICwdDetectionCapability {\n\treadonly type: TerminalCapability.CwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\treadonly cwds: string[];\n\tgetCwd(): string;\n\tupdateCwd(cwd: string): void;\n}\n\nexport interface IShellEnvDetectionCapability {\n\treadonly type: TerminalCapability.ShellEnvDetection;\n\treadonly onDidChangeEnv: Event<TerminalShellIntegrationEnvironment>;\n\tget env(): TerminalShellIntegrationEnvironment;\n\tsetEnvironment(envs: { [key: string]: string | undefined } | undefined, isTrusted: boolean): void;\n\tstartEnvironmentSingleVar(clear: boolean, isTrusted: boolean): void;\n\tsetEnvironmentSingleVar(key: string, value: string | undefined, isTrusted: boolean): void;\n\tdeleteEnvironmentSingleVar(key: string, value: string | undefined, isTrusted: boolean): void;\n\tendEnvironmentSingleVar(isTrusted: boolean): void;\n}\n\nexport interface IPromptTypeDetectionCapability {\n\treadonly type: TerminalCapability.PromptTypeDetection;\n\treadonly promptType: string | undefined;\n\treadonly onPromptTypeChanged: Event<string | undefined>;\n\tsetPromptType(value: string): void;\n}\n\nexport interface TerminalShellIntegrationEnvironment {\n\t/**\n\t * The dictionary of environment variables.\n\t */\n\tvalue: { [key: string]: string | undefined } | undefined;\n\n\t/**\n\t * Whether the environment came from a trusted source and is therefore safe to use its\n\t * values in a manner that could lead to execution of arbitrary code. If this value is\n\t * `false`, {@link value} should either not be used for something that could lead to arbitrary\n\t * code execution, or the user should be warned beforehand.\n\t *\n\t * This is `true` only when the environment was reported explicitly and it used a nonce for\n\t * verification.\n\t */\n\tisTrusted: boolean;\n}\n\nexport interface TerminalShellIntegration {\n\t/**\n\t * The environment of the shell process. This is undefined if the shell integration script\n\t * does not send the environment.\n\t */\n\treadonly env: TerminalShellIntegrationEnvironment;\n}\n\nexport const enum CommandInvalidationReason {\n\tWindows = 'windows',\n\tNoProblemsReported = 'noProblemsReported'\n}\n\nexport interface ICommandInvalidationRequest {\n\treason: CommandInvalidationReason;\n}\n\nexport interface IBufferMarkCapability {\n\ttype: TerminalCapability.BufferMarkDetection;\n\tmarkers(): IterableIterator<IMarker>;\n\treadonly onMarkAdded: Event<IMarkProperties>;\n\taddMark(properties?: IMarkProperties): void;\n\tgetMark(id: string): IMarker | undefined;\n}\n\nexport interface ICommandDetectionCapability {\n\treadonly type: TerminalCapability.CommandDetection;\n\treadonly promptInputModel: IPromptInputModel;\n\treadonly commands: readonly ITerminalCommand[];\n\t/** The command currently being executed, otherwise undefined. */\n\treadonly executingCommand: string | undefined;\n\treadonly executingCommandObject: ITerminalCommand | undefined;\n\treadonly executingCommandConfidence: 'low' | 'medium' | 'high' | undefined;\n\t/** The current cwd at the cursor's position. */\n\treadonly cwd: string | undefined;\n\treadonly hasRichCommandDetection: boolean;\n\treadonly currentCommand: ICurrentPartialCommand | undefined;\n\treadonly onCommandStarted: Event<ITerminalCommand>;\n\treadonly onCommandFinished: Event<ITerminalCommand>;\n\treadonly onCommandExecuted: Event<ITerminalCommand>;\n\treadonly onCommandInvalidated: Event<ITerminalCommand[]>;\n\treadonly onCurrentCommandInvalidated: Event<ICommandInvalidationRequest>;\n\treadonly onSetRichCommandDetection: Event<boolean>;\n\tsetContinuationPrompt(value: string): void;\n\tsetPromptTerminator(value: string, lastPromptLine: string): void;\n\tsetCwd(value: string): void;\n\tsetIsWindowsPty(value: boolean): void;\n\tsetIsCommandStorageDisabled(): void;\n\t/**\n\t * Gets the working directory for a line, this will return undefined if it's unknown in which\n\t * case the terminal's initial cwd should be used.\n\t */\n\tgetCwdForLine(line: number): string | undefined;\n\tgetCommandForLine(line: number): ITerminalCommand | ICurrentPartialCommand | undefined;\n\thandlePromptStart(options?: IHandleCommandOptions): void;\n\thandleContinuationStart(): void;\n\thandleContinuationEnd(): void;\n\thandleRightPromptStart(): void;\n\thandleRightPromptEnd(): void;\n\thandleCommandStart(options?: IHandleCommandOptions): void;\n\thandleCommandExecuted(options?: IHandleCommandOptions): void;\n\thandleCommandFinished(exitCode?: number, options?: IHandleCommandOptions): void;\n\tsetHasRichCommandDetection(value: boolean): void;\n\t/**\n\t * Set the command line explicitly.\n\t * @param commandLine The command line being set.\n\t * @param isTrusted Whether the command line is trusted via the optional nonce is send in order\n\t * to prevent spoofing. This is important as some interactions do not require verification\n\t * before re-running a command. Note that this is optional according to the spec, it should\n\t * always be present when running the _builtin_ SI scripts.\n\t */\n\tsetCommandLine(commandLine: string, isTrusted: boolean): void;\n\t/**\n\t * Sets the command ID to use for the next command that starts.\n\t * This allows pre-assigning an ID before the shell sends the command start sequence,\n\t * which is useful for linking commands across renderer and ptyHost.\n\t */\n\tsetNextCommandId(command: string, commandId: string): void;\n\tserialize(): ISerializedCommandDetectionCapability;\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n}\n\nexport interface IHandleCommandOptions {\n\t/**\n\t * Whether to allow an empty command to be registered. This should be used to support certain\n\t * shell integration scripts/features where tracking the command line may not be possible.\n\t */\n\tignoreCommandLine?: boolean;\n\t/**\n\t * The marker to use\n\t */\n\tmarker?: IMarker;\n\n\t/**\n\t * Properties for the mark\n\t */\n\tmarkProperties?: IMarkProperties;\n}\n\nexport interface INaiveCwdDetectionCapability {\n\treadonly type: TerminalCapability.NaiveCwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\tgetCwd(): Promise<string>;\n}\n\nexport interface IPartialCommandDetectionCapability {\n\treadonly type: TerminalCapability.PartialCommandDetection;\n\treadonly commands: readonly IMarker[];\n\treadonly onCommandFinished: Event<IMarker>;\n}\n\ninterface IBaseTerminalCommand {\n\t// Mandatory\n\tcommand: string;\n\tcommandLineConfidence: 'low' | 'medium' | 'high';\n\tisTrusted: boolean;\n\ttimestamp: number;\n\tduration: number;\n\tid: string | undefined;\n\n\t// Optional serializable\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n\texecutedX: number | undefined;\n\tstartX: number | undefined;\n}\n\nexport interface ITerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable\n\treadonly promptStartMarker?: IMarker;\n\treadonly marker?: IMarker;\n\tendMarker?: IMarker;\n\treadonly executedMarker?: IMarker;\n\treadonly aliases?: string[][];\n\treadonly wasReplayed?: boolean;\n\n\textractCommandLine(): string;\n\tgetOutput(): string | undefined;\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined;\n\thasOutput(): boolean;\n\tgetPromptRowCount(): number;\n\tgetCommandRowCount(): number;\n}\n\nexport interface ISerializedTerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable converted for serialization\n\tstartLine: number | undefined;\n\tpromptStartLine: number | undefined;\n\tendLine: number | undefined;\n\texecutedLine: number | undefined;\n}\n\n/**\n * A clone of the IMarker from xterm which cannot be imported from common\n */\n// export interface IMarker {\n// \treadonly id: number;\n// \treadonly isDisposed: boolean;\n// \treadonly line: number;\n// \tdispose(): void;\n// \tonDispose: {\n// \t\t(listener: () => any): { dispose(): void };\n// \t};\n// }\n\nexport interface IMarkProperties {\n\thoverMessage?: string;\n\tdisableCommandStorage?: boolean;\n\thidden?: boolean;\n\tmarker?: IMarker;\n\tid?: string;\n}\nexport interface ISerializedCommandDetectionCapability {\n\tisWindowsPty: boolean;\n\thasRichCommandDetection: boolean;\n\tcommands: ISerializedTerminalCommand[];\n\tpromptInputModel: ISerializedPromptInputModel | undefined;\n}\nexport interface IPtyHostProcessReplayEvent {\n\tevents: ReplayEntry[];\n\tcommands: ISerializedCommandDetectionCapability;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport type { IPromptInputModel, ISerializedPromptInputModel } from './commandDetection/promptInputModel.js';\nimport { ICurrentPartialCommand } from './commandDetection/terminalCommand.js';\nimport { ITerminalOutputMatch, ITerminalOutputMatcher } from '../terminal.js';\nimport { ReplayEntry } from '../terminalProcess.js';\nimport type { IMarker } from '@xterm/headless';\n\n/**\n * Primarily driven by the shell integration feature, a terminal capability is the mechanism for\n * progressively enhancing various features that may not be supported in all terminals/shells.\n */\nexport const enum TerminalCapability {\n\t/**\n\t * The terminal can reliably detect the current working directory as soon as the change happens\n\t * within the buffer.\n\t */\n\tCwdDetection,\n\t/**\n\t * The terminal can reliably detect the current working directory when requested.\n\t */\n\tNaiveCwdDetection,\n\t/**\n\t * The terminal can reliably identify prompts, commands and command outputs within the buffer.\n\t */\n\tCommandDetection,\n\t/**\n\t * The terminal can often identify prompts, commands and command outputs within the buffer. It\n\t * may not be so good at remembering the position of commands that ran in the past. This state\n\t * may be enabled when something goes wrong or when using conpty for example.\n\t */\n\tPartialCommandDetection,\n\n\t/**\n\t * Manages buffer marks that can be used for terminal navigation. The source of\n\t * the request (task, debug, etc) provides an ID, optional marker, hoverMessage, and hidden property. When\n\t * hidden is not provided, a generic decoration is added to the buffer and overview ruler.\n\t */\n\tBufferMarkDetection,\n\n\t/**\n\t * The terminal can detect the latest environment of user's current shell.\n\t */\n\tShellEnvDetection,\n\n\t/**\n\t * The terminal can detect the prompt type being used (e.g., p10k, posh-git).\n\t */\n\tPromptTypeDetection,\n}\n\n/**\n * An object that keeps track of additional capabilities and their implementations for features that\n * are not available for all terminals.\n */\nexport interface ITerminalCapabilityStore {\n\t/**\n\t * An iterable of all capabilities in the store.\n\t */\n\treadonly items: IterableIterator<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added.\n\t */\n\treadonly onDidAddCapability: Event<AnyTerminalCapabilityChangeEvent>;\n\n\t/**\n\t * Fired when a capability is removed.\n\t*/\n\treadonly onDidRemoveCapability: Event<AnyTerminalCapabilityChangeEvent>;\n\n\t/**\n\t * Fired when a capability if added or removed.\n\t */\n\treadonly onDidChangeCapabilities: Event<void>;\n\n\t/** Fired when the command detection capability is added. */\n\treadonly onDidAddCommandDetectionCapability: Event<ICommandDetectionCapability>;\n\t/** Fired when the command detection capability is removed. */\n\treadonly onDidRemoveCommandDetectionCapability: Event<void>;\n\t/** Fired when the cwd detection capability is added. */\n\treadonly onDidAddCwdDetectionCapability: Event<ICwdDetectionCapability>;\n\t/** Fired when the cwd detection capability is removed. */\n\treadonly onDidRemoveCwdDetectionCapability: Event<void>;\n\n\t/**\n\t * Create an event that's fired when a specific capability type is added. Use this over\n\t * {@link onDidAddCapability} when the generic type needs to be retained.\n\t * @param type The capability type.\n\t */\n\tcreateOnDidAddCapabilityOfTypeEvent<T extends TerminalCapability>(type: T): Event<ITerminalCapabilityImplMap[T]>;\n\n\t/**\n\t * Create an event that's fired when a specific capability type is removed. Use this over\n\t * {@link onDidRemoveCapability} when the generic type needs to be retained.\n\t * @param type The capability type.\n\t */\n\tcreateOnDidRemoveCapabilityOfTypeEvent<T extends TerminalCapability>(type: T): Event<ITerminalCapabilityImplMap[T]>;\n\n\t/**\n\t * Gets whether the capability exists in the store.\n\t */\n\thas(capability: TerminalCapability): boolean;\n\n\t/**\n\t * Gets the implementation of a capability if it has been added to the store.\n\t */\n\tget<T extends TerminalCapability>(capability: T): ITerminalCapabilityImplMap[T] | undefined;\n}\n\nexport interface TerminalCapabilityChangeEvent<T extends TerminalCapability> {\n\tid: T;\n\tcapability: ITerminalCapabilityImplMap[T];\n}\n\nexport type AnyTerminalCapabilityChangeEvent = {\n\t[K in TerminalCapability]: TerminalCapabilityChangeEvent<K>\n}[TerminalCapability];\n\n/**\n * Maps capability types to their implementation, enabling strongly typed fetching of\n * implementations.\n */\nexport interface ITerminalCapabilityImplMap {\n\t[TerminalCapability.CwdDetection]: ICwdDetectionCapability;\n\t[TerminalCapability.CommandDetection]: ICommandDetectionCapability;\n\t[TerminalCapability.NaiveCwdDetection]: INaiveCwdDetectionCapability;\n\t[TerminalCapability.PartialCommandDetection]: IPartialCommandDetectionCapability;\n\t[TerminalCapability.BufferMarkDetection]: IBufferMarkCapability;\n\t[TerminalCapability.ShellEnvDetection]: IShellEnvDetectionCapability;\n\t[TerminalCapability.PromptTypeDetection]: IPromptTypeDetectionCapability;\n}\n\nexport interface ICwdDetectionCapability {\n\treadonly type: TerminalCapability.CwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\treadonly cwds: string[];\n\tgetCwd(): string;\n\tupdateCwd(cwd: string): void;\n}\n\nexport interface IShellEnvDetectionCapability {\n\treadonly type: TerminalCapability.ShellEnvDetection;\n\treadonly onDidChangeEnv: Event<TerminalShellIntegrationEnvironment>;\n\tget env(): TerminalShellIntegrationEnvironment;\n\tsetEnvironment(envs: { [key: string]: string | undefined } | undefined, isTrusted: boolean): void;\n\tstartEnvironmentSingleVar(clear: boolean, isTrusted: boolean): void;\n\tsetEnvironmentSingleVar(key: string, value: string | undefined, isTrusted: boolean): void;\n\tdeleteEnvironmentSingleVar(key: string, value: string | undefined, isTrusted: boolean): void;\n\tendEnvironmentSingleVar(isTrusted: boolean): void;\n}\n\nexport interface IPromptTypeDetectionCapability {\n\treadonly type: TerminalCapability.PromptTypeDetection;\n\treadonly promptType: string | undefined;\n\treadonly onPromptTypeChanged: Event<string | undefined>;\n\tsetPromptType(value: string): void;\n}\n\nexport interface TerminalShellIntegrationEnvironment {\n\t/**\n\t * The dictionary of environment variables.\n\t */\n\tvalue: { [key: string]: string | undefined } | undefined;\n\n\t/**\n\t * Whether the environment came from a trusted source and is therefore safe to use its\n\t * values in a manner that could lead to execution of arbitrary code. If this value is\n\t * `false`, {@link value} should either not be used for something that could lead to arbitrary\n\t * code execution, or the user should be warned beforehand.\n\t *\n\t * This is `true` only when the environment was reported explicitly and it used a nonce for\n\t * verification.\n\t */\n\tisTrusted: boolean;\n}\n\nexport interface TerminalShellIntegration {\n\t/**\n\t * The environment of the shell process. This is undefined if the shell integration script\n\t * does not send the environment.\n\t */\n\treadonly env: TerminalShellIntegrationEnvironment;\n}\n\nexport const enum CommandInvalidationReason {\n\tWindows = 'windows',\n\tNoProblemsReported = 'noProblemsReported'\n}\n\nexport interface ICommandInvalidationRequest {\n\treason: CommandInvalidationReason;\n}\n\nexport interface IBufferMarkCapability {\n\ttype: TerminalCapability.BufferMarkDetection;\n\tmarkers(): IterableIterator<IMarker>;\n\treadonly onMarkAdded: Event<IMarkProperties>;\n\taddMark(properties?: IMarkProperties): void;\n\tgetMark(id: string): IMarker | undefined;\n}\n\nexport interface ICommandDetectionCapability {\n\treadonly type: TerminalCapability.CommandDetection;\n\treadonly promptInputModel: IPromptInputModel;\n\treadonly commands: readonly ITerminalCommand[];\n\t/** The command currently being executed, otherwise undefined. */\n\treadonly executingCommand: string | undefined;\n\treadonly executingCommandObject: ITerminalCommand | undefined;\n\treadonly executingCommandConfidence: 'low' | 'medium' | 'high' | undefined;\n\t/** The current cwd at the cursor's position. */\n\treadonly cwd: string | undefined;\n\treadonly hasRichCommandDetection: boolean;\n\treadonly currentCommand: ICurrentPartialCommand | undefined;\n\treadonly onCommandStarted: Event<ITerminalCommand>;\n\treadonly onCommandFinished: Event<ITerminalCommand>;\n\treadonly onCommandExecuted: Event<ITerminalCommand>;\n\treadonly onCommandInvalidated: Event<ITerminalCommand[]>;\n\treadonly onCurrentCommandInvalidated: Event<ICommandInvalidationRequest>;\n\treadonly onSetRichCommandDetection: Event<boolean>;\n\tsetContinuationPrompt(value: string): void;\n\tsetPromptTerminator(value: string, lastPromptLine: string): void;\n\tsetCwd(value: string): void;\n\tsetIsWindowsPty(value: boolean): void;\n\tsetIsCommandStorageDisabled(): void;\n\t/**\n\t * Gets the working directory for a line, this will return undefined if it's unknown in which\n\t * case the terminal's initial cwd should be used.\n\t */\n\tgetCwdForLine(line: number): string | undefined;\n\tgetCommandForLine(line: number): ITerminalCommand | ICurrentPartialCommand | undefined;\n\thandlePromptStart(options?: IHandleCommandOptions): void;\n\thandleContinuationStart(): void;\n\thandleContinuationEnd(): void;\n\thandleRightPromptStart(): void;\n\thandleRightPromptEnd(): void;\n\thandleCommandStart(options?: IHandleCommandOptions): void;\n\thandleCommandExecuted(options?: IHandleCommandOptions): void;\n\thandleCommandFinished(exitCode?: number, options?: IHandleCommandOptions): void;\n\tsetHasRichCommandDetection(value: boolean): void;\n\t/**\n\t * Set the command line explicitly.\n\t * @param commandLine The command line being set.\n\t * @param isTrusted Whether the command line is trusted via the optional nonce is send in order\n\t * to prevent spoofing. This is important as some interactions do not require verification\n\t * before re-running a command. Note that this is optional according to the spec, it should\n\t * always be present when running the _builtin_ SI scripts.\n\t */\n\tsetCommandLine(commandLine: string, isTrusted: boolean): void;\n\t/**\n\t * Sets the command ID to use for the next command that starts.\n\t * This allows pre-assigning an ID before the shell sends the command start sequence,\n\t * which is useful for linking commands across renderer and ptyHost.\n\t */\n\tsetNextCommandId(command: string, commandId: string): void;\n\tserialize(): ISerializedCommandDetectionCapability;\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n}\n\nexport interface IHandleCommandOptions {\n\t/**\n\t * Whether to allow an empty command to be registered. This should be used to support certain\n\t * shell integration scripts/features where tracking the command line may not be possible.\n\t */\n\tignoreCommandLine?: boolean;\n\t/**\n\t * The marker to use\n\t */\n\tmarker?: IMarker;\n\n\t/**\n\t * Properties for the mark\n\t */\n\tmarkProperties?: IMarkProperties;\n}\n\nexport interface INaiveCwdDetectionCapability {\n\treadonly type: TerminalCapability.NaiveCwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\tgetCwd(): Promise<string>;\n}\n\nexport interface IPartialCommandDetectionCapability {\n\treadonly type: TerminalCapability.PartialCommandDetection;\n\treadonly commands: readonly IMarker[];\n\treadonly onCommandFinished: Event<IMarker>;\n}\n\ninterface IBaseTerminalCommand {\n\t// Mandatory\n\tcommand: string;\n\tcommandLineConfidence: 'low' | 'medium' | 'high';\n\tisTrusted: boolean;\n\ttimestamp: number;\n\tduration: number;\n\tid: string | undefined;\n\n\t// Optional serializable\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n\texecutedX: number | undefined;\n\tstartX: number | undefined;\n}\n\nexport interface ITerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable\n\treadonly promptStartMarker?: IMarker;\n\treadonly marker?: IMarker;\n\tendMarker?: IMarker;\n\treadonly executedMarker?: IMarker;\n\treadonly aliases?: string[][];\n\treadonly wasReplayed?: boolean;\n\n\textractCommandLine(): string;\n\tgetOutput(): string | undefined;\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined;\n\thasOutput(): boolean;\n\tgetPromptRowCount(): number;\n\tgetCommandRowCount(): number;\n}\n\nexport interface ISerializedTerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable converted for serialization\n\tstartLine: number | undefined;\n\tpromptStartLine: number | undefined;\n\tendLine: number | undefined;\n\texecutedLine: number | undefined;\n}\n\n/**\n * A clone of the IMarker from xterm which cannot be imported from common\n */\n// export interface IMarker {\n// \treadonly id: number;\n// \treadonly isDisposed: boolean;\n// \treadonly line: number;\n// \tdispose(): void;\n// \tonDispose: {\n// \t\t(listener: () => any): { dispose(): void };\n// \t};\n// }\n\nexport interface IMarkProperties {\n\thoverMessage?: string;\n\tdisableCommandStorage?: boolean;\n\thidden?: boolean;\n\tmarker?: IMarker;\n\tid?: string;\n}\nexport interface ISerializedCommandDetectionCapability {\n\tisWindowsPty: boolean;\n\thasRichCommandDetection: boolean;\n\tcommands: ISerializedTerminalCommand[];\n\tpromptInputModel: ISerializedPromptInputModel | undefined;\n}\nexport interface IPtyHostProcessReplayEvent {\n\tevents: ReplayEntry[];\n\tcommands: ISerializedCommandDetectionCapability;\n}\n"]}