{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/capabilities/commandDetection/promptInputModel.ts","vs/platform/terminal/common/capabilities/commandDetection/promptInputModel.ts"],"names":[],"mappings":"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","file":"promptInputModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IBuffer, IBufferCell, IBufferLine, IMarker, Terminal } from '@xterm/headless';\nimport { throttle } from '../../../../../base/common/decorators.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ILogService, LogLevel } from '../../../../log/common/log.js';\nimport { PosixShellType, TerminalShellType } from '../../terminal.js';\nimport type { ITerminalCommand } from '../capabilities.js';\n\nexport const enum PromptInputState {\n\tUnknown = 0,\n\tInput = 1,\n\tExecute = 2,\n}\n\n/**\n * A model of the prompt input state using shell integration and analyzing the terminal buffer. This\n * may not be 100% accurate but provides a best guess.\n */\nexport interface IPromptInputModel extends IPromptInputModelState {\n\treadonly state: PromptInputState;\n\n\treadonly onDidStartInput: Event<IPromptInputModelState>;\n\treadonly onDidChangeInput: Event<IPromptInputModelState>;\n\treadonly onDidFinishInput: Event<IPromptInputModelState>;\n\t/**\n\t * Fires immediately before {@link onDidFinishInput} when a SIGINT/Ctrl+C/^C is detected.\n\t */\n\treadonly onDidInterrupt: Event<IPromptInputModelState>;\n\n\t/**\n\t * Gets the prompt input as a user-friendly string where `|` is the cursor position and `[` and\n\t * `]` wrap any ghost text.\n\t *\n\t * @param emptyStringWhenEmpty If true, an empty string is returned when the prompt input is\n\t * empty (as opposed to '|').\n\t */\n\tgetCombinedString(emptyStringWhenEmpty?: boolean): string;\n\n\tsetShellType(shellType?: TerminalShellType): void;\n}\n\nexport interface IPromptInputModelState {\n\t/**\n\t * The full prompt input include ghost text.\n\t */\n\treadonly value: string;\n\t/**\n\t * The prompt input up to the cursor index, this will always exclude the ghost text.\n\t */\n\treadonly prefix: string;\n\t/**\n\t * The prompt input from the cursor to the end, this _does not_ include ghost text.\n\t */\n\treadonly suffix: string;\n\t/**\n\t * The index of the cursor in {@link value}.\n\t */\n\treadonly cursorIndex: number;\n\t/**\n\t * The index of the start of ghost text in {@link value}. This is -1 when there is no ghost\n\t * text.\n\t */\n\treadonly ghostTextIndex: number;\n}\n\nexport interface ISerializedPromptInputModel {\n\treadonly modelState: IPromptInputModelState;\n\treadonly commandStartX: number;\n\treadonly lastPromptLine: string | undefined;\n\treadonly continuationPrompt: string | undefined;\n\treadonly lastUserInput: string;\n}\n\nexport class PromptInputModel extends Disposable implements IPromptInputModel {\n\tprivate _state: PromptInputState = PromptInputState.Unknown;\n\tget state() { return this._state; }\n\n\tprivate _commandStartMarker: IMarker | undefined;\n\tprivate _commandStartX: number = 0;\n\tprivate _lastPromptLine: string | undefined;\n\tprivate _continuationPrompt: string | undefined;\n\tprivate _shellType: TerminalShellType | undefined;\n\n\tprivate _lastUserInput: string = '';\n\n\tprivate _value: string = '';\n\tget value() { return this._value; }\n\tget prefix() { return this._value.substring(0, this._cursorIndex); }\n\tget suffix() { return this._value.substring(this._cursorIndex, this._ghostTextIndex === -1 ? undefined : this._ghostTextIndex); }\n\n\tprivate _cursorIndex: number = 0;\n\tget cursorIndex() { return this._cursorIndex; }\n\n\tprivate _ghostTextIndex: number = -1;\n\tget ghostTextIndex() { return this._ghostTextIndex; }\n\n\tprivate readonly _onDidStartInput = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidStartInput = this._onDidStartInput.event;\n\tprivate readonly _onDidChangeInput = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidChangeInput = this._onDidChangeInput.event;\n\tprivate readonly _onDidFinishInput = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidFinishInput = this._onDidFinishInput.event;\n\tprivate readonly _onDidInterrupt = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidInterrupt = this._onDidInterrupt.event;\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tonCommandStart: Event<ITerminalCommand>,\n\t\tonCommandStartChanged: Event<void>,\n\t\tonCommandExecuted: Event<ITerminalCommand>,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis._register(Event.any(\n\t\t\tthis._xterm.onCursorMove,\n\t\t\tthis._xterm.onData,\n\t\t\tthis._xterm.onWriteParsed,\n\t\t)(() => this._sync()));\n\t\tthis._register(this._xterm.onData(e => this._handleUserInput(e)));\n\n\t\tthis._register(onCommandStart(e => this._handleCommandStart(e as { marker: IMarker })));\n\t\tthis._register(onCommandStartChanged(() => this._handleCommandStartChanged()));\n\t\tthis._register(onCommandExecuted(() => this._handleCommandExecuted()));\n\n\t\tthis._register(this.onDidStartInput(() => this._logCombinedStringIfTrace('PromptInputModel#onDidStartInput')));\n\t\tthis._register(this.onDidChangeInput(() => this._logCombinedStringIfTrace('PromptInputModel#onDidChangeInput')));\n\t\tthis._register(this.onDidFinishInput(() => this._logCombinedStringIfTrace('PromptInputModel#onDidFinishInput')));\n\t\tthis._register(this.onDidInterrupt(() => this._logCombinedStringIfTrace('PromptInputModel#onDidInterrupt')));\n\t}\n\n\tprivate _logCombinedStringIfTrace(message: string) {\n\t\t// Only generate the combined string if trace\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace(message, this.getCombinedString());\n\t\t}\n\t}\n\n\tsetShellType(shellType: TerminalShellType): void {\n\t\tthis._shellType = shellType;\n\t}\n\n\tsetContinuationPrompt(value: string): void {\n\t\tthis._continuationPrompt = value;\n\t\tthis._sync();\n\t}\n\n\tsetLastPromptLine(value: string): void {\n\t\tthis._lastPromptLine = value;\n\t\tthis._sync();\n\t}\n\n\tsetConfidentCommandLine(value: string): void {\n\t\tif (this._value !== value) {\n\t\t\tthis._value = value;\n\t\t\tthis._cursorIndex = -1;\n\t\t\tthis._ghostTextIndex = -1;\n\t\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\t}\n\t}\n\n\tgetCombinedString(emptyStringWhenEmpty?: boolean): string {\n\t\tconst value = this._value.replaceAll('\\n', '\\u23CE');\n\t\tif (this._cursorIndex === -1) {\n\t\t\treturn value;\n\t\t}\n\t\tlet result = `${value.substring(0, this.cursorIndex)}|`;\n\t\tif (this.ghostTextIndex !== -1) {\n\t\t\tresult += `${value.substring(this.cursorIndex, this.ghostTextIndex)}[`;\n\t\t\tresult += `${value.substring(this.ghostTextIndex)}]`;\n\t\t} else {\n\t\t\tresult += value.substring(this.cursorIndex);\n\t\t}\n\t\tif (result === '|' && emptyStringWhenEmpty) {\n\t\t\treturn '';\n\t\t}\n\t\treturn result;\n\t}\n\n\tserialize(): ISerializedPromptInputModel {\n\t\treturn {\n\t\t\tmodelState: this._createStateObject(),\n\t\t\tcommandStartX: this._commandStartX,\n\t\t\tlastPromptLine: this._lastPromptLine,\n\t\t\tcontinuationPrompt: this._continuationPrompt,\n\t\t\tlastUserInput: this._lastUserInput\n\t\t};\n\t}\n\n\tdeserialize(serialized: ISerializedPromptInputModel): void {\n\t\tthis._value = serialized.modelState.value;\n\t\tthis._cursorIndex = serialized.modelState.cursorIndex;\n\t\tthis._ghostTextIndex = serialized.modelState.ghostTextIndex;\n\t\tthis._commandStartX = serialized.commandStartX;\n\t\tthis._lastPromptLine = serialized.lastPromptLine;\n\t\tthis._continuationPrompt = serialized.continuationPrompt;\n\t\tthis._lastUserInput = serialized.lastUserInput;\n\t}\n\n\tprivate _handleCommandStart(command: { marker: IMarker }) {\n\t\tif (this._state === PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._state = PromptInputState.Input;\n\t\tthis._commandStartMarker = command.marker;\n\t\tthis._commandStartX = this._xterm.buffer.active.cursorX;\n\t\tthis._value = '';\n\t\tthis._cursorIndex = 0;\n\t\tthis._onDidStartInput.fire(this._createStateObject());\n\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\n\t\t// Trigger a sync if prompt terminator is set as that could adjust the command start X\n\t\tif (this._lastPromptLine) {\n\t\t\tif (this._commandStartX !== this._lastPromptLine.length) {\n\t\t\t\tconst line = this._xterm.buffer.active.getLine(this._commandStartMarker.line);\n\t\t\t\tif (line?.translateToString(true).startsWith(this._lastPromptLine)) {\n\t\t\t\t\tthis._commandStartX = this._lastPromptLine.length;\n\t\t\t\t\tthis._sync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _handleCommandStartChanged() {\n\t\tif (this._state !== PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._commandStartX = this._xterm.buffer.active.cursorX;\n\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\tthis._sync();\n\t}\n\n\tprivate _handleCommandExecuted() {\n\t\tif (this._state === PromptInputState.Execute) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cursorIndex = -1;\n\n\t\t// Remove any ghost text from the input if it exists on execute\n\t\tif (this._ghostTextIndex !== -1) {\n\t\t\tthis._value = this._value.substring(0, this._ghostTextIndex);\n\t\t\tthis._ghostTextIndex = -1;\n\t\t}\n\n\t\tconst event = this._createStateObject();\n\t\tif (this._lastUserInput === '\\u0003') {\n\t\t\tthis._lastUserInput = '';\n\t\t\tthis._onDidInterrupt.fire(event);\n\t\t}\n\n\t\tthis._state = PromptInputState.Execute;\n\t\tthis._onDidFinishInput.fire(event);\n\t\tthis._onDidChangeInput.fire(event);\n\t}\n\n\t@throttle(0)\n\tprivate _sync() {\n\t\ttry {\n\t\t\tthis._doSync();\n\t\t} catch (e) {\n\t\t\tthis._logService.error('Error while syncing prompt input model', e);\n\t\t}\n\t}\n\n\tprivate _doSync() {\n\t\tif (this._state !== PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet commandStartY = this._commandStartMarker?.line;\n\t\tif (commandStartY === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst buffer = this._xterm.buffer.active;\n\t\tlet line = buffer.getLine(commandStartY);\n\t\tconst absoluteCursorY = buffer.baseY + buffer.cursorY;\n\t\tlet cursorIndex: number | undefined;\n\n\t\tlet commandLine = line?.translateToString(true, this._commandStartX);\n\t\tif (this._shellType === PosixShellType.Fish && (!line || !commandLine)) {\n\t\t\tcommandStartY += 1;\n\t\t\tline = buffer.getLine(commandStartY);\n\t\t\tif (line) {\n\t\t\t\tcommandLine = line.translateToString(true);\n\t\t\t\tcursorIndex = absoluteCursorY === commandStartY ? buffer.cursorX : commandLine?.trimEnd().length;\n\t\t\t}\n\t\t}\n\t\tif (line === undefined || commandLine === undefined) {\n\t\t\tthis._logService.trace(`PromptInputModel#_sync: no line`);\n\t\t\treturn;\n\t\t}\n\n\t\tlet value = commandLine;\n\t\tlet ghostTextIndex = -1;\n\t\tif (cursorIndex === undefined) {\n\t\t\tif (absoluteCursorY === commandStartY) {\n\t\t\t\tcursorIndex = Math.min(this._getRelativeCursorIndex(this._commandStartX, buffer, line), commandLine.length);\n\t\t\t} else {\n\t\t\t\tcursorIndex = commandLine.trimEnd().length;\n\t\t\t}\n\t\t}\n\n\t\t// From command start line to cursor line\n\t\tfor (let y = commandStartY + 1; y <= absoluteCursorY; y++) {\n\t\t\tconst nextLine = buffer.getLine(y);\n\t\t\tconst lineText = nextLine?.translateToString(true);\n\t\t\tif (lineText && nextLine) {\n\t\t\t\t// Check if the line wrapped without a new line (continuation) or\n\t\t\t\t// we're on the last line and the continuation prompt is not present, so we need to add the value\n\t\t\t\tif (nextLine.isWrapped || (absoluteCursorY === y && this._continuationPrompt && !this._lineContainsContinuationPrompt(lineText))) {\n\t\t\t\t\tvalue += `${lineText}`;\n\t\t\t\t\tconst relativeCursorIndex = this._getRelativeCursorIndex(0, buffer, nextLine);\n\t\t\t\t\tif (absoluteCursorY === y) {\n\t\t\t\t\t\tcursorIndex += relativeCursorIndex;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursorIndex += lineText.length;\n\t\t\t\t\t}\n\t\t\t\t} else if (this._shellType === PosixShellType.Fish) {\n\t\t\t\t\tif (value.endsWith('\\\\')) {\n\t\t\t\t\t\t// Trim off the trailing backslash\n\t\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t\t\tvalue += `${lineText.trim()}`;\n\t\t\t\t\t\tcursorIndex += lineText.trim().length - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^ {6,}/.test(lineText)) {\n\t\t\t\t\t\t\t// Was likely a new line\n\t\t\t\t\t\t\tvalue += `\\n${lineText.trim()}`;\n\t\t\t\t\t\t\tcursorIndex += lineText.trim().length + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue += lineText;\n\t\t\t\t\t\t\tcursorIndex += lineText.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Verify continuation prompt if we have it, if this line doesn't have it then the\n\t\t\t\t// user likely just pressed enter.\n\t\t\t\telse if (this._continuationPrompt === undefined || this._lineContainsContinuationPrompt(lineText)) {\n\t\t\t\t\tconst trimmedLineText = this._trimContinuationPrompt(lineText);\n\t\t\t\t\tvalue += `\\n${trimmedLineText}`;\n\t\t\t\t\tif (absoluteCursorY === y) {\n\t\t\t\t\t\tconst continuationCellWidth = this._getContinuationPromptCellWidth(nextLine, lineText);\n\t\t\t\t\t\tconst relativeCursorIndex = this._getRelativeCursorIndex(continuationCellWidth, buffer, nextLine);\n\t\t\t\t\t\tcursorIndex += relativeCursorIndex + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursorIndex += trimmedLineText.length + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Below cursor line\n\t\tfor (let y = absoluteCursorY + 1; y < buffer.baseY + this._xterm.rows; y++) {\n\t\t\tconst belowCursorLine = buffer.getLine(y);\n\t\t\tconst lineText = belowCursorLine?.translateToString(true);\n\t\t\tif (lineText && belowCursorLine) {\n\t\t\t\tif (this._shellType === PosixShellType.Fish) {\n\t\t\t\t\tvalue += `${lineText}`;\n\t\t\t\t} else if (this._continuationPrompt === undefined || this._lineContainsContinuationPrompt(lineText)) {\n\t\t\t\t\tvalue += `\\n${this._trimContinuationPrompt(lineText)}`;\n\t\t\t\t} else {\n\t\t\t\t\tvalue += lineText;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace(`PromptInputModel#_sync: ${this.getCombinedString()}`);\n\t\t}\n\n\t\t// Adjust trailing whitespace\n\t\t{\n\t\t\tlet trailingWhitespace = this._value.length - this._value.trimEnd().length;\n\n\t\t\t// Handle backspace key\n\t\t\tif (this._lastUserInput === '\\x7F') {\n\t\t\t\tthis._lastUserInput = '';\n\t\t\t\tif (cursorIndex === this._cursorIndex - 1) {\n\t\t\t\t\t// If trailing whitespace is being increased by removing a non-whitespace character\n\t\t\t\t\tif (this._value.trimEnd().length > value.trimEnd().length && value.trimEnd().length <= cursorIndex) {\n\t\t\t\t\t\ttrailingWhitespace = Math.max((this._value.length - 1) - value.trimEnd().length, 0);\n\t\t\t\t\t}\n\t\t\t\t\t// Standard case; subtract from trailing whitespace\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrailingWhitespace = Math.max(trailingWhitespace - 1, 0);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle delete key\n\t\t\tif (this._lastUserInput === '\\x1b[3~') {\n\t\t\t\tthis._lastUserInput = '';\n\t\t\t\tif (cursorIndex === this._cursorIndex) {\n\t\t\t\t\ttrailingWhitespace = Math.max(trailingWhitespace - 1, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst valueLines = value.split('\\n');\n\t\t\tconst isMultiLine = valueLines.length > 1;\n\t\t\tconst valueEndTrimmed = value.trimEnd();\n\t\t\tif (!isMultiLine) {\n\t\t\t\t// Adjust trimmed whitespace value based on cursor position\n\t\t\t\tif (valueEndTrimmed.length < value.length) {\n\t\t\t\t\t// Handle space key\n\t\t\t\t\tif (this._lastUserInput === ' ') {\n\t\t\t\t\t\tthis._lastUserInput = '';\n\t\t\t\t\t\tif (cursorIndex > valueEndTrimmed.length && cursorIndex > this._cursorIndex) {\n\t\t\t\t\t\t\ttrailingWhitespace++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttrailingWhitespace = Math.max(cursorIndex - valueEndTrimmed.length, trailingWhitespace, 0);\n\t\t\t\t}\n\n\t\t\t\t// Handle case where a non-space character is inserted in the middle of trailing whitespace\n\t\t\t\tconst charBeforeCursor = cursorIndex === 0 ? '' : value[cursorIndex - 1];\n\t\t\t\tif (trailingWhitespace > 0 && cursorIndex === this._cursorIndex + 1 && this._lastUserInput !== '' && charBeforeCursor !== ' ') {\n\t\t\t\t\ttrailingWhitespace = this._value.length - this._cursorIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isMultiLine) {\n\t\t\t\tvalueLines[valueLines.length - 1] = valueLines.at(-1)?.trimEnd() ?? '';\n\t\t\t\tconst continuationOffset = (valueLines.length - 1) * (this._continuationPrompt?.length ?? 0);\n\t\t\t\ttrailingWhitespace = Math.max(0, cursorIndex - value.length - continuationOffset);\n\t\t\t}\n\n\t\t\tvalue = valueLines.map(e => e.trimEnd()).join('\\n') + ' '.repeat(trailingWhitespace);\n\t\t}\n\n\t\tghostTextIndex = this._scanForGhostText(buffer, line, cursorIndex);\n\n\t\tif (this._value !== value || this._cursorIndex !== cursorIndex || this._ghostTextIndex !== ghostTextIndex) {\n\t\t\tthis._value = value;\n\t\t\tthis._cursorIndex = cursorIndex;\n\t\t\tthis._ghostTextIndex = ghostTextIndex;\n\t\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\t}\n\t}\n\n\tprivate _handleUserInput(e: string) {\n\t\tthis._lastUserInput = e;\n\t}\n\n\t/**\n\t * Detect ghost text by looking for italic or dim text in or after the cursor and\n\t * non-italic/dim text in the first non-whitespace cell following command start and before the cursor.\n\t */\n\tprivate _scanForGhostText(buffer: IBuffer, line: IBufferLine, cursorIndex: number): number {\n\t\tif (!this.value.trim().length) {\n\t\t\treturn -1;\n\t\t}\n\t\t// Check last non-whitespace character has non-ghost text styles\n\t\tlet ghostTextIndex = -1;\n\t\tlet proceedWithGhostTextCheck = false;\n\t\tlet x = buffer.cursorX;\n\t\twhile (x > 0) {\n\t\t\tconst cell = line.getCell(--x);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cell.getChars().trim().length > 0) {\n\t\t\t\tproceedWithGhostTextCheck = !this._isCellStyledLikeGhostText(cell);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Check to the end of the line for possible ghost text. For example pwsh's ghost text\n\t\t// can look like this `Get-|Ch[ildItem]`\n\t\tif (proceedWithGhostTextCheck) {\n\t\t\tlet potentialGhostIndexOffset = 0;\n\t\t\tlet x = buffer.cursorX;\n\n\t\t\twhile (x < line.length) {\n\t\t\t\tconst cell = line.getCell(x++);\n\t\t\t\tif (!cell || cell.getCode() === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._isCellStyledLikeGhostText(cell)) {\n\t\t\t\t\tghostTextIndex = cursorIndex + potentialGhostIndexOffset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tpotentialGhostIndexOffset += cell.getChars().length;\n\t\t\t}\n\t\t}\n\n\t\t// Ghost text may not be italic or dimmed, but will have a different style than the\n\t\t// rest of the line that precedes it.\n\t\tif (ghostTextIndex === -1) {\n\t\t\tghostTextIndex = this._scanForGhostTextAdvanced(buffer, line, cursorIndex);\n\t\t}\n\n\t\tif (ghostTextIndex > -1 && this.value.substring(ghostTextIndex).endsWith(' ')) {\n\t\t\tthis._value = this.value.trim();\n\t\t\tif (!this.value.substring(ghostTextIndex)) {\n\t\t\t\tghostTextIndex = -1;\n\t\t\t}\n\t\t}\n\t\treturn ghostTextIndex;\n\t}\n\n\tprivate _scanForGhostTextAdvanced(buffer: IBuffer, line: IBufferLine, cursorIndex: number): number {\n\t\tlet ghostTextIndex = -1;\n\t\tlet currentPos = buffer.cursorX; // Start scanning from the cursor position\n\n\t\t// Map to store styles and their corresponding positions\n\t\tconst styleMap = new Map<string, number[]>();\n\n\t\t// Identify the last non-whitespace character in the line\n\t\tlet lastNonWhitespaceCell = line.getCell(currentPos);\n\t\tlet nextCell: IBufferCell | undefined = lastNonWhitespaceCell;\n\n\t\t// Scan from the cursor position to the end of the line\n\t\twhile (nextCell && currentPos < line.length) {\n\t\t\tconst styleKey = this._getCellStyleAsString(nextCell);\n\n\t\t\t// Track all occurrences of each unique style in the line\n\t\t\tstyleMap.set(styleKey, [...(styleMap.get(styleKey) ?? []), currentPos]);\n\n\t\t\t// Move to the next cell\n\t\t\tnextCell = line.getCell(++currentPos);\n\n\t\t\t// Update `lastNonWhitespaceCell` only if the new cell contains visible characters\n\t\t\tif (nextCell?.getChars().trim().length) {\n\t\t\t\tlastNonWhitespaceCell = nextCell;\n\t\t\t}\n\t\t}\n\n\t\t// If there's no valid last non-whitespace cell OR the first and last styles match (indicating no ghost text)\n\t\tif (!lastNonWhitespaceCell?.getChars().trim().length ||\n\t\t\tthis._cellStylesMatch(line.getCell(this._commandStartX), lastNonWhitespaceCell)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Retrieve the positions of all cells with the same style as `lastNonWhitespaceCell`\n\t\tconst positionsWithGhostStyle = styleMap.get(this._getCellStyleAsString(lastNonWhitespaceCell));\n\t\tif (positionsWithGhostStyle) {\n\t\t\t// Ghost text must start at the cursor or one char after (e.g. a space)\n\t\t\t// To account for cursor movement, we also ensure there are not 5+ spaces preceding the ghost text position\n\t\t\tif (positionsWithGhostStyle[0] > buffer.cursorX + 1 && this._isPositionRightPrompt(line, positionsWithGhostStyle[0])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// Ensure these positions are contiguous\n\t\t\tfor (let i = 1; i < positionsWithGhostStyle.length; i++) {\n\t\t\t\tif (positionsWithGhostStyle[i] !== positionsWithGhostStyle[i - 1] + 1) {\n\t\t\t\t\t// Discontinuous styles, so may be syntax highlighting vs ghost text\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the ghost text start index\n\t\t\tif (buffer.baseY + buffer.cursorY === this._commandStartMarker?.line) {\n\t\t\t\tghostTextIndex = positionsWithGhostStyle[0] - this._commandStartX;\n\t\t\t} else {\n\t\t\t\tghostTextIndex = positionsWithGhostStyle[0];\n\t\t\t}\n\t\t}\n\n\t\t// Ensure no earlier cells in the line match `lastNonWhitespaceCell`'s style,\n\t\t// which would indicate the text is not ghost text.\n\t\tif (ghostTextIndex !== -1) {\n\t\t\tfor (let checkPos = buffer.cursorX; checkPos >= this._commandStartX; checkPos--) {\n\t\t\t\tconst checkCell = line.getCell(checkPos);\n\t\t\t\tif (!checkCell?.getChars.length) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (checkCell && checkCell.getCode() !== 0 && this._cellStylesMatch(lastNonWhitespaceCell, checkCell)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ghostTextIndex >= cursorIndex ? ghostTextIndex : -1;\n\t}\n\n\t/**\n\t * 5+ spaces preceding the position, following the command start,\n\t * indicates that we're likely in a right prompt at the current position\n\t */\n\tprivate _isPositionRightPrompt(line: IBufferLine, position: number): boolean {\n\t\tlet count = 0;\n\t\tfor (let i = position - 1; i >= this._commandStartX; i--) {\n\t\t\tconst cell = line.getCell(i);\n\t\t\t// treat missing cell or whitespace-only cell as empty; reset count on first non-empty\n\t\t\tif (!cell || cell.getChars().trim().length === 0) {\n\t\t\t\tcount++;\n\t\t\t\t// If we've already found 5 consecutive empties we can early-return\n\t\t\t\tif (count >= 5) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// consecutive sequence broken\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _getCellStyleAsString(cell: IBufferCell): string {\n\t\treturn `${cell.getFgColor()}${cell.getBgColor()}${cell.isBold()}${cell.isItalic()}${cell.isDim()}${cell.isUnderline()}${cell.isBlink()}${cell.isInverse()}${cell.isInvisible()}${cell.isStrikethrough()}${cell.isOverline()}${cell.getFgColorMode()}${cell.getBgColorMode()}`;\n\t}\n\n\tprivate _cellStylesMatch(a: IBufferCell | undefined, b: IBufferCell | undefined): boolean {\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.getFgColor() === b.getFgColor()\n\t\t\t&& a.getBgColor() === b.getBgColor()\n\t\t\t&& a.isBold() === b.isBold()\n\t\t\t&& a.isItalic() === b.isItalic()\n\t\t\t&& a.isDim() === b.isDim()\n\t\t\t&& a.isUnderline() === b.isUnderline()\n\t\t\t&& a.isBlink() === b.isBlink()\n\t\t\t&& a.isInverse() === b.isInverse()\n\t\t\t&& a.isInvisible() === b.isInvisible()\n\t\t\t&& a.isStrikethrough() === b.isStrikethrough()\n\t\t\t&& a.isOverline() === b.isOverline()\n\t\t\t&& a?.getBgColorMode() === b?.getBgColorMode()\n\t\t\t&& a?.getFgColorMode() === b?.getFgColorMode();\n\t}\n\n\tprivate _trimContinuationPrompt(lineText: string): string {\n\t\tif (this._lineContainsContinuationPrompt(lineText)) {\n\t\t\tlineText = lineText.substring(this._continuationPrompt!.length);\n\t\t}\n\t\treturn lineText;\n\t}\n\n\tprivate _lineContainsContinuationPrompt(lineText: string): boolean {\n\t\treturn !!(this._continuationPrompt && lineText.startsWith(this._continuationPrompt.trimEnd()));\n\t}\n\n\tprivate _getContinuationPromptCellWidth(line: IBufferLine, lineText: string): number {\n\t\tif (!this._continuationPrompt || !lineText.startsWith(this._continuationPrompt.trimEnd())) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet buffer = '';\n\t\tlet x = 0;\n\t\tlet cell: IBufferCell | undefined;\n\t\twhile (buffer !== this._continuationPrompt) {\n\t\t\tcell = line.getCell(x++);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuffer += cell.getChars();\n\t\t}\n\t\treturn x;\n\t}\n\n\tprivate _getRelativeCursorIndex(startCellX: number, buffer: IBuffer, line: IBufferLine): number {\n\t\treturn line?.translateToString(false, startCellX, buffer.cursorX).length ?? 0;\n\t}\n\n\tprivate _isCellStyledLikeGhostText(cell: IBufferCell): boolean {\n\t\treturn !!(cell.isItalic() || cell.isDim());\n\t}\n\n\tprivate _createStateObject(): IPromptInputModelState {\n\t\treturn Object.freeze({\n\t\t\tvalue: this._value,\n\t\t\tprefix: this.prefix,\n\t\t\tsuffix: this.suffix,\n\t\t\tcursorIndex: this._cursorIndex,\n\t\t\tghostTextIndex: this._ghostTextIndex\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IBuffer, IBufferCell, IBufferLine, IMarker, Terminal } from '@xterm/headless';\nimport { throttle } from '../../../../../base/common/decorators.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ILogService, LogLevel } from '../../../../log/common/log.js';\nimport { PosixShellType, TerminalShellType } from '../../terminal.js';\nimport type { ITerminalCommand } from '../capabilities.js';\n\nexport const enum PromptInputState {\n\tUnknown = 0,\n\tInput = 1,\n\tExecute = 2,\n}\n\n/**\n * A model of the prompt input state using shell integration and analyzing the terminal buffer. This\n * may not be 100% accurate but provides a best guess.\n */\nexport interface IPromptInputModel extends IPromptInputModelState {\n\treadonly state: PromptInputState;\n\n\treadonly onDidStartInput: Event<IPromptInputModelState>;\n\treadonly onDidChangeInput: Event<IPromptInputModelState>;\n\treadonly onDidFinishInput: Event<IPromptInputModelState>;\n\t/**\n\t * Fires immediately before {@link onDidFinishInput} when a SIGINT/Ctrl+C/^C is detected.\n\t */\n\treadonly onDidInterrupt: Event<IPromptInputModelState>;\n\n\t/**\n\t * Gets the prompt input as a user-friendly string where `|` is the cursor position and `[` and\n\t * `]` wrap any ghost text.\n\t *\n\t * @param emptyStringWhenEmpty If true, an empty string is returned when the prompt input is\n\t * empty (as opposed to '|').\n\t */\n\tgetCombinedString(emptyStringWhenEmpty?: boolean): string;\n\n\tsetShellType(shellType?: TerminalShellType): void;\n}\n\nexport interface IPromptInputModelState {\n\t/**\n\t * The full prompt input include ghost text.\n\t */\n\treadonly value: string;\n\t/**\n\t * The prompt input up to the cursor index, this will always exclude the ghost text.\n\t */\n\treadonly prefix: string;\n\t/**\n\t * The prompt input from the cursor to the end, this _does not_ include ghost text.\n\t */\n\treadonly suffix: string;\n\t/**\n\t * The index of the cursor in {@link value}.\n\t */\n\treadonly cursorIndex: number;\n\t/**\n\t * The index of the start of ghost text in {@link value}. This is -1 when there is no ghost\n\t * text.\n\t */\n\treadonly ghostTextIndex: number;\n}\n\nexport interface ISerializedPromptInputModel {\n\treadonly modelState: IPromptInputModelState;\n\treadonly commandStartX: number;\n\treadonly lastPromptLine: string | undefined;\n\treadonly continuationPrompt: string | undefined;\n\treadonly lastUserInput: string;\n}\n\nexport class PromptInputModel extends Disposable implements IPromptInputModel {\n\tprivate _state: PromptInputState = PromptInputState.Unknown;\n\tget state() { return this._state; }\n\n\tprivate _commandStartMarker: IMarker | undefined;\n\tprivate _commandStartX: number = 0;\n\tprivate _lastPromptLine: string | undefined;\n\tprivate _continuationPrompt: string | undefined;\n\tprivate _shellType: TerminalShellType | undefined;\n\n\tprivate _lastUserInput: string = '';\n\n\tprivate _value: string = '';\n\tget value() { return this._value; }\n\tget prefix() { return this._value.substring(0, this._cursorIndex); }\n\tget suffix() { return this._value.substring(this._cursorIndex, this._ghostTextIndex === -1 ? undefined : this._ghostTextIndex); }\n\n\tprivate _cursorIndex: number = 0;\n\tget cursorIndex() { return this._cursorIndex; }\n\n\tprivate _ghostTextIndex: number = -1;\n\tget ghostTextIndex() { return this._ghostTextIndex; }\n\n\tprivate readonly _onDidStartInput = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidStartInput = this._onDidStartInput.event;\n\tprivate readonly _onDidChangeInput = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidChangeInput = this._onDidChangeInput.event;\n\tprivate readonly _onDidFinishInput = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidFinishInput = this._onDidFinishInput.event;\n\tprivate readonly _onDidInterrupt = this._register(new Emitter<IPromptInputModelState>());\n\treadonly onDidInterrupt = this._onDidInterrupt.event;\n\n\tconstructor(\n\t\tprivate readonly _xterm: Terminal,\n\t\tonCommandStart: Event<ITerminalCommand>,\n\t\tonCommandStartChanged: Event<void>,\n\t\tonCommandExecuted: Event<ITerminalCommand>,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis._register(Event.any(\n\t\t\tthis._xterm.onCursorMove,\n\t\t\tthis._xterm.onData,\n\t\t\tthis._xterm.onWriteParsed,\n\t\t)(() => this._sync()));\n\t\tthis._register(this._xterm.onData(e => this._handleUserInput(e)));\n\n\t\tthis._register(onCommandStart(e => this._handleCommandStart(e as { marker: IMarker })));\n\t\tthis._register(onCommandStartChanged(() => this._handleCommandStartChanged()));\n\t\tthis._register(onCommandExecuted(() => this._handleCommandExecuted()));\n\n\t\tthis._register(this.onDidStartInput(() => this._logCombinedStringIfTrace('PromptInputModel#onDidStartInput')));\n\t\tthis._register(this.onDidChangeInput(() => this._logCombinedStringIfTrace('PromptInputModel#onDidChangeInput')));\n\t\tthis._register(this.onDidFinishInput(() => this._logCombinedStringIfTrace('PromptInputModel#onDidFinishInput')));\n\t\tthis._register(this.onDidInterrupt(() => this._logCombinedStringIfTrace('PromptInputModel#onDidInterrupt')));\n\t}\n\n\tprivate _logCombinedStringIfTrace(message: string) {\n\t\t// Only generate the combined string if trace\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace(message, this.getCombinedString());\n\t\t}\n\t}\n\n\tsetShellType(shellType: TerminalShellType): void {\n\t\tthis._shellType = shellType;\n\t}\n\n\tsetContinuationPrompt(value: string): void {\n\t\tthis._continuationPrompt = value;\n\t\tthis._sync();\n\t}\n\n\tsetLastPromptLine(value: string): void {\n\t\tthis._lastPromptLine = value;\n\t\tthis._sync();\n\t}\n\n\tsetConfidentCommandLine(value: string): void {\n\t\tif (this._value !== value) {\n\t\t\tthis._value = value;\n\t\t\tthis._cursorIndex = -1;\n\t\t\tthis._ghostTextIndex = -1;\n\t\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\t}\n\t}\n\n\tgetCombinedString(emptyStringWhenEmpty?: boolean): string {\n\t\tconst value = this._value.replaceAll('\\n', '\\u23CE');\n\t\tif (this._cursorIndex === -1) {\n\t\t\treturn value;\n\t\t}\n\t\tlet result = `${value.substring(0, this.cursorIndex)}|`;\n\t\tif (this.ghostTextIndex !== -1) {\n\t\t\tresult += `${value.substring(this.cursorIndex, this.ghostTextIndex)}[`;\n\t\t\tresult += `${value.substring(this.ghostTextIndex)}]`;\n\t\t} else {\n\t\t\tresult += value.substring(this.cursorIndex);\n\t\t}\n\t\tif (result === '|' && emptyStringWhenEmpty) {\n\t\t\treturn '';\n\t\t}\n\t\treturn result;\n\t}\n\n\tserialize(): ISerializedPromptInputModel {\n\t\treturn {\n\t\t\tmodelState: this._createStateObject(),\n\t\t\tcommandStartX: this._commandStartX,\n\t\t\tlastPromptLine: this._lastPromptLine,\n\t\t\tcontinuationPrompt: this._continuationPrompt,\n\t\t\tlastUserInput: this._lastUserInput\n\t\t};\n\t}\n\n\tdeserialize(serialized: ISerializedPromptInputModel): void {\n\t\tthis._value = serialized.modelState.value;\n\t\tthis._cursorIndex = serialized.modelState.cursorIndex;\n\t\tthis._ghostTextIndex = serialized.modelState.ghostTextIndex;\n\t\tthis._commandStartX = serialized.commandStartX;\n\t\tthis._lastPromptLine = serialized.lastPromptLine;\n\t\tthis._continuationPrompt = serialized.continuationPrompt;\n\t\tthis._lastUserInput = serialized.lastUserInput;\n\t}\n\n\tprivate _handleCommandStart(command: { marker: IMarker }) {\n\t\tif (this._state === PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._state = PromptInputState.Input;\n\t\tthis._commandStartMarker = command.marker;\n\t\tthis._commandStartX = this._xterm.buffer.active.cursorX;\n\t\tthis._value = '';\n\t\tthis._cursorIndex = 0;\n\t\tthis._onDidStartInput.fire(this._createStateObject());\n\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\n\t\t// Trigger a sync if prompt terminator is set as that could adjust the command start X\n\t\tif (this._lastPromptLine) {\n\t\t\tif (this._commandStartX !== this._lastPromptLine.length) {\n\t\t\t\tconst line = this._xterm.buffer.active.getLine(this._commandStartMarker.line);\n\t\t\t\tif (line?.translateToString(true).startsWith(this._lastPromptLine)) {\n\t\t\t\t\tthis._commandStartX = this._lastPromptLine.length;\n\t\t\t\t\tthis._sync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _handleCommandStartChanged() {\n\t\tif (this._state !== PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._commandStartX = this._xterm.buffer.active.cursorX;\n\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\tthis._sync();\n\t}\n\n\tprivate _handleCommandExecuted() {\n\t\tif (this._state === PromptInputState.Execute) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cursorIndex = -1;\n\n\t\t// Remove any ghost text from the input if it exists on execute\n\t\tif (this._ghostTextIndex !== -1) {\n\t\t\tthis._value = this._value.substring(0, this._ghostTextIndex);\n\t\t\tthis._ghostTextIndex = -1;\n\t\t}\n\n\t\tconst event = this._createStateObject();\n\t\tif (this._lastUserInput === '\\u0003') {\n\t\t\tthis._lastUserInput = '';\n\t\t\tthis._onDidInterrupt.fire(event);\n\t\t}\n\n\t\tthis._state = PromptInputState.Execute;\n\t\tthis._onDidFinishInput.fire(event);\n\t\tthis._onDidChangeInput.fire(event);\n\t}\n\n\t@throttle(0)\n\tprivate _sync() {\n\t\ttry {\n\t\t\tthis._doSync();\n\t\t} catch (e) {\n\t\t\tthis._logService.error('Error while syncing prompt input model', e);\n\t\t}\n\t}\n\n\tprivate _doSync() {\n\t\tif (this._state !== PromptInputState.Input) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet commandStartY = this._commandStartMarker?.line;\n\t\tif (commandStartY === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst buffer = this._xterm.buffer.active;\n\t\tlet line = buffer.getLine(commandStartY);\n\t\tconst absoluteCursorY = buffer.baseY + buffer.cursorY;\n\t\tlet cursorIndex: number | undefined;\n\n\t\tlet commandLine = line?.translateToString(true, this._commandStartX);\n\t\tif (this._shellType === PosixShellType.Fish && (!line || !commandLine)) {\n\t\t\tcommandStartY += 1;\n\t\t\tline = buffer.getLine(commandStartY);\n\t\t\tif (line) {\n\t\t\t\tcommandLine = line.translateToString(true);\n\t\t\t\tcursorIndex = absoluteCursorY === commandStartY ? buffer.cursorX : commandLine?.trimEnd().length;\n\t\t\t}\n\t\t}\n\t\tif (line === undefined || commandLine === undefined) {\n\t\t\tthis._logService.trace(`PromptInputModel#_sync: no line`);\n\t\t\treturn;\n\t\t}\n\n\t\tlet value = commandLine;\n\t\tlet ghostTextIndex = -1;\n\t\tif (cursorIndex === undefined) {\n\t\t\tif (absoluteCursorY === commandStartY) {\n\t\t\t\tcursorIndex = Math.min(this._getRelativeCursorIndex(this._commandStartX, buffer, line), commandLine.length);\n\t\t\t} else {\n\t\t\t\tcursorIndex = commandLine.trimEnd().length;\n\t\t\t}\n\t\t}\n\n\t\t// From command start line to cursor line\n\t\tfor (let y = commandStartY + 1; y <= absoluteCursorY; y++) {\n\t\t\tconst nextLine = buffer.getLine(y);\n\t\t\tconst lineText = nextLine?.translateToString(true);\n\t\t\tif (lineText && nextLine) {\n\t\t\t\t// Check if the line wrapped without a new line (continuation) or\n\t\t\t\t// we're on the last line and the continuation prompt is not present, so we need to add the value\n\t\t\t\tif (nextLine.isWrapped || (absoluteCursorY === y && this._continuationPrompt && !this._lineContainsContinuationPrompt(lineText))) {\n\t\t\t\t\tvalue += `${lineText}`;\n\t\t\t\t\tconst relativeCursorIndex = this._getRelativeCursorIndex(0, buffer, nextLine);\n\t\t\t\t\tif (absoluteCursorY === y) {\n\t\t\t\t\t\tcursorIndex += relativeCursorIndex;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursorIndex += lineText.length;\n\t\t\t\t\t}\n\t\t\t\t} else if (this._shellType === PosixShellType.Fish) {\n\t\t\t\t\tif (value.endsWith('\\\\')) {\n\t\t\t\t\t\t// Trim off the trailing backslash\n\t\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t\t\tvalue += `${lineText.trim()}`;\n\t\t\t\t\t\tcursorIndex += lineText.trim().length - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^ {6,}/.test(lineText)) {\n\t\t\t\t\t\t\t// Was likely a new line\n\t\t\t\t\t\t\tvalue += `\\n${lineText.trim()}`;\n\t\t\t\t\t\t\tcursorIndex += lineText.trim().length + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue += lineText;\n\t\t\t\t\t\t\tcursorIndex += lineText.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Verify continuation prompt if we have it, if this line doesn't have it then the\n\t\t\t\t// user likely just pressed enter.\n\t\t\t\telse if (this._continuationPrompt === undefined || this._lineContainsContinuationPrompt(lineText)) {\n\t\t\t\t\tconst trimmedLineText = this._trimContinuationPrompt(lineText);\n\t\t\t\t\tvalue += `\\n${trimmedLineText}`;\n\t\t\t\t\tif (absoluteCursorY === y) {\n\t\t\t\t\t\tconst continuationCellWidth = this._getContinuationPromptCellWidth(nextLine, lineText);\n\t\t\t\t\t\tconst relativeCursorIndex = this._getRelativeCursorIndex(continuationCellWidth, buffer, nextLine);\n\t\t\t\t\t\tcursorIndex += relativeCursorIndex + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursorIndex += trimmedLineText.length + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Below cursor line\n\t\tfor (let y = absoluteCursorY + 1; y < buffer.baseY + this._xterm.rows; y++) {\n\t\t\tconst belowCursorLine = buffer.getLine(y);\n\t\t\tconst lineText = belowCursorLine?.translateToString(true);\n\t\t\tif (lineText && belowCursorLine) {\n\t\t\t\tif (this._shellType === PosixShellType.Fish) {\n\t\t\t\t\tvalue += `${lineText}`;\n\t\t\t\t} else if (this._continuationPrompt === undefined || this._lineContainsContinuationPrompt(lineText)) {\n\t\t\t\t\tvalue += `\\n${this._trimContinuationPrompt(lineText)}`;\n\t\t\t\t} else {\n\t\t\t\t\tvalue += lineText;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace(`PromptInputModel#_sync: ${this.getCombinedString()}`);\n\t\t}\n\n\t\t// Adjust trailing whitespace\n\t\t{\n\t\t\tlet trailingWhitespace = this._value.length - this._value.trimEnd().length;\n\n\t\t\t// Handle backspace key\n\t\t\tif (this._lastUserInput === '\\x7F') {\n\t\t\t\tthis._lastUserInput = '';\n\t\t\t\tif (cursorIndex === this._cursorIndex - 1) {\n\t\t\t\t\t// If trailing whitespace is being increased by removing a non-whitespace character\n\t\t\t\t\tif (this._value.trimEnd().length > value.trimEnd().length && value.trimEnd().length <= cursorIndex) {\n\t\t\t\t\t\ttrailingWhitespace = Math.max((this._value.length - 1) - value.trimEnd().length, 0);\n\t\t\t\t\t}\n\t\t\t\t\t// Standard case; subtract from trailing whitespace\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrailingWhitespace = Math.max(trailingWhitespace - 1, 0);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle delete key\n\t\t\tif (this._lastUserInput === '\\x1b[3~') {\n\t\t\t\tthis._lastUserInput = '';\n\t\t\t\tif (cursorIndex === this._cursorIndex) {\n\t\t\t\t\ttrailingWhitespace = Math.max(trailingWhitespace - 1, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst valueLines = value.split('\\n');\n\t\t\tconst isMultiLine = valueLines.length > 1;\n\t\t\tconst valueEndTrimmed = value.trimEnd();\n\t\t\tif (!isMultiLine) {\n\t\t\t\t// Adjust trimmed whitespace value based on cursor position\n\t\t\t\tif (valueEndTrimmed.length < value.length) {\n\t\t\t\t\t// Handle space key\n\t\t\t\t\tif (this._lastUserInput === ' ') {\n\t\t\t\t\t\tthis._lastUserInput = '';\n\t\t\t\t\t\tif (cursorIndex > valueEndTrimmed.length && cursorIndex > this._cursorIndex) {\n\t\t\t\t\t\t\ttrailingWhitespace++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttrailingWhitespace = Math.max(cursorIndex - valueEndTrimmed.length, trailingWhitespace, 0);\n\t\t\t\t}\n\n\t\t\t\t// Handle case where a non-space character is inserted in the middle of trailing whitespace\n\t\t\t\tconst charBeforeCursor = cursorIndex === 0 ? '' : value[cursorIndex - 1];\n\t\t\t\tif (trailingWhitespace > 0 && cursorIndex === this._cursorIndex + 1 && this._lastUserInput !== '' && charBeforeCursor !== ' ') {\n\t\t\t\t\ttrailingWhitespace = this._value.length - this._cursorIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isMultiLine) {\n\t\t\t\tvalueLines[valueLines.length - 1] = valueLines.at(-1)?.trimEnd() ?? '';\n\t\t\t\tconst continuationOffset = (valueLines.length - 1) * (this._continuationPrompt?.length ?? 0);\n\t\t\t\ttrailingWhitespace = Math.max(0, cursorIndex - value.length - continuationOffset);\n\t\t\t}\n\n\t\t\tvalue = valueLines.map(e => e.trimEnd()).join('\\n') + ' '.repeat(trailingWhitespace);\n\t\t}\n\n\t\tghostTextIndex = this._scanForGhostText(buffer, line, cursorIndex);\n\n\t\tif (this._value !== value || this._cursorIndex !== cursorIndex || this._ghostTextIndex !== ghostTextIndex) {\n\t\t\tthis._value = value;\n\t\t\tthis._cursorIndex = cursorIndex;\n\t\t\tthis._ghostTextIndex = ghostTextIndex;\n\t\t\tthis._onDidChangeInput.fire(this._createStateObject());\n\t\t}\n\t}\n\n\tprivate _handleUserInput(e: string) {\n\t\tthis._lastUserInput = e;\n\t}\n\n\t/**\n\t * Detect ghost text by looking for italic or dim text in or after the cursor and\n\t * non-italic/dim text in the first non-whitespace cell following command start and before the cursor.\n\t */\n\tprivate _scanForGhostText(buffer: IBuffer, line: IBufferLine, cursorIndex: number): number {\n\t\tif (!this.value.trim().length) {\n\t\t\treturn -1;\n\t\t}\n\t\t// Check last non-whitespace character has non-ghost text styles\n\t\tlet ghostTextIndex = -1;\n\t\tlet proceedWithGhostTextCheck = false;\n\t\tlet x = buffer.cursorX;\n\t\twhile (x > 0) {\n\t\t\tconst cell = line.getCell(--x);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cell.getChars().trim().length > 0) {\n\t\t\t\tproceedWithGhostTextCheck = !this._isCellStyledLikeGhostText(cell);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Check to the end of the line for possible ghost text. For example pwsh's ghost text\n\t\t// can look like this `Get-|Ch[ildItem]`\n\t\tif (proceedWithGhostTextCheck) {\n\t\t\tlet potentialGhostIndexOffset = 0;\n\t\t\tlet x = buffer.cursorX;\n\n\t\t\twhile (x < line.length) {\n\t\t\t\tconst cell = line.getCell(x++);\n\t\t\t\tif (!cell || cell.getCode() === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._isCellStyledLikeGhostText(cell)) {\n\t\t\t\t\tghostTextIndex = cursorIndex + potentialGhostIndexOffset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tpotentialGhostIndexOffset += cell.getChars().length;\n\t\t\t}\n\t\t}\n\n\t\t// Ghost text may not be italic or dimmed, but will have a different style than the\n\t\t// rest of the line that precedes it.\n\t\tif (ghostTextIndex === -1) {\n\t\t\tghostTextIndex = this._scanForGhostTextAdvanced(buffer, line, cursorIndex);\n\t\t}\n\n\t\tif (ghostTextIndex > -1 && this.value.substring(ghostTextIndex).endsWith(' ')) {\n\t\t\tthis._value = this.value.trim();\n\t\t\tif (!this.value.substring(ghostTextIndex)) {\n\t\t\t\tghostTextIndex = -1;\n\t\t\t}\n\t\t}\n\t\treturn ghostTextIndex;\n\t}\n\n\tprivate _scanForGhostTextAdvanced(buffer: IBuffer, line: IBufferLine, cursorIndex: number): number {\n\t\tlet ghostTextIndex = -1;\n\t\tlet currentPos = buffer.cursorX; // Start scanning from the cursor position\n\n\t\t// Map to store styles and their corresponding positions\n\t\tconst styleMap = new Map<string, number[]>();\n\n\t\t// Identify the last non-whitespace character in the line\n\t\tlet lastNonWhitespaceCell = line.getCell(currentPos);\n\t\tlet nextCell: IBufferCell | undefined = lastNonWhitespaceCell;\n\n\t\t// Scan from the cursor position to the end of the line\n\t\twhile (nextCell && currentPos < line.length) {\n\t\t\tconst styleKey = this._getCellStyleAsString(nextCell);\n\n\t\t\t// Track all occurrences of each unique style in the line\n\t\t\tstyleMap.set(styleKey, [...(styleMap.get(styleKey) ?? []), currentPos]);\n\n\t\t\t// Move to the next cell\n\t\t\tnextCell = line.getCell(++currentPos);\n\n\t\t\t// Update `lastNonWhitespaceCell` only if the new cell contains visible characters\n\t\t\tif (nextCell?.getChars().trim().length) {\n\t\t\t\tlastNonWhitespaceCell = nextCell;\n\t\t\t}\n\t\t}\n\n\t\t// If there's no valid last non-whitespace cell OR the first and last styles match (indicating no ghost text)\n\t\tif (!lastNonWhitespaceCell?.getChars().trim().length ||\n\t\t\tthis._cellStylesMatch(line.getCell(this._commandStartX), lastNonWhitespaceCell)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Retrieve the positions of all cells with the same style as `lastNonWhitespaceCell`\n\t\tconst positionsWithGhostStyle = styleMap.get(this._getCellStyleAsString(lastNonWhitespaceCell));\n\t\tif (positionsWithGhostStyle) {\n\t\t\t// Ghost text must start at the cursor or one char after (e.g. a space)\n\t\t\t// To account for cursor movement, we also ensure there are not 5+ spaces preceding the ghost text position\n\t\t\tif (positionsWithGhostStyle[0] > buffer.cursorX + 1 && this._isPositionRightPrompt(line, positionsWithGhostStyle[0])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// Ensure these positions are contiguous\n\t\t\tfor (let i = 1; i < positionsWithGhostStyle.length; i++) {\n\t\t\t\tif (positionsWithGhostStyle[i] !== positionsWithGhostStyle[i - 1] + 1) {\n\t\t\t\t\t// Discontinuous styles, so may be syntax highlighting vs ghost text\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the ghost text start index\n\t\t\tif (buffer.baseY + buffer.cursorY === this._commandStartMarker?.line) {\n\t\t\t\tghostTextIndex = positionsWithGhostStyle[0] - this._commandStartX;\n\t\t\t} else {\n\t\t\t\tghostTextIndex = positionsWithGhostStyle[0];\n\t\t\t}\n\t\t}\n\n\t\t// Ensure no earlier cells in the line match `lastNonWhitespaceCell`'s style,\n\t\t// which would indicate the text is not ghost text.\n\t\tif (ghostTextIndex !== -1) {\n\t\t\tfor (let checkPos = buffer.cursorX; checkPos >= this._commandStartX; checkPos--) {\n\t\t\t\tconst checkCell = line.getCell(checkPos);\n\t\t\t\tif (!checkCell?.getChars.length) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (checkCell && checkCell.getCode() !== 0 && this._cellStylesMatch(lastNonWhitespaceCell, checkCell)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ghostTextIndex >= cursorIndex ? ghostTextIndex : -1;\n\t}\n\n\t/**\n\t * 5+ spaces preceding the position, following the command start,\n\t * indicates that we're likely in a right prompt at the current position\n\t */\n\tprivate _isPositionRightPrompt(line: IBufferLine, position: number): boolean {\n\t\tlet count = 0;\n\t\tfor (let i = position - 1; i >= this._commandStartX; i--) {\n\t\t\tconst cell = line.getCell(i);\n\t\t\t// treat missing cell or whitespace-only cell as empty; reset count on first non-empty\n\t\t\tif (!cell || cell.getChars().trim().length === 0) {\n\t\t\t\tcount++;\n\t\t\t\t// If we've already found 5 consecutive empties we can early-return\n\t\t\t\tif (count >= 5) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// consecutive sequence broken\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _getCellStyleAsString(cell: IBufferCell): string {\n\t\treturn `${cell.getFgColor()}${cell.getBgColor()}${cell.isBold()}${cell.isItalic()}${cell.isDim()}${cell.isUnderline()}${cell.isBlink()}${cell.isInverse()}${cell.isInvisible()}${cell.isStrikethrough()}${cell.isOverline()}${cell.getFgColorMode()}${cell.getBgColorMode()}`;\n\t}\n\n\tprivate _cellStylesMatch(a: IBufferCell | undefined, b: IBufferCell | undefined): boolean {\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.getFgColor() === b.getFgColor()\n\t\t\t&& a.getBgColor() === b.getBgColor()\n\t\t\t&& a.isBold() === b.isBold()\n\t\t\t&& a.isItalic() === b.isItalic()\n\t\t\t&& a.isDim() === b.isDim()\n\t\t\t&& a.isUnderline() === b.isUnderline()\n\t\t\t&& a.isBlink() === b.isBlink()\n\t\t\t&& a.isInverse() === b.isInverse()\n\t\t\t&& a.isInvisible() === b.isInvisible()\n\t\t\t&& a.isStrikethrough() === b.isStrikethrough()\n\t\t\t&& a.isOverline() === b.isOverline()\n\t\t\t&& a?.getBgColorMode() === b?.getBgColorMode()\n\t\t\t&& a?.getFgColorMode() === b?.getFgColorMode();\n\t}\n\n\tprivate _trimContinuationPrompt(lineText: string): string {\n\t\tif (this._lineContainsContinuationPrompt(lineText)) {\n\t\t\tlineText = lineText.substring(this._continuationPrompt!.length);\n\t\t}\n\t\treturn lineText;\n\t}\n\n\tprivate _lineContainsContinuationPrompt(lineText: string): boolean {\n\t\treturn !!(this._continuationPrompt && lineText.startsWith(this._continuationPrompt.trimEnd()));\n\t}\n\n\tprivate _getContinuationPromptCellWidth(line: IBufferLine, lineText: string): number {\n\t\tif (!this._continuationPrompt || !lineText.startsWith(this._continuationPrompt.trimEnd())) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet buffer = '';\n\t\tlet x = 0;\n\t\tlet cell: IBufferCell | undefined;\n\t\twhile (buffer !== this._continuationPrompt) {\n\t\t\tcell = line.getCell(x++);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuffer += cell.getChars();\n\t\t}\n\t\treturn x;\n\t}\n\n\tprivate _getRelativeCursorIndex(startCellX: number, buffer: IBuffer, line: IBufferLine): number {\n\t\treturn line?.translateToString(false, startCellX, buffer.cursorX).length ?? 0;\n\t}\n\n\tprivate _isCellStyledLikeGhostText(cell: IBufferCell): boolean {\n\t\treturn !!(cell.isItalic() || cell.isDim());\n\t}\n\n\tprivate _createStateObject(): IPromptInputModelState {\n\t\treturn Object.freeze({\n\t\t\tvalue: this._value,\n\t\t\tprefix: this.prefix,\n\t\t\tsuffix: this.suffix,\n\t\t\tcursorIndex: this._cursorIndex,\n\t\t\tghostTextIndex: this._ghostTextIndex\n\t\t});\n\t}\n}\n"]}