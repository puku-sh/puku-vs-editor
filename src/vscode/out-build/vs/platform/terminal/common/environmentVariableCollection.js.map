{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/common/environmentVariableCollection.ts","vs/platform/terminal/common/environmentVariableCollection.ts"],"names":[],"mappings":"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","file":"environmentVariableCollection.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IProcessEnvironment, isWindows } from '../../../base/common/platform.js';\nimport { EnvironmentVariableMutatorType, EnvironmentVariableScope, IEnvironmentVariableCollection, IExtensionOwnedEnvironmentDescriptionMutator, IExtensionOwnedEnvironmentVariableMutator, IMergedEnvironmentVariableCollection, IMergedEnvironmentVariableCollectionDiff } from './environmentVariable.js';\n\ntype VariableResolver = (str: string) => Promise<string>;\n\nconst mutatorTypeToLabelMap: Map<EnvironmentVariableMutatorType, string> = new Map([\n\t[EnvironmentVariableMutatorType.Append, 'APPEND'],\n\t[EnvironmentVariableMutatorType.Prepend, 'PREPEND'],\n\t[EnvironmentVariableMutatorType.Replace, 'REPLACE']\n]);\nconst PYTHON_ACTIVATION_VARS_PATTERN = /^VSCODE_PYTHON_(PWSH|ZSH|BASH|FISH)_ACTIVATE/;\nconst PYTHON_ENV_EXTENSION_ID = 'ms-python.vscode-python-envs';\n\nexport class MergedEnvironmentVariableCollection implements IMergedEnvironmentVariableCollection {\n\tprivate readonly map: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\tprivate readonly descriptionMap: Map<string, IExtensionOwnedEnvironmentDescriptionMutator[]> = new Map();\n\n\tconstructor(\n\t\treadonly collections: ReadonlyMap<string, IEnvironmentVariableCollection>,\n\t) {\n\t\tcollections.forEach((collection, extensionIdentifier) => {\n\t\t\tthis.populateDescriptionMap(collection, extensionIdentifier);\n\t\t\tconst it = collection.map.entries();\n\t\t\tlet next = it.next();\n\t\t\twhile (!next.done) {\n\t\t\t\tconst mutator = next.value[1];\n\t\t\t\tconst key = next.value[0];\n\n\t\t\t\tif (this.blockPythonActivationVar(key, extensionIdentifier)) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet entry = this.map.get(key);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = [];\n\t\t\t\t\tthis.map.set(key, entry);\n\t\t\t\t}\n\n\t\t\t\t// If the first item in the entry is replace ignore any other entries as they would\n\t\t\t\t// just get replaced by this one.\n\t\t\t\tif (entry.length > 0 && entry[0].type === EnvironmentVariableMutatorType.Replace) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst extensionMutator = {\n\t\t\t\t\textensionIdentifier,\n\t\t\t\t\tvalue: mutator.value,\n\t\t\t\t\ttype: mutator.type,\n\t\t\t\t\tscope: mutator.scope,\n\t\t\t\t\tvariable: mutator.variable,\n\t\t\t\t\toptions: mutator.options\n\t\t\t\t};\n\t\t\t\tif (!extensionMutator.scope) {\n\t\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t\t}\n\t\t\t\t// Mutators get applied in the reverse order than they are created\n\t\t\t\tentry.unshift(extensionMutator);\n\n\t\t\t\tnext = it.next();\n\t\t\t}\n\t\t});\n\t}\n\n\tasync applyToProcessEnvironment(env: IProcessEnvironment, scope: EnvironmentVariableScope | undefined, variableResolver?: VariableResolver): Promise<void> {\n\t\tlet lowerToActualVariableNames: { [lowerKey: string]: string | undefined } | undefined;\n\t\tif (isWindows) {\n\t\t\tlowerToActualVariableNames = {};\n\t\t\tObject.keys(env).forEach(e => lowerToActualVariableNames![e.toLowerCase()] = e);\n\t\t}\n\t\tfor (const [variable, mutators] of this.getVariableMap(scope)) {\n\t\t\tconst actualVariable = isWindows ? lowerToActualVariableNames![variable.toLowerCase()] || variable : variable;\n\t\t\tfor (const mutator of mutators) {\n\t\t\t\tconst value = variableResolver ? await variableResolver(mutator.value) : mutator.value;\n\n\t\t\t\tif (this.blockPythonActivationVar(mutator.variable, mutator.extensionIdentifier)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Default: true\n\t\t\t\tif (mutator.options?.applyAtProcessCreation ?? true) {\n\t\t\t\t\tswitch (mutator.type) {\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Append:\n\t\t\t\t\t\t\tenv[actualVariable] = (env[actualVariable] || '') + value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Prepend:\n\t\t\t\t\t\t\tenv[actualVariable] = value + (env[actualVariable] || '');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Replace:\n\t\t\t\t\t\t\tenv[actualVariable] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Default: false\n\t\t\t\tif (mutator.options?.applyAtShellIntegration ?? false) {\n\t\t\t\t\tconst key = `VSCODE_ENV_${mutatorTypeToLabelMap.get(mutator.type)!}`;\n\t\t\t\t\tenv[key] = (env[key] ? env[key] + ':' : '') + variable + '=' + this._encodeColons(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _encodeColons(value: string): string {\n\t\treturn value.replaceAll(':', '\\\\x3a');\n\t}\n\n\tprivate blockPythonActivationVar(variable: string, extensionIdentifier: string): boolean {\n\t\t// Only Python env extension can modify Python activate env var.\n\t\tif (PYTHON_ACTIVATION_VARS_PATTERN.test(variable) && PYTHON_ENV_EXTENSION_ID !== extensionIdentifier) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tdiff(other: IMergedEnvironmentVariableCollection, scope: EnvironmentVariableScope | undefined): IMergedEnvironmentVariableCollectionDiff | undefined {\n\t\tconst added: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst changed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst removed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\n\t\t// Find added\n\t\tother.getVariableMap(scope).forEach((otherMutators, variable) => {\n\t\t\tconst currentMutators = this.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(otherMutators, currentMutators);\n\t\t\tif (result) {\n\t\t\t\tadded.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find removed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tremoved.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find changed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getChangedMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tchanged.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\tif (added.size === 0 && changed.size === 0 && removed.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { added, changed, removed };\n\t}\n\n\tgetVariableMap(scope: EnvironmentVariableScope | undefined): Map<string, IExtensionOwnedEnvironmentVariableMutator[]> {\n\t\tconst result = new Map<string, IExtensionOwnedEnvironmentVariableMutator[]>();\n\t\tfor (const mutators of this.map.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope));\n\t\t\tif (filteredMutators.length > 0) {\n\t\t\t\t// All of these mutators are for the same variable because they are in the same scope, hence choose anyone to form a key.\n\t\t\t\tresult.set(filteredMutators[0].variable, filteredMutators);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetDescriptionMap(scope: EnvironmentVariableScope | undefined): Map<string, string | undefined> {\n\t\tconst result = new Map<string, string | undefined>();\n\t\tfor (const mutators of this.descriptionMap.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope, true));\n\t\t\tfor (const mutator of filteredMutators) {\n\t\t\t\tresult.set(mutator.extensionIdentifier, mutator.description);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate populateDescriptionMap(collection: IEnvironmentVariableCollection, extensionIdentifier: string): void {\n\t\tif (!collection.descriptionMap) {\n\t\t\treturn;\n\t\t}\n\t\tconst it = collection.descriptionMap.entries();\n\t\tlet next = it.next();\n\t\twhile (!next.done) {\n\t\t\tconst mutator = next.value[1];\n\t\t\tconst key = next.value[0];\n\t\t\tlet entry = this.descriptionMap.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tentry = [];\n\t\t\t\tthis.descriptionMap.set(key, entry);\n\t\t\t}\n\t\t\tconst extensionMutator = {\n\t\t\t\textensionIdentifier,\n\t\t\t\tscope: mutator.scope,\n\t\t\t\tdescription: mutator.description\n\t\t\t};\n\t\t\tif (!extensionMutator.scope) {\n\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t}\n\t\t\tentry.push(extensionMutator);\n\n\t\t\tnext = it.next();\n\t\t}\n\n\t}\n}\n\n/**\n * Returns whether a mutator matches with the scope provided.\n * @param mutator Mutator to filter\n * @param scope Scope to be used for querying\n * @param strictFilter If true, mutators with global scope is not returned when querying for workspace scope.\n * i.e whether mutator scope should always exactly match with query scope.\n */\nfunction filterScope(\n\tmutator: IExtensionOwnedEnvironmentVariableMutator | IExtensionOwnedEnvironmentDescriptionMutator,\n\tscope: EnvironmentVariableScope | undefined,\n\tstrictFilter = false\n): boolean {\n\tif (!mutator.scope) {\n\t\tif (strictFilter) {\n\t\t\treturn scope === mutator.scope;\n\t\t}\n\t\treturn true;\n\t}\n\t// If a mutator is scoped to a workspace folder, only apply it if the workspace\n\t// folder matches.\n\tif (mutator.scope.workspaceFolder && scope?.workspaceFolder && mutator.scope.workspaceFolder.index === scope.workspaceFolder.index) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction getMissingMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, all are removed\n\tif (!other) {\n\t\treturn current;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Set<string>();\n\tother.forEach(m => otherMutatorExtensions.add(m.extensionIdentifier));\n\n\t// Find entries removed from other\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tif (!otherMutatorExtensions.has(mutator.extensionIdentifier)) {\n\t\t\tresult.push(mutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n\nfunction getChangedMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, none are changed (they are removed)\n\tif (!other) {\n\t\treturn undefined;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Map<string, IExtensionOwnedEnvironmentVariableMutator>();\n\tother.forEach(m => otherMutatorExtensions.set(m.extensionIdentifier, m));\n\n\t// Find entries that exist in both but are not equal\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tconst otherMutator = otherMutatorExtensions.get(mutator.extensionIdentifier);\n\t\tif (otherMutator && (mutator.type !== otherMutator.type || mutator.value !== otherMutator.value || mutator.scope?.workspaceFolder?.index !== otherMutator.scope?.workspaceFolder?.index)) {\n\t\t\t// Return the new result, not the old one\n\t\t\tresult.push(otherMutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IProcessEnvironment, isWindows } from '../../../base/common/platform.js';\nimport { EnvironmentVariableMutatorType, EnvironmentVariableScope, IEnvironmentVariableCollection, IExtensionOwnedEnvironmentDescriptionMutator, IExtensionOwnedEnvironmentVariableMutator, IMergedEnvironmentVariableCollection, IMergedEnvironmentVariableCollectionDiff } from './environmentVariable.js';\n\ntype VariableResolver = (str: string) => Promise<string>;\n\nconst mutatorTypeToLabelMap: Map<EnvironmentVariableMutatorType, string> = new Map([\n\t[EnvironmentVariableMutatorType.Append, 'APPEND'],\n\t[EnvironmentVariableMutatorType.Prepend, 'PREPEND'],\n\t[EnvironmentVariableMutatorType.Replace, 'REPLACE']\n]);\nconst PYTHON_ACTIVATION_VARS_PATTERN = /^VSCODE_PYTHON_(PWSH|ZSH|BASH|FISH)_ACTIVATE/;\nconst PYTHON_ENV_EXTENSION_ID = 'ms-python.vscode-python-envs';\n\nexport class MergedEnvironmentVariableCollection implements IMergedEnvironmentVariableCollection {\n\tprivate readonly map: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\tprivate readonly descriptionMap: Map<string, IExtensionOwnedEnvironmentDescriptionMutator[]> = new Map();\n\n\tconstructor(\n\t\treadonly collections: ReadonlyMap<string, IEnvironmentVariableCollection>,\n\t) {\n\t\tcollections.forEach((collection, extensionIdentifier) => {\n\t\t\tthis.populateDescriptionMap(collection, extensionIdentifier);\n\t\t\tconst it = collection.map.entries();\n\t\t\tlet next = it.next();\n\t\t\twhile (!next.done) {\n\t\t\t\tconst mutator = next.value[1];\n\t\t\t\tconst key = next.value[0];\n\n\t\t\t\tif (this.blockPythonActivationVar(key, extensionIdentifier)) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet entry = this.map.get(key);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = [];\n\t\t\t\t\tthis.map.set(key, entry);\n\t\t\t\t}\n\n\t\t\t\t// If the first item in the entry is replace ignore any other entries as they would\n\t\t\t\t// just get replaced by this one.\n\t\t\t\tif (entry.length > 0 && entry[0].type === EnvironmentVariableMutatorType.Replace) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst extensionMutator = {\n\t\t\t\t\textensionIdentifier,\n\t\t\t\t\tvalue: mutator.value,\n\t\t\t\t\ttype: mutator.type,\n\t\t\t\t\tscope: mutator.scope,\n\t\t\t\t\tvariable: mutator.variable,\n\t\t\t\t\toptions: mutator.options\n\t\t\t\t};\n\t\t\t\tif (!extensionMutator.scope) {\n\t\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t\t}\n\t\t\t\t// Mutators get applied in the reverse order than they are created\n\t\t\t\tentry.unshift(extensionMutator);\n\n\t\t\t\tnext = it.next();\n\t\t\t}\n\t\t});\n\t}\n\n\tasync applyToProcessEnvironment(env: IProcessEnvironment, scope: EnvironmentVariableScope | undefined, variableResolver?: VariableResolver): Promise<void> {\n\t\tlet lowerToActualVariableNames: { [lowerKey: string]: string | undefined } | undefined;\n\t\tif (isWindows) {\n\t\t\tlowerToActualVariableNames = {};\n\t\t\tObject.keys(env).forEach(e => lowerToActualVariableNames![e.toLowerCase()] = e);\n\t\t}\n\t\tfor (const [variable, mutators] of this.getVariableMap(scope)) {\n\t\t\tconst actualVariable = isWindows ? lowerToActualVariableNames![variable.toLowerCase()] || variable : variable;\n\t\t\tfor (const mutator of mutators) {\n\t\t\t\tconst value = variableResolver ? await variableResolver(mutator.value) : mutator.value;\n\n\t\t\t\tif (this.blockPythonActivationVar(mutator.variable, mutator.extensionIdentifier)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Default: true\n\t\t\t\tif (mutator.options?.applyAtProcessCreation ?? true) {\n\t\t\t\t\tswitch (mutator.type) {\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Append:\n\t\t\t\t\t\t\tenv[actualVariable] = (env[actualVariable] || '') + value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Prepend:\n\t\t\t\t\t\t\tenv[actualVariable] = value + (env[actualVariable] || '');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Replace:\n\t\t\t\t\t\t\tenv[actualVariable] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Default: false\n\t\t\t\tif (mutator.options?.applyAtShellIntegration ?? false) {\n\t\t\t\t\tconst key = `VSCODE_ENV_${mutatorTypeToLabelMap.get(mutator.type)!}`;\n\t\t\t\t\tenv[key] = (env[key] ? env[key] + ':' : '') + variable + '=' + this._encodeColons(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _encodeColons(value: string): string {\n\t\treturn value.replaceAll(':', '\\\\x3a');\n\t}\n\n\tprivate blockPythonActivationVar(variable: string, extensionIdentifier: string): boolean {\n\t\t// Only Python env extension can modify Python activate env var.\n\t\tif (PYTHON_ACTIVATION_VARS_PATTERN.test(variable) && PYTHON_ENV_EXTENSION_ID !== extensionIdentifier) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tdiff(other: IMergedEnvironmentVariableCollection, scope: EnvironmentVariableScope | undefined): IMergedEnvironmentVariableCollectionDiff | undefined {\n\t\tconst added: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst changed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst removed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\n\t\t// Find added\n\t\tother.getVariableMap(scope).forEach((otherMutators, variable) => {\n\t\t\tconst currentMutators = this.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(otherMutators, currentMutators);\n\t\t\tif (result) {\n\t\t\t\tadded.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find removed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tremoved.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find changed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getChangedMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tchanged.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\tif (added.size === 0 && changed.size === 0 && removed.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { added, changed, removed };\n\t}\n\n\tgetVariableMap(scope: EnvironmentVariableScope | undefined): Map<string, IExtensionOwnedEnvironmentVariableMutator[]> {\n\t\tconst result = new Map<string, IExtensionOwnedEnvironmentVariableMutator[]>();\n\t\tfor (const mutators of this.map.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope));\n\t\t\tif (filteredMutators.length > 0) {\n\t\t\t\t// All of these mutators are for the same variable because they are in the same scope, hence choose anyone to form a key.\n\t\t\t\tresult.set(filteredMutators[0].variable, filteredMutators);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetDescriptionMap(scope: EnvironmentVariableScope | undefined): Map<string, string | undefined> {\n\t\tconst result = new Map<string, string | undefined>();\n\t\tfor (const mutators of this.descriptionMap.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope, true));\n\t\t\tfor (const mutator of filteredMutators) {\n\t\t\t\tresult.set(mutator.extensionIdentifier, mutator.description);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate populateDescriptionMap(collection: IEnvironmentVariableCollection, extensionIdentifier: string): void {\n\t\tif (!collection.descriptionMap) {\n\t\t\treturn;\n\t\t}\n\t\tconst it = collection.descriptionMap.entries();\n\t\tlet next = it.next();\n\t\twhile (!next.done) {\n\t\t\tconst mutator = next.value[1];\n\t\t\tconst key = next.value[0];\n\t\t\tlet entry = this.descriptionMap.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tentry = [];\n\t\t\t\tthis.descriptionMap.set(key, entry);\n\t\t\t}\n\t\t\tconst extensionMutator = {\n\t\t\t\textensionIdentifier,\n\t\t\t\tscope: mutator.scope,\n\t\t\t\tdescription: mutator.description\n\t\t\t};\n\t\t\tif (!extensionMutator.scope) {\n\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t}\n\t\t\tentry.push(extensionMutator);\n\n\t\t\tnext = it.next();\n\t\t}\n\n\t}\n}\n\n/**\n * Returns whether a mutator matches with the scope provided.\n * @param mutator Mutator to filter\n * @param scope Scope to be used for querying\n * @param strictFilter If true, mutators with global scope is not returned when querying for workspace scope.\n * i.e whether mutator scope should always exactly match with query scope.\n */\nfunction filterScope(\n\tmutator: IExtensionOwnedEnvironmentVariableMutator | IExtensionOwnedEnvironmentDescriptionMutator,\n\tscope: EnvironmentVariableScope | undefined,\n\tstrictFilter = false\n): boolean {\n\tif (!mutator.scope) {\n\t\tif (strictFilter) {\n\t\t\treturn scope === mutator.scope;\n\t\t}\n\t\treturn true;\n\t}\n\t// If a mutator is scoped to a workspace folder, only apply it if the workspace\n\t// folder matches.\n\tif (mutator.scope.workspaceFolder && scope?.workspaceFolder && mutator.scope.workspaceFolder.index === scope.workspaceFolder.index) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction getMissingMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, all are removed\n\tif (!other) {\n\t\treturn current;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Set<string>();\n\tother.forEach(m => otherMutatorExtensions.add(m.extensionIdentifier));\n\n\t// Find entries removed from other\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tif (!otherMutatorExtensions.has(mutator.extensionIdentifier)) {\n\t\t\tresult.push(mutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n\nfunction getChangedMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, none are changed (they are removed)\n\tif (!other) {\n\t\treturn undefined;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Map<string, IExtensionOwnedEnvironmentVariableMutator>();\n\tother.forEach(m => otherMutatorExtensions.set(m.extensionIdentifier, m));\n\n\t// Find entries that exist in both but are not equal\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tconst otherMutator = otherMutatorExtensions.get(mutator.extensionIdentifier);\n\t\tif (otherMutator && (mutator.type !== otherMutator.type || mutator.value !== otherMutator.value || mutator.scope?.workspaceFolder?.index !== otherMutator.scope?.workspaceFolder?.index)) {\n\t\t\t// Return the new result, not the old one\n\t\t\tresult.push(otherMutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n"]}