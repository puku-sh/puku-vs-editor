{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/terminal/node/terminalProfiles.ts","vs/platform/terminal/node/terminalProfiles.ts"],"names":[],"mappings":"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","file":"terminalProfiles.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { basename, delimiter, normalize, dirname, resolve } from '../../../base/common/path.js';\nimport { isLinux, isWindows } from '../../../base/common/platform.js';\nimport { findExecutable } from '../../../base/node/processes.js';\nimport { hasKey, isObject, isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport * as pfs from '../../../base/node/pfs.js';\nimport { enumeratePowerShellInstallations } from '../../../base/node/powershell.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ITerminalEnvironment, ITerminalExecutable, ITerminalProfile, ITerminalProfileSource, ITerminalUnsafePath, ProfileSource, TerminalIcon, TerminalSettingId } from '../common/terminal.js';\nimport { getWindowsBuildNumber } from './terminalEnvironment.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\n\nconst enum Constants {\n\tUnixShellsPath = '/etc/shells'\n}\n\nlet profileSources: Map<string, IPotentialTerminalProfile> | undefined;\nlet logIfWslNotInstalled: boolean = true;\n\nexport function detectAvailableProfiles(\n\tprofiles: unknown,\n\tdefaultProfile: unknown,\n\tincludeDetectedProfiles: boolean,\n\tconfigurationService: IConfigurationService,\n\tshellEnv: typeof process.env = process.env,\n\tfsProvider?: IFsProvider,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\ttestPwshSourcePaths?: string[]\n): Promise<ITerminalProfile[]> {\n\tfsProvider = fsProvider || {\n\t\texistsFile: pfs.SymlinkSupport.existsFile,\n\t\treadFile: fs.promises.readFile\n\t};\n\tif (isWindows) {\n\t\treturn detectAvailableWindowsProfiles(\n\t\t\tincludeDetectedProfiles,\n\t\t\tfsProvider,\n\t\t\tshellEnv,\n\t\t\tlogService,\n\t\t\tconfigurationService.getValue(TerminalSettingId.UseWslProfiles) !== false,\n\t\t\tprofiles && isObject(profiles) ? { ...profiles } : configurationService.getValue<{ [key: string]: IUnresolvedTerminalProfile }>(TerminalSettingId.ProfilesWindows),\n\t\t\tisString(defaultProfile) ? defaultProfile : configurationService.getValue<string>(TerminalSettingId.DefaultProfileWindows),\n\t\t\ttestPwshSourcePaths,\n\t\t\tvariableResolver\n\t\t);\n\t}\n\treturn detectAvailableUnixProfiles(\n\t\tfsProvider,\n\t\tlogService,\n\t\tincludeDetectedProfiles,\n\t\tprofiles && isObject(profiles) ? { ...profiles } : configurationService.getValue<{ [key: string]: IUnresolvedTerminalProfile }>(isLinux ? TerminalSettingId.ProfilesLinux : TerminalSettingId.ProfilesMacOs),\n\t\tisString(defaultProfile) ? defaultProfile : configurationService.getValue<string>(isLinux ? TerminalSettingId.DefaultProfileLinux : TerminalSettingId.DefaultProfileMacOs),\n\t\ttestPwshSourcePaths,\n\t\tvariableResolver,\n\t\tshellEnv\n\t);\n}\n\nasync function detectAvailableWindowsProfiles(\n\tincludeDetectedProfiles: boolean,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env,\n\tlogService?: ILogService,\n\tuseWslProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPwshSourcePaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>\n): Promise<ITerminalProfile[]> {\n\t// Determine the correct System32 path. We want to point to Sysnative\n\t// when the 32-bit version of VS Code is running on a 64-bit machine.\n\t// The reason for this is because PowerShell's important PSReadline\n\t// module doesn't work if this is not the case. See #27915.\n\tconst is32ProcessOn64Windows = process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432');\n\tconst system32Path = `${process.env['windir']}\\\\${is32ProcessOn64Windows ? 'Sysnative' : 'System32'}`;\n\n\t// WSL 2 released in the May 2020 Update, this is where the `-d` flag was added that we depend\n\t// upon\n\tconst allowWslDiscovery = getWindowsBuildNumber() >= 19041;\n\n\tawait initializeWindowsProfiles(testPwshSourcePaths);\n\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add auto detected profiles\n\tif (includeDetectedProfiles) {\n\t\tdetectedProfiles.set('PowerShell', {\n\t\t\tsource: ProfileSource.Pwsh,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Windows PowerShell', {\n\t\t\tpath: `${system32Path}\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe`,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Git Bash', {\n\t\t\tsource: ProfileSource.GitBash,\n\t\t\ticon: Codicon.terminalGitBash,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Command Prompt', {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\ticon: Codicon.terminalCmd,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Cygwin', {\n\t\t\tpath: [\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\cygwin64\\\\bin\\\\bash.exe`, isUnsafe: true },\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\cygwin\\\\bin\\\\bash.exe`, isUnsafe: true }\n\t\t\t],\n\t\t\targs: ['--login'],\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('bash (MSYS2)', {\n\t\t\tpath: [\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\msys64\\\\usr\\\\bin\\\\bash.exe`, isUnsafe: true },\n\t\t\t],\n\t\t\targs: ['--login', '-i'],\n\t\t\t// CHERE_INVOKING retains current working directory\n\t\t\tenv: { CHERE_INVOKING: '1' },\n\t\t\ticon: Codicon.terminalBash,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tconst cmderPath = `${process.env['CMDER_ROOT'] || `${process.env['HOMEDRIVE']}\\\\cmder`}\\\\vendor\\\\bin\\\\vscode_init.cmd`;\n\t\tdetectedProfiles.set('Cmder', {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\targs: ['/K', cmderPath],\n\t\t\t// The path is safe if it was derived from CMDER_ROOT\n\t\t\trequiresPath: process.env['CMDER_ROOT'] ? cmderPath : { path: cmderPath, isUnsafe: true },\n\t\t\tisAutoDetected: true\n\t\t});\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\tconst resultProfiles: ITerminalProfile[] = await transformToTerminalProfiles(detectedProfiles.entries(), defaultProfileName, fsProvider, shellEnv, logService, variableResolver);\n\n\tif (includeDetectedProfiles && useWslProfiles && allowWslDiscovery) {\n\t\ttry {\n\t\t\tconst result = await getWslProfiles(`${system32Path}\\\\wsl.exe`, defaultProfileName);\n\t\t\tfor (const wslProfile of result) {\n\t\t\t\tif (!configProfiles || !Object.prototype.hasOwnProperty.call(configProfiles, wslProfile.profileName)) {\n\t\t\t\t\tresultProfiles.push(wslProfile);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (logIfWslNotInstalled) {\n\t\t\t\tlogService?.trace('WSL is not installed, so could not detect WSL profiles');\n\t\t\t\tlogIfWslNotInstalled = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn resultProfiles;\n}\n\nasync function transformToTerminalProfiles(\n\tentries: IterableIterator<[string, IUnresolvedTerminalProfile]>,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n): Promise<ITerminalProfile[]> {\n\tconst promises: Promise<ITerminalProfile | undefined>[] = [];\n\tfor (const [profileName, profile] of entries) {\n\t\tpromises.push(getValidatedProfile(profileName, profile, defaultProfileName, fsProvider, shellEnv, logService, variableResolver));\n\t}\n\treturn (await Promise.all(promises)).filter(e => !!e);\n}\n\nasync function getValidatedProfile(\n\tprofileName: string,\n\tprofile: IUnresolvedTerminalProfile,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>\n): Promise<ITerminalProfile | undefined> {\n\tif (profile === null) {\n\t\treturn undefined;\n\t}\n\tlet originalPaths: (string | ITerminalUnsafePath)[];\n\tlet args: string[] | string | undefined;\n\tlet icon: ThemeIcon | URI | { light: URI; dark: URI } | undefined = undefined;\n\t// use calculated values if path is not specified\n\tif (hasKey(profile, { source: true })) {\n\t\tconst source = profileSources?.get(profile.source);\n\t\tif (!source) {\n\t\t\treturn undefined;\n\t\t}\n\t\toriginalPaths = source.paths;\n\n\t\t// if there are configured args, override the default ones\n\t\targs = profile.args || source.args;\n\t\tif (profile.icon) {\n\t\t\ticon = validateIcon(profile.icon);\n\t\t} else if (source.icon) {\n\t\t\ticon = source.icon;\n\t\t}\n\t} else {\n\t\toriginalPaths = Array.isArray(profile.path) ? profile.path : [profile.path];\n\t\targs = isWindows ? profile.args : Array.isArray(profile.args) ? profile.args : undefined;\n\t\ticon = validateIcon(profile.icon);\n\t}\n\n\tlet paths: (string | ITerminalUnsafePath)[];\n\tif (variableResolver) {\n\t\t// Convert to string[] for resolve\n\t\tconst mapped = originalPaths.map(e => isString(e) ? e : e.path);\n\n\t\tconst resolved = await variableResolver(mapped);\n\t\t// Convert resolved back to (T | string)[]\n\t\tpaths = new Array(originalPaths.length);\n\t\tfor (let i = 0; i < originalPaths.length; i++) {\n\t\t\tif (isString(originalPaths[i])) {\n\t\t\t\tpaths[i] = resolved[i];\n\t\t\t} else {\n\t\t\t\tpaths[i] = {\n\t\t\t\t\tpath: resolved[i],\n\t\t\t\t\tisUnsafe: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpaths = originalPaths.slice();\n\t}\n\n\tlet requiresUnsafePath: string | undefined;\n\tif (profile.requiresPath) {\n\t\t// Validate requiresPath exists\n\t\tlet actualRequiredPath: string;\n\t\tif (isString(profile.requiresPath)) {\n\t\t\tactualRequiredPath = profile.requiresPath;\n\t\t} else {\n\t\t\tactualRequiredPath = profile.requiresPath.path;\n\t\t\tif (profile.requiresPath.isUnsafe) {\n\t\t\t\trequiresUnsafePath = actualRequiredPath;\n\t\t\t}\n\t\t}\n\t\tconst result = await fsProvider.existsFile(actualRequiredPath);\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst validatedProfile = await validateProfilePaths(profileName, defaultProfileName, paths, fsProvider, shellEnv, args, profile.env, profile.overrideName, profile.isAutoDetected, requiresUnsafePath);\n\tif (!validatedProfile) {\n\t\tlogService?.debug('Terminal profile not validated', profileName, originalPaths);\n\t\treturn undefined;\n\t}\n\n\tvalidatedProfile.isAutoDetected = profile.isAutoDetected;\n\tvalidatedProfile.icon = icon;\n\tvalidatedProfile.color = profile.color;\n\treturn validatedProfile;\n}\n\nfunction validateIcon(icon: string | TerminalIcon | undefined): TerminalIcon | undefined {\n\tif (isString(icon)) {\n\t\treturn { id: icon };\n\t}\n\treturn icon;\n}\n\nasync function initializeWindowsProfiles(testPwshSourcePaths?: string[]): Promise<void> {\n\tif (profileSources && !testPwshSourcePaths) {\n\t\treturn;\n\t}\n\n\tconst [gitBashPaths, pwshPaths] = await Promise.all([getGitBashPaths(), testPwshSourcePaths || getPowershellPaths()]);\n\n\tprofileSources = new Map();\n\tprofileSources.set(\n\t\tProfileSource.GitBash, {\n\t\tprofileName: 'Git Bash',\n\t\tpaths: gitBashPaths,\n\t\targs: ['--login', '-i']\n\t});\n\tprofileSources.set(ProfileSource.Pwsh, {\n\t\tprofileName: 'PowerShell',\n\t\tpaths: pwshPaths,\n\t\ticon: Codicon.terminalPowershell\n\t});\n}\n\nasync function getGitBashPaths(): Promise<string[]> {\n\tconst gitDirs: Set<string> = new Set();\n\n\t// Look for git.exe on the PATH and use that if found. git.exe is located at\n\t// `<installdir>/cmd/git.exe`. This is not an unsafe location because the git executable is\n\t// located on the PATH which is only controlled by the user/admin.\n\tconst gitExePath = await findExecutable('git.exe');\n\tif (gitExePath) {\n\t\tconst gitExeDir = dirname(gitExePath);\n\t\tgitDirs.add(resolve(gitExeDir, '../..'));\n\t}\n\tfunction addTruthy<T>(set: Set<T>, value: T | undefined): void {\n\t\tif (value) {\n\t\t\tset.add(value);\n\t\t}\n\t}\n\n\t// Add common git install locations\n\taddTruthy(gitDirs, process.env['ProgramW6432']);\n\taddTruthy(gitDirs, process.env['ProgramFiles']);\n\taddTruthy(gitDirs, process.env['ProgramFiles(X86)']);\n\taddTruthy(gitDirs, `${process.env['LocalAppData']}\\\\Program`);\n\n\tconst gitBashPaths: string[] = [];\n\tfor (const gitDir of gitDirs) {\n\t\tgitBashPaths.push(\n\t\t\t`${gitDir}\\\\Git\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\Git\\\\usr\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\usr\\\\bin\\\\bash.exe` // using Git for Windows SDK\n\t\t);\n\t}\n\n\t// Add special installs that don't follow the standard directory structure\n\tgitBashPaths.push(`${process.env['UserProfile']}\\\\scoop\\\\apps\\\\git\\\\current\\\\bin\\\\bash.exe`);\n\tgitBashPaths.push(`${process.env['UserProfile']}\\\\scoop\\\\apps\\\\git-with-openssh\\\\current\\\\bin\\\\bash.exe`);\n\n\treturn gitBashPaths;\n}\n\nasync function getPowershellPaths(): Promise<string[]> {\n\tconst paths: string[] = [];\n\t// Add all of the different kinds of PowerShells\n\tfor await (const pwshExe of enumeratePowerShellInstallations()) {\n\t\tpaths.push(pwshExe.exePath);\n\t}\n\treturn paths;\n}\n\nasync function getWslProfiles(wslPath: string, defaultProfileName: string | undefined): Promise<ITerminalProfile[]> {\n\tconst profiles: ITerminalProfile[] = [];\n\tconst distroOutput = await new Promise<string>((resolve, reject) => {\n\t\t// wsl.exe output is encoded in utf16le (ie. A -> 0x4100) by default, force it in case the\n\t\t// user changed https://github.com/microsoft/vscode/issues/276253\n\t\tcp.exec('wsl.exe -l -q', { encoding: 'utf16le', env: { ...process.env, WSL_UTF8: '0' }, timeout: 1000 }, (err, stdout) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject('Problem occurred when getting wsl distros');\n\t\t\t}\n\t\t\tresolve(stdout);\n\t\t});\n\t});\n\tif (!distroOutput) {\n\t\treturn [];\n\t}\n\tconst regex = new RegExp(/[\\r?\\n]/);\n\tconst distroNames = distroOutput.split(regex).filter(t => t.trim().length > 0 && t !== '');\n\tfor (const distroName of distroNames) {\n\t\t// Skip empty lines\n\t\tif (distroName === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// docker-desktop and docker-desktop-data are treated as implementation details of\n\t\t// Docker Desktop for Windows and therefore not exposed\n\t\tif (distroName.startsWith('docker-desktop')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Create the profile, adding the icon depending on the distro\n\t\tconst profileName = `${distroName} (WSL)`;\n\t\tconst profile: ITerminalProfile = {\n\t\t\tprofileName,\n\t\t\tpath: wslPath,\n\t\t\targs: [`-d`, `${distroName}`],\n\t\t\tisDefault: profileName === defaultProfileName,\n\t\t\ticon: getWslIcon(distroName),\n\t\t\tisAutoDetected: false\n\t\t};\n\t\t// Add the profile\n\t\tprofiles.push(profile);\n\t}\n\treturn profiles;\n}\n\nfunction getWslIcon(distroName: string): ThemeIcon {\n\tif (distroName.includes('Ubuntu')) {\n\t\treturn Codicon.terminalUbuntu;\n\t} else if (distroName.includes('Debian')) {\n\t\treturn Codicon.terminalDebian;\n\t} else {\n\t\treturn Codicon.terminalLinux;\n\t}\n}\n\nasync function detectAvailableUnixProfiles(\n\tfsProvider: IFsProvider,\n\tlogService?: ILogService,\n\tincludeDetectedProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\tshellEnv?: typeof process.env\n): Promise<ITerminalProfile[]> {\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add non-quick launch profiles\n\tif (includeDetectedProfiles && await fsProvider.existsFile(Constants.UnixShellsPath)) {\n\t\tconst contents = (await fsProvider.readFile(Constants.UnixShellsPath)).toString();\n\t\tconst profiles = (\n\t\t\t(testPaths || contents.split('\\n'))\n\t\t\t\t.map(e => {\n\t\t\t\t\tconst index = e.indexOf('#');\n\t\t\t\t\treturn index === -1 ? e : e.substring(0, index);\n\t\t\t\t})\n\t\t\t\t.filter(e => e.trim().length > 0)\n\t\t);\n\t\tconst counts: Map<string, number> = new Map();\n\t\tfor (const profile of profiles) {\n\t\t\tlet profileName = basename(profile);\n\t\t\tlet count = counts.get(profileName) || 0;\n\t\t\tcount++;\n\t\t\tif (count > 1) {\n\t\t\t\tprofileName = `${profileName} (${count})`;\n\t\t\t}\n\t\t\tcounts.set(profileName, count);\n\t\t\tdetectedProfiles.set(profileName, { path: profile, isAutoDetected: true });\n\t\t}\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\treturn await transformToTerminalProfiles(detectedProfiles.entries(), defaultProfileName, fsProvider, shellEnv, logService, variableResolver);\n}\n\nfunction applyConfigProfilesToMap(configProfiles: { [key: string]: IUnresolvedTerminalProfile } | undefined, profilesMap: Map<string, IUnresolvedTerminalProfile>) {\n\tif (!configProfiles) {\n\t\treturn;\n\t}\n\tfor (const [profileName, value] of Object.entries(configProfiles)) {\n\t\tif (value === null || !isObject(value) || (!hasKey(value, { path: true }) && !hasKey(value, { source: true }))) {\n\t\t\tprofilesMap.delete(profileName);\n\t\t} else {\n\t\t\tvalue.icon = value.icon || profilesMap.get(profileName)?.icon;\n\t\t\tprofilesMap.set(profileName, value);\n\t\t}\n\t}\n}\n\nasync function validateProfilePaths(profileName: string, defaultProfileName: string | undefined, potentialPaths: (string | ITerminalUnsafePath)[], fsProvider: IFsProvider, shellEnv: typeof process.env, args?: string[] | string, env?: ITerminalEnvironment, overrideName?: boolean, isAutoDetected?: boolean, requiresUnsafePath?: string): Promise<ITerminalProfile | undefined> {\n\tif (potentialPaths.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tconst path = potentialPaths.shift()!;\n\tif (path === '') {\n\t\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args, env, overrideName, isAutoDetected);\n\t}\n\tconst isUnsafePath = !isString(path) && path.isUnsafe;\n\tconst actualPath = isString(path) ? path : path.path;\n\n\tconst profile: ITerminalProfile = {\n\t\tprofileName,\n\t\tpath: actualPath,\n\t\targs,\n\t\tenv,\n\t\toverrideName,\n\t\tisAutoDetected,\n\t\tisDefault: profileName === defaultProfileName,\n\t\tisUnsafePath,\n\t\trequiresUnsafePath\n\t};\n\n\t// For non-absolute paths, check if it's available on $PATH\n\tif (basename(actualPath) === actualPath) {\n\t\t// The executable isn't an absolute path, try find it on the PATH\n\t\tconst envPaths: string[] | undefined = shellEnv.PATH ? shellEnv.PATH.split(delimiter) : undefined;\n\t\tconst executable = await findExecutable(actualPath, undefined, envPaths, undefined, fsProvider.existsFile);\n\t\tif (!executable) {\n\t\t\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args);\n\t\t}\n\t\tprofile.path = executable;\n\t\tprofile.isFromPath = true;\n\t\treturn profile;\n\t}\n\n\tconst result = await fsProvider.existsFile(normalize(actualPath));\n\tif (result) {\n\t\treturn profile;\n\t}\n\n\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args, env, overrideName, isAutoDetected);\n}\n\nexport interface IFsProvider {\n\texistsFile(path: string): Promise<boolean>;\n\treadFile(path: string): Promise<Buffer>;\n}\n\ninterface IPotentialTerminalProfile {\n\tprofileName: string;\n\tpaths: string[];\n\targs?: string[];\n\ticon?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport type IUnresolvedTerminalProfile = ITerminalExecutable | ITerminalProfileSource | null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { basename, delimiter, normalize, dirname, resolve } from '../../../base/common/path.js';\nimport { isLinux, isWindows } from '../../../base/common/platform.js';\nimport { findExecutable } from '../../../base/node/processes.js';\nimport { hasKey, isObject, isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport * as pfs from '../../../base/node/pfs.js';\nimport { enumeratePowerShellInstallations } from '../../../base/node/powershell.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ITerminalEnvironment, ITerminalExecutable, ITerminalProfile, ITerminalProfileSource, ITerminalUnsafePath, ProfileSource, TerminalIcon, TerminalSettingId } from '../common/terminal.js';\nimport { getWindowsBuildNumber } from './terminalEnvironment.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\n\nconst enum Constants {\n\tUnixShellsPath = '/etc/shells'\n}\n\nlet profileSources: Map<string, IPotentialTerminalProfile> | undefined;\nlet logIfWslNotInstalled: boolean = true;\n\nexport function detectAvailableProfiles(\n\tprofiles: unknown,\n\tdefaultProfile: unknown,\n\tincludeDetectedProfiles: boolean,\n\tconfigurationService: IConfigurationService,\n\tshellEnv: typeof process.env = process.env,\n\tfsProvider?: IFsProvider,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\ttestPwshSourcePaths?: string[]\n): Promise<ITerminalProfile[]> {\n\tfsProvider = fsProvider || {\n\t\texistsFile: pfs.SymlinkSupport.existsFile,\n\t\treadFile: fs.promises.readFile\n\t};\n\tif (isWindows) {\n\t\treturn detectAvailableWindowsProfiles(\n\t\t\tincludeDetectedProfiles,\n\t\t\tfsProvider,\n\t\t\tshellEnv,\n\t\t\tlogService,\n\t\t\tconfigurationService.getValue(TerminalSettingId.UseWslProfiles) !== false,\n\t\t\tprofiles && isObject(profiles) ? { ...profiles } : configurationService.getValue<{ [key: string]: IUnresolvedTerminalProfile }>(TerminalSettingId.ProfilesWindows),\n\t\t\tisString(defaultProfile) ? defaultProfile : configurationService.getValue<string>(TerminalSettingId.DefaultProfileWindows),\n\t\t\ttestPwshSourcePaths,\n\t\t\tvariableResolver\n\t\t);\n\t}\n\treturn detectAvailableUnixProfiles(\n\t\tfsProvider,\n\t\tlogService,\n\t\tincludeDetectedProfiles,\n\t\tprofiles && isObject(profiles) ? { ...profiles } : configurationService.getValue<{ [key: string]: IUnresolvedTerminalProfile }>(isLinux ? TerminalSettingId.ProfilesLinux : TerminalSettingId.ProfilesMacOs),\n\t\tisString(defaultProfile) ? defaultProfile : configurationService.getValue<string>(isLinux ? TerminalSettingId.DefaultProfileLinux : TerminalSettingId.DefaultProfileMacOs),\n\t\ttestPwshSourcePaths,\n\t\tvariableResolver,\n\t\tshellEnv\n\t);\n}\n\nasync function detectAvailableWindowsProfiles(\n\tincludeDetectedProfiles: boolean,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env,\n\tlogService?: ILogService,\n\tuseWslProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPwshSourcePaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>\n): Promise<ITerminalProfile[]> {\n\t// Determine the correct System32 path. We want to point to Sysnative\n\t// when the 32-bit version of VS Code is running on a 64-bit machine.\n\t// The reason for this is because PowerShell's important PSReadline\n\t// module doesn't work if this is not the case. See #27915.\n\tconst is32ProcessOn64Windows = process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432');\n\tconst system32Path = `${process.env['windir']}\\\\${is32ProcessOn64Windows ? 'Sysnative' : 'System32'}`;\n\n\t// WSL 2 released in the May 2020 Update, this is where the `-d` flag was added that we depend\n\t// upon\n\tconst allowWslDiscovery = getWindowsBuildNumber() >= 19041;\n\n\tawait initializeWindowsProfiles(testPwshSourcePaths);\n\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add auto detected profiles\n\tif (includeDetectedProfiles) {\n\t\tdetectedProfiles.set('PowerShell', {\n\t\t\tsource: ProfileSource.Pwsh,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Windows PowerShell', {\n\t\t\tpath: `${system32Path}\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe`,\n\t\t\ticon: Codicon.terminalPowershell,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Git Bash', {\n\t\t\tsource: ProfileSource.GitBash,\n\t\t\ticon: Codicon.terminalGitBash,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Command Prompt', {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\ticon: Codicon.terminalCmd,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('Cygwin', {\n\t\t\tpath: [\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\cygwin64\\\\bin\\\\bash.exe`, isUnsafe: true },\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\cygwin\\\\bin\\\\bash.exe`, isUnsafe: true }\n\t\t\t],\n\t\t\targs: ['--login'],\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tdetectedProfiles.set('bash (MSYS2)', {\n\t\t\tpath: [\n\t\t\t\t{ path: `${process.env['HOMEDRIVE']}\\\\msys64\\\\usr\\\\bin\\\\bash.exe`, isUnsafe: true },\n\t\t\t],\n\t\t\targs: ['--login', '-i'],\n\t\t\t// CHERE_INVOKING retains current working directory\n\t\t\tenv: { CHERE_INVOKING: '1' },\n\t\t\ticon: Codicon.terminalBash,\n\t\t\tisAutoDetected: true\n\t\t});\n\t\tconst cmderPath = `${process.env['CMDER_ROOT'] || `${process.env['HOMEDRIVE']}\\\\cmder`}\\\\vendor\\\\bin\\\\vscode_init.cmd`;\n\t\tdetectedProfiles.set('Cmder', {\n\t\t\tpath: `${system32Path}\\\\cmd.exe`,\n\t\t\targs: ['/K', cmderPath],\n\t\t\t// The path is safe if it was derived from CMDER_ROOT\n\t\t\trequiresPath: process.env['CMDER_ROOT'] ? cmderPath : { path: cmderPath, isUnsafe: true },\n\t\t\tisAutoDetected: true\n\t\t});\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\tconst resultProfiles: ITerminalProfile[] = await transformToTerminalProfiles(detectedProfiles.entries(), defaultProfileName, fsProvider, shellEnv, logService, variableResolver);\n\n\tif (includeDetectedProfiles && useWslProfiles && allowWslDiscovery) {\n\t\ttry {\n\t\t\tconst result = await getWslProfiles(`${system32Path}\\\\wsl.exe`, defaultProfileName);\n\t\t\tfor (const wslProfile of result) {\n\t\t\t\tif (!configProfiles || !Object.prototype.hasOwnProperty.call(configProfiles, wslProfile.profileName)) {\n\t\t\t\t\tresultProfiles.push(wslProfile);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (logIfWslNotInstalled) {\n\t\t\t\tlogService?.trace('WSL is not installed, so could not detect WSL profiles');\n\t\t\t\tlogIfWslNotInstalled = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn resultProfiles;\n}\n\nasync function transformToTerminalProfiles(\n\tentries: IterableIterator<[string, IUnresolvedTerminalProfile]>,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n): Promise<ITerminalProfile[]> {\n\tconst promises: Promise<ITerminalProfile | undefined>[] = [];\n\tfor (const [profileName, profile] of entries) {\n\t\tpromises.push(getValidatedProfile(profileName, profile, defaultProfileName, fsProvider, shellEnv, logService, variableResolver));\n\t}\n\treturn (await Promise.all(promises)).filter(e => !!e);\n}\n\nasync function getValidatedProfile(\n\tprofileName: string,\n\tprofile: IUnresolvedTerminalProfile,\n\tdefaultProfileName: string | undefined,\n\tfsProvider: IFsProvider,\n\tshellEnv: typeof process.env = process.env,\n\tlogService?: ILogService,\n\tvariableResolver?: (text: string[]) => Promise<string[]>\n): Promise<ITerminalProfile | undefined> {\n\tif (profile === null) {\n\t\treturn undefined;\n\t}\n\tlet originalPaths: (string | ITerminalUnsafePath)[];\n\tlet args: string[] | string | undefined;\n\tlet icon: ThemeIcon | URI | { light: URI; dark: URI } | undefined = undefined;\n\t// use calculated values if path is not specified\n\tif (hasKey(profile, { source: true })) {\n\t\tconst source = profileSources?.get(profile.source);\n\t\tif (!source) {\n\t\t\treturn undefined;\n\t\t}\n\t\toriginalPaths = source.paths;\n\n\t\t// if there are configured args, override the default ones\n\t\targs = profile.args || source.args;\n\t\tif (profile.icon) {\n\t\t\ticon = validateIcon(profile.icon);\n\t\t} else if (source.icon) {\n\t\t\ticon = source.icon;\n\t\t}\n\t} else {\n\t\toriginalPaths = Array.isArray(profile.path) ? profile.path : [profile.path];\n\t\targs = isWindows ? profile.args : Array.isArray(profile.args) ? profile.args : undefined;\n\t\ticon = validateIcon(profile.icon);\n\t}\n\n\tlet paths: (string | ITerminalUnsafePath)[];\n\tif (variableResolver) {\n\t\t// Convert to string[] for resolve\n\t\tconst mapped = originalPaths.map(e => isString(e) ? e : e.path);\n\n\t\tconst resolved = await variableResolver(mapped);\n\t\t// Convert resolved back to (T | string)[]\n\t\tpaths = new Array(originalPaths.length);\n\t\tfor (let i = 0; i < originalPaths.length; i++) {\n\t\t\tif (isString(originalPaths[i])) {\n\t\t\t\tpaths[i] = resolved[i];\n\t\t\t} else {\n\t\t\t\tpaths[i] = {\n\t\t\t\t\tpath: resolved[i],\n\t\t\t\t\tisUnsafe: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpaths = originalPaths.slice();\n\t}\n\n\tlet requiresUnsafePath: string | undefined;\n\tif (profile.requiresPath) {\n\t\t// Validate requiresPath exists\n\t\tlet actualRequiredPath: string;\n\t\tif (isString(profile.requiresPath)) {\n\t\t\tactualRequiredPath = profile.requiresPath;\n\t\t} else {\n\t\t\tactualRequiredPath = profile.requiresPath.path;\n\t\t\tif (profile.requiresPath.isUnsafe) {\n\t\t\t\trequiresUnsafePath = actualRequiredPath;\n\t\t\t}\n\t\t}\n\t\tconst result = await fsProvider.existsFile(actualRequiredPath);\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst validatedProfile = await validateProfilePaths(profileName, defaultProfileName, paths, fsProvider, shellEnv, args, profile.env, profile.overrideName, profile.isAutoDetected, requiresUnsafePath);\n\tif (!validatedProfile) {\n\t\tlogService?.debug('Terminal profile not validated', profileName, originalPaths);\n\t\treturn undefined;\n\t}\n\n\tvalidatedProfile.isAutoDetected = profile.isAutoDetected;\n\tvalidatedProfile.icon = icon;\n\tvalidatedProfile.color = profile.color;\n\treturn validatedProfile;\n}\n\nfunction validateIcon(icon: string | TerminalIcon | undefined): TerminalIcon | undefined {\n\tif (isString(icon)) {\n\t\treturn { id: icon };\n\t}\n\treturn icon;\n}\n\nasync function initializeWindowsProfiles(testPwshSourcePaths?: string[]): Promise<void> {\n\tif (profileSources && !testPwshSourcePaths) {\n\t\treturn;\n\t}\n\n\tconst [gitBashPaths, pwshPaths] = await Promise.all([getGitBashPaths(), testPwshSourcePaths || getPowershellPaths()]);\n\n\tprofileSources = new Map();\n\tprofileSources.set(\n\t\tProfileSource.GitBash, {\n\t\tprofileName: 'Git Bash',\n\t\tpaths: gitBashPaths,\n\t\targs: ['--login', '-i']\n\t});\n\tprofileSources.set(ProfileSource.Pwsh, {\n\t\tprofileName: 'PowerShell',\n\t\tpaths: pwshPaths,\n\t\ticon: Codicon.terminalPowershell\n\t});\n}\n\nasync function getGitBashPaths(): Promise<string[]> {\n\tconst gitDirs: Set<string> = new Set();\n\n\t// Look for git.exe on the PATH and use that if found. git.exe is located at\n\t// `<installdir>/cmd/git.exe`. This is not an unsafe location because the git executable is\n\t// located on the PATH which is only controlled by the user/admin.\n\tconst gitExePath = await findExecutable('git.exe');\n\tif (gitExePath) {\n\t\tconst gitExeDir = dirname(gitExePath);\n\t\tgitDirs.add(resolve(gitExeDir, '../..'));\n\t}\n\tfunction addTruthy<T>(set: Set<T>, value: T | undefined): void {\n\t\tif (value) {\n\t\t\tset.add(value);\n\t\t}\n\t}\n\n\t// Add common git install locations\n\taddTruthy(gitDirs, process.env['ProgramW6432']);\n\taddTruthy(gitDirs, process.env['ProgramFiles']);\n\taddTruthy(gitDirs, process.env['ProgramFiles(X86)']);\n\taddTruthy(gitDirs, `${process.env['LocalAppData']}\\\\Program`);\n\n\tconst gitBashPaths: string[] = [];\n\tfor (const gitDir of gitDirs) {\n\t\tgitBashPaths.push(\n\t\t\t`${gitDir}\\\\Git\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\Git\\\\usr\\\\bin\\\\bash.exe`,\n\t\t\t`${gitDir}\\\\usr\\\\bin\\\\bash.exe` // using Git for Windows SDK\n\t\t);\n\t}\n\n\t// Add special installs that don't follow the standard directory structure\n\tgitBashPaths.push(`${process.env['UserProfile']}\\\\scoop\\\\apps\\\\git\\\\current\\\\bin\\\\bash.exe`);\n\tgitBashPaths.push(`${process.env['UserProfile']}\\\\scoop\\\\apps\\\\git-with-openssh\\\\current\\\\bin\\\\bash.exe`);\n\n\treturn gitBashPaths;\n}\n\nasync function getPowershellPaths(): Promise<string[]> {\n\tconst paths: string[] = [];\n\t// Add all of the different kinds of PowerShells\n\tfor await (const pwshExe of enumeratePowerShellInstallations()) {\n\t\tpaths.push(pwshExe.exePath);\n\t}\n\treturn paths;\n}\n\nasync function getWslProfiles(wslPath: string, defaultProfileName: string | undefined): Promise<ITerminalProfile[]> {\n\tconst profiles: ITerminalProfile[] = [];\n\tconst distroOutput = await new Promise<string>((resolve, reject) => {\n\t\t// wsl.exe output is encoded in utf16le (ie. A -> 0x4100) by default, force it in case the\n\t\t// user changed https://github.com/microsoft/vscode/issues/276253\n\t\tcp.exec('wsl.exe -l -q', { encoding: 'utf16le', env: { ...process.env, WSL_UTF8: '0' }, timeout: 1000 }, (err, stdout) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject('Problem occurred when getting wsl distros');\n\t\t\t}\n\t\t\tresolve(stdout);\n\t\t});\n\t});\n\tif (!distroOutput) {\n\t\treturn [];\n\t}\n\tconst regex = new RegExp(/[\\r?\\n]/);\n\tconst distroNames = distroOutput.split(regex).filter(t => t.trim().length > 0 && t !== '');\n\tfor (const distroName of distroNames) {\n\t\t// Skip empty lines\n\t\tif (distroName === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// docker-desktop and docker-desktop-data are treated as implementation details of\n\t\t// Docker Desktop for Windows and therefore not exposed\n\t\tif (distroName.startsWith('docker-desktop')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Create the profile, adding the icon depending on the distro\n\t\tconst profileName = `${distroName} (WSL)`;\n\t\tconst profile: ITerminalProfile = {\n\t\t\tprofileName,\n\t\t\tpath: wslPath,\n\t\t\targs: [`-d`, `${distroName}`],\n\t\t\tisDefault: profileName === defaultProfileName,\n\t\t\ticon: getWslIcon(distroName),\n\t\t\tisAutoDetected: false\n\t\t};\n\t\t// Add the profile\n\t\tprofiles.push(profile);\n\t}\n\treturn profiles;\n}\n\nfunction getWslIcon(distroName: string): ThemeIcon {\n\tif (distroName.includes('Ubuntu')) {\n\t\treturn Codicon.terminalUbuntu;\n\t} else if (distroName.includes('Debian')) {\n\t\treturn Codicon.terminalDebian;\n\t} else {\n\t\treturn Codicon.terminalLinux;\n\t}\n}\n\nasync function detectAvailableUnixProfiles(\n\tfsProvider: IFsProvider,\n\tlogService?: ILogService,\n\tincludeDetectedProfiles?: boolean,\n\tconfigProfiles?: { [key: string]: IUnresolvedTerminalProfile },\n\tdefaultProfileName?: string,\n\ttestPaths?: string[],\n\tvariableResolver?: (text: string[]) => Promise<string[]>,\n\tshellEnv?: typeof process.env\n): Promise<ITerminalProfile[]> {\n\tconst detectedProfiles: Map<string, IUnresolvedTerminalProfile> = new Map();\n\n\t// Add non-quick launch profiles\n\tif (includeDetectedProfiles && await fsProvider.existsFile(Constants.UnixShellsPath)) {\n\t\tconst contents = (await fsProvider.readFile(Constants.UnixShellsPath)).toString();\n\t\tconst profiles = (\n\t\t\t(testPaths || contents.split('\\n'))\n\t\t\t\t.map(e => {\n\t\t\t\t\tconst index = e.indexOf('#');\n\t\t\t\t\treturn index === -1 ? e : e.substring(0, index);\n\t\t\t\t})\n\t\t\t\t.filter(e => e.trim().length > 0)\n\t\t);\n\t\tconst counts: Map<string, number> = new Map();\n\t\tfor (const profile of profiles) {\n\t\t\tlet profileName = basename(profile);\n\t\t\tlet count = counts.get(profileName) || 0;\n\t\t\tcount++;\n\t\t\tif (count > 1) {\n\t\t\t\tprofileName = `${profileName} (${count})`;\n\t\t\t}\n\t\t\tcounts.set(profileName, count);\n\t\t\tdetectedProfiles.set(profileName, { path: profile, isAutoDetected: true });\n\t\t}\n\t}\n\n\tapplyConfigProfilesToMap(configProfiles, detectedProfiles);\n\n\treturn await transformToTerminalProfiles(detectedProfiles.entries(), defaultProfileName, fsProvider, shellEnv, logService, variableResolver);\n}\n\nfunction applyConfigProfilesToMap(configProfiles: { [key: string]: IUnresolvedTerminalProfile } | undefined, profilesMap: Map<string, IUnresolvedTerminalProfile>) {\n\tif (!configProfiles) {\n\t\treturn;\n\t}\n\tfor (const [profileName, value] of Object.entries(configProfiles)) {\n\t\tif (value === null || !isObject(value) || (!hasKey(value, { path: true }) && !hasKey(value, { source: true }))) {\n\t\t\tprofilesMap.delete(profileName);\n\t\t} else {\n\t\t\tvalue.icon = value.icon || profilesMap.get(profileName)?.icon;\n\t\t\tprofilesMap.set(profileName, value);\n\t\t}\n\t}\n}\n\nasync function validateProfilePaths(profileName: string, defaultProfileName: string | undefined, potentialPaths: (string | ITerminalUnsafePath)[], fsProvider: IFsProvider, shellEnv: typeof process.env, args?: string[] | string, env?: ITerminalEnvironment, overrideName?: boolean, isAutoDetected?: boolean, requiresUnsafePath?: string): Promise<ITerminalProfile | undefined> {\n\tif (potentialPaths.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tconst path = potentialPaths.shift()!;\n\tif (path === '') {\n\t\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args, env, overrideName, isAutoDetected);\n\t}\n\tconst isUnsafePath = !isString(path) && path.isUnsafe;\n\tconst actualPath = isString(path) ? path : path.path;\n\n\tconst profile: ITerminalProfile = {\n\t\tprofileName,\n\t\tpath: actualPath,\n\t\targs,\n\t\tenv,\n\t\toverrideName,\n\t\tisAutoDetected,\n\t\tisDefault: profileName === defaultProfileName,\n\t\tisUnsafePath,\n\t\trequiresUnsafePath\n\t};\n\n\t// For non-absolute paths, check if it's available on $PATH\n\tif (basename(actualPath) === actualPath) {\n\t\t// The executable isn't an absolute path, try find it on the PATH\n\t\tconst envPaths: string[] | undefined = shellEnv.PATH ? shellEnv.PATH.split(delimiter) : undefined;\n\t\tconst executable = await findExecutable(actualPath, undefined, envPaths, undefined, fsProvider.existsFile);\n\t\tif (!executable) {\n\t\t\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args);\n\t\t}\n\t\tprofile.path = executable;\n\t\tprofile.isFromPath = true;\n\t\treturn profile;\n\t}\n\n\tconst result = await fsProvider.existsFile(normalize(actualPath));\n\tif (result) {\n\t\treturn profile;\n\t}\n\n\treturn validateProfilePaths(profileName, defaultProfileName, potentialPaths, fsProvider, shellEnv, args, env, overrideName, isAutoDetected);\n}\n\nexport interface IFsProvider {\n\texistsFile(path: string): Promise<boolean>;\n\treadFile(path: string): Promise<Buffer>;\n}\n\ninterface IPotentialTerminalProfile {\n\tprofileName: string;\n\tpaths: string[];\n\targs?: string[];\n\ticon?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport type IUnresolvedTerminalProfile = ITerminalExecutable | ITerminalProfileSource | null;\n"]}