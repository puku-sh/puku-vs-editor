{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/workspaces/common/workspaces.ts","vs/platform/workspaces/common/workspaces.ts"],"names":[],"mappings":"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","file":"workspaces.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { isUNC, toSlashes } from '../../../base/common/extpath.js';\nimport * as json from '../../../base/common/json.js';\nimport * as jsonEdit from '../../../base/common/jsonEdit.js';\nimport { FormattingOptions } from '../../../base/common/jsonFormatter.js';\nimport { normalizeDriveLetter } from '../../../base/common/labels.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { isAbsolute, posix } from '../../../base/common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../base/common/platform.js';\nimport { IExtUri, isEqualAuthority } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWorkspaceBackupInfo, IFolderBackupInfo } from '../../backup/common/backup.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { getRemoteAuthority } from '../../remote/common/remoteHosts.js';\nimport { IBaseWorkspace, IRawFileWorkspaceFolder, IRawUriWorkspaceFolder, IWorkspaceIdentifier, WorkspaceFolder } from '../../workspace/common/workspace.js';\n\nexport const IWorkspacesService = createDecorator<IWorkspacesService>('workspacesService');\n\nexport interface IWorkspacesService {\n\n\treadonly _serviceBrand: undefined;\n\n\t// Workspaces Management\n\tenterWorkspace(workspaceUri: URI): Promise<IEnterWorkspaceResult | undefined>;\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier>;\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\tgetWorkspaceIdentifier(workspaceUri: URI): Promise<IWorkspaceIdentifier>;\n\n\t// Workspaces History\n\treadonly onDidChangeRecentlyOpened: Event<void>;\n\taddRecentlyOpened(recents: IRecent[]): Promise<void>;\n\tremoveRecentlyOpened(workspaces: URI[]): Promise<void>;\n\tclearRecentlyOpened(): Promise<void>;\n\tgetRecentlyOpened(): Promise<IRecentlyOpened>;\n\n\t// Dirty Workspaces\n\tgetDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>>;\n}\n\n//#region Workspaces Recently Opened\n\nexport interface IRecentlyOpened {\n\tworkspaces: Array<IRecentWorkspace | IRecentFolder>;\n\tfiles: IRecentFile[];\n}\n\nexport type IRecent = IRecentWorkspace | IRecentFolder | IRecentFile;\n\nexport interface IRecentWorkspace {\n\treadonly workspace: IWorkspaceIdentifier;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFolder {\n\treadonly folderUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFile {\n\treadonly fileUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport function isRecentWorkspace(curr: IRecent): curr is IRecentWorkspace {\n\treturn curr.hasOwnProperty('workspace');\n}\n\nexport function isRecentFolder(curr: IRecent): curr is IRecentFolder {\n\treturn curr.hasOwnProperty('folderUri');\n}\n\nexport function isRecentFile(curr: IRecent): curr is IRecentFile {\n\treturn curr.hasOwnProperty('fileUri');\n}\n\n//#endregion\n\n//#region Workspace File Utilities\n\nexport function isStoredWorkspaceFolder(obj: unknown): obj is IStoredWorkspaceFolder {\n\treturn isRawFileWorkspaceFolder(obj) || isRawUriWorkspaceFolder(obj);\n}\n\nfunction isRawFileWorkspaceFolder(obj: unknown): obj is IRawFileWorkspaceFolder {\n\tconst candidate = obj as IRawFileWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.path === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nfunction isRawUriWorkspaceFolder(obj: unknown): obj is IRawUriWorkspaceFolder {\n\tconst candidate = obj as IRawUriWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.uri === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nexport type IStoredWorkspaceFolder = IRawFileWorkspaceFolder | IRawUriWorkspaceFolder;\n\nexport interface IStoredWorkspace extends IBaseWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n}\n\nexport interface IWorkspaceFolderCreationData {\n\treadonly uri: URI;\n\treadonly name?: string;\n}\n\nexport interface IUntitledWorkspaceInfo {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IEnterWorkspaceResult {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly backupPath?: string;\n}\n\n/**\n * Given a folder URI and the workspace config folder, computes the `IStoredWorkspaceFolder`\n * using a relative or absolute path or a uri.\n * Undefined is returned if the `folderURI` and the `targetConfigFolderURI` don't have the\n * same schema or authority.\n *\n * @param folderURI a workspace folder\n * @param forceAbsolute if set, keep the path absolute\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n */\nexport function getStoredWorkspaceFolder(folderURI: URI, forceAbsolute: boolean, folderName: string | undefined, targetConfigFolderURI: URI, extUri: IExtUri): IStoredWorkspaceFolder {\n\n\t// Scheme mismatch: use full absolute URI as `uri`\n\tif (folderURI.scheme !== targetConfigFolderURI.scheme) {\n\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t}\n\n\t// Always prefer a relative path if possible unless\n\t// prevented to make the workspace file shareable\n\t// with other users\n\tlet folderPath = !forceAbsolute ? extUri.relativePath(targetConfigFolderURI, folderURI) : undefined;\n\tif (folderPath !== undefined) {\n\t\tif (folderPath.length === 0) {\n\t\t\tfolderPath = '.';\n\t\t} else {\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t// We could not resolve a relative path\n\telse {\n\n\t\t// Local file: use `fsPath`\n\t\tif (folderURI.scheme === Schemas.file) {\n\t\t\tfolderPath = folderURI.fsPath;\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\n\t\t// Different authority: use full absolute URI\n\t\telse if (!extUri.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n\t\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t\t}\n\n\t\t// Non-local file: use `path` of URI\n\t\telse {\n\t\t\tfolderPath = folderURI.path;\n\t\t}\n\t}\n\n\treturn { name: folderName, path: folderPath };\n}\n\nfunction massagePathForWindows(folderPath: string) {\n\n\t// Drive letter should be upper case\n\tfolderPath = normalizeDriveLetter(folderPath);\n\n\t// Always prefer slash over backslash unless\n\t// we deal with UNC paths where backslash is\n\t// mandatory.\n\tif (!isUNC(folderPath)) {\n\t\tfolderPath = toSlashes(folderPath);\n\t}\n\n\treturn folderPath;\n}\n\nexport function toWorkspaceFolders(configuredFolders: IStoredWorkspaceFolder[], workspaceConfigFile: URI, extUri: IExtUri): WorkspaceFolder[] {\n\tconst result: WorkspaceFolder[] = [];\n\tconst seen: Set<string> = new Set();\n\n\tconst relativeTo = extUri.dirname(workspaceConfigFile);\n\tfor (const configuredFolder of configuredFolders) {\n\t\tlet uri: URI | undefined = undefined;\n\t\tif (isRawFileWorkspaceFolder(configuredFolder)) {\n\t\t\tif (configuredFolder.path) {\n\t\t\t\turi = extUri.resolvePath(relativeTo, configuredFolder.path);\n\t\t\t}\n\t\t} else if (isRawUriWorkspaceFolder(configuredFolder)) {\n\t\t\ttry {\n\t\t\t\turi = URI.parse(configuredFolder.uri);\n\t\t\t\tif (uri.path[0] !== posix.sep) {\n\t\t\t\t\turi = uri.with({ path: posix.sep + uri.path }); // this makes sure all workspace folder are absolute\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(e); // ignore\n\t\t\t}\n\t\t}\n\n\t\tif (uri) {\n\n\t\t\t// remove duplicates\n\t\t\tconst comparisonKey = extUri.getComparisonKey(uri);\n\t\t\tif (!seen.has(comparisonKey)) {\n\t\t\t\tseen.add(comparisonKey);\n\n\t\t\t\tconst name = configuredFolder.name || extUri.basenameOrAuthority(uri);\n\t\t\t\tresult.push(new WorkspaceFolder({ uri, name, index: result.length }, configuredFolder));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nexport function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents: string, configPathURI: URI, isFromUntitledWorkspace: boolean, targetConfigPathURI: URI, extUri: IExtUri) {\n\tconst storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n\n\tconst sourceConfigFolder = extUri.dirname(configPathURI);\n\tconst targetConfigFolder = extUri.dirname(targetConfigPathURI);\n\n\tconst rewrittenFolders: IStoredWorkspaceFolder[] = [];\n\n\tfor (const folder of storedWorkspace.folders) {\n\t\tconst folderURI = isRawFileWorkspaceFolder(folder) ? extUri.resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);\n\t\tlet absolute;\n\t\tif (isFromUntitledWorkspace) {\n\t\t\tabsolute = false; // if it was an untitled workspace, try to make paths relative\n\t\t} else {\n\t\t\tabsolute = !isRawFileWorkspaceFolder(folder) || isAbsolute(folder.path); // for existing workspaces, preserve whether a path was absolute or relative\n\t\t}\n\t\trewrittenFolders.push(getStoredWorkspaceFolder(folderURI, absolute, folder.name, targetConfigFolder, extUri));\n\t}\n\n\t// Preserve as much of the existing workspace as possible by using jsonEdit\n\t// and only changing the folders portion.\n\tconst formattingOptions: FormattingOptions = { insertSpaces: false, tabSize: 4, eol: (isLinux || isMacintosh) ? '\\n' : '\\r\\n' };\n\tconst edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, formattingOptions);\n\tlet newContent = jsonEdit.applyEdits(rawWorkspaceContents, edits);\n\n\tif (isEqualAuthority(storedWorkspace.remoteAuthority, getRemoteAuthority(targetConfigPathURI))) {\n\t\t// unsaved remote workspaces have the remoteAuthority set. Remove it when no longer nexessary.\n\t\tnewContent = jsonEdit.applyEdits(newContent, jsonEdit.removeProperty(newContent, ['remoteAuthority'], formattingOptions));\n\t}\n\n\treturn newContent;\n}\n\nfunction doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t// Parse workspace file\n\tconst storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t// Filter out folders which do not have a path or uri set\n\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t} else {\n\t\tthrow new Error(`${path} looks like an invalid workspace file.`);\n\t}\n\n\treturn storedWorkspace;\n}\n\n//#endregion\n\n//#region Workspace Storage\n\ninterface ISerializedRecentWorkspace {\n\treadonly workspace: {\n\t\tid: string;\n\t\tconfigPath: string;\n\t};\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFolder {\n\treadonly folderUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFile {\n\treadonly fileUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentlyOpened {\n\treadonly entries: Array<ISerializedRecentWorkspace | ISerializedRecentFolder | ISerializedRecentFile>; // since 1.55\n}\n\nexport type RecentlyOpenedStorageData = object;\n\nfunction isSerializedRecentWorkspace(data: unknown): data is ISerializedRecentWorkspace {\n\tconst candidate = data as ISerializedRecentWorkspace | undefined;\n\n\treturn typeof candidate?.workspace === 'object' && typeof candidate.workspace.id === 'string' && typeof candidate.workspace.configPath === 'string';\n}\n\nfunction isSerializedRecentFolder(data: unknown): data is ISerializedRecentFolder {\n\tconst candidate = data as ISerializedRecentFolder | undefined;\n\n\treturn typeof candidate?.folderUri === 'string';\n}\n\nfunction isSerializedRecentFile(data: unknown): data is ISerializedRecentFile {\n\tconst candidate = data as ISerializedRecentFile | undefined;\n\n\treturn typeof candidate?.fileUri === 'string';\n}\n\nexport function restoreRecentlyOpened(data: RecentlyOpenedStorageData | undefined, logService: ILogService): IRecentlyOpened {\n\tconst result: IRecentlyOpened = { workspaces: [], files: [] };\n\tif (data) {\n\t\tconst restoreGracefully = function <T>(entries: T[], onEntry: (entry: T, index: number) => void) {\n\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tonEntry(entries[i], i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogService.warn(`Error restoring recent entry ${JSON.stringify(entries[i])}: ${e.toString()}. Skip entry.`);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst storedRecents = data as ISerializedRecentlyOpened;\n\t\tif (Array.isArray(storedRecents.entries)) {\n\t\t\trestoreGracefully(storedRecents.entries, entry => {\n\t\t\t\tconst label = entry.label;\n\t\t\t\tconst remoteAuthority = entry.remoteAuthority;\n\n\t\t\t\tif (isSerializedRecentWorkspace(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, workspace: { id: entry.workspace.id, configPath: URI.parse(entry.workspace.configPath) } });\n\t\t\t\t} else if (isSerializedRecentFolder(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, folderUri: URI.parse(entry.folderUri) });\n\t\t\t\t} else if (isSerializedRecentFile(entry)) {\n\t\t\t\t\tresult.files.push({ label, remoteAuthority, fileUri: URI.parse(entry.fileUri) });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function toStoreData(recents: IRecentlyOpened): RecentlyOpenedStorageData {\n\tconst serialized: ISerializedRecentlyOpened = { entries: [] };\n\n\tconst storeLabel = (label: string | undefined, uri: URI) => {\n\t\t// Only store the label if it is provided\n\t\t// and only if it differs from the path\n\t\t// This gives us a chance to render the\n\t\t// path better, e.g. use `~` for home.\n\t\treturn label && label !== uri.fsPath && label !== uri.path;\n\t};\n\n\tfor (const recent of recents.workspaces) {\n\t\tif (isRecentFolder(recent)) {\n\t\t\tserialized.entries.push({\n\t\t\t\tfolderUri: recent.folderUri.toString(),\n\t\t\t\tlabel: storeLabel(recent.label, recent.folderUri) ? recent.label : undefined,\n\t\t\t\tremoteAuthority: recent.remoteAuthority\n\t\t\t});\n\t\t} else {\n\t\t\tserialized.entries.push({\n\t\t\t\tworkspace: {\n\t\t\t\t\tid: recent.workspace.id,\n\t\t\t\t\tconfigPath: recent.workspace.configPath.toString()\n\t\t\t\t},\n\t\t\t\tlabel: storeLabel(recent.label, recent.workspace.configPath) ? recent.label : undefined,\n\t\t\t\tremoteAuthority: recent.remoteAuthority\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (const recent of recents.files) {\n\t\tserialized.entries.push({\n\t\t\tfileUri: recent.fileUri.toString(),\n\t\t\tlabel: storeLabel(recent.label, recent.fileUri) ? recent.label : undefined,\n\t\t\tremoteAuthority: recent.remoteAuthority\n\t\t});\n\t}\n\n\treturn serialized;\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { isUNC, toSlashes } from '../../../base/common/extpath.js';\nimport * as json from '../../../base/common/json.js';\nimport * as jsonEdit from '../../../base/common/jsonEdit.js';\nimport { FormattingOptions } from '../../../base/common/jsonFormatter.js';\nimport { normalizeDriveLetter } from '../../../base/common/labels.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { isAbsolute, posix } from '../../../base/common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../base/common/platform.js';\nimport { IExtUri, isEqualAuthority } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWorkspaceBackupInfo, IFolderBackupInfo } from '../../backup/common/backup.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { getRemoteAuthority } from '../../remote/common/remoteHosts.js';\nimport { IBaseWorkspace, IRawFileWorkspaceFolder, IRawUriWorkspaceFolder, IWorkspaceIdentifier, WorkspaceFolder } from '../../workspace/common/workspace.js';\n\nexport const IWorkspacesService = createDecorator<IWorkspacesService>('workspacesService');\n\nexport interface IWorkspacesService {\n\n\treadonly _serviceBrand: undefined;\n\n\t// Workspaces Management\n\tenterWorkspace(workspaceUri: URI): Promise<IEnterWorkspaceResult | undefined>;\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier>;\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\tgetWorkspaceIdentifier(workspaceUri: URI): Promise<IWorkspaceIdentifier>;\n\n\t// Workspaces History\n\treadonly onDidChangeRecentlyOpened: Event<void>;\n\taddRecentlyOpened(recents: IRecent[]): Promise<void>;\n\tremoveRecentlyOpened(workspaces: URI[]): Promise<void>;\n\tclearRecentlyOpened(): Promise<void>;\n\tgetRecentlyOpened(): Promise<IRecentlyOpened>;\n\n\t// Dirty Workspaces\n\tgetDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>>;\n}\n\n//#region Workspaces Recently Opened\n\nexport interface IRecentlyOpened {\n\tworkspaces: Array<IRecentWorkspace | IRecentFolder>;\n\tfiles: IRecentFile[];\n}\n\nexport type IRecent = IRecentWorkspace | IRecentFolder | IRecentFile;\n\nexport interface IRecentWorkspace {\n\treadonly workspace: IWorkspaceIdentifier;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFolder {\n\treadonly folderUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFile {\n\treadonly fileUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport function isRecentWorkspace(curr: IRecent): curr is IRecentWorkspace {\n\treturn curr.hasOwnProperty('workspace');\n}\n\nexport function isRecentFolder(curr: IRecent): curr is IRecentFolder {\n\treturn curr.hasOwnProperty('folderUri');\n}\n\nexport function isRecentFile(curr: IRecent): curr is IRecentFile {\n\treturn curr.hasOwnProperty('fileUri');\n}\n\n//#endregion\n\n//#region Workspace File Utilities\n\nexport function isStoredWorkspaceFolder(obj: unknown): obj is IStoredWorkspaceFolder {\n\treturn isRawFileWorkspaceFolder(obj) || isRawUriWorkspaceFolder(obj);\n}\n\nfunction isRawFileWorkspaceFolder(obj: unknown): obj is IRawFileWorkspaceFolder {\n\tconst candidate = obj as IRawFileWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.path === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nfunction isRawUriWorkspaceFolder(obj: unknown): obj is IRawUriWorkspaceFolder {\n\tconst candidate = obj as IRawUriWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.uri === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nexport type IStoredWorkspaceFolder = IRawFileWorkspaceFolder | IRawUriWorkspaceFolder;\n\nexport interface IStoredWorkspace extends IBaseWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n}\n\nexport interface IWorkspaceFolderCreationData {\n\treadonly uri: URI;\n\treadonly name?: string;\n}\n\nexport interface IUntitledWorkspaceInfo {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IEnterWorkspaceResult {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly backupPath?: string;\n}\n\n/**\n * Given a folder URI and the workspace config folder, computes the `IStoredWorkspaceFolder`\n * using a relative or absolute path or a uri.\n * Undefined is returned if the `folderURI` and the `targetConfigFolderURI` don't have the\n * same schema or authority.\n *\n * @param folderURI a workspace folder\n * @param forceAbsolute if set, keep the path absolute\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n */\nexport function getStoredWorkspaceFolder(folderURI: URI, forceAbsolute: boolean, folderName: string | undefined, targetConfigFolderURI: URI, extUri: IExtUri): IStoredWorkspaceFolder {\n\n\t// Scheme mismatch: use full absolute URI as `uri`\n\tif (folderURI.scheme !== targetConfigFolderURI.scheme) {\n\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t}\n\n\t// Always prefer a relative path if possible unless\n\t// prevented to make the workspace file shareable\n\t// with other users\n\tlet folderPath = !forceAbsolute ? extUri.relativePath(targetConfigFolderURI, folderURI) : undefined;\n\tif (folderPath !== undefined) {\n\t\tif (folderPath.length === 0) {\n\t\t\tfolderPath = '.';\n\t\t} else {\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t// We could not resolve a relative path\n\telse {\n\n\t\t// Local file: use `fsPath`\n\t\tif (folderURI.scheme === Schemas.file) {\n\t\t\tfolderPath = folderURI.fsPath;\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\n\t\t// Different authority: use full absolute URI\n\t\telse if (!extUri.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n\t\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t\t}\n\n\t\t// Non-local file: use `path` of URI\n\t\telse {\n\t\t\tfolderPath = folderURI.path;\n\t\t}\n\t}\n\n\treturn { name: folderName, path: folderPath };\n}\n\nfunction massagePathForWindows(folderPath: string) {\n\n\t// Drive letter should be upper case\n\tfolderPath = normalizeDriveLetter(folderPath);\n\n\t// Always prefer slash over backslash unless\n\t// we deal with UNC paths where backslash is\n\t// mandatory.\n\tif (!isUNC(folderPath)) {\n\t\tfolderPath = toSlashes(folderPath);\n\t}\n\n\treturn folderPath;\n}\n\nexport function toWorkspaceFolders(configuredFolders: IStoredWorkspaceFolder[], workspaceConfigFile: URI, extUri: IExtUri): WorkspaceFolder[] {\n\tconst result: WorkspaceFolder[] = [];\n\tconst seen: Set<string> = new Set();\n\n\tconst relativeTo = extUri.dirname(workspaceConfigFile);\n\tfor (const configuredFolder of configuredFolders) {\n\t\tlet uri: URI | undefined = undefined;\n\t\tif (isRawFileWorkspaceFolder(configuredFolder)) {\n\t\t\tif (configuredFolder.path) {\n\t\t\t\turi = extUri.resolvePath(relativeTo, configuredFolder.path);\n\t\t\t}\n\t\t} else if (isRawUriWorkspaceFolder(configuredFolder)) {\n\t\t\ttry {\n\t\t\t\turi = URI.parse(configuredFolder.uri);\n\t\t\t\tif (uri.path[0] !== posix.sep) {\n\t\t\t\t\turi = uri.with({ path: posix.sep + uri.path }); // this makes sure all workspace folder are absolute\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(e); // ignore\n\t\t\t}\n\t\t}\n\n\t\tif (uri) {\n\n\t\t\t// remove duplicates\n\t\t\tconst comparisonKey = extUri.getComparisonKey(uri);\n\t\t\tif (!seen.has(comparisonKey)) {\n\t\t\t\tseen.add(comparisonKey);\n\n\t\t\t\tconst name = configuredFolder.name || extUri.basenameOrAuthority(uri);\n\t\t\t\tresult.push(new WorkspaceFolder({ uri, name, index: result.length }, configuredFolder));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nexport function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents: string, configPathURI: URI, isFromUntitledWorkspace: boolean, targetConfigPathURI: URI, extUri: IExtUri) {\n\tconst storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n\n\tconst sourceConfigFolder = extUri.dirname(configPathURI);\n\tconst targetConfigFolder = extUri.dirname(targetConfigPathURI);\n\n\tconst rewrittenFolders: IStoredWorkspaceFolder[] = [];\n\n\tfor (const folder of storedWorkspace.folders) {\n\t\tconst folderURI = isRawFileWorkspaceFolder(folder) ? extUri.resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);\n\t\tlet absolute;\n\t\tif (isFromUntitledWorkspace) {\n\t\t\tabsolute = false; // if it was an untitled workspace, try to make paths relative\n\t\t} else {\n\t\t\tabsolute = !isRawFileWorkspaceFolder(folder) || isAbsolute(folder.path); // for existing workspaces, preserve whether a path was absolute or relative\n\t\t}\n\t\trewrittenFolders.push(getStoredWorkspaceFolder(folderURI, absolute, folder.name, targetConfigFolder, extUri));\n\t}\n\n\t// Preserve as much of the existing workspace as possible by using jsonEdit\n\t// and only changing the folders portion.\n\tconst formattingOptions: FormattingOptions = { insertSpaces: false, tabSize: 4, eol: (isLinux || isMacintosh) ? '\\n' : '\\r\\n' };\n\tconst edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, formattingOptions);\n\tlet newContent = jsonEdit.applyEdits(rawWorkspaceContents, edits);\n\n\tif (isEqualAuthority(storedWorkspace.remoteAuthority, getRemoteAuthority(targetConfigPathURI))) {\n\t\t// unsaved remote workspaces have the remoteAuthority set. Remove it when no longer nexessary.\n\t\tnewContent = jsonEdit.applyEdits(newContent, jsonEdit.removeProperty(newContent, ['remoteAuthority'], formattingOptions));\n\t}\n\n\treturn newContent;\n}\n\nfunction doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t// Parse workspace file\n\tconst storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t// Filter out folders which do not have a path or uri set\n\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t} else {\n\t\tthrow new Error(`${path} looks like an invalid workspace file.`);\n\t}\n\n\treturn storedWorkspace;\n}\n\n//#endregion\n\n//#region Workspace Storage\n\ninterface ISerializedRecentWorkspace {\n\treadonly workspace: {\n\t\tid: string;\n\t\tconfigPath: string;\n\t};\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFolder {\n\treadonly folderUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFile {\n\treadonly fileUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentlyOpened {\n\treadonly entries: Array<ISerializedRecentWorkspace | ISerializedRecentFolder | ISerializedRecentFile>; // since 1.55\n}\n\nexport type RecentlyOpenedStorageData = object;\n\nfunction isSerializedRecentWorkspace(data: unknown): data is ISerializedRecentWorkspace {\n\tconst candidate = data as ISerializedRecentWorkspace | undefined;\n\n\treturn typeof candidate?.workspace === 'object' && typeof candidate.workspace.id === 'string' && typeof candidate.workspace.configPath === 'string';\n}\n\nfunction isSerializedRecentFolder(data: unknown): data is ISerializedRecentFolder {\n\tconst candidate = data as ISerializedRecentFolder | undefined;\n\n\treturn typeof candidate?.folderUri === 'string';\n}\n\nfunction isSerializedRecentFile(data: unknown): data is ISerializedRecentFile {\n\tconst candidate = data as ISerializedRecentFile | undefined;\n\n\treturn typeof candidate?.fileUri === 'string';\n}\n\nexport function restoreRecentlyOpened(data: RecentlyOpenedStorageData | undefined, logService: ILogService): IRecentlyOpened {\n\tconst result: IRecentlyOpened = { workspaces: [], files: [] };\n\tif (data) {\n\t\tconst restoreGracefully = function <T>(entries: T[], onEntry: (entry: T, index: number) => void) {\n\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tonEntry(entries[i], i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogService.warn(`Error restoring recent entry ${JSON.stringify(entries[i])}: ${e.toString()}. Skip entry.`);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst storedRecents = data as ISerializedRecentlyOpened;\n\t\tif (Array.isArray(storedRecents.entries)) {\n\t\t\trestoreGracefully(storedRecents.entries, entry => {\n\t\t\t\tconst label = entry.label;\n\t\t\t\tconst remoteAuthority = entry.remoteAuthority;\n\n\t\t\t\tif (isSerializedRecentWorkspace(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, workspace: { id: entry.workspace.id, configPath: URI.parse(entry.workspace.configPath) } });\n\t\t\t\t} else if (isSerializedRecentFolder(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, folderUri: URI.parse(entry.folderUri) });\n\t\t\t\t} else if (isSerializedRecentFile(entry)) {\n\t\t\t\t\tresult.files.push({ label, remoteAuthority, fileUri: URI.parse(entry.fileUri) });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function toStoreData(recents: IRecentlyOpened): RecentlyOpenedStorageData {\n\tconst serialized: ISerializedRecentlyOpened = { entries: [] };\n\n\tconst storeLabel = (label: string | undefined, uri: URI) => {\n\t\t// Only store the label if it is provided\n\t\t// and only if it differs from the path\n\t\t// This gives us a chance to render the\n\t\t// path better, e.g. use `~` for home.\n\t\treturn label && label !== uri.fsPath && label !== uri.path;\n\t};\n\n\tfor (const recent of recents.workspaces) {\n\t\tif (isRecentFolder(recent)) {\n\t\t\tserialized.entries.push({\n\t\t\t\tfolderUri: recent.folderUri.toString(),\n\t\t\t\tlabel: storeLabel(recent.label, recent.folderUri) ? recent.label : undefined,\n\t\t\t\tremoteAuthority: recent.remoteAuthority\n\t\t\t});\n\t\t} else {\n\t\t\tserialized.entries.push({\n\t\t\t\tworkspace: {\n\t\t\t\t\tid: recent.workspace.id,\n\t\t\t\t\tconfigPath: recent.workspace.configPath.toString()\n\t\t\t\t},\n\t\t\t\tlabel: storeLabel(recent.label, recent.workspace.configPath) ? recent.label : undefined,\n\t\t\t\tremoteAuthority: recent.remoteAuthority\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (const recent of recents.files) {\n\t\tserialized.entries.push({\n\t\t\tfileUri: recent.fileUri.toString(),\n\t\t\tlabel: storeLabel(recent.label, recent.fileUri) ? recent.label : undefined,\n\t\t\tremoteAuthority: recent.remoteAuthority\n\t\t});\n\t}\n\n\treturn serialized;\n}\n\n//#endregion\n"]}