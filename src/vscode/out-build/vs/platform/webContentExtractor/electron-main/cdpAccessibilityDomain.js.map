{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/webContentExtractor/electron-main/cdpAccessibilityDomain.ts","vs/platform/webContentExtractor/electron-main/cdpAccessibilityDomain.ts"],"names":[],"mappings":"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","file":"cdpAccessibilityDomain.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n//#region Types\n\nimport { URI } from '../../../base/common/uri.js';\n\nexport interface AXValue {\n\ttype: AXValueType;\n\tvalue?: unknown;\n\trelatedNodes?: AXNode[];\n\tsources?: AXValueSource[];\n}\n\nexport interface AXValueSource {\n\ttype: AXValueSourceType;\n\tvalue?: AXValue;\n\tattribute?: string;\n\tattributeValue?: string;\n\tsuperseded?: boolean;\n\tnativeSource?: AXValueNativeSourceType;\n\tnativeSourceValue?: string;\n\tinvalid?: boolean;\n\tinvalidReason?: string;\n}\n\nexport interface AXNode {\n\tnodeId: string;\n\tignored: boolean;\n\tignoredReasons?: AXProperty[];\n\trole?: AXValue;\n\tchromeRole?: AXValue;\n\tname?: AXValue;\n\tdescription?: AXValue;\n\tvalue?: AXValue;\n\tproperties?: AXProperty[];\n\tchildIds?: string[];\n\tbackendDOMNodeId?: number;\n}\n\nexport interface AXProperty {\n\tname: AXPropertyName;\n\tvalue: AXValue;\n}\n\nexport type AXValueType = 'boolean' | 'tristate' | 'booleanOrUndefined' | 'idref' | 'idrefList' | 'integer' | 'node' | 'nodeList' | 'number' | 'string' | 'computedString' | 'token' | 'tokenList' | 'domRelation' | 'role' | 'internalRole' | 'valueUndefined';\n\nexport type AXValueSourceType = 'attribute' | 'implicit' | 'style' | 'contents' | 'placeholder' | 'relatedElement';\n\nexport type AXValueNativeSourceType = 'description' | 'figcaption' | 'label' | 'labelfor' | 'labelwrapped' | 'legend' | 'rubyannotation' | 'tablecaption' | 'title' | 'other';\n\nexport type AXPropertyName = 'url' | 'busy' | 'disabled' | 'editable' | 'focusable' | 'focused' | 'hidden' | 'hiddenRoot' | 'invalid' | 'keyshortcuts' | 'settable' | 'roledescription' | 'live' | 'atomic' | 'relevant' | 'root' | 'autocomplete' | 'hasPopup' | 'level' | 'multiselectable' | 'orientation' | 'multiline' | 'readonly' | 'required' | 'valuemin' | 'valuemax' | 'valuetext' | 'checked' | 'expanded' | 'pressed' | 'selected' | 'activedescendant' | 'controls' | 'describedby' | 'details' | 'errormessage' | 'flowto' | 'labelledby' | 'owns';\n\n//#endregion\n\ninterface AXNodeTree {\n\treadonly node: AXNode;\n\treadonly children: AXNodeTree[];\n\tparent: AXNodeTree | null;\n}\n\nfunction createNodeTree(nodes: AXNode[]): AXNodeTree | null {\n\tif (nodes.length === 0) {\n\t\treturn null;\n\t}\n\n\t// Create a map of node IDs to their corresponding nodes for quick lookup\n\tconst nodeLookup = new Map<string, AXNode>();\n\tfor (const node of nodes) {\n\t\tnodeLookup.set(node.nodeId, node);\n\t}\n\n\t// Helper function to get all non-ignored descendants of a node\n\tfunction getNonIgnoredDescendants(nodeId: string): string[] {\n\t\tconst node = nodeLookup.get(nodeId);\n\t\tif (!node || !node.childIds) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: string[] = [];\n\t\tfor (const childId of node.childIds) {\n\t\t\tconst childNode = nodeLookup.get(childId);\n\t\t\tif (!childNode) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (childNode.ignored) {\n\t\t\t\t// If child is ignored, add its non-ignored descendants instead\n\t\t\t\tresult.push(...getNonIgnoredDescendants(childId));\n\t\t\t} else {\n\t\t\t\t// Otherwise, add the child itself\n\t\t\t\tresult.push(childId);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Create tree nodes only for non-ignored nodes\n\tconst nodeMap = new Map<string, AXNodeTree>();\n\tfor (const node of nodes) {\n\t\tif (!node.ignored) {\n\t\t\tnodeMap.set(node.nodeId, { node, children: [], parent: null });\n\t\t}\n\t}\n\n\t// Establish parent-child relationships, bypassing ignored nodes\n\tfor (const node of nodes) {\n\t\tif (node.ignored) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst treeNode = nodeMap.get(node.nodeId)!;\n\t\tif (node.childIds) {\n\t\t\tfor (const childId of node.childIds) {\n\t\t\t\tconst childNode = nodeLookup.get(childId);\n\t\t\t\tif (!childNode) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (childNode.ignored) {\n\t\t\t\t\t// If child is ignored, connect its non-ignored descendants to this node\n\t\t\t\t\tconst nonIgnoredDescendants = getNonIgnoredDescendants(childId);\n\t\t\t\t\tfor (const descendantId of nonIgnoredDescendants) {\n\t\t\t\t\t\tconst descendantTreeNode = nodeMap.get(descendantId);\n\t\t\t\t\t\tif (descendantTreeNode) {\n\t\t\t\t\t\t\tdescendantTreeNode.parent = treeNode;\n\t\t\t\t\t\t\ttreeNode.children.push(descendantTreeNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Normal case: add non-ignored child directly\n\t\t\t\t\tconst childTreeNode = nodeMap.get(childId);\n\t\t\t\t\tif (childTreeNode) {\n\t\t\t\t\t\tchildTreeNode.parent = treeNode;\n\t\t\t\t\t\ttreeNode.children.push(childTreeNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find the root node (a node without a parent)\n\tfor (const node of nodeMap.values()) {\n\t\tif (!node.parent) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * When possible, we will make sure lines are no longer than 80. This is to help\n * certain pieces of software that can't handle long lines.\n */\nconst LINE_MAX_LENGTH = 80;\n\n/**\n * Converts an accessibility tree represented by AXNode objects into a markdown string.\n *\n * @param uri The URI of the document\n * @param axNodes The array of AXNode objects representing the accessibility tree\n * @returns A markdown representation of the accessibility tree\n */\nexport function convertAXTreeToMarkdown(uri: URI, axNodes: AXNode[]): string {\n\tconst tree = createNodeTree(axNodes);\n\tif (!tree) {\n\t\treturn ''; // Return empty string for empty tree\n\t}\n\n\t// Process tree to extract main content and navigation links\n\tconst mainContent = extractMainContent(uri, tree);\n\tconst navLinks = collectNavigationLinks(tree);\n\n\t// Combine main content and navigation links\n\treturn mainContent + (navLinks.length > 0 ? '\\n\\n## Additional Links\\n' + navLinks.join('\\n') : '');\n}\n\nfunction extractMainContent(uri: URI, tree: AXNodeTree): string {\n\tconst contentBuffer: string[] = [];\n\tprocessNode(uri, tree, contentBuffer, 0, true);\n\treturn contentBuffer.join('');\n}\n\nfunction processNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number, allowWrap: boolean): void {\n\tconst role = getNodeRole(node.node);\n\n\tswitch (role) {\n\t\tcase 'navigation':\n\t\t\treturn; // Skip navigation nodes\n\n\t\tcase 'heading':\n\t\t\tprocessHeadingNode(uri, node, buffer, depth);\n\t\t\treturn;\n\n\t\tcase 'paragraph':\n\t\t\tprocessParagraphNode(uri, node, buffer, depth, allowWrap);\n\t\t\treturn;\n\n\t\tcase 'list':\n\t\t\tbuffer.push('\\n');\n\t\t\tfor (const descChild of node.children) {\n\t\t\t\tprocessNode(uri, descChild, buffer, depth + 1, true);\n\t\t\t}\n\t\t\tbuffer.push('\\n');\n\t\t\treturn;\n\n\t\tcase 'ListMarker':\n\t\t\t// TODO: Should we normalize these ListMarkers to `-` and normal lists?\n\t\t\tbuffer.push(getNodeText(node.node, allowWrap));\n\t\t\treturn;\n\n\t\tcase 'listitem': {\n\t\t\tconst tempBuffer: string[] = [];\n\t\t\t// Process the children of the list item\n\t\t\tfor (const descChild of node.children) {\n\t\t\t\tprocessNode(uri, descChild, tempBuffer, depth + 1, true);\n\t\t\t}\n\t\t\tconst indent = getLevel(node.node) > 1 ? ' '.repeat(getLevel(node.node)) : '';\n\t\t\tbuffer.push(`${indent}${tempBuffer.join('').trim()}\\n`);\n\t\t\treturn;\n\t\t}\n\n\t\tcase 'link':\n\t\t\tif (!isNavigationLink(node)) {\n\t\t\t\tconst linkText = getNodeText(node.node, allowWrap);\n\t\t\t\tconst url = getLinkUrl(node.node);\n\t\t\t\tif (!isSameUriIgnoringQueryAndFragment(uri, node.node)) {\n\t\t\t\t\tbuffer.push(`[${linkText}](${url})`);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer.push(linkText);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\tcase 'StaticText': {\n\t\t\tconst staticText = getNodeText(node.node, allowWrap);\n\t\t\tif (staticText) {\n\t\t\t\tbuffer.push(staticText);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'image': {\n\t\t\tconst altText = getNodeText(node.node, allowWrap) || 'Image';\n\t\t\tconst imageUrl = getImageUrl(node.node);\n\t\t\tif (imageUrl) {\n\t\t\t\tbuffer.push(`![${altText}](${imageUrl})\\n\\n`);\n\t\t\t} else {\n\t\t\t\tbuffer.push(`[Image: ${altText}]\\n\\n`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'DescriptionList':\n\t\t\tprocessDescriptionListNode(uri, node, buffer, depth);\n\t\t\treturn;\n\n\t\tcase 'blockquote':\n\t\t\tbuffer.push('> ' + getNodeText(node.node, allowWrap).replace(/\\n/g, '\\n> ') + '\\n\\n');\n\t\t\tbreak;\n\n\t\t// TODO: Is this the correct way to handle the generic role?\n\t\tcase 'generic':\n\t\t\tbuffer.push(' ');\n\t\t\tbreak;\n\n\t\tcase 'code': {\n\t\t\tprocessCodeNode(uri, node, buffer, depth);\n\t\t\treturn;\n\t\t}\n\n\t\tcase 'pre':\n\t\t\tbuffer.push('```\\n' + getNodeText(node.node, false) + '\\n```\\n\\n');\n\t\t\tbreak;\n\n\t\tcase 'table':\n\t\t\tprocessTableNode(node, buffer);\n\t\t\treturn;\n\t}\n\n\t// Process children if not already handled in specific cases\n\tfor (const child of node.children) {\n\t\tprocessNode(uri, child, buffer, depth + 1, allowWrap);\n\t}\n}\n\nfunction getNodeRole(node: AXNode): string {\n\treturn node.role?.value as string || '';\n}\n\nfunction getNodeText(node: AXNode, allowWrap: boolean): string {\n\tconst text = node.name?.value as string || node.value?.value as string || '';\n\tif (!allowWrap) {\n\t\treturn text;\n\t}\n\n\tif (text.length <= LINE_MAX_LENGTH) {\n\t\treturn text;\n\t}\n\n\tconst chars = text.split('');\n\tlet lastSpaceIndex = -1;\n\tfor (let i = 1; i < chars.length; i++) {\n\t\tif (chars[i] === ' ') {\n\t\t\tlastSpaceIndex = i;\n\t\t}\n\t\t// Check if we reached the line max length, try to break at the last space\n\t\t// before the line max length\n\t\tif (i % LINE_MAX_LENGTH === 0 && lastSpaceIndex !== -1) {\n\t\t\t// replace the space with a new line\n\t\t\tchars[lastSpaceIndex] = '\\n';\n\t\t\tlastSpaceIndex = i;\n\t\t}\n\t}\n\treturn chars.join('');\n}\n\nfunction getLevel(node: AXNode): number {\n\tconst levelProp = node.properties?.find(p => p.name === 'level');\n\treturn levelProp ? Math.min(Number(levelProp.value.value) || 1, 6) : 1;\n}\n\nfunction getLinkUrl(node: AXNode): string {\n\t// Find URL in properties\n\tconst urlProp = node.properties?.find(p => p.name === 'url');\n\treturn urlProp?.value.value as string || '#';\n}\n\nfunction getImageUrl(node: AXNode): string | null {\n\t// Find URL in properties\n\tconst urlProp = node.properties?.find(p => p.name === 'url');\n\treturn urlProp?.value.value as string || null;\n}\n\nfunction isNavigationLink(node: AXNodeTree): boolean {\n\t// Check if this link is part of navigation\n\tlet current: AXNodeTree | null = node;\n\twhile (current) {\n\t\tconst role = getNodeRole(current.node);\n\t\tif (['navigation', 'menu', 'menubar'].includes(role)) {\n\t\t\treturn true;\n\t\t}\n\t\tcurrent = current.parent;\n\t}\n\treturn false;\n}\n\nfunction isSameUriIgnoringQueryAndFragment(uri: URI, node: AXNode): boolean {\n\t// Check if this link is an anchor link\n\tconst link = getLinkUrl(node);\n\ttry {\n\t\tconst parsed = URI.parse(link);\n\t\treturn parsed.scheme === uri.scheme && parsed.authority === uri.authority && parsed.path === uri.path;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction processParagraphNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number, allowWrap: boolean): void {\n\tbuffer.push('\\n');\n\t// Process the children of the paragraph\n\tfor (const child of node.children) {\n\t\tprocessNode(uri, child, buffer, depth + 1, allowWrap);\n\t}\n\tbuffer.push('\\n\\n');\n}\n\nfunction processHeadingNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number): void {\n\tbuffer.push('\\n');\n\tconst level = getLevel(node.node);\n\tbuffer.push(`${'#'.repeat(level)} `);\n\t// Process children nodes of the heading\n\tfor (const child of node.children) {\n\t\tif (getNodeRole(child.node) === 'StaticText') {\n\t\t\tbuffer.push(getNodeText(child.node, false));\n\t\t} else {\n\t\t\tprocessNode(uri, child, buffer, depth + 1, false);\n\t\t}\n\t}\n\tbuffer.push('\\n\\n');\n}\n\nfunction processDescriptionListNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number): void {\n\tbuffer.push('\\n');\n\n\t// Process each child of the description list\n\tfor (const child of node.children) {\n\t\tif (getNodeRole(child.node) === 'term') {\n\t\t\tbuffer.push('- **');\n\t\t\t// Process term nodes\n\t\t\tfor (const termChild of child.children) {\n\t\t\t\tprocessNode(uri, termChild, buffer, depth + 1, true);\n\t\t\t}\n\t\t\tbuffer.push('** ');\n\t\t} else if (getNodeRole(child.node) === 'definition') {\n\t\t\t// Process description nodes\n\t\t\tfor (const descChild of child.children) {\n\t\t\t\tprocessNode(uri, descChild, buffer, depth + 1, true);\n\t\t\t}\n\t\t\tbuffer.push('\\n');\n\t\t}\n\t}\n\n\tbuffer.push('\\n');\n}\n\nfunction isTableCell(role: string): boolean {\n\t// Match cell, gridcell, columnheader, rowheader roles\n\treturn role === 'cell' || role === 'gridcell' || role === 'columnheader' || role === 'rowheader';\n}\n\nfunction processTableNode(node: AXNodeTree, buffer: string[]): void {\n\tbuffer.push('\\n');\n\n\t// Find rows\n\tconst rows = node.children.filter(child => getNodeRole(child.node).includes('row'));\n\n\tif (rows.length > 0) {\n\t\t// First row as header\n\t\tconst headerCells = rows[0].children.filter(cell => isTableCell(getNodeRole(cell.node)));\n\n\t\t// Generate header row\n\t\tconst headerContent = headerCells.map(cell => getNodeText(cell.node, false) || ' ');\n\t\tbuffer.push('| ' + headerContent.join(' | ') + ' |\\n');\n\n\t\t// Generate separator row\n\t\tbuffer.push('| ' + headerCells.map(() => '---').join(' | ') + ' |\\n');\n\n\t\t// Generate data rows\n\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\tconst dataCells = rows[i].children.filter(cell => isTableCell(getNodeRole(cell.node)));\n\t\t\tconst rowContent = dataCells.map(cell => getNodeText(cell.node, false) || ' ');\n\t\t\tbuffer.push('| ' + rowContent.join(' | ') + ' |\\n');\n\t\t}\n\t}\n\n\tbuffer.push('\\n');\n}\n\nfunction processCodeNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number): void {\n\tconst tempBuffer: string[] = [];\n\t// Process the children of the code node\n\tfor (const child of node.children) {\n\t\tprocessNode(uri, child, tempBuffer, depth + 1, false);\n\t}\n\tconst isCodeblock = tempBuffer.some(text => text.includes('\\n'));\n\tif (isCodeblock) {\n\t\tbuffer.push('\\n```\\n');\n\t\t// Append the processed text to the buffer\n\t\tbuffer.push(tempBuffer.join(''));\n\t\tbuffer.push('\\n```\\n');\n\t} else {\n\t\tbuffer.push('`');\n\t\tlet characterCount = 0;\n\t\t// Append the processed text to the buffer\n\t\tfor (const tempItem of tempBuffer) {\n\t\t\tcharacterCount += tempItem.length;\n\t\t\tif (characterCount > LINE_MAX_LENGTH) {\n\t\t\t\tbuffer.push('\\n');\n\t\t\t\tcharacterCount = 0;\n\t\t\t}\n\t\t\tbuffer.push(tempItem);\n\t\t\tbuffer.push('`');\n\t\t}\n\t}\n}\n\nfunction collectNavigationLinks(tree: AXNodeTree): string[] {\n\tconst links: string[] = [];\n\tcollectLinks(tree, links);\n\treturn links;\n}\n\nfunction collectLinks(node: AXNodeTree, links: string[]): void {\n\tconst role = getNodeRole(node.node);\n\n\tif (role === 'link' && isNavigationLink(node)) {\n\t\tconst linkText = getNodeText(node.node, true);\n\t\tconst url = getLinkUrl(node.node);\n\t\tconst description = node.node.description?.value as string || '';\n\n\t\tlinks.push(`- [${linkText}](${url})${description ? ' - ' + description : ''}`);\n\t}\n\n\t// Process children\n\tfor (const child of node.children) {\n\t\tcollectLinks(child, links);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n//#region Types\n\nimport { URI } from '../../../base/common/uri.js';\n\nexport interface AXValue {\n\ttype: AXValueType;\n\tvalue?: unknown;\n\trelatedNodes?: AXNode[];\n\tsources?: AXValueSource[];\n}\n\nexport interface AXValueSource {\n\ttype: AXValueSourceType;\n\tvalue?: AXValue;\n\tattribute?: string;\n\tattributeValue?: string;\n\tsuperseded?: boolean;\n\tnativeSource?: AXValueNativeSourceType;\n\tnativeSourceValue?: string;\n\tinvalid?: boolean;\n\tinvalidReason?: string;\n}\n\nexport interface AXNode {\n\tnodeId: string;\n\tignored: boolean;\n\tignoredReasons?: AXProperty[];\n\trole?: AXValue;\n\tchromeRole?: AXValue;\n\tname?: AXValue;\n\tdescription?: AXValue;\n\tvalue?: AXValue;\n\tproperties?: AXProperty[];\n\tchildIds?: string[];\n\tbackendDOMNodeId?: number;\n}\n\nexport interface AXProperty {\n\tname: AXPropertyName;\n\tvalue: AXValue;\n}\n\nexport type AXValueType = 'boolean' | 'tristate' | 'booleanOrUndefined' | 'idref' | 'idrefList' | 'integer' | 'node' | 'nodeList' | 'number' | 'string' | 'computedString' | 'token' | 'tokenList' | 'domRelation' | 'role' | 'internalRole' | 'valueUndefined';\n\nexport type AXValueSourceType = 'attribute' | 'implicit' | 'style' | 'contents' | 'placeholder' | 'relatedElement';\n\nexport type AXValueNativeSourceType = 'description' | 'figcaption' | 'label' | 'labelfor' | 'labelwrapped' | 'legend' | 'rubyannotation' | 'tablecaption' | 'title' | 'other';\n\nexport type AXPropertyName = 'url' | 'busy' | 'disabled' | 'editable' | 'focusable' | 'focused' | 'hidden' | 'hiddenRoot' | 'invalid' | 'keyshortcuts' | 'settable' | 'roledescription' | 'live' | 'atomic' | 'relevant' | 'root' | 'autocomplete' | 'hasPopup' | 'level' | 'multiselectable' | 'orientation' | 'multiline' | 'readonly' | 'required' | 'valuemin' | 'valuemax' | 'valuetext' | 'checked' | 'expanded' | 'pressed' | 'selected' | 'activedescendant' | 'controls' | 'describedby' | 'details' | 'errormessage' | 'flowto' | 'labelledby' | 'owns';\n\n//#endregion\n\ninterface AXNodeTree {\n\treadonly node: AXNode;\n\treadonly children: AXNodeTree[];\n\tparent: AXNodeTree | null;\n}\n\nfunction createNodeTree(nodes: AXNode[]): AXNodeTree | null {\n\tif (nodes.length === 0) {\n\t\treturn null;\n\t}\n\n\t// Create a map of node IDs to their corresponding nodes for quick lookup\n\tconst nodeLookup = new Map<string, AXNode>();\n\tfor (const node of nodes) {\n\t\tnodeLookup.set(node.nodeId, node);\n\t}\n\n\t// Helper function to get all non-ignored descendants of a node\n\tfunction getNonIgnoredDescendants(nodeId: string): string[] {\n\t\tconst node = nodeLookup.get(nodeId);\n\t\tif (!node || !node.childIds) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: string[] = [];\n\t\tfor (const childId of node.childIds) {\n\t\t\tconst childNode = nodeLookup.get(childId);\n\t\t\tif (!childNode) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (childNode.ignored) {\n\t\t\t\t// If child is ignored, add its non-ignored descendants instead\n\t\t\t\tresult.push(...getNonIgnoredDescendants(childId));\n\t\t\t} else {\n\t\t\t\t// Otherwise, add the child itself\n\t\t\t\tresult.push(childId);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Create tree nodes only for non-ignored nodes\n\tconst nodeMap = new Map<string, AXNodeTree>();\n\tfor (const node of nodes) {\n\t\tif (!node.ignored) {\n\t\t\tnodeMap.set(node.nodeId, { node, children: [], parent: null });\n\t\t}\n\t}\n\n\t// Establish parent-child relationships, bypassing ignored nodes\n\tfor (const node of nodes) {\n\t\tif (node.ignored) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst treeNode = nodeMap.get(node.nodeId)!;\n\t\tif (node.childIds) {\n\t\t\tfor (const childId of node.childIds) {\n\t\t\t\tconst childNode = nodeLookup.get(childId);\n\t\t\t\tif (!childNode) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (childNode.ignored) {\n\t\t\t\t\t// If child is ignored, connect its non-ignored descendants to this node\n\t\t\t\t\tconst nonIgnoredDescendants = getNonIgnoredDescendants(childId);\n\t\t\t\t\tfor (const descendantId of nonIgnoredDescendants) {\n\t\t\t\t\t\tconst descendantTreeNode = nodeMap.get(descendantId);\n\t\t\t\t\t\tif (descendantTreeNode) {\n\t\t\t\t\t\t\tdescendantTreeNode.parent = treeNode;\n\t\t\t\t\t\t\ttreeNode.children.push(descendantTreeNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Normal case: add non-ignored child directly\n\t\t\t\t\tconst childTreeNode = nodeMap.get(childId);\n\t\t\t\t\tif (childTreeNode) {\n\t\t\t\t\t\tchildTreeNode.parent = treeNode;\n\t\t\t\t\t\ttreeNode.children.push(childTreeNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find the root node (a node without a parent)\n\tfor (const node of nodeMap.values()) {\n\t\tif (!node.parent) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * When possible, we will make sure lines are no longer than 80. This is to help\n * certain pieces of software that can't handle long lines.\n */\nconst LINE_MAX_LENGTH = 80;\n\n/**\n * Converts an accessibility tree represented by AXNode objects into a markdown string.\n *\n * @param uri The URI of the document\n * @param axNodes The array of AXNode objects representing the accessibility tree\n * @returns A markdown representation of the accessibility tree\n */\nexport function convertAXTreeToMarkdown(uri: URI, axNodes: AXNode[]): string {\n\tconst tree = createNodeTree(axNodes);\n\tif (!tree) {\n\t\treturn ''; // Return empty string for empty tree\n\t}\n\n\t// Process tree to extract main content and navigation links\n\tconst mainContent = extractMainContent(uri, tree);\n\tconst navLinks = collectNavigationLinks(tree);\n\n\t// Combine main content and navigation links\n\treturn mainContent + (navLinks.length > 0 ? '\\n\\n## Additional Links\\n' + navLinks.join('\\n') : '');\n}\n\nfunction extractMainContent(uri: URI, tree: AXNodeTree): string {\n\tconst contentBuffer: string[] = [];\n\tprocessNode(uri, tree, contentBuffer, 0, true);\n\treturn contentBuffer.join('');\n}\n\nfunction processNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number, allowWrap: boolean): void {\n\tconst role = getNodeRole(node.node);\n\n\tswitch (role) {\n\t\tcase 'navigation':\n\t\t\treturn; // Skip navigation nodes\n\n\t\tcase 'heading':\n\t\t\tprocessHeadingNode(uri, node, buffer, depth);\n\t\t\treturn;\n\n\t\tcase 'paragraph':\n\t\t\tprocessParagraphNode(uri, node, buffer, depth, allowWrap);\n\t\t\treturn;\n\n\t\tcase 'list':\n\t\t\tbuffer.push('\\n');\n\t\t\tfor (const descChild of node.children) {\n\t\t\t\tprocessNode(uri, descChild, buffer, depth + 1, true);\n\t\t\t}\n\t\t\tbuffer.push('\\n');\n\t\t\treturn;\n\n\t\tcase 'ListMarker':\n\t\t\t// TODO: Should we normalize these ListMarkers to `-` and normal lists?\n\t\t\tbuffer.push(getNodeText(node.node, allowWrap));\n\t\t\treturn;\n\n\t\tcase 'listitem': {\n\t\t\tconst tempBuffer: string[] = [];\n\t\t\t// Process the children of the list item\n\t\t\tfor (const descChild of node.children) {\n\t\t\t\tprocessNode(uri, descChild, tempBuffer, depth + 1, true);\n\t\t\t}\n\t\t\tconst indent = getLevel(node.node) > 1 ? ' '.repeat(getLevel(node.node)) : '';\n\t\t\tbuffer.push(`${indent}${tempBuffer.join('').trim()}\\n`);\n\t\t\treturn;\n\t\t}\n\n\t\tcase 'link':\n\t\t\tif (!isNavigationLink(node)) {\n\t\t\t\tconst linkText = getNodeText(node.node, allowWrap);\n\t\t\t\tconst url = getLinkUrl(node.node);\n\t\t\t\tif (!isSameUriIgnoringQueryAndFragment(uri, node.node)) {\n\t\t\t\t\tbuffer.push(`[${linkText}](${url})`);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer.push(linkText);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\tcase 'StaticText': {\n\t\t\tconst staticText = getNodeText(node.node, allowWrap);\n\t\t\tif (staticText) {\n\t\t\t\tbuffer.push(staticText);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'image': {\n\t\t\tconst altText = getNodeText(node.node, allowWrap) || 'Image';\n\t\t\tconst imageUrl = getImageUrl(node.node);\n\t\t\tif (imageUrl) {\n\t\t\t\tbuffer.push(`![${altText}](${imageUrl})\\n\\n`);\n\t\t\t} else {\n\t\t\t\tbuffer.push(`[Image: ${altText}]\\n\\n`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'DescriptionList':\n\t\t\tprocessDescriptionListNode(uri, node, buffer, depth);\n\t\t\treturn;\n\n\t\tcase 'blockquote':\n\t\t\tbuffer.push('> ' + getNodeText(node.node, allowWrap).replace(/\\n/g, '\\n> ') + '\\n\\n');\n\t\t\tbreak;\n\n\t\t// TODO: Is this the correct way to handle the generic role?\n\t\tcase 'generic':\n\t\t\tbuffer.push(' ');\n\t\t\tbreak;\n\n\t\tcase 'code': {\n\t\t\tprocessCodeNode(uri, node, buffer, depth);\n\t\t\treturn;\n\t\t}\n\n\t\tcase 'pre':\n\t\t\tbuffer.push('```\\n' + getNodeText(node.node, false) + '\\n```\\n\\n');\n\t\t\tbreak;\n\n\t\tcase 'table':\n\t\t\tprocessTableNode(node, buffer);\n\t\t\treturn;\n\t}\n\n\t// Process children if not already handled in specific cases\n\tfor (const child of node.children) {\n\t\tprocessNode(uri, child, buffer, depth + 1, allowWrap);\n\t}\n}\n\nfunction getNodeRole(node: AXNode): string {\n\treturn node.role?.value as string || '';\n}\n\nfunction getNodeText(node: AXNode, allowWrap: boolean): string {\n\tconst text = node.name?.value as string || node.value?.value as string || '';\n\tif (!allowWrap) {\n\t\treturn text;\n\t}\n\n\tif (text.length <= LINE_MAX_LENGTH) {\n\t\treturn text;\n\t}\n\n\tconst chars = text.split('');\n\tlet lastSpaceIndex = -1;\n\tfor (let i = 1; i < chars.length; i++) {\n\t\tif (chars[i] === ' ') {\n\t\t\tlastSpaceIndex = i;\n\t\t}\n\t\t// Check if we reached the line max length, try to break at the last space\n\t\t// before the line max length\n\t\tif (i % LINE_MAX_LENGTH === 0 && lastSpaceIndex !== -1) {\n\t\t\t// replace the space with a new line\n\t\t\tchars[lastSpaceIndex] = '\\n';\n\t\t\tlastSpaceIndex = i;\n\t\t}\n\t}\n\treturn chars.join('');\n}\n\nfunction getLevel(node: AXNode): number {\n\tconst levelProp = node.properties?.find(p => p.name === 'level');\n\treturn levelProp ? Math.min(Number(levelProp.value.value) || 1, 6) : 1;\n}\n\nfunction getLinkUrl(node: AXNode): string {\n\t// Find URL in properties\n\tconst urlProp = node.properties?.find(p => p.name === 'url');\n\treturn urlProp?.value.value as string || '#';\n}\n\nfunction getImageUrl(node: AXNode): string | null {\n\t// Find URL in properties\n\tconst urlProp = node.properties?.find(p => p.name === 'url');\n\treturn urlProp?.value.value as string || null;\n}\n\nfunction isNavigationLink(node: AXNodeTree): boolean {\n\t// Check if this link is part of navigation\n\tlet current: AXNodeTree | null = node;\n\twhile (current) {\n\t\tconst role = getNodeRole(current.node);\n\t\tif (['navigation', 'menu', 'menubar'].includes(role)) {\n\t\t\treturn true;\n\t\t}\n\t\tcurrent = current.parent;\n\t}\n\treturn false;\n}\n\nfunction isSameUriIgnoringQueryAndFragment(uri: URI, node: AXNode): boolean {\n\t// Check if this link is an anchor link\n\tconst link = getLinkUrl(node);\n\ttry {\n\t\tconst parsed = URI.parse(link);\n\t\treturn parsed.scheme === uri.scheme && parsed.authority === uri.authority && parsed.path === uri.path;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction processParagraphNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number, allowWrap: boolean): void {\n\tbuffer.push('\\n');\n\t// Process the children of the paragraph\n\tfor (const child of node.children) {\n\t\tprocessNode(uri, child, buffer, depth + 1, allowWrap);\n\t}\n\tbuffer.push('\\n\\n');\n}\n\nfunction processHeadingNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number): void {\n\tbuffer.push('\\n');\n\tconst level = getLevel(node.node);\n\tbuffer.push(`${'#'.repeat(level)} `);\n\t// Process children nodes of the heading\n\tfor (const child of node.children) {\n\t\tif (getNodeRole(child.node) === 'StaticText') {\n\t\t\tbuffer.push(getNodeText(child.node, false));\n\t\t} else {\n\t\t\tprocessNode(uri, child, buffer, depth + 1, false);\n\t\t}\n\t}\n\tbuffer.push('\\n\\n');\n}\n\nfunction processDescriptionListNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number): void {\n\tbuffer.push('\\n');\n\n\t// Process each child of the description list\n\tfor (const child of node.children) {\n\t\tif (getNodeRole(child.node) === 'term') {\n\t\t\tbuffer.push('- **');\n\t\t\t// Process term nodes\n\t\t\tfor (const termChild of child.children) {\n\t\t\t\tprocessNode(uri, termChild, buffer, depth + 1, true);\n\t\t\t}\n\t\t\tbuffer.push('** ');\n\t\t} else if (getNodeRole(child.node) === 'definition') {\n\t\t\t// Process description nodes\n\t\t\tfor (const descChild of child.children) {\n\t\t\t\tprocessNode(uri, descChild, buffer, depth + 1, true);\n\t\t\t}\n\t\t\tbuffer.push('\\n');\n\t\t}\n\t}\n\n\tbuffer.push('\\n');\n}\n\nfunction isTableCell(role: string): boolean {\n\t// Match cell, gridcell, columnheader, rowheader roles\n\treturn role === 'cell' || role === 'gridcell' || role === 'columnheader' || role === 'rowheader';\n}\n\nfunction processTableNode(node: AXNodeTree, buffer: string[]): void {\n\tbuffer.push('\\n');\n\n\t// Find rows\n\tconst rows = node.children.filter(child => getNodeRole(child.node).includes('row'));\n\n\tif (rows.length > 0) {\n\t\t// First row as header\n\t\tconst headerCells = rows[0].children.filter(cell => isTableCell(getNodeRole(cell.node)));\n\n\t\t// Generate header row\n\t\tconst headerContent = headerCells.map(cell => getNodeText(cell.node, false) || ' ');\n\t\tbuffer.push('| ' + headerContent.join(' | ') + ' |\\n');\n\n\t\t// Generate separator row\n\t\tbuffer.push('| ' + headerCells.map(() => '---').join(' | ') + ' |\\n');\n\n\t\t// Generate data rows\n\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\tconst dataCells = rows[i].children.filter(cell => isTableCell(getNodeRole(cell.node)));\n\t\t\tconst rowContent = dataCells.map(cell => getNodeText(cell.node, false) || ' ');\n\t\t\tbuffer.push('| ' + rowContent.join(' | ') + ' |\\n');\n\t\t}\n\t}\n\n\tbuffer.push('\\n');\n}\n\nfunction processCodeNode(uri: URI, node: AXNodeTree, buffer: string[], depth: number): void {\n\tconst tempBuffer: string[] = [];\n\t// Process the children of the code node\n\tfor (const child of node.children) {\n\t\tprocessNode(uri, child, tempBuffer, depth + 1, false);\n\t}\n\tconst isCodeblock = tempBuffer.some(text => text.includes('\\n'));\n\tif (isCodeblock) {\n\t\tbuffer.push('\\n```\\n');\n\t\t// Append the processed text to the buffer\n\t\tbuffer.push(tempBuffer.join(''));\n\t\tbuffer.push('\\n```\\n');\n\t} else {\n\t\tbuffer.push('`');\n\t\tlet characterCount = 0;\n\t\t// Append the processed text to the buffer\n\t\tfor (const tempItem of tempBuffer) {\n\t\t\tcharacterCount += tempItem.length;\n\t\t\tif (characterCount > LINE_MAX_LENGTH) {\n\t\t\t\tbuffer.push('\\n');\n\t\t\t\tcharacterCount = 0;\n\t\t\t}\n\t\t\tbuffer.push(tempItem);\n\t\t\tbuffer.push('`');\n\t\t}\n\t}\n}\n\nfunction collectNavigationLinks(tree: AXNodeTree): string[] {\n\tconst links: string[] = [];\n\tcollectLinks(tree, links);\n\treturn links;\n}\n\nfunction collectLinks(node: AXNodeTree, links: string[]): void {\n\tconst role = getNodeRole(node.node);\n\n\tif (role === 'link' && isNavigationLink(node)) {\n\t\tconst linkText = getNodeText(node.node, true);\n\t\tconst url = getLinkUrl(node.node);\n\t\tconst description = node.node.description?.value as string || '';\n\n\t\tlinks.push(`- [${linkText}](${url})${description ? ' - ' + description : ''}`);\n\t}\n\n\t// Process children\n\tfor (const child of node.children) {\n\t\tcollectLinks(child, links);\n\t}\n}\n"]}