{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/observable/common/observableMemento.ts","vs/platform/observable/common/observableMemento.ts"],"names":[],"mappings":"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","file":"observableMemento.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { strictEquals } from '../../../base/common/equals.js';\nimport { DisposableStore, IDisposable } from '../../../base/common/lifecycle.js';\nimport { DebugLocation } from '../../../base/common/observable.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { DebugNameData } from '../../../base/common/observableInternal/debugName.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { ObservableValue } from '../../../base/common/observableInternal/observables/observableValue.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../storage/common/storage.js';\n\ninterface IObservableMementoOpts<T> {\n\tdefaultValue: T;\n\tkey: string;\n\ttoStorage: (value: T) => string;\n\tfromStorage: (value: string) => T;\n}\n\n/**\n * Defines an observable memento. Returns a function that can be called with\n * the specific storage scope, target, and service to use in a class.\n *\n * Note that the returned Observable is a disposable, because it interacts\n * with storage service events, and must be tracked appropriately.\n */\nexport function observableMemento<T>(opts: IObservableMementoOpts<T>) {\n\treturn (scope: StorageScope, target: StorageTarget, storageService: IStorageService): ObservableMemento<T> => {\n\t\treturn new ObservableMemento<T>(opts, scope, target, storageService);\n\t};\n}\n\n/**\n * A value that is stored, and is also observable. Note: T should be readonly.\n */\nexport class ObservableMemento<T> extends ObservableValue<T> implements IDisposable {\n\tprivate readonly _store = new DisposableStore();\n\tprivate _noStorageUpdateNeeded = false;\n\n\tconstructor(\n\t\tprivate readonly opts: IObservableMementoOpts<T>,\n\t\tprivate readonly storageScope: StorageScope,\n\t\tprivate readonly storageTarget: StorageTarget,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t) {\n\t\tconst getStorageValue = (): T => {\n\t\t\tconst fromStorage = storageService.get(opts.key, storageScope);\n\t\t\tif (fromStorage !== undefined) {\n\t\t\t\ttry {\n\t\t\t\t\treturn opts.fromStorage(fromStorage);\n\t\t\t\t} catch {\n\t\t\t\t\treturn opts.defaultValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opts.defaultValue;\n\t\t};\n\n\t\tconst initialValue = getStorageValue();\n\t\tsuper(new DebugNameData(undefined, `storage/${opts.key}`, undefined), initialValue, strictEquals, DebugLocation.ofCaller());\n\n\t\tconst didChange = storageService.onDidChangeValue(storageScope, opts.key, this._store);\n\t\tthis._store.add(didChange((e) => {\n\t\t\tif (e.external && e.key === opts.key) {\n\t\t\t\tthis._noStorageUpdateNeeded = true;\n\t\t\t\ttry {\n\t\t\t\t\tthis.set(getStorageValue(), undefined);\n\t\t\t\t} finally {\n\t\t\t\t\tthis._noStorageUpdateNeeded = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tprotected override _setValue(newValue: T): void {\n\t\tsuper._setValue(newValue);\n\t\tif (this._noStorageUpdateNeeded) {\n\t\t\treturn;\n\t\t}\n\t\tconst valueToStore = this.opts.toStorage(this.get());\n\t\tthis.storageService.store(this.opts.key, valueToStore, this.storageScope, this.storageTarget);\n\t}\n\n\tdispose(): void {\n\t\tthis._store.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { strictEquals } from '../../../base/common/equals.js';\nimport { DisposableStore, IDisposable } from '../../../base/common/lifecycle.js';\nimport { DebugLocation } from '../../../base/common/observable.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { DebugNameData } from '../../../base/common/observableInternal/debugName.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { ObservableValue } from '../../../base/common/observableInternal/observables/observableValue.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../storage/common/storage.js';\n\ninterface IObservableMementoOpts<T> {\n\tdefaultValue: T;\n\tkey: string;\n\ttoStorage: (value: T) => string;\n\tfromStorage: (value: string) => T;\n}\n\n/**\n * Defines an observable memento. Returns a function that can be called with\n * the specific storage scope, target, and service to use in a class.\n *\n * Note that the returned Observable is a disposable, because it interacts\n * with storage service events, and must be tracked appropriately.\n */\nexport function observableMemento<T>(opts: IObservableMementoOpts<T>) {\n\treturn (scope: StorageScope, target: StorageTarget, storageService: IStorageService): ObservableMemento<T> => {\n\t\treturn new ObservableMemento<T>(opts, scope, target, storageService);\n\t};\n}\n\n/**\n * A value that is stored, and is also observable. Note: T should be readonly.\n */\nexport class ObservableMemento<T> extends ObservableValue<T> implements IDisposable {\n\tprivate readonly _store = new DisposableStore();\n\tprivate _noStorageUpdateNeeded = false;\n\n\tconstructor(\n\t\tprivate readonly opts: IObservableMementoOpts<T>,\n\t\tprivate readonly storageScope: StorageScope,\n\t\tprivate readonly storageTarget: StorageTarget,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t) {\n\t\tconst getStorageValue = (): T => {\n\t\t\tconst fromStorage = storageService.get(opts.key, storageScope);\n\t\t\tif (fromStorage !== undefined) {\n\t\t\t\ttry {\n\t\t\t\t\treturn opts.fromStorage(fromStorage);\n\t\t\t\t} catch {\n\t\t\t\t\treturn opts.defaultValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opts.defaultValue;\n\t\t};\n\n\t\tconst initialValue = getStorageValue();\n\t\tsuper(new DebugNameData(undefined, `storage/${opts.key}`, undefined), initialValue, strictEquals, DebugLocation.ofCaller());\n\n\t\tconst didChange = storageService.onDidChangeValue(storageScope, opts.key, this._store);\n\t\tthis._store.add(didChange((e) => {\n\t\t\tif (e.external && e.key === opts.key) {\n\t\t\t\tthis._noStorageUpdateNeeded = true;\n\t\t\t\ttry {\n\t\t\t\t\tthis.set(getStorageValue(), undefined);\n\t\t\t\t} finally {\n\t\t\t\t\tthis._noStorageUpdateNeeded = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tprotected override _setValue(newValue: T): void {\n\t\tsuper._setValue(newValue);\n\t\tif (this._noStorageUpdateNeeded) {\n\t\t\treturn;\n\t\t}\n\t\tconst valueToStore = this.opts.toStorage(this.get());\n\t\tthis.storageService.store(this.opts.key, valueToStore, this.storageScope, this.storageTarget);\n\t}\n\n\tdispose(): void {\n\t\tthis._store.dispose();\n\t}\n}\n"]}