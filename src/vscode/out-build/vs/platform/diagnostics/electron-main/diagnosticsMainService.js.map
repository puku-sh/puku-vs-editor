{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/diagnostics/electron-main/diagnosticsMainService.ts","vs/platform/diagnostics/electron-main/diagnosticsMainService.ts"],"names":[],"mappings":"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","file":"diagnosticsMainService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, BrowserWindow, Event as IpcEvent } from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IDiagnosticInfo, IDiagnosticInfoOptions, IMainProcessDiagnostics, IProcessDiagnostics, IRemoteDiagnosticError, IRemoteDiagnosticInfo, IWindowDiagnostics } from '../common/diagnostics.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ICodeWindow } from '../../window/electron-main/window.js';\nimport { getAllWindowsExcludingOffscreen, IWindowsMainService } from '../../windows/electron-main/windows.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { IWorkspacesManagementMainService } from '../../workspaces/electron-main/workspacesManagementMainService.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { UtilityProcess } from '../../utilityProcess/electron-main/utilityProcess.js';\n\nexport const ID = 'diagnosticsMainService';\nexport const IDiagnosticsMainService = createDecorator<IDiagnosticsMainService>(ID);\n\nexport interface IRemoteDiagnosticOptions {\n\tincludeProcesses?: boolean;\n\tincludeWorkspaceMetadata?: boolean;\n}\n\nexport interface IDiagnosticsMainService {\n\treadonly _serviceBrand: undefined;\n\tgetRemoteDiagnostics(options: IRemoteDiagnosticOptions): Promise<(IRemoteDiagnosticInfo | IRemoteDiagnosticError)[]>;\n\tgetMainDiagnostics(): Promise<IMainProcessDiagnostics>;\n}\n\nexport class DiagnosticsMainService implements IDiagnosticsMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IWorkspacesManagementMainService private readonly workspacesManagementMainService: IWorkspacesManagementMainService,\n\t\t@ILogService private readonly logService: ILogService\n\t) { }\n\n\tasync getRemoteDiagnostics(options: IRemoteDiagnosticOptions): Promise<(IRemoteDiagnosticInfo | IRemoteDiagnosticError)[]> {\n\t\tconst windows = this.windowsMainService.getWindows();\n\t\tconst diagnostics: Array<IDiagnosticInfo | IRemoteDiagnosticError | undefined> = await Promise.all(windows.map(async window => {\n\t\t\tconst remoteAuthority = window.remoteAuthority;\n\t\t\tif (!remoteAuthority) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst replyChannel = `vscode:getDiagnosticInfoResponse${window.id}`;\n\t\t\tconst args: IDiagnosticInfoOptions = {\n\t\t\t\tincludeProcesses: options.includeProcesses,\n\t\t\t\tfolders: options.includeWorkspaceMetadata ? await this.getFolderURIs(window) : undefined\n\t\t\t};\n\n\t\t\treturn new Promise<IDiagnosticInfo | IRemoteDiagnosticError>(resolve => {\n\t\t\t\twindow.sendWhenReady('vscode:getDiagnosticInfo', CancellationToken.None, { replyChannel, args });\n\n\t\t\t\tvalidatedIpcMain.once(replyChannel, (_: IpcEvent, data: IRemoteDiagnosticInfo) => {\n\t\t\t\t\t// No data is returned if getting the connection fails.\n\t\t\t\t\tif (!data) {\n\t\t\t\t\t\tresolve({ hostName: remoteAuthority, errorMessage: `Unable to resolve connection to '${remoteAuthority}'.` });\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(data);\n\t\t\t\t});\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tresolve({ hostName: remoteAuthority, errorMessage: `Connection to '${remoteAuthority}' could not be established` });\n\t\t\t\t}, 5000);\n\t\t\t});\n\t\t}));\n\n\t\treturn diagnostics.filter((x): x is IRemoteDiagnosticInfo | IRemoteDiagnosticError => !!x);\n\t}\n\n\tasync getMainDiagnostics(): Promise<IMainProcessDiagnostics> {\n\t\tthis.logService.trace('Received request for main process info from other instance.');\n\n\t\tconst windows: IWindowDiagnostics[] = [];\n\t\tfor (const window of getAllWindowsExcludingOffscreen()) {\n\t\t\tconst codeWindow = this.windowsMainService.getWindowById(window.id);\n\t\t\tif (codeWindow) {\n\t\t\t\twindows.push(await this.codeWindowToInfo(codeWindow));\n\t\t\t} else {\n\t\t\t\twindows.push(this.browserWindowToInfo(window));\n\t\t\t}\n\t\t}\n\n\t\tconst pidToNames: IProcessDiagnostics[] = [];\n\t\tfor (const { pid, name } of UtilityProcess.getAll()) {\n\t\t\tpidToNames.push({ pid, name });\n\t\t}\n\n\t\treturn {\n\t\t\tmainPID: process.pid,\n\t\t\tmainArguments: process.argv.slice(1),\n\t\t\twindows,\n\t\t\tpidToNames,\n\t\t\tscreenReader: !!app.accessibilitySupportEnabled,\n\t\t\tgpuFeatureStatus: app.getGPUFeatureStatus()\n\t\t};\n\t}\n\n\tprivate async codeWindowToInfo(window: ICodeWindow): Promise<IWindowDiagnostics> {\n\t\tconst folderURIs = await this.getFolderURIs(window);\n\t\tconst win = assertReturnsDefined(window.win);\n\n\t\treturn this.browserWindowToInfo(win, folderURIs, window.remoteAuthority);\n\t}\n\n\tprivate browserWindowToInfo(window: BrowserWindow, folderURIs: URI[] = [], remoteAuthority?: string): IWindowDiagnostics {\n\t\treturn {\n\t\t\tid: window.id,\n\t\t\tpid: window.webContents.getOSProcessId(),\n\t\t\ttitle: window.getTitle(),\n\t\t\tfolderURIs,\n\t\t\tremoteAuthority\n\t\t};\n\t}\n\n\tprivate async getFolderURIs(window: ICodeWindow): Promise<URI[]> {\n\t\tconst folderURIs: URI[] = [];\n\n\t\tconst workspace = window.openedWorkspace;\n\t\tif (isSingleFolderWorkspaceIdentifier(workspace)) {\n\t\t\tfolderURIs.push(workspace.uri);\n\t\t} else if (isWorkspaceIdentifier(workspace)) {\n\t\t\tconst resolvedWorkspace = await this.workspacesManagementMainService.resolveLocalWorkspace(workspace.configPath); // workspace folders can only be shown for local (resolved) workspaces\n\t\t\tif (resolvedWorkspace) {\n\t\t\t\tconst rootFolders = resolvedWorkspace.folders;\n\t\t\t\trootFolders.forEach(root => {\n\t\t\t\t\tfolderURIs.push(root.uri);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn folderURIs;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, BrowserWindow, Event as IpcEvent } from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IDiagnosticInfo, IDiagnosticInfoOptions, IMainProcessDiagnostics, IProcessDiagnostics, IRemoteDiagnosticError, IRemoteDiagnosticInfo, IWindowDiagnostics } from '../common/diagnostics.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ICodeWindow } from '../../window/electron-main/window.js';\nimport { getAllWindowsExcludingOffscreen, IWindowsMainService } from '../../windows/electron-main/windows.js';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { IWorkspacesManagementMainService } from '../../workspaces/electron-main/workspacesManagementMainService.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { UtilityProcess } from '../../utilityProcess/electron-main/utilityProcess.js';\n\nexport const ID = 'diagnosticsMainService';\nexport const IDiagnosticsMainService = createDecorator<IDiagnosticsMainService>(ID);\n\nexport interface IRemoteDiagnosticOptions {\n\tincludeProcesses?: boolean;\n\tincludeWorkspaceMetadata?: boolean;\n}\n\nexport interface IDiagnosticsMainService {\n\treadonly _serviceBrand: undefined;\n\tgetRemoteDiagnostics(options: IRemoteDiagnosticOptions): Promise<(IRemoteDiagnosticInfo | IRemoteDiagnosticError)[]>;\n\tgetMainDiagnostics(): Promise<IMainProcessDiagnostics>;\n}\n\nexport class DiagnosticsMainService implements IDiagnosticsMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IWorkspacesManagementMainService private readonly workspacesManagementMainService: IWorkspacesManagementMainService,\n\t\t@ILogService private readonly logService: ILogService\n\t) { }\n\n\tasync getRemoteDiagnostics(options: IRemoteDiagnosticOptions): Promise<(IRemoteDiagnosticInfo | IRemoteDiagnosticError)[]> {\n\t\tconst windows = this.windowsMainService.getWindows();\n\t\tconst diagnostics: Array<IDiagnosticInfo | IRemoteDiagnosticError | undefined> = await Promise.all(windows.map(async window => {\n\t\t\tconst remoteAuthority = window.remoteAuthority;\n\t\t\tif (!remoteAuthority) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst replyChannel = `vscode:getDiagnosticInfoResponse${window.id}`;\n\t\t\tconst args: IDiagnosticInfoOptions = {\n\t\t\t\tincludeProcesses: options.includeProcesses,\n\t\t\t\tfolders: options.includeWorkspaceMetadata ? await this.getFolderURIs(window) : undefined\n\t\t\t};\n\n\t\t\treturn new Promise<IDiagnosticInfo | IRemoteDiagnosticError>(resolve => {\n\t\t\t\twindow.sendWhenReady('vscode:getDiagnosticInfo', CancellationToken.None, { replyChannel, args });\n\n\t\t\t\tvalidatedIpcMain.once(replyChannel, (_: IpcEvent, data: IRemoteDiagnosticInfo) => {\n\t\t\t\t\t// No data is returned if getting the connection fails.\n\t\t\t\t\tif (!data) {\n\t\t\t\t\t\tresolve({ hostName: remoteAuthority, errorMessage: `Unable to resolve connection to '${remoteAuthority}'.` });\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(data);\n\t\t\t\t});\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tresolve({ hostName: remoteAuthority, errorMessage: `Connection to '${remoteAuthority}' could not be established` });\n\t\t\t\t}, 5000);\n\t\t\t});\n\t\t}));\n\n\t\treturn diagnostics.filter((x): x is IRemoteDiagnosticInfo | IRemoteDiagnosticError => !!x);\n\t}\n\n\tasync getMainDiagnostics(): Promise<IMainProcessDiagnostics> {\n\t\tthis.logService.trace('Received request for main process info from other instance.');\n\n\t\tconst windows: IWindowDiagnostics[] = [];\n\t\tfor (const window of getAllWindowsExcludingOffscreen()) {\n\t\t\tconst codeWindow = this.windowsMainService.getWindowById(window.id);\n\t\t\tif (codeWindow) {\n\t\t\t\twindows.push(await this.codeWindowToInfo(codeWindow));\n\t\t\t} else {\n\t\t\t\twindows.push(this.browserWindowToInfo(window));\n\t\t\t}\n\t\t}\n\n\t\tconst pidToNames: IProcessDiagnostics[] = [];\n\t\tfor (const { pid, name } of UtilityProcess.getAll()) {\n\t\t\tpidToNames.push({ pid, name });\n\t\t}\n\n\t\treturn {\n\t\t\tmainPID: process.pid,\n\t\t\tmainArguments: process.argv.slice(1),\n\t\t\twindows,\n\t\t\tpidToNames,\n\t\t\tscreenReader: !!app.accessibilitySupportEnabled,\n\t\t\tgpuFeatureStatus: app.getGPUFeatureStatus()\n\t\t};\n\t}\n\n\tprivate async codeWindowToInfo(window: ICodeWindow): Promise<IWindowDiagnostics> {\n\t\tconst folderURIs = await this.getFolderURIs(window);\n\t\tconst win = assertReturnsDefined(window.win);\n\n\t\treturn this.browserWindowToInfo(win, folderURIs, window.remoteAuthority);\n\t}\n\n\tprivate browserWindowToInfo(window: BrowserWindow, folderURIs: URI[] = [], remoteAuthority?: string): IWindowDiagnostics {\n\t\treturn {\n\t\t\tid: window.id,\n\t\t\tpid: window.webContents.getOSProcessId(),\n\t\t\ttitle: window.getTitle(),\n\t\t\tfolderURIs,\n\t\t\tremoteAuthority\n\t\t};\n\t}\n\n\tprivate async getFolderURIs(window: ICodeWindow): Promise<URI[]> {\n\t\tconst folderURIs: URI[] = [];\n\n\t\tconst workspace = window.openedWorkspace;\n\t\tif (isSingleFolderWorkspaceIdentifier(workspace)) {\n\t\t\tfolderURIs.push(workspace.uri);\n\t\t} else if (isWorkspaceIdentifier(workspace)) {\n\t\t\tconst resolvedWorkspace = await this.workspacesManagementMainService.resolveLocalWorkspace(workspace.configPath); // workspace folders can only be shown for local (resolved) workspaces\n\t\t\tif (resolvedWorkspace) {\n\t\t\t\tconst rootFolders = resolvedWorkspace.folders;\n\t\t\t\trootFolders.forEach(root => {\n\t\t\t\t\tfolderURIs.push(root.uri);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn folderURIs;\n\t}\n}\n"]}