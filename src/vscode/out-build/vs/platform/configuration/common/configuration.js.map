{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/configuration/common/configuration.ts","vs/platform/configuration/common/configuration.ts"],"names":[],"mappings":"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","file":"configuration.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../../base/common/assert.js';\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { Event } from '../../../base/common/event.js';\nimport * as types from '../../../base/common/types.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IWorkspaceFolder } from '../../workspace/common/workspace.js';\n\nexport const IConfigurationService = createDecorator<IConfigurationService>('configurationService');\n\nexport function isConfigurationOverrides(obj: unknown): obj is IConfigurationOverrides {\n\tconst thing = obj as IConfigurationOverrides;\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n\t\t&& (!thing.resource || thing.resource instanceof URI);\n}\n\nexport interface IConfigurationOverrides {\n\toverrideIdentifier?: string | null;\n\tresource?: URI | null;\n}\n\nexport function isConfigurationUpdateOverrides(obj: unknown): obj is IConfigurationUpdateOverrides {\n\tconst thing = obj as IConfigurationUpdateOverrides | IConfigurationOverrides;\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& (!(thing as IConfigurationUpdateOverrides).overrideIdentifiers || Array.isArray((thing as IConfigurationUpdateOverrides).overrideIdentifiers))\n\t\t&& !(thing as IConfigurationOverrides).overrideIdentifier\n\t\t&& (!thing.resource || thing.resource instanceof URI);\n}\n\nexport type IConfigurationUpdateOverrides = Omit<IConfigurationOverrides, 'overrideIdentifier'> & { overrideIdentifiers?: string[] | null };\n\nexport const enum ConfigurationTarget {\n\tAPPLICATION = 1,\n\tUSER,\n\tUSER_LOCAL,\n\tUSER_REMOTE,\n\tWORKSPACE,\n\tWORKSPACE_FOLDER,\n\tDEFAULT,\n\tMEMORY\n}\nexport function ConfigurationTargetToString(configurationTarget: ConfigurationTarget) {\n\tswitch (configurationTarget) {\n\t\tcase ConfigurationTarget.APPLICATION: return 'APPLICATION';\n\t\tcase ConfigurationTarget.USER: return 'USER';\n\t\tcase ConfigurationTarget.USER_LOCAL: return 'USER_LOCAL';\n\t\tcase ConfigurationTarget.USER_REMOTE: return 'USER_REMOTE';\n\t\tcase ConfigurationTarget.WORKSPACE: return 'WORKSPACE';\n\t\tcase ConfigurationTarget.WORKSPACE_FOLDER: return 'WORKSPACE_FOLDER';\n\t\tcase ConfigurationTarget.DEFAULT: return 'DEFAULT';\n\t\tcase ConfigurationTarget.MEMORY: return 'MEMORY';\n\t}\n}\n\nexport interface IConfigurationChange {\n\tkeys: string[];\n\toverrides: [string, string[]][];\n}\n\nexport interface IConfigurationChangeEvent {\n\n\treadonly source: ConfigurationTarget;\n\treadonly affectedKeys: ReadonlySet<string>;\n\treadonly change: IConfigurationChange;\n\n\taffectsConfiguration(configuration: string, overrides?: IConfigurationOverrides): boolean;\n}\n\nexport interface IInspectValue<T> {\n\treadonly value?: T;\n\treadonly override?: T;\n\treadonly overrides?: { readonly identifiers: string[]; readonly value: T }[];\n}\n\nexport interface IConfigurationValue<T> {\n\n\treadonly defaultValue?: T;\n\treadonly applicationValue?: T;\n\treadonly userValue?: T;\n\treadonly userLocalValue?: T;\n\treadonly userRemoteValue?: T;\n\treadonly workspaceValue?: T;\n\treadonly workspaceFolderValue?: T;\n\treadonly memoryValue?: T;\n\treadonly policyValue?: T;\n\treadonly value?: T;\n\n\treadonly default?: IInspectValue<T>;\n\treadonly application?: IInspectValue<T>;\n\treadonly user?: IInspectValue<T>;\n\treadonly userLocal?: IInspectValue<T>;\n\treadonly userRemote?: IInspectValue<T>;\n\treadonly workspace?: IInspectValue<T>;\n\treadonly workspaceFolder?: IInspectValue<T>;\n\treadonly memory?: IInspectValue<T>;\n\treadonly policy?: { value?: T };\n\n\treadonly overrideIdentifiers?: string[];\n}\n\nexport function getConfigValueInTarget<T>(configValue: IConfigurationValue<T>, scope: ConfigurationTarget): T | undefined {\n\tswitch (scope) {\n\t\tcase ConfigurationTarget.APPLICATION:\n\t\t\treturn configValue.applicationValue;\n\t\tcase ConfigurationTarget.USER:\n\t\t\treturn configValue.userValue;\n\t\tcase ConfigurationTarget.USER_LOCAL:\n\t\t\treturn configValue.userLocalValue;\n\t\tcase ConfigurationTarget.USER_REMOTE:\n\t\t\treturn configValue.userRemoteValue;\n\t\tcase ConfigurationTarget.WORKSPACE:\n\t\t\treturn configValue.workspaceValue;\n\t\tcase ConfigurationTarget.WORKSPACE_FOLDER:\n\t\t\treturn configValue.workspaceFolderValue;\n\t\tcase ConfigurationTarget.DEFAULT:\n\t\t\treturn configValue.defaultValue;\n\t\tcase ConfigurationTarget.MEMORY:\n\t\t\treturn configValue.memoryValue;\n\t\tdefault:\n\t\t\tassertNever(scope);\n\t}\n}\n\nexport function isConfigured<T>(configValue: IConfigurationValue<T>): configValue is IConfigurationValue<T> & { value: T } {\n\treturn configValue.applicationValue !== undefined ||\n\t\tconfigValue.userValue !== undefined ||\n\t\tconfigValue.userLocalValue !== undefined ||\n\t\tconfigValue.userRemoteValue !== undefined ||\n\t\tconfigValue.workspaceValue !== undefined ||\n\t\tconfigValue.workspaceFolderValue !== undefined;\n}\n\nexport interface IConfigurationUpdateOptions {\n\t/**\n\t * If `true`, do not notifies the error to user by showing the message box. Default is `false`.\n\t */\n\tdonotNotifyError?: boolean;\n\t/**\n\t * How to handle dirty file when updating the configuration.\n\t */\n\thandleDirtyFile?: 'save' | 'revert';\n}\n\nexport interface IConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeConfiguration: Event<IConfigurationChangeEvent>;\n\n\tgetConfigurationData(): IConfigurationData | null;\n\n\t/**\n\t * Fetches the value of the section for the given overrides.\n\t * Value can be of native type or an object keyed off the section name.\n\t *\n\t * @param section - Section of the configuration. Can be `null` or `undefined`.\n\t * @param overrides - Overrides that has to be applied while fetching\n\t *\n\t */\n\tgetValue<T>(): T;\n\tgetValue<T>(section: string): T;\n\tgetValue<T>(overrides: IConfigurationOverrides): T;\n\tgetValue<T>(section: string, overrides: IConfigurationOverrides): T;\n\n\t/**\n\t * Update a configuration value.\n\t *\n\t * Use `target` to update the configuration in a specific `ConfigurationTarget`.\n\t *\n\t * Use `overrides` to update the configuration for a resource or for override identifiers or both.\n\t *\n\t * Passing a resource through overrides will update the configuration in the workspace folder containing that resource.\n\t *\n\t * *Note 1:* Updating configuration to a default value will remove the configuration from the requested target. If not target is passed, it will be removed from all writeable targets.\n\t *\n\t * *Note 2:* Use `undefined` value to remove the configuration from the given target. If not target is passed, it will be removed from all writeable targets.\n\t *\n\t * Use `donotNotifyError` and set it to `true` to surpresss errors.\n\t *\n\t * @param key setting to be updated\n\t * @param value The new value\n\t */\n\tupdateValue(key: string, value: unknown): Promise<void>;\n\tupdateValue(key: string, value: unknown, target: ConfigurationTarget): Promise<void>;\n\tupdateValue(key: string, value: unknown, overrides: IConfigurationOverrides | IConfigurationUpdateOverrides): Promise<void>;\n\tupdateValue(key: string, value: unknown, overrides: IConfigurationOverrides | IConfigurationUpdateOverrides, target: ConfigurationTarget, options?: IConfigurationUpdateOptions): Promise<void>;\n\n\tinspect<T>(key: string, overrides?: IConfigurationOverrides): IConfigurationValue<Readonly<T>>;\n\n\treloadConfiguration(target?: ConfigurationTarget | IWorkspaceFolder): Promise<void>;\n\n\tkeys(): {\n\t\tdefault: string[];\n\t\tpolicy: string[];\n\t\tuser: string[];\n\t\tworkspace: string[];\n\t\tworkspaceFolder: string[];\n\t\tmemory?: string[];\n\t};\n}\n\nexport interface IConfigurationModel {\n\tcontents: IStringDictionary<unknown>;\n\tkeys: string[];\n\toverrides: IOverrides[];\n\traw?: ReadonlyArray<IStringDictionary<unknown>> | IStringDictionary<unknown>;\n}\n\nexport interface IOverrides {\n\tkeys: string[];\n\tcontents: IStringDictionary<unknown>;\n\tidentifiers: string[];\n}\n\nexport interface IConfigurationData {\n\tdefaults: IConfigurationModel;\n\tpolicy: IConfigurationModel;\n\tapplication: IConfigurationModel;\n\tuserLocal: IConfigurationModel;\n\tuserRemote: IConfigurationModel;\n\tworkspace: IConfigurationModel;\n\tfolders: [UriComponents, IConfigurationModel][];\n}\n\nexport interface IConfigurationCompareResult {\n\tadded: string[];\n\tremoved: string[];\n\tupdated: string[];\n\toverrides: [string, string[]][];\n}\n\nexport function toValuesTree(properties: IStringDictionary<unknown>, conflictReporter: (message: string) => void): IStringDictionary<unknown> {\n\tconst root = Object.create(null);\n\n\tfor (const key in properties) {\n\t\taddToValueTree(root, key, properties[key], conflictReporter);\n\t}\n\n\treturn root;\n}\n\nexport function addToValueTree(settingsTreeRoot: IStringDictionary<unknown>, key: string, value: unknown, conflictReporter: (message: string) => void): void {\n\tconst segments = key.split('.');\n\tconst last = segments.pop()!;\n\n\tlet curr: IStringDictionary<unknown> = settingsTreeRoot;\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tconst s = segments[i];\n\t\tlet obj = curr[s];\n\t\tswitch (typeof obj) {\n\t\t\tcase 'undefined':\n\t\t\t\tobj = curr[s] = Object.create(null);\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (obj === null) {\n\t\t\t\t\tconflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is null`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n\t\t\t\treturn;\n\t\t}\n\t\tcurr = obj as IStringDictionary<unknown>;\n\t}\n\n\tif (typeof curr === 'object' && curr !== null) {\n\t\ttry {\n\t\t\t(curr as IStringDictionary<unknown>)[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606\n\t\t} catch (e) {\n\t\t\tconflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n\t\t}\n\t} else {\n\t\tconflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n\t}\n}\n\nexport function removeFromValueTree(valueTree: IStringDictionary<unknown>, key: string): void {\n\tconst segments = key.split('.');\n\tdoRemoveFromValueTree(valueTree, segments);\n}\n\nfunction doRemoveFromValueTree(valueTree: IStringDictionary<unknown> | unknown, segments: string[]): void {\n\tif (!valueTree) {\n\t\treturn;\n\t}\n\n\tconst valueTreeRecord = valueTree as IStringDictionary<unknown>;\n\tconst first = segments.shift()!;\n\tif (segments.length === 0) {\n\t\t// Reached last segment\n\t\tdelete valueTreeRecord[first];\n\t\treturn;\n\t}\n\n\tif (Object.keys(valueTreeRecord).indexOf(first) !== -1) {\n\t\tconst value = valueTreeRecord[first];\n\t\tif (typeof value === 'object' && !Array.isArray(value)) {\n\t\t\tdoRemoveFromValueTree(value, segments);\n\t\t\tif (Object.keys(value as object).length === 0) {\n\t\t\t\tdelete valueTreeRecord[first];\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n */\nexport function getConfigurationValue<T>(config: IStringDictionary<unknown>, settingPath: string): T | undefined;\nexport function getConfigurationValue<T>(config: IStringDictionary<unknown>, settingPath: string, defaultValue: T): T;\nexport function getConfigurationValue<T>(config: IStringDictionary<unknown>, settingPath: string, defaultValue?: T): T | undefined {\n\tfunction accessSetting(config: IStringDictionary<unknown>, path: string[]): unknown {\n\t\tlet current: unknown = config;\n\t\tfor (const component of path) {\n\t\t\tif (typeof current !== 'object' || current === null) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrent = (current as IStringDictionary<unknown>)[component];\n\t\t}\n\t\treturn current as T;\n\t}\n\n\tconst path = settingPath.split('.');\n\tconst result = accessSetting(config, path);\n\n\treturn typeof result === 'undefined' ? defaultValue : result as T;\n}\n\nexport function merge(base: IStringDictionary<unknown>, add: IStringDictionary<unknown>, overwrite: boolean): void {\n\tObject.keys(add).forEach(key => {\n\t\tif (key !== '__proto__') {\n\t\t\tif (key in base) {\n\t\t\t\tif (types.isObject(base[key]) && types.isObject(add[key])) {\n\t\t\t\t\tmerge(base[key] as IStringDictionary<unknown>, add[key] as IStringDictionary<unknown>, overwrite);\n\t\t\t\t} else if (overwrite) {\n\t\t\t\t\tbase[key] = add[key];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbase[key] = add[key];\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function getLanguageTagSettingPlainKey(settingKey: string) {\n\treturn settingKey\n\t\t.replace(/^\\[/, '')\n\t\t.replace(/]$/g, '')\n\t\t.replace(/\\]\\[/g, ', ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../../base/common/assert.js';\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { Event } from '../../../base/common/event.js';\nimport * as types from '../../../base/common/types.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IWorkspaceFolder } from '../../workspace/common/workspace.js';\n\nexport const IConfigurationService = createDecorator<IConfigurationService>('configurationService');\n\nexport function isConfigurationOverrides(obj: unknown): obj is IConfigurationOverrides {\n\tconst thing = obj as IConfigurationOverrides;\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n\t\t&& (!thing.resource || thing.resource instanceof URI);\n}\n\nexport interface IConfigurationOverrides {\n\toverrideIdentifier?: string | null;\n\tresource?: URI | null;\n}\n\nexport function isConfigurationUpdateOverrides(obj: unknown): obj is IConfigurationUpdateOverrides {\n\tconst thing = obj as IConfigurationUpdateOverrides | IConfigurationOverrides;\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& (!(thing as IConfigurationUpdateOverrides).overrideIdentifiers || Array.isArray((thing as IConfigurationUpdateOverrides).overrideIdentifiers))\n\t\t&& !(thing as IConfigurationOverrides).overrideIdentifier\n\t\t&& (!thing.resource || thing.resource instanceof URI);\n}\n\nexport type IConfigurationUpdateOverrides = Omit<IConfigurationOverrides, 'overrideIdentifier'> & { overrideIdentifiers?: string[] | null };\n\nexport const enum ConfigurationTarget {\n\tAPPLICATION = 1,\n\tUSER,\n\tUSER_LOCAL,\n\tUSER_REMOTE,\n\tWORKSPACE,\n\tWORKSPACE_FOLDER,\n\tDEFAULT,\n\tMEMORY\n}\nexport function ConfigurationTargetToString(configurationTarget: ConfigurationTarget) {\n\tswitch (configurationTarget) {\n\t\tcase ConfigurationTarget.APPLICATION: return 'APPLICATION';\n\t\tcase ConfigurationTarget.USER: return 'USER';\n\t\tcase ConfigurationTarget.USER_LOCAL: return 'USER_LOCAL';\n\t\tcase ConfigurationTarget.USER_REMOTE: return 'USER_REMOTE';\n\t\tcase ConfigurationTarget.WORKSPACE: return 'WORKSPACE';\n\t\tcase ConfigurationTarget.WORKSPACE_FOLDER: return 'WORKSPACE_FOLDER';\n\t\tcase ConfigurationTarget.DEFAULT: return 'DEFAULT';\n\t\tcase ConfigurationTarget.MEMORY: return 'MEMORY';\n\t}\n}\n\nexport interface IConfigurationChange {\n\tkeys: string[];\n\toverrides: [string, string[]][];\n}\n\nexport interface IConfigurationChangeEvent {\n\n\treadonly source: ConfigurationTarget;\n\treadonly affectedKeys: ReadonlySet<string>;\n\treadonly change: IConfigurationChange;\n\n\taffectsConfiguration(configuration: string, overrides?: IConfigurationOverrides): boolean;\n}\n\nexport interface IInspectValue<T> {\n\treadonly value?: T;\n\treadonly override?: T;\n\treadonly overrides?: { readonly identifiers: string[]; readonly value: T }[];\n}\n\nexport interface IConfigurationValue<T> {\n\n\treadonly defaultValue?: T;\n\treadonly applicationValue?: T;\n\treadonly userValue?: T;\n\treadonly userLocalValue?: T;\n\treadonly userRemoteValue?: T;\n\treadonly workspaceValue?: T;\n\treadonly workspaceFolderValue?: T;\n\treadonly memoryValue?: T;\n\treadonly policyValue?: T;\n\treadonly value?: T;\n\n\treadonly default?: IInspectValue<T>;\n\treadonly application?: IInspectValue<T>;\n\treadonly user?: IInspectValue<T>;\n\treadonly userLocal?: IInspectValue<T>;\n\treadonly userRemote?: IInspectValue<T>;\n\treadonly workspace?: IInspectValue<T>;\n\treadonly workspaceFolder?: IInspectValue<T>;\n\treadonly memory?: IInspectValue<T>;\n\treadonly policy?: { value?: T };\n\n\treadonly overrideIdentifiers?: string[];\n}\n\nexport function getConfigValueInTarget<T>(configValue: IConfigurationValue<T>, scope: ConfigurationTarget): T | undefined {\n\tswitch (scope) {\n\t\tcase ConfigurationTarget.APPLICATION:\n\t\t\treturn configValue.applicationValue;\n\t\tcase ConfigurationTarget.USER:\n\t\t\treturn configValue.userValue;\n\t\tcase ConfigurationTarget.USER_LOCAL:\n\t\t\treturn configValue.userLocalValue;\n\t\tcase ConfigurationTarget.USER_REMOTE:\n\t\t\treturn configValue.userRemoteValue;\n\t\tcase ConfigurationTarget.WORKSPACE:\n\t\t\treturn configValue.workspaceValue;\n\t\tcase ConfigurationTarget.WORKSPACE_FOLDER:\n\t\t\treturn configValue.workspaceFolderValue;\n\t\tcase ConfigurationTarget.DEFAULT:\n\t\t\treturn configValue.defaultValue;\n\t\tcase ConfigurationTarget.MEMORY:\n\t\t\treturn configValue.memoryValue;\n\t\tdefault:\n\t\t\tassertNever(scope);\n\t}\n}\n\nexport function isConfigured<T>(configValue: IConfigurationValue<T>): configValue is IConfigurationValue<T> & { value: T } {\n\treturn configValue.applicationValue !== undefined ||\n\t\tconfigValue.userValue !== undefined ||\n\t\tconfigValue.userLocalValue !== undefined ||\n\t\tconfigValue.userRemoteValue !== undefined ||\n\t\tconfigValue.workspaceValue !== undefined ||\n\t\tconfigValue.workspaceFolderValue !== undefined;\n}\n\nexport interface IConfigurationUpdateOptions {\n\t/**\n\t * If `true`, do not notifies the error to user by showing the message box. Default is `false`.\n\t */\n\tdonotNotifyError?: boolean;\n\t/**\n\t * How to handle dirty file when updating the configuration.\n\t */\n\thandleDirtyFile?: 'save' | 'revert';\n}\n\nexport interface IConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeConfiguration: Event<IConfigurationChangeEvent>;\n\n\tgetConfigurationData(): IConfigurationData | null;\n\n\t/**\n\t * Fetches the value of the section for the given overrides.\n\t * Value can be of native type or an object keyed off the section name.\n\t *\n\t * @param section - Section of the configuration. Can be `null` or `undefined`.\n\t * @param overrides - Overrides that has to be applied while fetching\n\t *\n\t */\n\tgetValue<T>(): T;\n\tgetValue<T>(section: string): T;\n\tgetValue<T>(overrides: IConfigurationOverrides): T;\n\tgetValue<T>(section: string, overrides: IConfigurationOverrides): T;\n\n\t/**\n\t * Update a configuration value.\n\t *\n\t * Use `target` to update the configuration in a specific `ConfigurationTarget`.\n\t *\n\t * Use `overrides` to update the configuration for a resource or for override identifiers or both.\n\t *\n\t * Passing a resource through overrides will update the configuration in the workspace folder containing that resource.\n\t *\n\t * *Note 1:* Updating configuration to a default value will remove the configuration from the requested target. If not target is passed, it will be removed from all writeable targets.\n\t *\n\t * *Note 2:* Use `undefined` value to remove the configuration from the given target. If not target is passed, it will be removed from all writeable targets.\n\t *\n\t * Use `donotNotifyError` and set it to `true` to surpresss errors.\n\t *\n\t * @param key setting to be updated\n\t * @param value The new value\n\t */\n\tupdateValue(key: string, value: unknown): Promise<void>;\n\tupdateValue(key: string, value: unknown, target: ConfigurationTarget): Promise<void>;\n\tupdateValue(key: string, value: unknown, overrides: IConfigurationOverrides | IConfigurationUpdateOverrides): Promise<void>;\n\tupdateValue(key: string, value: unknown, overrides: IConfigurationOverrides | IConfigurationUpdateOverrides, target: ConfigurationTarget, options?: IConfigurationUpdateOptions): Promise<void>;\n\n\tinspect<T>(key: string, overrides?: IConfigurationOverrides): IConfigurationValue<Readonly<T>>;\n\n\treloadConfiguration(target?: ConfigurationTarget | IWorkspaceFolder): Promise<void>;\n\n\tkeys(): {\n\t\tdefault: string[];\n\t\tpolicy: string[];\n\t\tuser: string[];\n\t\tworkspace: string[];\n\t\tworkspaceFolder: string[];\n\t\tmemory?: string[];\n\t};\n}\n\nexport interface IConfigurationModel {\n\tcontents: IStringDictionary<unknown>;\n\tkeys: string[];\n\toverrides: IOverrides[];\n\traw?: ReadonlyArray<IStringDictionary<unknown>> | IStringDictionary<unknown>;\n}\n\nexport interface IOverrides {\n\tkeys: string[];\n\tcontents: IStringDictionary<unknown>;\n\tidentifiers: string[];\n}\n\nexport interface IConfigurationData {\n\tdefaults: IConfigurationModel;\n\tpolicy: IConfigurationModel;\n\tapplication: IConfigurationModel;\n\tuserLocal: IConfigurationModel;\n\tuserRemote: IConfigurationModel;\n\tworkspace: IConfigurationModel;\n\tfolders: [UriComponents, IConfigurationModel][];\n}\n\nexport interface IConfigurationCompareResult {\n\tadded: string[];\n\tremoved: string[];\n\tupdated: string[];\n\toverrides: [string, string[]][];\n}\n\nexport function toValuesTree(properties: IStringDictionary<unknown>, conflictReporter: (message: string) => void): IStringDictionary<unknown> {\n\tconst root = Object.create(null);\n\n\tfor (const key in properties) {\n\t\taddToValueTree(root, key, properties[key], conflictReporter);\n\t}\n\n\treturn root;\n}\n\nexport function addToValueTree(settingsTreeRoot: IStringDictionary<unknown>, key: string, value: unknown, conflictReporter: (message: string) => void): void {\n\tconst segments = key.split('.');\n\tconst last = segments.pop()!;\n\n\tlet curr: IStringDictionary<unknown> = settingsTreeRoot;\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tconst s = segments[i];\n\t\tlet obj = curr[s];\n\t\tswitch (typeof obj) {\n\t\t\tcase 'undefined':\n\t\t\t\tobj = curr[s] = Object.create(null);\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (obj === null) {\n\t\t\t\t\tconflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is null`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n\t\t\t\treturn;\n\t\t}\n\t\tcurr = obj as IStringDictionary<unknown>;\n\t}\n\n\tif (typeof curr === 'object' && curr !== null) {\n\t\ttry {\n\t\t\t(curr as IStringDictionary<unknown>)[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606\n\t\t} catch (e) {\n\t\t\tconflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n\t\t}\n\t} else {\n\t\tconflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n\t}\n}\n\nexport function removeFromValueTree(valueTree: IStringDictionary<unknown>, key: string): void {\n\tconst segments = key.split('.');\n\tdoRemoveFromValueTree(valueTree, segments);\n}\n\nfunction doRemoveFromValueTree(valueTree: IStringDictionary<unknown> | unknown, segments: string[]): void {\n\tif (!valueTree) {\n\t\treturn;\n\t}\n\n\tconst valueTreeRecord = valueTree as IStringDictionary<unknown>;\n\tconst first = segments.shift()!;\n\tif (segments.length === 0) {\n\t\t// Reached last segment\n\t\tdelete valueTreeRecord[first];\n\t\treturn;\n\t}\n\n\tif (Object.keys(valueTreeRecord).indexOf(first) !== -1) {\n\t\tconst value = valueTreeRecord[first];\n\t\tif (typeof value === 'object' && !Array.isArray(value)) {\n\t\t\tdoRemoveFromValueTree(value, segments);\n\t\t\tif (Object.keys(value as object).length === 0) {\n\t\t\t\tdelete valueTreeRecord[first];\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n */\nexport function getConfigurationValue<T>(config: IStringDictionary<unknown>, settingPath: string): T | undefined;\nexport function getConfigurationValue<T>(config: IStringDictionary<unknown>, settingPath: string, defaultValue: T): T;\nexport function getConfigurationValue<T>(config: IStringDictionary<unknown>, settingPath: string, defaultValue?: T): T | undefined {\n\tfunction accessSetting(config: IStringDictionary<unknown>, path: string[]): unknown {\n\t\tlet current: unknown = config;\n\t\tfor (const component of path) {\n\t\t\tif (typeof current !== 'object' || current === null) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrent = (current as IStringDictionary<unknown>)[component];\n\t\t}\n\t\treturn current as T;\n\t}\n\n\tconst path = settingPath.split('.');\n\tconst result = accessSetting(config, path);\n\n\treturn typeof result === 'undefined' ? defaultValue : result as T;\n}\n\nexport function merge(base: IStringDictionary<unknown>, add: IStringDictionary<unknown>, overwrite: boolean): void {\n\tObject.keys(add).forEach(key => {\n\t\tif (key !== '__proto__') {\n\t\t\tif (key in base) {\n\t\t\t\tif (types.isObject(base[key]) && types.isObject(add[key])) {\n\t\t\t\t\tmerge(base[key] as IStringDictionary<unknown>, add[key] as IStringDictionary<unknown>, overwrite);\n\t\t\t\t} else if (overwrite) {\n\t\t\t\t\tbase[key] = add[key];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbase[key] = add[key];\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function getLanguageTagSettingPlainKey(settingKey: string) {\n\treturn settingKey\n\t\t.replace(/^\\[/, '')\n\t\t.replace(/]$/g, '')\n\t\t.replace(/\\]\\[/g, ', ');\n}\n"]}