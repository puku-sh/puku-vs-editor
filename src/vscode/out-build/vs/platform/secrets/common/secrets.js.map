{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/secrets/common/secrets.ts","vs/platform/secrets/common/secrets.ts"],"names":[],"mappings":"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","file":"secrets.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SequencerByKey } from '../../../base/common/async.js';\nimport { IEncryptionService } from '../../encryption/common/encryptionService.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IStorageService, InMemoryStorageService, StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Lazy } from '../../../base/common/lazy.js';\n\nexport const ISecretStorageService = createDecorator<ISecretStorageService>('secretStorageService');\n\nexport interface ISecretStorageProvider {\n\ttype: 'in-memory' | 'persisted' | 'unknown';\n\tget(key: string): Promise<string | undefined>;\n\tset(key: string, value: string): Promise<void>;\n\tdelete(key: string): Promise<void>;\n\tkeys?(): Promise<string[]>;\n}\n\nexport interface ISecretStorageService extends ISecretStorageProvider {\n\treadonly _serviceBrand: undefined;\n\treadonly onDidChangeSecret: Event<string>;\n}\n\nexport class BaseSecretStorageService extends Disposable implements ISecretStorageService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _storagePrefix = 'secret://';\n\n\tprotected readonly onDidChangeSecretEmitter = this._register(new Emitter<string>());\n\treadonly onDidChangeSecret: Event<string> = this.onDidChangeSecretEmitter.event;\n\n\tprotected readonly _sequencer = new SequencerByKey<string>();\n\n\tprivate _type: 'in-memory' | 'persisted' | 'unknown' = 'unknown';\n\n\tprivate readonly _onDidChangeValueDisposable = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _useInMemoryStorage: boolean,\n\t\t@IStorageService private _storageService: IStorageService,\n\t\t@IEncryptionService protected _encryptionService: IEncryptionService,\n\t\t@ILogService protected readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @Note initialize must be called first so that this can be resolved properly\n\t * otherwise it will return 'unknown'.\n\t */\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tprivate _lazyStorageService: Lazy<Promise<IStorageService>> = new Lazy(() => this.initialize());\n\tprotected get resolvedStorageService() {\n\t\treturn this._lazyStorageService.value;\n\t}\n\n\tget(key: string): Promise<string | undefined> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] getting secret for key:', fullKey);\n\t\t\tconst encrypted = storageService.get(fullKey, StorageScope.APPLICATION);\n\t\t\tif (!encrypted) {\n\t\t\t\tthis._logService.trace('[secrets] no secret found for key:', fullKey);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._logService.trace('[secrets] decrypting gotten secret for key:', fullKey);\n\t\t\t\t// If the storage service is in-memory, we don't need to decrypt\n\t\t\t\tconst result = this._type === 'in-memory'\n\t\t\t\t\t? encrypted\n\t\t\t\t\t: await this._encryptionService.decrypt(encrypted);\n\t\t\t\tthis._logService.trace('[secrets] decrypted secret for key:', fullKey);\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthis.delete(key);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\tset(key: string, value: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tthis._logService.trace('[secrets] encrypting secret for key:', key);\n\t\t\tlet encrypted;\n\t\t\ttry {\n\t\t\t\t// If the storage service is in-memory, we don't need to encrypt\n\t\t\t\tencrypted = this._type === 'in-memory'\n\t\t\t\t\t? value\n\t\t\t\t\t: await this._encryptionService.encrypt(value);\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] storing encrypted secret for key:', fullKey);\n\t\t\tstorageService.store(fullKey, encrypted, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\t\tthis._logService.trace('[secrets] stored encrypted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] deleting secret for key:', fullKey);\n\t\t\tstorageService.remove(fullKey, StorageScope.APPLICATION);\n\t\t\tthis._logService.trace('[secrets] deleted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tkeys(): Promise<string[]> {\n\t\treturn this._sequencer.queue('__keys__', async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\t\t\tthis._logService.trace('[secrets] fetching keys of all secrets');\n\t\t\tconst allKeys = storageService.keys(StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\t\tthis._logService.trace('[secrets] fetched keys of all secrets');\n\t\t\treturn allKeys.filter(key => key.startsWith(this._storagePrefix)).map(key => key.slice(this._storagePrefix.length));\n\t\t});\n\t}\n\n\tprivate async initialize(): Promise<IStorageService> {\n\t\tlet storageService;\n\t\tif (!this._useInMemoryStorage && await this._encryptionService.isEncryptionAvailable()) {\n\t\t\tthis._logService.trace(`[SecretStorageService] Encryption is available, using persisted storage`);\n\t\t\tthis._type = 'persisted';\n\t\t\tstorageService = this._storageService;\n\t\t} else {\n\t\t\t// If we already have an in-memory storage service, we don't need to recreate it\n\t\t\tif (this._type === 'in-memory') {\n\t\t\t\treturn this._storageService;\n\t\t\t}\n\t\t\tthis._logService.trace('[SecretStorageService] Encryption is not available, falling back to in-memory storage');\n\t\t\tthis._type = 'in-memory';\n\t\t\tstorageService = this._register(new InMemoryStorageService());\n\t\t}\n\n\t\tthis._onDidChangeValueDisposable.clear();\n\t\tthis._onDidChangeValueDisposable.add(storageService.onDidChangeValue(StorageScope.APPLICATION, undefined, this._onDidChangeValueDisposable)(e => {\n\t\t\tthis.onDidChangeValue(e.key);\n\t\t}));\n\t\treturn storageService;\n\t}\n\n\tprotected reinitialize(): void {\n\t\tthis._lazyStorageService = new Lazy(() => this.initialize());\n\t}\n\n\tprivate onDidChangeValue(key: string): void {\n\t\tif (!key.startsWith(this._storagePrefix)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst secretKey = key.slice(this._storagePrefix.length);\n\n\t\tthis._logService.trace(`[SecretStorageService] Notifying change in value for secret: ${secretKey}`);\n\t\tthis.onDidChangeSecretEmitter.fire(secretKey);\n\t}\n\n\tprivate getKey(key: string): string {\n\t\treturn `${this._storagePrefix}${key}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SequencerByKey } from '../../../base/common/async.js';\nimport { IEncryptionService } from '../../encryption/common/encryptionService.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IStorageService, InMemoryStorageService, StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Lazy } from '../../../base/common/lazy.js';\n\nexport const ISecretStorageService = createDecorator<ISecretStorageService>('secretStorageService');\n\nexport interface ISecretStorageProvider {\n\ttype: 'in-memory' | 'persisted' | 'unknown';\n\tget(key: string): Promise<string | undefined>;\n\tset(key: string, value: string): Promise<void>;\n\tdelete(key: string): Promise<void>;\n\tkeys?(): Promise<string[]>;\n}\n\nexport interface ISecretStorageService extends ISecretStorageProvider {\n\treadonly _serviceBrand: undefined;\n\treadonly onDidChangeSecret: Event<string>;\n}\n\nexport class BaseSecretStorageService extends Disposable implements ISecretStorageService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _storagePrefix = 'secret://';\n\n\tprotected readonly onDidChangeSecretEmitter = this._register(new Emitter<string>());\n\treadonly onDidChangeSecret: Event<string> = this.onDidChangeSecretEmitter.event;\n\n\tprotected readonly _sequencer = new SequencerByKey<string>();\n\n\tprivate _type: 'in-memory' | 'persisted' | 'unknown' = 'unknown';\n\n\tprivate readonly _onDidChangeValueDisposable = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _useInMemoryStorage: boolean,\n\t\t@IStorageService private _storageService: IStorageService,\n\t\t@IEncryptionService protected _encryptionService: IEncryptionService,\n\t\t@ILogService protected readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @Note initialize must be called first so that this can be resolved properly\n\t * otherwise it will return 'unknown'.\n\t */\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tprivate _lazyStorageService: Lazy<Promise<IStorageService>> = new Lazy(() => this.initialize());\n\tprotected get resolvedStorageService() {\n\t\treturn this._lazyStorageService.value;\n\t}\n\n\tget(key: string): Promise<string | undefined> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] getting secret for key:', fullKey);\n\t\t\tconst encrypted = storageService.get(fullKey, StorageScope.APPLICATION);\n\t\t\tif (!encrypted) {\n\t\t\t\tthis._logService.trace('[secrets] no secret found for key:', fullKey);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._logService.trace('[secrets] decrypting gotten secret for key:', fullKey);\n\t\t\t\t// If the storage service is in-memory, we don't need to decrypt\n\t\t\t\tconst result = this._type === 'in-memory'\n\t\t\t\t\t? encrypted\n\t\t\t\t\t: await this._encryptionService.decrypt(encrypted);\n\t\t\t\tthis._logService.trace('[secrets] decrypted secret for key:', fullKey);\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthis.delete(key);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\tset(key: string, value: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tthis._logService.trace('[secrets] encrypting secret for key:', key);\n\t\t\tlet encrypted;\n\t\t\ttry {\n\t\t\t\t// If the storage service is in-memory, we don't need to encrypt\n\t\t\t\tencrypted = this._type === 'in-memory'\n\t\t\t\t\t? value\n\t\t\t\t\t: await this._encryptionService.encrypt(value);\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] storing encrypted secret for key:', fullKey);\n\t\t\tstorageService.store(fullKey, encrypted, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\t\tthis._logService.trace('[secrets] stored encrypted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] deleting secret for key:', fullKey);\n\t\t\tstorageService.remove(fullKey, StorageScope.APPLICATION);\n\t\t\tthis._logService.trace('[secrets] deleted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tkeys(): Promise<string[]> {\n\t\treturn this._sequencer.queue('__keys__', async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\t\t\tthis._logService.trace('[secrets] fetching keys of all secrets');\n\t\t\tconst allKeys = storageService.keys(StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\t\tthis._logService.trace('[secrets] fetched keys of all secrets');\n\t\t\treturn allKeys.filter(key => key.startsWith(this._storagePrefix)).map(key => key.slice(this._storagePrefix.length));\n\t\t});\n\t}\n\n\tprivate async initialize(): Promise<IStorageService> {\n\t\tlet storageService;\n\t\tif (!this._useInMemoryStorage && await this._encryptionService.isEncryptionAvailable()) {\n\t\t\tthis._logService.trace(`[SecretStorageService] Encryption is available, using persisted storage`);\n\t\t\tthis._type = 'persisted';\n\t\t\tstorageService = this._storageService;\n\t\t} else {\n\t\t\t// If we already have an in-memory storage service, we don't need to recreate it\n\t\t\tif (this._type === 'in-memory') {\n\t\t\t\treturn this._storageService;\n\t\t\t}\n\t\t\tthis._logService.trace('[SecretStorageService] Encryption is not available, falling back to in-memory storage');\n\t\t\tthis._type = 'in-memory';\n\t\t\tstorageService = this._register(new InMemoryStorageService());\n\t\t}\n\n\t\tthis._onDidChangeValueDisposable.clear();\n\t\tthis._onDidChangeValueDisposable.add(storageService.onDidChangeValue(StorageScope.APPLICATION, undefined, this._onDidChangeValueDisposable)(e => {\n\t\t\tthis.onDidChangeValue(e.key);\n\t\t}));\n\t\treturn storageService;\n\t}\n\n\tprotected reinitialize(): void {\n\t\tthis._lazyStorageService = new Lazy(() => this.initialize());\n\t}\n\n\tprivate onDidChangeValue(key: string): void {\n\t\tif (!key.startsWith(this._storagePrefix)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst secretKey = key.slice(this._storagePrefix.length);\n\n\t\tthis._logService.trace(`[SecretStorageService] Notifying change in value for secret: ${secretKey}`);\n\t\tthis.onDidChangeSecretEmitter.fire(secretKey);\n\t}\n\n\tprivate getKey(key: string): string {\n\t\treturn `${this._storagePrefix}${key}`;\n\t}\n}\n"]}