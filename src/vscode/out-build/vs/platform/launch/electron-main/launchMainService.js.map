{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/launch/electron-main/launchMainService.ts","vs/platform/launch/electron-main/launchMainService.ts"],"names":[],"mappings":"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","file":"launchMainService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app } from 'electron';\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { IProcessEnvironment, isMacintosh } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { whenDeleted } from '../../../base/node/pfs.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { NativeParsedArgs } from '../../environment/common/argv.js';\nimport { isLaunchedFromCli } from '../../environment/node/argvHelper.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IURLService } from '../../url/common/url.js';\nimport { ICodeWindow } from '../../window/electron-main/window.js';\nimport { IWindowSettings } from '../../window/common/window.js';\nimport { IOpenConfiguration, IWindowsMainService, OpenContext } from '../../windows/electron-main/windows.js';\nimport { IProtocolUrl } from '../../url/electron-main/url.js';\n\nexport const ID = 'launchMainService';\nexport const ILaunchMainService = createDecorator<ILaunchMainService>(ID);\n\nexport interface IStartArguments {\n\treadonly args: NativeParsedArgs;\n\treadonly userEnv: IProcessEnvironment;\n}\n\nexport interface ILaunchMainService {\n\n\treadonly _serviceBrand: undefined;\n\n\tstart(args: NativeParsedArgs, userEnv: IProcessEnvironment): Promise<void>;\n\n\tgetMainProcessId(): Promise<number>;\n}\n\nexport class LaunchMainService implements ILaunchMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IURLService private readonly urlService: IURLService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) { }\n\n\tasync start(args: NativeParsedArgs, userEnv: IProcessEnvironment): Promise<void> {\n\t\tthis.logService.trace('Received data from other instance: ', args, userEnv);\n\n\t\t// macOS: Electron > 7.x changed its behaviour to not\n\t\t// bring the application to the foreground when a window\n\t\t// is focused programmatically. Only via `app.focus` and\n\t\t// the option `steal: true` can you get the previous\n\t\t// behaviour back. The only reason to use this option is\n\t\t// when a window is getting focused while the application\n\t\t// is not in the foreground and since we got instructed\n\t\t// to open a new window from another instance, we ensure\n\t\t// that the app has focus.\n\t\tif (isMacintosh) {\n\t\t\tapp.focus({ steal: true });\n\t\t}\n\n\t\t// Check early for open-url which is handled in URL service\n\t\tconst urlsToOpen = this.parseOpenUrl(args);\n\t\tif (urlsToOpen.length) {\n\t\t\tlet whenWindowReady: Promise<unknown> = Promise.resolve();\n\n\t\t\t// Create a window if there is none\n\t\t\tif (this.windowsMainService.getWindowCount() === 0) {\n\t\t\t\tconst window = (await this.windowsMainService.openEmptyWindow({ context: OpenContext.DESKTOP })).at(0);\n\t\t\t\tif (window) {\n\t\t\t\t\twhenWindowReady = window.ready();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure a window is open, ready to receive the url event\n\t\t\twhenWindowReady.then(() => {\n\t\t\t\tfor (const { uri, originalUrl } of urlsToOpen) {\n\t\t\t\t\tthis.urlService.open(uri, { originalUrl });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Otherwise handle in windows service\n\t\telse {\n\t\t\treturn this.startOpenWindow(args, userEnv);\n\t\t}\n\t}\n\n\tprivate parseOpenUrl(args: NativeParsedArgs): IProtocolUrl[] {\n\t\tif (args['open-url'] && args._urls && args._urls.length > 0) {\n\n\t\t\t// --open-url must contain -- followed by the url(s)\n\t\t\t// process.argv is used over args._ as args._ are resolved to file paths at this point\n\n\t\t\treturn coalesce(args._urls\n\t\t\t\t.map(url => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn { uri: URI.parse(url), originalUrl: url };\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate async startOpenWindow(args: NativeParsedArgs, userEnv: IProcessEnvironment): Promise<void> {\n\t\tconst context = isLaunchedFromCli(userEnv) ? OpenContext.CLI : OpenContext.DESKTOP;\n\t\tlet usedWindows: ICodeWindow[] = [];\n\n\t\tconst waitMarkerFileURI = args.wait && args.waitMarkerFilePath ? URI.file(args.waitMarkerFilePath) : undefined;\n\t\tconst remoteAuthority = args.remote || undefined;\n\n\t\tconst baseConfig: IOpenConfiguration = {\n\t\t\tcontext,\n\t\t\tcli: args,\n\t\t\t/**\n\t\t\t * When opening a new window from a second instance that sent args and env\n\t\t\t * over to this instance, we want to preserve the environment only if that second\n\t\t\t * instance was spawned from the CLI or used the `--preserve-env` flag (example:\n\t\t\t * when using `open -n \"VSCode.app\" --args --preserve-env WORKSPACE_FOLDER`).\n\t\t\t *\n\t\t\t * This is done to ensure that the second window gets treated exactly the same\n\t\t\t * as the first window, for example, it gets the same resolved user shell environment.\n\t\t\t *\n\t\t\t * https://github.com/microsoft/vscode/issues/194736\n\t\t\t */\n\t\t\tuserEnv: (args['preserve-env'] || context === OpenContext.CLI) ? userEnv : undefined,\n\t\t\twaitMarkerFileURI,\n\t\t\tremoteAuthority,\n\t\t\tforceProfile: args.profile,\n\t\t\tforceTempProfile: args['profile-temp']\n\t\t};\n\n\t\t// Special case extension development\n\t\tif (args.extensionDevelopmentPath) {\n\t\t\tawait this.windowsMainService.openExtensionDevelopmentHostWindow(args.extensionDevelopmentPath, baseConfig);\n\t\t}\n\n\t\t// Start without file/folder arguments\n\t\telse if (!args._.length && !args['folder-uri'] && !args['file-uri']) {\n\t\t\tlet openNewWindow = false;\n\n\t\t\t// Force new window\n\t\t\tif (args['new-window'] || baseConfig.forceProfile || baseConfig.forceTempProfile) {\n\t\t\t\topenNewWindow = true;\n\t\t\t}\n\n\t\t\t// Force reuse window\n\t\t\telse if (args['reuse-window']) {\n\t\t\t\topenNewWindow = false;\n\t\t\t}\n\n\t\t\t// Otherwise check for settings\n\t\t\telse {\n\t\t\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\t\t\t\tconst openWithoutArgumentsInNewWindowConfig = windowConfig?.openWithoutArgumentsInNewWindow || 'default' /* default */;\n\t\t\t\tswitch (openWithoutArgumentsInNewWindowConfig) {\n\t\t\t\t\tcase 'on':\n\t\t\t\t\t\topenNewWindow = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'off':\n\t\t\t\t\t\topenNewWindow = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\topenNewWindow = !isMacintosh; // prefer to restore running instance on macOS\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Open new Window\n\t\t\tif (openNewWindow) {\n\t\t\t\tusedWindows = await this.windowsMainService.open({\n\t\t\t\t\t...baseConfig,\n\t\t\t\t\tforceNewWindow: true,\n\t\t\t\t\tforceEmpty: true\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Focus existing window or open if none opened\n\t\t\telse {\n\t\t\t\tconst lastActive = this.windowsMainService.getLastActiveWindow();\n\t\t\t\tif (lastActive) {\n\t\t\t\t\tthis.windowsMainService.openExistingWindow(lastActive, baseConfig);\n\n\t\t\t\t\tusedWindows = [lastActive];\n\t\t\t\t} else {\n\t\t\t\t\tusedWindows = await this.windowsMainService.open({\n\t\t\t\t\t\t...baseConfig,\n\t\t\t\t\t\tforceEmpty: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Start with file/folder arguments\n\t\telse {\n\t\t\tusedWindows = await this.windowsMainService.open({\n\t\t\t\t...baseConfig,\n\t\t\t\tforceNewWindow: args['new-window'],\n\t\t\t\tpreferNewWindow: !args['reuse-window'] && !args.wait,\n\t\t\t\tforceReuseWindow: args['reuse-window'],\n\t\t\t\tdiffMode: args.diff,\n\t\t\t\tmergeMode: args.merge,\n\t\t\t\taddMode: args.add,\n\t\t\t\tremoveMode: args.remove,\n\t\t\t\tnoRecentEntry: !!args['skip-add-to-recently-opened'],\n\t\t\t\tgotoLineMode: args.goto\n\t\t\t});\n\t\t}\n\n\t\t// If the other instance is waiting to be killed, we hook up a window listener if one window\n\t\t// is being used and only then resolve the startup promise which will kill this second instance.\n\t\t// In addition, we poll for the wait marker file to be deleted to return.\n\t\tif (waitMarkerFileURI && usedWindows.length === 1 && usedWindows[0]) {\n\t\t\treturn Promise.race([\n\t\t\t\tusedWindows[0].whenClosedOrLoaded,\n\t\t\t\twhenDeleted(waitMarkerFileURI.fsPath)\n\t\t\t]).then(() => undefined, () => undefined);\n\t\t}\n\t}\n\n\tasync getMainProcessId(): Promise<number> {\n\t\tthis.logService.trace('Received request for process ID from other instance.');\n\n\t\treturn process.pid;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app } from 'electron';\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { IProcessEnvironment, isMacintosh } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { whenDeleted } from '../../../base/node/pfs.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { NativeParsedArgs } from '../../environment/common/argv.js';\nimport { isLaunchedFromCli } from '../../environment/node/argvHelper.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IURLService } from '../../url/common/url.js';\nimport { ICodeWindow } from '../../window/electron-main/window.js';\nimport { IWindowSettings } from '../../window/common/window.js';\nimport { IOpenConfiguration, IWindowsMainService, OpenContext } from '../../windows/electron-main/windows.js';\nimport { IProtocolUrl } from '../../url/electron-main/url.js';\n\nexport const ID = 'launchMainService';\nexport const ILaunchMainService = createDecorator<ILaunchMainService>(ID);\n\nexport interface IStartArguments {\n\treadonly args: NativeParsedArgs;\n\treadonly userEnv: IProcessEnvironment;\n}\n\nexport interface ILaunchMainService {\n\n\treadonly _serviceBrand: undefined;\n\n\tstart(args: NativeParsedArgs, userEnv: IProcessEnvironment): Promise<void>;\n\n\tgetMainProcessId(): Promise<number>;\n}\n\nexport class LaunchMainService implements ILaunchMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IURLService private readonly urlService: IURLService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) { }\n\n\tasync start(args: NativeParsedArgs, userEnv: IProcessEnvironment): Promise<void> {\n\t\tthis.logService.trace('Received data from other instance: ', args, userEnv);\n\n\t\t// macOS: Electron > 7.x changed its behaviour to not\n\t\t// bring the application to the foreground when a window\n\t\t// is focused programmatically. Only via `app.focus` and\n\t\t// the option `steal: true` can you get the previous\n\t\t// behaviour back. The only reason to use this option is\n\t\t// when a window is getting focused while the application\n\t\t// is not in the foreground and since we got instructed\n\t\t// to open a new window from another instance, we ensure\n\t\t// that the app has focus.\n\t\tif (isMacintosh) {\n\t\t\tapp.focus({ steal: true });\n\t\t}\n\n\t\t// Check early for open-url which is handled in URL service\n\t\tconst urlsToOpen = this.parseOpenUrl(args);\n\t\tif (urlsToOpen.length) {\n\t\t\tlet whenWindowReady: Promise<unknown> = Promise.resolve();\n\n\t\t\t// Create a window if there is none\n\t\t\tif (this.windowsMainService.getWindowCount() === 0) {\n\t\t\t\tconst window = (await this.windowsMainService.openEmptyWindow({ context: OpenContext.DESKTOP })).at(0);\n\t\t\t\tif (window) {\n\t\t\t\t\twhenWindowReady = window.ready();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure a window is open, ready to receive the url event\n\t\t\twhenWindowReady.then(() => {\n\t\t\t\tfor (const { uri, originalUrl } of urlsToOpen) {\n\t\t\t\t\tthis.urlService.open(uri, { originalUrl });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Otherwise handle in windows service\n\t\telse {\n\t\t\treturn this.startOpenWindow(args, userEnv);\n\t\t}\n\t}\n\n\tprivate parseOpenUrl(args: NativeParsedArgs): IProtocolUrl[] {\n\t\tif (args['open-url'] && args._urls && args._urls.length > 0) {\n\n\t\t\t// --open-url must contain -- followed by the url(s)\n\t\t\t// process.argv is used over args._ as args._ are resolved to file paths at this point\n\n\t\t\treturn coalesce(args._urls\n\t\t\t\t.map(url => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn { uri: URI.parse(url), originalUrl: url };\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate async startOpenWindow(args: NativeParsedArgs, userEnv: IProcessEnvironment): Promise<void> {\n\t\tconst context = isLaunchedFromCli(userEnv) ? OpenContext.CLI : OpenContext.DESKTOP;\n\t\tlet usedWindows: ICodeWindow[] = [];\n\n\t\tconst waitMarkerFileURI = args.wait && args.waitMarkerFilePath ? URI.file(args.waitMarkerFilePath) : undefined;\n\t\tconst remoteAuthority = args.remote || undefined;\n\n\t\tconst baseConfig: IOpenConfiguration = {\n\t\t\tcontext,\n\t\t\tcli: args,\n\t\t\t/**\n\t\t\t * When opening a new window from a second instance that sent args and env\n\t\t\t * over to this instance, we want to preserve the environment only if that second\n\t\t\t * instance was spawned from the CLI or used the `--preserve-env` flag (example:\n\t\t\t * when using `open -n \"VSCode.app\" --args --preserve-env WORKSPACE_FOLDER`).\n\t\t\t *\n\t\t\t * This is done to ensure that the second window gets treated exactly the same\n\t\t\t * as the first window, for example, it gets the same resolved user shell environment.\n\t\t\t *\n\t\t\t * https://github.com/microsoft/vscode/issues/194736\n\t\t\t */\n\t\t\tuserEnv: (args['preserve-env'] || context === OpenContext.CLI) ? userEnv : undefined,\n\t\t\twaitMarkerFileURI,\n\t\t\tremoteAuthority,\n\t\t\tforceProfile: args.profile,\n\t\t\tforceTempProfile: args['profile-temp']\n\t\t};\n\n\t\t// Special case extension development\n\t\tif (args.extensionDevelopmentPath) {\n\t\t\tawait this.windowsMainService.openExtensionDevelopmentHostWindow(args.extensionDevelopmentPath, baseConfig);\n\t\t}\n\n\t\t// Start without file/folder arguments\n\t\telse if (!args._.length && !args['folder-uri'] && !args['file-uri']) {\n\t\t\tlet openNewWindow = false;\n\n\t\t\t// Force new window\n\t\t\tif (args['new-window'] || baseConfig.forceProfile || baseConfig.forceTempProfile) {\n\t\t\t\topenNewWindow = true;\n\t\t\t}\n\n\t\t\t// Force reuse window\n\t\t\telse if (args['reuse-window']) {\n\t\t\t\topenNewWindow = false;\n\t\t\t}\n\n\t\t\t// Otherwise check for settings\n\t\t\telse {\n\t\t\t\tconst windowConfig = this.configurationService.getValue<IWindowSettings | undefined>('window');\n\t\t\t\tconst openWithoutArgumentsInNewWindowConfig = windowConfig?.openWithoutArgumentsInNewWindow || 'default' /* default */;\n\t\t\t\tswitch (openWithoutArgumentsInNewWindowConfig) {\n\t\t\t\t\tcase 'on':\n\t\t\t\t\t\topenNewWindow = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'off':\n\t\t\t\t\t\topenNewWindow = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\topenNewWindow = !isMacintosh; // prefer to restore running instance on macOS\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Open new Window\n\t\t\tif (openNewWindow) {\n\t\t\t\tusedWindows = await this.windowsMainService.open({\n\t\t\t\t\t...baseConfig,\n\t\t\t\t\tforceNewWindow: true,\n\t\t\t\t\tforceEmpty: true\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Focus existing window or open if none opened\n\t\t\telse {\n\t\t\t\tconst lastActive = this.windowsMainService.getLastActiveWindow();\n\t\t\t\tif (lastActive) {\n\t\t\t\t\tthis.windowsMainService.openExistingWindow(lastActive, baseConfig);\n\n\t\t\t\t\tusedWindows = [lastActive];\n\t\t\t\t} else {\n\t\t\t\t\tusedWindows = await this.windowsMainService.open({\n\t\t\t\t\t\t...baseConfig,\n\t\t\t\t\t\tforceEmpty: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Start with file/folder arguments\n\t\telse {\n\t\t\tusedWindows = await this.windowsMainService.open({\n\t\t\t\t...baseConfig,\n\t\t\t\tforceNewWindow: args['new-window'],\n\t\t\t\tpreferNewWindow: !args['reuse-window'] && !args.wait,\n\t\t\t\tforceReuseWindow: args['reuse-window'],\n\t\t\t\tdiffMode: args.diff,\n\t\t\t\tmergeMode: args.merge,\n\t\t\t\taddMode: args.add,\n\t\t\t\tremoveMode: args.remove,\n\t\t\t\tnoRecentEntry: !!args['skip-add-to-recently-opened'],\n\t\t\t\tgotoLineMode: args.goto\n\t\t\t});\n\t\t}\n\n\t\t// If the other instance is waiting to be killed, we hook up a window listener if one window\n\t\t// is being used and only then resolve the startup promise which will kill this second instance.\n\t\t// In addition, we poll for the wait marker file to be deleted to return.\n\t\tif (waitMarkerFileURI && usedWindows.length === 1 && usedWindows[0]) {\n\t\t\treturn Promise.race([\n\t\t\t\tusedWindows[0].whenClosedOrLoaded,\n\t\t\t\twhenDeleted(waitMarkerFileURI.fsPath)\n\t\t\t]).then(() => undefined, () => undefined);\n\t\t}\n\t}\n\n\tasync getMainProcessId(): Promise<number> {\n\t\tthis.logService.trace('Received request for process ID from other instance.');\n\n\t\treturn process.pid;\n\t}\n}\n"]}