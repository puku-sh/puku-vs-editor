{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/profiling/common/profilingModel.ts","vs/platform/profiling/common/profilingModel.ts"],"names":[],"mappings":"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","file":"profilingModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IV8Profile, IV8ProfileNode } from './profiling.js';\n\n// #region\n// https://github.com/microsoft/vscode-js-profile-visualizer/blob/6e7401128ee860be113a916f80fcfe20ac99418e/packages/vscode-js-profile-core/src/cpu/model.ts#L4\n\nexport interface IProfileModel {\n\tnodes: ReadonlyArray<IComputedNode>;\n\tlocations: ReadonlyArray<ILocation>;\n\tsamples: ReadonlyArray<number>;\n\ttimeDeltas: ReadonlyArray<number>;\n\trootPath?: string;\n\tduration: number;\n}\n\nexport interface IComputedNode {\n\tid: number;\n\tselfTime: number;\n\taggregateTime: number;\n\tchildren: number[];\n\tparent?: number;\n\tlocationId: number;\n}\n\nexport interface ISourceLocation {\n\tlineNumber: number;\n\tcolumnNumber: number;\n\t//   source: Dap.Source;\n\trelativePath?: string;\n}\n\nexport interface CdpCallFrame {\n\tfunctionName: string;\n\tscriptId: string;\n\turl: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport interface CdpPositionTickInfo {\n\tline: number;\n\tticks: number;\n}\n\nexport interface INode {\n\tid: number;\n\t//   category: Category;\n\tcallFrame: CdpCallFrame;\n\tsrc?: ISourceLocation;\n}\n\nexport interface ILocation extends INode {\n\tselfTime: number;\n\taggregateTime: number;\n\tticks: number;\n}\n\nexport interface IAnnotationLocation {\n\tcallFrame: CdpCallFrame;\n\tlocations: ISourceLocation[];\n}\n\nexport interface IProfileNode extends IV8ProfileNode {\n\tlocationId?: number;\n\tpositionTicks?: (CdpPositionTickInfo & {\n\t\tstartLocationId?: number;\n\t\tendLocationId?: number;\n\t})[];\n}\n\nexport interface ICpuProfileRaw extends IV8Profile {\n\t//   $vscode?: IJsDebugAnnotations;\n\tnodes: IProfileNode[];\n}\n\n\n/**\n * Recursive function that computes and caches the aggregate time for the\n * children of the computed now.\n */\nconst computeAggregateTime = (index: number, nodes: IComputedNode[]): number => {\n\tconst row = nodes[index];\n\tif (row.aggregateTime) {\n\t\treturn row.aggregateTime;\n\t}\n\n\tlet total = row.selfTime;\n\tfor (const child of row.children) {\n\t\ttotal += computeAggregateTime(child, nodes);\n\t}\n\n\treturn (row.aggregateTime = total);\n};\n\nconst ensureSourceLocations = (profile: ICpuProfileRaw): ReadonlyArray<IAnnotationLocation> => {\n\n\tlet locationIdCounter = 0;\n\tconst locationsByRef = new Map<string, { id: number; callFrame: CdpCallFrame; location: ISourceLocation }>();\n\n\tconst getLocationIdFor = (callFrame: CdpCallFrame) => {\n\t\tconst ref = [\n\t\t\tcallFrame.functionName,\n\t\t\tcallFrame.url,\n\t\t\tcallFrame.scriptId,\n\t\t\tcallFrame.lineNumber,\n\t\t\tcallFrame.columnNumber,\n\t\t].join(':');\n\n\t\tconst existing = locationsByRef.get(ref);\n\t\tif (existing) {\n\t\t\treturn existing.id;\n\t\t}\n\t\tconst id = locationIdCounter++;\n\t\tlocationsByRef.set(ref, {\n\t\t\tid,\n\t\t\tcallFrame,\n\t\t\tlocation: {\n\t\t\t\tlineNumber: callFrame.lineNumber + 1,\n\t\t\t\tcolumnNumber: callFrame.columnNumber + 1,\n\t\t\t\t// source: {\n\t\t\t\t// \tname: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tpath: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tsourceReference: 0,\n\t\t\t\t// },\n\t\t\t},\n\t\t});\n\n\t\treturn id;\n\t};\n\n\tfor (const node of profile.nodes) {\n\t\tnode.locationId = getLocationIdFor(node.callFrame);\n\t\tnode.positionTicks = node.positionTicks?.map(tick => ({\n\t\t\t...tick,\n\t\t\t// weirdly, line numbers here are 1-based, not 0-based. The position tick\n\t\t\t// only gives line-level granularity, so 'mark' the entire range of source\n\t\t\t// code the tick refers to\n\t\t\tstartLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line - 1,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t\tendLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t}));\n\t}\n\n\treturn [...locationsByRef.values()]\n\t\t.sort((a, b) => a.id - b.id)\n\t\t.map(l => ({ locations: [l.location], callFrame: l.callFrame }));\n};\n\n/**\n * Computes the model for the given profile.\n */\nexport const buildModel = (profile: ICpuProfileRaw): IProfileModel => {\n\tif (!profile.timeDeltas || !profile.samples) {\n\t\treturn {\n\t\t\tnodes: [],\n\t\t\tlocations: [],\n\t\t\tsamples: profile.samples || [],\n\t\t\ttimeDeltas: profile.timeDeltas || [],\n\t\t\t// rootPath: profile.$vscode?.rootPath,\n\t\t\tduration: profile.endTime - profile.startTime,\n\t\t};\n\t}\n\n\tconst { samples, timeDeltas } = profile;\n\tconst sourceLocations = ensureSourceLocations(profile);\n\tconst locations: ILocation[] = sourceLocations.map((l, id) => {\n\t\tconst src = l.locations[0]; //getBestLocation(profile, l.locations);\n\n\t\treturn {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\t// category: categorize(l.callFrame, src),\n\t\t\tcallFrame: l.callFrame,\n\t\t\tsrc,\n\t\t};\n\t});\n\n\tconst idMap = new Map<number /* id in profile */, number /* incrementing ID */>();\n\tconst mapId = (nodeId: number) => {\n\t\tlet id = idMap.get(nodeId);\n\t\tif (id === undefined) {\n\t\t\tid = idMap.size;\n\t\t\tidMap.set(nodeId, id);\n\t\t}\n\n\t\treturn id;\n\t};\n\n\t// 1. Created a sorted list of nodes. It seems that the profile always has\n\t// incrementing IDs, although they are just not initially sorted.\n\tconst nodes = new Array<IComputedNode>(profile.nodes.length);\n\tfor (let i = 0; i < profile.nodes.length; i++) {\n\t\tconst node = profile.nodes[i];\n\n\t\t// make them 0-based:\n\t\tconst id = mapId(node.id);\n\t\tnodes[id] = {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tlocationId: node.locationId as number,\n\t\t\tchildren: node.children?.map(mapId) || [],\n\t\t};\n\n\t\tfor (const child of node.positionTicks || []) {\n\t\t\tif (child.startLocationId) {\n\t\t\t\tlocations[child.startLocationId].ticks += child.ticks;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const node of nodes) {\n\t\tfor (const child of node.children) {\n\t\t\tnodes[child].parent = node.id;\n\t\t}\n\t}\n\n\t// 2. The profile samples are the 'bottom-most' node, the currently running\n\t// code. Sum of these in the self time.\n\tconst duration = profile.endTime - profile.startTime;\n\tlet lastNodeTime = duration - timeDeltas[0];\n\tfor (let i = 0; i < timeDeltas.length - 1; i++) {\n\t\tconst d = timeDeltas[i + 1];\n\t\tnodes[mapId(samples[i])].selfTime += d;\n\t\tlastNodeTime -= d;\n\t}\n\n\t// Add in an extra time delta for the last sample. `timeDeltas[0]` is the\n\t// time before the first sample, and the time of the last sample is only\n\t// derived (approximately) by the missing time in the sum of deltas. Save\n\t// some work by calculating it here.\n\tif (nodes.length) {\n\t\tnodes[mapId(samples[timeDeltas.length - 1])].selfTime += lastNodeTime;\n\t\ttimeDeltas.push(lastNodeTime);\n\t}\n\n\t// 3. Add the aggregate times for all node children and locations\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst node = nodes[i];\n\t\tconst location = locations[node.locationId];\n\t\tlocation.aggregateTime += computeAggregateTime(i, nodes);\n\t\tlocation.selfTime += node.selfTime;\n\t}\n\n\treturn {\n\t\tnodes,\n\t\tlocations,\n\t\tsamples: samples.map(mapId),\n\t\ttimeDeltas,\n\t\t// rootPath: profile.$vscode?.rootPath,\n\t\tduration,\n\t};\n};\n\nexport class BottomUpNode {\n\tpublic static root() {\n\t\treturn new BottomUpNode({\n\t\t\tid: -1,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\tcallFrame: {\n\t\t\t\tfunctionName: '(root)',\n\t\t\t\tlineNumber: -1,\n\t\t\t\tcolumnNumber: -1,\n\t\t\t\tscriptId: '0',\n\t\t\t\turl: '',\n\t\t\t},\n\t\t});\n\t}\n\n\tpublic children: { [id: number]: BottomUpNode } = {};\n\tpublic aggregateTime = 0;\n\tpublic selfTime = 0;\n\tpublic ticks = 0;\n\tpublic childrenSize = 0;\n\n\tpublic get id() {\n\t\treturn this.location.id;\n\t}\n\n\tpublic get callFrame() {\n\t\treturn this.location.callFrame;\n\t}\n\n\tpublic get src() {\n\t\treturn this.location.src;\n\t}\n\n\tconstructor(public readonly location: ILocation, public readonly parent?: BottomUpNode) { }\n\n\tpublic addNode(node: IComputedNode) {\n\t\tthis.selfTime += node.selfTime;\n\t\tthis.aggregateTime += node.aggregateTime;\n\t}\n\n}\n\nexport const processNode = (aggregate: BottomUpNode, node: IComputedNode, model: IProfileModel, initialNode = node) => {\n\tlet child = aggregate.children[node.locationId];\n\tif (!child) {\n\t\tchild = new BottomUpNode(model.locations[node.locationId], aggregate);\n\t\taggregate.childrenSize++;\n\t\taggregate.children[node.locationId] = child;\n\t}\n\n\tchild.addNode(initialNode);\n\n\tif (node.parent) {\n\t\tprocessNode(child, model.nodes[node.parent], model, initialNode);\n\t}\n};\n\n//#endregion\n\n\nexport interface BottomUpSample {\n\tselfTime: number;\n\ttotalTime: number;\n\tlocation: string;\n\tabsLocation: string;\n\turl: string;\n\tcaller: { percentage: number; absLocation: string; location: string }[];\n\tpercentage: number;\n\tisSpecial: boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IV8Profile, IV8ProfileNode } from './profiling.js';\n\n// #region\n// https://github.com/microsoft/vscode-js-profile-visualizer/blob/6e7401128ee860be113a916f80fcfe20ac99418e/packages/vscode-js-profile-core/src/cpu/model.ts#L4\n\nexport interface IProfileModel {\n\tnodes: ReadonlyArray<IComputedNode>;\n\tlocations: ReadonlyArray<ILocation>;\n\tsamples: ReadonlyArray<number>;\n\ttimeDeltas: ReadonlyArray<number>;\n\trootPath?: string;\n\tduration: number;\n}\n\nexport interface IComputedNode {\n\tid: number;\n\tselfTime: number;\n\taggregateTime: number;\n\tchildren: number[];\n\tparent?: number;\n\tlocationId: number;\n}\n\nexport interface ISourceLocation {\n\tlineNumber: number;\n\tcolumnNumber: number;\n\t//   source: Dap.Source;\n\trelativePath?: string;\n}\n\nexport interface CdpCallFrame {\n\tfunctionName: string;\n\tscriptId: string;\n\turl: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport interface CdpPositionTickInfo {\n\tline: number;\n\tticks: number;\n}\n\nexport interface INode {\n\tid: number;\n\t//   category: Category;\n\tcallFrame: CdpCallFrame;\n\tsrc?: ISourceLocation;\n}\n\nexport interface ILocation extends INode {\n\tselfTime: number;\n\taggregateTime: number;\n\tticks: number;\n}\n\nexport interface IAnnotationLocation {\n\tcallFrame: CdpCallFrame;\n\tlocations: ISourceLocation[];\n}\n\nexport interface IProfileNode extends IV8ProfileNode {\n\tlocationId?: number;\n\tpositionTicks?: (CdpPositionTickInfo & {\n\t\tstartLocationId?: number;\n\t\tendLocationId?: number;\n\t})[];\n}\n\nexport interface ICpuProfileRaw extends IV8Profile {\n\t//   $vscode?: IJsDebugAnnotations;\n\tnodes: IProfileNode[];\n}\n\n\n/**\n * Recursive function that computes and caches the aggregate time for the\n * children of the computed now.\n */\nconst computeAggregateTime = (index: number, nodes: IComputedNode[]): number => {\n\tconst row = nodes[index];\n\tif (row.aggregateTime) {\n\t\treturn row.aggregateTime;\n\t}\n\n\tlet total = row.selfTime;\n\tfor (const child of row.children) {\n\t\ttotal += computeAggregateTime(child, nodes);\n\t}\n\n\treturn (row.aggregateTime = total);\n};\n\nconst ensureSourceLocations = (profile: ICpuProfileRaw): ReadonlyArray<IAnnotationLocation> => {\n\n\tlet locationIdCounter = 0;\n\tconst locationsByRef = new Map<string, { id: number; callFrame: CdpCallFrame; location: ISourceLocation }>();\n\n\tconst getLocationIdFor = (callFrame: CdpCallFrame) => {\n\t\tconst ref = [\n\t\t\tcallFrame.functionName,\n\t\t\tcallFrame.url,\n\t\t\tcallFrame.scriptId,\n\t\t\tcallFrame.lineNumber,\n\t\t\tcallFrame.columnNumber,\n\t\t].join(':');\n\n\t\tconst existing = locationsByRef.get(ref);\n\t\tif (existing) {\n\t\t\treturn existing.id;\n\t\t}\n\t\tconst id = locationIdCounter++;\n\t\tlocationsByRef.set(ref, {\n\t\t\tid,\n\t\t\tcallFrame,\n\t\t\tlocation: {\n\t\t\t\tlineNumber: callFrame.lineNumber + 1,\n\t\t\t\tcolumnNumber: callFrame.columnNumber + 1,\n\t\t\t\t// source: {\n\t\t\t\t// \tname: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tpath: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tsourceReference: 0,\n\t\t\t\t// },\n\t\t\t},\n\t\t});\n\n\t\treturn id;\n\t};\n\n\tfor (const node of profile.nodes) {\n\t\tnode.locationId = getLocationIdFor(node.callFrame);\n\t\tnode.positionTicks = node.positionTicks?.map(tick => ({\n\t\t\t...tick,\n\t\t\t// weirdly, line numbers here are 1-based, not 0-based. The position tick\n\t\t\t// only gives line-level granularity, so 'mark' the entire range of source\n\t\t\t// code the tick refers to\n\t\t\tstartLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line - 1,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t\tendLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t}));\n\t}\n\n\treturn [...locationsByRef.values()]\n\t\t.sort((a, b) => a.id - b.id)\n\t\t.map(l => ({ locations: [l.location], callFrame: l.callFrame }));\n};\n\n/**\n * Computes the model for the given profile.\n */\nexport const buildModel = (profile: ICpuProfileRaw): IProfileModel => {\n\tif (!profile.timeDeltas || !profile.samples) {\n\t\treturn {\n\t\t\tnodes: [],\n\t\t\tlocations: [],\n\t\t\tsamples: profile.samples || [],\n\t\t\ttimeDeltas: profile.timeDeltas || [],\n\t\t\t// rootPath: profile.$vscode?.rootPath,\n\t\t\tduration: profile.endTime - profile.startTime,\n\t\t};\n\t}\n\n\tconst { samples, timeDeltas } = profile;\n\tconst sourceLocations = ensureSourceLocations(profile);\n\tconst locations: ILocation[] = sourceLocations.map((l, id) => {\n\t\tconst src = l.locations[0]; //getBestLocation(profile, l.locations);\n\n\t\treturn {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\t// category: categorize(l.callFrame, src),\n\t\t\tcallFrame: l.callFrame,\n\t\t\tsrc,\n\t\t};\n\t});\n\n\tconst idMap = new Map<number /* id in profile */, number /* incrementing ID */>();\n\tconst mapId = (nodeId: number) => {\n\t\tlet id = idMap.get(nodeId);\n\t\tif (id === undefined) {\n\t\t\tid = idMap.size;\n\t\t\tidMap.set(nodeId, id);\n\t\t}\n\n\t\treturn id;\n\t};\n\n\t// 1. Created a sorted list of nodes. It seems that the profile always has\n\t// incrementing IDs, although they are just not initially sorted.\n\tconst nodes = new Array<IComputedNode>(profile.nodes.length);\n\tfor (let i = 0; i < profile.nodes.length; i++) {\n\t\tconst node = profile.nodes[i];\n\n\t\t// make them 0-based:\n\t\tconst id = mapId(node.id);\n\t\tnodes[id] = {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tlocationId: node.locationId as number,\n\t\t\tchildren: node.children?.map(mapId) || [],\n\t\t};\n\n\t\tfor (const child of node.positionTicks || []) {\n\t\t\tif (child.startLocationId) {\n\t\t\t\tlocations[child.startLocationId].ticks += child.ticks;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const node of nodes) {\n\t\tfor (const child of node.children) {\n\t\t\tnodes[child].parent = node.id;\n\t\t}\n\t}\n\n\t// 2. The profile samples are the 'bottom-most' node, the currently running\n\t// code. Sum of these in the self time.\n\tconst duration = profile.endTime - profile.startTime;\n\tlet lastNodeTime = duration - timeDeltas[0];\n\tfor (let i = 0; i < timeDeltas.length - 1; i++) {\n\t\tconst d = timeDeltas[i + 1];\n\t\tnodes[mapId(samples[i])].selfTime += d;\n\t\tlastNodeTime -= d;\n\t}\n\n\t// Add in an extra time delta for the last sample. `timeDeltas[0]` is the\n\t// time before the first sample, and the time of the last sample is only\n\t// derived (approximately) by the missing time in the sum of deltas. Save\n\t// some work by calculating it here.\n\tif (nodes.length) {\n\t\tnodes[mapId(samples[timeDeltas.length - 1])].selfTime += lastNodeTime;\n\t\ttimeDeltas.push(lastNodeTime);\n\t}\n\n\t// 3. Add the aggregate times for all node children and locations\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst node = nodes[i];\n\t\tconst location = locations[node.locationId];\n\t\tlocation.aggregateTime += computeAggregateTime(i, nodes);\n\t\tlocation.selfTime += node.selfTime;\n\t}\n\n\treturn {\n\t\tnodes,\n\t\tlocations,\n\t\tsamples: samples.map(mapId),\n\t\ttimeDeltas,\n\t\t// rootPath: profile.$vscode?.rootPath,\n\t\tduration,\n\t};\n};\n\nexport class BottomUpNode {\n\tpublic static root() {\n\t\treturn new BottomUpNode({\n\t\t\tid: -1,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\tcallFrame: {\n\t\t\t\tfunctionName: '(root)',\n\t\t\t\tlineNumber: -1,\n\t\t\t\tcolumnNumber: -1,\n\t\t\t\tscriptId: '0',\n\t\t\t\turl: '',\n\t\t\t},\n\t\t});\n\t}\n\n\tpublic children: { [id: number]: BottomUpNode } = {};\n\tpublic aggregateTime = 0;\n\tpublic selfTime = 0;\n\tpublic ticks = 0;\n\tpublic childrenSize = 0;\n\n\tpublic get id() {\n\t\treturn this.location.id;\n\t}\n\n\tpublic get callFrame() {\n\t\treturn this.location.callFrame;\n\t}\n\n\tpublic get src() {\n\t\treturn this.location.src;\n\t}\n\n\tconstructor(public readonly location: ILocation, public readonly parent?: BottomUpNode) { }\n\n\tpublic addNode(node: IComputedNode) {\n\t\tthis.selfTime += node.selfTime;\n\t\tthis.aggregateTime += node.aggregateTime;\n\t}\n\n}\n\nexport const processNode = (aggregate: BottomUpNode, node: IComputedNode, model: IProfileModel, initialNode = node) => {\n\tlet child = aggregate.children[node.locationId];\n\tif (!child) {\n\t\tchild = new BottomUpNode(model.locations[node.locationId], aggregate);\n\t\taggregate.childrenSize++;\n\t\taggregate.children[node.locationId] = child;\n\t}\n\n\tchild.addNode(initialNode);\n\n\tif (node.parent) {\n\t\tprocessNode(child, model.nodes[node.parent], model, initialNode);\n\t}\n};\n\n//#endregion\n\n\nexport interface BottomUpSample {\n\tselfTime: number;\n\ttotalTime: number;\n\tlocation: string;\n\tabsLocation: string;\n\turl: string;\n\tcaller: { percentage: number; absLocation: string; location: string }[];\n\tpercentage: number;\n\tisSpecial: boolean;\n}\n"]}