{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/ipc/electron-browser/services.ts","vs/platform/ipc/electron-browser/services.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAY,YAAY,EAAE,MAAM,uCAAuC,CAAC;AAC/E,OAAO,EAAE,cAAc,EAAE,MAAM,2CAA2C,CAAC;AAC3E,OAAO,EAAE,iBAAiB,EAAE,MAAM,0CAA0C,CAAC;AAC7E,OAAO,EAAE,eAAe,EAAE,qBAAqB,EAAqB,MAAM,6CAA6C,CAAC;AACxH,OAAO,EAAE,mBAAmB,EAAE,MAAM,iCAAiC,CAAC;AAOtE,MAAe,iBAAiB;IAC/B,YACC,WAAmB,EACnB,OAA+F,EAC/F,MAAc,EACd,oBAA2C;QAE3C,MAAM,OAAO,GAAG,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAE/C,IAAI,uCAAuC,CAAC,OAAO,CAAC,EAAE,CAAC;YACtD,OAAO,oBAAoB,CAAC,cAAc,CAAC,IAAI,cAAc,CAAC,OAAO,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACtG,CAAC;QAED,OAAO,YAAY,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;IAC/D,CAAC;CACD;AAUD,SAAS,uCAAuC,CAAI,GAAY;IAC/D,MAAM,SAAS,GAAG,GAA4D,CAAC;IAE/E,OAAO,CAAC,CAAC,SAAS,EAAE,iBAAiB,CAAC;AACvC,CAAC;AAED,sBAAsB;AAEtB,IAAM,4BAA4B,GAAlC,MAAM,4BAA+C,SAAQ,iBAAoB;IAChF,YAAY,WAAmB,EAAE,OAA+F,EAAuB,UAA+B,EAAyB,oBAA2C;QACzP,KAAK,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU,EAAE,oBAAoB,CAAC,CAAC;IAC/D,CAAC;CACD,CAAA;AAJK,4BAA4B;IACkG,WAAA,mBAAmB,CAAA;IAAmC,WAAA,qBAAqB,CAAA;GADzM,4BAA4B,CAIjC;AAED,MAAM,UAAU,gCAAgC,CAAI,EAAwB,EAAE,WAAmB,EAAE,OAAoF;IACtL,iBAAiB,CAAC,EAAE,EAAE,IAAI,cAAc,CAAC,4BAA4B,EAAE,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACvG,CAAC;AAED,YAAY;AAEZ,wBAAwB;AAExB,MAAM,CAAC,MAAM,qBAAqB,GAAG,eAAe,CAAwB,sBAAsB,CAAC,CAAC;AAoBpG,IAAM,8BAA8B,GAApC,MAAM,8BAAiD,SAAQ,iBAAoB;IAClF,YAAY,WAAmB,EAAE,OAA+F,EAAyB,UAAiC,EAAyB,oBAA2C;QAC7P,KAAK,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU,EAAE,oBAAoB,CAAC,CAAC;IAC/D,CAAC;CACD,CAAA;AAJK,8BAA8B;IACgG,WAAA,qBAAqB,CAAA;IAAqC,WAAA,qBAAqB,CAAA;GAD7M,8BAA8B,CAInC;AAED,MAAM,UAAU,kCAAkC,CAAI,EAAwB,EAAE,WAAmB,EAAE,OAAoF;IACxL,iBAAiB,CAAC,EAAE,EAAE,IAAI,cAAc,CAAC,8BAA8B,EAAE,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACzG,CAAC;AAED,YAAY","file":"services.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChannel, ProxyChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { SyncDescriptor } from '../../instantiation/common/descriptors.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { createDecorator, IInstantiationService, ServiceIdentifier } from '../../instantiation/common/instantiation.js';\nimport { IMainProcessService } from '../common/mainProcessService.js';\nimport { IRemoteService } from '../common/services.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ChannelClientCtor<T> = { new(channel: IChannel, ...args: any[]): T };\ntype Remote = { getChannel(channelName: string): IChannel };\n\nabstract class RemoteServiceStub<T extends object> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined,\n\t\tremote: Remote,\n\t\tinstantiationService: IInstantiationService\n\t) {\n\t\tconst channel = remote.getChannel(channelName);\n\n\t\tif (isRemoteServiceWithChannelClientOptions(options)) {\n\t\t\treturn instantiationService.createInstance(new SyncDescriptor(options.channelClientCtor, [channel]));\n\t\t}\n\n\t\treturn ProxyChannel.toService(channel, options?.proxyOptions);\n\t}\n}\n\nexport interface IRemoteServiceWithChannelClientOptions<T> {\n\treadonly channelClientCtor: ChannelClientCtor<T>;\n}\n\nexport interface IRemoteServiceWithProxyOptions {\n\treadonly proxyOptions?: ProxyChannel.ICreateProxyServiceOptions;\n}\n\nfunction isRemoteServiceWithChannelClientOptions<T>(obj: unknown): obj is IRemoteServiceWithChannelClientOptions<T> {\n\tconst candidate = obj as IRemoteServiceWithChannelClientOptions<T> | undefined;\n\n\treturn !!candidate?.channelClientCtor;\n}\n\n//#region Main Process\n\nclass MainProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @IMainProcessService ipcService: IMainProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerMainProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(MainProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n\n//#region Shared Process\n\nexport const ISharedProcessService = createDecorator<ISharedProcessService>('sharedProcessService');\n\nexport interface ISharedProcessService extends IRemoteService {\n\n\t/**\n\t * Allows to create a `MessagePort` connection between the\n\t * shared process and the renderer process.\n\t *\n\t * Use this only when you need raw IPC to the shared process\n\t * via `postMessage` and `on('message')` of special data structures\n\t * like typed arrays.\n\t *\n\t * Callers have to call `port.start()` after having installed\n\t * listeners to enable the data flow.\n\t */\n\tcreateRawConnection(): Promise<MessagePort>;\n\n\tnotifyRestored(): void;\n}\n\nclass SharedProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @ISharedProcessService ipcService: ISharedProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerSharedProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(SharedProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChannel, ProxyChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { SyncDescriptor } from '../../instantiation/common/descriptors.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { createDecorator, IInstantiationService, ServiceIdentifier } from '../../instantiation/common/instantiation.js';\nimport { IMainProcessService } from '../common/mainProcessService.js';\nimport { IRemoteService } from '../common/services.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ChannelClientCtor<T> = { new(channel: IChannel, ...args: any[]): T };\ntype Remote = { getChannel(channelName: string): IChannel };\n\nabstract class RemoteServiceStub<T extends object> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined,\n\t\tremote: Remote,\n\t\tinstantiationService: IInstantiationService\n\t) {\n\t\tconst channel = remote.getChannel(channelName);\n\n\t\tif (isRemoteServiceWithChannelClientOptions(options)) {\n\t\t\treturn instantiationService.createInstance(new SyncDescriptor(options.channelClientCtor, [channel]));\n\t\t}\n\n\t\treturn ProxyChannel.toService(channel, options?.proxyOptions);\n\t}\n}\n\nexport interface IRemoteServiceWithChannelClientOptions<T> {\n\treadonly channelClientCtor: ChannelClientCtor<T>;\n}\n\nexport interface IRemoteServiceWithProxyOptions {\n\treadonly proxyOptions?: ProxyChannel.ICreateProxyServiceOptions;\n}\n\nfunction isRemoteServiceWithChannelClientOptions<T>(obj: unknown): obj is IRemoteServiceWithChannelClientOptions<T> {\n\tconst candidate = obj as IRemoteServiceWithChannelClientOptions<T> | undefined;\n\n\treturn !!candidate?.channelClientCtor;\n}\n\n//#region Main Process\n\nclass MainProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @IMainProcessService ipcService: IMainProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerMainProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(MainProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n\n//#region Shared Process\n\nexport const ISharedProcessService = createDecorator<ISharedProcessService>('sharedProcessService');\n\nexport interface ISharedProcessService extends IRemoteService {\n\n\t/**\n\t * Allows to create a `MessagePort` connection between the\n\t * shared process and the renderer process.\n\t *\n\t * Use this only when you need raw IPC to the shared process\n\t * via `postMessage` and `on('message')` of special data structures\n\t * like typed arrays.\n\t *\n\t * Callers have to call `port.start()` after having installed\n\t * listeners to enable the data flow.\n\t */\n\tcreateRawConnection(): Promise<MessagePort>;\n\n\tnotifyRestored(): void;\n}\n\nclass SharedProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @ISharedProcessService ipcService: ISharedProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerSharedProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(SharedProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n"]}