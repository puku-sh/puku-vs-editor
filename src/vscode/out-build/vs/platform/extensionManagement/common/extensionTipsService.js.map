{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/extensionManagement/common/extensionTipsService.ts","vs/platform/extensionManagement/common/extensionTipsService.ts"],"names":[],"mappings":"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","file":"extensionTipsService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { IConfigBasedExtensionTip as IRawConfigBasedExtensionTip } from '../../../base/common/product.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigBasedExtensionTip, IExecutableBasedExtensionTip, IExtensionManagementService, IExtensionTipsService, ILocalExtension } from './extensionManagement.js';\nimport { IFileService } from '../../files/common/files.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { disposableTimeout } from '../../../base/common/async.js';\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { Event } from '../../../base/common/event.js';\nimport { join } from '../../../base/common/path.js';\nimport { isWindows } from '../../../base/common/platform.js';\nimport { env } from '../../../base/common/process.js';\nimport { areSameExtensions } from './extensionManagementUtil.js';\nimport { IExtensionRecommendationNotificationService, RecommendationsNotificationResult, RecommendationSource } from '../../extensionRecommendations/common/extensionRecommendations.js';\nimport { ExtensionType } from '../../extensions/common/extensions.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\n\n//#region Base Extension Tips Service\n\nexport class ExtensionTipsService extends Disposable implements IExtensionTipsService {\n\n\t_serviceBrand: undefined;\n\n\tprivate readonly allConfigBasedTips: Map<string, IRawConfigBasedExtensionTip> = new Map<string, IRawConfigBasedExtensionTip>();\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@IProductService private readonly productService: IProductService,\n\t) {\n\t\tsuper();\n\t\tif (this.productService.configBasedExtensionTips) {\n\t\t\tObject.entries(this.productService.configBasedExtensionTips).forEach(([, value]) => this.allConfigBasedTips.set(value.configPath, value));\n\t\t}\n\t}\n\n\tgetConfigBasedTips(folder: URI): Promise<IConfigBasedExtensionTip[]> {\n\t\treturn this.getValidConfigBasedTips(folder);\n\t}\n\n\tasync getImportantExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\treturn [];\n\t}\n\n\tasync getOtherExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\treturn [];\n\t}\n\n\tprivate async getValidConfigBasedTips(folder: URI): Promise<IConfigBasedExtensionTip[]> {\n\t\tconst result: IConfigBasedExtensionTip[] = [];\n\t\tfor (const [configPath, tip] of this.allConfigBasedTips) {\n\t\t\tif (tip.configScheme && tip.configScheme !== folder.scheme) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst content = (await this.fileService.readFile(joinPath(folder, configPath))).value.toString();\n\t\t\t\tfor (const [key, value] of Object.entries(tip.recommendations)) {\n\t\t\t\t\tif (!value.contentPattern || new RegExp(value.contentPattern, 'mig').test(content)) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\textensionId: key,\n\t\t\t\t\t\t\textensionName: value.name,\n\t\t\t\t\t\t\tconfigName: tip.configName,\n\t\t\t\t\t\t\timportant: !!value.important,\n\t\t\t\t\t\t\tisExtensionPack: !!value.isExtensionPack,\n\t\t\t\t\t\t\twhenNotInstalled: value.whenNotInstalled\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) { /* Ignore */ }\n\t\t}\n\t\treturn result;\n\t}\n}\n\n//#endregion\n\n//#region Native Extension Tips Service (enables unit testing having it here in \"common\")\n\ntype ExeExtensionRecommendationsClassification = {\n\towner: 'sandy081';\n\tcomment: 'Information about executable based extension recommendation';\n\textensionId: { classification: 'PublicNonPersonalData'; purpose: 'FeatureInsight'; comment: 'id of the recommended extension' };\n\texeName: { classification: 'PublicNonPersonalData'; purpose: 'FeatureInsight'; comment: 'name of the executable for which extension is being recommended' };\n};\n\ntype IExeBasedExtensionTips = {\n\treadonly exeFriendlyName: string;\n\treadonly windowsPath?: string;\n\treadonly recommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean; whenNotInstalled?: string[] }[];\n};\n\nconst promptedExecutableTipsStorageKey = 'extensionTips/promptedExecutableTips';\nconst lastPromptedMediumImpExeTimeStorageKey = 'extensionTips/lastPromptedMediumImpExeTime';\n\nexport abstract class AbstractNativeExtensionTipsService extends ExtensionTipsService {\n\n\tprivate readonly highImportanceExecutableTips: Map<string, IExeBasedExtensionTips> = new Map<string, IExeBasedExtensionTips>();\n\tprivate readonly mediumImportanceExecutableTips: Map<string, IExeBasedExtensionTips> = new Map<string, IExeBasedExtensionTips>();\n\tprivate readonly allOtherExecutableTips: Map<string, IExeBasedExtensionTips> = new Map<string, IExeBasedExtensionTips>();\n\n\tprivate highImportanceTipsByExe = new Map<string, IExecutableBasedExtensionTip[]>();\n\tprivate mediumImportanceTipsByExe = new Map<string, IExecutableBasedExtensionTip[]>();\n\n\tconstructor(\n\t\tprivate readonly userHome: URI,\n\t\tprivate readonly windowEvents: {\n\t\t\treadonly onDidOpenMainWindow: Event<unknown>;\n\t\t\treadonly onDidFocusMainWindow: Event<unknown>;\n\t\t},\n\t\tprivate readonly telemetryService: ITelemetryService,\n\t\tprivate readonly extensionManagementService: IExtensionManagementService,\n\t\tprivate readonly storageService: IStorageService,\n\t\tprivate readonly extensionRecommendationNotificationService: IExtensionRecommendationNotificationService,\n\t\tfileService: IFileService,\n\t\tproductService: IProductService\n\t) {\n\t\tsuper(fileService, productService);\n\t\tif (productService.exeBasedExtensionTips) {\n\t\t\tObject.entries(productService.exeBasedExtensionTips).forEach(([key, exeBasedExtensionTip]) => {\n\t\t\t\tconst highImportanceRecommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean }[] = [];\n\t\t\t\tconst mediumImportanceRecommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean }[] = [];\n\t\t\t\tconst otherRecommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean }[] = [];\n\t\t\t\tObject.entries(exeBasedExtensionTip.recommendations).forEach(([extensionId, value]) => {\n\t\t\t\t\tif (value.important) {\n\t\t\t\t\t\tif (exeBasedExtensionTip.important) {\n\t\t\t\t\t\t\thighImportanceRecommendations.push({ extensionId, extensionName: value.name, isExtensionPack: !!value.isExtensionPack });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmediumImportanceRecommendations.push({ extensionId, extensionName: value.name, isExtensionPack: !!value.isExtensionPack });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\totherRecommendations.push({ extensionId, extensionName: value.name, isExtensionPack: !!value.isExtensionPack });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (highImportanceRecommendations.length) {\n\t\t\t\t\tthis.highImportanceExecutableTips.set(key, { exeFriendlyName: exeBasedExtensionTip.friendlyName, windowsPath: exeBasedExtensionTip.windowsPath, recommendations: highImportanceRecommendations });\n\t\t\t\t}\n\t\t\t\tif (mediumImportanceRecommendations.length) {\n\t\t\t\t\tthis.mediumImportanceExecutableTips.set(key, { exeFriendlyName: exeBasedExtensionTip.friendlyName, windowsPath: exeBasedExtensionTip.windowsPath, recommendations: mediumImportanceRecommendations });\n\t\t\t\t}\n\t\t\t\tif (otherRecommendations.length) {\n\t\t\t\t\tthis.allOtherExecutableTips.set(key, { exeFriendlyName: exeBasedExtensionTip.friendlyName, windowsPath: exeBasedExtensionTip.windowsPath, recommendations: otherRecommendations });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/*\n\t\t\t3s has come out to be the good number to fetch and prompt important exe based recommendations\n\t\t\tAlso fetch important exe based recommendations for reporting telemetry\n\t\t*/\n\t\tdisposableTimeout(async () => {\n\t\t\tawait this.collectTips();\n\t\t\tthis.promptHighImportanceExeBasedTip();\n\t\t\tthis.promptMediumImportanceExeBasedTip();\n\t\t}, 3000, this._store);\n\t}\n\n\toverride async getImportantExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\tconst highImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.highImportanceExecutableTips);\n\t\tconst mediumImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.mediumImportanceExecutableTips);\n\t\treturn [...highImportanceExeTips, ...mediumImportanceExeTips];\n\t}\n\n\toverride getOtherExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\treturn this.getValidExecutableBasedExtensionTips(this.allOtherExecutableTips);\n\t}\n\n\tprivate async collectTips(): Promise<void> {\n\t\tconst highImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.highImportanceExecutableTips);\n\t\tconst mediumImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.mediumImportanceExecutableTips);\n\t\tconst local = await this.extensionManagementService.getInstalled();\n\n\t\tthis.highImportanceTipsByExe = this.groupImportantTipsByExe(highImportanceExeTips, local);\n\t\tthis.mediumImportanceTipsByExe = this.groupImportantTipsByExe(mediumImportanceExeTips, local);\n\t}\n\n\tprivate groupImportantTipsByExe(importantExeBasedTips: IExecutableBasedExtensionTip[], local: ILocalExtension[]): Map<string, IExecutableBasedExtensionTip[]> {\n\t\tconst importantExeBasedRecommendations = new Map<string, IExecutableBasedExtensionTip>();\n\t\timportantExeBasedTips.forEach(tip => importantExeBasedRecommendations.set(tip.extensionId.toLowerCase(), tip));\n\n\t\tconst { installed, uninstalled: recommendations } = this.groupByInstalled([...importantExeBasedRecommendations.keys()], local);\n\n\t\t/* Log installed and uninstalled exe based recommendations */\n\t\tfor (const extensionId of installed) {\n\t\t\tconst tip = importantExeBasedRecommendations.get(extensionId);\n\t\t\tif (tip) {\n\t\t\t\tthis.telemetryService.publicLog2<{ exeName: string; extensionId: string }, ExeExtensionRecommendationsClassification>('exeExtensionRecommendations:alreadyInstalled', { extensionId, exeName: tip.exeName });\n\t\t\t}\n\t\t}\n\t\tfor (const extensionId of recommendations) {\n\t\t\tconst tip = importantExeBasedRecommendations.get(extensionId);\n\t\t\tif (tip) {\n\t\t\t\tthis.telemetryService.publicLog2<{ exeName: string; extensionId: string }, ExeExtensionRecommendationsClassification>('exeExtensionRecommendations:notInstalled', { extensionId, exeName: tip.exeName });\n\t\t\t}\n\t\t}\n\n\t\tconst promptedExecutableTips = this.getPromptedExecutableTips();\n\t\tconst tipsByExe = new Map<string, IExecutableBasedExtensionTip[]>();\n\t\tfor (const extensionId of recommendations) {\n\t\t\tconst tip = importantExeBasedRecommendations.get(extensionId);\n\t\t\tif (tip && (!promptedExecutableTips[tip.exeName] || !promptedExecutableTips[tip.exeName].includes(tip.extensionId))) {\n\t\t\t\tlet tips = tipsByExe.get(tip.exeName);\n\t\t\t\tif (!tips) {\n\t\t\t\t\ttips = [];\n\t\t\t\t\ttipsByExe.set(tip.exeName, tips);\n\t\t\t\t}\n\t\t\t\ttips.push(tip);\n\t\t\t}\n\t\t}\n\n\t\treturn tipsByExe;\n\t}\n\n\t/**\n\t * High importance tips are prompted once per restart session\n\t */\n\tprivate promptHighImportanceExeBasedTip(): void {\n\t\tif (this.highImportanceTipsByExe.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [exeName, tips] = [...this.highImportanceTipsByExe.entries()][0];\n\t\tthis.promptExeRecommendations(tips)\n\t\t\t.then(result => {\n\t\t\t\tswitch (result) {\n\t\t\t\t\tcase RecommendationsNotificationResult.Accepted:\n\t\t\t\t\t\tthis.addToRecommendedExecutables(tips[0].exeName, tips);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RecommendationsNotificationResult.Ignored:\n\t\t\t\t\t\tthis.highImportanceTipsByExe.delete(exeName);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RecommendationsNotificationResult.IncompatibleWindow: {\n\t\t\t\t\t\t// Recommended in incompatible window. Schedule the prompt after active window change\n\t\t\t\t\t\tconst onActiveWindowChange = Event.once(Event.latch(Event.any(this.windowEvents.onDidOpenMainWindow, this.windowEvents.onDidFocusMainWindow)));\n\t\t\t\t\t\tthis._register(onActiveWindowChange(() => this.promptHighImportanceExeBasedTip()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RecommendationsNotificationResult.TooMany: {\n\t\t\t\t\t\t// Too many notifications. Schedule the prompt after one hour\n\t\t\t\t\t\tconst disposable = this._register(new MutableDisposable());\n\t\t\t\t\t\tdisposable.value = disposableTimeout(() => { disposable.dispose(); this.promptHighImportanceExeBasedTip(); }, 60 * 60 * 1000 /* 1 hour */);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Medium importance tips are prompted once per 7 days\n\t */\n\tprivate promptMediumImportanceExeBasedTip(): void {\n\t\tif (this.mediumImportanceTipsByExe.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst lastPromptedMediumExeTime = this.getLastPromptedMediumExeTime();\n\t\tconst timeSinceLastPrompt = Date.now() - lastPromptedMediumExeTime;\n\t\tconst promptInterval = 7 * 24 * 60 * 60 * 1000; // 7 Days\n\t\tif (timeSinceLastPrompt < promptInterval) {\n\t\t\t// Wait until interval and prompt\n\t\t\tconst disposable = this._register(new MutableDisposable());\n\t\t\tdisposable.value = disposableTimeout(() => { disposable.dispose(); this.promptMediumImportanceExeBasedTip(); }, promptInterval - timeSinceLastPrompt);\n\t\t\treturn;\n\t\t}\n\n\t\tconst [exeName, tips] = [...this.mediumImportanceTipsByExe.entries()][0];\n\t\tthis.promptExeRecommendations(tips)\n\t\t\t.then(result => {\n\t\t\t\tswitch (result) {\n\t\t\t\t\tcase RecommendationsNotificationResult.Accepted: {\n\t\t\t\t\t\t// Accepted: Update the last prompted time and caches.\n\t\t\t\t\t\tthis.updateLastPromptedMediumExeTime(Date.now());\n\t\t\t\t\t\tthis.mediumImportanceTipsByExe.delete(exeName);\n\t\t\t\t\t\tthis.addToRecommendedExecutables(tips[0].exeName, tips);\n\n\t\t\t\t\t\t// Schedule the next recommendation for next internval\n\t\t\t\t\t\tconst disposable1 = this._register(new MutableDisposable());\n\t\t\t\t\t\tdisposable1.value = disposableTimeout(() => { disposable1.dispose(); this.promptMediumImportanceExeBasedTip(); }, promptInterval);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RecommendationsNotificationResult.Ignored:\n\t\t\t\t\t\t// Ignored: Remove from the cache and prompt next recommendation\n\t\t\t\t\t\tthis.mediumImportanceTipsByExe.delete(exeName);\n\t\t\t\t\t\tthis.promptMediumImportanceExeBasedTip();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RecommendationsNotificationResult.IncompatibleWindow: {\n\t\t\t\t\t\t// Recommended in incompatible window. Schedule the prompt after active window change\n\t\t\t\t\t\tconst onActiveWindowChange = Event.once(Event.latch(Event.any(this.windowEvents.onDidOpenMainWindow, this.windowEvents.onDidFocusMainWindow)));\n\t\t\t\t\t\tthis._register(onActiveWindowChange(() => this.promptMediumImportanceExeBasedTip()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RecommendationsNotificationResult.TooMany: {\n\t\t\t\t\t\t// Too many notifications. Schedule the prompt after one hour\n\t\t\t\t\t\tconst disposable2 = this._register(new MutableDisposable());\n\t\t\t\t\t\tdisposable2.value = disposableTimeout(() => { disposable2.dispose(); this.promptMediumImportanceExeBasedTip(); }, 60 * 60 * 1000 /* 1 hour */);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tprivate async promptExeRecommendations(tips: IExecutableBasedExtensionTip[]): Promise<RecommendationsNotificationResult> {\n\t\tconst installed = await this.extensionManagementService.getInstalled(ExtensionType.User);\n\t\tconst extensions = tips\n\t\t\t.filter(tip => !tip.whenNotInstalled || tip.whenNotInstalled.every(id => installed.every(local => !areSameExtensions(local.identifier, { id }))))\n\t\t\t.map(({ extensionId }) => extensionId.toLowerCase());\n\t\treturn this.extensionRecommendationNotificationService.promptImportantExtensionsInstallNotification({ extensions, source: RecommendationSource.EXE, name: tips[0].exeFriendlyName, searchValue: `@exe:\"${tips[0].exeName}\"` });\n\t}\n\n\tprivate getLastPromptedMediumExeTime(): number {\n\t\tlet value = this.storageService.getNumber(lastPromptedMediumImpExeTimeStorageKey, StorageScope.APPLICATION);\n\t\tif (!value) {\n\t\t\tvalue = Date.now();\n\t\t\tthis.updateLastPromptedMediumExeTime(value);\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate updateLastPromptedMediumExeTime(value: number): void {\n\t\tthis.storageService.store(lastPromptedMediumImpExeTimeStorageKey, value, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t}\n\n\tprivate getPromptedExecutableTips(): IStringDictionary<string[]> {\n\t\treturn JSON.parse(this.storageService.get(promptedExecutableTipsStorageKey, StorageScope.APPLICATION, '{}'));\n\t}\n\n\tprivate addToRecommendedExecutables(exeName: string, tips: IExecutableBasedExtensionTip[]) {\n\t\tconst promptedExecutableTips = this.getPromptedExecutableTips();\n\t\tpromptedExecutableTips[exeName] = tips.map(({ extensionId }) => extensionId.toLowerCase());\n\t\tthis.storageService.store(promptedExecutableTipsStorageKey, JSON.stringify(promptedExecutableTips), StorageScope.APPLICATION, StorageTarget.USER);\n\t}\n\n\tprivate groupByInstalled(recommendationsToSuggest: string[], local: ILocalExtension[]): { installed: string[]; uninstalled: string[] } {\n\t\tconst installed: string[] = [], uninstalled: string[] = [];\n\t\tconst installedExtensionsIds = local.reduce((result, i) => { result.add(i.identifier.id.toLowerCase()); return result; }, new Set<string>());\n\t\trecommendationsToSuggest.forEach(id => {\n\t\t\tif (installedExtensionsIds.has(id.toLowerCase())) {\n\t\t\t\tinstalled.push(id);\n\t\t\t} else {\n\t\t\t\tuninstalled.push(id);\n\t\t\t}\n\t\t});\n\t\treturn { installed, uninstalled };\n\t}\n\n\tprivate async getValidExecutableBasedExtensionTips(executableTips: Map<string, IExeBasedExtensionTips>): Promise<IExecutableBasedExtensionTip[]> {\n\t\tconst result: IExecutableBasedExtensionTip[] = [];\n\n\t\tconst checkedExecutables: Map<string, boolean> = new Map<string, boolean>();\n\t\tfor (const exeName of executableTips.keys()) {\n\t\t\tconst extensionTip = executableTips.get(exeName);\n\t\t\tif (!extensionTip || !isNonEmptyArray(extensionTip.recommendations)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst exePaths: string[] = [];\n\t\t\tif (isWindows) {\n\t\t\t\tif (extensionTip.windowsPath) {\n\t\t\t\t\texePaths.push(extensionTip.windowsPath.replace('%USERPROFILE%', () => env['USERPROFILE']!)\n\t\t\t\t\t\t.replace('%ProgramFiles(x86)%', () => env['ProgramFiles(x86)']!)\n\t\t\t\t\t\t.replace('%ProgramFiles%', () => env['ProgramFiles']!)\n\t\t\t\t\t\t.replace('%APPDATA%', () => env['APPDATA']!)\n\t\t\t\t\t\t.replace('%WINDIR%', () => env['WINDIR']!));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texePaths.push(join('/usr/local/bin', exeName));\n\t\t\t\texePaths.push(join('/usr/bin', exeName));\n\t\t\t\texePaths.push(join(this.userHome.fsPath, exeName));\n\t\t\t}\n\n\t\t\tfor (const exePath of exePaths) {\n\t\t\t\tlet exists = checkedExecutables.get(exePath);\n\t\t\t\tif (exists === undefined) {\n\t\t\t\t\texists = await this.fileService.exists(URI.file(exePath));\n\t\t\t\t\tcheckedExecutables.set(exePath, exists);\n\t\t\t\t}\n\t\t\t\tif (exists) {\n\t\t\t\t\tfor (const { extensionId, extensionName, isExtensionPack, whenNotInstalled } of extensionTip.recommendations) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\textensionId,\n\t\t\t\t\t\t\textensionName,\n\t\t\t\t\t\t\tisExtensionPack,\n\t\t\t\t\t\t\texeName,\n\t\t\t\t\t\t\texeFriendlyName: extensionTip.exeFriendlyName,\n\t\t\t\t\t\t\twindowsPath: extensionTip.windowsPath,\n\t\t\t\t\t\t\twhenNotInstalled: whenNotInstalled\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { IConfigBasedExtensionTip as IRawConfigBasedExtensionTip } from '../../../base/common/product.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigBasedExtensionTip, IExecutableBasedExtensionTip, IExtensionManagementService, IExtensionTipsService, ILocalExtension } from './extensionManagement.js';\nimport { IFileService } from '../../files/common/files.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { disposableTimeout } from '../../../base/common/async.js';\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { Event } from '../../../base/common/event.js';\nimport { join } from '../../../base/common/path.js';\nimport { isWindows } from '../../../base/common/platform.js';\nimport { env } from '../../../base/common/process.js';\nimport { areSameExtensions } from './extensionManagementUtil.js';\nimport { IExtensionRecommendationNotificationService, RecommendationsNotificationResult, RecommendationSource } from '../../extensionRecommendations/common/extensionRecommendations.js';\nimport { ExtensionType } from '../../extensions/common/extensions.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\n\n//#region Base Extension Tips Service\n\nexport class ExtensionTipsService extends Disposable implements IExtensionTipsService {\n\n\t_serviceBrand: undefined;\n\n\tprivate readonly allConfigBasedTips: Map<string, IRawConfigBasedExtensionTip> = new Map<string, IRawConfigBasedExtensionTip>();\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@IProductService private readonly productService: IProductService,\n\t) {\n\t\tsuper();\n\t\tif (this.productService.configBasedExtensionTips) {\n\t\t\tObject.entries(this.productService.configBasedExtensionTips).forEach(([, value]) => this.allConfigBasedTips.set(value.configPath, value));\n\t\t}\n\t}\n\n\tgetConfigBasedTips(folder: URI): Promise<IConfigBasedExtensionTip[]> {\n\t\treturn this.getValidConfigBasedTips(folder);\n\t}\n\n\tasync getImportantExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\treturn [];\n\t}\n\n\tasync getOtherExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\treturn [];\n\t}\n\n\tprivate async getValidConfigBasedTips(folder: URI): Promise<IConfigBasedExtensionTip[]> {\n\t\tconst result: IConfigBasedExtensionTip[] = [];\n\t\tfor (const [configPath, tip] of this.allConfigBasedTips) {\n\t\t\tif (tip.configScheme && tip.configScheme !== folder.scheme) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst content = (await this.fileService.readFile(joinPath(folder, configPath))).value.toString();\n\t\t\t\tfor (const [key, value] of Object.entries(tip.recommendations)) {\n\t\t\t\t\tif (!value.contentPattern || new RegExp(value.contentPattern, 'mig').test(content)) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\textensionId: key,\n\t\t\t\t\t\t\textensionName: value.name,\n\t\t\t\t\t\t\tconfigName: tip.configName,\n\t\t\t\t\t\t\timportant: !!value.important,\n\t\t\t\t\t\t\tisExtensionPack: !!value.isExtensionPack,\n\t\t\t\t\t\t\twhenNotInstalled: value.whenNotInstalled\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) { /* Ignore */ }\n\t\t}\n\t\treturn result;\n\t}\n}\n\n//#endregion\n\n//#region Native Extension Tips Service (enables unit testing having it here in \"common\")\n\ntype ExeExtensionRecommendationsClassification = {\n\towner: 'sandy081';\n\tcomment: 'Information about executable based extension recommendation';\n\textensionId: { classification: 'PublicNonPersonalData'; purpose: 'FeatureInsight'; comment: 'id of the recommended extension' };\n\texeName: { classification: 'PublicNonPersonalData'; purpose: 'FeatureInsight'; comment: 'name of the executable for which extension is being recommended' };\n};\n\ntype IExeBasedExtensionTips = {\n\treadonly exeFriendlyName: string;\n\treadonly windowsPath?: string;\n\treadonly recommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean; whenNotInstalled?: string[] }[];\n};\n\nconst promptedExecutableTipsStorageKey = 'extensionTips/promptedExecutableTips';\nconst lastPromptedMediumImpExeTimeStorageKey = 'extensionTips/lastPromptedMediumImpExeTime';\n\nexport abstract class AbstractNativeExtensionTipsService extends ExtensionTipsService {\n\n\tprivate readonly highImportanceExecutableTips: Map<string, IExeBasedExtensionTips> = new Map<string, IExeBasedExtensionTips>();\n\tprivate readonly mediumImportanceExecutableTips: Map<string, IExeBasedExtensionTips> = new Map<string, IExeBasedExtensionTips>();\n\tprivate readonly allOtherExecutableTips: Map<string, IExeBasedExtensionTips> = new Map<string, IExeBasedExtensionTips>();\n\n\tprivate highImportanceTipsByExe = new Map<string, IExecutableBasedExtensionTip[]>();\n\tprivate mediumImportanceTipsByExe = new Map<string, IExecutableBasedExtensionTip[]>();\n\n\tconstructor(\n\t\tprivate readonly userHome: URI,\n\t\tprivate readonly windowEvents: {\n\t\t\treadonly onDidOpenMainWindow: Event<unknown>;\n\t\t\treadonly onDidFocusMainWindow: Event<unknown>;\n\t\t},\n\t\tprivate readonly telemetryService: ITelemetryService,\n\t\tprivate readonly extensionManagementService: IExtensionManagementService,\n\t\tprivate readonly storageService: IStorageService,\n\t\tprivate readonly extensionRecommendationNotificationService: IExtensionRecommendationNotificationService,\n\t\tfileService: IFileService,\n\t\tproductService: IProductService\n\t) {\n\t\tsuper(fileService, productService);\n\t\tif (productService.exeBasedExtensionTips) {\n\t\t\tObject.entries(productService.exeBasedExtensionTips).forEach(([key, exeBasedExtensionTip]) => {\n\t\t\t\tconst highImportanceRecommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean }[] = [];\n\t\t\t\tconst mediumImportanceRecommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean }[] = [];\n\t\t\t\tconst otherRecommendations: { extensionId: string; extensionName: string; isExtensionPack: boolean }[] = [];\n\t\t\t\tObject.entries(exeBasedExtensionTip.recommendations).forEach(([extensionId, value]) => {\n\t\t\t\t\tif (value.important) {\n\t\t\t\t\t\tif (exeBasedExtensionTip.important) {\n\t\t\t\t\t\t\thighImportanceRecommendations.push({ extensionId, extensionName: value.name, isExtensionPack: !!value.isExtensionPack });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmediumImportanceRecommendations.push({ extensionId, extensionName: value.name, isExtensionPack: !!value.isExtensionPack });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\totherRecommendations.push({ extensionId, extensionName: value.name, isExtensionPack: !!value.isExtensionPack });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (highImportanceRecommendations.length) {\n\t\t\t\t\tthis.highImportanceExecutableTips.set(key, { exeFriendlyName: exeBasedExtensionTip.friendlyName, windowsPath: exeBasedExtensionTip.windowsPath, recommendations: highImportanceRecommendations });\n\t\t\t\t}\n\t\t\t\tif (mediumImportanceRecommendations.length) {\n\t\t\t\t\tthis.mediumImportanceExecutableTips.set(key, { exeFriendlyName: exeBasedExtensionTip.friendlyName, windowsPath: exeBasedExtensionTip.windowsPath, recommendations: mediumImportanceRecommendations });\n\t\t\t\t}\n\t\t\t\tif (otherRecommendations.length) {\n\t\t\t\t\tthis.allOtherExecutableTips.set(key, { exeFriendlyName: exeBasedExtensionTip.friendlyName, windowsPath: exeBasedExtensionTip.windowsPath, recommendations: otherRecommendations });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/*\n\t\t\t3s has come out to be the good number to fetch and prompt important exe based recommendations\n\t\t\tAlso fetch important exe based recommendations for reporting telemetry\n\t\t*/\n\t\tdisposableTimeout(async () => {\n\t\t\tawait this.collectTips();\n\t\t\tthis.promptHighImportanceExeBasedTip();\n\t\t\tthis.promptMediumImportanceExeBasedTip();\n\t\t}, 3000, this._store);\n\t}\n\n\toverride async getImportantExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\tconst highImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.highImportanceExecutableTips);\n\t\tconst mediumImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.mediumImportanceExecutableTips);\n\t\treturn [...highImportanceExeTips, ...mediumImportanceExeTips];\n\t}\n\n\toverride getOtherExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]> {\n\t\treturn this.getValidExecutableBasedExtensionTips(this.allOtherExecutableTips);\n\t}\n\n\tprivate async collectTips(): Promise<void> {\n\t\tconst highImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.highImportanceExecutableTips);\n\t\tconst mediumImportanceExeTips = await this.getValidExecutableBasedExtensionTips(this.mediumImportanceExecutableTips);\n\t\tconst local = await this.extensionManagementService.getInstalled();\n\n\t\tthis.highImportanceTipsByExe = this.groupImportantTipsByExe(highImportanceExeTips, local);\n\t\tthis.mediumImportanceTipsByExe = this.groupImportantTipsByExe(mediumImportanceExeTips, local);\n\t}\n\n\tprivate groupImportantTipsByExe(importantExeBasedTips: IExecutableBasedExtensionTip[], local: ILocalExtension[]): Map<string, IExecutableBasedExtensionTip[]> {\n\t\tconst importantExeBasedRecommendations = new Map<string, IExecutableBasedExtensionTip>();\n\t\timportantExeBasedTips.forEach(tip => importantExeBasedRecommendations.set(tip.extensionId.toLowerCase(), tip));\n\n\t\tconst { installed, uninstalled: recommendations } = this.groupByInstalled([...importantExeBasedRecommendations.keys()], local);\n\n\t\t/* Log installed and uninstalled exe based recommendations */\n\t\tfor (const extensionId of installed) {\n\t\t\tconst tip = importantExeBasedRecommendations.get(extensionId);\n\t\t\tif (tip) {\n\t\t\t\tthis.telemetryService.publicLog2<{ exeName: string; extensionId: string }, ExeExtensionRecommendationsClassification>('exeExtensionRecommendations:alreadyInstalled', { extensionId, exeName: tip.exeName });\n\t\t\t}\n\t\t}\n\t\tfor (const extensionId of recommendations) {\n\t\t\tconst tip = importantExeBasedRecommendations.get(extensionId);\n\t\t\tif (tip) {\n\t\t\t\tthis.telemetryService.publicLog2<{ exeName: string; extensionId: string }, ExeExtensionRecommendationsClassification>('exeExtensionRecommendations:notInstalled', { extensionId, exeName: tip.exeName });\n\t\t\t}\n\t\t}\n\n\t\tconst promptedExecutableTips = this.getPromptedExecutableTips();\n\t\tconst tipsByExe = new Map<string, IExecutableBasedExtensionTip[]>();\n\t\tfor (const extensionId of recommendations) {\n\t\t\tconst tip = importantExeBasedRecommendations.get(extensionId);\n\t\t\tif (tip && (!promptedExecutableTips[tip.exeName] || !promptedExecutableTips[tip.exeName].includes(tip.extensionId))) {\n\t\t\t\tlet tips = tipsByExe.get(tip.exeName);\n\t\t\t\tif (!tips) {\n\t\t\t\t\ttips = [];\n\t\t\t\t\ttipsByExe.set(tip.exeName, tips);\n\t\t\t\t}\n\t\t\t\ttips.push(tip);\n\t\t\t}\n\t\t}\n\n\t\treturn tipsByExe;\n\t}\n\n\t/**\n\t * High importance tips are prompted once per restart session\n\t */\n\tprivate promptHighImportanceExeBasedTip(): void {\n\t\tif (this.highImportanceTipsByExe.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [exeName, tips] = [...this.highImportanceTipsByExe.entries()][0];\n\t\tthis.promptExeRecommendations(tips)\n\t\t\t.then(result => {\n\t\t\t\tswitch (result) {\n\t\t\t\t\tcase RecommendationsNotificationResult.Accepted:\n\t\t\t\t\t\tthis.addToRecommendedExecutables(tips[0].exeName, tips);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RecommendationsNotificationResult.Ignored:\n\t\t\t\t\t\tthis.highImportanceTipsByExe.delete(exeName);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RecommendationsNotificationResult.IncompatibleWindow: {\n\t\t\t\t\t\t// Recommended in incompatible window. Schedule the prompt after active window change\n\t\t\t\t\t\tconst onActiveWindowChange = Event.once(Event.latch(Event.any(this.windowEvents.onDidOpenMainWindow, this.windowEvents.onDidFocusMainWindow)));\n\t\t\t\t\t\tthis._register(onActiveWindowChange(() => this.promptHighImportanceExeBasedTip()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RecommendationsNotificationResult.TooMany: {\n\t\t\t\t\t\t// Too many notifications. Schedule the prompt after one hour\n\t\t\t\t\t\tconst disposable = this._register(new MutableDisposable());\n\t\t\t\t\t\tdisposable.value = disposableTimeout(() => { disposable.dispose(); this.promptHighImportanceExeBasedTip(); }, 60 * 60 * 1000 /* 1 hour */);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Medium importance tips are prompted once per 7 days\n\t */\n\tprivate promptMediumImportanceExeBasedTip(): void {\n\t\tif (this.mediumImportanceTipsByExe.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst lastPromptedMediumExeTime = this.getLastPromptedMediumExeTime();\n\t\tconst timeSinceLastPrompt = Date.now() - lastPromptedMediumExeTime;\n\t\tconst promptInterval = 7 * 24 * 60 * 60 * 1000; // 7 Days\n\t\tif (timeSinceLastPrompt < promptInterval) {\n\t\t\t// Wait until interval and prompt\n\t\t\tconst disposable = this._register(new MutableDisposable());\n\t\t\tdisposable.value = disposableTimeout(() => { disposable.dispose(); this.promptMediumImportanceExeBasedTip(); }, promptInterval - timeSinceLastPrompt);\n\t\t\treturn;\n\t\t}\n\n\t\tconst [exeName, tips] = [...this.mediumImportanceTipsByExe.entries()][0];\n\t\tthis.promptExeRecommendations(tips)\n\t\t\t.then(result => {\n\t\t\t\tswitch (result) {\n\t\t\t\t\tcase RecommendationsNotificationResult.Accepted: {\n\t\t\t\t\t\t// Accepted: Update the last prompted time and caches.\n\t\t\t\t\t\tthis.updateLastPromptedMediumExeTime(Date.now());\n\t\t\t\t\t\tthis.mediumImportanceTipsByExe.delete(exeName);\n\t\t\t\t\t\tthis.addToRecommendedExecutables(tips[0].exeName, tips);\n\n\t\t\t\t\t\t// Schedule the next recommendation for next internval\n\t\t\t\t\t\tconst disposable1 = this._register(new MutableDisposable());\n\t\t\t\t\t\tdisposable1.value = disposableTimeout(() => { disposable1.dispose(); this.promptMediumImportanceExeBasedTip(); }, promptInterval);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RecommendationsNotificationResult.Ignored:\n\t\t\t\t\t\t// Ignored: Remove from the cache and prompt next recommendation\n\t\t\t\t\t\tthis.mediumImportanceTipsByExe.delete(exeName);\n\t\t\t\t\t\tthis.promptMediumImportanceExeBasedTip();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RecommendationsNotificationResult.IncompatibleWindow: {\n\t\t\t\t\t\t// Recommended in incompatible window. Schedule the prompt after active window change\n\t\t\t\t\t\tconst onActiveWindowChange = Event.once(Event.latch(Event.any(this.windowEvents.onDidOpenMainWindow, this.windowEvents.onDidFocusMainWindow)));\n\t\t\t\t\t\tthis._register(onActiveWindowChange(() => this.promptMediumImportanceExeBasedTip()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RecommendationsNotificationResult.TooMany: {\n\t\t\t\t\t\t// Too many notifications. Schedule the prompt after one hour\n\t\t\t\t\t\tconst disposable2 = this._register(new MutableDisposable());\n\t\t\t\t\t\tdisposable2.value = disposableTimeout(() => { disposable2.dispose(); this.promptMediumImportanceExeBasedTip(); }, 60 * 60 * 1000 /* 1 hour */);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tprivate async promptExeRecommendations(tips: IExecutableBasedExtensionTip[]): Promise<RecommendationsNotificationResult> {\n\t\tconst installed = await this.extensionManagementService.getInstalled(ExtensionType.User);\n\t\tconst extensions = tips\n\t\t\t.filter(tip => !tip.whenNotInstalled || tip.whenNotInstalled.every(id => installed.every(local => !areSameExtensions(local.identifier, { id }))))\n\t\t\t.map(({ extensionId }) => extensionId.toLowerCase());\n\t\treturn this.extensionRecommendationNotificationService.promptImportantExtensionsInstallNotification({ extensions, source: RecommendationSource.EXE, name: tips[0].exeFriendlyName, searchValue: `@exe:\"${tips[0].exeName}\"` });\n\t}\n\n\tprivate getLastPromptedMediumExeTime(): number {\n\t\tlet value = this.storageService.getNumber(lastPromptedMediumImpExeTimeStorageKey, StorageScope.APPLICATION);\n\t\tif (!value) {\n\t\t\tvalue = Date.now();\n\t\t\tthis.updateLastPromptedMediumExeTime(value);\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate updateLastPromptedMediumExeTime(value: number): void {\n\t\tthis.storageService.store(lastPromptedMediumImpExeTimeStorageKey, value, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t}\n\n\tprivate getPromptedExecutableTips(): IStringDictionary<string[]> {\n\t\treturn JSON.parse(this.storageService.get(promptedExecutableTipsStorageKey, StorageScope.APPLICATION, '{}'));\n\t}\n\n\tprivate addToRecommendedExecutables(exeName: string, tips: IExecutableBasedExtensionTip[]) {\n\t\tconst promptedExecutableTips = this.getPromptedExecutableTips();\n\t\tpromptedExecutableTips[exeName] = tips.map(({ extensionId }) => extensionId.toLowerCase());\n\t\tthis.storageService.store(promptedExecutableTipsStorageKey, JSON.stringify(promptedExecutableTips), StorageScope.APPLICATION, StorageTarget.USER);\n\t}\n\n\tprivate groupByInstalled(recommendationsToSuggest: string[], local: ILocalExtension[]): { installed: string[]; uninstalled: string[] } {\n\t\tconst installed: string[] = [], uninstalled: string[] = [];\n\t\tconst installedExtensionsIds = local.reduce((result, i) => { result.add(i.identifier.id.toLowerCase()); return result; }, new Set<string>());\n\t\trecommendationsToSuggest.forEach(id => {\n\t\t\tif (installedExtensionsIds.has(id.toLowerCase())) {\n\t\t\t\tinstalled.push(id);\n\t\t\t} else {\n\t\t\t\tuninstalled.push(id);\n\t\t\t}\n\t\t});\n\t\treturn { installed, uninstalled };\n\t}\n\n\tprivate async getValidExecutableBasedExtensionTips(executableTips: Map<string, IExeBasedExtensionTips>): Promise<IExecutableBasedExtensionTip[]> {\n\t\tconst result: IExecutableBasedExtensionTip[] = [];\n\n\t\tconst checkedExecutables: Map<string, boolean> = new Map<string, boolean>();\n\t\tfor (const exeName of executableTips.keys()) {\n\t\t\tconst extensionTip = executableTips.get(exeName);\n\t\t\tif (!extensionTip || !isNonEmptyArray(extensionTip.recommendations)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst exePaths: string[] = [];\n\t\t\tif (isWindows) {\n\t\t\t\tif (extensionTip.windowsPath) {\n\t\t\t\t\texePaths.push(extensionTip.windowsPath.replace('%USERPROFILE%', () => env['USERPROFILE']!)\n\t\t\t\t\t\t.replace('%ProgramFiles(x86)%', () => env['ProgramFiles(x86)']!)\n\t\t\t\t\t\t.replace('%ProgramFiles%', () => env['ProgramFiles']!)\n\t\t\t\t\t\t.replace('%APPDATA%', () => env['APPDATA']!)\n\t\t\t\t\t\t.replace('%WINDIR%', () => env['WINDIR']!));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texePaths.push(join('/usr/local/bin', exeName));\n\t\t\t\texePaths.push(join('/usr/bin', exeName));\n\t\t\t\texePaths.push(join(this.userHome.fsPath, exeName));\n\t\t\t}\n\n\t\t\tfor (const exePath of exePaths) {\n\t\t\t\tlet exists = checkedExecutables.get(exePath);\n\t\t\t\tif (exists === undefined) {\n\t\t\t\t\texists = await this.fileService.exists(URI.file(exePath));\n\t\t\t\t\tcheckedExecutables.set(exePath, exists);\n\t\t\t\t}\n\t\t\t\tif (exists) {\n\t\t\t\t\tfor (const { extensionId, extensionName, isExtensionPack, whenNotInstalled } of extensionTip.recommendations) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\textensionId,\n\t\t\t\t\t\t\textensionName,\n\t\t\t\t\t\t\tisExtensionPack,\n\t\t\t\t\t\t\texeName,\n\t\t\t\t\t\t\texeFriendlyName: extensionTip.exeFriendlyName,\n\t\t\t\t\t\t\twindowsPath: extensionTip.windowsPath,\n\t\t\t\t\t\t\twhenNotInstalled: whenNotInstalled\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n//#endregion\n"]}