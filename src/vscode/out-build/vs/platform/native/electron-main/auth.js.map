{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/native/electron-main/auth.ts","vs/platform/native/electron-main/auth.ts"],"names":[],"mappings":"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","file":"auth.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, AuthenticationResponseDetails, AuthInfo as ElectronAuthInfo, Event as ElectronEvent, WebContents } from 'electron';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEncryptionMainService } from '../../encryption/common/encryptionService.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AuthInfo, Credentials } from '../../request/common/request.js';\nimport { StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { IApplicationStorageMainService } from '../../storage/electron-main/storageMainService.js';\nimport { IWindowsMainService } from '../../windows/electron-main/windows.js';\n\ninterface ElectronAuthenticationResponseDetails extends AuthenticationResponseDetails {\n\tfirstAuthAttempt?: boolean; // https://github.com/electron/electron/blob/84a42a050e7d45225e69df5bd2d2bf9f1037ea41/shell/browser/login_handler.cc#L70\n}\n\ntype LoginEvent = {\n\tevent?: ElectronEvent;\n\tauthInfo: AuthInfo;\n\tcallback?: (username?: string, password?: string) => void;\n};\n\nexport const IProxyAuthService = createDecorator<IProxyAuthService>('proxyAuthService');\n\nexport interface IProxyAuthService {\n\tlookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined>;\n}\n\nexport class ProxyAuthService extends Disposable implements IProxyAuthService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly PROXY_CREDENTIALS_SERVICE_KEY = 'proxy-credentials://';\n\n\tprivate pendingProxyResolves = new Map<string, Promise<Credentials | undefined>>();\n\tprivate currentDialog: Promise<Credentials | undefined> | undefined = undefined;\n\n\tprivate cancelledAuthInfoHashes = new Set<string>();\n\n\tprivate sessionCredentials = new Map<string, Credentials | undefined>();\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IEncryptionMainService private readonly encryptionMainService: IEncryptionMainService,\n\t\t@IApplicationStorageMainService private readonly applicationStorageMainService: IApplicationStorageMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tconst onLogin = Event.fromNodeEventEmitter<LoginEvent>(app, 'login', (event: ElectronEvent, _webContents: WebContents, req: ElectronAuthenticationResponseDetails, authInfo: ElectronAuthInfo, callback) => ({ event, authInfo: { ...authInfo, attempt: req.firstAuthAttempt ? 1 : 2 }, callback } satisfies LoginEvent));\n\t\tthis._register(onLogin(this.onLogin, this));\n\t}\n\n\tasync lookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\treturn this.onLogin({ authInfo });\n\t}\n\n\tprivate async onLogin({ event, authInfo, callback }: LoginEvent): Promise<Credentials | undefined> {\n\t\tif (!authInfo.isProxy) {\n\t\t\treturn; // only for proxy\n\t\t}\n\n\t\t// Signal we handle this event on our own, otherwise\n\t\t// Electron will ignore our provided credentials.\n\t\tevent?.preventDefault();\n\n\t\t// Compute a hash over the authentication info to be used\n\t\t// with the credentials store to return the right credentials\n\t\t// given the properties of the auth request\n\t\t// (see https://github.com/microsoft/vscode/issues/109497)\n\t\tconst authInfoHash = String(hash({ scheme: authInfo.scheme, host: authInfo.host, port: authInfo.port }));\n\n\t\tlet credentials: Credentials | undefined = undefined;\n\t\tlet pendingProxyResolve = this.pendingProxyResolves.get(authInfoHash);\n\t\tif (!pendingProxyResolve) {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - no pending proxy handling found, starting new');\n\n\t\t\tpendingProxyResolve = this.resolveProxyCredentials(authInfo, authInfoHash);\n\t\t\tthis.pendingProxyResolves.set(authInfoHash, pendingProxyResolve);\n\t\t\ttry {\n\t\t\t\tcredentials = await pendingProxyResolve;\n\t\t\t} finally {\n\t\t\t\tthis.pendingProxyResolves.delete(authInfoHash);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - pending proxy handling found');\n\n\t\t\tcredentials = await pendingProxyResolve;\n\t\t}\n\n\t\t// According to Electron docs, it is fine to call back without\n\t\t// username or password to signal that the authentication was handled\n\t\t// by us, even though without having credentials received:\n\t\t//\n\t\t// > If `callback` is called without a username or password, the authentication\n\t\t// > request will be cancelled and the authentication error will be returned to the\n\t\t// > page.\n\t\tcallback?.(credentials?.username, credentials?.password);\n\t\treturn credentials;\n\t}\n\n\tprivate async resolveProxyCredentials(authInfo: AuthInfo, authInfoHash: string): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - enter');\n\n\t\ttry {\n\t\t\tconst credentials = await this.doResolveProxyCredentials(authInfo, authInfoHash);\n\t\t\tif (credentials) {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - got credentials');\n\n\t\t\t\treturn credentials;\n\t\t\t} else {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - did not get credentials');\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - exit');\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doResolveProxyCredentials(authInfo: AuthInfo, authInfoHash: string): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#doResolveProxyCredentials - enter', authInfo);\n\n\t\t// For testing.\n\t\tif (this.environmentMainService.extensionTestsLocationURI) {\n\t\t\ttry {\n\t\t\t\tconst decodedRealm = Buffer.from(authInfo.realm, 'base64').toString('utf-8');\n\t\t\t\tif (decodedRealm.startsWith('{')) {\n\t\t\t\t\treturn JSON.parse(decodedRealm);\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Reply with manually supplied credentials. Fail if they are wrong.\n\t\tconst newHttpProxy = (this.configurationService.getValue<string>('http.proxy') || '').trim()\n\t\t\t|| (process.env['https_proxy'] || process.env['HTTPS_PROXY'] || process.env['http_proxy'] || process.env['HTTP_PROXY'] || '').trim()\n\t\t\t|| undefined;\n\n\t\tif (newHttpProxy?.indexOf('@') !== -1) {\n\t\t\tconst uri = URI.parse(newHttpProxy!);\n\t\t\tconst i = uri.authority.indexOf('@');\n\t\t\tif (i !== -1) {\n\t\t\t\tif (authInfo.attempt > 1) {\n\t\t\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - ignoring previously used config/envvar credentials');\n\t\t\t\t\treturn undefined; // We tried already, let the user handle it.\n\t\t\t\t}\n\t\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found config/envvar credentials to use');\n\t\t\t\tconst credentials = uri.authority.substring(0, i);\n\t\t\t\tconst j = credentials.indexOf(':');\n\t\t\t\tif (j !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials.substring(0, j),\n\t\t\t\t\t\tpassword: credentials.substring(j + 1)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials,\n\t\t\t\t\t\tpassword: ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reply with session credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tconst sessionCredentials = authInfo.attempt === 1 && this.sessionCredentials.get(authInfoHash);\n\t\tif (sessionCredentials) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found session credentials to use');\n\n\t\t\tconst { username, password } = sessionCredentials;\n\t\t\treturn { username, password };\n\t\t}\n\n\t\tlet storedUsername: string | undefined;\n\t\tlet storedPassword: string | undefined;\n\t\ttry {\n\t\t\t// Try to find stored credentials for the given auth info\n\t\t\tconst encryptedValue = this.applicationStorageMainService.get(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\tif (encryptedValue) {\n\t\t\t\tconst credentials: Credentials = JSON.parse(await this.encryptionMainService.decrypt(encryptedValue));\n\t\t\t\tstoredUsername = credentials.username;\n\t\t\t\tstoredPassword = credentials.password;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error); // handle errors by asking user for login via dialog\n\t\t}\n\n\t\t// Reply with stored credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tif (authInfo.attempt === 1 && typeof storedUsername === 'string' && typeof storedPassword === 'string') {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found stored credentials to use');\n\n\t\t\tthis.sessionCredentials.set(authInfoHash, { username: storedUsername, password: storedPassword });\n\t\t\treturn { username: storedUsername, password: storedPassword };\n\t\t}\n\n\t\tconst previousDialog = this.currentDialog;\n\t\tconst currentDialog = this.currentDialog = (async () => {\n\t\t\tawait previousDialog;\n\t\t\tconst credentials = await this.showProxyCredentialsDialog(authInfo, authInfoHash, storedUsername, storedPassword);\n\t\t\tif (this.currentDialog === currentDialog!) {\n\t\t\t\tthis.currentDialog = undefined;\n\t\t\t}\n\t\t\treturn credentials;\n\t\t})();\n\t\treturn currentDialog;\n\t}\n\n\tprivate async showProxyCredentialsDialog(authInfo: AuthInfo, authInfoHash: string, storedUsername: string | undefined, storedPassword: string | undefined): Promise<Credentials | undefined> {\n\t\tif (this.cancelledAuthInfoHashes.has(authInfoHash)) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - login dialog was cancelled before, not showing again');\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Find suitable window to show dialog: prefer to show it in the\n\t\t// active window because any other network request will wait on\n\t\t// the credentials and we want the user to present the dialog.\n\t\tconst window = this.windowsMainService.getFocusedWindow() || this.windowsMainService.getLastActiveWindow();\n\t\tif (!window) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - no opened window found to show dialog in');\n\n\t\t\treturn undefined; // unexpected\n\t\t}\n\n\t\tthis.logService.trace(`auth#doResolveProxyCredentials (proxy) - asking window ${window.id} to handle proxy login`);\n\n\t\t// Open proxy dialog\n\t\tconst sessionCredentials = this.sessionCredentials.get(authInfoHash);\n\t\tconst payload = {\n\t\t\tauthInfo,\n\t\t\tusername: sessionCredentials?.username ?? storedUsername, // prefer to show already used username (if any) over stored\n\t\t\tpassword: sessionCredentials?.password ?? storedPassword, // prefer to show already used password (if any) over stored\n\t\t\treplyChannel: `vscode:proxyAuthResponse:${generateUuid()}`\n\t\t};\n\t\twindow.sendWhenReady('vscode:openProxyAuthenticationDialog', CancellationToken.None, payload);\n\n\t\t// Handle reply\n\t\tconst loginDialogCredentials = await new Promise<Credentials | undefined>(resolve => {\n\t\t\tconst proxyAuthResponseHandler = async (event: ElectronEvent, channel: string, reply: Credentials & { remember: boolean } | undefined /* canceled */) => {\n\t\t\t\tif (channel === payload.replyChannel) {\n\t\t\t\t\tthis.logService.trace(`auth#doResolveProxyCredentials - exit - received credentials from window ${window.id}`);\n\t\t\t\t\twindow.win?.webContents.off('ipc-message', proxyAuthResponseHandler);\n\n\t\t\t\t\t// We got credentials from the window\n\t\t\t\t\tif (reply) {\n\t\t\t\t\t\tconst credentials: Credentials = { username: reply.username, password: reply.password };\n\n\t\t\t\t\t\t// Update stored credentials based on `remember` flag\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (reply.remember) {\n\t\t\t\t\t\t\t\tconst encryptedSerializedCredentials = await this.encryptionMainService.encrypt(JSON.stringify(credentials));\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.store(\n\t\t\t\t\t\t\t\t\tthis.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash,\n\t\t\t\t\t\t\t\t\tencryptedSerializedCredentials,\n\t\t\t\t\t\t\t\t\tStorageScope.APPLICATION,\n\t\t\t\t\t\t\t\t\t// Always store in machine scope because we do not want these values to be synced\n\t\t\t\t\t\t\t\t\tStorageTarget.MACHINE\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.remove(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logService.error(error); // handle gracefully\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve({ username: credentials.username, password: credentials.password });\n\t\t\t\t\t}\n\n\t\t\t\t\t// We did not get any credentials from the window (e.g. cancelled)\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.cancelledAuthInfoHashes.add(authInfoHash);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.win?.webContents.on('ipc-message', proxyAuthResponseHandler);\n\t\t});\n\n\t\t// Remember credentials for the session in case\n\t\t// the credentials are wrong and we show the dialog\n\t\t// again\n\t\tthis.sessionCredentials.set(authInfoHash, loginDialogCredentials);\n\n\t\treturn loginDialogCredentials;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, AuthenticationResponseDetails, AuthInfo as ElectronAuthInfo, Event as ElectronEvent, WebContents } from 'electron';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEncryptionMainService } from '../../encryption/common/encryptionService.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AuthInfo, Credentials } from '../../request/common/request.js';\nimport { StorageScope, StorageTarget } from '../../storage/common/storage.js';\nimport { IApplicationStorageMainService } from '../../storage/electron-main/storageMainService.js';\nimport { IWindowsMainService } from '../../windows/electron-main/windows.js';\n\ninterface ElectronAuthenticationResponseDetails extends AuthenticationResponseDetails {\n\tfirstAuthAttempt?: boolean; // https://github.com/electron/electron/blob/84a42a050e7d45225e69df5bd2d2bf9f1037ea41/shell/browser/login_handler.cc#L70\n}\n\ntype LoginEvent = {\n\tevent?: ElectronEvent;\n\tauthInfo: AuthInfo;\n\tcallback?: (username?: string, password?: string) => void;\n};\n\nexport const IProxyAuthService = createDecorator<IProxyAuthService>('proxyAuthService');\n\nexport interface IProxyAuthService {\n\tlookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined>;\n}\n\nexport class ProxyAuthService extends Disposable implements IProxyAuthService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly PROXY_CREDENTIALS_SERVICE_KEY = 'proxy-credentials://';\n\n\tprivate pendingProxyResolves = new Map<string, Promise<Credentials | undefined>>();\n\tprivate currentDialog: Promise<Credentials | undefined> | undefined = undefined;\n\n\tprivate cancelledAuthInfoHashes = new Set<string>();\n\n\tprivate sessionCredentials = new Map<string, Credentials | undefined>();\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IEncryptionMainService private readonly encryptionMainService: IEncryptionMainService,\n\t\t@IApplicationStorageMainService private readonly applicationStorageMainService: IApplicationStorageMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tconst onLogin = Event.fromNodeEventEmitter<LoginEvent>(app, 'login', (event: ElectronEvent, _webContents: WebContents, req: ElectronAuthenticationResponseDetails, authInfo: ElectronAuthInfo, callback) => ({ event, authInfo: { ...authInfo, attempt: req.firstAuthAttempt ? 1 : 2 }, callback } satisfies LoginEvent));\n\t\tthis._register(onLogin(this.onLogin, this));\n\t}\n\n\tasync lookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\treturn this.onLogin({ authInfo });\n\t}\n\n\tprivate async onLogin({ event, authInfo, callback }: LoginEvent): Promise<Credentials | undefined> {\n\t\tif (!authInfo.isProxy) {\n\t\t\treturn; // only for proxy\n\t\t}\n\n\t\t// Signal we handle this event on our own, otherwise\n\t\t// Electron will ignore our provided credentials.\n\t\tevent?.preventDefault();\n\n\t\t// Compute a hash over the authentication info to be used\n\t\t// with the credentials store to return the right credentials\n\t\t// given the properties of the auth request\n\t\t// (see https://github.com/microsoft/vscode/issues/109497)\n\t\tconst authInfoHash = String(hash({ scheme: authInfo.scheme, host: authInfo.host, port: authInfo.port }));\n\n\t\tlet credentials: Credentials | undefined = undefined;\n\t\tlet pendingProxyResolve = this.pendingProxyResolves.get(authInfoHash);\n\t\tif (!pendingProxyResolve) {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - no pending proxy handling found, starting new');\n\n\t\t\tpendingProxyResolve = this.resolveProxyCredentials(authInfo, authInfoHash);\n\t\t\tthis.pendingProxyResolves.set(authInfoHash, pendingProxyResolve);\n\t\t\ttry {\n\t\t\t\tcredentials = await pendingProxyResolve;\n\t\t\t} finally {\n\t\t\t\tthis.pendingProxyResolves.delete(authInfoHash);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - pending proxy handling found');\n\n\t\t\tcredentials = await pendingProxyResolve;\n\t\t}\n\n\t\t// According to Electron docs, it is fine to call back without\n\t\t// username or password to signal that the authentication was handled\n\t\t// by us, even though without having credentials received:\n\t\t//\n\t\t// > If `callback` is called without a username or password, the authentication\n\t\t// > request will be cancelled and the authentication error will be returned to the\n\t\t// > page.\n\t\tcallback?.(credentials?.username, credentials?.password);\n\t\treturn credentials;\n\t}\n\n\tprivate async resolveProxyCredentials(authInfo: AuthInfo, authInfoHash: string): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - enter');\n\n\t\ttry {\n\t\t\tconst credentials = await this.doResolveProxyCredentials(authInfo, authInfoHash);\n\t\t\tif (credentials) {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - got credentials');\n\n\t\t\t\treturn credentials;\n\t\t\t} else {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - did not get credentials');\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - exit');\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doResolveProxyCredentials(authInfo: AuthInfo, authInfoHash: string): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#doResolveProxyCredentials - enter', authInfo);\n\n\t\t// For testing.\n\t\tif (this.environmentMainService.extensionTestsLocationURI) {\n\t\t\ttry {\n\t\t\t\tconst decodedRealm = Buffer.from(authInfo.realm, 'base64').toString('utf-8');\n\t\t\t\tif (decodedRealm.startsWith('{')) {\n\t\t\t\t\treturn JSON.parse(decodedRealm);\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Reply with manually supplied credentials. Fail if they are wrong.\n\t\tconst newHttpProxy = (this.configurationService.getValue<string>('http.proxy') || '').trim()\n\t\t\t|| (process.env['https_proxy'] || process.env['HTTPS_PROXY'] || process.env['http_proxy'] || process.env['HTTP_PROXY'] || '').trim()\n\t\t\t|| undefined;\n\n\t\tif (newHttpProxy?.indexOf('@') !== -1) {\n\t\t\tconst uri = URI.parse(newHttpProxy!);\n\t\t\tconst i = uri.authority.indexOf('@');\n\t\t\tif (i !== -1) {\n\t\t\t\tif (authInfo.attempt > 1) {\n\t\t\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - ignoring previously used config/envvar credentials');\n\t\t\t\t\treturn undefined; // We tried already, let the user handle it.\n\t\t\t\t}\n\t\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found config/envvar credentials to use');\n\t\t\t\tconst credentials = uri.authority.substring(0, i);\n\t\t\t\tconst j = credentials.indexOf(':');\n\t\t\t\tif (j !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials.substring(0, j),\n\t\t\t\t\t\tpassword: credentials.substring(j + 1)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tusername: credentials,\n\t\t\t\t\t\tpassword: ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reply with session credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tconst sessionCredentials = authInfo.attempt === 1 && this.sessionCredentials.get(authInfoHash);\n\t\tif (sessionCredentials) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found session credentials to use');\n\n\t\t\tconst { username, password } = sessionCredentials;\n\t\t\treturn { username, password };\n\t\t}\n\n\t\tlet storedUsername: string | undefined;\n\t\tlet storedPassword: string | undefined;\n\t\ttry {\n\t\t\t// Try to find stored credentials for the given auth info\n\t\t\tconst encryptedValue = this.applicationStorageMainService.get(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\tif (encryptedValue) {\n\t\t\t\tconst credentials: Credentials = JSON.parse(await this.encryptionMainService.decrypt(encryptedValue));\n\t\t\t\tstoredUsername = credentials.username;\n\t\t\t\tstoredPassword = credentials.password;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error); // handle errors by asking user for login via dialog\n\t\t}\n\n\t\t// Reply with stored credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tif (authInfo.attempt === 1 && typeof storedUsername === 'string' && typeof storedPassword === 'string') {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found stored credentials to use');\n\n\t\t\tthis.sessionCredentials.set(authInfoHash, { username: storedUsername, password: storedPassword });\n\t\t\treturn { username: storedUsername, password: storedPassword };\n\t\t}\n\n\t\tconst previousDialog = this.currentDialog;\n\t\tconst currentDialog = this.currentDialog = (async () => {\n\t\t\tawait previousDialog;\n\t\t\tconst credentials = await this.showProxyCredentialsDialog(authInfo, authInfoHash, storedUsername, storedPassword);\n\t\t\tif (this.currentDialog === currentDialog!) {\n\t\t\t\tthis.currentDialog = undefined;\n\t\t\t}\n\t\t\treturn credentials;\n\t\t})();\n\t\treturn currentDialog;\n\t}\n\n\tprivate async showProxyCredentialsDialog(authInfo: AuthInfo, authInfoHash: string, storedUsername: string | undefined, storedPassword: string | undefined): Promise<Credentials | undefined> {\n\t\tif (this.cancelledAuthInfoHashes.has(authInfoHash)) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - login dialog was cancelled before, not showing again');\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Find suitable window to show dialog: prefer to show it in the\n\t\t// active window because any other network request will wait on\n\t\t// the credentials and we want the user to present the dialog.\n\t\tconst window = this.windowsMainService.getFocusedWindow() || this.windowsMainService.getLastActiveWindow();\n\t\tif (!window) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - no opened window found to show dialog in');\n\n\t\t\treturn undefined; // unexpected\n\t\t}\n\n\t\tthis.logService.trace(`auth#doResolveProxyCredentials (proxy) - asking window ${window.id} to handle proxy login`);\n\n\t\t// Open proxy dialog\n\t\tconst sessionCredentials = this.sessionCredentials.get(authInfoHash);\n\t\tconst payload = {\n\t\t\tauthInfo,\n\t\t\tusername: sessionCredentials?.username ?? storedUsername, // prefer to show already used username (if any) over stored\n\t\t\tpassword: sessionCredentials?.password ?? storedPassword, // prefer to show already used password (if any) over stored\n\t\t\treplyChannel: `vscode:proxyAuthResponse:${generateUuid()}`\n\t\t};\n\t\twindow.sendWhenReady('vscode:openProxyAuthenticationDialog', CancellationToken.None, payload);\n\n\t\t// Handle reply\n\t\tconst loginDialogCredentials = await new Promise<Credentials | undefined>(resolve => {\n\t\t\tconst proxyAuthResponseHandler = async (event: ElectronEvent, channel: string, reply: Credentials & { remember: boolean } | undefined /* canceled */) => {\n\t\t\t\tif (channel === payload.replyChannel) {\n\t\t\t\t\tthis.logService.trace(`auth#doResolveProxyCredentials - exit - received credentials from window ${window.id}`);\n\t\t\t\t\twindow.win?.webContents.off('ipc-message', proxyAuthResponseHandler);\n\n\t\t\t\t\t// We got credentials from the window\n\t\t\t\t\tif (reply) {\n\t\t\t\t\t\tconst credentials: Credentials = { username: reply.username, password: reply.password };\n\n\t\t\t\t\t\t// Update stored credentials based on `remember` flag\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (reply.remember) {\n\t\t\t\t\t\t\t\tconst encryptedSerializedCredentials = await this.encryptionMainService.encrypt(JSON.stringify(credentials));\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.store(\n\t\t\t\t\t\t\t\t\tthis.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash,\n\t\t\t\t\t\t\t\t\tencryptedSerializedCredentials,\n\t\t\t\t\t\t\t\t\tStorageScope.APPLICATION,\n\t\t\t\t\t\t\t\t\t// Always store in machine scope because we do not want these values to be synced\n\t\t\t\t\t\t\t\t\tStorageTarget.MACHINE\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.remove(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logService.error(error); // handle gracefully\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve({ username: credentials.username, password: credentials.password });\n\t\t\t\t\t}\n\n\t\t\t\t\t// We did not get any credentials from the window (e.g. cancelled)\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.cancelledAuthInfoHashes.add(authInfoHash);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.win?.webContents.on('ipc-message', proxyAuthResponseHandler);\n\t\t});\n\n\t\t// Remember credentials for the session in case\n\t\t// the credentials are wrong and we show the dialog\n\t\t// again\n\t\tthis.sessionCredentials.set(authInfoHash, loginDialogCredentials);\n\n\t\treturn loginDialogCredentials;\n\t}\n}\n"]}