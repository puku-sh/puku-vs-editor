{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/update/electron-main/updateService.snap.ts","vs/platform/update/electron-main/updateService.snap.ts"],"names":[],"mappings":"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","file":"updateService.snap.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { spawn } from 'child_process';\nimport { realpath, watch } from 'fs';\nimport { timeout } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport * as path from '../../../base/common/path.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AvailableForDownload, IUpdateService, State, StateType, UpdateType } from '../common/update.js';\n\nabstract class AbstractUpdateService implements IUpdateService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _state: State = State.Uninitialized;\n\n\tprivate readonly _onStateChange = new Emitter<State>();\n\treadonly onStateChange: Event<State> = this._onStateChange.event;\n\n\tget state(): State {\n\t\treturn this._state;\n\t}\n\n\tprotected setState(state: State): void {\n\t\tthis.logService.info('update#setState', state.type);\n\t\tthis._state = state;\n\t\tthis._onStateChange.fire(state);\n\t}\n\n\tconstructor(\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@ILogService protected logService: ILogService,\n\t) {\n\t\tif (environmentMainService.disableUpdates) {\n\t\t\tthis.logService.info('update#ctor - updates are disabled');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setState(State.Idle(this.getUpdateType()));\n\n\t\t// Start checking for updates after 30 seconds\n\t\tthis.scheduleCheckForUpdates(30 * 1000).then(undefined, err => this.logService.error(err));\n\t}\n\n\tprivate scheduleCheckForUpdates(delay = 60 * 60 * 1000): Promise<void> {\n\t\treturn timeout(delay)\n\t\t\t.then(() => this.checkForUpdates(false))\n\t\t\t.then(() => {\n\t\t\t\t// Check again after 1 hour\n\t\t\t\treturn this.scheduleCheckForUpdates(60 * 60 * 1000);\n\t\t\t});\n\t}\n\n\tasync checkForUpdates(explicit: boolean): Promise<void> {\n\t\tthis.logService.trace('update#checkForUpdates, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Idle) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.doCheckForUpdates(explicit);\n\t}\n\n\tasync downloadUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#downloadUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.AvailableForDownload) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doDownloadUpdate(this.state);\n\t}\n\n\tprotected doDownloadUpdate(state: AvailableForDownload): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tasync applyUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#applyUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Downloaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doApplyUpdate();\n\t}\n\n\tprotected doApplyUpdate(): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tquitAndInstall(): Promise<void> {\n\t\tthis.logService.trace('update#quitAndInstall, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Ready) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\tthis.logService.trace('update#quitAndInstall(): before lifecycle quit()');\n\n\t\tthis.lifecycleMainService.quit(true /* will restart */).then(vetod => {\n\t\t\tthis.logService.trace(`update#quitAndInstall(): after lifecycle quit() with veto: ${vetod}`);\n\t\t\tif (vetod) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n\t\t\tthis.doQuitAndInstall();\n\t\t});\n\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\n\tprotected getUpdateType(): UpdateType {\n\t\treturn UpdateType.Snap;\n\t}\n\n\tprotected doQuitAndInstall(): void {\n\t\t// noop\n\t}\n\n\tabstract isLatestVersion(): Promise<boolean | undefined>;\n\n\tasync _applySpecificUpdate(packagePath: string): Promise<void> {\n\t\t// noop\n\t}\n\n\tprotected abstract doCheckForUpdates(context: any): void;\n}\n\nexport class SnapUpdateService extends AbstractUpdateService {\n\n\tconstructor(\n\t\tprivate snap: string,\n\t\tprivate snapRevision: string,\n\t\t@ILifecycleMainService lifecycleMainService: ILifecycleMainService,\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@ILogService logService: ILogService,\n\t) {\n\t\tsuper(lifecycleMainService, environmentMainService, logService);\n\n\t\tconst watcher = watch(path.dirname(this.snap));\n\t\tconst onChange = Event.fromNodeEventEmitter(watcher, 'change', (_, fileName: string) => fileName);\n\t\tconst onCurrentChange = Event.filter(onChange, n => n === 'current');\n\t\tconst onDebouncedCurrentChange = Event.debounce(onCurrentChange, (_, e) => e, 2000);\n\t\tconst listener = onDebouncedCurrentChange(() => this.checkForUpdates(false));\n\n\t\tlifecycleMainService.onWillShutdown(() => {\n\t\t\tlistener.dispose();\n\t\t\twatcher.close();\n\t\t});\n\t}\n\n\tprotected doCheckForUpdates(): void {\n\t\tthis.setState(State.CheckingForUpdates(false));\n\t\tthis.isUpdateAvailable().then(result => {\n\t\t\tif (result) {\n\t\t\t\tthis.setState(State.Ready({ version: 'something' }));\n\t\t\t} else {\n\t\t\t\tthis.setState(State.Idle(UpdateType.Snap));\n\t\t\t}\n\t\t}, err => {\n\t\t\tthis.logService.error(err);\n\t\t\tthis.setState(State.Idle(UpdateType.Snap, err.message || err));\n\t\t});\n\t}\n\n\tprotected override doQuitAndInstall(): void {\n\t\tthis.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n\n\t\t// Allow 3 seconds for VS Code to close\n\t\tspawn('sleep 3 && ' + path.basename(process.argv[0]), {\n\t\t\tshell: true,\n\t\t\tdetached: true,\n\t\t\tstdio: 'ignore',\n\t\t});\n\t}\n\n\tprivate async isUpdateAvailable(): Promise<boolean> {\n\t\tconst resolvedCurrentSnapPath = await new Promise<string>((c, e) => realpath(`${path.dirname(this.snap)}/current`, (err, r) => err ? e(err) : c(r)));\n\t\tconst currentRevision = path.basename(resolvedCurrentSnapPath);\n\t\treturn this.snapRevision !== currentRevision;\n\t}\n\n\tisLatestVersion(): Promise<boolean | undefined> {\n\t\treturn this.isUpdateAvailable().then(undefined, err => {\n\t\t\tthis.logService.error('update#checkForSnapUpdate(): Could not get realpath of application.');\n\t\t\treturn undefined;\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { spawn } from 'child_process';\nimport { realpath, watch } from 'fs';\nimport { timeout } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport * as path from '../../../base/common/path.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AvailableForDownload, IUpdateService, State, StateType, UpdateType } from '../common/update.js';\n\nabstract class AbstractUpdateService implements IUpdateService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _state: State = State.Uninitialized;\n\n\tprivate readonly _onStateChange = new Emitter<State>();\n\treadonly onStateChange: Event<State> = this._onStateChange.event;\n\n\tget state(): State {\n\t\treturn this._state;\n\t}\n\n\tprotected setState(state: State): void {\n\t\tthis.logService.info('update#setState', state.type);\n\t\tthis._state = state;\n\t\tthis._onStateChange.fire(state);\n\t}\n\n\tconstructor(\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@ILogService protected logService: ILogService,\n\t) {\n\t\tif (environmentMainService.disableUpdates) {\n\t\t\tthis.logService.info('update#ctor - updates are disabled');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setState(State.Idle(this.getUpdateType()));\n\n\t\t// Start checking for updates after 30 seconds\n\t\tthis.scheduleCheckForUpdates(30 * 1000).then(undefined, err => this.logService.error(err));\n\t}\n\n\tprivate scheduleCheckForUpdates(delay = 60 * 60 * 1000): Promise<void> {\n\t\treturn timeout(delay)\n\t\t\t.then(() => this.checkForUpdates(false))\n\t\t\t.then(() => {\n\t\t\t\t// Check again after 1 hour\n\t\t\t\treturn this.scheduleCheckForUpdates(60 * 60 * 1000);\n\t\t\t});\n\t}\n\n\tasync checkForUpdates(explicit: boolean): Promise<void> {\n\t\tthis.logService.trace('update#checkForUpdates, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Idle) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.doCheckForUpdates(explicit);\n\t}\n\n\tasync downloadUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#downloadUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.AvailableForDownload) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doDownloadUpdate(this.state);\n\t}\n\n\tprotected doDownloadUpdate(state: AvailableForDownload): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tasync applyUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#applyUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Downloaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doApplyUpdate();\n\t}\n\n\tprotected doApplyUpdate(): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tquitAndInstall(): Promise<void> {\n\t\tthis.logService.trace('update#quitAndInstall, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Ready) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\tthis.logService.trace('update#quitAndInstall(): before lifecycle quit()');\n\n\t\tthis.lifecycleMainService.quit(true /* will restart */).then(vetod => {\n\t\t\tthis.logService.trace(`update#quitAndInstall(): after lifecycle quit() with veto: ${vetod}`);\n\t\t\tif (vetod) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n\t\t\tthis.doQuitAndInstall();\n\t\t});\n\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\n\tprotected getUpdateType(): UpdateType {\n\t\treturn UpdateType.Snap;\n\t}\n\n\tprotected doQuitAndInstall(): void {\n\t\t// noop\n\t}\n\n\tabstract isLatestVersion(): Promise<boolean | undefined>;\n\n\tasync _applySpecificUpdate(packagePath: string): Promise<void> {\n\t\t// noop\n\t}\n\n\tprotected abstract doCheckForUpdates(context: any): void;\n}\n\nexport class SnapUpdateService extends AbstractUpdateService {\n\n\tconstructor(\n\t\tprivate snap: string,\n\t\tprivate snapRevision: string,\n\t\t@ILifecycleMainService lifecycleMainService: ILifecycleMainService,\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@ILogService logService: ILogService,\n\t) {\n\t\tsuper(lifecycleMainService, environmentMainService, logService);\n\n\t\tconst watcher = watch(path.dirname(this.snap));\n\t\tconst onChange = Event.fromNodeEventEmitter(watcher, 'change', (_, fileName: string) => fileName);\n\t\tconst onCurrentChange = Event.filter(onChange, n => n === 'current');\n\t\tconst onDebouncedCurrentChange = Event.debounce(onCurrentChange, (_, e) => e, 2000);\n\t\tconst listener = onDebouncedCurrentChange(() => this.checkForUpdates(false));\n\n\t\tlifecycleMainService.onWillShutdown(() => {\n\t\t\tlistener.dispose();\n\t\t\twatcher.close();\n\t\t});\n\t}\n\n\tprotected doCheckForUpdates(): void {\n\t\tthis.setState(State.CheckingForUpdates(false));\n\t\tthis.isUpdateAvailable().then(result => {\n\t\t\tif (result) {\n\t\t\t\tthis.setState(State.Ready({ version: 'something' }));\n\t\t\t} else {\n\t\t\t\tthis.setState(State.Idle(UpdateType.Snap));\n\t\t\t}\n\t\t}, err => {\n\t\t\tthis.logService.error(err);\n\t\t\tthis.setState(State.Idle(UpdateType.Snap, err.message || err));\n\t\t});\n\t}\n\n\tprotected override doQuitAndInstall(): void {\n\t\tthis.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n\n\t\t// Allow 3 seconds for VS Code to close\n\t\tspawn('sleep 3 && ' + path.basename(process.argv[0]), {\n\t\t\tshell: true,\n\t\t\tdetached: true,\n\t\t\tstdio: 'ignore',\n\t\t});\n\t}\n\n\tprivate async isUpdateAvailable(): Promise<boolean> {\n\t\tconst resolvedCurrentSnapPath = await new Promise<string>((c, e) => realpath(`${path.dirname(this.snap)}/current`, (err, r) => err ? e(err) : c(r)));\n\t\tconst currentRevision = path.basename(resolvedCurrentSnapPath);\n\t\treturn this.snapRevision !== currentRevision;\n\t}\n\n\tisLatestVersion(): Promise<boolean | undefined> {\n\t\treturn this.isUpdateAvailable().then(undefined, err => {\n\t\t\tthis.logService.error('update#checkForSnapUpdate(): Could not get realpath of application.');\n\t\t\treturn undefined;\n\t\t});\n\t}\n}\n"]}