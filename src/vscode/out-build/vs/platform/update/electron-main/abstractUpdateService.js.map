{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/update/electron-main/abstractUpdateService.ts","vs/platform/update/electron-main/abstractUpdateService.ts"],"names":[],"mappings":"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","file":"abstractUpdateService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService, LifecycleMainPhase } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IRequestService } from '../../request/common/request.js';\nimport { AvailableForDownload, DisablementReason, IUpdateService, State, StateType, UpdateType } from '../common/update.js';\n\nexport function createUpdateURL(platform: string, quality: string, productService: IProductService): string {\n\treturn `${productService.updateUrl}/api/update/${platform}/${quality}/${productService.commit}`;\n}\n\nexport type UpdateErrorClassification = {\n\towner: 'joaomoreno';\n\tmessageHash: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The hash of the error message.' };\n\tcomment: 'This is used to know how often VS Code updates have failed.';\n};\n\nexport abstract class AbstractUpdateService implements IUpdateService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected url: string | undefined;\n\n\tprivate _state: State = State.Uninitialized;\n\n\tprivate readonly _onStateChange = new Emitter<State>();\n\treadonly onStateChange: Event<State> = this._onStateChange.event;\n\n\tget state(): State {\n\t\treturn this._state;\n\t}\n\n\tprotected setState(state: State): void {\n\t\tthis.logService.info('update#setState', state.type);\n\t\tthis._state = state;\n\t\tthis._onStateChange.fire(state);\n\t}\n\n\tconstructor(\n\t\t@ILifecycleMainService protected readonly lifecycleMainService: ILifecycleMainService,\n\t\t@IConfigurationService protected configurationService: IConfigurationService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IRequestService protected requestService: IRequestService,\n\t\t@ILogService protected logService: ILogService,\n\t\t@IProductService protected readonly productService: IProductService\n\t) {\n\t\tlifecycleMainService.when(LifecycleMainPhase.AfterWindowOpen)\n\t\t\t.finally(() => this.initialize());\n\t}\n\n\t/**\n\t * This must be called before any other call. This is a performance\n\t * optimization, to avoid using extra CPU cycles before first window open.\n\t * https://github.com/microsoft/vscode/issues/89784\n\t */\n\tprotected async initialize(): Promise<void> {\n\t\tif (!this.environmentMainService.isBuilt) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.NotBuilt));\n\t\t\treturn; // updates are never enabled when running out of sources\n\t\t}\n\n\t\tif (this.environmentMainService.disableUpdates) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.DisabledByEnvironment));\n\t\t\tthis.logService.info('update#ctor - updates are disabled by the environment');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.productService.updateUrl || !this.productService.commit) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.MissingConfiguration));\n\t\t\tthis.logService.info('update#ctor - updates are disabled as there is no update URL');\n\t\t\treturn;\n\t\t}\n\n\t\tconst updateMode = this.configurationService.getValue<'none' | 'manual' | 'start' | 'default'>('update.mode');\n\t\tconst quality = this.getProductQuality(updateMode);\n\n\t\tif (!quality) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.ManuallyDisabled));\n\t\t\tthis.logService.info('update#ctor - updates are disabled by user preference');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.url = this.buildUpdateFeedUrl(quality);\n\t\tif (!this.url) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.InvalidConfiguration));\n\t\t\tthis.logService.info('update#ctor - updates are disabled as the update URL is badly formed');\n\t\t\treturn;\n\t\t}\n\n\t\t// hidden setting\n\t\tif (this.configurationService.getValue<boolean>('_update.prss')) {\n\t\t\tconst url = new URL(this.url);\n\t\t\turl.searchParams.set('prss', 'true');\n\t\t\tthis.url = url.toString();\n\t\t}\n\n\t\tthis.setState(State.Idle(this.getUpdateType()));\n\n\t\tif (updateMode === 'manual') {\n\t\t\tthis.logService.info('update#ctor - manual checks only; automatic updates are disabled by user preference');\n\t\t\treturn;\n\t\t}\n\n\t\tif (updateMode === 'start') {\n\t\t\tthis.logService.info('update#ctor - startup checks only; automatic updates are disabled by user preference');\n\n\t\t\t// Check for updates only once after 30 seconds\n\t\t\tsetTimeout(() => this.checkForUpdates(false), 30 * 1000);\n\t\t} else {\n\t\t\t// Start checking for updates after 30 seconds\n\t\t\tthis.scheduleCheckForUpdates(30 * 1000).then(undefined, err => this.logService.error(err));\n\t\t}\n\t}\n\n\tprivate getProductQuality(updateMode: string): string | undefined {\n\t\treturn updateMode === 'none' ? undefined : this.productService.quality;\n\t}\n\n\tprivate scheduleCheckForUpdates(delay = 60 * 60 * 1000): Promise<void> {\n\t\treturn timeout(delay)\n\t\t\t.then(() => this.checkForUpdates(false))\n\t\t\t.then(() => {\n\t\t\t\t// Check again after 1 hour\n\t\t\t\treturn this.scheduleCheckForUpdates(60 * 60 * 1000);\n\t\t\t});\n\t}\n\n\tasync checkForUpdates(explicit: boolean): Promise<void> {\n\t\tthis.logService.trace('update#checkForUpdates, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Idle) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.doCheckForUpdates(explicit);\n\t}\n\n\tasync downloadUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#downloadUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.AvailableForDownload) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doDownloadUpdate(this.state);\n\t}\n\n\tprotected async doDownloadUpdate(state: AvailableForDownload): Promise<void> {\n\t\t// noop\n\t}\n\n\tasync applyUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#applyUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Downloaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doApplyUpdate();\n\t}\n\n\tprotected async doApplyUpdate(): Promise<void> {\n\t\t// noop\n\t}\n\n\tquitAndInstall(): Promise<void> {\n\t\tthis.logService.trace('update#quitAndInstall, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Ready) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\tthis.logService.trace('update#quitAndInstall(): before lifecycle quit()');\n\n\t\tthis.lifecycleMainService.quit(true /* will restart */).then(vetod => {\n\t\t\tthis.logService.trace(`update#quitAndInstall(): after lifecycle quit() with veto: ${vetod}`);\n\t\t\tif (vetod) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n\t\t\tthis.doQuitAndInstall();\n\t\t});\n\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tasync isLatestVersion(): Promise<boolean | undefined> {\n\t\tif (!this.url) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst mode = this.configurationService.getValue<'none' | 'manual' | 'start' | 'default'>('update.mode');\n\n\t\tif (mode === 'none') {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tconst context = await this.requestService.request({ url: this.url }, CancellationToken.None);\n\t\t\t// The update server replies with 204 (No Content) when no\n\t\t\t// update is available - that's all we want to know.\n\t\t\treturn context.res.statusCode === 204;\n\n\t\t} catch (error) {\n\t\t\tthis.logService.error('update#isLatestVersion(): failed to check for updates');\n\t\t\tthis.logService.error(error);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync _applySpecificUpdate(packagePath: string): Promise<void> {\n\t\t// noop\n\t}\n\n\tprotected getUpdateType(): UpdateType {\n\t\treturn UpdateType.Archive;\n\t}\n\n\tprotected doQuitAndInstall(): void {\n\t\t// noop\n\t}\n\n\tprotected abstract buildUpdateFeedUrl(quality: string): string | undefined;\n\tprotected abstract doCheckForUpdates(explicit: boolean): void;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService, LifecycleMainPhase } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IRequestService } from '../../request/common/request.js';\nimport { AvailableForDownload, DisablementReason, IUpdateService, State, StateType, UpdateType } from '../common/update.js';\n\nexport function createUpdateURL(platform: string, quality: string, productService: IProductService): string {\n\treturn `${productService.updateUrl}/api/update/${platform}/${quality}/${productService.commit}`;\n}\n\nexport type UpdateErrorClassification = {\n\towner: 'joaomoreno';\n\tmessageHash: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The hash of the error message.' };\n\tcomment: 'This is used to know how often VS Code updates have failed.';\n};\n\nexport abstract class AbstractUpdateService implements IUpdateService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected url: string | undefined;\n\n\tprivate _state: State = State.Uninitialized;\n\n\tprivate readonly _onStateChange = new Emitter<State>();\n\treadonly onStateChange: Event<State> = this._onStateChange.event;\n\n\tget state(): State {\n\t\treturn this._state;\n\t}\n\n\tprotected setState(state: State): void {\n\t\tthis.logService.info('update#setState', state.type);\n\t\tthis._state = state;\n\t\tthis._onStateChange.fire(state);\n\t}\n\n\tconstructor(\n\t\t@ILifecycleMainService protected readonly lifecycleMainService: ILifecycleMainService,\n\t\t@IConfigurationService protected configurationService: IConfigurationService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IRequestService protected requestService: IRequestService,\n\t\t@ILogService protected logService: ILogService,\n\t\t@IProductService protected readonly productService: IProductService\n\t) {\n\t\tlifecycleMainService.when(LifecycleMainPhase.AfterWindowOpen)\n\t\t\t.finally(() => this.initialize());\n\t}\n\n\t/**\n\t * This must be called before any other call. This is a performance\n\t * optimization, to avoid using extra CPU cycles before first window open.\n\t * https://github.com/microsoft/vscode/issues/89784\n\t */\n\tprotected async initialize(): Promise<void> {\n\t\tif (!this.environmentMainService.isBuilt) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.NotBuilt));\n\t\t\treturn; // updates are never enabled when running out of sources\n\t\t}\n\n\t\tif (this.environmentMainService.disableUpdates) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.DisabledByEnvironment));\n\t\t\tthis.logService.info('update#ctor - updates are disabled by the environment');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.productService.updateUrl || !this.productService.commit) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.MissingConfiguration));\n\t\t\tthis.logService.info('update#ctor - updates are disabled as there is no update URL');\n\t\t\treturn;\n\t\t}\n\n\t\tconst updateMode = this.configurationService.getValue<'none' | 'manual' | 'start' | 'default'>('update.mode');\n\t\tconst quality = this.getProductQuality(updateMode);\n\n\t\tif (!quality) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.ManuallyDisabled));\n\t\t\tthis.logService.info('update#ctor - updates are disabled by user preference');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.url = this.buildUpdateFeedUrl(quality);\n\t\tif (!this.url) {\n\t\t\tthis.setState(State.Disabled(DisablementReason.InvalidConfiguration));\n\t\t\tthis.logService.info('update#ctor - updates are disabled as the update URL is badly formed');\n\t\t\treturn;\n\t\t}\n\n\t\t// hidden setting\n\t\tif (this.configurationService.getValue<boolean>('_update.prss')) {\n\t\t\tconst url = new URL(this.url);\n\t\t\turl.searchParams.set('prss', 'true');\n\t\t\tthis.url = url.toString();\n\t\t}\n\n\t\tthis.setState(State.Idle(this.getUpdateType()));\n\n\t\tif (updateMode === 'manual') {\n\t\t\tthis.logService.info('update#ctor - manual checks only; automatic updates are disabled by user preference');\n\t\t\treturn;\n\t\t}\n\n\t\tif (updateMode === 'start') {\n\t\t\tthis.logService.info('update#ctor - startup checks only; automatic updates are disabled by user preference');\n\n\t\t\t// Check for updates only once after 30 seconds\n\t\t\tsetTimeout(() => this.checkForUpdates(false), 30 * 1000);\n\t\t} else {\n\t\t\t// Start checking for updates after 30 seconds\n\t\t\tthis.scheduleCheckForUpdates(30 * 1000).then(undefined, err => this.logService.error(err));\n\t\t}\n\t}\n\n\tprivate getProductQuality(updateMode: string): string | undefined {\n\t\treturn updateMode === 'none' ? undefined : this.productService.quality;\n\t}\n\n\tprivate scheduleCheckForUpdates(delay = 60 * 60 * 1000): Promise<void> {\n\t\treturn timeout(delay)\n\t\t\t.then(() => this.checkForUpdates(false))\n\t\t\t.then(() => {\n\t\t\t\t// Check again after 1 hour\n\t\t\t\treturn this.scheduleCheckForUpdates(60 * 60 * 1000);\n\t\t\t});\n\t}\n\n\tasync checkForUpdates(explicit: boolean): Promise<void> {\n\t\tthis.logService.trace('update#checkForUpdates, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Idle) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.doCheckForUpdates(explicit);\n\t}\n\n\tasync downloadUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#downloadUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.AvailableForDownload) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doDownloadUpdate(this.state);\n\t}\n\n\tprotected async doDownloadUpdate(state: AvailableForDownload): Promise<void> {\n\t\t// noop\n\t}\n\n\tasync applyUpdate(): Promise<void> {\n\t\tthis.logService.trace('update#applyUpdate, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Downloaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.doApplyUpdate();\n\t}\n\n\tprotected async doApplyUpdate(): Promise<void> {\n\t\t// noop\n\t}\n\n\tquitAndInstall(): Promise<void> {\n\t\tthis.logService.trace('update#quitAndInstall, state = ', this.state.type);\n\n\t\tif (this.state.type !== StateType.Ready) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\tthis.logService.trace('update#quitAndInstall(): before lifecycle quit()');\n\n\t\tthis.lifecycleMainService.quit(true /* will restart */).then(vetod => {\n\t\t\tthis.logService.trace(`update#quitAndInstall(): after lifecycle quit() with veto: ${vetod}`);\n\t\t\tif (vetod) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n\t\t\tthis.doQuitAndInstall();\n\t\t});\n\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tasync isLatestVersion(): Promise<boolean | undefined> {\n\t\tif (!this.url) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst mode = this.configurationService.getValue<'none' | 'manual' | 'start' | 'default'>('update.mode');\n\n\t\tif (mode === 'none') {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tconst context = await this.requestService.request({ url: this.url }, CancellationToken.None);\n\t\t\t// The update server replies with 204 (No Content) when no\n\t\t\t// update is available - that's all we want to know.\n\t\t\treturn context.res.statusCode === 204;\n\n\t\t} catch (error) {\n\t\t\tthis.logService.error('update#isLatestVersion(): failed to check for updates');\n\t\t\tthis.logService.error(error);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync _applySpecificUpdate(packagePath: string): Promise<void> {\n\t\t// noop\n\t}\n\n\tprotected getUpdateType(): UpdateType {\n\t\treturn UpdateType.Archive;\n\t}\n\n\tprotected doQuitAndInstall(): void {\n\t\t// noop\n\t}\n\n\tprotected abstract buildUpdateFeedUrl(quality: string): string | undefined;\n\tprotected abstract doCheckForUpdates(explicit: boolean): void;\n}\n"]}