{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/sharedProcess/electron-main/sharedProcess.ts","vs/platform/sharedProcess/electron-main/sharedProcess.ts"],"names":[],"mappings":"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","file":"sharedProcess.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IpcMainEvent, MessagePortMain } from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { Barrier, DeferredPromise } from '../../../base/common/async.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ISharedProcessConfiguration } from '../node/sharedProcess.js';\nimport { IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\nimport { IPolicyService } from '../../policy/common/policy.js';\nimport { ILoggerMainService } from '../../log/electron-main/loggerService.js';\nimport { UtilityProcess } from '../../utilityProcess/electron-main/utilityProcess.js';\nimport { NullTelemetryService } from '../../telemetry/common/telemetryUtils.js';\nimport { parseSharedProcessDebugPort } from '../../environment/node/environmentService.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { SharedProcessChannelConnection, SharedProcessRawConnection, SharedProcessLifecycle } from '../common/sharedProcess.js';\nimport { Emitter } from '../../../base/common/event.js';\n\nexport class SharedProcess extends Disposable {\n\n\tprivate readonly firstWindowConnectionBarrier = new Barrier();\n\n\tprivate utilityProcess: UtilityProcess | undefined = undefined;\n\tprivate utilityProcessLogListener: IDisposable | undefined = undefined;\n\n\tprivate readonly _onDidCrash = this._register(new Emitter<void>());\n\treadonly onDidCrash = this._onDidCrash.event;\n\n\tconstructor(\n\t\tprivate readonly machineId: string,\n\t\tprivate readonly sqmId: string,\n\t\tprivate readonly devDeviceId: string,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IUserDataProfilesService private readonly userDataProfilesService: IUserDataProfilesService,\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@ILoggerMainService private readonly loggerMainService: ILoggerMainService,\n\t\t@IPolicyService private readonly policyService: IPolicyService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Shared process channel connections from workbench windows\n\t\tvalidatedIpcMain.on(SharedProcessChannelConnection.request, (e, nonce: string) => this.onWindowConnection(e, nonce, SharedProcessChannelConnection.response));\n\n\t\t// Shared process raw connections from workbench windows\n\t\tvalidatedIpcMain.on(SharedProcessRawConnection.request, (e, nonce: string) => this.onWindowConnection(e, nonce, SharedProcessRawConnection.response));\n\n\t\t// Lifecycle\n\t\tthis._register(this.lifecycleMainService.onWillShutdown(() => this.onWillShutdown()));\n\t}\n\n\tprivate async onWindowConnection(e: IpcMainEvent, nonce: string, responseChannel: string): Promise<void> {\n\t\tthis.logService.trace(`[SharedProcess] onWindowConnection for: ${responseChannel}`);\n\n\t\t// release barrier if this is the first window connection\n\t\tif (!this.firstWindowConnectionBarrier.isOpen()) {\n\t\t\tthis.firstWindowConnectionBarrier.open();\n\t\t}\n\n\t\t// await the shared process to be overall ready\n\t\t// we do not just wait for IPC ready because the\n\t\t// workbench window will communicate directly\n\n\t\tawait this.whenReady();\n\n\t\t// connect to the shared process passing the responseChannel\n\t\t// as payload to give a hint what the connection is about\n\n\t\tconst port = await this.connect(responseChannel);\n\n\t\t// Check back if the requesting window meanwhile closed\n\t\t// Since shared process is delayed on startup there is\n\t\t// a chance that the window close before the shared process\n\t\t// was ready for a connection.\n\n\t\tif (e.sender.isDestroyed()) {\n\t\t\treturn port.close();\n\t\t}\n\n\t\t// send the port back to the requesting window\n\t\te.sender.postMessage(responseChannel, nonce, [port]);\n\t}\n\n\tprivate onWillShutdown(): void {\n\t\tthis.logService.trace('[SharedProcess] onWillShutdown');\n\n\t\tthis.utilityProcess?.postMessage(SharedProcessLifecycle.exit);\n\t\tthis.utilityProcess = undefined;\n\t}\n\n\tprivate _whenReady: Promise<void> | undefined = undefined;\n\twhenReady(): Promise<void> {\n\t\tif (!this._whenReady) {\n\t\t\tthis._whenReady = (async () => {\n\n\t\t\t\t// Wait for shared process being ready to accept connection\n\t\t\t\tawait this.whenIpcReady;\n\n\t\t\t\t// Overall signal that the shared process was loaded and\n\t\t\t\t// all services within have been created.\n\n\t\t\t\tconst whenReady = new DeferredPromise<void>();\n\t\t\t\tthis.utilityProcess?.once(SharedProcessLifecycle.initDone, () => whenReady.complete());\n\n\t\t\t\tawait whenReady.p;\n\t\t\t\tthis.utilityProcessLogListener?.dispose();\n\t\t\t\tthis.logService.trace('[SharedProcess] Overall ready');\n\t\t\t})();\n\t\t}\n\n\t\treturn this._whenReady;\n\t}\n\n\tprivate _whenIpcReady: Promise<void> | undefined = undefined;\n\tprivate get whenIpcReady() {\n\t\tif (!this._whenIpcReady) {\n\t\t\tthis._whenIpcReady = (async () => {\n\n\t\t\t\t// Always wait for first window asking for connection\n\t\t\t\tawait this.firstWindowConnectionBarrier.wait();\n\n\t\t\t\t// Spawn shared process\n\t\t\t\tthis.createUtilityProcess();\n\n\t\t\t\t// Wait for shared process indicating that IPC connections are accepted\n\t\t\t\tconst sharedProcessIpcReady = new DeferredPromise<void>();\n\t\t\t\tthis.utilityProcess?.once(SharedProcessLifecycle.ipcReady, () => sharedProcessIpcReady.complete());\n\n\t\t\t\tawait sharedProcessIpcReady.p;\n\t\t\t\tthis.logService.trace('[SharedProcess] IPC ready');\n\t\t\t})();\n\t\t}\n\n\t\treturn this._whenIpcReady;\n\t}\n\n\tprivate createUtilityProcess(): void {\n\t\tthis.utilityProcess = this._register(new UtilityProcess(this.logService, NullTelemetryService, this.lifecycleMainService));\n\n\t\t// Install a log listener for very early shared process warnings and errors\n\t\tthis.utilityProcessLogListener = this.utilityProcess.onMessage(e => {\n\t\t\tconst logValue = e as { warning?: unknown; error?: unknown };\n\t\t\tif (typeof logValue.warning === 'string') {\n\t\t\t\tthis.logService.warn(logValue.warning);\n\t\t\t} else if (typeof logValue.error === 'string') {\n\t\t\t\tthis.logService.error(logValue.error);\n\t\t\t}\n\t\t});\n\n\t\tconst inspectParams = parseSharedProcessDebugPort(this.environmentMainService.args, this.environmentMainService.isBuilt);\n\t\tlet execArgv: string[] | undefined = undefined;\n\t\tif (inspectParams.port) {\n\t\t\texecArgv = ['--nolazy', '--experimental-network-inspection'];\n\t\t\tif (inspectParams.break) {\n\t\t\t\texecArgv.push(`--inspect-brk=${inspectParams.port}`);\n\t\t\t} else {\n\t\t\t\texecArgv.push(`--inspect=${inspectParams.port}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.utilityProcess.start({\n\t\t\ttype: 'shared-process',\n\t\t\tname: 'shared-process',\n\t\t\tentryPoint: 'vs/code/electron-utility/sharedProcess/sharedProcessMain',\n\t\t\tpayload: this.createSharedProcessConfiguration(),\n\t\t\trespondToAuthRequestsFromMainProcess: true,\n\t\t\texecArgv\n\t\t});\n\n\t\tthis._register(this.utilityProcess.onCrash(() => this._onDidCrash.fire()));\n\t}\n\n\tprivate createSharedProcessConfiguration(): ISharedProcessConfiguration {\n\t\treturn {\n\t\t\tmachineId: this.machineId,\n\t\t\tsqmId: this.sqmId,\n\t\t\tdevDeviceId: this.devDeviceId,\n\t\t\tcodeCachePath: this.environmentMainService.codeCachePath,\n\t\t\tprofiles: {\n\t\t\t\thome: this.userDataProfilesService.profilesHome,\n\t\t\t\tall: this.userDataProfilesService.profiles,\n\t\t\t},\n\t\t\targs: this.environmentMainService.args,\n\t\t\tlogLevel: this.loggerMainService.getLogLevel(),\n\t\t\tloggers: this.loggerMainService.getGlobalLoggers(),\n\t\t\tpoliciesData: this.policyService.serialize()\n\t\t};\n\t}\n\n\tasync connect(payload?: unknown): Promise<MessagePortMain> {\n\n\t\t// Wait for shared process being ready to accept connection\n\t\tawait this.whenIpcReady;\n\n\t\t// Connect and return message port\n\t\tconst utilityProcess = assertReturnsDefined(this.utilityProcess);\n\t\treturn utilityProcess.connect(payload);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IpcMainEvent, MessagePortMain } from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { Barrier, DeferredPromise } from '../../../base/common/async.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { ILifecycleMainService } from '../../lifecycle/electron-main/lifecycleMainService.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { ISharedProcessConfiguration } from '../node/sharedProcess.js';\nimport { IUserDataProfilesService } from '../../userDataProfile/common/userDataProfile.js';\nimport { IPolicyService } from '../../policy/common/policy.js';\nimport { ILoggerMainService } from '../../log/electron-main/loggerService.js';\nimport { UtilityProcess } from '../../utilityProcess/electron-main/utilityProcess.js';\nimport { NullTelemetryService } from '../../telemetry/common/telemetryUtils.js';\nimport { parseSharedProcessDebugPort } from '../../environment/node/environmentService.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { SharedProcessChannelConnection, SharedProcessRawConnection, SharedProcessLifecycle } from '../common/sharedProcess.js';\nimport { Emitter } from '../../../base/common/event.js';\n\nexport class SharedProcess extends Disposable {\n\n\tprivate readonly firstWindowConnectionBarrier = new Barrier();\n\n\tprivate utilityProcess: UtilityProcess | undefined = undefined;\n\tprivate utilityProcessLogListener: IDisposable | undefined = undefined;\n\n\tprivate readonly _onDidCrash = this._register(new Emitter<void>());\n\treadonly onDidCrash = this._onDidCrash.event;\n\n\tconstructor(\n\t\tprivate readonly machineId: string,\n\t\tprivate readonly sqmId: string,\n\t\tprivate readonly devDeviceId: string,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IUserDataProfilesService private readonly userDataProfilesService: IUserDataProfilesService,\n\t\t@ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@ILoggerMainService private readonly loggerMainService: ILoggerMainService,\n\t\t@IPolicyService private readonly policyService: IPolicyService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Shared process channel connections from workbench windows\n\t\tvalidatedIpcMain.on(SharedProcessChannelConnection.request, (e, nonce: string) => this.onWindowConnection(e, nonce, SharedProcessChannelConnection.response));\n\n\t\t// Shared process raw connections from workbench windows\n\t\tvalidatedIpcMain.on(SharedProcessRawConnection.request, (e, nonce: string) => this.onWindowConnection(e, nonce, SharedProcessRawConnection.response));\n\n\t\t// Lifecycle\n\t\tthis._register(this.lifecycleMainService.onWillShutdown(() => this.onWillShutdown()));\n\t}\n\n\tprivate async onWindowConnection(e: IpcMainEvent, nonce: string, responseChannel: string): Promise<void> {\n\t\tthis.logService.trace(`[SharedProcess] onWindowConnection for: ${responseChannel}`);\n\n\t\t// release barrier if this is the first window connection\n\t\tif (!this.firstWindowConnectionBarrier.isOpen()) {\n\t\t\tthis.firstWindowConnectionBarrier.open();\n\t\t}\n\n\t\t// await the shared process to be overall ready\n\t\t// we do not just wait for IPC ready because the\n\t\t// workbench window will communicate directly\n\n\t\tawait this.whenReady();\n\n\t\t// connect to the shared process passing the responseChannel\n\t\t// as payload to give a hint what the connection is about\n\n\t\tconst port = await this.connect(responseChannel);\n\n\t\t// Check back if the requesting window meanwhile closed\n\t\t// Since shared process is delayed on startup there is\n\t\t// a chance that the window close before the shared process\n\t\t// was ready for a connection.\n\n\t\tif (e.sender.isDestroyed()) {\n\t\t\treturn port.close();\n\t\t}\n\n\t\t// send the port back to the requesting window\n\t\te.sender.postMessage(responseChannel, nonce, [port]);\n\t}\n\n\tprivate onWillShutdown(): void {\n\t\tthis.logService.trace('[SharedProcess] onWillShutdown');\n\n\t\tthis.utilityProcess?.postMessage(SharedProcessLifecycle.exit);\n\t\tthis.utilityProcess = undefined;\n\t}\n\n\tprivate _whenReady: Promise<void> | undefined = undefined;\n\twhenReady(): Promise<void> {\n\t\tif (!this._whenReady) {\n\t\t\tthis._whenReady = (async () => {\n\n\t\t\t\t// Wait for shared process being ready to accept connection\n\t\t\t\tawait this.whenIpcReady;\n\n\t\t\t\t// Overall signal that the shared process was loaded and\n\t\t\t\t// all services within have been created.\n\n\t\t\t\tconst whenReady = new DeferredPromise<void>();\n\t\t\t\tthis.utilityProcess?.once(SharedProcessLifecycle.initDone, () => whenReady.complete());\n\n\t\t\t\tawait whenReady.p;\n\t\t\t\tthis.utilityProcessLogListener?.dispose();\n\t\t\t\tthis.logService.trace('[SharedProcess] Overall ready');\n\t\t\t})();\n\t\t}\n\n\t\treturn this._whenReady;\n\t}\n\n\tprivate _whenIpcReady: Promise<void> | undefined = undefined;\n\tprivate get whenIpcReady() {\n\t\tif (!this._whenIpcReady) {\n\t\t\tthis._whenIpcReady = (async () => {\n\n\t\t\t\t// Always wait for first window asking for connection\n\t\t\t\tawait this.firstWindowConnectionBarrier.wait();\n\n\t\t\t\t// Spawn shared process\n\t\t\t\tthis.createUtilityProcess();\n\n\t\t\t\t// Wait for shared process indicating that IPC connections are accepted\n\t\t\t\tconst sharedProcessIpcReady = new DeferredPromise<void>();\n\t\t\t\tthis.utilityProcess?.once(SharedProcessLifecycle.ipcReady, () => sharedProcessIpcReady.complete());\n\n\t\t\t\tawait sharedProcessIpcReady.p;\n\t\t\t\tthis.logService.trace('[SharedProcess] IPC ready');\n\t\t\t})();\n\t\t}\n\n\t\treturn this._whenIpcReady;\n\t}\n\n\tprivate createUtilityProcess(): void {\n\t\tthis.utilityProcess = this._register(new UtilityProcess(this.logService, NullTelemetryService, this.lifecycleMainService));\n\n\t\t// Install a log listener for very early shared process warnings and errors\n\t\tthis.utilityProcessLogListener = this.utilityProcess.onMessage(e => {\n\t\t\tconst logValue = e as { warning?: unknown; error?: unknown };\n\t\t\tif (typeof logValue.warning === 'string') {\n\t\t\t\tthis.logService.warn(logValue.warning);\n\t\t\t} else if (typeof logValue.error === 'string') {\n\t\t\t\tthis.logService.error(logValue.error);\n\t\t\t}\n\t\t});\n\n\t\tconst inspectParams = parseSharedProcessDebugPort(this.environmentMainService.args, this.environmentMainService.isBuilt);\n\t\tlet execArgv: string[] | undefined = undefined;\n\t\tif (inspectParams.port) {\n\t\t\texecArgv = ['--nolazy', '--experimental-network-inspection'];\n\t\t\tif (inspectParams.break) {\n\t\t\t\texecArgv.push(`--inspect-brk=${inspectParams.port}`);\n\t\t\t} else {\n\t\t\t\texecArgv.push(`--inspect=${inspectParams.port}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.utilityProcess.start({\n\t\t\ttype: 'shared-process',\n\t\t\tname: 'shared-process',\n\t\t\tentryPoint: 'vs/code/electron-utility/sharedProcess/sharedProcessMain',\n\t\t\tpayload: this.createSharedProcessConfiguration(),\n\t\t\trespondToAuthRequestsFromMainProcess: true,\n\t\t\texecArgv\n\t\t});\n\n\t\tthis._register(this.utilityProcess.onCrash(() => this._onDidCrash.fire()));\n\t}\n\n\tprivate createSharedProcessConfiguration(): ISharedProcessConfiguration {\n\t\treturn {\n\t\t\tmachineId: this.machineId,\n\t\t\tsqmId: this.sqmId,\n\t\t\tdevDeviceId: this.devDeviceId,\n\t\t\tcodeCachePath: this.environmentMainService.codeCachePath,\n\t\t\tprofiles: {\n\t\t\t\thome: this.userDataProfilesService.profilesHome,\n\t\t\t\tall: this.userDataProfilesService.profiles,\n\t\t\t},\n\t\t\targs: this.environmentMainService.args,\n\t\t\tlogLevel: this.loggerMainService.getLogLevel(),\n\t\t\tloggers: this.loggerMainService.getGlobalLoggers(),\n\t\t\tpoliciesData: this.policyService.serialize()\n\t\t};\n\t}\n\n\tasync connect(payload?: unknown): Promise<MessagePortMain> {\n\n\t\t// Wait for shared process being ready to accept connection\n\t\tawait this.whenIpcReady;\n\n\t\t// Connect and return message port\n\t\tconst utilityProcess = assertReturnsDefined(this.utilityProcess);\n\t\treturn utilityProcess.connect(payload);\n\t}\n}\n"]}