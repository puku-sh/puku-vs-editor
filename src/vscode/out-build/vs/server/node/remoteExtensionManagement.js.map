{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/server/node/remoteExtensionManagement.ts","vs/server/node/remoteExtensionManagement.ts"],"names":[],"mappings":"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","file":"remoteExtensionManagement.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { PersistentProtocol, ISocket, ProtocolConstants } from '../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../platform/log/common/log.js';\nimport { Emitter, Event } from '../../base/common/event.js';\nimport { VSBuffer } from '../../base/common/buffer.js';\nimport { ProcessTimeRunOnceScheduler } from '../../base/common/async.js';\n\nfunction printTime(ms: number): string {\n\tlet h = 0;\n\tlet m = 0;\n\tlet s = 0;\n\tif (ms >= 1000) {\n\t\ts = Math.floor(ms / 1000);\n\t\tms -= s * 1000;\n\t}\n\tif (s >= 60) {\n\t\tm = Math.floor(s / 60);\n\t\ts -= m * 60;\n\t}\n\tif (m >= 60) {\n\t\th = Math.floor(m / 60);\n\t\tm -= h * 60;\n\t}\n\tconst _h = h ? `${h}h` : ``;\n\tconst _m = m ? `${m}m` : ``;\n\tconst _s = s ? `${s}s` : ``;\n\tconst _ms = ms ? `${ms}ms` : ``;\n\treturn `${_h}${_m}${_s}${_ms}`;\n}\n\nexport class ManagementConnection {\n\n\tprivate _onClose = new Emitter<void>();\n\tpublic readonly onClose: Event<void> = this._onClose.event;\n\n\tprivate readonly _reconnectionGraceTime: number;\n\tprivate readonly _reconnectionShortGraceTime: number;\n\tprivate _remoteAddress: string;\n\n\tpublic readonly protocol: PersistentProtocol;\n\tprivate _disposed: boolean;\n\tprivate _disconnectRunner1: ProcessTimeRunOnceScheduler;\n\tprivate _disconnectRunner2: ProcessTimeRunOnceScheduler;\n\n\tconstructor(\n\t\tprivate readonly _logService: ILogService,\n\t\tprivate readonly _reconnectionToken: string,\n\t\tremoteAddress: string,\n\t\tprotocol: PersistentProtocol,\n\t\treconnectionGraceTime: number\n\t) {\n\t\tthis._reconnectionGraceTime = reconnectionGraceTime;\n\t\tconst defaultShortGrace = ProtocolConstants.ReconnectionShortGraceTime;\n\t\tthis._reconnectionShortGraceTime = reconnectionGraceTime > 0 ? Math.min(defaultShortGrace, reconnectionGraceTime) : 0;\n\t\tthis._remoteAddress = remoteAddress;\n\n\t\tthis.protocol = protocol;\n\t\tthis._disposed = false;\n\t\tthis._disconnectRunner1 = new ProcessTimeRunOnceScheduler(() => {\n\t\t\tthis._log(`The reconnection grace time of ${printTime(this._reconnectionGraceTime)} has expired, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t}, this._reconnectionGraceTime);\n\t\tthis._disconnectRunner2 = new ProcessTimeRunOnceScheduler(() => {\n\t\t\tthis._log(`The reconnection short grace time of ${printTime(this._reconnectionShortGraceTime)} has expired, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t}, this._reconnectionShortGraceTime);\n\n\t\tthis.protocol.onDidDispose(() => {\n\t\t\tthis._log(`The client has disconnected gracefully, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t});\n\t\tthis.protocol.onSocketClose(() => {\n\t\t\tthis._log(`The client has disconnected, will wait for reconnection ${printTime(this._reconnectionGraceTime)} before disposing...`);\n\t\t\t// The socket has closed, let's give the renderer a certain amount of time to reconnect\n\t\t\tthis._disconnectRunner1.schedule();\n\t\t});\n\n\t\tthis._log(`New connection established.`);\n\t}\n\n\tprivate _log(_str: string): void {\n\t\tthis._logService.info(`[${this._remoteAddress}][${this._reconnectionToken.substr(0, 8)}][ManagementConnection] ${_str}`);\n\t}\n\n\tpublic shortenReconnectionGraceTimeIfNecessary(): void {\n\t\tif (this._disconnectRunner2.isScheduled()) {\n\t\t\t// we are disconnected and already running the short reconnection timer\n\t\t\treturn;\n\t\t}\n\t\tif (this._disconnectRunner1.isScheduled()) {\n\t\t\tthis._log(`Another client has connected, will shorten the wait for reconnection ${printTime(this._reconnectionShortGraceTime)} before disposing...`);\n\t\t\t// we are disconnected and running the long reconnection timer\n\t\t\tthis._disconnectRunner2.schedule();\n\t\t}\n\t}\n\n\tprivate _cleanResources(): void {\n\t\tif (this._disposed) {\n\t\t\t// already called\n\t\t\treturn;\n\t\t}\n\t\tthis._disposed = true;\n\t\tthis._disconnectRunner1.dispose();\n\t\tthis._disconnectRunner2.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t\tthis._onClose.fire(undefined);\n\t}\n\n\tpublic acceptReconnection(remoteAddress: string, socket: ISocket, initialDataChunk: VSBuffer): void {\n\t\tthis._remoteAddress = remoteAddress;\n\t\tthis._log(`The client has reconnected.`);\n\t\tthis._disconnectRunner1.cancel();\n\t\tthis._disconnectRunner2.cancel();\n\t\tthis.protocol.beginAcceptReconnection(socket, initialDataChunk);\n\t\tthis.protocol.endAcceptReconnection();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { PersistentProtocol, ISocket, ProtocolConstants } from '../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../platform/log/common/log.js';\nimport { Emitter, Event } from '../../base/common/event.js';\nimport { VSBuffer } from '../../base/common/buffer.js';\nimport { ProcessTimeRunOnceScheduler } from '../../base/common/async.js';\n\nfunction printTime(ms: number): string {\n\tlet h = 0;\n\tlet m = 0;\n\tlet s = 0;\n\tif (ms >= 1000) {\n\t\ts = Math.floor(ms / 1000);\n\t\tms -= s * 1000;\n\t}\n\tif (s >= 60) {\n\t\tm = Math.floor(s / 60);\n\t\ts -= m * 60;\n\t}\n\tif (m >= 60) {\n\t\th = Math.floor(m / 60);\n\t\tm -= h * 60;\n\t}\n\tconst _h = h ? `${h}h` : ``;\n\tconst _m = m ? `${m}m` : ``;\n\tconst _s = s ? `${s}s` : ``;\n\tconst _ms = ms ? `${ms}ms` : ``;\n\treturn `${_h}${_m}${_s}${_ms}`;\n}\n\nexport class ManagementConnection {\n\n\tprivate _onClose = new Emitter<void>();\n\tpublic readonly onClose: Event<void> = this._onClose.event;\n\n\tprivate readonly _reconnectionGraceTime: number;\n\tprivate readonly _reconnectionShortGraceTime: number;\n\tprivate _remoteAddress: string;\n\n\tpublic readonly protocol: PersistentProtocol;\n\tprivate _disposed: boolean;\n\tprivate _disconnectRunner1: ProcessTimeRunOnceScheduler;\n\tprivate _disconnectRunner2: ProcessTimeRunOnceScheduler;\n\n\tconstructor(\n\t\tprivate readonly _logService: ILogService,\n\t\tprivate readonly _reconnectionToken: string,\n\t\tremoteAddress: string,\n\t\tprotocol: PersistentProtocol,\n\t\treconnectionGraceTime: number\n\t) {\n\t\tthis._reconnectionGraceTime = reconnectionGraceTime;\n\t\tconst defaultShortGrace = ProtocolConstants.ReconnectionShortGraceTime;\n\t\tthis._reconnectionShortGraceTime = reconnectionGraceTime > 0 ? Math.min(defaultShortGrace, reconnectionGraceTime) : 0;\n\t\tthis._remoteAddress = remoteAddress;\n\n\t\tthis.protocol = protocol;\n\t\tthis._disposed = false;\n\t\tthis._disconnectRunner1 = new ProcessTimeRunOnceScheduler(() => {\n\t\t\tthis._log(`The reconnection grace time of ${printTime(this._reconnectionGraceTime)} has expired, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t}, this._reconnectionGraceTime);\n\t\tthis._disconnectRunner2 = new ProcessTimeRunOnceScheduler(() => {\n\t\t\tthis._log(`The reconnection short grace time of ${printTime(this._reconnectionShortGraceTime)} has expired, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t}, this._reconnectionShortGraceTime);\n\n\t\tthis.protocol.onDidDispose(() => {\n\t\t\tthis._log(`The client has disconnected gracefully, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t});\n\t\tthis.protocol.onSocketClose(() => {\n\t\t\tthis._log(`The client has disconnected, will wait for reconnection ${printTime(this._reconnectionGraceTime)} before disposing...`);\n\t\t\t// The socket has closed, let's give the renderer a certain amount of time to reconnect\n\t\t\tthis._disconnectRunner1.schedule();\n\t\t});\n\n\t\tthis._log(`New connection established.`);\n\t}\n\n\tprivate _log(_str: string): void {\n\t\tthis._logService.info(`[${this._remoteAddress}][${this._reconnectionToken.substr(0, 8)}][ManagementConnection] ${_str}`);\n\t}\n\n\tpublic shortenReconnectionGraceTimeIfNecessary(): void {\n\t\tif (this._disconnectRunner2.isScheduled()) {\n\t\t\t// we are disconnected and already running the short reconnection timer\n\t\t\treturn;\n\t\t}\n\t\tif (this._disconnectRunner1.isScheduled()) {\n\t\t\tthis._log(`Another client has connected, will shorten the wait for reconnection ${printTime(this._reconnectionShortGraceTime)} before disposing...`);\n\t\t\t// we are disconnected and running the long reconnection timer\n\t\t\tthis._disconnectRunner2.schedule();\n\t\t}\n\t}\n\n\tprivate _cleanResources(): void {\n\t\tif (this._disposed) {\n\t\t\t// already called\n\t\t\treturn;\n\t\t}\n\t\tthis._disposed = true;\n\t\tthis._disconnectRunner1.dispose();\n\t\tthis._disconnectRunner2.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t\tthis._onClose.fire(undefined);\n\t}\n\n\tpublic acceptReconnection(remoteAddress: string, socket: ISocket, initialDataChunk: VSBuffer): void {\n\t\tthis._remoteAddress = remoteAddress;\n\t\tthis._log(`The client has reconnected.`);\n\t\tthis._disconnectRunner1.cancel();\n\t\tthis._disconnectRunner2.cancel();\n\t\tthis.protocol.beginAcceptReconnection(socket, initialDataChunk);\n\t\tthis.protocol.endAcceptReconnection();\n\t}\n}\n"]}