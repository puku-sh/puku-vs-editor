{"version":3,"sources":["../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/nls.messages.ts","../vs/nls.messages.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/nls.ts","../vs/nls.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/platform.ts","../vs/base/common/platform.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/process.ts","../vs/base/common/process.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/path.ts","../vs/base/common/path.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/collections.ts","../vs/base/common/collections.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/errors.ts","../vs/base/common/errors.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/functional.ts","../vs/base/common/functional.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/arraysFind.ts","../vs/base/common/arraysFind.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/arrays.ts","../vs/base/common/arrays.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/map.ts","../vs/base/common/map.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/assert.ts","../vs/base/common/assert.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/types.ts","../vs/base/common/types.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/iterator.ts","../vs/base/common/iterator.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/lifecycle.ts","../vs/base/common/lifecycle.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/linkedList.ts","../vs/base/common/linkedList.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/stopwatch.ts","../vs/base/common/stopwatch.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/event.ts","../vs/base/common/event.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/cancellation.ts","../vs/base/common/cancellation.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/cache.ts","../vs/base/common/cache.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/lazy.ts","../vs/base/common/lazy.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/strings.ts","../vs/base/common/strings.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/extpath.ts","../vs/base/common/extpath.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/uri.ts","../vs/base/common/uri.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/network.ts","../vs/base/common/network.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/resources.ts","../vs/base/common/resources.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/symbols.ts","../vs/base/common/symbols.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/async.ts","../vs/base/common/async.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/normalization.ts","../vs/base/common/normalization.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/pfs.ts","../vs/base/node/pfs.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/ports.ts","../vs/base/common/ports.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/ports.ts","../vs/base/node/ports.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/glob.ts","../vs/base/common/glob.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/ternarySearchTree.ts","../vs/base/common/ternarySearchTree.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/instantiation/common/instantiation.ts","../vs/platform/instantiation/common/instantiation.ts","../vs/platform/files/common/files.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/common/watcher.ts","../vs/platform/files/common/watcher.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.ts","../vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.ts","../node_modules/minimist/index.js","../vs/platform/environment/node/argv.ts","../vs/platform/environment/node/argvHelper.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/terminalEncoding.ts","../vs/base/node/terminalEncoding.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/environment/node/stdin.ts","../vs/platform/environment/node/stdin.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/environment/node/wait.ts","../vs/platform/environment/node/wait.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/product/common/product.ts","../vs/platform/product/common/product.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/profiling/common/profiling.ts","../vs/platform/profiling/common/profiling.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/unc.ts","../vs/base/node/unc.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/code/node/cli.ts","../vs/code/node/cli.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/bootstrap-cli.ts","../bootstrap-cli.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/bootstrap-node.ts","../bootstrap-node.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/bootstrap-esm.ts","../bootstrap-esm.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/bootstrap-meta.ts","../bootstrap-meta.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/performance.ts","../vs/base/common/performance.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/nls.ts","../vs/base/node/nls.ts","../file:/Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/cli.ts","../cli.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n * This module exists so that the AMD build of the monaco editor can replace this with an async loader plugin.\n * If you add new functions to this module make sure that they are also provided in the AMD build of the monaco editor.\n *\n * TODO@esm remove me once we no longer ship an AMD build.\n */\n\nexport function getNLSMessages(): string[] {\n\treturn globalThis._VSCODE_NLS_MESSAGES;\n}\n\nexport function getNLSLanguage(): string | undefined {\n\treturn globalThis._VSCODE_NLS_LANGUAGE;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n * This module exists so that the AMD build of the monaco editor can replace this with an async loader plugin.\n * If you add new functions to this module make sure that they are also provided in the AMD build of the monaco editor.\n *\n * TODO@esm remove me once we no longer ship an AMD build.\n */\n\nexport function getNLSMessages(): string[] {\n\treturn globalThis._VSCODE_NLS_MESSAGES;\n}\n\nexport function getNLSLanguage(): string | undefined {\n\treturn globalThis._VSCODE_NLS_LANGUAGE;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// eslint-disable-next-line local/code-import-patterns\nimport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n// eslint-disable-next-line local/code-import-patterns\nexport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n\ndeclare const document: { location?: { hash?: string } } | undefined;\nconst isPseudo = getNLSLanguage() === 'pseudo' || (typeof document !== 'undefined' && document.location && typeof document.location.hash === 'string' && document.location.hash.indexOf('pseudo=true') >= 0);\n\nexport interface ILocalizeInfo {\n\tkey: string;\n\tcomment: string[];\n}\n\nexport interface ILocalizedString {\n\toriginal: string;\n\tvalue: string;\n}\n\nfunction _format(message: string, args: (string | number | boolean | undefined | null)[]): string {\n\tlet result: string;\n\n\tif (args.length === 0) {\n\t\tresult = message;\n\t} else {\n\t\tresult = message.replace(/\\{(\\d+)\\}/g, (match, rest) => {\n\t\t\tconst index = rest[0];\n\t\t\tconst arg = args[index];\n\t\t\tlet result = match;\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tresult = arg;\n\t\t\t} else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\n\t\t\t\tresult = String(arg);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tif (isPseudo) {\n\t\t// FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n\t\tresult = '\\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n\t}\n\n\treturn result;\n}\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example For example, `localize('sayHello', 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * @skipMangle\n */\nexport function localize(data: ILocalizeInfo | string /* | number when built */, message: string /* | null when built */, ...args: (string | number | boolean | undefined | null)[]): string {\n\tif (typeof data === 'number') {\n\t\treturn _format(lookupMessage(data, message), args);\n\t}\n\treturn _format(message, args);\n}\n\n/**\n * Only used when built: Looks up the message in the global NLS table.\n * This table is being made available as a global through bootstrapping\n * depending on the target context.\n */\nfunction lookupMessage(index: number, fallback: string | null): string {\n\tconst message = getNLSMessages()?.[index];\n\tif (typeof message !== 'string') {\n\t\tif (typeof fallback === 'string') {\n\t\t\treturn fallback;\n\t\t}\n\t\tthrow new Error(`!!! NLS MISSING: ${index} !!!`);\n\t}\n\treturn message;\n}\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize2({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize('sayHello', 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * @skipMangle\n */\nexport function localize2(data: ILocalizeInfo | string /* | number when built */, originalMessage: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString {\n\tlet message: string;\n\tif (typeof data === 'number') {\n\t\tmessage = lookupMessage(data, originalMessage);\n\t} else {\n\t\tmessage = originalMessage;\n\t}\n\n\tconst value = _format(message, args);\n\n\treturn {\n\t\tvalue,\n\t\toriginal: originalMessage === message ? value : _format(originalMessage, args)\n\t};\n}\n\nexport interface INLSLanguagePackConfiguration {\n\n\t/**\n\t * The path to the translations config file that contains pointers to\n\t * all message bundles for `main` and extensions.\n\t */\n\treadonly translationsConfigFile: string;\n\n\t/**\n\t * The path to the file containing the translations for this language\n\t * pack as flat string array.\n\t */\n\treadonly messagesFile: string;\n\n\t/**\n\t * The path to the file that can be used to signal a corrupt language\n\t * pack, for example when reading the `messagesFile` fails. This will\n\t * instruct the application to re-create the cache on next startup.\n\t */\n\treadonly corruptMarkerFile: string;\n}\n\nexport interface INLSConfiguration {\n\n\t/**\n\t * Locale as defined in `argv.json` or `app.getLocale()`.\n\t */\n\treadonly userLocale: string;\n\n\t/**\n\t * Locale as defined by the OS (e.g. `app.getPreferredSystemLanguages()`).\n\t */\n\treadonly osLocale: string;\n\n\t/**\n\t * The actual language of the UI that ends up being used considering `userLocale`\n\t * and `osLocale`.\n\t */\n\treadonly resolvedLanguage: string;\n\n\t/**\n\t * Defined if a language pack is used that is not the\n\t * default english language pack. This requires a language\n\t * pack to be installed as extension.\n\t */\n\treadonly languagePack?: INLSLanguagePackConfiguration;\n\n\t/**\n\t * The path to the file containing the default english messages\n\t * as flat string array. The file is only present in built\n\t * versions of the application.\n\t */\n\treadonly defaultMessagesFile: string;\n\n\t/**\n\t * Below properties are deprecated and only there to continue support\n\t * for `vscode-nls` module that depends on them.\n\t * Refs https://github.com/microsoft/vscode-nls/blob/main/src/node/main.ts#L36-L46\n\t */\n\t/** @deprecated */\n\treadonly locale: string;\n\t/** @deprecated */\n\treadonly availableLanguages: Record<string, string>;\n\t/** @deprecated */\n\treadonly _languagePackSupport?: boolean;\n\t/** @deprecated */\n\treadonly _languagePackId?: string;\n\t/** @deprecated */\n\treadonly _translationsConfigFile?: string;\n\t/** @deprecated */\n\treadonly _cacheRoot?: string;\n\t/** @deprecated */\n\treadonly _resolvedLanguagePackCoreLocation?: string;\n\t/** @deprecated */\n\treadonly _corruptedFile?: string;\n}\n\nexport interface ILanguagePack {\n\treadonly hash: string;\n\treadonly label: string | undefined;\n\treadonly extensions: {\n\t\treadonly extensionIdentifier: { readonly id: string; readonly uuid?: string };\n\t\treadonly version: string;\n\t}[];\n\treadonly translations: Record<string, string | undefined>;\n}\n\nexport type ILanguagePacks = Record<string, ILanguagePack | undefined>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// eslint-disable-next-line local/code-import-patterns\nimport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n// eslint-disable-next-line local/code-import-patterns\nexport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n\ndeclare const document: { location?: { hash?: string } } | undefined;\nconst isPseudo = getNLSLanguage() === 'pseudo' || (typeof document !== 'undefined' && document.location && typeof document.location.hash === 'string' && document.location.hash.indexOf('pseudo=true') >= 0);\n\nexport interface ILocalizeInfo {\n\tkey: string;\n\tcomment: string[];\n}\n\nexport interface ILocalizedString {\n\toriginal: string;\n\tvalue: string;\n}\n\nfunction _format(message: string, args: (string | number | boolean | undefined | null)[]): string {\n\tlet result: string;\n\n\tif (args.length === 0) {\n\t\tresult = message;\n\t} else {\n\t\tresult = message.replace(/\\{(\\d+)\\}/g, (match, rest) => {\n\t\t\tconst index = rest[0];\n\t\t\tconst arg = args[index];\n\t\t\tlet result = match;\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tresult = arg;\n\t\t\t} else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\n\t\t\t\tresult = String(arg);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tif (isPseudo) {\n\t\t// FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n\t\tresult = '\\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n\t}\n\n\treturn result;\n}\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example For example, `localize('sayHello', 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * @skipMangle\n */\nexport function localize(data: ILocalizeInfo | string /* | number when built */, message: string /* | null when built */, ...args: (string | number | boolean | undefined | null)[]): string {\n\tif (typeof data === 'number') {\n\t\treturn _format(lookupMessage(data, message), args);\n\t}\n\treturn _format(message, args);\n}\n\n/**\n * Only used when built: Looks up the message in the global NLS table.\n * This table is being made available as a global through bootstrapping\n * depending on the target context.\n */\nfunction lookupMessage(index: number, fallback: string | null): string {\n\tconst message = getNLSMessages()?.[index];\n\tif (typeof message !== 'string') {\n\t\tif (typeof fallback === 'string') {\n\t\t\treturn fallback;\n\t\t}\n\t\tthrow new Error(`!!! NLS MISSING: ${index} !!!`);\n\t}\n\treturn message;\n}\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize2({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize('sayHello', 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * @skipMangle\n */\nexport function localize2(data: ILocalizeInfo | string /* | number when built */, originalMessage: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString {\n\tlet message: string;\n\tif (typeof data === 'number') {\n\t\tmessage = lookupMessage(data, originalMessage);\n\t} else {\n\t\tmessage = originalMessage;\n\t}\n\n\tconst value = _format(message, args);\n\n\treturn {\n\t\tvalue,\n\t\toriginal: originalMessage === message ? value : _format(originalMessage, args)\n\t};\n}\n\nexport interface INLSLanguagePackConfiguration {\n\n\t/**\n\t * The path to the translations config file that contains pointers to\n\t * all message bundles for `main` and extensions.\n\t */\n\treadonly translationsConfigFile: string;\n\n\t/**\n\t * The path to the file containing the translations for this language\n\t * pack as flat string array.\n\t */\n\treadonly messagesFile: string;\n\n\t/**\n\t * The path to the file that can be used to signal a corrupt language\n\t * pack, for example when reading the `messagesFile` fails. This will\n\t * instruct the application to re-create the cache on next startup.\n\t */\n\treadonly corruptMarkerFile: string;\n}\n\nexport interface INLSConfiguration {\n\n\t/**\n\t * Locale as defined in `argv.json` or `app.getLocale()`.\n\t */\n\treadonly userLocale: string;\n\n\t/**\n\t * Locale as defined by the OS (e.g. `app.getPreferredSystemLanguages()`).\n\t */\n\treadonly osLocale: string;\n\n\t/**\n\t * The actual language of the UI that ends up being used considering `userLocale`\n\t * and `osLocale`.\n\t */\n\treadonly resolvedLanguage: string;\n\n\t/**\n\t * Defined if a language pack is used that is not the\n\t * default english language pack. This requires a language\n\t * pack to be installed as extension.\n\t */\n\treadonly languagePack?: INLSLanguagePackConfiguration;\n\n\t/**\n\t * The path to the file containing the default english messages\n\t * as flat string array. The file is only present in built\n\t * versions of the application.\n\t */\n\treadonly defaultMessagesFile: string;\n\n\t/**\n\t * Below properties are deprecated and only there to continue support\n\t * for `vscode-nls` module that depends on them.\n\t * Refs https://github.com/microsoft/vscode-nls/blob/main/src/node/main.ts#L36-L46\n\t */\n\t/** @deprecated */\n\treadonly locale: string;\n\t/** @deprecated */\n\treadonly availableLanguages: Record<string, string>;\n\t/** @deprecated */\n\treadonly _languagePackSupport?: boolean;\n\t/** @deprecated */\n\treadonly _languagePackId?: string;\n\t/** @deprecated */\n\treadonly _translationsConfigFile?: string;\n\t/** @deprecated */\n\treadonly _cacheRoot?: string;\n\t/** @deprecated */\n\treadonly _resolvedLanguagePackCoreLocation?: string;\n\t/** @deprecated */\n\treadonly _corruptedFile?: string;\n}\n\nexport interface ILanguagePack {\n\treadonly hash: string;\n\treadonly label: string | undefined;\n\treadonly extensions: {\n\t\treadonly extensionIdentifier: { readonly id: string; readonly uuid?: string };\n\t\treadonly version: string;\n\t}[];\n\treadonly translations: Record<string, string | undefined>;\n}\n\nexport type ILanguagePacks = Record<string, ILanguagePack | undefined>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../nls.js';\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _isMobile = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _platformLocale: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\nlet _userAgent: string | undefined = undefined;\n\nexport interface IProcessEnvironment {\n\t[key: string]: string | undefined;\n}\n\n/**\n * This interface is intentionally not identical to node.js\n * process because it also works in sandboxed environments\n * where the process object is implemented differently. We\n * define the properties here that we need for `platform`\n * to work and nothing else.\n */\nexport interface INodeProcess {\n\tplatform: string;\n\tarch: string;\n\tenv: IProcessEnvironment;\n\tversions?: {\n\t\tnode?: string;\n\t\telectron?: string;\n\t\tchrome?: string;\n\t};\n\ttype?: string;\n\tcwd: () => string;\n}\n\ndeclare const process: INodeProcess;\n\nconst $globalThis: any = globalThis;\n\nlet nodeProcess: INodeProcess | undefined = undefined;\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\n\t// Native environment (sandboxed)\n\tnodeProcess = $globalThis.vscode.process;\n} else if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\t// Native environment (non-sandboxed)\n\tnodeProcess = process;\n}\n\nconst isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';\nconst isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';\n\ninterface INavigator {\n\tuserAgent: string;\n\tmaxTouchPoints?: number;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\n\n// Native environment\nif (typeof nodeProcess === 'object') {\n\t_isWindows = (nodeProcess.platform === 'win32');\n\t_isMacintosh = (nodeProcess.platform === 'darwin');\n\t_isLinux = (nodeProcess.platform === 'linux');\n\t_isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n\t_isElectron = isElectronProcess;\n\t_isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'] || !!nodeProcess.env['GITHUB_WORKSPACE'];\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: nls.INLSConfiguration = JSON.parse(rawNlsConfig);\n\t\t\t_locale = nlsConfig.userLocale;\n\t\t\t_platformLocale = nlsConfig.osLocale;\n\t\t\t_language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\n// Web environment\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\n\t_userAgent = navigator.userAgent;\n\t_isWindows = _userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n\t_isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n\t_isLinux = _userAgent.indexOf('Linux') >= 0;\n\t_isMobile = _userAgent?.indexOf('Mobi') >= 0;\n\t_isWeb = true;\n\t_language = nls.getNLSLanguage() || LANGUAGE_DEFAULT;\n\t_locale = navigator.language.toLowerCase();\n\t_platformLocale = _locale;\n}\n\n// Unknown environment\nelse {\n\tconsole.error('Unable to resolve platform.');\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport type PlatformName = 'Web' | 'Windows' | 'Mac' | 'Linux';\n\nexport function PlatformToString(platform: Platform): PlatformName {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\nlet _platform: Platform = Platform.Web;\nif (_isMacintosh) {\n\t_platform = Platform.Mac;\n} else if (_isWindows) {\n\t_platform = Platform.Windows;\n} else if (_isLinux) {\n\t_platform = Platform.Linux;\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isLinuxSnap = _isLinuxSnap;\nexport const isNative = _isNative;\nexport const isElectron = _isElectron;\nexport const isWeb = _isWeb;\nexport const isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\nexport const webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;\nexport const isIOS = _isIOS;\nexport const isMobile = _isMobile;\n/**\n * Whether we run inside a CI environment, such as\n * GH actions or Azure Pipelines.\n */\nexport const isCI = _isCI;\nexport const platform = _platform;\nexport const userAgent = _userAgent;\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese or de for German)\n */\nexport const language = _language;\n\nexport namespace Language {\n\n\texport function value(): string {\n\t\treturn language;\n\t}\n\n\texport function isDefaultVariant(): boolean {\n\t\tif (language.length === 2) {\n\t\t\treturn language === 'en';\n\t\t} else if (language.length >= 3) {\n\t\t\treturn language[0] === 'e' && language[1] === 'n' && language[2] === '-';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function isDefault(): boolean {\n\t\treturn language === 'en';\n\t}\n}\n\n/**\n * Desktop: The OS locale or the locale specified by --locale or `argv.json`.\n * Web: matches `platformLocale`.\n *\n * The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * This will always be set to the OS/browser's locale regardless of\n * what was specified otherwise. The format of the string is all\n * lower case (e.g. zh-tw for Traditional Chinese). The UI is not\n * necessarily shown in the provided locale.\n */\nexport const platformLocale = _platformLocale;\n\n/**\n * The translations that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nexport const setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\n\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexport const setTimeout0 = (() => {\n\tif (setTimeout0IsFaster) {\n\t\tinterface IQueueElement {\n\t\t\tid: number;\n\t\t\tcallback: () => void;\n\t\t}\n\t\tconst pending: IQueueElement[] = [];\n\n\t\t$globalThis.addEventListener('message', (e: any) => {\n\t\t\tif (e.data && e.data.vscodeScheduleAsyncWork) {\n\t\t\t\tfor (let i = 0, len = pending.length; i < len; i++) {\n\t\t\t\t\tconst candidate = pending[i];\n\t\t\t\t\tif (candidate.id === e.data.vscodeScheduleAsyncWork) {\n\t\t\t\t\t\tpending.splice(i, 1);\n\t\t\t\t\t\tcandidate.callback();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlet lastId = 0;\n\t\treturn (callback: () => void) => {\n\t\t\tconst myId = ++lastId;\n\t\t\tpending.push({\n\t\t\t\tid: myId,\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t\t$globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n\t\t};\n\t}\n\treturn (callback: () => void) => setTimeout(callback);\n})();\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian(): boolean {\n\tif (!_isLittleEndianComputed) {\n\t\t_isLittleEndianComputed = true;\n\t\tconst test = new Uint8Array(2);\n\t\ttest[0] = 1;\n\t\ttest[1] = 2;\n\t\tconst view = new Uint16Array(test.buffer);\n\t\t_isLittleEndian = (view[0] === (2 << 8) + 1);\n\t}\n\treturn _isLittleEndian;\n}\n\nexport const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nexport const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nexport const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nexport const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nexport const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n\nexport function isBigSurOrNewer(osVersion: string): boolean {\n\treturn parseFloat(osVersion) >= 20;\n}\n\nexport function isTahoeOrNewer(osVersion: string): boolean {\n\treturn parseFloat(osVersion) >= 25;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../nls.js';\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _isMobile = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _platformLocale: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\nlet _userAgent: string | undefined = undefined;\n\nexport interface IProcessEnvironment {\n\t[key: string]: string | undefined;\n}\n\n/**\n * This interface is intentionally not identical to node.js\n * process because it also works in sandboxed environments\n * where the process object is implemented differently. We\n * define the properties here that we need for `platform`\n * to work and nothing else.\n */\nexport interface INodeProcess {\n\tplatform: string;\n\tarch: string;\n\tenv: IProcessEnvironment;\n\tversions?: {\n\t\tnode?: string;\n\t\telectron?: string;\n\t\tchrome?: string;\n\t};\n\ttype?: string;\n\tcwd: () => string;\n}\n\ndeclare const process: INodeProcess;\n\nconst $globalThis: any = globalThis;\n\nlet nodeProcess: INodeProcess | undefined = undefined;\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\n\t// Native environment (sandboxed)\n\tnodeProcess = $globalThis.vscode.process;\n} else if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\t// Native environment (non-sandboxed)\n\tnodeProcess = process;\n}\n\nconst isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';\nconst isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';\n\ninterface INavigator {\n\tuserAgent: string;\n\tmaxTouchPoints?: number;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\n\n// Native environment\nif (typeof nodeProcess === 'object') {\n\t_isWindows = (nodeProcess.platform === 'win32');\n\t_isMacintosh = (nodeProcess.platform === 'darwin');\n\t_isLinux = (nodeProcess.platform === 'linux');\n\t_isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n\t_isElectron = isElectronProcess;\n\t_isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'] || !!nodeProcess.env['GITHUB_WORKSPACE'];\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: nls.INLSConfiguration = JSON.parse(rawNlsConfig);\n\t\t\t_locale = nlsConfig.userLocale;\n\t\t\t_platformLocale = nlsConfig.osLocale;\n\t\t\t_language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\n// Web environment\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\n\t_userAgent = navigator.userAgent;\n\t_isWindows = _userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n\t_isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n\t_isLinux = _userAgent.indexOf('Linux') >= 0;\n\t_isMobile = _userAgent?.indexOf('Mobi') >= 0;\n\t_isWeb = true;\n\t_language = nls.getNLSLanguage() || LANGUAGE_DEFAULT;\n\t_locale = navigator.language.toLowerCase();\n\t_platformLocale = _locale;\n}\n\n// Unknown environment\nelse {\n\tconsole.error('Unable to resolve platform.');\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport type PlatformName = 'Web' | 'Windows' | 'Mac' | 'Linux';\n\nexport function PlatformToString(platform: Platform): PlatformName {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\nlet _platform: Platform = Platform.Web;\nif (_isMacintosh) {\n\t_platform = Platform.Mac;\n} else if (_isWindows) {\n\t_platform = Platform.Windows;\n} else if (_isLinux) {\n\t_platform = Platform.Linux;\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isLinuxSnap = _isLinuxSnap;\nexport const isNative = _isNative;\nexport const isElectron = _isElectron;\nexport const isWeb = _isWeb;\nexport const isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\nexport const webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;\nexport const isIOS = _isIOS;\nexport const isMobile = _isMobile;\n/**\n * Whether we run inside a CI environment, such as\n * GH actions or Azure Pipelines.\n */\nexport const isCI = _isCI;\nexport const platform = _platform;\nexport const userAgent = _userAgent;\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese or de for German)\n */\nexport const language = _language;\n\nexport namespace Language {\n\n\texport function value(): string {\n\t\treturn language;\n\t}\n\n\texport function isDefaultVariant(): boolean {\n\t\tif (language.length === 2) {\n\t\t\treturn language === 'en';\n\t\t} else if (language.length >= 3) {\n\t\t\treturn language[0] === 'e' && language[1] === 'n' && language[2] === '-';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function isDefault(): boolean {\n\t\treturn language === 'en';\n\t}\n}\n\n/**\n * Desktop: The OS locale or the locale specified by --locale or `argv.json`.\n * Web: matches `platformLocale`.\n *\n * The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * This will always be set to the OS/browser's locale regardless of\n * what was specified otherwise. The format of the string is all\n * lower case (e.g. zh-tw for Traditional Chinese). The UI is not\n * necessarily shown in the provided locale.\n */\nexport const platformLocale = _platformLocale;\n\n/**\n * The translations that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nexport const setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\n\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexport const setTimeout0 = (() => {\n\tif (setTimeout0IsFaster) {\n\t\tinterface IQueueElement {\n\t\t\tid: number;\n\t\t\tcallback: () => void;\n\t\t}\n\t\tconst pending: IQueueElement[] = [];\n\n\t\t$globalThis.addEventListener('message', (e: any) => {\n\t\t\tif (e.data && e.data.vscodeScheduleAsyncWork) {\n\t\t\t\tfor (let i = 0, len = pending.length; i < len; i++) {\n\t\t\t\t\tconst candidate = pending[i];\n\t\t\t\t\tif (candidate.id === e.data.vscodeScheduleAsyncWork) {\n\t\t\t\t\t\tpending.splice(i, 1);\n\t\t\t\t\t\tcandidate.callback();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlet lastId = 0;\n\t\treturn (callback: () => void) => {\n\t\t\tconst myId = ++lastId;\n\t\t\tpending.push({\n\t\t\t\tid: myId,\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t\t$globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n\t\t};\n\t}\n\treturn (callback: () => void) => setTimeout(callback);\n})();\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian(): boolean {\n\tif (!_isLittleEndianComputed) {\n\t\t_isLittleEndianComputed = true;\n\t\tconst test = new Uint8Array(2);\n\t\ttest[0] = 1;\n\t\ttest[1] = 2;\n\t\tconst view = new Uint16Array(test.buffer);\n\t\t_isLittleEndian = (view[0] === (2 << 8) + 1);\n\t}\n\treturn _isLittleEndian;\n}\n\nexport const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nexport const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nexport const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nexport const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nexport const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n\nexport function isBigSurOrNewer(osVersion: string): boolean {\n\treturn parseFloat(osVersion) >= 20;\n}\n\nexport function isTahoeOrNewer(osVersion: string): boolean {\n\treturn parseFloat(osVersion) >= 25;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { INodeProcess, isMacintosh, isWindows } from './platform.js';\n\nlet safeProcess: Omit<INodeProcess, 'arch'> & { arch: string | undefined };\ndeclare const process: INodeProcess;\n\n// Native sandbox environment\nconst vscodeGlobal = (globalThis as { vscode?: { process?: INodeProcess } }).vscode;\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.process !== 'undefined') {\n\tconst sandboxProcess: INodeProcess = vscodeGlobal.process;\n\tsafeProcess = {\n\t\tget platform() { return sandboxProcess.platform; },\n\t\tget arch() { return sandboxProcess.arch; },\n\t\tget env() { return sandboxProcess.env; },\n\t\tcwd() { return sandboxProcess.cwd(); }\n\t};\n}\n\n// Native node.js environment\nelse if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\tsafeProcess = {\n\t\tget platform() { return process.platform; },\n\t\tget arch() { return process.arch; },\n\t\tget env() { return process.env; },\n\t\tcwd() { return process.env['VSCODE_CWD'] || process.cwd(); }\n\t};\n}\n\n// Web environment\nelse {\n\tsafeProcess = {\n\n\t\t// Supported\n\t\tget platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\t\tget arch() { return undefined; /* arch is undefined in web */ },\n\n\t\t// Unsupported\n\t\tget env() { return {}; },\n\t\tcwd() { return '/'; }\n\t};\n}\n\n/**\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `/`.\n *\n * @skipMangle\n */\nexport const cwd = safeProcess.cwd;\n\n/**\n * Provides safe access to the `env` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `{}`.\n */\nexport const env = safeProcess.env;\n\n/**\n * Provides safe access to the `platform` property in node.js, sandboxed or web\n * environments.\n */\nexport const platform = safeProcess.platform;\n\n/**\n * Provides safe access to the `arch` method in node.js, sandboxed or web\n * environments.\n * Note: `arch` is `undefined` in web\n */\nexport const arch = safeProcess.arch;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { INodeProcess, isMacintosh, isWindows } from './platform.js';\n\nlet safeProcess: Omit<INodeProcess, 'arch'> & { arch: string | undefined };\ndeclare const process: INodeProcess;\n\n// Native sandbox environment\nconst vscodeGlobal = (globalThis as { vscode?: { process?: INodeProcess } }).vscode;\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.process !== 'undefined') {\n\tconst sandboxProcess: INodeProcess = vscodeGlobal.process;\n\tsafeProcess = {\n\t\tget platform() { return sandboxProcess.platform; },\n\t\tget arch() { return sandboxProcess.arch; },\n\t\tget env() { return sandboxProcess.env; },\n\t\tcwd() { return sandboxProcess.cwd(); }\n\t};\n}\n\n// Native node.js environment\nelse if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\tsafeProcess = {\n\t\tget platform() { return process.platform; },\n\t\tget arch() { return process.arch; },\n\t\tget env() { return process.env; },\n\t\tcwd() { return process.env['VSCODE_CWD'] || process.cwd(); }\n\t};\n}\n\n// Web environment\nelse {\n\tsafeProcess = {\n\n\t\t// Supported\n\t\tget platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\t\tget arch() { return undefined; /* arch is undefined in web */ },\n\n\t\t// Unsupported\n\t\tget env() { return {}; },\n\t\tcwd() { return '/'; }\n\t};\n}\n\n/**\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `/`.\n *\n * @skipMangle\n */\nexport const cwd = safeProcess.cwd;\n\n/**\n * Provides safe access to the `env` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `{}`.\n */\nexport const env = safeProcess.env;\n\n/**\n * Provides safe access to the `platform` property in node.js, sandboxed or web\n * environments.\n */\nexport const platform = safeProcess.platform;\n\n/**\n * Provides safe access to the `arch` method in node.js, sandboxed or web\n * environments.\n * Note: `arch` is `undefined` in web\n */\nexport const arch = safeProcess.arch;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/commits/v22.15.0/lib/path.js\n// Excluding: the change that adds primordials\n// (https://github.com/nodejs/node/commit/187a862d221dec42fa9a5c4214e7034d9092792f and others)\n// Excluding: the change that adds glob matching\n// (https://github.com/nodejs/node/commit/57b8b8e18e5e2007114c63b71bf0baedc01936a6)\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from './process.js';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: unknown) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateObject(pathObject: object, name: string) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType(name, 'Object', pathObject);\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n\t\t(code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction formatExt(ext: string): string {\n\treturn ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tvalidateObject(pathObject, 'pathObject');\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${formatExt(pathObject.ext)}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, suffix?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\t(path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (!isAbsolute && device === undefined && path.includes(':')) {\n\t\t\t// If the original path was not absolute and if we have not been able to\n\t\t\t// resolve it relative to a particular device, we need to ensure that the\n\t\t\t// `tail` has not become something that Windows might interpret as an\n\t\t\t// absolute path. See CVE-2024-36139.\n\t\t\tif (tail.length >= 2 &&\n\t\t\t\tisWindowsDeviceRoot(tail.charCodeAt(0)) &&\n\t\t\t\ttail.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t}\n\t\t\tlet index = path.indexOf(':');\n\t\t\tdo {\n\t\t\t\tif (index === len - 1 || isPathSeparator(path.charCodeAt(index + 1))) {\n\t\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t\t}\n\t\t\t} while ((index = path.indexOf(':', index + 1)) !== -1);\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\t(len > 2 &&\n\t\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\tisPathSeparator(path.charCodeAt(2)));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for a UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at a UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as a UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (fromOrig.length !== from.length || toOrig.length !== to.length) {\n\t\t\tconst fromSplit = fromOrig.split('\\\\');\n\t\t\tconst toSplit = toOrig.split('\\\\');\n\t\t\tif (fromSplit[fromSplit.length - 1] === '') {\n\t\t\t\tfromSplit.pop();\n\t\t\t}\n\t\t\tif (toSplit[toSplit.length - 1] === '') {\n\t\t\t\ttoSplit.pop();\n\t\t\t}\n\n\t\t\tconst fromLen = fromSplit.length;\n\t\t\tconst toLen = toSplit.length;\n\t\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tif (fromSplit[i].toLowerCase() !== toSplit[i].toLowerCase()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === 0) {\n\t\t\t\treturn toOrig;\n\t\t\t} else if (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\treturn toSplit.slice(i).join('\\\\');\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\treturn '..\\\\'.repeat(fromLen - 1 - i) + '..';\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\treturn '..\\\\'.repeat(fromLen - i) + toSplit.slice(i).join('\\\\');\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string' || path.length === 0) {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn resolvedPath;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nconst posixCwd = (() => {\n\tif (platformIsWin32) {\n\t\t// Converts Windows' backslash path separators to POSIX forward slashes\n\t\t// and truncates any drive indicator\n\t\tconst regexp = /\\\\/g;\n\t\treturn () => {\n\t\t\tconst cwd = process.cwd().replace(regexp, '/');\n\t\t\treturn cwd.slice(cwd.indexOf('/'));\n\t\t};\n\t}\n\n\t// We're already on POSIX, no need for any transformations\n\treturn () => process.cwd();\n})();\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= 0 && !resolvedAbsolute; i--) {\n\t\t\tconst path = pathSegments[i];\n\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (!resolvedAbsolute) {\n\t\t\tconst cwd = posixCwd();\n\t\t\tresolvedPath = `${cwd}/${resolvedPath}`;\n\t\t\tresolvedAbsolute =\n\t\t\t\tcwd.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst path = [];\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tpath.push(arg);\n\t\t\t}\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\treturn posix.normalize(path.join('/'));\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst char = path[i];\n\t\t\tif (char === '/') {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (char === '.') {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (platformIsWin32 ? win32.normalize : posix.normalize);\nexport const isAbsolute = (platformIsWin32 ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (platformIsWin32 ? win32.join : posix.join);\nexport const resolve = (platformIsWin32 ? win32.resolve : posix.resolve);\nexport const relative = (platformIsWin32 ? win32.relative : posix.relative);\nexport const dirname = (platformIsWin32 ? win32.dirname : posix.dirname);\nexport const basename = (platformIsWin32 ? win32.basename : posix.basename);\nexport const extname = (platformIsWin32 ? win32.extname : posix.extname);\nexport const format = (platformIsWin32 ? win32.format : posix.format);\nexport const parse = (platformIsWin32 ? win32.parse : posix.parse);\nexport const toNamespacedPath = (platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (platformIsWin32 ? win32.sep : posix.sep);\nexport const delimiter = (platformIsWin32 ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/commits/v22.15.0/lib/path.js\n// Excluding: the change that adds primordials\n// (https://github.com/nodejs/node/commit/187a862d221dec42fa9a5c4214e7034d9092792f and others)\n// Excluding: the change that adds glob matching\n// (https://github.com/nodejs/node/commit/57b8b8e18e5e2007114c63b71bf0baedc01936a6)\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from './process.js';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: unknown) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateObject(pathObject: object, name: string) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType(name, 'Object', pathObject);\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n\t\t(code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction formatExt(ext: string): string {\n\treturn ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tvalidateObject(pathObject, 'pathObject');\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${formatExt(pathObject.ext)}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, suffix?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\t(path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (!isAbsolute && device === undefined && path.includes(':')) {\n\t\t\t// If the original path was not absolute and if we have not been able to\n\t\t\t// resolve it relative to a particular device, we need to ensure that the\n\t\t\t// `tail` has not become something that Windows might interpret as an\n\t\t\t// absolute path. See CVE-2024-36139.\n\t\t\tif (tail.length >= 2 &&\n\t\t\t\tisWindowsDeviceRoot(tail.charCodeAt(0)) &&\n\t\t\t\ttail.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t}\n\t\t\tlet index = path.indexOf(':');\n\t\t\tdo {\n\t\t\t\tif (index === len - 1 || isPathSeparator(path.charCodeAt(index + 1))) {\n\t\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t\t}\n\t\t\t} while ((index = path.indexOf(':', index + 1)) !== -1);\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\t(len > 2 &&\n\t\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\tisPathSeparator(path.charCodeAt(2)));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for a UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at a UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as a UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (fromOrig.length !== from.length || toOrig.length !== to.length) {\n\t\t\tconst fromSplit = fromOrig.split('\\\\');\n\t\t\tconst toSplit = toOrig.split('\\\\');\n\t\t\tif (fromSplit[fromSplit.length - 1] === '') {\n\t\t\t\tfromSplit.pop();\n\t\t\t}\n\t\t\tif (toSplit[toSplit.length - 1] === '') {\n\t\t\t\ttoSplit.pop();\n\t\t\t}\n\n\t\t\tconst fromLen = fromSplit.length;\n\t\t\tconst toLen = toSplit.length;\n\t\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tif (fromSplit[i].toLowerCase() !== toSplit[i].toLowerCase()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === 0) {\n\t\t\t\treturn toOrig;\n\t\t\t} else if (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\treturn toSplit.slice(i).join('\\\\');\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\treturn '..\\\\'.repeat(fromLen - 1 - i) + '..';\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\treturn '..\\\\'.repeat(fromLen - i) + toSplit.slice(i).join('\\\\');\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string' || path.length === 0) {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn resolvedPath;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nconst posixCwd = (() => {\n\tif (platformIsWin32) {\n\t\t// Converts Windows' backslash path separators to POSIX forward slashes\n\t\t// and truncates any drive indicator\n\t\tconst regexp = /\\\\/g;\n\t\treturn () => {\n\t\t\tconst cwd = process.cwd().replace(regexp, '/');\n\t\t\treturn cwd.slice(cwd.indexOf('/'));\n\t\t};\n\t}\n\n\t// We're already on POSIX, no need for any transformations\n\treturn () => process.cwd();\n})();\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= 0 && !resolvedAbsolute; i--) {\n\t\t\tconst path = pathSegments[i];\n\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (!resolvedAbsolute) {\n\t\t\tconst cwd = posixCwd();\n\t\t\tresolvedPath = `${cwd}/${resolvedPath}`;\n\t\t\tresolvedAbsolute =\n\t\t\t\tcwd.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst path = [];\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tpath.push(arg);\n\t\t\t}\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\treturn posix.normalize(path.join('/'));\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst char = path[i];\n\t\t\tif (char === '/') {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (char === '.') {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (platformIsWin32 ? win32.normalize : posix.normalize);\nexport const isAbsolute = (platformIsWin32 ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (platformIsWin32 ? win32.join : posix.join);\nexport const resolve = (platformIsWin32 ? win32.resolve : posix.resolve);\nexport const relative = (platformIsWin32 ? win32.relative : posix.relative);\nexport const dirname = (platformIsWin32 ? win32.dirname : posix.dirname);\nexport const basename = (platformIsWin32 ? win32.basename : posix.basename);\nexport const extname = (platformIsWin32 ? win32.extname : posix.extname);\nexport const format = (platformIsWin32 ? win32.format : posix.format);\nexport const parse = (platformIsWin32 ? win32.parse : posix.parse);\nexport const toNamespacedPath = (platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (platformIsWin32 ? win32.sep : posix.sep);\nexport const delimiter = (platformIsWin32 ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are strings.\n */\nexport type IStringDictionary<V> = Record<string, V>;\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are numbers.\n */\nexport type INumberDictionary<V> = Record<number, V>;\n\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nexport function groupBy<K extends string | number | symbol, V>(data: readonly V[], groupFn: (element: V) => K): Partial<Record<K, V[]>> {\n\tconst result: Partial<Record<K, V[]>> = Object.create(null);\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result[key];\n\t\tif (!target) {\n\t\t\ttarget = result[key] = [];\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function groupByMap<K, V>(data: V[], groupFn: (element: V) => K): Map<K, V[]> {\n\tconst result = new Map<K, V[]>();\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result.get(key);\n\t\tif (!target) {\n\t\t\ttarget = [];\n\t\t\tresult.set(key, target);\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function diffSets<T>(before: ReadonlySet<T>, after: ReadonlySet<T>): { removed: T[]; added: T[] } {\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\tfor (const element of before) {\n\t\tif (!after.has(element)) {\n\t\t\tremoved.push(element);\n\t\t}\n\t}\n\tfor (const element of after) {\n\t\tif (!before.has(element)) {\n\t\t\tadded.push(element);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\nexport function diffMaps<K, V>(before: Map<K, V>, after: Map<K, V>): { removed: V[]; added: V[] } {\n\tconst removed: V[] = [];\n\tconst added: V[] = [];\n\tfor (const [index, value] of before) {\n\t\tif (!after.has(index)) {\n\t\t\tremoved.push(value);\n\t\t}\n\t}\n\tfor (const [index, value] of after) {\n\t\tif (!before.has(index)) {\n\t\t\tadded.push(value);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nexport function intersection<T>(setA: Set<T>, setB: Iterable<T>): Set<T> {\n\tconst result = new Set<T>();\n\tfor (const elem of setB) {\n\t\tif (setA.has(elem)) {\n\t\t\tresult.add(elem);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class SetWithKey<T> implements Set<T> {\n\tprivate _map = new Map<unknown, T>();\n\n\tconstructor(values: T[], private toKey: (t: T) => unknown) {\n\t\tfor (const value of values) {\n\t\t\tthis.add(value);\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: T): this {\n\t\tconst key = this.toKey(value);\n\t\tthis._map.set(key, value);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\treturn this._map.delete(this.toKey(value));\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this._map.has(this.toKey(value));\n\t}\n\n\t*entries(): IterableIterator<[T, T]> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield [entry, entry];\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield entry;\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tforEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: unknown): void {\n\t\tthis._map.forEach(entry => callbackfn.call(thisArg, entry, entry, this));\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t[Symbol.toStringTag]: string = 'SetWithKey';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are strings.\n */\nexport type IStringDictionary<V> = Record<string, V>;\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are numbers.\n */\nexport type INumberDictionary<V> = Record<number, V>;\n\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nexport function groupBy<K extends string | number | symbol, V>(data: readonly V[], groupFn: (element: V) => K): Partial<Record<K, V[]>> {\n\tconst result: Partial<Record<K, V[]>> = Object.create(null);\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result[key];\n\t\tif (!target) {\n\t\t\ttarget = result[key] = [];\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function groupByMap<K, V>(data: V[], groupFn: (element: V) => K): Map<K, V[]> {\n\tconst result = new Map<K, V[]>();\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result.get(key);\n\t\tif (!target) {\n\t\t\ttarget = [];\n\t\t\tresult.set(key, target);\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function diffSets<T>(before: ReadonlySet<T>, after: ReadonlySet<T>): { removed: T[]; added: T[] } {\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\tfor (const element of before) {\n\t\tif (!after.has(element)) {\n\t\t\tremoved.push(element);\n\t\t}\n\t}\n\tfor (const element of after) {\n\t\tif (!before.has(element)) {\n\t\t\tadded.push(element);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\nexport function diffMaps<K, V>(before: Map<K, V>, after: Map<K, V>): { removed: V[]; added: V[] } {\n\tconst removed: V[] = [];\n\tconst added: V[] = [];\n\tfor (const [index, value] of before) {\n\t\tif (!after.has(index)) {\n\t\t\tremoved.push(value);\n\t\t}\n\t}\n\tfor (const [index, value] of after) {\n\t\tif (!before.has(index)) {\n\t\t\tadded.push(value);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nexport function intersection<T>(setA: Set<T>, setB: Iterable<T>): Set<T> {\n\tconst result = new Set<T>();\n\tfor (const elem of setB) {\n\t\tif (setA.has(elem)) {\n\t\t\tresult.add(elem);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class SetWithKey<T> implements Set<T> {\n\tprivate _map = new Map<unknown, T>();\n\n\tconstructor(values: T[], private toKey: (t: T) => unknown) {\n\t\tfor (const value of values) {\n\t\t\tthis.add(value);\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: T): this {\n\t\tconst key = this.toKey(value);\n\t\tthis._map.set(key, value);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\treturn this._map.delete(this.toKey(value));\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this._map.has(this.toKey(value));\n\t}\n\n\t*entries(): IterableIterator<[T, T]> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield [entry, entry];\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield entry;\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tforEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: unknown): void {\n\t\tthis._map.forEach(entry => callbackfn.call(thisArg, entry, entry, this));\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t[Symbol.toStringTag]: string = 'SetWithKey';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\n/** @skipMangle */\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\n/**\n * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be\n * logged at most once, to avoid a loop.\n *\n * @see https://github.com/microsoft/vscode-remote-release/issues/6481\n */\nexport function isSigPipeError(e: unknown): e is Error {\n\tif (!e || typeof e !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst cast = e as Record<string, string | undefined>;\n\treturn cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';\n}\n\n/**\n * This function should only be called with errors that indicate a bug in the product.\n * E.g. buggy extensions/invalid user-input/network issues should not be able to trigger this code path.\n * If they are, this indicates there is also a bug in the product.\n*/\nexport function onBugIndicatingError(e: any): undefined {\n\terrorHandler.onUnexpectedError(e);\n\treturn undefined;\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n\treadonly noTelemetry: boolean;\n\treadonly code?: string;\n\treadonly cause?: SerializedError;\n}\n\ntype ErrorWithCode = Error & {\n\tcode: string | undefined;\n};\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message, cause } = error;\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error),\n\t\t\tcause: cause ? transformErrorForSerialization(cause) : undefined,\n\t\t\tcode: (<ErrorWithCode>error).code\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\nexport function transformErrorFromSerialization(data: SerializedError): Error {\n\tlet error: Error;\n\tif (data.noTelemetry) {\n\t\terror = new ErrorNoTelemetry();\n\t} else {\n\t\terror = new Error();\n\t\terror.name = data.name;\n\t}\n\terror.message = data.message;\n\terror.stack = data.stack;\n\tif (data.code) {\n\t\t(<ErrorWithCode>error).code = data.code;\n\t}\n\tif (data.cause) {\n\t\terror.cause = transformErrorFromSerialization(data.cause);\n\t}\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): unknown;\n\tgetTypeName(): string | null;\n\tgetFunction(): Function | undefined;\n\tgetFunctionName(): string | null;\n\tgetMethodName(): string | null;\n\tgetFileName(): string | null;\n\tgetLineNumber(): number | null;\n\tgetColumnNumber(): number | null;\n\tgetEvalOrigin(): string | undefined;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nexport const canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\nexport class PendingMigrationError extends Error {\n\n\tprivate static readonly _name = 'PendingMigrationError';\n\n\tstatic is(error: unknown): error is PendingMigrationError {\n\t\treturn error instanceof PendingMigrationError || (error instanceof Error && error.name === PendingMigrationError._name);\n\t}\n\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = PendingMigrationError._name;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport class ReadonlyError extends TypeError {\n\tconstructor(name?: string) {\n\t\tsuper(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');\n\t}\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class ExpectedError extends Error {\n\treadonly isExpected = true;\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'CodeExpectedError';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'CodeExpectedError';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// debugger;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\n/** @skipMangle */\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\n/**\n * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be\n * logged at most once, to avoid a loop.\n *\n * @see https://github.com/microsoft/vscode-remote-release/issues/6481\n */\nexport function isSigPipeError(e: unknown): e is Error {\n\tif (!e || typeof e !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst cast = e as Record<string, string | undefined>;\n\treturn cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';\n}\n\n/**\n * This function should only be called with errors that indicate a bug in the product.\n * E.g. buggy extensions/invalid user-input/network issues should not be able to trigger this code path.\n * If they are, this indicates there is also a bug in the product.\n*/\nexport function onBugIndicatingError(e: any): undefined {\n\terrorHandler.onUnexpectedError(e);\n\treturn undefined;\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n\treadonly noTelemetry: boolean;\n\treadonly code?: string;\n\treadonly cause?: SerializedError;\n}\n\ntype ErrorWithCode = Error & {\n\tcode: string | undefined;\n};\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message, cause } = error;\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error),\n\t\t\tcause: cause ? transformErrorForSerialization(cause) : undefined,\n\t\t\tcode: (<ErrorWithCode>error).code\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\nexport function transformErrorFromSerialization(data: SerializedError): Error {\n\tlet error: Error;\n\tif (data.noTelemetry) {\n\t\terror = new ErrorNoTelemetry();\n\t} else {\n\t\terror = new Error();\n\t\terror.name = data.name;\n\t}\n\terror.message = data.message;\n\terror.stack = data.stack;\n\tif (data.code) {\n\t\t(<ErrorWithCode>error).code = data.code;\n\t}\n\tif (data.cause) {\n\t\terror.cause = transformErrorFromSerialization(data.cause);\n\t}\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): unknown;\n\tgetTypeName(): string | null;\n\tgetFunction(): Function | undefined;\n\tgetFunctionName(): string | null;\n\tgetMethodName(): string | null;\n\tgetFileName(): string | null;\n\tgetLineNumber(): number | null;\n\tgetColumnNumber(): number | null;\n\tgetEvalOrigin(): string | undefined;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nexport const canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\nexport class PendingMigrationError extends Error {\n\n\tprivate static readonly _name = 'PendingMigrationError';\n\n\tstatic is(error: unknown): error is PendingMigrationError {\n\t\treturn error instanceof PendingMigrationError || (error instanceof Error && error.name === PendingMigrationError._name);\n\t}\n\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = PendingMigrationError._name;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport class ReadonlyError extends TypeError {\n\tconstructor(name?: string) {\n\t\tsuper(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');\n\t}\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class ExpectedError extends Error {\n\treadonly isExpected = true;\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'CodeExpectedError';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'CodeExpectedError';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// debugger;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Given a function, returns a function that is only calling that function once.\n */\nexport function createSingleCallFunction<T extends Function>(this: unknown, fn: T, fnDidRunCallback?: () => void): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: unknown;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tif (fnDidRunCallback) {\n\t\t\ttry {\n\t\t\t\tresult = fn.apply(_this, arguments);\n\t\t\t} finally {\n\t\t\t\tfnDidRunCallback();\n\t\t\t}\n\t\t} else {\n\t\t\tresult = fn.apply(_this, arguments);\n\t\t}\n\n\t\treturn result;\n\t} as unknown as T;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Given a function, returns a function that is only calling that function once.\n */\nexport function createSingleCallFunction<T extends Function>(this: unknown, fn: T, fnDidRunCallback?: () => void): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: unknown;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tif (fnDidRunCallback) {\n\t\t\ttry {\n\t\t\t\tresult = fn.apply(_this, arguments);\n\t\t\t} finally {\n\t\t\t\tfnDidRunCallback();\n\t\t\t}\n\t\t} else {\n\t\t\tresult = fn.apply(_this, arguments);\n\t\t}\n\n\t\treturn result;\n\t} as unknown as T;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Comparator } from './arrays.js';\n\nexport function findLast<T, R extends T>(array: readonly T[], predicate: (item: T, index: number) => item is R, fromIndex?: number): R | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex?: number): T | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = array.length - 1): T | undefined {\n\tconst idx = findLastIdx(array, predicate, fromIndex);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findLastIdx<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = array.length - 1): number {\n\tfor (let i = fromIndex; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element, i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function findFirst<T, R extends T>(array: readonly T[], predicate: (item: T, index: number) => item is R, fromIndex?: number): R | undefined;\nexport function findFirst<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex?: number): T | undefined;\nexport function findFirst<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = 0): T | undefined {\n\tconst idx = findFirstIdx(array, predicate, fromIndex);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findFirstIdx<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = 0): number {\n\tfor (let i = fromIndex; i < array.length; i++) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element, i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdxMonotonous(array, predicate);\n\treturn idx === -1 ? undefined : array[idx];\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\ti = k + 1;\n\t\t} else {\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn i - 1;\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n\treturn idx === array.length ? undefined : array[idx];\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\tj = k;\n\t\t} else {\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function findFirstIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n\treturn idx === array.length ? -1 : idx;\n}\n\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray<T> {\n\tpublic static assertInvariants = false;\n\n\tprivate _findLastMonotonousLastIdx = 0;\n\tprivate _prevFindLastPredicate: ((item: T) => boolean) | undefined;\n\n\tconstructor(private readonly _array: readonly T[]) {\n\t}\n\n\t/**\n\t * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n\t * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n\t */\n\tfindLastMonotonous(predicate: (item: T) => boolean): T | undefined {\n\t\tif (MonotonousArray.assertInvariants) {\n\t\t\tif (this._prevFindLastPredicate) {\n\t\t\t\tfor (const item of this._array) {\n\t\t\t\t\tif (this._prevFindLastPredicate(item) && !predicate(item)) {\n\t\t\t\t\t\tthrow new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._prevFindLastPredicate = predicate;\n\t\t}\n\n\t\tconst idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n\t\tthis._findLastMonotonousLastIdx = idx + 1;\n\t\treturn idx === -1 ? undefined : this._array[idx];\n\t}\n}\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findFirstMax(array, (a, b) => -comparator(a, b));\n}\n\nexport function findMaxIdx<T>(array: readonly T[], comparator: Comparator<T>): number {\n\tif (array.length === 0) {\n\t\treturn -1;\n\t}\n\n\tlet maxIdx = 0;\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, array[maxIdx]) > 0) {\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\treturn maxIdx;\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst<T, R>(items: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of items) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Comparator } from './arrays.js';\n\nexport function findLast<T, R extends T>(array: readonly T[], predicate: (item: T, index: number) => item is R, fromIndex?: number): R | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex?: number): T | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = array.length - 1): T | undefined {\n\tconst idx = findLastIdx(array, predicate, fromIndex);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findLastIdx<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = array.length - 1): number {\n\tfor (let i = fromIndex; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element, i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function findFirst<T, R extends T>(array: readonly T[], predicate: (item: T, index: number) => item is R, fromIndex?: number): R | undefined;\nexport function findFirst<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex?: number): T | undefined;\nexport function findFirst<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = 0): T | undefined {\n\tconst idx = findFirstIdx(array, predicate, fromIndex);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findFirstIdx<T>(array: readonly T[], predicate: (item: T, index: number) => unknown, fromIndex = 0): number {\n\tfor (let i = fromIndex; i < array.length; i++) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element, i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdxMonotonous(array, predicate);\n\treturn idx === -1 ? undefined : array[idx];\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\ti = k + 1;\n\t\t} else {\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn i - 1;\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n\treturn idx === array.length ? undefined : array[idx];\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\tj = k;\n\t\t} else {\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function findFirstIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n\treturn idx === array.length ? -1 : idx;\n}\n\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray<T> {\n\tpublic static assertInvariants = false;\n\n\tprivate _findLastMonotonousLastIdx = 0;\n\tprivate _prevFindLastPredicate: ((item: T) => boolean) | undefined;\n\n\tconstructor(private readonly _array: readonly T[]) {\n\t}\n\n\t/**\n\t * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n\t * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n\t */\n\tfindLastMonotonous(predicate: (item: T) => boolean): T | undefined {\n\t\tif (MonotonousArray.assertInvariants) {\n\t\t\tif (this._prevFindLastPredicate) {\n\t\t\t\tfor (const item of this._array) {\n\t\t\t\t\tif (this._prevFindLastPredicate(item) && !predicate(item)) {\n\t\t\t\t\t\tthrow new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._prevFindLastPredicate = predicate;\n\t\t}\n\n\t\tconst idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n\t\tthis._findLastMonotonousLastIdx = idx + 1;\n\t\treturn idx === -1 ? undefined : this._array[idx];\n\t}\n}\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findFirstMax(array, (a, b) => -comparator(a, b));\n}\n\nexport function findMaxIdx<T>(array: readonly T[], comparator: Comparator<T>): number {\n\tif (array.length === 0) {\n\t\treturn -1;\n\t}\n\n\tlet maxIdx = 0;\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, array[maxIdx]) > 0) {\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\treturn maxIdx;\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst<T, R>(items: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of items) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findFirstIdxMonotonousOrArrLen } from './arraysFind.js';\nimport { CancellationToken } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { ISplice } from './sequence.js';\n\n/**\n * Returns the last entry and the initial N-1 entries of the array, as a tuple of [rest, last].\n *\n * The array must have at least one element.\n *\n * @param arr The input array\n * @returns A tuple of [rest, last] where rest is all but the last element and last is the last element\n * @throws Error if the array is empty\n */\nexport function tail<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder<T>(array: T[], index: number) {\n\tconst last = array.length - 1;\n\tif (index < last) {\n\t\tarray[index] = array[last];\n\t}\n\tarray.pop();\n}\n\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\treturn binarySearch2(array.length, i => comparator(array[i], key));\n}\n\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length: number, compareToKey: (index: number) => number): number {\n\tlet low = 0,\n\t\thigh = length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = compareToKey(mid);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n/**\n * Finds the nth smallest element in the array using quickselect algorithm.\n * The data does not need to be sorted.\n *\n * @param nth The zero-based index of the element to find (0 = smallest, 1 = second smallest, etc.)\n * @param data The unsorted array\n * @param compare A comparator function that defines the sort order\n * @returns The nth smallest element\n * @throws TypeError if nth is >= data.length\n */\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tconst pivotValue = data[Math.floor(data.length * Math.random())];\n\tconst lower: T[] = [];\n\tconst higher: T[] = [];\n\tconst pivots: T[] = [];\n\n\tfor (const value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of data.slice(0).sort(compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nexport function* groupAdjacentBy<T>(items: Iterable<T>, shouldBeGrouped: (item1: T, item2: T) => boolean): Iterable<T[]> {\n\tlet currentGroup: T[] | undefined;\n\tlet last: T | undefined;\n\tfor (const item of items) {\n\t\tif (last !== undefined && shouldBeGrouped(last, item)) {\n\t\t\tcurrentGroup!.push(item);\n\t\t} else {\n\t\t\tif (currentGroup) {\n\t\t\t\tyield currentGroup;\n\t\t\t}\n\t\t\tcurrentGroup = [item];\n\t\t}\n\t\tlast = item;\n\t}\n\tif (currentGroup) {\n\t\tyield currentGroup;\n\t}\n}\n\nexport function forEachAdjacent<T>(arr: T[], f: (item1: T | undefined, item2: T | undefined) => void): void {\n\tfor (let i = 0; i <= arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n\t}\n}\n\nexport function forEachWithNeighbors<T>(arr: T[], f: (before: T | undefined, element: T, after: T | undefined) => void): void {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n\t}\n}\n\nexport function concatArrays<T extends any[]>(...arrays: T): T[number][number][] {\n\treturn [].concat(...arrays);\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\treadonly toInsert: T[];\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[]; added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn array.filter((e): e is T => !!e);\n}\n\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): asserts array is Array<T> {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nexport function move(array: unknown[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: unknown): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn: (value: T) => unknown = value => value): T[] {\n\tconst seen = new Set<any>();\n\n\treturn array.filter(element => {\n\t\tconst key = keyFn(element);\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tseen.add(key);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T, R>(keyFn: (t: T) => R): (t: T) => boolean {\n\tconst seen = new Set<R>();\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(key);\n\t\treturn true;\n\t};\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function pushMany<T>(arr: T[], items: ReadonlyArray<T>): void {\n\tfor (const item of items) {\n\t\tarr.push(item);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function mapFilter<T, U>(array: ReadonlyArray<T>, fn: (t: T) => U | undefined): U[] {\n\tconst result: U[] = [];\n\tfor (const item of array) {\n\t\tconst mapped = fn(item);\n\t\tif (mapped !== undefined) {\n\t\t\tresult.push(mapped);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function withoutDuplicates<T>(array: ReadonlyArray<T>): T[] {\n\tconst s = new Set(array);\n\treturn Array.from(s);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto<T>(array: T[], start: number, newItems: T[]): void {\n\tconst startIdx = getActualStartIndex(array, start);\n\tconst originalLength = array.length;\n\tconst newItemsLength = newItems.length;\n\tarray.length = originalLength + newItemsLength;\n\t// Move the items after the start index, start from the end so that we don't overwrite any value.\n\tfor (let i = originalLength - 1; i >= startIdx; i--) {\n\t\tarray[i + newItemsLength] = array[i];\n\t}\n\n\tfor (let i = 0; i < newItemsLength; i++) {\n\t\tarray[i + startIdx] = newItems[i];\n\t}\n}\n\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start: number, deleteCount: number, newItems: T[]): T[] {\n\tconst index = getActualStartIndex(array, start);\n\tlet result = array.splice(index, deleteCount);\n\tif (result === undefined) {\n\t\t// see https://bugs.webkit.org/show_bug.cgi?id=261140\n\t\tresult = [];\n\t}\n\tinsertInto(array, index, newItems);\n\treturn result;\n}\n\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex<T>(array: T[], start: number): number {\n\treturn start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\n\n\n\n/**\n * When comparing two values,\n * a negative number indicates that the first value is less than the second,\n * a positive number indicates that the first value is greater than the second,\n * and zero indicates that neither is the case.\n*/\nexport type CompareResult = number;\n\nexport namespace CompareResult {\n\texport function isLessThan(result: CompareResult): boolean {\n\t\treturn result < 0;\n\t}\n\n\texport function isLessThanOrEqual(result: CompareResult): boolean {\n\t\treturn result <= 0;\n\t}\n\n\texport function isGreaterThan(result: CompareResult): boolean {\n\t\treturn result > 0;\n\t}\n\n\texport function isNeitherLessOrGreaterThan(result: CompareResult): boolean {\n\t\treturn result === 0;\n\t}\n\n\texport const greaterThan = 1;\n\texport const lessThan = -1;\n\texport const neitherLessOrGreaterThan = 0;\n}\n\n/**\n * A comparator `c` defines a total order `<=` on `T` as following:\n * `c(a, b) <= 0` iff `a` <= `b`.\n * We also have `c(a, b) == 0` iff `c(b, a) == 0`.\n*/\nexport type Comparator<T> = (a: T, b: T) => CompareResult;\n\nexport function compareBy<TItem, TCompareBy>(selector: (item: TItem) => TCompareBy, comparator: Comparator<TCompareBy>): Comparator<TItem> {\n\treturn (a, b) => comparator(selector(a), selector(b));\n}\n\nexport function tieBreakComparators<TItem>(...comparators: Comparator<TItem>[]): Comparator<TItem> {\n\treturn (item1, item2) => {\n\t\tfor (const comparator of comparators) {\n\t\t\tconst result = comparator(item1, item2);\n\t\t\tif (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn CompareResult.neitherLessOrGreaterThan;\n\t};\n}\n\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator: Comparator<number> = (a, b) => a - b;\n\nexport const booleanComparator: Comparator<boolean> = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\n\nexport function reverseOrder<TItem>(comparator: Comparator<TItem>): Comparator<TItem> {\n\treturn (a, b) => -comparator(a, b);\n}\n\n/**\n * Returns a new comparator that treats `undefined` as the smallest value.\n * All other values are compared using the given comparator.\n*/\nexport function compareUndefinedSmallest<T>(comparator: Comparator<T>): Comparator<T | undefined> {\n\treturn (a, b) => {\n\t\tif (a === undefined) {\n\t\t\treturn b === undefined ? CompareResult.neitherLessOrGreaterThan : CompareResult.lessThan;\n\t\t} else if (b === undefined) {\n\t\t\treturn CompareResult.greaterThan;\n\t\t}\n\n\t\treturn comparator(a, b);\n\t};\n}\n\nexport class ArrayQueue<T> {\n\tprivate readonly items: readonly T[];\n\tprivate firstIdx = 0;\n\tprivate lastIdx: number;\n\n\t/**\n\t * Constructs a queue that is backed by the given array. Runtime is O(1).\n\t*/\n\tconstructor(items: readonly T[]) {\n\t\tthis.items = items;\n\t\tthis.lastIdx = this.items.length - 1;\n\t}\n\n\tget length(): number {\n\t\treturn this.lastIdx - this.firstIdx + 1;\n\t}\n\n\t/**\n\t * Consumes elements from the beginning of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n\t*/\n\ttakeWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := k <= this.lastIdx && predicate(this.items[k])\n\t\t// Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n\n\t\tlet startIdx = this.firstIdx;\n\t\twhile (startIdx < this.items.length && predicate(this.items[startIdx])) {\n\t\t\tstartIdx++;\n\t\t}\n\t\tconst result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n\t\tthis.firstIdx = startIdx;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Consumes elements from the end of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned.\n\t * The result has the same order as the underlying array!\n\t*/\n\ttakeFromEndWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := this.firstIdx >= k && predicate(this.items[k])\n\t\t// Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n\n\t\tlet endIdx = this.lastIdx;\n\t\twhile (endIdx >= 0 && predicate(this.items[endIdx])) {\n\t\t\tendIdx--;\n\t\t}\n\t\tconst result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n\t\tthis.lastIdx = endIdx;\n\t\treturn result;\n\t}\n\n\tpeek(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.firstIdx];\n\t}\n\n\tpeekLast(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.lastIdx];\n\t}\n\n\tdequeue(): T | undefined {\n\t\tconst result = this.items[this.firstIdx];\n\t\tthis.firstIdx++;\n\t\treturn result;\n\t}\n\n\tremoveLast(): T | undefined {\n\t\tconst result = this.items[this.lastIdx];\n\t\tthis.lastIdx--;\n\t\treturn result;\n\t}\n\n\ttakeCount(count: number): T[] {\n\t\tconst result = this.items.slice(this.firstIdx, this.firstIdx + count);\n\t\tthis.firstIdx += count;\n\t\treturn result;\n\t}\n}\n\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nexport class CallbackIterable<T> {\n\tpublic static readonly empty = new CallbackIterable<never>(_callback => { });\n\n\tconstructor(\n\t\t/**\n\t\t * Calls the callback for every item.\n\t\t * Stops when the callback returns false.\n\t\t*/\n\t\tpublic readonly iterate: (callback: (item: T) => boolean) => void\n\t) {\n\t}\n\n\tforEach(handler: (item: T) => void) {\n\t\tthis.iterate(item => { handler(item); return true; });\n\t}\n\n\ttoArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tthis.iterate(item => { result.push(item); return true; });\n\t\treturn result;\n\t}\n\n\tfilter(predicate: (item: T) => boolean): CallbackIterable<T> {\n\t\treturn new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n\t}\n\n\tmap<TResult>(mapFn: (item: T) => TResult): CallbackIterable<TResult> {\n\t\treturn new CallbackIterable<TResult>(cb => this.iterate(item => cb(mapFn(item))));\n\t}\n\n\tsome(predicate: (item: T) => boolean): boolean {\n\t\tlet result = false;\n\t\tthis.iterate(item => { result = predicate(item); return !result; });\n\t\treturn result;\n\t}\n\n\tfindFirst(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLast(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLastMaxBy(comparator: Comparator<T>): T | undefined {\n\t\tlet result: T | undefined;\n\t\tlet first = true;\n\t\tthis.iterate(item => {\n\t\t\tif (first || CompareResult.isGreaterThan(comparator(item, result!))) {\n\t\t\t\tfirst = false;\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n}\n\n/**\n * Represents a re-arrangement of items in an array.\n */\nexport class Permutation {\n\tconstructor(private readonly _indexMap: readonly number[]) { }\n\n\t/**\n\t * Returns a permutation that sorts the given array according to the given compare function.\n\t */\n\tpublic static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation {\n\t\tconst sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n\t\treturn new Permutation(sortIndices);\n\t}\n\n\t/**\n\t * Returns a new array with the elements of the given array re-arranged according to this permutation.\n\t */\n\tapply<T>(arr: readonly T[]): T[] {\n\t\treturn arr.map((_, index) => arr[this._indexMap[index]]);\n\t}\n\n\t/**\n\t * Returns a new permutation that undoes the re-arrangement of this permutation.\n\t*/\n\tinverse(): Permutation {\n\t\tconst inverseIndexMap = this._indexMap.slice();\n\t\tfor (let i = 0; i < this._indexMap.length; i++) {\n\t\t\tinverseIndexMap[this._indexMap[i]] = i;\n\t\t}\n\t\treturn new Permutation(inverseIndexMap);\n\t}\n}\n\n/**\n * Asynchronous variant of `Array.find()`, returning the first element in\n * the array for which the predicate returns true.\n *\n * This implementation does not bail early and waits for all promises to\n * resolve before returning.\n */\nexport async function findAsync<T>(array: readonly T[], predicate: (element: T, index: number) => Promise<boolean>): Promise<T | undefined> {\n\tconst results = await Promise.all(array.map(\n\t\tasync (element, index) => ({ element, ok: await predicate(element, index) })\n\t));\n\n\treturn results.find(r => r.ok)?.element;\n}\n\nexport function sum(array: readonly number[]): number {\n\treturn array.reduce((acc, value) => acc + value, 0);\n}\n\nexport function sumBy<T>(array: readonly T[], selector: (value: T) => number): number {\n\treturn array.reduce((acc, value) => acc + selector(value), 0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findFirstIdxMonotonousOrArrLen } from './arraysFind.js';\nimport { CancellationToken } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { ISplice } from './sequence.js';\n\n/**\n * Returns the last entry and the initial N-1 entries of the array, as a tuple of [rest, last].\n *\n * The array must have at least one element.\n *\n * @param arr The input array\n * @returns A tuple of [rest, last] where rest is all but the last element and last is the last element\n * @throws Error if the array is empty\n */\nexport function tail<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder<T>(array: T[], index: number) {\n\tconst last = array.length - 1;\n\tif (index < last) {\n\t\tarray[index] = array[last];\n\t}\n\tarray.pop();\n}\n\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\treturn binarySearch2(array.length, i => comparator(array[i], key));\n}\n\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length: number, compareToKey: (index: number) => number): number {\n\tlet low = 0,\n\t\thigh = length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = compareToKey(mid);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n/**\n * Finds the nth smallest element in the array using quickselect algorithm.\n * The data does not need to be sorted.\n *\n * @param nth The zero-based index of the element to find (0 = smallest, 1 = second smallest, etc.)\n * @param data The unsorted array\n * @param compare A comparator function that defines the sort order\n * @returns The nth smallest element\n * @throws TypeError if nth is >= data.length\n */\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tconst pivotValue = data[Math.floor(data.length * Math.random())];\n\tconst lower: T[] = [];\n\tconst higher: T[] = [];\n\tconst pivots: T[] = [];\n\n\tfor (const value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of data.slice(0).sort(compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nexport function* groupAdjacentBy<T>(items: Iterable<T>, shouldBeGrouped: (item1: T, item2: T) => boolean): Iterable<T[]> {\n\tlet currentGroup: T[] | undefined;\n\tlet last: T | undefined;\n\tfor (const item of items) {\n\t\tif (last !== undefined && shouldBeGrouped(last, item)) {\n\t\t\tcurrentGroup!.push(item);\n\t\t} else {\n\t\t\tif (currentGroup) {\n\t\t\t\tyield currentGroup;\n\t\t\t}\n\t\t\tcurrentGroup = [item];\n\t\t}\n\t\tlast = item;\n\t}\n\tif (currentGroup) {\n\t\tyield currentGroup;\n\t}\n}\n\nexport function forEachAdjacent<T>(arr: T[], f: (item1: T | undefined, item2: T | undefined) => void): void {\n\tfor (let i = 0; i <= arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n\t}\n}\n\nexport function forEachWithNeighbors<T>(arr: T[], f: (before: T | undefined, element: T, after: T | undefined) => void): void {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n\t}\n}\n\nexport function concatArrays<T extends any[]>(...arrays: T): T[number][number][] {\n\treturn [].concat(...arrays);\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\treadonly toInsert: T[];\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[]; added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn array.filter((e): e is T => !!e);\n}\n\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): asserts array is Array<T> {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nexport function move(array: unknown[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: unknown): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn: (value: T) => unknown = value => value): T[] {\n\tconst seen = new Set<any>();\n\n\treturn array.filter(element => {\n\t\tconst key = keyFn(element);\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tseen.add(key);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T, R>(keyFn: (t: T) => R): (t: T) => boolean {\n\tconst seen = new Set<R>();\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(key);\n\t\treturn true;\n\t};\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function pushMany<T>(arr: T[], items: ReadonlyArray<T>): void {\n\tfor (const item of items) {\n\t\tarr.push(item);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function mapFilter<T, U>(array: ReadonlyArray<T>, fn: (t: T) => U | undefined): U[] {\n\tconst result: U[] = [];\n\tfor (const item of array) {\n\t\tconst mapped = fn(item);\n\t\tif (mapped !== undefined) {\n\t\t\tresult.push(mapped);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function withoutDuplicates<T>(array: ReadonlyArray<T>): T[] {\n\tconst s = new Set(array);\n\treturn Array.from(s);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto<T>(array: T[], start: number, newItems: T[]): void {\n\tconst startIdx = getActualStartIndex(array, start);\n\tconst originalLength = array.length;\n\tconst newItemsLength = newItems.length;\n\tarray.length = originalLength + newItemsLength;\n\t// Move the items after the start index, start from the end so that we don't overwrite any value.\n\tfor (let i = originalLength - 1; i >= startIdx; i--) {\n\t\tarray[i + newItemsLength] = array[i];\n\t}\n\n\tfor (let i = 0; i < newItemsLength; i++) {\n\t\tarray[i + startIdx] = newItems[i];\n\t}\n}\n\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start: number, deleteCount: number, newItems: T[]): T[] {\n\tconst index = getActualStartIndex(array, start);\n\tlet result = array.splice(index, deleteCount);\n\tif (result === undefined) {\n\t\t// see https://bugs.webkit.org/show_bug.cgi?id=261140\n\t\tresult = [];\n\t}\n\tinsertInto(array, index, newItems);\n\treturn result;\n}\n\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex<T>(array: T[], start: number): number {\n\treturn start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\n\n\n\n/**\n * When comparing two values,\n * a negative number indicates that the first value is less than the second,\n * a positive number indicates that the first value is greater than the second,\n * and zero indicates that neither is the case.\n*/\nexport type CompareResult = number;\n\nexport namespace CompareResult {\n\texport function isLessThan(result: CompareResult): boolean {\n\t\treturn result < 0;\n\t}\n\n\texport function isLessThanOrEqual(result: CompareResult): boolean {\n\t\treturn result <= 0;\n\t}\n\n\texport function isGreaterThan(result: CompareResult): boolean {\n\t\treturn result > 0;\n\t}\n\n\texport function isNeitherLessOrGreaterThan(result: CompareResult): boolean {\n\t\treturn result === 0;\n\t}\n\n\texport const greaterThan = 1;\n\texport const lessThan = -1;\n\texport const neitherLessOrGreaterThan = 0;\n}\n\n/**\n * A comparator `c` defines a total order `<=` on `T` as following:\n * `c(a, b) <= 0` iff `a` <= `b`.\n * We also have `c(a, b) == 0` iff `c(b, a) == 0`.\n*/\nexport type Comparator<T> = (a: T, b: T) => CompareResult;\n\nexport function compareBy<TItem, TCompareBy>(selector: (item: TItem) => TCompareBy, comparator: Comparator<TCompareBy>): Comparator<TItem> {\n\treturn (a, b) => comparator(selector(a), selector(b));\n}\n\nexport function tieBreakComparators<TItem>(...comparators: Comparator<TItem>[]): Comparator<TItem> {\n\treturn (item1, item2) => {\n\t\tfor (const comparator of comparators) {\n\t\t\tconst result = comparator(item1, item2);\n\t\t\tif (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn CompareResult.neitherLessOrGreaterThan;\n\t};\n}\n\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator: Comparator<number> = (a, b) => a - b;\n\nexport const booleanComparator: Comparator<boolean> = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\n\nexport function reverseOrder<TItem>(comparator: Comparator<TItem>): Comparator<TItem> {\n\treturn (a, b) => -comparator(a, b);\n}\n\n/**\n * Returns a new comparator that treats `undefined` as the smallest value.\n * All other values are compared using the given comparator.\n*/\nexport function compareUndefinedSmallest<T>(comparator: Comparator<T>): Comparator<T | undefined> {\n\treturn (a, b) => {\n\t\tif (a === undefined) {\n\t\t\treturn b === undefined ? CompareResult.neitherLessOrGreaterThan : CompareResult.lessThan;\n\t\t} else if (b === undefined) {\n\t\t\treturn CompareResult.greaterThan;\n\t\t}\n\n\t\treturn comparator(a, b);\n\t};\n}\n\nexport class ArrayQueue<T> {\n\tprivate readonly items: readonly T[];\n\tprivate firstIdx = 0;\n\tprivate lastIdx: number;\n\n\t/**\n\t * Constructs a queue that is backed by the given array. Runtime is O(1).\n\t*/\n\tconstructor(items: readonly T[]) {\n\t\tthis.items = items;\n\t\tthis.lastIdx = this.items.length - 1;\n\t}\n\n\tget length(): number {\n\t\treturn this.lastIdx - this.firstIdx + 1;\n\t}\n\n\t/**\n\t * Consumes elements from the beginning of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n\t*/\n\ttakeWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := k <= this.lastIdx && predicate(this.items[k])\n\t\t// Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n\n\t\tlet startIdx = this.firstIdx;\n\t\twhile (startIdx < this.items.length && predicate(this.items[startIdx])) {\n\t\t\tstartIdx++;\n\t\t}\n\t\tconst result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n\t\tthis.firstIdx = startIdx;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Consumes elements from the end of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned.\n\t * The result has the same order as the underlying array!\n\t*/\n\ttakeFromEndWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := this.firstIdx >= k && predicate(this.items[k])\n\t\t// Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n\n\t\tlet endIdx = this.lastIdx;\n\t\twhile (endIdx >= 0 && predicate(this.items[endIdx])) {\n\t\t\tendIdx--;\n\t\t}\n\t\tconst result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n\t\tthis.lastIdx = endIdx;\n\t\treturn result;\n\t}\n\n\tpeek(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.firstIdx];\n\t}\n\n\tpeekLast(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.lastIdx];\n\t}\n\n\tdequeue(): T | undefined {\n\t\tconst result = this.items[this.firstIdx];\n\t\tthis.firstIdx++;\n\t\treturn result;\n\t}\n\n\tremoveLast(): T | undefined {\n\t\tconst result = this.items[this.lastIdx];\n\t\tthis.lastIdx--;\n\t\treturn result;\n\t}\n\n\ttakeCount(count: number): T[] {\n\t\tconst result = this.items.slice(this.firstIdx, this.firstIdx + count);\n\t\tthis.firstIdx += count;\n\t\treturn result;\n\t}\n}\n\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nexport class CallbackIterable<T> {\n\tpublic static readonly empty = new CallbackIterable<never>(_callback => { });\n\n\tconstructor(\n\t\t/**\n\t\t * Calls the callback for every item.\n\t\t * Stops when the callback returns false.\n\t\t*/\n\t\tpublic readonly iterate: (callback: (item: T) => boolean) => void\n\t) {\n\t}\n\n\tforEach(handler: (item: T) => void) {\n\t\tthis.iterate(item => { handler(item); return true; });\n\t}\n\n\ttoArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tthis.iterate(item => { result.push(item); return true; });\n\t\treturn result;\n\t}\n\n\tfilter(predicate: (item: T) => boolean): CallbackIterable<T> {\n\t\treturn new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n\t}\n\n\tmap<TResult>(mapFn: (item: T) => TResult): CallbackIterable<TResult> {\n\t\treturn new CallbackIterable<TResult>(cb => this.iterate(item => cb(mapFn(item))));\n\t}\n\n\tsome(predicate: (item: T) => boolean): boolean {\n\t\tlet result = false;\n\t\tthis.iterate(item => { result = predicate(item); return !result; });\n\t\treturn result;\n\t}\n\n\tfindFirst(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLast(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLastMaxBy(comparator: Comparator<T>): T | undefined {\n\t\tlet result: T | undefined;\n\t\tlet first = true;\n\t\tthis.iterate(item => {\n\t\t\tif (first || CompareResult.isGreaterThan(comparator(item, result!))) {\n\t\t\t\tfirst = false;\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n}\n\n/**\n * Represents a re-arrangement of items in an array.\n */\nexport class Permutation {\n\tconstructor(private readonly _indexMap: readonly number[]) { }\n\n\t/**\n\t * Returns a permutation that sorts the given array according to the given compare function.\n\t */\n\tpublic static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation {\n\t\tconst sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n\t\treturn new Permutation(sortIndices);\n\t}\n\n\t/**\n\t * Returns a new array with the elements of the given array re-arranged according to this permutation.\n\t */\n\tapply<T>(arr: readonly T[]): T[] {\n\t\treturn arr.map((_, index) => arr[this._indexMap[index]]);\n\t}\n\n\t/**\n\t * Returns a new permutation that undoes the re-arrangement of this permutation.\n\t*/\n\tinverse(): Permutation {\n\t\tconst inverseIndexMap = this._indexMap.slice();\n\t\tfor (let i = 0; i < this._indexMap.length; i++) {\n\t\t\tinverseIndexMap[this._indexMap[i]] = i;\n\t\t}\n\t\treturn new Permutation(inverseIndexMap);\n\t}\n}\n\n/**\n * Asynchronous variant of `Array.find()`, returning the first element in\n * the array for which the predicate returns true.\n *\n * This implementation does not bail early and waits for all promises to\n * resolve before returning.\n */\nexport async function findAsync<T>(array: readonly T[], predicate: (element: T, index: number) => Promise<boolean>): Promise<T | undefined> {\n\tconst results = await Promise.all(array.map(\n\t\tasync (element, index) => ({ element, ok: await predicate(element, index) })\n\t));\n\n\treturn results.find(r => r.ok)?.element;\n}\n\nexport function sum(array: readonly number[]): number {\n\treturn array.reduce((acc, value) => acc + value, 0);\n}\n\nexport function sumBy<T>(array: readonly T[], selector: (value: T) => number): number {\n\treturn array.reduce((acc, value) => acc + selector(value), 0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from './uri.js';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nfunction isEntries<T>(arg: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[] | undefined): arg is readonly (readonly [URI, T])[] {\n\treturn Array.isArray(arg);\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(entries?: readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn);\n\n\tconstructor(arg?: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn) {\n\t\tif (arg instanceof ResourceMap) {\n\t\t\tthis.map = new Map(arg.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else if (isEntries(arg)) {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\n\t\t\tfor (const [resource, value] of arg) {\n\t\t\t\tthis.set(resource, value);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = arg ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: object): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: unknown): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: unknown): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprotected trimNew(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._tail;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.previous;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._tail = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.next = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nabstract class Cache<K, V> extends LinkedMap<K, V> {\n\n\tprotected _limit: number;\n\tprotected _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\treturn this;\n\t}\n\n\tprotected checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n\n\tprotected abstract trim(newSize: number): void;\n}\n\nexport class LRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimOld(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n}\n\nexport class MRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimNew(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tif (this._limit <= this.size && !this.has(key)) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio) - 1);\n\t\t}\n\n\t\tsuper.set(key, value);\n\t\treturn this;\n\t}\n}\n\nexport class CounterSet<T> {\n\n\tprivate map = new Map<T, number>();\n\n\tadd(value: T): CounterSet<T> {\n\t\tthis.map.set(value, (this.map.get(value) || 0) + 1);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\tlet counter = this.map.get(value) || 0;\n\n\t\tif (counter === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcounter--;\n\n\t\tif (counter === 0) {\n\t\t\tthis.map.delete(value);\n\t\t} else {\n\t\t\tthis.map.set(value, counter);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this.map.has(value);\n\t}\n}\n\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nexport class BidirectionalMap<K, V> {\n\n\tprivate readonly _m1 = new Map<K, V>();\n\tprivate readonly _m2 = new Map<V, K>();\n\n\tconstructor(entries?: readonly (readonly [K, V])[]) {\n\t\tif (entries) {\n\t\t\tfor (const [key, value] of entries) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._m1.clear();\n\t\tthis._m2.clear();\n\t}\n\n\tset(key: K, value: V): void {\n\t\tthis._m1.set(key, value);\n\t\tthis._m2.set(value, key);\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._m1.get(key);\n\t}\n\n\tgetKey(value: V): K | undefined {\n\t\treturn this._m2.get(value);\n\t}\n\n\tdelete(key: K): boolean {\n\t\tconst value = this._m1.get(key);\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._m1.delete(key);\n\t\tthis._m2.delete(value);\n\t\treturn true;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: BidirectionalMap<K, V>) => void, thisArg?: unknown): void {\n\t\tthis._m1.forEach((value, key) => {\n\t\t\tcallbackfn.call(thisArg, value, key, this);\n\t\t});\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._m1.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._m1.values();\n\t}\n}\n\nexport class SetMap<K, V> {\n\n\tprivate map = new Map<K, Set<V>>();\n\n\tadd(key: K, value: V): void {\n\t\tlet values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\tvalues = new Set<V>();\n\t\t\tthis.map.set(key, values);\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\tdelete(key: K, value: V): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.delete(value);\n\n\t\tif (values.size === 0) {\n\t\t\tthis.map.delete(key);\n\t\t}\n\t}\n\n\tforEach(key: K, fn: (value: V) => void): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.forEach(fn);\n\t}\n\n\tget(key: K): ReadonlySet<V> {\n\t\tconst values = this.map.get(key);\n\t\tif (!values) {\n\t\t\treturn new Set<V>();\n\t\t}\n\t\treturn values;\n\t}\n}\n\nexport function mapsStrictEqualIgnoreOrder(a: Map<unknown, unknown>, b: Map<unknown, unknown>): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.size !== b.size) {\n\t\treturn false;\n\t}\n\n\tfor (const [key, value] of a) {\n\t\tif (!b.has(key) || b.get(key) !== value) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const [key] of b) {\n\t\tif (!a.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * A map that is addressable with an arbitrary number of keys. This is useful in high performance\n * scenarios where creating a composite key whenever the data is accessed is too expensive. For\n * example for a very hot function, constructing a string like `first-second-third` for every call\n * will cause a significant hit to performance.\n */\nexport class NKeyMap<TValue, TKeys extends (string | boolean | number)[]> {\n\tprivate _data: Map<any, any> = new Map();\n\n\t/**\n\t * Sets a value on the map. Note that unlike a standard `Map`, the first argument is the value.\n\t * This is because the spread operator is used for the keys and must be last..\n\t * @param value The value to set.\n\t * @param keys The keys for the value.\n\t */\n\tpublic set(value: TValue, ...keys: [...TKeys]): void {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\tcurrentMap.set(keys[i], new Map());\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\tcurrentMap.set(keys[keys.length - 1], value);\n\t}\n\n\tpublic get(...keys: [...TKeys]): TValue | undefined {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\treturn currentMap.get(keys[keys.length - 1]);\n\t}\n\n\tpublic clear(): void {\n\t\tthis._data.clear();\n\t}\n\n\tpublic *values(): IterableIterator<TValue> {\n\t\tfunction* iterate(map: Map<any, any>): IterableIterator<TValue> {\n\t\t\tfor (const value of map.values()) {\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tyield* iterate(value);\n\t\t\t\t} else {\n\t\t\t\t\tyield value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyield* iterate(this._data);\n\t}\n\n\t/**\n\t * Get a textual representation of the map for debugging purposes.\n\t */\n\tpublic toString(): string {\n\t\tconst printMap = (map: Map<any, any>, depth: number): string => {\n\t\t\tlet result = '';\n\t\t\tfor (const [key, value] of map) {\n\t\t\t\tresult += `${'  '.repeat(depth)}${key}: `;\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tresult += '\\n' + printMap(value, depth + 1);\n\t\t\t\t} else {\n\t\t\t\t\tresult += `${value}\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\treturn printMap(this._data, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from './uri.js';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nfunction isEntries<T>(arg: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[] | undefined): arg is readonly (readonly [URI, T])[] {\n\treturn Array.isArray(arg);\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(entries?: readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn);\n\n\tconstructor(arg?: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn) {\n\t\tif (arg instanceof ResourceMap) {\n\t\t\tthis.map = new Map(arg.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else if (isEntries(arg)) {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\n\t\t\tfor (const [resource, value] of arg) {\n\t\t\t\tthis.set(resource, value);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = arg ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: object): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: unknown): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: unknown): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprotected trimNew(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._tail;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.previous;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._tail = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.next = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nabstract class Cache<K, V> extends LinkedMap<K, V> {\n\n\tprotected _limit: number;\n\tprotected _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\treturn this;\n\t}\n\n\tprotected checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n\n\tprotected abstract trim(newSize: number): void;\n}\n\nexport class LRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimOld(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n}\n\nexport class MRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimNew(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tif (this._limit <= this.size && !this.has(key)) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio) - 1);\n\t\t}\n\n\t\tsuper.set(key, value);\n\t\treturn this;\n\t}\n}\n\nexport class CounterSet<T> {\n\n\tprivate map = new Map<T, number>();\n\n\tadd(value: T): CounterSet<T> {\n\t\tthis.map.set(value, (this.map.get(value) || 0) + 1);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\tlet counter = this.map.get(value) || 0;\n\n\t\tif (counter === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcounter--;\n\n\t\tif (counter === 0) {\n\t\t\tthis.map.delete(value);\n\t\t} else {\n\t\t\tthis.map.set(value, counter);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this.map.has(value);\n\t}\n}\n\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nexport class BidirectionalMap<K, V> {\n\n\tprivate readonly _m1 = new Map<K, V>();\n\tprivate readonly _m2 = new Map<V, K>();\n\n\tconstructor(entries?: readonly (readonly [K, V])[]) {\n\t\tif (entries) {\n\t\t\tfor (const [key, value] of entries) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._m1.clear();\n\t\tthis._m2.clear();\n\t}\n\n\tset(key: K, value: V): void {\n\t\tthis._m1.set(key, value);\n\t\tthis._m2.set(value, key);\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._m1.get(key);\n\t}\n\n\tgetKey(value: V): K | undefined {\n\t\treturn this._m2.get(value);\n\t}\n\n\tdelete(key: K): boolean {\n\t\tconst value = this._m1.get(key);\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._m1.delete(key);\n\t\tthis._m2.delete(value);\n\t\treturn true;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: BidirectionalMap<K, V>) => void, thisArg?: unknown): void {\n\t\tthis._m1.forEach((value, key) => {\n\t\t\tcallbackfn.call(thisArg, value, key, this);\n\t\t});\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._m1.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._m1.values();\n\t}\n}\n\nexport class SetMap<K, V> {\n\n\tprivate map = new Map<K, Set<V>>();\n\n\tadd(key: K, value: V): void {\n\t\tlet values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\tvalues = new Set<V>();\n\t\t\tthis.map.set(key, values);\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\tdelete(key: K, value: V): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.delete(value);\n\n\t\tif (values.size === 0) {\n\t\t\tthis.map.delete(key);\n\t\t}\n\t}\n\n\tforEach(key: K, fn: (value: V) => void): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.forEach(fn);\n\t}\n\n\tget(key: K): ReadonlySet<V> {\n\t\tconst values = this.map.get(key);\n\t\tif (!values) {\n\t\t\treturn new Set<V>();\n\t\t}\n\t\treturn values;\n\t}\n}\n\nexport function mapsStrictEqualIgnoreOrder(a: Map<unknown, unknown>, b: Map<unknown, unknown>): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.size !== b.size) {\n\t\treturn false;\n\t}\n\n\tfor (const [key, value] of a) {\n\t\tif (!b.has(key) || b.get(key) !== value) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const [key] of b) {\n\t\tif (!a.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * A map that is addressable with an arbitrary number of keys. This is useful in high performance\n * scenarios where creating a composite key whenever the data is accessed is too expensive. For\n * example for a very hot function, constructing a string like `first-second-third` for every call\n * will cause a significant hit to performance.\n */\nexport class NKeyMap<TValue, TKeys extends (string | boolean | number)[]> {\n\tprivate _data: Map<any, any> = new Map();\n\n\t/**\n\t * Sets a value on the map. Note that unlike a standard `Map`, the first argument is the value.\n\t * This is because the spread operator is used for the keys and must be last..\n\t * @param value The value to set.\n\t * @param keys The keys for the value.\n\t */\n\tpublic set(value: TValue, ...keys: [...TKeys]): void {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\tcurrentMap.set(keys[i], new Map());\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\tcurrentMap.set(keys[keys.length - 1], value);\n\t}\n\n\tpublic get(...keys: [...TKeys]): TValue | undefined {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\treturn currentMap.get(keys[keys.length - 1]);\n\t}\n\n\tpublic clear(): void {\n\t\tthis._data.clear();\n\t}\n\n\tpublic *values(): IterableIterator<TValue> {\n\t\tfunction* iterate(map: Map<any, any>): IterableIterator<TValue> {\n\t\t\tfor (const value of map.values()) {\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tyield* iterate(value);\n\t\t\t\t} else {\n\t\t\t\t\tyield value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyield* iterate(this._data);\n\t}\n\n\t/**\n\t * Get a textual representation of the map for debugging purposes.\n\t */\n\tpublic toString(): string {\n\t\tconst printMap = (map: Map<any, any>, depth: number): string => {\n\t\t\tlet result = '';\n\t\t\tfor (const [key, value] of map) {\n\t\t\t\tresult += `${'  '.repeat(depth)}${key}: `;\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tresult += '\\n' + printMap(value, depth + 1);\n\t\t\t\t} else {\n\t\t\t\t\tresult += `${value}\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\treturn printMap(this._data, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n\t}\n}\n\nexport function assertNever(value: never, message = 'Unreachable'): never {\n\tthrow new Error(message);\n}\n\nexport function softAssertNever(value: never): void {\n\t// no-op\n}\n\n/**\n * Asserts that a condition is `truthy`.\n *\n * @throws provided {@linkcode messageOrError} if the {@linkcode condition} is `falsy`.\n *\n * @param condition The condition to assert.\n * @param messageOrError An error message or error object to throw if condition is `falsy`.\n */\nexport function assert(\n\tcondition: boolean,\n\tmessageOrError: string | Error = 'unexpected state',\n): asserts condition {\n\tif (!condition) {\n\t\t// if error instance is provided, use it, otherwise create a new one\n\t\tconst errorToThrow = typeof messageOrError === 'string'\n\t\t\t? new BugIndicatingError(`Assertion Failed: ${messageOrError}`)\n\t\t\t: messageOrError;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition: boolean, message = 'Soft Assertion Failed'): void {\n\tif (!condition) {\n\t\tonUnexpectedError(new BugIndicatingError(message));\n\t}\n}\n\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition: () => boolean): void {\n\tif (!condition()) {\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t\t// Reevaluate `condition` again to make debugging easier\n\t\tcondition();\n\t\tonUnexpectedError(new BugIndicatingError('Assertion Failed'));\n\t}\n}\n\nexport function checkAdjacentItems<T>(items: readonly T[], predicate: (item1: T, item2: T) => boolean): boolean {\n\tlet i = 0;\n\twhile (i < items.length - 1) {\n\t\tconst a = items[i];\n\t\tconst b = items[i + 1];\n\t\tif (!predicate(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n\t}\n}\n\nexport function assertNever(value: never, message = 'Unreachable'): never {\n\tthrow new Error(message);\n}\n\nexport function softAssertNever(value: never): void {\n\t// no-op\n}\n\n/**\n * Asserts that a condition is `truthy`.\n *\n * @throws provided {@linkcode messageOrError} if the {@linkcode condition} is `falsy`.\n *\n * @param condition The condition to assert.\n * @param messageOrError An error message or error object to throw if condition is `falsy`.\n */\nexport function assert(\n\tcondition: boolean,\n\tmessageOrError: string | Error = 'unexpected state',\n): asserts condition {\n\tif (!condition) {\n\t\t// if error instance is provided, use it, otherwise create a new one\n\t\tconst errorToThrow = typeof messageOrError === 'string'\n\t\t\t? new BugIndicatingError(`Assertion Failed: ${messageOrError}`)\n\t\t\t: messageOrError;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition: boolean, message = 'Soft Assertion Failed'): void {\n\tif (!condition) {\n\t\tonUnexpectedError(new BugIndicatingError(message));\n\t}\n}\n\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition: () => boolean): void {\n\tif (!condition()) {\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t\t// Reevaluate `condition` again to make debugging easier\n\t\tcondition();\n\t\tonUnexpectedError(new BugIndicatingError('Assertion Failed'));\n\t}\n}\n\nexport function checkAdjacentItems<T>(items: readonly T[], predicate: (item1: T, item2: T) => boolean): boolean {\n\tlet i = 0;\n\twhile (i < items.length - 1) {\n\t\tconst a = items[i];\n\t\tconst b = items[i + 1];\n\t\tif (!predicate(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from './assert.js';\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn isArrayOf(value, isString);\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array satisfies the provided type guard.\n */\nexport function isArrayOf<T>(value: unknown, check: (item: unknown) => item is T): value is T[] {\n\treturn Array.isArray(value) && value.every(check);\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isAsyncIterable<T>(obj: unknown): obj is AsyncIterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n *\n * @see {@link assertDefined} for a similar utility that leverages TS assertion functions to narrow down the type of `arg` to be non-nullable.\n */\nexport function assertReturnsDefined<T>(arg: T | null | undefined): NonNullable<T> {\n\tassert(\n\t\targ !== null && arg !== undefined,\n\t\t'Argument is `undefined` or `null`.',\n\t);\n\n\treturn arg;\n}\n\n/**\n * Asserts that a provided `value` is `defined` - not `null` or `undefined`,\n * throwing an error with the provided error or error message, while also\n * narrowing down the type of the `value` to be `NonNullable` using TS\n * assertion functions.\n *\n * @throws if the provided `value` is `null` or `undefined`.\n *\n * ## Examples\n *\n * ```typescript\n * // an assert with an error message\n * assertDefined('some value', 'String constant is not defined o_O.');\n *\n * // `throws!` the provided error\n * assertDefined(null, new Error('Should throw this error.'));\n *\n * // narrows down the type of `someValue` to be non-nullable\n * const someValue: string | undefined | null = blackbox();\n * assertDefined(someValue, 'Some value must be defined.');\n * console.log(someValue.length); // now type of `someValue` is `string`\n * ```\n *\n * @see {@link assertReturnsDefined} for a similar utility but without assertion.\n * @see {@link https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions typescript-3-7.html#assertion-functions}\n */\nexport function assertDefined<T>(value: T, error: string | NonNullable<Error>): asserts value is NonNullable<T> {\n\tif (value === null || value === undefined) {\n\t\tconst errorToThrow = typeof error === 'string' ? new Error(error) : error;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertReturnsAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertReturnsAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertReturnsAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertReturnsAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\n/**\n * Checks if the provided value is one of the vales in the provided list.\n *\n * ## Examples\n *\n * ```typescript\n * // note! item type is a `subset of string`\n * type TItem = ':' | '.' | '/';\n *\n * // note! item is type of `string` here\n * const item: string = ':';\n * // list of the items to check against\n * const list: TItem[] = [':', '.'];\n *\n * // ok\n * assert(\n *   isOneOf(item, list),\n *   'Must succeed.',\n * );\n *\n * // `item` is of `TItem` type now\n * ```\n */\nexport const isOneOf = <TType, TSubtype extends TType>(\n\tvalue: TType,\n\tvalidValues: readonly TSubtype[],\n): value is TSubtype => {\n\t// note! it is OK to type cast here, because we rely on the includes\n\t//       utility to check if the value is present in the provided list\n\treturn validValues.includes(<TSubtype>value);\n};\n\n/**\n * Compile-time type check of a variable.\n */\nexport function typeCheck<T = never>(_thing: NoInfer<T>): void { }\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base = Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = { [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K] };\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P]\n};\n\n/**\n * A type that adds readonly to all properties of T, recursively.\n */\nexport type DeepImmutable<T> = T extends (infer U)[]\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends ReadonlyArray<infer U>\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends Map<infer K, infer V>\n\t? ReadonlyMap<K, DeepImmutable<V>>\n\t: T extends Set<infer U>\n\t? ReadonlySet<DeepImmutable<U>>\n\t: T extends object\n\t? {\n\t\treadonly [K in keyof T]: DeepImmutable<T[K]>;\n\t}\n\t: T;\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n/**\n * Given a `type X = { foo?: string }` checking that an object `satisfies X`\n * will ensure each property was explicitly defined, ensuring no properties\n * are omitted or forgotten.\n */\nexport type WithDefinedProps<T> = { [K in keyof Required<T>]: T[K] };\n\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;\n};\n\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;\n\n\ntype KeysOfUnionType<T> = T extends T ? keyof T : never;\ntype FilterType<T, TTest> = T extends TTest ? T : never;\ntype MakeOptionalAndTrue<T extends object> = { [K in keyof T]?: true };\n\n/**\n * Type guard that checks if an object has specific keys and narrows the type accordingly.\n *\n * @param x - The object to check\n * @param key - An object with boolean values indicating which keys to check for\n * @returns true if all specified keys exist in the object, false otherwise\n *\n * @example\n * ```typescript\n * type A = { a: string };\n * type B = { b: number };\n * const obj: A | B = getObject();\n *\n * if (hasKey(obj, { a: true })) {\n *   // obj is now narrowed to type A\n *   console.log(obj.a);\n * }\n * ```\n */\nexport function hasKey<T extends object, TKeys extends MakeOptionalAndTrue<T>>(x: T, key: TKeys): x is FilterType<T, { [K in KeysOfUnionType<T> & keyof TKeys]: unknown }> {\n\tfor (const k in key) {\n\t\tif (!(k in x)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from './assert.js';\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn isArrayOf(value, isString);\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array satisfies the provided type guard.\n */\nexport function isArrayOf<T>(value: unknown, check: (item: unknown) => item is T): value is T[] {\n\treturn Array.isArray(value) && value.every(check);\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isAsyncIterable<T>(obj: unknown): obj is AsyncIterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n *\n * @see {@link assertDefined} for a similar utility that leverages TS assertion functions to narrow down the type of `arg` to be non-nullable.\n */\nexport function assertReturnsDefined<T>(arg: T | null | undefined): NonNullable<T> {\n\tassert(\n\t\targ !== null && arg !== undefined,\n\t\t'Argument is `undefined` or `null`.',\n\t);\n\n\treturn arg;\n}\n\n/**\n * Asserts that a provided `value` is `defined` - not `null` or `undefined`,\n * throwing an error with the provided error or error message, while also\n * narrowing down the type of the `value` to be `NonNullable` using TS\n * assertion functions.\n *\n * @throws if the provided `value` is `null` or `undefined`.\n *\n * ## Examples\n *\n * ```typescript\n * // an assert with an error message\n * assertDefined('some value', 'String constant is not defined o_O.');\n *\n * // `throws!` the provided error\n * assertDefined(null, new Error('Should throw this error.'));\n *\n * // narrows down the type of `someValue` to be non-nullable\n * const someValue: string | undefined | null = blackbox();\n * assertDefined(someValue, 'Some value must be defined.');\n * console.log(someValue.length); // now type of `someValue` is `string`\n * ```\n *\n * @see {@link assertReturnsDefined} for a similar utility but without assertion.\n * @see {@link https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions typescript-3-7.html#assertion-functions}\n */\nexport function assertDefined<T>(value: T, error: string | NonNullable<Error>): asserts value is NonNullable<T> {\n\tif (value === null || value === undefined) {\n\t\tconst errorToThrow = typeof error === 'string' ? new Error(error) : error;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertReturnsAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertReturnsAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertReturnsAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertReturnsAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\n/**\n * Checks if the provided value is one of the vales in the provided list.\n *\n * ## Examples\n *\n * ```typescript\n * // note! item type is a `subset of string`\n * type TItem = ':' | '.' | '/';\n *\n * // note! item is type of `string` here\n * const item: string = ':';\n * // list of the items to check against\n * const list: TItem[] = [':', '.'];\n *\n * // ok\n * assert(\n *   isOneOf(item, list),\n *   'Must succeed.',\n * );\n *\n * // `item` is of `TItem` type now\n * ```\n */\nexport const isOneOf = <TType, TSubtype extends TType>(\n\tvalue: TType,\n\tvalidValues: readonly TSubtype[],\n): value is TSubtype => {\n\t// note! it is OK to type cast here, because we rely on the includes\n\t//       utility to check if the value is present in the provided list\n\treturn validValues.includes(<TSubtype>value);\n};\n\n/**\n * Compile-time type check of a variable.\n */\nexport function typeCheck<T = never>(_thing: NoInfer<T>): void { }\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base = Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = { [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K] };\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P]\n};\n\n/**\n * A type that adds readonly to all properties of T, recursively.\n */\nexport type DeepImmutable<T> = T extends (infer U)[]\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends ReadonlyArray<infer U>\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends Map<infer K, infer V>\n\t? ReadonlyMap<K, DeepImmutable<V>>\n\t: T extends Set<infer U>\n\t? ReadonlySet<DeepImmutable<U>>\n\t: T extends object\n\t? {\n\t\treadonly [K in keyof T]: DeepImmutable<T[K]>;\n\t}\n\t: T;\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n/**\n * Given a `type X = { foo?: string }` checking that an object `satisfies X`\n * will ensure each property was explicitly defined, ensuring no properties\n * are omitted or forgotten.\n */\nexport type WithDefinedProps<T> = { [K in keyof Required<T>]: T[K] };\n\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;\n};\n\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;\n\n\ntype KeysOfUnionType<T> = T extends T ? keyof T : never;\ntype FilterType<T, TTest> = T extends TTest ? T : never;\ntype MakeOptionalAndTrue<T extends object> = { [K in keyof T]?: true };\n\n/**\n * Type guard that checks if an object has specific keys and narrows the type accordingly.\n *\n * @param x - The object to check\n * @param key - An object with boolean values indicating which keys to check for\n * @returns true if all specified keys exist in the object, false otherwise\n *\n * @example\n * ```typescript\n * type A = { a: string };\n * type B = { b: number };\n * const obj: A | B = getObject();\n *\n * if (hasKey(obj, { a: true })) {\n *   // obj is now narrowed to type A\n *   console.log(obj.a);\n * }\n * ```\n */\nexport function hasKey<T extends object, TKeys extends MakeOptionalAndTrue<T>>(x: T, key: TKeys): x is FilterType<T, { [K in KeysOfUnionType<T> & keyof TKeys]: unknown }> {\n\tfor (const k in key) {\n\t\tif (!(k in x)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isIterable } from './types.js';\n\nexport namespace Iterable {\n\n\texport function is<T = unknown>(thing: unknown): thing is Iterable<T> {\n\t\treturn !!thing && typeof thing === 'object' && typeof (thing as Iterable<T>)[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<never> = Object.freeze([]);\n\texport function empty<T = never>(): Iterable<T> {\n\t\treturn _empty as Iterable<T>;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function wrap<T>(iterableOrElement: Iterable<T> | T): Iterable<T> {\n\t\tif (is(iterableOrElement)) {\n\t\t\treturn iterableOrElement;\n\t\t} else {\n\t\t\treturn single(iterableOrElement);\n\t\t}\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable ?? (_empty as Iterable<T>);\n\t}\n\n\texport function* reverse<T>(array: ReadonlyArray<T>): Iterable<T> {\n\t\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\t\tyield array[i];\n\t\t}\n\t}\n\n\texport function isEmpty<T>(iterable: Iterable<T> | undefined | null): boolean {\n\t\treturn !iterable || iterable[Symbol.iterator]().next().done === true;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element, i++)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function every<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (!predicate(element, i++)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\texport function find<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): R | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\texport function filter<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): Iterable<R>;\n\texport function filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T>;\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => R): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element, index++);\n\t\t}\n\t}\n\n\texport function* flatMap<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => Iterable<R>): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield* fn(element, index++);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: (Iterable<T> | T)[]): Iterable<T> {\n\t\tfor (const item of iterables) {\n\t\t\tif (isIterable(item)) {\n\t\t\t\tyield* item;\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function reduce<T, R>(iterable: Iterable<T>, reducer: (previousValue: R, currentValue: T) => R, initialValue: R): R {\n\t\tlet value = initialValue;\n\t\tfor (const element of iterable) {\n\t\t\tvalue = reducer(value, element);\n\t\t}\n\t\treturn value;\n\t}\n\n\texport function length<T>(iterable: Iterable<T>): number {\n\t\tlet count = 0;\n\t\tfor (const _ of iterable) {\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n\t */\n\texport function* slice<T>(arr: ReadonlyArray<T>, from: number, to = arr.length): Iterable<T> {\n\t\tif (from < -arr.length) {\n\t\t\tfrom = 0;\n\t\t}\n\t\tif (from < 0) {\n\t\t\tfrom += arr.length;\n\t\t}\n\n\t\tif (to < 0) {\n\t\t\tto += arr.length;\n\t\t} else if (to > arr.length) {\n\t\t\tto = arr.length;\n\t\t}\n\n\t\tfor (; from < to; from++) {\n\t\t\tyield arr[from];\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n\n\texport async function asyncToArray<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\texport async function asyncToArrayFlat<T>(iterable: AsyncIterable<T[]>): Promise<T[]> {\n\t\tlet result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult = result.concat(item);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isIterable } from './types.js';\n\nexport namespace Iterable {\n\n\texport function is<T = unknown>(thing: unknown): thing is Iterable<T> {\n\t\treturn !!thing && typeof thing === 'object' && typeof (thing as Iterable<T>)[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<never> = Object.freeze([]);\n\texport function empty<T = never>(): Iterable<T> {\n\t\treturn _empty as Iterable<T>;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function wrap<T>(iterableOrElement: Iterable<T> | T): Iterable<T> {\n\t\tif (is(iterableOrElement)) {\n\t\t\treturn iterableOrElement;\n\t\t} else {\n\t\t\treturn single(iterableOrElement);\n\t\t}\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable ?? (_empty as Iterable<T>);\n\t}\n\n\texport function* reverse<T>(array: ReadonlyArray<T>): Iterable<T> {\n\t\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\t\tyield array[i];\n\t\t}\n\t}\n\n\texport function isEmpty<T>(iterable: Iterable<T> | undefined | null): boolean {\n\t\treturn !iterable || iterable[Symbol.iterator]().next().done === true;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element, i++)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function every<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (!predicate(element, i++)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\texport function find<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): R | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\texport function filter<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): Iterable<R>;\n\texport function filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T>;\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => R): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element, index++);\n\t\t}\n\t}\n\n\texport function* flatMap<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => Iterable<R>): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield* fn(element, index++);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: (Iterable<T> | T)[]): Iterable<T> {\n\t\tfor (const item of iterables) {\n\t\t\tif (isIterable(item)) {\n\t\t\t\tyield* item;\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function reduce<T, R>(iterable: Iterable<T>, reducer: (previousValue: R, currentValue: T) => R, initialValue: R): R {\n\t\tlet value = initialValue;\n\t\tfor (const element of iterable) {\n\t\t\tvalue = reducer(value, element);\n\t\t}\n\t\treturn value;\n\t}\n\n\texport function length<T>(iterable: Iterable<T>): number {\n\t\tlet count = 0;\n\t\tfor (const _ of iterable) {\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n\t */\n\texport function* slice<T>(arr: ReadonlyArray<T>, from: number, to = arr.length): Iterable<T> {\n\t\tif (from < -arr.length) {\n\t\t\tfrom = 0;\n\t\t}\n\t\tif (from < 0) {\n\t\t\tfrom += arr.length;\n\t\t}\n\n\t\tif (to < 0) {\n\t\t\tto += arr.length;\n\t\t} else if (to > arr.length) {\n\t\t\tto = arr.length;\n\t\t}\n\n\t\tfor (; from < to; from++) {\n\t\t\tyield arr[from];\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n\n\texport async function asyncToArray<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\texport async function asyncToArrayFlat<T>(iterable: AsyncIterable<T[]>): Promise<T[]> {\n\t\tlet result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult = result.concat(item);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from './arrays.js';\nimport { groupBy } from './collections.js';\nimport { SetMap } from './map.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport class GCBasedDisposableTracker implements IDisposableTracker {\n\n\tprivate readonly _registry = new FinalizationRegistry<string>(heldValue => {\n\t\tconsole.warn(`[LEAKED DISPOSABLE] ${heldValue}`);\n\t});\n\n\ttrackDisposable(disposable: IDisposable): void {\n\t\tconst stack = new Error('CREATED via:').stack!;\n\t\tthis._registry.register(disposable, stack, disposable);\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tif (parent) {\n\t\t\tthis._registry.unregister(child);\n\t\t} else {\n\t\t\tthis.trackDisposable(child);\n\t\t}\n\t}\n\n\tmarkAsDisposed(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source =\n\t\t\t\tnew Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(data: DisposableInfo, cache: Map<DisposableInfo, DisposableInfo>): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n\t\t\t.flatMap(([k]) => k);\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(maxReported = 10, preComputedLeaks?: DisposableInfo[]): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()]\n\t\t\t\t.filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter(l => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error('There are cyclic diposable chains!');\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(array: string[], linesToRemove: (string | RegExp)[]) {\n\t\t\t\twhile (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking.source!.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n\t\t\tremovePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n\n\t\tlet message = '';\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n\t\t\t\tconst continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tif (set) {\n\t\t\t\t\t\tstackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E>(thing: E): thing is E & IDisposable {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn typeof thing === 'object' && thing !== null && typeof (<IDisposable><any>thing).dispose === 'function' && (<IDisposable><any>thing).dispose.length === 0;\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends Iterable<T> = Iterable<T>>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | Iterable<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(errors, 'Encountered errors while disposing of store');\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(disposables: Array<T>): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\nclass FunctionDisposable implements IDisposable {\n\tprivate _isDisposed: boolean;\n\tprivate readonly _fn: () => void;\n\n\tconstructor(fn: () => void) {\n\t\tthis._isDisposed = false;\n\t\tthis._fn = fn;\n\t\ttrackDisposable(this);\n\t}\n\n\tdispose() {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fn) {\n\t\t\tthrow new Error(`Unbound disposable context: Need to use an arrow function to preserve the value of this`);\n\t\t}\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._fn();\n\t}\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn new FunctionDisposable(fn);\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o || o === Disposable.None) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\t/**\n\t * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n\t * disposable even when the disposable is not part in the store.\n\t */\n\tpublic delete<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot dispose a disposable on itself!');\n\t\t}\n\t\tthis._toDispose.delete(o);\n\t\to.dispose();\n\t}\n\n\t/**\n\t * Deletes the value from the store, but does not dispose it.\n\t */\n\tpublic deleteAndLeak<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._toDispose.has(o)) {\n\t\t\tthis._toDispose.delete(o);\n\t\t\tsetParentOfDisposable(o, null);\n\t\t}\n\t}\n\n\tpublic assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tonUnexpectedError(new BugIndicatingError('Object disposed'));\n\t\t}\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Get the currently held disposable value, or `undefined` if this MutableDisposable has been disposed\n\t */\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\t/**\n\t * Set a new disposable value.\n\t *\n\t * Behaviour:\n\t * - If the MutableDisposable has been disposed, the setter is a no-op.\n\t * - If the new value is strictly equal to the current value, the setter is a no-op.\n\t * - Otherwise the previous value (if any) is disposed and the new value is stored.\n\t *\n\t * Related helpers:\n\t * - clear() resets the value to `undefined` (and disposes the previous value).\n\t * - clearAndLeak() returns the old value without disposing it and removes its parent.\n\t */\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nexport class MandatoryMutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate readonly _disposable = new MutableDisposable<T>();\n\tprivate _isDisposed = false;\n\n\tconstructor(initialValue: T) {\n\t\tthis._disposable.value = initialValue;\n\t}\n\n\tget value(): T {\n\t\treturn this._disposable.value!;\n\t}\n\n\tset value(value: T) {\n\t\tif (this._isDisposed || value === this._disposable.value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposable.value = value;\n\t}\n\n\tdispose() {\n\t\tthis._isDisposed = true;\n\t\tthis._disposable.dispose();\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: unknown[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = createSingleCallFunction(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: unknown[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable> implements IDisposable {\n\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t\tsetParentOfDisposable(value, this);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map but return it. The caller is\n\t * responsible for disposing of the value.\n\t */\n\tdeleteAndLeak(key: K): V | undefined {\n\t\tconst value = this._store.get(key);\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, null);\n\t\t}\n\t\tthis._store.delete(key);\n\t\treturn value;\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._store.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._store.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n\n/**\n * Call `then` on a Promise, unless the returned disposable is disposed.\n */\nexport function thenIfNotDisposed<T>(promise: Promise<T>, then: (result: T) => void): IDisposable {\n\tlet disposed = false;\n\tpromise.then(result => {\n\t\tif (disposed) {\n\t\t\treturn;\n\t\t}\n\t\tthen(result);\n\t});\n\treturn toDisposable(() => {\n\t\tdisposed = true;\n\t});\n}\n\n/**\n * Call `then` on a promise that resolves to a {@link IDisposable}, then either register the\n * disposable or register it to the {@link DisposableStore}, depending on whether the store is\n * disposed or not.\n */\nexport function thenRegisterOrDispose<T extends IDisposable>(promise: Promise<T>, store: DisposableStore): Promise<T> {\n\treturn promise.then(disposable => {\n\t\tif (store.isDisposed) {\n\t\t\tdisposable.dispose();\n\t\t} else {\n\t\t\tstore.add(disposable);\n\t\t}\n\t\treturn disposable;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from './arrays.js';\nimport { groupBy } from './collections.js';\nimport { SetMap } from './map.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport class GCBasedDisposableTracker implements IDisposableTracker {\n\n\tprivate readonly _registry = new FinalizationRegistry<string>(heldValue => {\n\t\tconsole.warn(`[LEAKED DISPOSABLE] ${heldValue}`);\n\t});\n\n\ttrackDisposable(disposable: IDisposable): void {\n\t\tconst stack = new Error('CREATED via:').stack!;\n\t\tthis._registry.register(disposable, stack, disposable);\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tif (parent) {\n\t\t\tthis._registry.unregister(child);\n\t\t} else {\n\t\t\tthis.trackDisposable(child);\n\t\t}\n\t}\n\n\tmarkAsDisposed(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source =\n\t\t\t\tnew Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(data: DisposableInfo, cache: Map<DisposableInfo, DisposableInfo>): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n\t\t\t.flatMap(([k]) => k);\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(maxReported = 10, preComputedLeaks?: DisposableInfo[]): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()]\n\t\t\t\t.filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter(l => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error('There are cyclic diposable chains!');\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(array: string[], linesToRemove: (string | RegExp)[]) {\n\t\t\t\twhile (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking.source!.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n\t\t\tremovePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n\n\t\tlet message = '';\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n\t\t\t\tconst continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tif (set) {\n\t\t\t\t\t\tstackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E>(thing: E): thing is E & IDisposable {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn typeof thing === 'object' && thing !== null && typeof (<IDisposable><any>thing).dispose === 'function' && (<IDisposable><any>thing).dispose.length === 0;\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends Iterable<T> = Iterable<T>>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | Iterable<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(errors, 'Encountered errors while disposing of store');\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(disposables: Array<T>): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\nclass FunctionDisposable implements IDisposable {\n\tprivate _isDisposed: boolean;\n\tprivate readonly _fn: () => void;\n\n\tconstructor(fn: () => void) {\n\t\tthis._isDisposed = false;\n\t\tthis._fn = fn;\n\t\ttrackDisposable(this);\n\t}\n\n\tdispose() {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fn) {\n\t\t\tthrow new Error(`Unbound disposable context: Need to use an arrow function to preserve the value of this`);\n\t\t}\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._fn();\n\t}\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn new FunctionDisposable(fn);\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o || o === Disposable.None) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\t/**\n\t * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n\t * disposable even when the disposable is not part in the store.\n\t */\n\tpublic delete<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot dispose a disposable on itself!');\n\t\t}\n\t\tthis._toDispose.delete(o);\n\t\to.dispose();\n\t}\n\n\t/**\n\t * Deletes the value from the store, but does not dispose it.\n\t */\n\tpublic deleteAndLeak<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._toDispose.has(o)) {\n\t\t\tthis._toDispose.delete(o);\n\t\t\tsetParentOfDisposable(o, null);\n\t\t}\n\t}\n\n\tpublic assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tonUnexpectedError(new BugIndicatingError('Object disposed'));\n\t\t}\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Get the currently held disposable value, or `undefined` if this MutableDisposable has been disposed\n\t */\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\t/**\n\t * Set a new disposable value.\n\t *\n\t * Behaviour:\n\t * - If the MutableDisposable has been disposed, the setter is a no-op.\n\t * - If the new value is strictly equal to the current value, the setter is a no-op.\n\t * - Otherwise the previous value (if any) is disposed and the new value is stored.\n\t *\n\t * Related helpers:\n\t * - clear() resets the value to `undefined` (and disposes the previous value).\n\t * - clearAndLeak() returns the old value without disposing it and removes its parent.\n\t */\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nexport class MandatoryMutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate readonly _disposable = new MutableDisposable<T>();\n\tprivate _isDisposed = false;\n\n\tconstructor(initialValue: T) {\n\t\tthis._disposable.value = initialValue;\n\t}\n\n\tget value(): T {\n\t\treturn this._disposable.value!;\n\t}\n\n\tset value(value: T) {\n\t\tif (this._isDisposed || value === this._disposable.value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposable.value = value;\n\t}\n\n\tdispose() {\n\t\tthis._isDisposed = true;\n\t\tthis._disposable.dispose();\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: unknown[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = createSingleCallFunction(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: unknown[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable> implements IDisposable {\n\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t\tsetParentOfDisposable(value, this);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map but return it. The caller is\n\t * responsible for disposing of the value.\n\t */\n\tdeleteAndLeak(key: K): V | undefined {\n\t\tconst value = this._store.get(key);\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, null);\n\t\t}\n\t\tthis._store.delete(key);\n\t\treturn value;\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._store.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._store.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n\n/**\n * Call `then` on a Promise, unless the returned disposable is disposed.\n */\nexport function thenIfNotDisposed<T>(promise: Promise<T>, then: (result: T) => void): IDisposable {\n\tlet disposed = false;\n\tpromise.then(result => {\n\t\tif (disposed) {\n\t\t\treturn;\n\t\t}\n\t\tthen(result);\n\t});\n\treturn toDisposable(() => {\n\t\tdisposed = true;\n\t});\n}\n\n/**\n * Call `then` on a promise that resolves to a {@link IDisposable}, then either register the\n * disposable or register it to the {@link DisposableStore}, depending on whether the store is\n * disposed or not.\n */\nexport function thenRegisterOrDispose<T extends IDisposable>(promise: Promise<T>, store: DisposableStore): Promise<T> {\n\treturn promise.then(disposable => {\n\t\tif (store.isDisposed) {\n\t\t\tdisposable.dispose();\n\t\t} else {\n\t\t\tstore.add(disposable);\n\t\t}\n\t\treturn disposable;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<unknown>(undefined);\n\n\telement: E;\n\tnext: Node<E> | typeof Node.Undefined;\n\tprev: Node<E> | typeof Node.Undefined;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> | typeof Node.Undefined = Node.Undefined;\n\tprivate _last: Node<E> | typeof Node.Undefined = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tconst next = node.next;\n\t\t\tnode.prev = Node.Undefined;\n\t\t\tnode.next = Node.Undefined;\n\t\t\tnode = next;\n\t\t}\n\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res as E;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res as E;\n\t\t}\n\t}\n\n\tpeek(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\treturn res as E;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E> | typeof Node.Undefined): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element as E;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<unknown>(undefined);\n\n\telement: E;\n\tnext: Node<E> | typeof Node.Undefined;\n\tprev: Node<E> | typeof Node.Undefined;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> | typeof Node.Undefined = Node.Undefined;\n\tprivate _last: Node<E> | typeof Node.Undefined = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tconst next = node.next;\n\t\t\tnode.prev = Node.Undefined;\n\t\t\tnode.next = Node.Undefined;\n\t\t\tnode = next;\n\t\t}\n\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res as E;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res as E;\n\t\t}\n\t}\n\n\tpeek(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\treturn res as E;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E> | typeof Node.Undefined): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element as E;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\ndeclare const globalThis: { performance: { now(): number } };\nconst performanceNow = globalThis.performance.now.bind(globalThis.performance);\n\nexport class StopWatch {\n\n\tprivate _startTime: number;\n\tprivate _stopTime: number;\n\n\tprivate readonly _now: () => number;\n\n\tpublic static create(highResolution?: boolean): StopWatch {\n\t\treturn new StopWatch(highResolution);\n\t}\n\n\tconstructor(highResolution?: boolean) {\n\t\tthis._now = highResolution === false ? Date.now : performanceNow;\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic stop(): void {\n\t\tthis._stopTime = this._now();\n\t}\n\n\tpublic reset(): void {\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic elapsed(): number {\n\t\tif (this._stopTime !== -1) {\n\t\t\treturn this._stopTime - this._startTime;\n\t\t}\n\t\treturn this._now() - this._startTime;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\ndeclare const globalThis: { performance: { now(): number } };\nconst performanceNow = globalThis.performance.now.bind(globalThis.performance);\n\nexport class StopWatch {\n\n\tprivate _startTime: number;\n\tprivate _stopTime: number;\n\n\tprivate readonly _now: () => number;\n\n\tpublic static create(highResolution?: boolean): StopWatch {\n\t\treturn new StopWatch(highResolution);\n\t}\n\n\tconstructor(highResolution?: boolean) {\n\t\tthis._now = highResolution === false ? Date.now : performanceNow;\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic stop(): void {\n\t\tthis._stopTime = this._now();\n\t}\n\n\tpublic reset(): void {\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic elapsed(): number {\n\t\tif (this._stopTime !== -1) {\n\t\t\treturn this._stopTime - this._startTime;\n\t\t}\n\t\treturn this._now() - this._startTime;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise } from './async.js';\nimport { CancellationToken } from './cancellation.js';\nimport { diffSets } from './collections.js';\nimport { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { IObservable, IObservableWithChange, IObserver } from './observable.js';\nimport { StopWatch } from './stopwatch.js';\nimport { MicrotaskDelay } from './symbols.js';\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void> {\n\t\treturn debounce<unknown, void>(event, () => void 0, 0, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once, and only when the condition is met.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function onceIf<T>(event: Event<T>, condition: (e: T) => boolean): Event<T> {\n\t\treturn Event.once(Event.filter(event, condition));\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(d: T, store: DisposableStore | IDisposable[] | undefined): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number | typeof MicrotaskDelay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: Timeout | undefined | null = undefined;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === 'number') {\n\t\t\t\t\t\tif (handle) {\n\t\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (handle === undefined) {\n\t\t\t\t\t\t\thandle = null;\n\t\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(event: Event<T>, delay: number | typeof MicrotaskDelay = 0, disposable?: DisposableStore): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(event, (last, e) => {\n\t\t\tif (!last) {\n\t\t\t\treturn [e];\n\t\t\t}\n\t\t\tlast.push(e);\n\t\t\treturn last;\n\t\t}, delay, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = [], disposable?: DisposableStore): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(event: Event<T>, sythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(new ChainableSynthesis()) as ChainableSynthesis;\n\t\t\treturn event(function (value) {\n\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol('HaltChainable');\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => unknown)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push(v => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push(v => fn(v) ? v : HaltChainable);\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: any) => R, initial?: R | undefined): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push(v => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(equals: (a: any, b: any) => boolean = (a, b) => a === b): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push(value => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter<R extends T>(fn: (e: T) => e is R): IChainableSythensis<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\treduce<R>(merge: (last: R, event: T) => R, initial: R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>, disposables?: IDisposable[] | DisposableStore): CancelablePromise<T> {\n\t\tlet cancelRef: () => void;\n\t\tlet listener: IDisposable;\n\t\tconst promise = new Promise((resolve) => {\n\t\t\tlistener = once(event)(resolve);\n\t\t\taddToDisposables(listener, disposables);\n\n\t\t\t// not resolved, matching the behavior of a normal disposal\n\t\t\tcancelRef = () => {\n\t\t\t\tdisposeAndRemove(listener, disposables);\n\t\t\t};\n\t\t}) as CancelablePromise<T>;\n\t\tpromise.cancel = cancelRef!;\n\n\t\tif (disposables) {\n\t\t\tpromise.finally(() => disposeAndRemove(listener, disposables));\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * A convenience function for forwarding an event to another emitter which\n\t * improves readability.\n\t *\n\t * This is similar to {@link Relay} but allows instantiating and forwarding\n\t * on a single line and also allows for multiple source events.\n\t * @param from The event to forward.\n\t * @param to The emitter to forward the event to.\n\t * @example\n\t * Event.forward(event, emitter);\n\t * // equivalent to\n\t * event(e => emitter.fire(e));\n\t * // equivalent to\n\t * event(emitter.fire, emitter);\n\t */\n\texport function forward<T>(from: Event<T>, to: Emitter<T>): IDisposable {\n\t\treturn from(e => to.fire(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T) => unknown, initial: T): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown, initial?: T): IDisposable {\n\t\thandler(initial);\n\t\treturn event(e => handler(e));\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly _observable: IObservable<T>, store: DisposableStore | undefined) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\n\t\t\t\t\t// Communicate to the observable that we received its current value and would like to be notified about future changes.\n\t\t\t\t\tthis._observable.reportChanges();\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservableWithChange<T, TChange>, _change: TChange): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(obs: IObservable<T>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(observable: IObservable<unknown>): Event<void> {\n\t\treturn (listener, thisArgs, disposables) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener.call(thisArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\tconst disposable = {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\taddToDisposables(disposable, disposables);\n\n\t\t\treturn disposable;\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nexport class EventProfiling {\n\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount: number = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate static _idPool = 1;\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _errorHandler: (err: Error) => void,\n\t\treadonly threshold: number,\n\t\treadonly name: string = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')\n\t) { }\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\tconst [topStack, topCount] = this.getMostFrequentStack()!;\n\t\t\tconst message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n\t\t\tconsole.warn(message);\n\t\t\tconsole.warn(topStack);\n\n\t\t\tconst error = new ListenerLeakError(message, topStack);\n\t\t\tthis._errorHandler(error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n\n\tgetMostFrequentStack(): [string, number] | undefined {\n\t\tif (!this._stacks) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet topStack: [string, number] | undefined;\n\t\tlet topCount: number = 0;\n\t\tfor (const [stack, count] of this._stacks) {\n\t\t\tif (!topStack || topCount < count) {\n\t\t\t\ttopStack = [stack, count];\n\t\t\t\ttopCount = count;\n\t\t\t}\n\t\t}\n\t\treturn topStack;\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\tconst err = new Error();\n\t\treturn new Stacktrace(err.stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerRefusalError';\n\t\tthis.stack = stack;\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) { }\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> = (ListenerContainer<T> | undefined)[] | ListenerContainer<T>;\n\nconst forEachListener = <T>(listeners: ListenerOrListeners<T>, fn: (c: ListenerContainer<T>) => void) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n\t\t\t? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n\t\t\tundefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as EventDeliveryQueuePrivate | undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, l => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (callback: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\tif (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n\t\t\t\tconst message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n\t\t\t\tconsole.warn(message);\n\n\t\t\t\tconst tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n\t\t\t\tconst error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n\t\t\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\t\t\terrorHandler(error);\n\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\t\t\tthis._options?.onDidAddListener?.(this);\n\n\t\t\tthis._size++;\n\n\n\t\t\tconst result = toDisposable(() => {\n\t\t\t\tremoveMonitor?.();\n\t\t\t\tthis._removeListener(contained);\n\t\t\t});\n\t\t\taddToDisposables(result, disposables);\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (ListenerContainer<T> | undefined)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log('disposed?', this._disposed);\n\t\t\tconsole.log('size?', this._size);\n\t\t\tconsole.log('arr?', JSON.stringify(this._listeners));\n\t\t\tthrow new Error('Attempted to dispose unknown listener');\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue && n < this._deliveryQueue!.end) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(listener: undefined | UniqueContainer<(value: T) => void>, value: T) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (ListenerContainer<T> | undefined)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue => new EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[(ev: T) => void, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, listener => this._asyncDeliveryQueue!.push([listener.value, data]));\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: Timeout | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(createSingleCallFunction(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener?.dispose();\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\n\t\tfor (const e of this.events) {\n\t\t\te.listener?.dispose();\n\t\t}\n\t\tthis.events = [];\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType> implements IDynamicListEventMultiplexer<TEventType> {\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(new DisposableMap<TItem, IDisposable>());\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(onAddItem(instance => {\n\t\t\taddItem(instance);\n\t\t}));\n\n\t\t// Removed items\n\t\tthis._store.add(onRemoveItem(instance => {\n\t\t\titemListeners.deleteAndDispose(instance);\n\t\t}));\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate data: { buffers: Function[] }[] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T>;\n\twrapEvent<T>(event: Event<T>, reduce: (last: T | undefined, event: T) => T): Event<T>;\n\twrapEvent<T, O>(event: Event<T>, reduce: (last: O | undefined, event: T) => O, initial: O): Event<O>;\n\twrapEvent<T, O>(event: Event<T>, reduce?: (last: T | O | undefined, event: T) => T | O, initial?: O): Event<O | T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst data = this.data[this.data.length - 1];\n\n\t\t\t\t// Non-reduce scenario\n\t\t\t\tif (!reduce) {\n\t\t\t\t\t// Buffering case\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tdata.buffers.push(() => listener.call(thisArgs, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not buffering case\n\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Reduce scenario\n\t\t\t\tconst reduceData = data as typeof data & {\n\t\t\t\t\t/**\n\t\t\t\t\t * The accumulated items that will be reduced.\n\t\t\t\t\t */\n\t\t\t\t\titems?: T[];\n\t\t\t\t\t/**\n\t\t\t\t\t * The reduced result cached to be shared with other listeners.\n\t\t\t\t\t */\n\t\t\t\t\treducedResult?: T | O;\n\t\t\t\t};\n\n\t\t\t\t// Not buffering case\n\t\t\t\tif (!reduceData) {\n\t\t\t\t\t// TODO: Is there a way to cache this reduce call for all listeners?\n\t\t\t\t\tlistener.call(thisArgs, reduce(initial, i));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Buffering case\n\t\t\t\treduceData.items ??= [];\n\t\t\t\treduceData.items.push(i);\n\t\t\t\tif (reduceData.buffers.length === 0) {\n\t\t\t\t\t// Include a single buffered function that will reduce all events when we're done buffering events\n\t\t\t\t\tdata.buffers.push(() => {\n\t\t\t\t\t\t// cache the reduced result so that the value can be shared across all listeners\n\t\t\t\t\t\treduceData.reducedResult ??= initial\n\t\t\t\t\t\t\t? reduceData.items!.reduce(reduce as (last: O | undefined, event: T) => O, initial)\n\t\t\t\t\t\t\t: reduceData.items!.reduce(reduce as (last: T | undefined, event: T) => T);\n\t\t\t\t\t\tlistener.call(thisArgs, reduceData.reducedResult);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst data = { buffers: new Array<Function>() };\n\t\tthis.data.push(data);\n\t\tconst r = fn();\n\t\tthis.data.pop();\n\t\tdata.buffers.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IValueWithChangeEvent<T> {\n\treadonly onDidChange: Event<void>;\n\tget value(): T;\n}\n\nexport class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic static const<T>(value: T): IValueWithChangeEvent<T> {\n\t\treturn new ConstValueWithChangeEvent(value);\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(private _value: T) { }\n\n\tget value(): T {\n\t\treturn this._value;\n\t}\n\n\tset value(value: T) {\n\t\tif (value !== this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis._onDidChange.fire(undefined);\n\t\t}\n\t}\n}\n\nclass ConstValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic readonly onDidChange: Event<void> = Event.None;\n\n\tconstructor(readonly value: T) { }\n}\n\n/**\n * @param handleItem Is called for each item in the set (but only the first time the item is seen in the set).\n * \tThe returned disposable is disposed if the item is no longer in the set.\n */\nexport function trackSetChanges<T>(getData: () => ReadonlySet<T>, onDidChangeData: Event<unknown>, handleItem: (d: T) => IDisposable): IDisposable {\n\tconst map = new DisposableMap<T, IDisposable>();\n\tlet oldData = new Set(getData());\n\tfor (const d of oldData) {\n\t\tmap.set(d, handleItem(d));\n\t}\n\n\tconst store = new DisposableStore();\n\tstore.add(onDidChangeData(() => {\n\t\tconst newData = getData();\n\t\tconst diff = diffSets(oldData, newData);\n\t\tfor (const r of diff.removed) {\n\t\t\tmap.deleteAndDispose(r);\n\t\t}\n\t\tfor (const a of diff.added) {\n\t\t\tmap.set(a, handleItem(a));\n\t\t}\n\t\toldData = new Set(newData);\n\t}));\n\tstore.add(map);\n\treturn store;\n}\n\n\nfunction addToDisposables(result: IDisposable, disposables: DisposableStore | IDisposable[] | undefined) {\n\tif (disposables instanceof DisposableStore) {\n\t\tdisposables.add(result);\n\t} else if (Array.isArray(disposables)) {\n\t\tdisposables.push(result);\n\t}\n}\n\nfunction disposeAndRemove(result: IDisposable, disposables: DisposableStore | IDisposable[] | undefined) {\n\tif (disposables instanceof DisposableStore) {\n\t\tdisposables.delete(result);\n\t} else if (Array.isArray(disposables)) {\n\t\tconst index = disposables.indexOf(result);\n\t\tif (index !== -1) {\n\t\t\tdisposables.splice(index, 1);\n\t\t}\n\t}\n\tresult.dispose();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise } from './async.js';\nimport { CancellationToken } from './cancellation.js';\nimport { diffSets } from './collections.js';\nimport { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { IObservable, IObservableWithChange, IObserver } from './observable.js';\nimport { StopWatch } from './stopwatch.js';\nimport { MicrotaskDelay } from './symbols.js';\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void> {\n\t\treturn debounce<unknown, void>(event, () => void 0, 0, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once, and only when the condition is met.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function onceIf<T>(event: Event<T>, condition: (e: T) => boolean): Event<T> {\n\t\treturn Event.once(Event.filter(event, condition));\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(d: T, store: DisposableStore | IDisposable[] | undefined): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number | typeof MicrotaskDelay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: Timeout | undefined | null = undefined;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === 'number') {\n\t\t\t\t\t\tif (handle) {\n\t\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (handle === undefined) {\n\t\t\t\t\t\t\thandle = null;\n\t\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(event: Event<T>, delay: number | typeof MicrotaskDelay = 0, disposable?: DisposableStore): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(event, (last, e) => {\n\t\t\tif (!last) {\n\t\t\t\treturn [e];\n\t\t\t}\n\t\t\tlast.push(e);\n\t\t\treturn last;\n\t\t}, delay, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = [], disposable?: DisposableStore): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(event: Event<T>, sythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(new ChainableSynthesis()) as ChainableSynthesis;\n\t\t\treturn event(function (value) {\n\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol('HaltChainable');\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => unknown)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push(v => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push(v => fn(v) ? v : HaltChainable);\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: any) => R, initial?: R | undefined): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push(v => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(equals: (a: any, b: any) => boolean = (a, b) => a === b): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push(value => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter<R extends T>(fn: (e: T) => e is R): IChainableSythensis<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\treduce<R>(merge: (last: R, event: T) => R, initial: R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>, disposables?: IDisposable[] | DisposableStore): CancelablePromise<T> {\n\t\tlet cancelRef: () => void;\n\t\tlet listener: IDisposable;\n\t\tconst promise = new Promise((resolve) => {\n\t\t\tlistener = once(event)(resolve);\n\t\t\taddToDisposables(listener, disposables);\n\n\t\t\t// not resolved, matching the behavior of a normal disposal\n\t\t\tcancelRef = () => {\n\t\t\t\tdisposeAndRemove(listener, disposables);\n\t\t\t};\n\t\t}) as CancelablePromise<T>;\n\t\tpromise.cancel = cancelRef!;\n\n\t\tif (disposables) {\n\t\t\tpromise.finally(() => disposeAndRemove(listener, disposables));\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * A convenience function for forwarding an event to another emitter which\n\t * improves readability.\n\t *\n\t * This is similar to {@link Relay} but allows instantiating and forwarding\n\t * on a single line and also allows for multiple source events.\n\t * @param from The event to forward.\n\t * @param to The emitter to forward the event to.\n\t * @example\n\t * Event.forward(event, emitter);\n\t * // equivalent to\n\t * event(e => emitter.fire(e));\n\t * // equivalent to\n\t * event(emitter.fire, emitter);\n\t */\n\texport function forward<T>(from: Event<T>, to: Emitter<T>): IDisposable {\n\t\treturn from(e => to.fire(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T) => unknown, initial: T): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown, initial?: T): IDisposable {\n\t\thandler(initial);\n\t\treturn event(e => handler(e));\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly _observable: IObservable<T>, store: DisposableStore | undefined) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\n\t\t\t\t\t// Communicate to the observable that we received its current value and would like to be notified about future changes.\n\t\t\t\t\tthis._observable.reportChanges();\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservableWithChange<T, TChange>, _change: TChange): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(obs: IObservable<T>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(observable: IObservable<unknown>): Event<void> {\n\t\treturn (listener, thisArgs, disposables) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener.call(thisArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\tconst disposable = {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\taddToDisposables(disposable, disposables);\n\n\t\t\treturn disposable;\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nexport class EventProfiling {\n\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount: number = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate static _idPool = 1;\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _errorHandler: (err: Error) => void,\n\t\treadonly threshold: number,\n\t\treadonly name: string = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')\n\t) { }\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\tconst [topStack, topCount] = this.getMostFrequentStack()!;\n\t\t\tconst message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n\t\t\tconsole.warn(message);\n\t\t\tconsole.warn(topStack);\n\n\t\t\tconst error = new ListenerLeakError(message, topStack);\n\t\t\tthis._errorHandler(error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n\n\tgetMostFrequentStack(): [string, number] | undefined {\n\t\tif (!this._stacks) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet topStack: [string, number] | undefined;\n\t\tlet topCount: number = 0;\n\t\tfor (const [stack, count] of this._stacks) {\n\t\t\tif (!topStack || topCount < count) {\n\t\t\t\ttopStack = [stack, count];\n\t\t\t\ttopCount = count;\n\t\t\t}\n\t\t}\n\t\treturn topStack;\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\tconst err = new Error();\n\t\treturn new Stacktrace(err.stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerRefusalError';\n\t\tthis.stack = stack;\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) { }\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> = (ListenerContainer<T> | undefined)[] | ListenerContainer<T>;\n\nconst forEachListener = <T>(listeners: ListenerOrListeners<T>, fn: (c: ListenerContainer<T>) => void) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n\t\t\t? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n\t\t\tundefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as EventDeliveryQueuePrivate | undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, l => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (callback: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\tif (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n\t\t\t\tconst message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n\t\t\t\tconsole.warn(message);\n\n\t\t\t\tconst tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n\t\t\t\tconst error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n\t\t\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\t\t\terrorHandler(error);\n\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\t\t\tthis._options?.onDidAddListener?.(this);\n\n\t\t\tthis._size++;\n\n\n\t\t\tconst result = toDisposable(() => {\n\t\t\t\tremoveMonitor?.();\n\t\t\t\tthis._removeListener(contained);\n\t\t\t});\n\t\t\taddToDisposables(result, disposables);\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (ListenerContainer<T> | undefined)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log('disposed?', this._disposed);\n\t\t\tconsole.log('size?', this._size);\n\t\t\tconsole.log('arr?', JSON.stringify(this._listeners));\n\t\t\tthrow new Error('Attempted to dispose unknown listener');\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue && n < this._deliveryQueue!.end) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(listener: undefined | UniqueContainer<(value: T) => void>, value: T) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (ListenerContainer<T> | undefined)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue => new EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[(ev: T) => void, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, listener => this._asyncDeliveryQueue!.push([listener.value, data]));\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: Timeout | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(createSingleCallFunction(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener?.dispose();\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\n\t\tfor (const e of this.events) {\n\t\t\te.listener?.dispose();\n\t\t}\n\t\tthis.events = [];\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType> implements IDynamicListEventMultiplexer<TEventType> {\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(new DisposableMap<TItem, IDisposable>());\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(onAddItem(instance => {\n\t\t\taddItem(instance);\n\t\t}));\n\n\t\t// Removed items\n\t\tthis._store.add(onRemoveItem(instance => {\n\t\t\titemListeners.deleteAndDispose(instance);\n\t\t}));\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate data: { buffers: Function[] }[] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T>;\n\twrapEvent<T>(event: Event<T>, reduce: (last: T | undefined, event: T) => T): Event<T>;\n\twrapEvent<T, O>(event: Event<T>, reduce: (last: O | undefined, event: T) => O, initial: O): Event<O>;\n\twrapEvent<T, O>(event: Event<T>, reduce?: (last: T | O | undefined, event: T) => T | O, initial?: O): Event<O | T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst data = this.data[this.data.length - 1];\n\n\t\t\t\t// Non-reduce scenario\n\t\t\t\tif (!reduce) {\n\t\t\t\t\t// Buffering case\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tdata.buffers.push(() => listener.call(thisArgs, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not buffering case\n\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Reduce scenario\n\t\t\t\tconst reduceData = data as typeof data & {\n\t\t\t\t\t/**\n\t\t\t\t\t * The accumulated items that will be reduced.\n\t\t\t\t\t */\n\t\t\t\t\titems?: T[];\n\t\t\t\t\t/**\n\t\t\t\t\t * The reduced result cached to be shared with other listeners.\n\t\t\t\t\t */\n\t\t\t\t\treducedResult?: T | O;\n\t\t\t\t};\n\n\t\t\t\t// Not buffering case\n\t\t\t\tif (!reduceData) {\n\t\t\t\t\t// TODO: Is there a way to cache this reduce call for all listeners?\n\t\t\t\t\tlistener.call(thisArgs, reduce(initial, i));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Buffering case\n\t\t\t\treduceData.items ??= [];\n\t\t\t\treduceData.items.push(i);\n\t\t\t\tif (reduceData.buffers.length === 0) {\n\t\t\t\t\t// Include a single buffered function that will reduce all events when we're done buffering events\n\t\t\t\t\tdata.buffers.push(() => {\n\t\t\t\t\t\t// cache the reduced result so that the value can be shared across all listeners\n\t\t\t\t\t\treduceData.reducedResult ??= initial\n\t\t\t\t\t\t\t? reduceData.items!.reduce(reduce as (last: O | undefined, event: T) => O, initial)\n\t\t\t\t\t\t\t: reduceData.items!.reduce(reduce as (last: T | undefined, event: T) => T);\n\t\t\t\t\t\tlistener.call(thisArgs, reduceData.reducedResult);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst data = { buffers: new Array<Function>() };\n\t\tthis.data.push(data);\n\t\tconst r = fn();\n\t\tthis.data.pop();\n\t\tdata.buffers.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IValueWithChangeEvent<T> {\n\treadonly onDidChange: Event<void>;\n\tget value(): T;\n}\n\nexport class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic static const<T>(value: T): IValueWithChangeEvent<T> {\n\t\treturn new ConstValueWithChangeEvent(value);\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(private _value: T) { }\n\n\tget value(): T {\n\t\treturn this._value;\n\t}\n\n\tset value(value: T) {\n\t\tif (value !== this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis._onDidChange.fire(undefined);\n\t\t}\n\t}\n}\n\nclass ConstValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic readonly onDidChange: Event<void> = Event.None;\n\n\tconstructor(readonly value: T) { }\n}\n\n/**\n * @param handleItem Is called for each item in the set (but only the first time the item is seen in the set).\n * \tThe returned disposable is disposed if the item is no longer in the set.\n */\nexport function trackSetChanges<T>(getData: () => ReadonlySet<T>, onDidChangeData: Event<unknown>, handleItem: (d: T) => IDisposable): IDisposable {\n\tconst map = new DisposableMap<T, IDisposable>();\n\tlet oldData = new Set(getData());\n\tfor (const d of oldData) {\n\t\tmap.set(d, handleItem(d));\n\t}\n\n\tconst store = new DisposableStore();\n\tstore.add(onDidChangeData(() => {\n\t\tconst newData = getData();\n\t\tconst diff = diffSets(oldData, newData);\n\t\tfor (const r of diff.removed) {\n\t\t\tmap.deleteAndDispose(r);\n\t\t}\n\t\tfor (const a of diff.added) {\n\t\t\tmap.set(a, handleItem(a));\n\t\t}\n\t\toldData = new Set(newData);\n\t}));\n\tstore.add(map);\n\treturn store;\n}\n\n\nfunction addToDisposables(result: IDisposable, disposables: DisposableStore | IDisposable[] | undefined) {\n\tif (disposables instanceof DisposableStore) {\n\t\tdisposables.add(result);\n\t} else if (Array.isArray(disposables)) {\n\t\tdisposables.push(result);\n\t}\n}\n\nfunction disposeAndRemove(result: IDisposable, disposables: DisposableStore | IDisposable[] | undefined) {\n\tif (disposables instanceof DisposableStore) {\n\t\tdisposables.delete(result);\n\t} else if (Array.isArray(disposables)) {\n\t\tconst index = disposables.indexOf(result);\n\t\tif (index !== -1) {\n\t\t\tdisposables.splice(index, 1);\n\t\t}\n\t}\n\tresult.dispose();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from './event.js';\nimport { DisposableStore, IDisposable } from './lifecycle.js';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: void) => unknown, thisArgs?: unknown, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<void> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<void> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<void> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<void>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tthis._parentListener?.dispose();\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n\nexport function cancelOnDispose(store: DisposableStore): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tstore.add({ dispose() { source.cancel(); } });\n\treturn source.token;\n}\n\n/**\n * A pool that aggregates multiple cancellation tokens. The pool's own token\n * (accessible via `pool.token`) is cancelled only after every token added\n * to the pool has been cancelled. Adding tokens after the pool token has\n * been cancelled has no effect.\n */\nexport class CancellationTokenPool {\n\n\tprivate readonly _source = new CancellationTokenSource();\n\tprivate readonly _listeners = new DisposableStore();\n\n\tprivate _total: number = 0;\n\tprivate _cancelled: number = 0;\n\tprivate _isDone: boolean = false;\n\n\tget token(): CancellationToken {\n\t\treturn this._source.token;\n\t}\n\n\t/**\n\t * Add a token to the pool. If the token is already cancelled it is counted\n\t * immediately. Tokens added after the pool token has been cancelled are ignored.\n\t */\n\tadd(token: CancellationToken): void {\n\t\tif (this._isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._total++;\n\n\t\tif (token.isCancellationRequested) {\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t\treturn;\n\t\t}\n\n\t\tconst d = token.onCancellationRequested(() => {\n\t\t\td.dispose();\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t});\n\t\tthis._listeners.add(d);\n\t}\n\n\tprivate _check(): void {\n\t\tif (!this._isDone && this._total > 0 && this._total === this._cancelled) {\n\t\t\tthis._isDone = true;\n\t\t\tthis._listeners.dispose();\n\t\t\tthis._source.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._listeners.dispose();\n\t\tthis._source.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from './event.js';\nimport { DisposableStore, IDisposable } from './lifecycle.js';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: void) => unknown, thisArgs?: unknown, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<void> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<void> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<void> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<void>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tthis._parentListener?.dispose();\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n\nexport function cancelOnDispose(store: DisposableStore): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tstore.add({ dispose() { source.cancel(); } });\n\treturn source.token;\n}\n\n/**\n * A pool that aggregates multiple cancellation tokens. The pool's own token\n * (accessible via `pool.token`) is cancelled only after every token added\n * to the pool has been cancelled. Adding tokens after the pool token has\n * been cancelled has no effect.\n */\nexport class CancellationTokenPool {\n\n\tprivate readonly _source = new CancellationTokenSource();\n\tprivate readonly _listeners = new DisposableStore();\n\n\tprivate _total: number = 0;\n\tprivate _cancelled: number = 0;\n\tprivate _isDone: boolean = false;\n\n\tget token(): CancellationToken {\n\t\treturn this._source.token;\n\t}\n\n\t/**\n\t * Add a token to the pool. If the token is already cancelled it is counted\n\t * immediately. Tokens added after the pool token has been cancelled are ignored.\n\t */\n\tadd(token: CancellationToken): void {\n\t\tif (this._isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._total++;\n\n\t\tif (token.isCancellationRequested) {\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t\treturn;\n\t\t}\n\n\t\tconst d = token.onCancellationRequested(() => {\n\t\t\td.dispose();\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t});\n\t\tthis._listeners.add(d);\n\t}\n\n\tprivate _check(): void {\n\t\tif (!this._isDone && this._total > 0 && this._total === this._cancelled) {\n\t\t\tthis._isDone = true;\n\t\t\tthis._listeners.dispose();\n\t\t\tthis._source.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._listeners.dispose();\n\t\tthis._source.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { IDisposable } from './lifecycle.js';\n\nexport interface CacheResult<T> extends IDisposable {\n\tpromise: Promise<T>;\n}\n\nexport class Cache<T> {\n\n\tprivate result: CacheResult<T> | null = null;\n\tconstructor(private task: (ct: CancellationToken) => Promise<T>) { }\n\n\tget(): CacheResult<T> {\n\t\tif (this.result) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst promise = this.task(cts.token);\n\n\t\tthis.result = {\n\t\t\tpromise,\n\t\t\tdispose: () => {\n\t\t\t\tthis.result = null;\n\t\t\t\tcts.cancel();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t};\n\n\t\treturn this.result;\n\t}\n}\n\nexport function identity<T>(t: T): T {\n\treturn t;\n}\n\ninterface ICacheOptions<TArg> {\n\t/**\n\t * The cache key is used to identify the cache entry.\n\t * Strict equality is used to compare cache keys.\n\t*/\n\tgetCacheKey: (arg: TArg) => unknown;\n}\n\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nexport class LRUCachedFunction<TArg, TComputed> {\n\tprivate lastCache: TComputed | undefined = undefined;\n\tprivate lastArgKey: unknown | undefined = undefined;\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this.lastArgKey !== key) {\n\t\t\tthis.lastArgKey = key;\n\t\t\tthis.lastCache = this._fn(arg);\n\t\t}\n\t\treturn this.lastCache!;\n\t}\n}\n\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class CachedFunction<TArg, TComputed> {\n\tprivate readonly _map = new Map<TArg, TComputed>();\n\tprivate readonly _map2 = new Map<unknown, TComputed>();\n\tpublic get cachedValues(): ReadonlyMap<TArg, TComputed> {\n\t\treturn this._map;\n\t}\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this._map2.has(key)) {\n\t\t\treturn this._map2.get(key)!;\n\t\t}\n\n\t\tconst value = this._fn(arg);\n\t\tthis._map.set(arg, value);\n\t\tthis._map2.set(key, value);\n\t\treturn value;\n\t}\n}\n\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class WeakCachedFunction<TArg, TComputed> {\n\tprivate readonly _map = new WeakMap<WeakKey, TComputed>();\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg) as WeakKey;\n\t\tif (this._map.has(key)) {\n\t\t\treturn this._map.get(key)!;\n\t\t}\n\n\t\tconst value = this._fn(arg);\n\t\tthis._map.set(key, value);\n\t\treturn value;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { IDisposable } from './lifecycle.js';\n\nexport interface CacheResult<T> extends IDisposable {\n\tpromise: Promise<T>;\n}\n\nexport class Cache<T> {\n\n\tprivate result: CacheResult<T> | null = null;\n\tconstructor(private task: (ct: CancellationToken) => Promise<T>) { }\n\n\tget(): CacheResult<T> {\n\t\tif (this.result) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst promise = this.task(cts.token);\n\n\t\tthis.result = {\n\t\t\tpromise,\n\t\t\tdispose: () => {\n\t\t\t\tthis.result = null;\n\t\t\t\tcts.cancel();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t};\n\n\t\treturn this.result;\n\t}\n}\n\nexport function identity<T>(t: T): T {\n\treturn t;\n}\n\ninterface ICacheOptions<TArg> {\n\t/**\n\t * The cache key is used to identify the cache entry.\n\t * Strict equality is used to compare cache keys.\n\t*/\n\tgetCacheKey: (arg: TArg) => unknown;\n}\n\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nexport class LRUCachedFunction<TArg, TComputed> {\n\tprivate lastCache: TComputed | undefined = undefined;\n\tprivate lastArgKey: unknown | undefined = undefined;\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this.lastArgKey !== key) {\n\t\t\tthis.lastArgKey = key;\n\t\t\tthis.lastCache = this._fn(arg);\n\t\t}\n\t\treturn this.lastCache!;\n\t}\n}\n\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class CachedFunction<TArg, TComputed> {\n\tprivate readonly _map = new Map<TArg, TComputed>();\n\tprivate readonly _map2 = new Map<unknown, TComputed>();\n\tpublic get cachedValues(): ReadonlyMap<TArg, TComputed> {\n\t\treturn this._map;\n\t}\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this._map2.has(key)) {\n\t\t\treturn this._map2.get(key)!;\n\t\t}\n\n\t\tconst value = this._fn(arg);\n\t\tthis._map.set(arg, value);\n\t\tthis._map2.set(key, value);\n\t\treturn value;\n\t}\n}\n\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class WeakCachedFunction<TArg, TComputed> {\n\tprivate readonly _map = new WeakMap<WeakKey, TComputed>();\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg) as WeakKey;\n\t\tif (this._map.has(key)) {\n\t\t\treturn this._map.get(key)!;\n\t\t}\n\n\t\tconst value = this._fn(arg);\n\t\tthis._map.set(key, value);\n\t\treturn value;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nenum LazyValueState {\n\tUninitialized,\n\tRunning,\n\tCompleted,\n}\n\nexport class Lazy<T> {\n\n\tprivate _state = LazyValueState.Uninitialized;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * True if the lazy value has been resolved.\n\t */\n\tget hasValue(): boolean { return this._state === LazyValueState.Completed; }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tget value(): T {\n\t\tif (this._state === LazyValueState.Uninitialized) {\n\t\t\tthis._state = LazyValueState.Running;\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._state = LazyValueState.Completed;\n\t\t\t}\n\t\t} else if (this._state === LazyValueState.Running) {\n\t\t\tthrow new Error('Cannot read the value of a lazy that is being initialized');\n\t\t}\n\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nenum LazyValueState {\n\tUninitialized,\n\tRunning,\n\tCompleted,\n}\n\nexport class Lazy<T> {\n\n\tprivate _state = LazyValueState.Uninitialized;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * True if the lazy value has been resolved.\n\t */\n\tget hasValue(): boolean { return this._state === LazyValueState.Completed; }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tget value(): T {\n\t\tif (this._state === LazyValueState.Uninitialized) {\n\t\t\tthis._state = LazyValueState.Running;\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._state = LazyValueState.Completed;\n\t\t\t}\n\t\t} else if (this._state === LazyValueState.Running) {\n\t\t\tthrow new Error('Cannot read the value of a lazy that is being initialized');\n\t\t}\n\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCachedFunction } from './cache.js';\nimport { CharCode } from './charCode.js';\nimport { Lazy } from './lazy.js';\nimport { Constants } from './uint.js';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\nconst _format2Regexp = /{([^}]+)}/g;\n\n/**\n * Helper to create a string from a template and a string record.\n * Similar to `format` but with objects instead of positional arguments.\n */\nexport function format2(template: string, values: Record<string, unknown>): string {\n\tif (Object.keys(values).length === 0) {\n\t\treturn template;\n\t}\n\treturn template.replace(_format2Regexp, (match, group) => (values[group] ?? match) as string);\n}\n\n/**\n * Encodes the given value so that it can be used as literal value in html attributes.\n *\n * In other words, computes `$val`, such that `attr` in `<div attr=\"$val\" />` has the runtime value `value`.\n * This prevents XSS injection.\n */\nexport function htmlAttributeEncodeValue(value: string): string {\n\treturn value.replace(/[<>\"'&]/g, ch => {\n\t\tswitch (ch) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '\"': return '&quot;';\n\t\t\tcase '\\'': return '&apos;';\n\t\t\tcase '&': return '&amp;';\n\t\t}\n\t\treturn ch;\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n\n/**\n * Counts how often `substr` occurs inside `value`.\n */\nexport function count(value: string, substr: string): number {\n\tlet result = 0;\n\tlet index = value.indexOf(substr);\n\twhile (index !== -1) {\n\t\tresult++;\n\t\tindex = value.indexOf(substr, index + substr.length);\n\t}\n\treturn result;\n}\n\nexport function truncate(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\treturn `${value.substr(0, maxLength)}${suffix}`;\n}\n\nexport function truncateMiddle(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\tconst prefixLength = Math.ceil(maxLength / 2) - suffix.length / 2;\n\tconst suffixLength = Math.floor(maxLength / 2) - suffix.length / 2;\n\n\treturn `${value.substr(0, prefixLength)}${suffix}${value.substr(value.length - suffixLength)}`;\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tlet offset = 0;\n\tif (needleLen === 1) {\n\t\tconst ch = needle.charCodeAt(0);\n\t\twhile (offset < haystack.length && haystack.charCodeAt(offset) === ch) {\n\t\t\toffset++;\n\t\t}\n\t} else {\n\t\twhile (haystack.startsWith(needle, offset)) {\n\t\t\toffset += needleLen;\n\t\t}\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 1) {\n\t\tlet end = haystackLen;\n\t\tconst ch = needle.charCodeAt(0);\n\t\twhile (end > 0 && haystack.charCodeAt(end - 1) === ch) {\n\t\t\tend--;\n\t\t}\n\t\treturn haystack.substring(0, end);\n\t}\n\n\tlet offset = haystackLen;\n\twhile (offset > 0 && haystack.endsWith(needle, offset)) {\n\t\toffset -= needleLen;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && regexp.lastIndex === 0);\n}\n\nexport function joinStrings(items: (string | undefined | null | false)[], separator: string): string {\n\treturn items.filter(item => item !== undefined && item !== null && item !== false).join(separator);\n}\n\nexport function splitLines(str: string): string[] {\n\treturn str.split(/\\r\\n|\\r|\\n/);\n}\n\nexport function splitLinesIncludeSeparators(str: string): string[] {\n\tconst linesWithSeparators: string[] = [];\n\tconst splitLinesAndSeparators = str.split(/(\\r\\n|\\r|\\n)/);\n\tfor (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {\n\t\tlinesWithSeparators.push(splitLinesAndSeparators[2 * i] + (splitLinesAndSeparators[2 * i + 1] ?? ''));\n\t}\n\treturn linesWithSeparators;\n}\n\nexport function indexOfPattern(str: string, re: RegExp) {\n\tconst match = re.exec(str);\n\tif (match) {\n\t\treturn match.index;\n\t}\n\treturn -1;\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function getIndentationLength(str: string): number {\n\tconst idx = firstNonWhitespaceIndex(str);\n\tif (idx === -1) { return str.length; }\n\treturn idx;\n}\n\n/**\n * Function that works identically to String.prototype.replace, except, the\n * replace function is allowed to be async and return a Promise.\n */\nexport function replaceAsync(str: string, search: RegExp, replacer: (match: string, ...args: unknown[]) => Promise<string>): Promise<string> {\n\tconst parts: (string | Promise<string>)[] = [];\n\n\tlet last = 0;\n\tfor (const match of str.matchAll(search)) {\n\t\tparts.push(str.slice(last, match.index));\n\t\tif (match.index === undefined) {\n\t\t\tthrow new Error('match.index should be defined');\n\t\t}\n\n\t\tlast = match.index + match[0].length;\n\t\tparts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));\n\t}\n\n\tparts.push(str.slice(last));\n\n\treturn Promise.all(parts).then(p => p.join(''));\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\t\tconst codeA = a.charCodeAt(aStart);\n\t\tconst codeB = b.charCodeAt(bStart);\n\t\tif (codeA < codeB) {\n\t\t\treturn -1;\n\t\t} else if (codeA > codeB) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\treturn compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (codeA >= 128 || codeB >= 128) {\n\t\t\t// not ASCII letters -> fallback to lower-casing strings\n\t\t\treturn compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n\t\t}\n\n\t\t// mapper lower-case ascii letter onto upper-case varinats\n\t\t// [97-122] (lower ascii) --> [65-90] (upper ascii)\n\t\tif (isLowerAsciiLetter(codeA)) {\n\t\t\tcodeA -= 32;\n\t\t}\n\t\tif (isLowerAsciiLetter(codeB)) {\n\t\t\tcodeB -= 32;\n\t\t}\n\n\t\t// compare both code points\n\t\tconst diff = codeA - codeB;\n\t\tif (diff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nexport function isAsciiDigit(code: number): boolean {\n\treturn code >= CharCode.Digit0 && code <= CharCode.Digit9;\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\treturn a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\n\nexport function equals(a: string | undefined, b: string | undefined, ignoreCase?: boolean): boolean {\n\treturn a === b || (!!ignoreCase && a !== undefined && b !== undefined && equalsIgnoreCase(a, b));\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst len = candidate.length;\n\treturn len <= str.length && compareSubstringIgnoreCase(str, candidate, 0, len) === 0;\n}\n\nexport function endsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst len = str.length;\n\tconst start = len - candidate.length;\n\treturn start >= 0 && compareSubstringIgnoreCase(str, candidate, start, len) === 0;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate: number, lowSurrogate: number): number {\n\treturn ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str: string, len: number, offset: number): number {\n\tconst charCode = str.charCodeAt(offset);\n\tif (isHighSurrogate(charCode) && offset + 1 < len) {\n\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\tif (isLowSurrogate(nextCharCode)) {\n\t\t\treturn computeCodePoint(charCode, nextCharCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str: string, offset: number): number {\n\tconst charCode = str.charCodeAt(offset - 1);\n\tif (isLowSurrogate(charCode) && offset > 1) {\n\t\tconst prevCharCode = str.charCodeAt(offset - 2);\n\t\tif (isHighSurrogate(prevCharCode)) {\n\t\t\treturn computeCodePoint(prevCharCode, charCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\nexport class CodePointIterator {\n\n\tprivate readonly _str: string;\n\tprivate readonly _len: number;\n\tprivate _offset: number;\n\n\tpublic get offset(): number {\n\t\treturn this._offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._str = str;\n\t\tthis._len = str.length;\n\t\tthis._offset = offset;\n\t}\n\n\tpublic setOffset(offset: number): void {\n\t\tthis._offset = offset;\n\t}\n\n\tpublic prevCodePoint(): number {\n\t\tconst codePoint = getPrevCodePoint(this._str, this._offset);\n\t\tthis._offset -= (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic nextCodePoint(): number {\n\t\tconst codePoint = getNextCodePoint(this._str, this._len, this._offset);\n\t\tthis._offset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn (this._offset >= this._len);\n\t}\n}\n\nexport class GraphemeIterator {\n\n\tprivate readonly _iterator: CodePointIterator;\n\n\tpublic get offset(): number {\n\t\treturn this._iterator.offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._iterator = new CodePointIterator(str, offset);\n\t}\n\n\tpublic nextGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\twhile (!iterator.eol()) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = nextGraphemeBreakType;\n\t\t}\n\t\treturn (iterator.offset - initialOffset);\n\t}\n\n\tpublic prevGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\twhile (iterator.offset > 0) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = prevGraphemeBreakType;\n\t\t}\n\t\treturn (initialOffset - iterator.offset);\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn this._iterator.eol();\n\t}\n}\n\nexport function nextCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.nextGraphemeLength();\n}\n\nexport function prevCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.prevGraphemeLength();\n}\n\nexport function getCharContainingOffset(str: string, offset: number): [number, number] {\n\tif (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n\t\toffset--;\n\t}\n\tconst endOffset = offset + nextCharLength(str, offset);\n\tconst startOffset = endOffset - prevCharLength(str, endOffset);\n\treturn [startOffset, endOffset];\n}\n\nexport function charCount(str: string): number {\n\tconst iterator = new GraphemeIterator(str);\n\tlet length = 0;\n\twhile (!iterator.eol()) {\n\t\tlength++;\n\t\titerator.nextGraphemeLength();\n\t}\n\treturn length;\n}\n\nlet CONTAINS_RTL: RegExp | undefined = undefined;\n\nfunction makeContainsRtl() {\n\t// Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\n\treturn /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n}\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\tif (!CONTAINS_RTL) {\n\t\tCONTAINS_RTL = makeContainsRtl();\n\t}\n\n\treturn CONTAINS_RTL.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str: string): boolean {\n\treturn UNUSUAL_LINE_TERMINATORS.test(str);\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 - 2EFF   CJK Radicals Supplement\n\t//          2F00 - 2FDF   Kangxi Radicals\n\t//          2FF0 - 2FFF   Ideographic Description Characters\n\t//          3000 - 303F   CJK Symbols and Punctuation\n\t//          3040 - 309F   Hiragana\n\t//          30A0 - 30FF   Katakana\n\t//          3100 - 312F   Bopomofo\n\t//          3130 - 318F   Hangul Compatibility Jamo\n\t//          3190 - 319F   Kanbun\n\t//          31A0 - 31BF   Bopomofo Extended\n\t//          31F0 - 31FF   Katakana Phonetic Extensions\n\t//          3200 - 32FF   Enclosed CJK Letters and Months\n\t//          3300 - 33FF   CJK Compatibility\n\t//          3400 - 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 - 4DFF   Yijing Hexagram Symbols\n\t//          4E00 - 9FFF   CJK Unified Ideographs\n\t//          A000 - A48F   Yi Syllables\n\t//          A490 - A4CF   Yi Radicals\n\t//          AC00 - D7AF   Hangul Syllables\n\t// [IGNORE] D800 - DB7F   High Surrogates\n\t// [IGNORE] DB80 - DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 - DFFF   Low Surrogates\n\t// [IGNORE] E000 - F8FF   Private Use Area\n\t//          F900 - FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 - FE0F   Variation Selectors\n\t// [IGNORE] FE20 - FE2F   Combining Half Marks\n\t// [IGNORE] FE30 - FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 - FE6F   Small Form Variants\n\t// [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\n\t//          FF00 - FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 - FFFF   Specials\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\n */\nexport function isEmojiImprecise(x: number): boolean {\n\treturn (\n\t\t(x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n\t\t|| (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n\t\t|| (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n\t\t|| (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\n\t\t|| (x >= 129648 && x <= 129782)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n * The return value can be longer than the given value of `n`. Leading whitespace is always trimmed.\n */\nexport function lcut(text: string, n: number, prefix = ''): string {\n\tconst trimmed = text.trimStart();\n\n\tif (trimmed.length < n) {\n\t\treturn trimmed;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(trimmed)) {\n\t\tif (trimmed.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\tif (i === 0) {\n\t\treturn trimmed;\n\t}\n\n\treturn prefix + trimmed.substring(i).trimStart();\n}\n\n// Defacto standard: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html\nconst CSI_SEQUENCE = /(?:\\x1b\\[|\\x9b)[=?>!]?[\\d;:]*[\"$#'* ]?[a-zA-Z@^`{}|~]/;\nconst OSC_SEQUENCE = /(?:\\x1b\\]|\\x9d).*?(?:\\x1b\\\\|\\x07|\\x9c)/;\nconst ESC_SEQUENCE = /\\x1b(?:[ #%\\(\\)\\*\\+\\-\\.\\/]?[a-zA-Z0-9\\|}~@])/;\nconst CONTROL_SEQUENCES = new RegExp('(?:' + [\n\tCSI_SEQUENCE.source,\n\tOSC_SEQUENCE.source,\n\tESC_SEQUENCE.source,\n].join('|') + ')', 'g');\n\n/** Iterates over parts of a string with CSI sequences */\nexport function* forAnsiStringParts(str: string) {\n\tlet last = 0;\n\tfor (const match of str.matchAll(CONTROL_SEQUENCES)) {\n\t\tif (last !== match.index) {\n\t\t\tyield { isCode: false, str: str.substring(last, match.index) };\n\t\t}\n\n\t\tyield { isCode: true, str: match[0] };\n\t\tlast = match.index + match[0].length;\n\t}\n\n\tif (last !== str.length) {\n\t\tyield { isCode: false, str: str.substring(last) };\n\t}\n}\n\n/**\n * Strips ANSI escape sequences from a string.\n * @param str The dastringa stringo strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodes('\\u001b[31mHello, World!\\u001b[0m');\n * // 'Hello, World!'\n */\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(CONTROL_SEQUENCES, '');\n\t}\n\n\treturn str;\n}\n\nconst PROMPT_NON_PRINTABLE = /\\\\\\[.*?\\\\\\]/g;\n\n/**\n * Strips ANSI escape sequences from a UNIX-style prompt string (eg. `$PS1`).\n * @param str The string to strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodesFromPrompt('\\n\\\\[\\u001b[01;34m\\\\]\\\\w\\\\[\\u001b[00m\\\\]\\n\\\\[\\u001b[1;32m\\\\]> \\\\[\\u001b[0m\\\\]');\n * // '\\n\\\\w\\n> '\n */\nexport function removeAnsiEscapeCodesFromPrompt(str: string): string {\n\treturn removeAnsiEscapeCodes(str).replace(PROMPT_NON_PRINTABLE, '');\n}\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\tif (idx === -1) {\n\t\treturn str;\n\t}\n\n\tif (str[idx - 1] === '\\r') {\n\t\tidx--;\n\t}\n\n\treturn str.substr(0, idx);\n}\n\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n: number): string {\n\tconst LETTERS_CNT = (CharCode.Z - CharCode.A + 1);\n\n\tn = n % (2 * LETTERS_CNT);\n\n\tif (n < LETTERS_CNT) {\n\t\treturn String.fromCharCode(CharCode.a + n);\n\t}\n\n\treturn String.fromCharCode(CharCode.A + n - LETTERS_CNT);\n}\n\n//#region Unicode Grapheme Break\n\nexport function getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\treturn graphemeBreakTree.getGraphemeBreakType(codePoint);\n}\n\nfunction breakBetweenGraphemeBreakType(breakTypeA: GraphemeBreakType, breakTypeB: GraphemeBreakType): boolean {\n\t// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n\n\t// !!! Let's make the common case a bit faster\n\tif (breakTypeA === GraphemeBreakType.Other) {\n\t\t// see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n\t\treturn (breakTypeB !== GraphemeBreakType.Extend && breakTypeB !== GraphemeBreakType.SpacingMark);\n\t}\n\n\t// Do not break between a CR and LF. Otherwise, break before and after controls.\n\t// GB3                                        CR  LF\n\t// GB4                       (Control | CR | LF) \n\t// GB5                                            (Control | CR | LF)\n\tif (breakTypeA === GraphemeBreakType.CR) {\n\t\tif (breakTypeB === GraphemeBreakType.LF) {\n\t\t\treturn false; // GB3\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.Control || breakTypeA === GraphemeBreakType.CR || breakTypeA === GraphemeBreakType.LF) {\n\t\treturn true; // GB4\n\t}\n\tif (breakTypeB === GraphemeBreakType.Control || breakTypeB === GraphemeBreakType.CR || breakTypeB === GraphemeBreakType.LF) {\n\t\treturn true; // GB5\n\t}\n\n\t// Do not break Hangul syllable sequences.\n\t// GB6                                         L  (L | V | LV | LVT)\n\t// GB7                                  (LV | V)  (V | T)\n\t// GB8                                 (LVT | T)  T\n\tif (breakTypeA === GraphemeBreakType.L) {\n\t\tif (breakTypeB === GraphemeBreakType.L || breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.LV || breakTypeB === GraphemeBreakType.LVT) {\n\t\t\treturn false; // GB6\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LV || breakTypeA === GraphemeBreakType.V) {\n\t\tif (breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB7\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LVT || breakTypeA === GraphemeBreakType.T) {\n\t\tif (breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB8\n\t\t}\n\t}\n\n\t// Do not break before extending characters or ZWJ.\n\t// GB9                                            (Extend | ZWJ)\n\tif (breakTypeB === GraphemeBreakType.Extend || breakTypeB === GraphemeBreakType.ZWJ) {\n\t\treturn false; // GB9\n\t}\n\n\t// The GB9a and GB9b rules only apply to extended grapheme clusters:\n\t// Do not break before SpacingMarks, or after Prepend characters.\n\t// GB9a                                           SpacingMark\n\t// GB9b                                  Prepend \n\tif (breakTypeB === GraphemeBreakType.SpacingMark) {\n\t\treturn false; // GB9a\n\t}\n\tif (breakTypeA === GraphemeBreakType.Prepend) {\n\t\treturn false; // GB9b\n\t}\n\n\t// Do not break within emoji modifier sequences or emoji zwj sequences.\n\t// GB11    \\p{Extended_Pictographic} Extend* ZWJ  \\p{Extended_Pictographic}\n\tif (breakTypeA === GraphemeBreakType.ZWJ && breakTypeB === GraphemeBreakType.Extended_Pictographic) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB11\n\t}\n\n\t// GB12                          sot (RI RI)* RI  RI\n\t// GB13                        [^RI] (RI RI)* RI  RI\n\tif (breakTypeA === GraphemeBreakType.Regional_Indicator && breakTypeB === GraphemeBreakType.Regional_Indicator) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB12 & GB13\n\t}\n\n\t// GB999                                     Any  Any\n\treturn true;\n}\n\nexport const enum GraphemeBreakType {\n\tOther = 0,\n\tPrepend = 1,\n\tCR = 2,\n\tLF = 3,\n\tControl = 4,\n\tExtend = 5,\n\tRegional_Indicator = 6,\n\tSpacingMark = 7,\n\tL = 8,\n\tV = 9,\n\tT = 10,\n\tLV = 11,\n\tLVT = 12,\n\tZWJ = 13,\n\tExtended_Pictographic = 14\n}\n\nclass GraphemeBreakTree {\n\n\tprivate static _INSTANCE: GraphemeBreakTree | null = null;\n\tpublic static getInstance(): GraphemeBreakTree {\n\t\tif (!GraphemeBreakTree._INSTANCE) {\n\t\t\tGraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n\t\t}\n\t\treturn GraphemeBreakTree._INSTANCE;\n\t}\n\n\tprivate readonly _data: number[];\n\n\tconstructor() {\n\t\tthis._data = getGraphemeBreakRawData();\n\t}\n\n\tpublic getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\t\t// !!! Let's make 7bit ASCII a bit faster: 0..31\n\t\tif (codePoint < 32) {\n\t\t\tif (codePoint === CharCode.LineFeed) {\n\t\t\t\treturn GraphemeBreakType.LF;\n\t\t\t}\n\t\t\tif (codePoint === CharCode.CarriageReturn) {\n\t\t\t\treturn GraphemeBreakType.CR;\n\t\t\t}\n\t\t\treturn GraphemeBreakType.Control;\n\t\t}\n\t\t// !!! Let's make 7bit ASCII a bit faster: 32..126\n\t\tif (codePoint < 127) {\n\t\t\treturn GraphemeBreakType.Other;\n\t\t}\n\n\t\tconst data = this._data;\n\t\tconst nodeCount = data.length / 3;\n\t\tlet nodeIndex = 1;\n\t\twhile (nodeIndex <= nodeCount) {\n\t\t\tif (codePoint < data[3 * nodeIndex]) {\n\t\t\t\t// go left\n\t\t\t\tnodeIndex = 2 * nodeIndex;\n\t\t\t} else if (codePoint > data[3 * nodeIndex + 1]) {\n\t\t\t\t// go right\n\t\t\t\tnodeIndex = 2 * nodeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// hit\n\t\t\t\treturn data[3 * nodeIndex + 2];\n\t\t\t}\n\t\t}\n\n\t\treturn GraphemeBreakType.Other;\n\t}\n}\n\nfunction getGraphemeBreakRawData(): number[] {\n\t// generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\n\treturn JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\n}\n\n//#endregion\n\n/**\n * Computes the offset after performing a left delete on the given string,\n * while considering unicode grapheme/emoji rules.\n*/\nexport function getLeftDeleteOffset(offset: number, str: string): number {\n\tif (offset === 0) {\n\t\treturn 0;\n\t}\n\n\t// Try to delete emoji part.\n\tconst emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\n\tif (emojiOffset !== undefined) {\n\t\treturn emojiOffset;\n\t}\n\n\t// Otherwise, just skip a single code point.\n\tconst iterator = new CodePointIterator(str, offset);\n\titerator.prevCodePoint();\n\treturn iterator.offset;\n}\n\nfunction getOffsetBeforeLastEmojiComponent(initialOffset: number, str: string): number | undefined {\n\t// See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\n\t// structure of emojis.\n\tconst iterator = new CodePointIterator(str, initialOffset);\n\tlet codePoint = iterator.prevCodePoint();\n\n\t// Skip modifiers\n\twhile ((isEmojiModifier(codePoint) || codePoint === CodePoint.emojiVariantSelector || codePoint === CodePoint.enclosingKeyCap)) {\n\t\tif (iterator.offset === 0) {\n\t\t\t// Cannot skip modifier, no preceding emoji base.\n\t\t\treturn undefined;\n\t\t}\n\t\tcodePoint = iterator.prevCodePoint();\n\t}\n\n\t// Expect base emoji\n\tif (!isEmojiImprecise(codePoint)) {\n\t\t// Unexpected code point, not a valid emoji.\n\t\treturn undefined;\n\t}\n\n\tlet resultOffset = iterator.offset;\n\n\tif (resultOffset > 0) {\n\t\t// Skip optional ZWJ code points that combine multiple emojis.\n\t\t// In theory, we should check if that ZWJ actually combines multiple emojis\n\t\t// to prevent deleting ZWJs in situations we didn't account for.\n\t\tconst optionalZwjCodePoint = iterator.prevCodePoint();\n\t\tif (optionalZwjCodePoint === CodePoint.zwj) {\n\t\t\tresultOffset = iterator.offset;\n\t\t}\n\t}\n\n\treturn resultOffset;\n}\n\nfunction isEmojiModifier(codePoint: number): boolean {\n\treturn 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\n}\n\nconst enum CodePoint {\n\tzwj = 0x200D,\n\n\t/**\n\t * Variation Selector-16 (VS16)\n\t*/\n\temojiVariantSelector = 0xFE0F,\n\n\t/**\n\t * Combining Enclosing Keycap\n\t */\n\tenclosingKeyCap = 0x20E3,\n\n\tspace = 0x0020,\n}\n\nexport const noBreakWhitespace = '\\xa0';\n\nexport class AmbiguousCharacters {\n\tprivate static readonly ambiguousCharacterData = new Lazy<\n\t\tRecord<\n\t\t\tstring | '_common' | '_default',\n\t\t\t/* code point -> ascii code point */ number[]\n\t\t>\n\t>(() => {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\t// Stored as key1, value1, key2, value2, ...\n\t\treturn JSON.parse(\n\t\t\t'{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\\\"_default\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"cs\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"fr\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ja\\\":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],\\\"ko\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ru\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"zh-hans\\\":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],\\\"zh-hant\\\":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}'\n\t\t);\n\t});\n\n\tprivate static readonly cache = new LRUCachedFunction<string, AmbiguousCharacters>((localesStr) => {\n\t\tconst locales = localesStr.split(',');\n\n\t\tfunction arrayToMap(arr: number[]): Map<number, number> {\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (let i = 0; i < arr.length; i += 2) {\n\t\t\t\tresult.set(arr[i], arr[i + 1]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction mergeMaps(\n\t\t\tmap1: Map<number, number>,\n\t\t\tmap2: Map<number, number>\n\t\t): Map<number, number> {\n\t\t\tconst result = new Map<number, number>(map1);\n\t\t\tfor (const [key, value] of map2) {\n\t\t\t\tresult.set(key, value);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction intersectMaps(\n\t\t\tmap1: Map<number, number> | undefined,\n\t\t\tmap2: Map<number, number>\n\t\t) {\n\t\t\tif (!map1) {\n\t\t\t\treturn map2;\n\t\t\t}\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (const [key, value] of map1) {\n\t\t\t\tif (map2.has(key)) {\n\t\t\t\t\tresult.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst data = this.ambiguousCharacterData.value;\n\n\t\tlet filteredLocales = locales.filter(\n\t\t\t(l) => !l.startsWith('_') && Object.hasOwn(data, l)\n\t\t);\n\t\tif (filteredLocales.length === 0) {\n\t\t\tfilteredLocales = ['_default'];\n\t\t}\n\n\t\tlet languageSpecificMap: Map<number, number> | undefined = undefined;\n\t\tfor (const locale of filteredLocales) {\n\t\t\tconst map = arrayToMap(data[locale]);\n\t\t\tlanguageSpecificMap = intersectMaps(languageSpecificMap, map);\n\t\t}\n\n\t\tconst commonMap = arrayToMap(data['_common']);\n\t\tconst map = mergeMaps(commonMap, languageSpecificMap!);\n\n\t\treturn new AmbiguousCharacters(map);\n\t});\n\n\tpublic static getInstance(locales: Iterable<string>): AmbiguousCharacters {\n\t\treturn AmbiguousCharacters.cache.get(Array.from(locales).join(','));\n\t}\n\n\tprivate static _locales = new Lazy<string[]>(() =>\n\t\tObject.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter(\n\t\t\t(k) => !k.startsWith('_')\n\t\t)\n\t);\n\tpublic static getLocales(): string[] {\n\t\treturn AmbiguousCharacters._locales.value;\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly confusableDictionary: Map<number, number>\n\t) { }\n\n\tpublic isAmbiguous(codePoint: number): boolean {\n\t\treturn this.confusableDictionary.has(codePoint);\n\t}\n\n\tpublic containsAmbiguousCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && this.isAmbiguous(codePoint)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the non basic ASCII code point that the given code point can be confused,\n\t * or undefined if such code point does note exist.\n\t */\n\tpublic getPrimaryConfusable(codePoint: number): number | undefined {\n\t\treturn this.confusableDictionary.get(codePoint);\n\t}\n\n\tpublic getConfusableCodePoints(): ReadonlySet<number> {\n\t\treturn new Set(this.confusableDictionary.keys());\n\t}\n}\n\nexport class InvisibleCharacters {\n\tprivate static getRawData(): Record<string | '_common', number[]> {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\treturn JSON.parse('{\\\"_common\\\":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],\\\"cs\\\":[173,8203,12288],\\\"de\\\":[173,8203,12288],\\\"es\\\":[8203,12288],\\\"fr\\\":[173,8203,12288],\\\"it\\\":[160,173,12288],\\\"ja\\\":[173],\\\"ko\\\":[173,12288],\\\"pl\\\":[173,8203,12288],\\\"pt-BR\\\":[173,8203,12288],\\\"qps-ploc\\\":[160,173,8203,12288],\\\"ru\\\":[173,12288],\\\"tr\\\":[160,173,8203,12288],\\\"zh-hans\\\":[160,173,8203,12288],\\\"zh-hant\\\":[173,12288]}');\n\t}\n\n\tprivate static _data: Set<number> | undefined = undefined;\n\n\tprivate static getData() {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Set([...Object.values(InvisibleCharacters.getRawData())].flat());\n\t\t}\n\t\treturn this._data;\n\t}\n\n\tpublic static isInvisibleCharacter(codePoint: number): boolean {\n\t\treturn InvisibleCharacters.getData().has(codePoint);\n\t}\n\n\tpublic static containsInvisibleCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && (InvisibleCharacters.isInvisibleCharacter(codePoint) || codePoint === CodePoint.space)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static get codePoints(): ReadonlySet<number> {\n\t\treturn InvisibleCharacters.getData();\n\t}\n}\n\nexport const Ellipsis = '\\u2026';\n\n/**\n * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte\n *\n * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa\n */\nfunction toBinary(str: string): string {\n\tconst codeUnits = new Uint16Array(str.length);\n\tfor (let i = 0; i < codeUnits.length; i++) {\n\t\tcodeUnits[i] = str.charCodeAt(i);\n\t}\n\tlet binary = '';\n\tconst uint8array = new Uint8Array(codeUnits.buffer);\n\tfor (let i = 0; i < uint8array.length; i++) {\n\t\tbinary += String.fromCharCode(uint8array[i]);\n\t}\n\treturn binary;\n}\n\n/**\n * Version of the global `btoa` function that handles multi-byte characters instead\n * of throwing an exception.\n */\n\nexport function multibyteAwareBtoa(str: string): string {\n\treturn btoa(toBinary(str));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCachedFunction } from './cache.js';\nimport { CharCode } from './charCode.js';\nimport { Lazy } from './lazy.js';\nimport { Constants } from './uint.js';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\nconst _format2Regexp = /{([^}]+)}/g;\n\n/**\n * Helper to create a string from a template and a string record.\n * Similar to `format` but with objects instead of positional arguments.\n */\nexport function format2(template: string, values: Record<string, unknown>): string {\n\tif (Object.keys(values).length === 0) {\n\t\treturn template;\n\t}\n\treturn template.replace(_format2Regexp, (match, group) => (values[group] ?? match) as string);\n}\n\n/**\n * Encodes the given value so that it can be used as literal value in html attributes.\n *\n * In other words, computes `$val`, such that `attr` in `<div attr=\"$val\" />` has the runtime value `value`.\n * This prevents XSS injection.\n */\nexport function htmlAttributeEncodeValue(value: string): string {\n\treturn value.replace(/[<>\"'&]/g, ch => {\n\t\tswitch (ch) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '\"': return '&quot;';\n\t\t\tcase '\\'': return '&apos;';\n\t\t\tcase '&': return '&amp;';\n\t\t}\n\t\treturn ch;\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n\n/**\n * Counts how often `substr` occurs inside `value`.\n */\nexport function count(value: string, substr: string): number {\n\tlet result = 0;\n\tlet index = value.indexOf(substr);\n\twhile (index !== -1) {\n\t\tresult++;\n\t\tindex = value.indexOf(substr, index + substr.length);\n\t}\n\treturn result;\n}\n\nexport function truncate(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\treturn `${value.substr(0, maxLength)}${suffix}`;\n}\n\nexport function truncateMiddle(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\tconst prefixLength = Math.ceil(maxLength / 2) - suffix.length / 2;\n\tconst suffixLength = Math.floor(maxLength / 2) - suffix.length / 2;\n\n\treturn `${value.substr(0, prefixLength)}${suffix}${value.substr(value.length - suffixLength)}`;\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tlet offset = 0;\n\tif (needleLen === 1) {\n\t\tconst ch = needle.charCodeAt(0);\n\t\twhile (offset < haystack.length && haystack.charCodeAt(offset) === ch) {\n\t\t\toffset++;\n\t\t}\n\t} else {\n\t\twhile (haystack.startsWith(needle, offset)) {\n\t\t\toffset += needleLen;\n\t\t}\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 1) {\n\t\tlet end = haystackLen;\n\t\tconst ch = needle.charCodeAt(0);\n\t\twhile (end > 0 && haystack.charCodeAt(end - 1) === ch) {\n\t\t\tend--;\n\t\t}\n\t\treturn haystack.substring(0, end);\n\t}\n\n\tlet offset = haystackLen;\n\twhile (offset > 0 && haystack.endsWith(needle, offset)) {\n\t\toffset -= needleLen;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && regexp.lastIndex === 0);\n}\n\nexport function joinStrings(items: (string | undefined | null | false)[], separator: string): string {\n\treturn items.filter(item => item !== undefined && item !== null && item !== false).join(separator);\n}\n\nexport function splitLines(str: string): string[] {\n\treturn str.split(/\\r\\n|\\r|\\n/);\n}\n\nexport function splitLinesIncludeSeparators(str: string): string[] {\n\tconst linesWithSeparators: string[] = [];\n\tconst splitLinesAndSeparators = str.split(/(\\r\\n|\\r|\\n)/);\n\tfor (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {\n\t\tlinesWithSeparators.push(splitLinesAndSeparators[2 * i] + (splitLinesAndSeparators[2 * i + 1] ?? ''));\n\t}\n\treturn linesWithSeparators;\n}\n\nexport function indexOfPattern(str: string, re: RegExp) {\n\tconst match = re.exec(str);\n\tif (match) {\n\t\treturn match.index;\n\t}\n\treturn -1;\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function getIndentationLength(str: string): number {\n\tconst idx = firstNonWhitespaceIndex(str);\n\tif (idx === -1) { return str.length; }\n\treturn idx;\n}\n\n/**\n * Function that works identically to String.prototype.replace, except, the\n * replace function is allowed to be async and return a Promise.\n */\nexport function replaceAsync(str: string, search: RegExp, replacer: (match: string, ...args: unknown[]) => Promise<string>): Promise<string> {\n\tconst parts: (string | Promise<string>)[] = [];\n\n\tlet last = 0;\n\tfor (const match of str.matchAll(search)) {\n\t\tparts.push(str.slice(last, match.index));\n\t\tif (match.index === undefined) {\n\t\t\tthrow new Error('match.index should be defined');\n\t\t}\n\n\t\tlast = match.index + match[0].length;\n\t\tparts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));\n\t}\n\n\tparts.push(str.slice(last));\n\n\treturn Promise.all(parts).then(p => p.join(''));\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\t\tconst codeA = a.charCodeAt(aStart);\n\t\tconst codeB = b.charCodeAt(bStart);\n\t\tif (codeA < codeB) {\n\t\t\treturn -1;\n\t\t} else if (codeA > codeB) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\treturn compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (codeA >= 128 || codeB >= 128) {\n\t\t\t// not ASCII letters -> fallback to lower-casing strings\n\t\t\treturn compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n\t\t}\n\n\t\t// mapper lower-case ascii letter onto upper-case varinats\n\t\t// [97-122] (lower ascii) --> [65-90] (upper ascii)\n\t\tif (isLowerAsciiLetter(codeA)) {\n\t\t\tcodeA -= 32;\n\t\t}\n\t\tif (isLowerAsciiLetter(codeB)) {\n\t\t\tcodeB -= 32;\n\t\t}\n\n\t\t// compare both code points\n\t\tconst diff = codeA - codeB;\n\t\tif (diff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nexport function isAsciiDigit(code: number): boolean {\n\treturn code >= CharCode.Digit0 && code <= CharCode.Digit9;\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\treturn a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\n\nexport function equals(a: string | undefined, b: string | undefined, ignoreCase?: boolean): boolean {\n\treturn a === b || (!!ignoreCase && a !== undefined && b !== undefined && equalsIgnoreCase(a, b));\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst len = candidate.length;\n\treturn len <= str.length && compareSubstringIgnoreCase(str, candidate, 0, len) === 0;\n}\n\nexport function endsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst len = str.length;\n\tconst start = len - candidate.length;\n\treturn start >= 0 && compareSubstringIgnoreCase(str, candidate, start, len) === 0;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate: number, lowSurrogate: number): number {\n\treturn ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str: string, len: number, offset: number): number {\n\tconst charCode = str.charCodeAt(offset);\n\tif (isHighSurrogate(charCode) && offset + 1 < len) {\n\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\tif (isLowSurrogate(nextCharCode)) {\n\t\t\treturn computeCodePoint(charCode, nextCharCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str: string, offset: number): number {\n\tconst charCode = str.charCodeAt(offset - 1);\n\tif (isLowSurrogate(charCode) && offset > 1) {\n\t\tconst prevCharCode = str.charCodeAt(offset - 2);\n\t\tif (isHighSurrogate(prevCharCode)) {\n\t\t\treturn computeCodePoint(prevCharCode, charCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\nexport class CodePointIterator {\n\n\tprivate readonly _str: string;\n\tprivate readonly _len: number;\n\tprivate _offset: number;\n\n\tpublic get offset(): number {\n\t\treturn this._offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._str = str;\n\t\tthis._len = str.length;\n\t\tthis._offset = offset;\n\t}\n\n\tpublic setOffset(offset: number): void {\n\t\tthis._offset = offset;\n\t}\n\n\tpublic prevCodePoint(): number {\n\t\tconst codePoint = getPrevCodePoint(this._str, this._offset);\n\t\tthis._offset -= (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic nextCodePoint(): number {\n\t\tconst codePoint = getNextCodePoint(this._str, this._len, this._offset);\n\t\tthis._offset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn (this._offset >= this._len);\n\t}\n}\n\nexport class GraphemeIterator {\n\n\tprivate readonly _iterator: CodePointIterator;\n\n\tpublic get offset(): number {\n\t\treturn this._iterator.offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._iterator = new CodePointIterator(str, offset);\n\t}\n\n\tpublic nextGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\twhile (!iterator.eol()) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = nextGraphemeBreakType;\n\t\t}\n\t\treturn (iterator.offset - initialOffset);\n\t}\n\n\tpublic prevGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\twhile (iterator.offset > 0) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = prevGraphemeBreakType;\n\t\t}\n\t\treturn (initialOffset - iterator.offset);\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn this._iterator.eol();\n\t}\n}\n\nexport function nextCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.nextGraphemeLength();\n}\n\nexport function prevCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.prevGraphemeLength();\n}\n\nexport function getCharContainingOffset(str: string, offset: number): [number, number] {\n\tif (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n\t\toffset--;\n\t}\n\tconst endOffset = offset + nextCharLength(str, offset);\n\tconst startOffset = endOffset - prevCharLength(str, endOffset);\n\treturn [startOffset, endOffset];\n}\n\nexport function charCount(str: string): number {\n\tconst iterator = new GraphemeIterator(str);\n\tlet length = 0;\n\twhile (!iterator.eol()) {\n\t\tlength++;\n\t\titerator.nextGraphemeLength();\n\t}\n\treturn length;\n}\n\nlet CONTAINS_RTL: RegExp | undefined = undefined;\n\nfunction makeContainsRtl() {\n\t// Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\n\treturn /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n}\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\tif (!CONTAINS_RTL) {\n\t\tCONTAINS_RTL = makeContainsRtl();\n\t}\n\n\treturn CONTAINS_RTL.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str: string): boolean {\n\treturn UNUSUAL_LINE_TERMINATORS.test(str);\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 - 2EFF   CJK Radicals Supplement\n\t//          2F00 - 2FDF   Kangxi Radicals\n\t//          2FF0 - 2FFF   Ideographic Description Characters\n\t//          3000 - 303F   CJK Symbols and Punctuation\n\t//          3040 - 309F   Hiragana\n\t//          30A0 - 30FF   Katakana\n\t//          3100 - 312F   Bopomofo\n\t//          3130 - 318F   Hangul Compatibility Jamo\n\t//          3190 - 319F   Kanbun\n\t//          31A0 - 31BF   Bopomofo Extended\n\t//          31F0 - 31FF   Katakana Phonetic Extensions\n\t//          3200 - 32FF   Enclosed CJK Letters and Months\n\t//          3300 - 33FF   CJK Compatibility\n\t//          3400 - 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 - 4DFF   Yijing Hexagram Symbols\n\t//          4E00 - 9FFF   CJK Unified Ideographs\n\t//          A000 - A48F   Yi Syllables\n\t//          A490 - A4CF   Yi Radicals\n\t//          AC00 - D7AF   Hangul Syllables\n\t// [IGNORE] D800 - DB7F   High Surrogates\n\t// [IGNORE] DB80 - DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 - DFFF   Low Surrogates\n\t// [IGNORE] E000 - F8FF   Private Use Area\n\t//          F900 - FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 - FE0F   Variation Selectors\n\t// [IGNORE] FE20 - FE2F   Combining Half Marks\n\t// [IGNORE] FE30 - FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 - FE6F   Small Form Variants\n\t// [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\n\t//          FF00 - FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 - FFFF   Specials\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\n */\nexport function isEmojiImprecise(x: number): boolean {\n\treturn (\n\t\t(x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n\t\t|| (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n\t\t|| (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n\t\t|| (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\n\t\t|| (x >= 129648 && x <= 129782)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n * The return value can be longer than the given value of `n`. Leading whitespace is always trimmed.\n */\nexport function lcut(text: string, n: number, prefix = ''): string {\n\tconst trimmed = text.trimStart();\n\n\tif (trimmed.length < n) {\n\t\treturn trimmed;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(trimmed)) {\n\t\tif (trimmed.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\tif (i === 0) {\n\t\treturn trimmed;\n\t}\n\n\treturn prefix + trimmed.substring(i).trimStart();\n}\n\n// Defacto standard: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html\nconst CSI_SEQUENCE = /(?:\\x1b\\[|\\x9b)[=?>!]?[\\d;:]*[\"$#'* ]?[a-zA-Z@^`{}|~]/;\nconst OSC_SEQUENCE = /(?:\\x1b\\]|\\x9d).*?(?:\\x1b\\\\|\\x07|\\x9c)/;\nconst ESC_SEQUENCE = /\\x1b(?:[ #%\\(\\)\\*\\+\\-\\.\\/]?[a-zA-Z0-9\\|}~@])/;\nconst CONTROL_SEQUENCES = new RegExp('(?:' + [\n\tCSI_SEQUENCE.source,\n\tOSC_SEQUENCE.source,\n\tESC_SEQUENCE.source,\n].join('|') + ')', 'g');\n\n/** Iterates over parts of a string with CSI sequences */\nexport function* forAnsiStringParts(str: string) {\n\tlet last = 0;\n\tfor (const match of str.matchAll(CONTROL_SEQUENCES)) {\n\t\tif (last !== match.index) {\n\t\t\tyield { isCode: false, str: str.substring(last, match.index) };\n\t\t}\n\n\t\tyield { isCode: true, str: match[0] };\n\t\tlast = match.index + match[0].length;\n\t}\n\n\tif (last !== str.length) {\n\t\tyield { isCode: false, str: str.substring(last) };\n\t}\n}\n\n/**\n * Strips ANSI escape sequences from a string.\n * @param str The dastringa stringo strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodes('\\u001b[31mHello, World!\\u001b[0m');\n * // 'Hello, World!'\n */\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(CONTROL_SEQUENCES, '');\n\t}\n\n\treturn str;\n}\n\nconst PROMPT_NON_PRINTABLE = /\\\\\\[.*?\\\\\\]/g;\n\n/**\n * Strips ANSI escape sequences from a UNIX-style prompt string (eg. `$PS1`).\n * @param str The string to strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodesFromPrompt('\\n\\\\[\\u001b[01;34m\\\\]\\\\w\\\\[\\u001b[00m\\\\]\\n\\\\[\\u001b[1;32m\\\\]> \\\\[\\u001b[0m\\\\]');\n * // '\\n\\\\w\\n> '\n */\nexport function removeAnsiEscapeCodesFromPrompt(str: string): string {\n\treturn removeAnsiEscapeCodes(str).replace(PROMPT_NON_PRINTABLE, '');\n}\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\tif (idx === -1) {\n\t\treturn str;\n\t}\n\n\tif (str[idx - 1] === '\\r') {\n\t\tidx--;\n\t}\n\n\treturn str.substr(0, idx);\n}\n\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n: number): string {\n\tconst LETTERS_CNT = (CharCode.Z - CharCode.A + 1);\n\n\tn = n % (2 * LETTERS_CNT);\n\n\tif (n < LETTERS_CNT) {\n\t\treturn String.fromCharCode(CharCode.a + n);\n\t}\n\n\treturn String.fromCharCode(CharCode.A + n - LETTERS_CNT);\n}\n\n//#region Unicode Grapheme Break\n\nexport function getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\treturn graphemeBreakTree.getGraphemeBreakType(codePoint);\n}\n\nfunction breakBetweenGraphemeBreakType(breakTypeA: GraphemeBreakType, breakTypeB: GraphemeBreakType): boolean {\n\t// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n\n\t// !!! Let's make the common case a bit faster\n\tif (breakTypeA === GraphemeBreakType.Other) {\n\t\t// see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n\t\treturn (breakTypeB !== GraphemeBreakType.Extend && breakTypeB !== GraphemeBreakType.SpacingMark);\n\t}\n\n\t// Do not break between a CR and LF. Otherwise, break before and after controls.\n\t// GB3                                        CR  LF\n\t// GB4                       (Control | CR | LF) \n\t// GB5                                            (Control | CR | LF)\n\tif (breakTypeA === GraphemeBreakType.CR) {\n\t\tif (breakTypeB === GraphemeBreakType.LF) {\n\t\t\treturn false; // GB3\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.Control || breakTypeA === GraphemeBreakType.CR || breakTypeA === GraphemeBreakType.LF) {\n\t\treturn true; // GB4\n\t}\n\tif (breakTypeB === GraphemeBreakType.Control || breakTypeB === GraphemeBreakType.CR || breakTypeB === GraphemeBreakType.LF) {\n\t\treturn true; // GB5\n\t}\n\n\t// Do not break Hangul syllable sequences.\n\t// GB6                                         L  (L | V | LV | LVT)\n\t// GB7                                  (LV | V)  (V | T)\n\t// GB8                                 (LVT | T)  T\n\tif (breakTypeA === GraphemeBreakType.L) {\n\t\tif (breakTypeB === GraphemeBreakType.L || breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.LV || breakTypeB === GraphemeBreakType.LVT) {\n\t\t\treturn false; // GB6\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LV || breakTypeA === GraphemeBreakType.V) {\n\t\tif (breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB7\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LVT || breakTypeA === GraphemeBreakType.T) {\n\t\tif (breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB8\n\t\t}\n\t}\n\n\t// Do not break before extending characters or ZWJ.\n\t// GB9                                            (Extend | ZWJ)\n\tif (breakTypeB === GraphemeBreakType.Extend || breakTypeB === GraphemeBreakType.ZWJ) {\n\t\treturn false; // GB9\n\t}\n\n\t// The GB9a and GB9b rules only apply to extended grapheme clusters:\n\t// Do not break before SpacingMarks, or after Prepend characters.\n\t// GB9a                                           SpacingMark\n\t// GB9b                                  Prepend \n\tif (breakTypeB === GraphemeBreakType.SpacingMark) {\n\t\treturn false; // GB9a\n\t}\n\tif (breakTypeA === GraphemeBreakType.Prepend) {\n\t\treturn false; // GB9b\n\t}\n\n\t// Do not break within emoji modifier sequences or emoji zwj sequences.\n\t// GB11    \\p{Extended_Pictographic} Extend* ZWJ  \\p{Extended_Pictographic}\n\tif (breakTypeA === GraphemeBreakType.ZWJ && breakTypeB === GraphemeBreakType.Extended_Pictographic) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB11\n\t}\n\n\t// GB12                          sot (RI RI)* RI  RI\n\t// GB13                        [^RI] (RI RI)* RI  RI\n\tif (breakTypeA === GraphemeBreakType.Regional_Indicator && breakTypeB === GraphemeBreakType.Regional_Indicator) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB12 & GB13\n\t}\n\n\t// GB999                                     Any  Any\n\treturn true;\n}\n\nexport const enum GraphemeBreakType {\n\tOther = 0,\n\tPrepend = 1,\n\tCR = 2,\n\tLF = 3,\n\tControl = 4,\n\tExtend = 5,\n\tRegional_Indicator = 6,\n\tSpacingMark = 7,\n\tL = 8,\n\tV = 9,\n\tT = 10,\n\tLV = 11,\n\tLVT = 12,\n\tZWJ = 13,\n\tExtended_Pictographic = 14\n}\n\nclass GraphemeBreakTree {\n\n\tprivate static _INSTANCE: GraphemeBreakTree | null = null;\n\tpublic static getInstance(): GraphemeBreakTree {\n\t\tif (!GraphemeBreakTree._INSTANCE) {\n\t\t\tGraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n\t\t}\n\t\treturn GraphemeBreakTree._INSTANCE;\n\t}\n\n\tprivate readonly _data: number[];\n\n\tconstructor() {\n\t\tthis._data = getGraphemeBreakRawData();\n\t}\n\n\tpublic getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\t\t// !!! Let's make 7bit ASCII a bit faster: 0..31\n\t\tif (codePoint < 32) {\n\t\t\tif (codePoint === CharCode.LineFeed) {\n\t\t\t\treturn GraphemeBreakType.LF;\n\t\t\t}\n\t\t\tif (codePoint === CharCode.CarriageReturn) {\n\t\t\t\treturn GraphemeBreakType.CR;\n\t\t\t}\n\t\t\treturn GraphemeBreakType.Control;\n\t\t}\n\t\t// !!! Let's make 7bit ASCII a bit faster: 32..126\n\t\tif (codePoint < 127) {\n\t\t\treturn GraphemeBreakType.Other;\n\t\t}\n\n\t\tconst data = this._data;\n\t\tconst nodeCount = data.length / 3;\n\t\tlet nodeIndex = 1;\n\t\twhile (nodeIndex <= nodeCount) {\n\t\t\tif (codePoint < data[3 * nodeIndex]) {\n\t\t\t\t// go left\n\t\t\t\tnodeIndex = 2 * nodeIndex;\n\t\t\t} else if (codePoint > data[3 * nodeIndex + 1]) {\n\t\t\t\t// go right\n\t\t\t\tnodeIndex = 2 * nodeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// hit\n\t\t\t\treturn data[3 * nodeIndex + 2];\n\t\t\t}\n\t\t}\n\n\t\treturn GraphemeBreakType.Other;\n\t}\n}\n\nfunction getGraphemeBreakRawData(): number[] {\n\t// generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\n\treturn JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\n}\n\n//#endregion\n\n/**\n * Computes the offset after performing a left delete on the given string,\n * while considering unicode grapheme/emoji rules.\n*/\nexport function getLeftDeleteOffset(offset: number, str: string): number {\n\tif (offset === 0) {\n\t\treturn 0;\n\t}\n\n\t// Try to delete emoji part.\n\tconst emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\n\tif (emojiOffset !== undefined) {\n\t\treturn emojiOffset;\n\t}\n\n\t// Otherwise, just skip a single code point.\n\tconst iterator = new CodePointIterator(str, offset);\n\titerator.prevCodePoint();\n\treturn iterator.offset;\n}\n\nfunction getOffsetBeforeLastEmojiComponent(initialOffset: number, str: string): number | undefined {\n\t// See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\n\t// structure of emojis.\n\tconst iterator = new CodePointIterator(str, initialOffset);\n\tlet codePoint = iterator.prevCodePoint();\n\n\t// Skip modifiers\n\twhile ((isEmojiModifier(codePoint) || codePoint === CodePoint.emojiVariantSelector || codePoint === CodePoint.enclosingKeyCap)) {\n\t\tif (iterator.offset === 0) {\n\t\t\t// Cannot skip modifier, no preceding emoji base.\n\t\t\treturn undefined;\n\t\t}\n\t\tcodePoint = iterator.prevCodePoint();\n\t}\n\n\t// Expect base emoji\n\tif (!isEmojiImprecise(codePoint)) {\n\t\t// Unexpected code point, not a valid emoji.\n\t\treturn undefined;\n\t}\n\n\tlet resultOffset = iterator.offset;\n\n\tif (resultOffset > 0) {\n\t\t// Skip optional ZWJ code points that combine multiple emojis.\n\t\t// In theory, we should check if that ZWJ actually combines multiple emojis\n\t\t// to prevent deleting ZWJs in situations we didn't account for.\n\t\tconst optionalZwjCodePoint = iterator.prevCodePoint();\n\t\tif (optionalZwjCodePoint === CodePoint.zwj) {\n\t\t\tresultOffset = iterator.offset;\n\t\t}\n\t}\n\n\treturn resultOffset;\n}\n\nfunction isEmojiModifier(codePoint: number): boolean {\n\treturn 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\n}\n\nconst enum CodePoint {\n\tzwj = 0x200D,\n\n\t/**\n\t * Variation Selector-16 (VS16)\n\t*/\n\temojiVariantSelector = 0xFE0F,\n\n\t/**\n\t * Combining Enclosing Keycap\n\t */\n\tenclosingKeyCap = 0x20E3,\n\n\tspace = 0x0020,\n}\n\nexport const noBreakWhitespace = '\\xa0';\n\nexport class AmbiguousCharacters {\n\tprivate static readonly ambiguousCharacterData = new Lazy<\n\t\tRecord<\n\t\t\tstring | '_common' | '_default',\n\t\t\t/* code point -> ascii code point */ number[]\n\t\t>\n\t>(() => {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\t// Stored as key1, value1, key2, value2, ...\n\t\treturn JSON.parse(\n\t\t\t'{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\\\"_default\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"cs\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"fr\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ja\\\":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],\\\"ko\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ru\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"zh-hans\\\":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],\\\"zh-hant\\\":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}'\n\t\t);\n\t});\n\n\tprivate static readonly cache = new LRUCachedFunction<string, AmbiguousCharacters>((localesStr) => {\n\t\tconst locales = localesStr.split(',');\n\n\t\tfunction arrayToMap(arr: number[]): Map<number, number> {\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (let i = 0; i < arr.length; i += 2) {\n\t\t\t\tresult.set(arr[i], arr[i + 1]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction mergeMaps(\n\t\t\tmap1: Map<number, number>,\n\t\t\tmap2: Map<number, number>\n\t\t): Map<number, number> {\n\t\t\tconst result = new Map<number, number>(map1);\n\t\t\tfor (const [key, value] of map2) {\n\t\t\t\tresult.set(key, value);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction intersectMaps(\n\t\t\tmap1: Map<number, number> | undefined,\n\t\t\tmap2: Map<number, number>\n\t\t) {\n\t\t\tif (!map1) {\n\t\t\t\treturn map2;\n\t\t\t}\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (const [key, value] of map1) {\n\t\t\t\tif (map2.has(key)) {\n\t\t\t\t\tresult.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst data = this.ambiguousCharacterData.value;\n\n\t\tlet filteredLocales = locales.filter(\n\t\t\t(l) => !l.startsWith('_') && Object.hasOwn(data, l)\n\t\t);\n\t\tif (filteredLocales.length === 0) {\n\t\t\tfilteredLocales = ['_default'];\n\t\t}\n\n\t\tlet languageSpecificMap: Map<number, number> | undefined = undefined;\n\t\tfor (const locale of filteredLocales) {\n\t\t\tconst map = arrayToMap(data[locale]);\n\t\t\tlanguageSpecificMap = intersectMaps(languageSpecificMap, map);\n\t\t}\n\n\t\tconst commonMap = arrayToMap(data['_common']);\n\t\tconst map = mergeMaps(commonMap, languageSpecificMap!);\n\n\t\treturn new AmbiguousCharacters(map);\n\t});\n\n\tpublic static getInstance(locales: Iterable<string>): AmbiguousCharacters {\n\t\treturn AmbiguousCharacters.cache.get(Array.from(locales).join(','));\n\t}\n\n\tprivate static _locales = new Lazy<string[]>(() =>\n\t\tObject.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter(\n\t\t\t(k) => !k.startsWith('_')\n\t\t)\n\t);\n\tpublic static getLocales(): string[] {\n\t\treturn AmbiguousCharacters._locales.value;\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly confusableDictionary: Map<number, number>\n\t) { }\n\n\tpublic isAmbiguous(codePoint: number): boolean {\n\t\treturn this.confusableDictionary.has(codePoint);\n\t}\n\n\tpublic containsAmbiguousCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && this.isAmbiguous(codePoint)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the non basic ASCII code point that the given code point can be confused,\n\t * or undefined if such code point does note exist.\n\t */\n\tpublic getPrimaryConfusable(codePoint: number): number | undefined {\n\t\treturn this.confusableDictionary.get(codePoint);\n\t}\n\n\tpublic getConfusableCodePoints(): ReadonlySet<number> {\n\t\treturn new Set(this.confusableDictionary.keys());\n\t}\n}\n\nexport class InvisibleCharacters {\n\tprivate static getRawData(): Record<string | '_common', number[]> {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\treturn JSON.parse('{\\\"_common\\\":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],\\\"cs\\\":[173,8203,12288],\\\"de\\\":[173,8203,12288],\\\"es\\\":[8203,12288],\\\"fr\\\":[173,8203,12288],\\\"it\\\":[160,173,12288],\\\"ja\\\":[173],\\\"ko\\\":[173,12288],\\\"pl\\\":[173,8203,12288],\\\"pt-BR\\\":[173,8203,12288],\\\"qps-ploc\\\":[160,173,8203,12288],\\\"ru\\\":[173,12288],\\\"tr\\\":[160,173,8203,12288],\\\"zh-hans\\\":[160,173,8203,12288],\\\"zh-hant\\\":[173,12288]}');\n\t}\n\n\tprivate static _data: Set<number> | undefined = undefined;\n\n\tprivate static getData() {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Set([...Object.values(InvisibleCharacters.getRawData())].flat());\n\t\t}\n\t\treturn this._data;\n\t}\n\n\tpublic static isInvisibleCharacter(codePoint: number): boolean {\n\t\treturn InvisibleCharacters.getData().has(codePoint);\n\t}\n\n\tpublic static containsInvisibleCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && (InvisibleCharacters.isInvisibleCharacter(codePoint) || codePoint === CodePoint.space)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static get codePoints(): ReadonlySet<number> {\n\t\treturn InvisibleCharacters.getData();\n\t}\n}\n\nexport const Ellipsis = '\\u2026';\n\n/**\n * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte\n *\n * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa\n */\nfunction toBinary(str: string): string {\n\tconst codeUnits = new Uint16Array(str.length);\n\tfor (let i = 0; i < codeUnits.length; i++) {\n\t\tcodeUnits[i] = str.charCodeAt(i);\n\t}\n\tlet binary = '';\n\tconst uint8array = new Uint8Array(codeUnits.buffer);\n\tfor (let i = 0; i < uint8array.length; i++) {\n\t\tbinary += String.fromCharCode(uint8array[i]);\n\t}\n\treturn binary;\n}\n\n/**\n * Version of the global `btoa` function that handles multi-byte characters instead\n * of throwing an exception.\n */\n\nexport function multibyteAwareBtoa(str: string): string {\n\treturn btoa(toBinary(str));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { isAbsolute, join, normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from './strings.js';\nimport { isNumber } from './types.js';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\treturn removeTrailingPathSeparator(candidate);\n}\n\nexport function removeTrailingPathSeparator(candidate: string): string {\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined;\n\tlet line: number | undefined;\n\tlet column: number | undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { isAbsolute, join, normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from './strings.js';\nimport { isNumber } from './types.js';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\treturn removeTrailingPathSeparator(candidate);\n}\n\nexport function removeTrailingPathSeparator(candidate: string): string {\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined;\n\tlet line: number | undefined;\n\tlet column: number | undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { MarshalledId } from './marshallingIds.js';\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: unknown): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\t/**\n\t * Creates new URI from uri components.\n\t *\n\t * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n\t * validation and should be used for untrusted uri components retrieved from storage,\n\t * user input, command arguments etc\n\t */\n\tstatic from(components: UriComponents, strict?: boolean): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t\tstrict\n\t\t);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(`[UriError]: cannot call joinPath on URI without path`);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === 'file') {\n\t\t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\t/**\n\t * A helper function to revive URIs.\n\t *\n\t * **Note** that this function should only be used when receiving URI#toJSON generated data\n\t * and that it doesn't do any validation. Use {@link URI.from} when received \"untrusted\"\n\t * uri components such as command arguments or data from storage.\n\t *\n\t * @param data The URI components or URI to revive.\n\t * @returns The revived URI or undefined or null.\n\t */\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external ?? null;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath ?? null : null;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t[Symbol.for('debug.description')]() {\n\t\treturn `URI(${this.toString()})`;\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority?: string;\n\tpath?: string;\n\tquery?: string;\n\tfragment?: string;\n}\n\nexport function isUriComponents(thing: unknown): thing is UriComponents {\n\tif (!thing || typeof thing !== 'object') {\n\t\treturn false;\n\t}\n\treturn typeof (<UriComponents>thing).scheme === 'string'\n\t\t&& (typeof (<UriComponents>thing).authority === 'string' || typeof (<UriComponents>thing).authority === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).path === 'string' || typeof (<UriComponents>thing).path === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).query === 'string' || typeof (<UriComponents>thing).query === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).fragment === 'string' || typeof (<UriComponents>thing).fragment === 'undefined');\n}\n\ninterface UriState extends UriComponents {\n\t$mid: MarshalledId.Uri;\n\texternal?: string;\n\tfsPath?: string;\n\t_sep?: 1;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tconst res = <UriState>{\n\t\t\t$mid: MarshalledId.Uri\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t//--- uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\t// TODO\n\t\t// this isn't correct and can violate the UriComponents contract but\n\t\t// this is part of the vscode.Uri API and we shouldn't change how that\n\t\t// works anymore\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, isPath: boolean, isAuthority: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (isPath && code === CharCode.Slash)\n\t\t\t|| (isAuthority && code === CharCode.OpenSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.CloseSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.Colon)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.lastIndexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false, false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false, true);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.lastIndexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false, true);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false, true);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true, false);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { MarshalledId } from './marshallingIds.js';\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: unknown): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\t/**\n\t * Creates new URI from uri components.\n\t *\n\t * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n\t * validation and should be used for untrusted uri components retrieved from storage,\n\t * user input, command arguments etc\n\t */\n\tstatic from(components: UriComponents, strict?: boolean): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t\tstrict\n\t\t);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(`[UriError]: cannot call joinPath on URI without path`);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === 'file') {\n\t\t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\t/**\n\t * A helper function to revive URIs.\n\t *\n\t * **Note** that this function should only be used when receiving URI#toJSON generated data\n\t * and that it doesn't do any validation. Use {@link URI.from} when received \"untrusted\"\n\t * uri components such as command arguments or data from storage.\n\t *\n\t * @param data The URI components or URI to revive.\n\t * @returns The revived URI or undefined or null.\n\t */\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external ?? null;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath ?? null : null;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t[Symbol.for('debug.description')]() {\n\t\treturn `URI(${this.toString()})`;\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority?: string;\n\tpath?: string;\n\tquery?: string;\n\tfragment?: string;\n}\n\nexport function isUriComponents(thing: unknown): thing is UriComponents {\n\tif (!thing || typeof thing !== 'object') {\n\t\treturn false;\n\t}\n\treturn typeof (<UriComponents>thing).scheme === 'string'\n\t\t&& (typeof (<UriComponents>thing).authority === 'string' || typeof (<UriComponents>thing).authority === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).path === 'string' || typeof (<UriComponents>thing).path === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).query === 'string' || typeof (<UriComponents>thing).query === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).fragment === 'string' || typeof (<UriComponents>thing).fragment === 'undefined');\n}\n\ninterface UriState extends UriComponents {\n\t$mid: MarshalledId.Uri;\n\texternal?: string;\n\tfsPath?: string;\n\t_sep?: 1;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tconst res = <UriState>{\n\t\t\t$mid: MarshalledId.Uri\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t//--- uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\t// TODO\n\t\t// this isn't correct and can violate the UriComponents contract but\n\t\t// this is part of the vscode.Uri API and we shouldn't change how that\n\t\t// works anymore\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, isPath: boolean, isAuthority: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (isPath && code === CharCode.Slash)\n\t\t\t|| (isAuthority && code === CharCode.OpenSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.CloseSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.Colon)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.lastIndexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false, false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false, true);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.lastIndexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false, true);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false, true);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true, false);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from './errors.js';\nimport * as platform from './platform.js';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from './strings.js';\nimport { URI } from './uri.js';\nimport * as paths from './path.js';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellMetadataDiff = 'vscode-notebook-cell-metadata-diff';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeNotebookCellOutputDiff = 'vscode-notebook-cell-output-diff';\n\texport const vscodeNotebookMetadata = 'vscode-notebook-metadata';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/** Scheme used for code blocks in chat. */\n\texport const vscodeChatCodeBlock = 'vscode-chat-code-block';\n\n\t/** Scheme used for LHS of code compare (aka diff) blocks in chat. */\n\texport const vscodeChatCodeCompareBlock = 'vscode-chat-code-compare-block';\n\n\t/** Scheme used for the chat input editor. */\n\texport const vscodeChatEditor = 'vscode-chat-editor';\n\n\t/** Scheme used for the chat input part */\n\texport const vscodeChatInput = 'chatSessionInput';\n\n\t/** Scheme used for local chat session content */\n\texport const vscodeLocalChatSession = 'vscode-chat-session';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n\n\t/**\n\t * Scheme used for input box for creating comments.\n\t */\n\texport const commentsInput = 'comment';\n\n\t/**\n\t * Scheme used for special rendering of settings in the release notes\n\t */\n\texport const codeSetting = 'code-setting';\n\n\t/**\n\t * Scheme used for output panel resources\n\t */\n\texport const outputChannel = 'output';\n\n\t/**\n\t * Scheme used for the accessible view\n\t */\n\texport const accessibleView = 'accessible-view';\n\n\t/**\n\t * Used for snapshots of chat edits\n\t */\n\texport const chatEditingSnapshotScheme = 'chat-editing-snapshot-text-model';\n\texport const chatEditingModel = 'chat-editing-text-model';\n\n\t/**\n\t * Used for rendering multidiffs in copilot agent sessions\n\t */\n\texport const copilotPr = 'copilot-pr';\n}\n\nexport function matchesScheme(target: URI | string, scheme: string): boolean {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n\nexport function matchesSomeScheme(target: URI | string, ...schemes: string[]): boolean {\n\treturn schemes.some(scheme => matchesScheme(target, scheme));\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _serverRootPath: string = '/';\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(product: { quality?: string; commit?: string }, serverBasePath: string | undefined): void {\n\t\tthis._serverRootPath = paths.posix.join(serverBasePath ?? '/', getServerProductSegment(product));\n\t}\n\n\tgetServerRootPath(): string {\n\t\treturn this._serverRootPath;\n\t}\n\n\tprivate get _remoteResourcesPath(): string {\n\t\treturn paths.posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nexport function getServerProductSegment(product: { quality?: string; commit?: string }) {\n\treturn `${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`;\n}\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nexport const VSCODE_AUTHORITY = 'vscode-app';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\tif (globalThis._VSCODE_FILE_ROOT) {\n\t\t\tconst rootUriOrPath = globalThis._VSCODE_FILE_ROOT;\n\n\t\t\t// File URL (with scheme)\n\t\t\tif (/^\\w[\\w\\d+.-]*:\\/\\//.test(rootUriOrPath)) {\n\t\t\t\treturn URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);\n\t\t\t}\n\n\t\t\t// File Path (no scheme)\n\t\t\tconst modulePath = paths.join(rootUriOrPath, uriOrModule);\n\t\t\treturn URI.file(modulePath);\n\t\t}\n\n\t\tthrow new Error('Cannot determine URI for module id!');\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\nexport const CacheControlheaders: Record<string, string> = Object.freeze({\n\t'Cache-Control': 'no-cache, no-store'\n});\n\nexport const DocumentPolicyheaders: Record<string, string> = Object.freeze({\n\t'Document-Policy': 'include-js-call-stacks-in-crash-reports'\n});\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(globalThis as typeof globalThis & { crossOriginIsolated?: boolean }).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\turlOrSearch[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from './errors.js';\nimport * as platform from './platform.js';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from './strings.js';\nimport { URI } from './uri.js';\nimport * as paths from './path.js';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellMetadataDiff = 'vscode-notebook-cell-metadata-diff';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeNotebookCellOutputDiff = 'vscode-notebook-cell-output-diff';\n\texport const vscodeNotebookMetadata = 'vscode-notebook-metadata';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/** Scheme used for code blocks in chat. */\n\texport const vscodeChatCodeBlock = 'vscode-chat-code-block';\n\n\t/** Scheme used for LHS of code compare (aka diff) blocks in chat. */\n\texport const vscodeChatCodeCompareBlock = 'vscode-chat-code-compare-block';\n\n\t/** Scheme used for the chat input editor. */\n\texport const vscodeChatEditor = 'vscode-chat-editor';\n\n\t/** Scheme used for the chat input part */\n\texport const vscodeChatInput = 'chatSessionInput';\n\n\t/** Scheme used for local chat session content */\n\texport const vscodeLocalChatSession = 'vscode-chat-session';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n\n\t/**\n\t * Scheme used for input box for creating comments.\n\t */\n\texport const commentsInput = 'comment';\n\n\t/**\n\t * Scheme used for special rendering of settings in the release notes\n\t */\n\texport const codeSetting = 'code-setting';\n\n\t/**\n\t * Scheme used for output panel resources\n\t */\n\texport const outputChannel = 'output';\n\n\t/**\n\t * Scheme used for the accessible view\n\t */\n\texport const accessibleView = 'accessible-view';\n\n\t/**\n\t * Used for snapshots of chat edits\n\t */\n\texport const chatEditingSnapshotScheme = 'chat-editing-snapshot-text-model';\n\texport const chatEditingModel = 'chat-editing-text-model';\n\n\t/**\n\t * Used for rendering multidiffs in copilot agent sessions\n\t */\n\texport const copilotPr = 'copilot-pr';\n}\n\nexport function matchesScheme(target: URI | string, scheme: string): boolean {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n\nexport function matchesSomeScheme(target: URI | string, ...schemes: string[]): boolean {\n\treturn schemes.some(scheme => matchesScheme(target, scheme));\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _serverRootPath: string = '/';\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(product: { quality?: string; commit?: string }, serverBasePath: string | undefined): void {\n\t\tthis._serverRootPath = paths.posix.join(serverBasePath ?? '/', getServerProductSegment(product));\n\t}\n\n\tgetServerRootPath(): string {\n\t\treturn this._serverRootPath;\n\t}\n\n\tprivate get _remoteResourcesPath(): string {\n\t\treturn paths.posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nexport function getServerProductSegment(product: { quality?: string; commit?: string }) {\n\treturn `${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`;\n}\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nexport const VSCODE_AUTHORITY = 'vscode-app';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\tif (globalThis._VSCODE_FILE_ROOT) {\n\t\t\tconst rootUriOrPath = globalThis._VSCODE_FILE_ROOT;\n\n\t\t\t// File URL (with scheme)\n\t\t\tif (/^\\w[\\w\\d+.-]*:\\/\\//.test(rootUriOrPath)) {\n\t\t\t\treturn URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);\n\t\t\t}\n\n\t\t\t// File Path (no scheme)\n\t\t\tconst modulePath = paths.join(rootUriOrPath, uriOrModule);\n\t\t\treturn URI.file(modulePath);\n\t\t}\n\n\t\tthrow new Error('Cannot determine URI for module id!');\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\nexport const CacheControlheaders: Record<string, string> = Object.freeze({\n\t'Cache-Control': 'no-cache, no-store'\n});\n\nexport const DocumentPolicyheaders: Record<string, string> = Object.freeze({\n\t'Document-Policy': 'include-js-call-stacks-in-crash-reports'\n});\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(globalThis as typeof globalThis & { crossOriginIsolated?: boolean }).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\turlOrSearch[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, isDisposable, MutableDisposable, toDisposable } from './lifecycle.js';\nimport { extUri as defaultExtUri, IExtUri } from './resources.js';\nimport { URI } from './uri.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Wraps a cancellable promise such that it is no cancellable. Can be used to\n * avoid issues with shared promises that would normally be returned as\n * cancellable to consumers.\n */\nexport function notCancellablePromise<T>(promise: CancelablePromise<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tpromise.then(resolve, reject);\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport function raceCancellablePromises<T>(cancellablePromises: (CancelablePromise<T> | Promise<T>)[]): CancelablePromise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst promise = Promise.race(promises) as CancelablePromise<T>;\n\tpromise.cancel = () => {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex && (cancellablePromise as CancelablePromise<T>).cancel) {\n\t\t\t\t(cancellablePromise as CancelablePromise<T>).cancel();\n\t\t\t}\n\t\t});\n\t};\n\tpromise.finally(() => {\n\t\tpromise.cancel();\n\t});\n\treturn promise;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\nexport interface ICancellableTask<T> {\n\t(token: CancellationToken): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ICancellableTask<Promise<any>> | null;\n\tprivate cancellationTokenSource: CancellationTokenSource;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\n\t\tthis.cancellationTokenSource = new CancellationTokenSource();\n\t}\n\n\tqueue<T>(promiseFactory: ICancellableTask<Promise<T>>): Promise<T> {\n\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory(this.cancellationTokenSource.token);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancellationTokenSource.cancel();\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n\n\tpeek(key: TKey): Promise<unknown> | undefined {\n\t\treturn this.promiseMap.get(key) || undefined;\n\t}\n\n\tkeys(): IterableIterator<TKey> {\n\t\treturn this.promiseMap.keys();\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ICancellableTask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: Timeout;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: unknown): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result as T);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Wrap a type in an optional promise. This can be useful to avoid the runtime\n * overhead of creating a promise.\n */\nexport type MaybePromise<T> = Promise<T> | T;\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is resolved with undefined.\n\t*/\n\tpublic scheduleSkipIfCleared<T>(task: Task<T>): Promise<T | undefined> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: true });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: Timeout | undefined;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = undefined;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== undefined;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = undefined;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n\n\t/**\n\t * When enabled will guarantee that two distinct calls to `work()` are not executed\n\t * without throttle delay between them.\n\t * Otherwise if the worker isn't currently throttling it will execute work immediately.\n\t */\n\twaitThrottleDelayBetweenWorkUnits?: boolean;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\tprivate lastExecutionTime = 0;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\tconst timeSinceLastExecution = Date.now() - this.lastExecutionTime;\n\n\t\tif (!this.throttler.value && (!this.options.waitThrottleDelayBetweenWorkUnits || timeSinceLastExecution >= this.options.throttleDelay)) {\n\t\t\t// Work directly if we are not throttling and we are not\n\t\t\t// enforced to throttle between `work()` calls.\n\t\t\tthis.doWork();\n\t\t} else if (!this.throttler.value && this.options.waitThrottleDelayBetweenWorkUnits) {\n\t\t\t// Otherwise, schedule the throttler to work.\n\t\t\tthis.scheduleThrottler(Math.max(this.options.throttleDelay - timeSinceLastExecution, 0));\n\t\t} else {\n\t\t\t// Otherwise, our work will be picked up by the running throttler\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\t\tthis.lastExecutionTime = Date.now();\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.scheduleThrottler();\n\t\t}\n\t}\n\n\tprivate scheduleThrottler(delay = this.options.throttleDelay): void {\n\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\tthis.throttler.clear();\n\n\t\t\tthis.doWork();\n\t\t}, delay);\n\t\tthis.throttler.value.schedule();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.pendingWork.length = 0;\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve,\n\t\t\t\tpromiseReject\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tpublic static fromPromise<T>(promise: Promise<T>): DeferredPromise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tdeferred.settleWith(promise);\n\t\treturn deferred;\n\t}\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic settleWith(promise: Promise<T>): Promise<void> {\n\t\treturn promise.then(\n\t\t\tvalue => this.complete(value),\n\t\t\terror => this.error(error)\n\t\t);\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitOneFn: (item: T) => void;\n\tprivate _emitManyFn: (item: T[]) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitOneFn = (item: T) => emitter.emitOne(item);\n\t\t\tthis._emitManyFn = (items: T[]) => emitter.emitMany(items);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t\tthis._emitOneFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._emitManyFn = (items: T[]) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = items.slice();\n\t\t\t} else {\n\t\t\t\titems.forEach(item => earlyItems!.push(item));\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitOneFn(item);\n\t}\n\n\temitMany(items: T[]) {\n\t\tthis._emitManyFn(items);\n\t}\n}\n\nexport function cancellableIterable<T>(iterableOrIterator: AsyncIterator<T> | AsyncIterable<T>, token: CancellationToken): AsyncIterableIterator<T> {\n\tconst iterator = Symbol.asyncIterator in iterableOrIterator ? iterableOrIterator[Symbol.asyncIterator]() : iterableOrIterator;\n\n\treturn {\n\t\tasync next(): Promise<IteratorResult<T>> {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t\tconst result = await raceCancellation(iterator.next(), token);\n\t\t\treturn result || { done: true, value: undefined };\n\t\t},\n\t\tthrow: iterator.throw?.bind(iterator),\n\t\treturn: iterator.return?.bind(iterator),\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static tee<T>(iterable: AsyncIterable<T>): [AsyncIterableProducer<T>, AsyncIterableProducer<T>] {\n\t\tlet emitter1: AsyncIterableEmitter<T> | undefined;\n\t\tlet emitter2: AsyncIterableEmitter<T> | undefined;\n\n\t\tconst defer = new DeferredPromise<void>();\n\n\t\tconst start = async () => {\n\t\t\tif (!emitter1 || !emitter2) {\n\t\t\t\treturn; // not yet ready\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter1.emitOne(item);\n\t\t\t\t\temitter2.emitOne(item);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\temitter1.reject(err);\n\t\t\t\temitter2.reject(err);\n\t\t\t} finally {\n\t\t\t\tdefer.complete();\n\t\t\t}\n\t\t};\n\n\t\tconst p1 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter1 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\tconst p2 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter2 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\treturn [p1, p2];\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n\nexport class AsyncReader<T> {\n\tprivate _buffer: T[] = [];\n\tprivate _atEnd = false;\n\n\tpublic get endOfStream(): boolean { return this._buffer.length === 0 && this._atEnd; }\n\tprivate _extendBufferPromise: Promise<void> | undefined;\n\n\tconstructor(\n\t\tprivate readonly _source: AsyncIterator<T>\n\t) {\n\t}\n\n\tpublic async read(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer.shift()!;\n\t}\n\n\tpublic async readWhile(predicate: (value: T) => boolean, callback: (element: T) => unknown): Promise<void> {\n\t\tdo {\n\t\t\tconst piece = await this.peek();\n\t\t\tif (piece === AsyncReaderEndOfStream) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!predicate(piece)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait this.read(); // consume\n\t\t\tawait callback(piece);\n\t\t} while (true);\n\t}\n\n\tpublic readBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tconst value = this.peekBufferedOrThrow();\n\t\tthis._buffer.shift();\n\t\treturn value;\n\t}\n\n\tpublic async consumeToEnd(): Promise<void> {\n\t\twhile (!this.endOfStream) {\n\t\t\tawait this.read();\n\t\t}\n\t}\n\n\tpublic async peek(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic peekBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tif (this._buffer.length === 0) {\n\t\t\tif (this._atEnd) {\n\t\t\t\treturn AsyncReaderEndOfStream;\n\t\t\t}\n\t\t\tthrow new BugIndicatingError('No buffered elements');\n\t\t}\n\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic async peekTimeout(timeoutMs: number): Promise<T | typeof AsyncReaderEndOfStream | undefined> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait raceTimeout(this._extendBuffer(), timeoutMs);\n\t\t}\n\t\tif (this._atEnd) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tprivate _extendBuffer(): Promise<void> {\n\t\tif (this._atEnd) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (!this._extendBufferPromise) {\n\t\t\tthis._extendBufferPromise = (async () => {\n\t\t\t\tconst { value, done } = await this._source.next();\n\t\t\t\tthis._extendBufferPromise = undefined;\n\t\t\t\tif (done) {\n\t\t\t\t\tthis._atEnd = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._buffer.push(value);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this._extendBufferPromise;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, isDisposable, MutableDisposable, toDisposable } from './lifecycle.js';\nimport { extUri as defaultExtUri, IExtUri } from './resources.js';\nimport { URI } from './uri.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Wraps a cancellable promise such that it is no cancellable. Can be used to\n * avoid issues with shared promises that would normally be returned as\n * cancellable to consumers.\n */\nexport function notCancellablePromise<T>(promise: CancelablePromise<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tpromise.then(resolve, reject);\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport function raceCancellablePromises<T>(cancellablePromises: (CancelablePromise<T> | Promise<T>)[]): CancelablePromise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst promise = Promise.race(promises) as CancelablePromise<T>;\n\tpromise.cancel = () => {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex && (cancellablePromise as CancelablePromise<T>).cancel) {\n\t\t\t\t(cancellablePromise as CancelablePromise<T>).cancel();\n\t\t\t}\n\t\t});\n\t};\n\tpromise.finally(() => {\n\t\tpromise.cancel();\n\t});\n\treturn promise;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\nexport interface ICancellableTask<T> {\n\t(token: CancellationToken): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ICancellableTask<Promise<any>> | null;\n\tprivate cancellationTokenSource: CancellationTokenSource;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\n\t\tthis.cancellationTokenSource = new CancellationTokenSource();\n\t}\n\n\tqueue<T>(promiseFactory: ICancellableTask<Promise<T>>): Promise<T> {\n\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory(this.cancellationTokenSource.token);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancellationTokenSource.cancel();\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n\n\tpeek(key: TKey): Promise<unknown> | undefined {\n\t\treturn this.promiseMap.get(key) || undefined;\n\t}\n\n\tkeys(): IterableIterator<TKey> {\n\t\treturn this.promiseMap.keys();\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ICancellableTask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: Timeout;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: unknown): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result as T);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Wrap a type in an optional promise. This can be useful to avoid the runtime\n * overhead of creating a promise.\n */\nexport type MaybePromise<T> = Promise<T> | T;\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is resolved with undefined.\n\t*/\n\tpublic scheduleSkipIfCleared<T>(task: Task<T>): Promise<T | undefined> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: true });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: Timeout | undefined;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = undefined;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== undefined;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = undefined;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n\n\t/**\n\t * When enabled will guarantee that two distinct calls to `work()` are not executed\n\t * without throttle delay between them.\n\t * Otherwise if the worker isn't currently throttling it will execute work immediately.\n\t */\n\twaitThrottleDelayBetweenWorkUnits?: boolean;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\tprivate lastExecutionTime = 0;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\tconst timeSinceLastExecution = Date.now() - this.lastExecutionTime;\n\n\t\tif (!this.throttler.value && (!this.options.waitThrottleDelayBetweenWorkUnits || timeSinceLastExecution >= this.options.throttleDelay)) {\n\t\t\t// Work directly if we are not throttling and we are not\n\t\t\t// enforced to throttle between `work()` calls.\n\t\t\tthis.doWork();\n\t\t} else if (!this.throttler.value && this.options.waitThrottleDelayBetweenWorkUnits) {\n\t\t\t// Otherwise, schedule the throttler to work.\n\t\t\tthis.scheduleThrottler(Math.max(this.options.throttleDelay - timeSinceLastExecution, 0));\n\t\t} else {\n\t\t\t// Otherwise, our work will be picked up by the running throttler\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\t\tthis.lastExecutionTime = Date.now();\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.scheduleThrottler();\n\t\t}\n\t}\n\n\tprivate scheduleThrottler(delay = this.options.throttleDelay): void {\n\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\tthis.throttler.clear();\n\n\t\t\tthis.doWork();\n\t\t}, delay);\n\t\tthis.throttler.value.schedule();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.pendingWork.length = 0;\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve,\n\t\t\t\tpromiseReject\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tpublic static fromPromise<T>(promise: Promise<T>): DeferredPromise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tdeferred.settleWith(promise);\n\t\treturn deferred;\n\t}\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic settleWith(promise: Promise<T>): Promise<void> {\n\t\treturn promise.then(\n\t\t\tvalue => this.complete(value),\n\t\t\terror => this.error(error)\n\t\t);\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitOneFn: (item: T) => void;\n\tprivate _emitManyFn: (item: T[]) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitOneFn = (item: T) => emitter.emitOne(item);\n\t\t\tthis._emitManyFn = (items: T[]) => emitter.emitMany(items);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t\tthis._emitOneFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._emitManyFn = (items: T[]) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = items.slice();\n\t\t\t} else {\n\t\t\t\titems.forEach(item => earlyItems!.push(item));\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitOneFn(item);\n\t}\n\n\temitMany(items: T[]) {\n\t\tthis._emitManyFn(items);\n\t}\n}\n\nexport function cancellableIterable<T>(iterableOrIterator: AsyncIterator<T> | AsyncIterable<T>, token: CancellationToken): AsyncIterableIterator<T> {\n\tconst iterator = Symbol.asyncIterator in iterableOrIterator ? iterableOrIterator[Symbol.asyncIterator]() : iterableOrIterator;\n\n\treturn {\n\t\tasync next(): Promise<IteratorResult<T>> {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t\tconst result = await raceCancellation(iterator.next(), token);\n\t\t\treturn result || { done: true, value: undefined };\n\t\t},\n\t\tthrow: iterator.throw?.bind(iterator),\n\t\treturn: iterator.return?.bind(iterator),\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static tee<T>(iterable: AsyncIterable<T>): [AsyncIterableProducer<T>, AsyncIterableProducer<T>] {\n\t\tlet emitter1: AsyncIterableEmitter<T> | undefined;\n\t\tlet emitter2: AsyncIterableEmitter<T> | undefined;\n\n\t\tconst defer = new DeferredPromise<void>();\n\n\t\tconst start = async () => {\n\t\t\tif (!emitter1 || !emitter2) {\n\t\t\t\treturn; // not yet ready\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter1.emitOne(item);\n\t\t\t\t\temitter2.emitOne(item);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\temitter1.reject(err);\n\t\t\t\temitter2.reject(err);\n\t\t\t} finally {\n\t\t\t\tdefer.complete();\n\t\t\t}\n\t\t};\n\n\t\tconst p1 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter1 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\tconst p2 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter2 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\treturn [p1, p2];\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n\nexport class AsyncReader<T> {\n\tprivate _buffer: T[] = [];\n\tprivate _atEnd = false;\n\n\tpublic get endOfStream(): boolean { return this._buffer.length === 0 && this._atEnd; }\n\tprivate _extendBufferPromise: Promise<void> | undefined;\n\n\tconstructor(\n\t\tprivate readonly _source: AsyncIterator<T>\n\t) {\n\t}\n\n\tpublic async read(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer.shift()!;\n\t}\n\n\tpublic async readWhile(predicate: (value: T) => boolean, callback: (element: T) => unknown): Promise<void> {\n\t\tdo {\n\t\t\tconst piece = await this.peek();\n\t\t\tif (piece === AsyncReaderEndOfStream) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!predicate(piece)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait this.read(); // consume\n\t\t\tawait callback(piece);\n\t\t} while (true);\n\t}\n\n\tpublic readBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tconst value = this.peekBufferedOrThrow();\n\t\tthis._buffer.shift();\n\t\treturn value;\n\t}\n\n\tpublic async consumeToEnd(): Promise<void> {\n\t\twhile (!this.endOfStream) {\n\t\t\tawait this.read();\n\t\t}\n\t}\n\n\tpublic async peek(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic peekBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tif (this._buffer.length === 0) {\n\t\t\tif (this._atEnd) {\n\t\t\t\treturn AsyncReaderEndOfStream;\n\t\t\t}\n\t\t\tthrow new BugIndicatingError('No buffered elements');\n\t\t}\n\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic async peekTimeout(timeoutMs: number): Promise<T | typeof AsyncReaderEndOfStream | undefined> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait raceTimeout(this._extendBuffer(), timeoutMs);\n\t\t}\n\t\tif (this._atEnd) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tprivate _extendBuffer(): Promise<void> {\n\t\tif (this._atEnd) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (!this._extendBufferPromise) {\n\t\t\tthis._extendBufferPromise = (async () => {\n\t\t\t\tconst { value, done } = await this._source.next();\n\t\t\t\tthis._extendBufferPromise = undefined;\n\t\t\t\tif (done) {\n\t\t\t\t\tthis._atEnd = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._buffer.push(value);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this._extendBufferPromise;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCache } from './map.js';\n\nconst nfcCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFC(str: string): string {\n\treturn normalize(str, 'NFC', nfcCache);\n}\n\nconst nfdCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFD(str: string): string {\n\treturn normalize(str, 'NFD', nfdCache);\n}\n\nconst nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nfunction normalize(str: string, form: string, normalizedCache: LRUCache<string, string>): string {\n\tif (!str) {\n\t\treturn str;\n\t}\n\n\tconst cached = normalizedCache.get(str);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tlet res: string;\n\tif (nonAsciiCharactersPattern.test(str)) {\n\t\tres = str.normalize(form);\n\t} else {\n\t\tres = str;\n\t}\n\n\t// Use the cache for fast lookup\n\tnormalizedCache.set(str, res);\n\n\treturn res;\n}\n\n/**\n * Attempts to normalize the string to Unicode base format (NFD -> remove accents -> lower case).\n * When original string contains accent characters directly, only lower casing will be performed.\n * This is done so as to keep the string length the same and not affect indices.\n *\n * @see https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n */\nexport const tryNormalizeToBase: (str: string) => string = function () {\n\tconst cache = new LRUCache<string, string>(10000); // bounded to 10000 elements\n\tconst accentsRegex = /[\\u0300-\\u036f]/g;\n\treturn function (str: string): string {\n\t\tconst cached = cache.get(str);\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tconst noAccents = normalizeNFD(str).replace(accentsRegex, '');\n\t\tconst result = (noAccents.length === str.length ? noAccents : str).toLowerCase();\n\t\tcache.set(str, result);\n\t\treturn result;\n\t};\n}();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCache } from './map.js';\n\nconst nfcCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFC(str: string): string {\n\treturn normalize(str, 'NFC', nfcCache);\n}\n\nconst nfdCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFD(str: string): string {\n\treturn normalize(str, 'NFD', nfdCache);\n}\n\nconst nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nfunction normalize(str: string, form: string, normalizedCache: LRUCache<string, string>): string {\n\tif (!str) {\n\t\treturn str;\n\t}\n\n\tconst cached = normalizedCache.get(str);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tlet res: string;\n\tif (nonAsciiCharactersPattern.test(str)) {\n\t\tres = str.normalize(form);\n\t} else {\n\t\tres = str;\n\t}\n\n\t// Use the cache for fast lookup\n\tnormalizedCache.set(str, res);\n\n\treturn res;\n}\n\n/**\n * Attempts to normalize the string to Unicode base format (NFD -> remove accents -> lower case).\n * When original string contains accent characters directly, only lower casing will be performed.\n * This is done so as to keep the string length the same and not affect indices.\n *\n * @see https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n */\nexport const tryNormalizeToBase: (str: string) => string = function () {\n\tconst cache = new LRUCache<string, string>(10000); // bounded to 10000 elements\n\tconst accentsRegex = /[\\u0300-\\u036f]/g;\n\treturn function (str: string): string {\n\t\tconst cached = cache.get(str);\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tconst noAccents = normalizeNFD(str).replace(accentsRegex, '');\n\t\tconst result = (noAccents.length === str.length ? noAccents : str).toLowerCase();\n\t\tcache.set(str, result);\n\t\treturn result;\n\t};\n}();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { ResourceQueue, timeout } from '../common/async.js';\nimport { isEqualOrParent, isRootOrDriveLetter, randomPath } from '../common/extpath.js';\nimport { normalizeNFC } from '../common/normalization.js';\nimport { basename, dirname, join, normalize, sep } from '../common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../common/resources.js';\nimport { URI } from '../common/uri.js';\nimport { CancellationToken } from '../common/cancellation.js';\nimport { rtrim } from '../common/strings.js';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n *           the optional `moveToPath` allows to override where to rename the\n *           path to before deleting it.\n */\nasync function rimraf(path: string, mode: RimRafMode.UNLINK): Promise<void>;\nasync function rimraf(path: string, mode: RimRafMode.MOVE, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode?: RimRafMode, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode = RimRafMode.UNLINK, moveToPath?: string): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path, moveToPath);\n}\n\nasync function rimrafMove(path: string, moveToPath = randomPath(tmpdir())): Promise<void> {\n\ttry {\n\t\ttry {\n\t\t\tawait fs.promises.rename(path, moveToPath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn; // ignore - path to delete did not exist\n\t\t\t}\n\n\t\t\treturn rimrafUnlink(path); // otherwise fallback to unlink\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(moveToPath).catch(() => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn fs.promises.rm(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nasync function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\ttry {\n\t\treturn await doReaddir(path, options);\n\t} catch (error) {\n\t\t// Workaround for #252361 that should be removed once the upstream issue\n\t\t// in node.js is resolved. Adds a trailing dot to a root drive letter path\n\t\t// (G:\\ => G:\\.) as a workaround.\n\t\tif (error.code === 'ENOENT' && isWindows && isRootOrDriveLetter(path)) {\n\t\t\ttry {\n\t\t\t\treturn await doReaddir(`${path}.`, options);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tthrow error;\n\t}\n}\n\nasync function doReaddir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : fs.promises.readdir(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await fs.promises.readdir(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await fs.promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await fs.promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await fs.promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.promises.stat(await fs.promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), () => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t}, extUriBiasedIgnorePathCase);\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n *\n * @deprecated always prefer async variants over sync!\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n * - attempts to retry the operation for certain error codes on Windows\n */\nasync function rename(source: string, target: string, windowsRetryTimeout: number | false = 60000): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tif (isWindows && typeof windowsRetryTimeout === 'number') {\n\t\t\t// On Windows, a rename can fail when either source or target\n\t\t\t// is locked by AV software.\n\t\t\tawait renameWithRetry(source, target, Date.now(), windowsRetryTimeout);\n\t\t} else {\n\t\t\tawait fs.promises.rename(source, target);\n\t\t}\n\t} catch (error) {\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function renameWithRetry(source: string, target: string, startTime: number, retryTimeout: number, attempt = 0): Promise<void> {\n\ttry {\n\t\treturn await fs.promises.rename(source, target);\n\t} catch (error) {\n\t\tif (error.code !== 'EACCES' && error.code !== 'EPERM' && error.code !== 'EBUSY') {\n\t\t\tthrow error; // only for errors we think are temporary\n\t\t}\n\n\t\tif (Date.now() - startTime >= retryTimeout) {\n\t\t\tconsole.error(`[node.js fs] rename failed after ${attempt} retries with error: ${error}`);\n\n\t\t\tthrow error; // give up after configurable timeout\n\t\t}\n\n\t\tif (attempt === 0) {\n\t\t\tlet abortRetry = false;\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(target);\n\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\tabortRetry = true; // if target is not a file, EPERM error may be raised and we should not attempt to retry\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\tif (abortRetry) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Delay with incremental backoff up to 100ms\n\t\tawait timeout(Math.min(100, attempt * 10));\n\n\t\t// Attempt again\n\t\treturn renameWithRetry(source, target, startTime, retryTimeout, attempt + 1);\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait fs.promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait fs.promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait fs.promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await fs.promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait fs.promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Path resolvers\n\n/**\n * Given an absolute, normalized, and existing file path 'realcase' returns the\n * exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original\n * path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the\n * original path.\n * In case of errors, null is returned. But you cannot use this function to verify that\n * a path exists.\n *\n * realcase does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport async function realcase(path: string, token?: CancellationToken): Promise<string | null> {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst entries = await Promises.readdir(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nasync function realpath(path: string): Promise<string> {\n\ttry {\n\t\t// DO NOT USE `fs.promises.realpath` here as it internally\n\t\t// calls `fs.native.realpath` which will result in subst\n\t\t// drives to be resolved to their target on Windows\n\t\t// https://github.com/microsoft/vscode/issues/118562\n\t\treturn await promisify(fs.realpath)(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait fs.promises.access(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\n/**\n * @deprecated always prefer async variants over sync!\n */\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Some low level `fs` methods provided as `Promises` similar to\n * `fs.promises` but with notable differences, either implemented\n * by us or by restoring the original callback based behavior.\n *\n * At least `realpath` is implemented differently in the promise\n * based implementation compared to the callback based one. The\n * promise based implementation actually calls `fs.realpath.native`.\n * (https://github.com/microsoft/vscode/issues/118562)\n */\nexport const Promises = new class {\n\n\t//#region Implemented by node.js\n\n\tget read() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number, length: number, position: number | null) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget write() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.write(fd, buffer, offset, length, position, (err, bytesWritten, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget fdatasync() { return promisify(fs.fdatasync); } // not exposed as API in 22.x yet\n\n\tget open() { return promisify(fs.open); } \t\t\t// changed to return `FileHandle` in promise API\n\tget close() { return promisify(fs.close); } \t\t// not exposed as API due to the `FileHandle` return type of `open`\n\n\tget ftruncate() { return promisify(fs.ftruncate); } // not exposed as API in 22.x yet\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() { return readdir; }\n\tget readDirsInDir() { return readDirsInDir; }\n\n\tget writeFile() { return writeFile; }\n\n\tget rm() { return rimraf; }\n\n\tget rename() { return rename; }\n\tget copy() { return copy; }\n\n\tget realpath() { return realpath; }\t// `fs.promises.realpath` will use `fs.realpath.native` which we do not want\n\n\t//#endregion\n};\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { ResourceQueue, timeout } from '../common/async.js';\nimport { isEqualOrParent, isRootOrDriveLetter, randomPath } from '../common/extpath.js';\nimport { normalizeNFC } from '../common/normalization.js';\nimport { basename, dirname, join, normalize, sep } from '../common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../common/resources.js';\nimport { URI } from '../common/uri.js';\nimport { CancellationToken } from '../common/cancellation.js';\nimport { rtrim } from '../common/strings.js';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n *           the optional `moveToPath` allows to override where to rename the\n *           path to before deleting it.\n */\nasync function rimraf(path: string, mode: RimRafMode.UNLINK): Promise<void>;\nasync function rimraf(path: string, mode: RimRafMode.MOVE, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode?: RimRafMode, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode = RimRafMode.UNLINK, moveToPath?: string): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path, moveToPath);\n}\n\nasync function rimrafMove(path: string, moveToPath = randomPath(tmpdir())): Promise<void> {\n\ttry {\n\t\ttry {\n\t\t\tawait fs.promises.rename(path, moveToPath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn; // ignore - path to delete did not exist\n\t\t\t}\n\n\t\t\treturn rimrafUnlink(path); // otherwise fallback to unlink\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(moveToPath).catch(() => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn fs.promises.rm(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nasync function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\ttry {\n\t\treturn await doReaddir(path, options);\n\t} catch (error) {\n\t\t// Workaround for #252361 that should be removed once the upstream issue\n\t\t// in node.js is resolved. Adds a trailing dot to a root drive letter path\n\t\t// (G:\\ => G:\\.) as a workaround.\n\t\tif (error.code === 'ENOENT' && isWindows && isRootOrDriveLetter(path)) {\n\t\t\ttry {\n\t\t\t\treturn await doReaddir(`${path}.`, options);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tthrow error;\n\t}\n}\n\nasync function doReaddir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : fs.promises.readdir(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await fs.promises.readdir(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await fs.promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await fs.promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await fs.promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.promises.stat(await fs.promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), () => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t}, extUriBiasedIgnorePathCase);\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n *\n * @deprecated always prefer async variants over sync!\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n * - attempts to retry the operation for certain error codes on Windows\n */\nasync function rename(source: string, target: string, windowsRetryTimeout: number | false = 60000): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tif (isWindows && typeof windowsRetryTimeout === 'number') {\n\t\t\t// On Windows, a rename can fail when either source or target\n\t\t\t// is locked by AV software.\n\t\t\tawait renameWithRetry(source, target, Date.now(), windowsRetryTimeout);\n\t\t} else {\n\t\t\tawait fs.promises.rename(source, target);\n\t\t}\n\t} catch (error) {\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function renameWithRetry(source: string, target: string, startTime: number, retryTimeout: number, attempt = 0): Promise<void> {\n\ttry {\n\t\treturn await fs.promises.rename(source, target);\n\t} catch (error) {\n\t\tif (error.code !== 'EACCES' && error.code !== 'EPERM' && error.code !== 'EBUSY') {\n\t\t\tthrow error; // only for errors we think are temporary\n\t\t}\n\n\t\tif (Date.now() - startTime >= retryTimeout) {\n\t\t\tconsole.error(`[node.js fs] rename failed after ${attempt} retries with error: ${error}`);\n\n\t\t\tthrow error; // give up after configurable timeout\n\t\t}\n\n\t\tif (attempt === 0) {\n\t\t\tlet abortRetry = false;\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(target);\n\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\tabortRetry = true; // if target is not a file, EPERM error may be raised and we should not attempt to retry\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\tif (abortRetry) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Delay with incremental backoff up to 100ms\n\t\tawait timeout(Math.min(100, attempt * 10));\n\n\t\t// Attempt again\n\t\treturn renameWithRetry(source, target, startTime, retryTimeout, attempt + 1);\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait fs.promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait fs.promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait fs.promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await fs.promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait fs.promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Path resolvers\n\n/**\n * Given an absolute, normalized, and existing file path 'realcase' returns the\n * exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original\n * path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the\n * original path.\n * In case of errors, null is returned. But you cannot use this function to verify that\n * a path exists.\n *\n * realcase does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport async function realcase(path: string, token?: CancellationToken): Promise<string | null> {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst entries = await Promises.readdir(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nasync function realpath(path: string): Promise<string> {\n\ttry {\n\t\t// DO NOT USE `fs.promises.realpath` here as it internally\n\t\t// calls `fs.native.realpath` which will result in subst\n\t\t// drives to be resolved to their target on Windows\n\t\t// https://github.com/microsoft/vscode/issues/118562\n\t\treturn await promisify(fs.realpath)(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait fs.promises.access(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\n/**\n * @deprecated always prefer async variants over sync!\n */\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Some low level `fs` methods provided as `Promises` similar to\n * `fs.promises` but with notable differences, either implemented\n * by us or by restoring the original callback based behavior.\n *\n * At least `realpath` is implemented differently in the promise\n * based implementation compared to the callback based one. The\n * promise based implementation actually calls `fs.realpath.native`.\n * (https://github.com/microsoft/vscode/issues/118562)\n */\nexport const Promises = new class {\n\n\t//#region Implemented by node.js\n\n\tget read() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number, length: number, position: number | null) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget write() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.write(fd, buffer, offset, length, position, (err, bytesWritten, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget fdatasync() { return promisify(fs.fdatasync); } // not exposed as API in 22.x yet\n\n\tget open() { return promisify(fs.open); } \t\t\t// changed to return `FileHandle` in promise API\n\tget close() { return promisify(fs.close); } \t\t// not exposed as API due to the `FileHandle` return type of `open`\n\n\tget ftruncate() { return promisify(fs.ftruncate); } // not exposed as API in 22.x yet\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() { return readdir; }\n\tget readDirsInDir() { return readDirsInDir; }\n\n\tget writeFile() { return writeFile; }\n\n\tget rm() { return rimraf; }\n\n\tget rename() { return rename; }\n\tget copy() { return copy; }\n\n\tget realpath() { return realpath; }\t// `fs.promises.realpath` will use `fs.realpath.native` which we do not want\n\n\t//#endregion\n};\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * @returns Returns a random port between 1025 and 65535.\n */\nexport function randomPort(): number {\n\tconst min = 1025;\n\tconst max = 65535;\n\treturn min + Math.floor((max - min) * Math.random());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * @returns Returns a random port between 1025 and 65535.\n */\nexport function randomPort(): number {\n\tconst min = 1025;\n\tconst max = 65535;\n\treturn min + Math.floor((max - min) * Math.random());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\n\n/**\n * Given a start point and a max number of retries, will find a port that\n * is openable. Will return 0 in case no free port can be found.\n */\nexport function findFreePort(startPort: number, giveUpAfter: number, timeout: number, stride = 1): Promise<number> {\n\tlet done = false;\n\n\treturn new Promise(resolve => {\n\t\tconst timeoutHandle = setTimeout(() => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\treturn resolve(0);\n\t\t\t}\n\t\t}, timeout);\n\n\t\tdoFindFreePort(startPort, giveUpAfter, stride, (port) => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t\treturn resolve(port);\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction doFindFreePort(startPort: number, giveUpAfter: number, stride: number, clb: (port: number) => void): void {\n\tif (giveUpAfter === 0) {\n\t\treturn clb(0);\n\t}\n\n\tconst client = new net.Socket();\n\n\t// If we can connect to the port it means the port is already taken so we continue searching\n\tclient.once('connect', () => {\n\t\tdispose(client);\n\n\t\treturn doFindFreePort(startPort + stride, giveUpAfter - 1, stride, clb);\n\t});\n\n\tclient.once('data', () => {\n\t\t// this listener is required since node.js 8.x\n\t});\n\n\tclient.once('error', (err: Error & { code?: string }) => {\n\t\tdispose(client);\n\n\t\t// If we receive any non ECONNREFUSED error, it means the port is used but we cannot connect\n\t\tif (err.code !== 'ECONNREFUSED') {\n\t\t\treturn doFindFreePort(startPort + stride, giveUpAfter - 1, stride, clb);\n\t\t}\n\n\t\t// Otherwise it means the port is free to use!\n\t\treturn clb(startPort);\n\t});\n\n\tclient.connect(startPort, '127.0.0.1');\n}\n\n// Reference: https://chromium.googlesource.com/chromium/src.git/+/refs/heads/main/net/base/port_util.cc#56\nexport const BROWSER_RESTRICTED_PORTS: Record<number, boolean> = {\n\t1: true,      // tcpmux\n\t7: true,      // echo\n\t9: true,      // discard\n\t11: true,     // systat\n\t13: true,     // daytime\n\t15: true,     // netstat\n\t17: true,     // qotd\n\t19: true,     // chargen\n\t20: true,     // ftp data\n\t21: true,     // ftp access\n\t22: true,     // ssh\n\t23: true,     // telnet\n\t25: true,     // smtp\n\t37: true,     // time\n\t42: true,     // name\n\t43: true,     // nicname\n\t53: true,     // domain\n\t69: true,     // tftp\n\t77: true,     // priv-rjs\n\t79: true,     // finger\n\t87: true,     // ttylink\n\t95: true,     // supdup\n\t101: true,    // hostriame\n\t102: true,    // iso-tsap\n\t103: true,    // gppitnp\n\t104: true,    // acr-nema\n\t109: true,    // pop2\n\t110: true,    // pop3\n\t111: true,    // sunrpc\n\t113: true,    // auth\n\t115: true,    // sftp\n\t117: true,    // uucp-path\n\t119: true,    // nntp\n\t123: true,    // NTP\n\t135: true,    // loc-srv /epmap\n\t137: true,    // netbios\n\t139: true,    // netbios\n\t143: true,    // imap2\n\t161: true,    // snmp\n\t179: true,    // BGP\n\t389: true,    // ldap\n\t427: true,    // SLP (Also used by Apple Filing Protocol)\n\t465: true,    // smtp+ssl\n\t512: true,    // print / exec\n\t513: true,    // login\n\t514: true,    // shell\n\t515: true,    // printer\n\t526: true,    // tempo\n\t530: true,    // courier\n\t531: true,    // chat\n\t532: true,    // netnews\n\t540: true,    // uucp\n\t548: true,    // AFP (Apple Filing Protocol)\n\t554: true,    // rtsp\n\t556: true,    // remotefs\n\t563: true,    // nntp+ssl\n\t587: true,    // smtp (rfc6409)\n\t601: true,    // syslog-conn (rfc3195)\n\t636: true,    // ldap+ssl\n\t989: true,    // ftps-data\n\t990: true,    // ftps\n\t993: true,    // ldap+ssl\n\t995: true,    // pop3+ssl\n\t1719: true,   // h323gatestat\n\t1720: true,   // h323hostcall\n\t1723: true,   // pptp\n\t2049: true,   // nfs\n\t3659: true,   // apple-sasl / PasswordServer\n\t4045: true,   // lockd\n\t5060: true,   // sip\n\t5061: true,   // sips\n\t6000: true,   // X11\n\t6566: true,   // sane-port\n\t6665: true,   // Alternate IRC [Apple addition]\n\t6666: true,   // Alternate IRC [Apple addition]\n\t6667: true,   // Standard IRC [Apple addition]\n\t6668: true,   // Alternate IRC [Apple addition]\n\t6669: true,   // Alternate IRC [Apple addition]\n\t6697: true,   // IRC + TLS\n\t10080: true   // Amanda\n};\n\nexport function isPortFree(port: number, timeout: number): Promise<boolean> {\n\treturn findFreePortFaster(port, 0, timeout).then(port => port !== 0);\n}\n\ninterface ServerError {\n\tcode?: string;\n}\n\n/**\n * Uses listen instead of connect. Is faster, but if there is another listener on 0.0.0.0 then this will take 127.0.0.1 from that listener.\n */\nexport function findFreePortFaster(startPort: number, giveUpAfter: number, timeout: number, hostname: string = '127.0.0.1'): Promise<number> {\n\tlet resolved: boolean = false;\n\tlet timeoutHandle: Timeout | undefined = undefined;\n\tlet countTried: number = 1;\n\tconst server = net.createServer({ pauseOnConnect: true });\n\tfunction doResolve(port: number, resolve: (port: number) => void) {\n\t\tif (!resolved) {\n\t\t\tresolved = true;\n\t\t\tserver.removeAllListeners();\n\t\t\tserver.close();\n\t\t\tif (timeoutHandle) {\n\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t}\n\t\t\tresolve(port);\n\t\t}\n\t}\n\treturn new Promise<number>(resolve => {\n\t\ttimeoutHandle = setTimeout(() => {\n\t\t\tdoResolve(0, resolve);\n\t\t}, timeout);\n\n\t\tserver.on('listening', () => {\n\t\t\tdoResolve(startPort, resolve);\n\t\t});\n\t\tserver.on('error', (err: ServerError) => {\n\t\t\tif (err && (err.code === 'EADDRINUSE' || err.code === 'EACCES') && (countTried < giveUpAfter)) {\n\t\t\t\tstartPort++;\n\t\t\t\tcountTried++;\n\t\t\t\tserver.listen(startPort, hostname);\n\t\t\t} else {\n\t\t\t\tdoResolve(0, resolve);\n\t\t\t}\n\t\t});\n\t\tserver.on('close', () => {\n\t\t\tdoResolve(0, resolve);\n\t\t});\n\t\tserver.listen(startPort, hostname);\n\t});\n}\n\nfunction dispose(socket: net.Socket): void {\n\ttry {\n\t\tsocket.removeAllListeners('connect');\n\t\tsocket.removeAllListeners('error');\n\t\tsocket.end();\n\t\tsocket.destroy();\n\t\tsocket.unref();\n\t} catch (error) {\n\t\tconsole.error(error); // otherwise this error would get lost in the callback chain\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\n\n/**\n * Given a start point and a max number of retries, will find a port that\n * is openable. Will return 0 in case no free port can be found.\n */\nexport function findFreePort(startPort: number, giveUpAfter: number, timeout: number, stride = 1): Promise<number> {\n\tlet done = false;\n\n\treturn new Promise(resolve => {\n\t\tconst timeoutHandle = setTimeout(() => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\treturn resolve(0);\n\t\t\t}\n\t\t}, timeout);\n\n\t\tdoFindFreePort(startPort, giveUpAfter, stride, (port) => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t\treturn resolve(port);\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction doFindFreePort(startPort: number, giveUpAfter: number, stride: number, clb: (port: number) => void): void {\n\tif (giveUpAfter === 0) {\n\t\treturn clb(0);\n\t}\n\n\tconst client = new net.Socket();\n\n\t// If we can connect to the port it means the port is already taken so we continue searching\n\tclient.once('connect', () => {\n\t\tdispose(client);\n\n\t\treturn doFindFreePort(startPort + stride, giveUpAfter - 1, stride, clb);\n\t});\n\n\tclient.once('data', () => {\n\t\t// this listener is required since node.js 8.x\n\t});\n\n\tclient.once('error', (err: Error & { code?: string }) => {\n\t\tdispose(client);\n\n\t\t// If we receive any non ECONNREFUSED error, it means the port is used but we cannot connect\n\t\tif (err.code !== 'ECONNREFUSED') {\n\t\t\treturn doFindFreePort(startPort + stride, giveUpAfter - 1, stride, clb);\n\t\t}\n\n\t\t// Otherwise it means the port is free to use!\n\t\treturn clb(startPort);\n\t});\n\n\tclient.connect(startPort, '127.0.0.1');\n}\n\n// Reference: https://chromium.googlesource.com/chromium/src.git/+/refs/heads/main/net/base/port_util.cc#56\nexport const BROWSER_RESTRICTED_PORTS: Record<number, boolean> = {\n\t1: true,      // tcpmux\n\t7: true,      // echo\n\t9: true,      // discard\n\t11: true,     // systat\n\t13: true,     // daytime\n\t15: true,     // netstat\n\t17: true,     // qotd\n\t19: true,     // chargen\n\t20: true,     // ftp data\n\t21: true,     // ftp access\n\t22: true,     // ssh\n\t23: true,     // telnet\n\t25: true,     // smtp\n\t37: true,     // time\n\t42: true,     // name\n\t43: true,     // nicname\n\t53: true,     // domain\n\t69: true,     // tftp\n\t77: true,     // priv-rjs\n\t79: true,     // finger\n\t87: true,     // ttylink\n\t95: true,     // supdup\n\t101: true,    // hostriame\n\t102: true,    // iso-tsap\n\t103: true,    // gppitnp\n\t104: true,    // acr-nema\n\t109: true,    // pop2\n\t110: true,    // pop3\n\t111: true,    // sunrpc\n\t113: true,    // auth\n\t115: true,    // sftp\n\t117: true,    // uucp-path\n\t119: true,    // nntp\n\t123: true,    // NTP\n\t135: true,    // loc-srv /epmap\n\t137: true,    // netbios\n\t139: true,    // netbios\n\t143: true,    // imap2\n\t161: true,    // snmp\n\t179: true,    // BGP\n\t389: true,    // ldap\n\t427: true,    // SLP (Also used by Apple Filing Protocol)\n\t465: true,    // smtp+ssl\n\t512: true,    // print / exec\n\t513: true,    // login\n\t514: true,    // shell\n\t515: true,    // printer\n\t526: true,    // tempo\n\t530: true,    // courier\n\t531: true,    // chat\n\t532: true,    // netnews\n\t540: true,    // uucp\n\t548: true,    // AFP (Apple Filing Protocol)\n\t554: true,    // rtsp\n\t556: true,    // remotefs\n\t563: true,    // nntp+ssl\n\t587: true,    // smtp (rfc6409)\n\t601: true,    // syslog-conn (rfc3195)\n\t636: true,    // ldap+ssl\n\t989: true,    // ftps-data\n\t990: true,    // ftps\n\t993: true,    // ldap+ssl\n\t995: true,    // pop3+ssl\n\t1719: true,   // h323gatestat\n\t1720: true,   // h323hostcall\n\t1723: true,   // pptp\n\t2049: true,   // nfs\n\t3659: true,   // apple-sasl / PasswordServer\n\t4045: true,   // lockd\n\t5060: true,   // sip\n\t5061: true,   // sips\n\t6000: true,   // X11\n\t6566: true,   // sane-port\n\t6665: true,   // Alternate IRC [Apple addition]\n\t6666: true,   // Alternate IRC [Apple addition]\n\t6667: true,   // Standard IRC [Apple addition]\n\t6668: true,   // Alternate IRC [Apple addition]\n\t6669: true,   // Alternate IRC [Apple addition]\n\t6697: true,   // IRC + TLS\n\t10080: true   // Amanda\n};\n\nexport function isPortFree(port: number, timeout: number): Promise<boolean> {\n\treturn findFreePortFaster(port, 0, timeout).then(port => port !== 0);\n}\n\ninterface ServerError {\n\tcode?: string;\n}\n\n/**\n * Uses listen instead of connect. Is faster, but if there is another listener on 0.0.0.0 then this will take 127.0.0.1 from that listener.\n */\nexport function findFreePortFaster(startPort: number, giveUpAfter: number, timeout: number, hostname: string = '127.0.0.1'): Promise<number> {\n\tlet resolved: boolean = false;\n\tlet timeoutHandle: Timeout | undefined = undefined;\n\tlet countTried: number = 1;\n\tconst server = net.createServer({ pauseOnConnect: true });\n\tfunction doResolve(port: number, resolve: (port: number) => void) {\n\t\tif (!resolved) {\n\t\t\tresolved = true;\n\t\t\tserver.removeAllListeners();\n\t\t\tserver.close();\n\t\t\tif (timeoutHandle) {\n\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t}\n\t\t\tresolve(port);\n\t\t}\n\t}\n\treturn new Promise<number>(resolve => {\n\t\ttimeoutHandle = setTimeout(() => {\n\t\t\tdoResolve(0, resolve);\n\t\t}, timeout);\n\n\t\tserver.on('listening', () => {\n\t\t\tdoResolve(startPort, resolve);\n\t\t});\n\t\tserver.on('error', (err: ServerError) => {\n\t\t\tif (err && (err.code === 'EADDRINUSE' || err.code === 'EACCES') && (countTried < giveUpAfter)) {\n\t\t\t\tstartPort++;\n\t\t\t\tcountTried++;\n\t\t\t\tserver.listen(startPort, hostname);\n\t\t\t} else {\n\t\t\t\tdoResolve(0, resolve);\n\t\t\t}\n\t\t});\n\t\tserver.on('close', () => {\n\t\t\tdoResolve(0, resolve);\n\t\t});\n\t\tserver.listen(startPort, hostname);\n\t});\n}\n\nfunction dispose(socket: net.Socket): void {\n\ttry {\n\t\tsocket.removeAllListeners('connect');\n\t\tsocket.removeAllListeners('error');\n\t\tsocket.end();\n\t\tsocket.destroy();\n\t\tsocket.unref();\n\t} catch (error) {\n\t\tconsole.error(error); // otherwise this error would get lost in the callback chain\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from './arrays.js';\nimport { isThenable } from './async.js';\nimport { CharCode } from './charCode.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { endsWithIgnoreCase, equalsIgnoreCase, escapeRegExpCharacters, ltrim } from './strings.js';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n\n\t/**\n\t * Whether glob pattern matching should be case insensitive.\n\t */\n\tignoreCase?: boolean;\n}\n\ninterface IGlobOptionsInternal extends IGlobOptions {\n\tequals: (a: string, b: string) => boolean;\n\tendsWith: (str: string, candidate: string) => boolean;\n\tisEqualOrParent: (base: string, candidate: string) => boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\n/**\n * Check if a provided parsed pattern or expression\n * is empty - hence it won't ever match anything.\n *\n * See {@link FALSE} and {@link NULL}.\n */\nexport function isEmptyPattern(pattern: ParsedPattern | ParsedExpression): pattern is (typeof FALSE | typeof NULL) {\n\tif (pattern === FALSE) {\n\t\treturn true;\n\t}\n\n\tif (pattern === NULL) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\tconst ignoreCase = options.ignoreCase ?? false;\n\tconst internalOptions = {\n\t\t...options,\n\t\tequals: ignoreCase ? equalsIgnoreCase : (a: string, b: string) => a === b,\n\t\tendsWith: ignoreCase ? endsWithIgnoreCase : (str: string, candidate: string) => str.endsWith(candidate),\n\t\t// TODO: the '!isLinux' part below is to keep current behavior unchanged, but it should probably be removed\n\t\t// in favor of passing correct options from the caller.\n\t\tisEqualOrParent: (base: string, candidate: string) => isEqualOrParent(base, candidate, !isLinux || ignoreCase)\n\t};\n\n\t// Check cache\n\tconst patternKey = `${ignoreCase ? pattern.toLowerCase() : pattern}_${!!options.trimForExclusions}_${ignoreCase}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1, internalOptions);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substring(4), pattern, internalOptions); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, internalOptions))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern, internalOptions);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, internalOptions);\n\t} else if (match = T4.exec(trimForExclusions(pattern, internalOptions))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substring(1), pattern, true, internalOptions);\n\t} else if (match = T5.exec(trimForExclusions(pattern, internalOptions))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false, internalOptions);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern, internalOptions);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1, internalOptions);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern, options: IGlobOptionsInternal): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!options.isEqualOrParent(path, arg2.base)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substring(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substring(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string, options: IGlobOptionsInternal): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && options.endsWith(path, base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string, options: IGlobOptionsInternal): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn options.equals(basename, base) ? pattern : null;\n\t\t}\n\n\t\treturn options.equals(path, base) || options.endsWith(path, slashBase) || options.endsWith(path, backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptionsInternal): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean, options: IGlobOptionsInternal): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (\n\t\t\t\t(options.equals(path, nativePath) || options.endsWith(path, nativePathEnd)) ||\n\t\t\t\t!usingPosixSep && (options.equals(path, targetPath) || options.endsWith(path, targetPathEnd))\n\t\t\t) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (options.equals(path, nativePath) || (!usingPosixSep && options.equals(path, targetPath))) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`, options.ignoreCase ? 'i' : undefined);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string, options?: IGlobOptions): boolean;\nexport function match(expression: IExpression, path: string, options?: IGlobOptions): boolean;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, options?: IGlobOptions): boolean {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1, options)(path) as boolean;\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substring(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substring(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\n// NOTE: This is not used for actual matching, only for resetting watcher when patterns change.\n// That is why it's ok to avoid case-insensitive comparison here.\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from './arrays.js';\nimport { isThenable } from './async.js';\nimport { CharCode } from './charCode.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { endsWithIgnoreCase, equalsIgnoreCase, escapeRegExpCharacters, ltrim } from './strings.js';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n\n\t/**\n\t * Whether glob pattern matching should be case insensitive.\n\t */\n\tignoreCase?: boolean;\n}\n\ninterface IGlobOptionsInternal extends IGlobOptions {\n\tequals: (a: string, b: string) => boolean;\n\tendsWith: (str: string, candidate: string) => boolean;\n\tisEqualOrParent: (base: string, candidate: string) => boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\n/**\n * Check if a provided parsed pattern or expression\n * is empty - hence it won't ever match anything.\n *\n * See {@link FALSE} and {@link NULL}.\n */\nexport function isEmptyPattern(pattern: ParsedPattern | ParsedExpression): pattern is (typeof FALSE | typeof NULL) {\n\tif (pattern === FALSE) {\n\t\treturn true;\n\t}\n\n\tif (pattern === NULL) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\tconst ignoreCase = options.ignoreCase ?? false;\n\tconst internalOptions = {\n\t\t...options,\n\t\tequals: ignoreCase ? equalsIgnoreCase : (a: string, b: string) => a === b,\n\t\tendsWith: ignoreCase ? endsWithIgnoreCase : (str: string, candidate: string) => str.endsWith(candidate),\n\t\t// TODO: the '!isLinux' part below is to keep current behavior unchanged, but it should probably be removed\n\t\t// in favor of passing correct options from the caller.\n\t\tisEqualOrParent: (base: string, candidate: string) => isEqualOrParent(base, candidate, !isLinux || ignoreCase)\n\t};\n\n\t// Check cache\n\tconst patternKey = `${ignoreCase ? pattern.toLowerCase() : pattern}_${!!options.trimForExclusions}_${ignoreCase}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1, internalOptions);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substring(4), pattern, internalOptions); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, internalOptions))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern, internalOptions);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, internalOptions);\n\t} else if (match = T4.exec(trimForExclusions(pattern, internalOptions))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substring(1), pattern, true, internalOptions);\n\t} else if (match = T5.exec(trimForExclusions(pattern, internalOptions))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false, internalOptions);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern, internalOptions);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1, internalOptions);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern, options: IGlobOptionsInternal): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!options.isEqualOrParent(path, arg2.base)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substring(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substring(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string, options: IGlobOptionsInternal): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && options.endsWith(path, base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string, options: IGlobOptionsInternal): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn options.equals(basename, base) ? pattern : null;\n\t\t}\n\n\t\treturn options.equals(path, base) || options.endsWith(path, slashBase) || options.endsWith(path, backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptionsInternal): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean, options: IGlobOptionsInternal): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (\n\t\t\t\t(options.equals(path, nativePath) || options.endsWith(path, nativePathEnd)) ||\n\t\t\t\t!usingPosixSep && (options.equals(path, targetPath) || options.endsWith(path, targetPathEnd))\n\t\t\t) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (options.equals(path, nativePath) || (!usingPosixSep && options.equals(path, targetPath))) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`, options.ignoreCase ? 'i' : undefined);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string, options?: IGlobOptions): boolean;\nexport function match(expression: IExpression, path: string, options?: IGlobOptions): boolean;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, options?: IGlobOptions): boolean {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1, options)(path) as boolean;\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substring(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substring(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\n// NOTE: This is not used for actual matching, only for resetting watcher when patterns change.\n// That is why it's ok to avoid case-insensitive comparison here.\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { shuffle } from './arrays.js';\nimport { assert } from './assert.js';\nimport { CharCode } from './charCode.js';\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';\nimport { URI } from './uri.js';\n\nexport interface IKeyIterator<K> {\n\treset(key: K): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator<string> {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class ConfigKeysIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Period) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _valueLen!: number;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _splitOnBackslash: boolean = true,\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\tthis._value = key;\n\t\tthis._valueLen = key.length;\n\t\tfor (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n\t\t\tconst ch = this._value.charCodeAt(pos);\n\t\t\tif (!(ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._valueLen;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._valueLen; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nconst enum UriIteratorState {\n\tScheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n\tprivate _pathIterator!: PathIterator;\n\tprivate _value!: URI;\n\tprivate _states: UriIteratorState[] = [];\n\tprivate _stateIdx: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _ignorePathCasing: (uri: URI) => boolean,\n\t\tprivate readonly _ignoreQueryAndFragment: (uri: URI) => boolean) { }\n\n\treset(key: URI): this {\n\t\tthis._value = key;\n\t\tthis._states = [];\n\t\tif (this._value.scheme) {\n\t\t\tthis._states.push(UriIteratorState.Scheme);\n\t\t}\n\t\tif (this._value.authority) {\n\t\t\tthis._states.push(UriIteratorState.Authority);\n\t\t}\n\t\tif (this._value.path) {\n\t\t\tthis._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n\t\t\tthis._pathIterator.reset(key.path);\n\t\t\tif (this._pathIterator.value()) {\n\t\t\t\tthis._states.push(UriIteratorState.Path);\n\t\t\t}\n\t\t}\n\t\tif (!this._ignoreQueryAndFragment(key)) {\n\t\t\tif (this._value.query) {\n\t\t\t\tthis._states.push(UriIteratorState.Query);\n\t\t\t}\n\t\t\tif (this._value.fragment) {\n\t\t\t\tthis._states.push(UriIteratorState.Fragment);\n\t\t\t}\n\t\t}\n\t\tthis._stateIdx = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n\t\t\tthis._pathIterator.next();\n\t\t} else {\n\t\t\tthis._stateIdx += 1;\n\t\t}\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n\t\t\t|| this._stateIdx < this._states.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn compareIgnoreCase(a, this._value.scheme);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn compareIgnoreCase(a, this._value.authority);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.cmp(a);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn compare(a, this._value.query);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn compare(a, this._value.fragment);\n\t\t}\n\t\tthrow new Error();\n\t}\n\n\tvalue(): string {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn this._value.scheme;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn this._value.authority;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.value();\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn this._value.query;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn this._value.fragment;\n\t\t}\n\t\tthrow new Error();\n\t}\n}\n\nabstract class Undef {\n\n\tstatic readonly Val: unique symbol = Symbol('undefined_placeholder');\n\n\tstatic wrap<V>(value: V | undefined): V | typeof Undef.Val {\n\t\treturn value === undefined ? Undef.Val : value;\n\t}\n\n\tstatic unwrap<V>(value: V | typeof Undef.Val): V | undefined {\n\t\treturn value === Undef.Val ? undefined : value;\n\t}\n}\n\nclass TernarySearchTreeNode<K, V> {\n\theight: number = 1;\n\tsegment!: string;\n\tvalue: V | typeof Undef.Val | undefined = undefined;\n\tkey: K | undefined = undefined;\n\tleft: TernarySearchTreeNode<K, V> | undefined = undefined;\n\tmid: TernarySearchTreeNode<K, V> | undefined = undefined;\n\tright: TernarySearchTreeNode<K, V> | undefined = undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && this.value === undefined;\n\t}\n\n\trotateLeft() {\n\t\tconst tmp = this.right!;\n\t\tthis.right = tmp.left;\n\t\ttmp.left = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\trotateRight() {\n\t\tconst tmp = this.left!;\n\t\tthis.left = tmp.right;\n\t\ttmp.right = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\tupdateHeight() {\n\t\tthis.height = 1 + Math.max(this.heightLeft, this.heightRight);\n\t}\n\n\tbalanceFactor() {\n\t\treturn this.heightRight - this.heightLeft;\n\t}\n\n\tget heightLeft() {\n\t\treturn this.left?.height ?? 0;\n\t}\n\n\tget heightRight() {\n\t\treturn this.right?.height ?? 0;\n\t}\n}\n\nconst enum Dir {\n\tLeft = -1,\n\tMid = 0,\n\tRight = 1\n}\n\nexport class TernarySearchTree<K, V> {\n\n\tstatic forUris<E>(ignorePathCasing: (key: URI) => boolean = () => false, ignoreQueryAndFragment: (key: URI) => boolean = () => false): TernarySearchTree<URI, E> {\n\t\treturn new TernarySearchTree<URI, E>(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));\n\t}\n\n\tstatic forPaths<E>(ignorePathCasing = false): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new PathIterator(undefined, !ignorePathCasing));\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new StringIterator());\n\t}\n\n\tstatic forConfigKeys<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new ConfigKeysIterator());\n\t}\n\n\tprivate _iter: IKeyIterator<K>;\n\tprivate _root: TernarySearchTreeNode<K, V> | undefined;\n\n\tconstructor(segments: IKeyIterator<K>) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\t/**\n\t * Fill the tree with the same value of the given keys\n\t */\n\tfill(element: V, keys: readonly K[]): void;\n\t/**\n\t * Fill the tree with given [key,value]-tuples\n\t */\n\tfill(values: readonly [K, V][]): void;\n\tfill(values: readonly [K, V][] | V, keys?: readonly K[]): void {\n\t\tif (keys) {\n\t\t\tconst arr = keys.slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const k of arr) {\n\t\t\t\tthis.set(k, (<V>values));\n\t\t\t}\n\t\t} else {\n\t\t\tconst arr = (<[K, V][]>values).slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const entry of arr) {\n\t\t\t\tthis.set(entry[0], entry[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key: K, element: V): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<K, V>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<K, V>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\n\t\t// find insert_node\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// set value\n\t\tconst oldElement = Undef.unwrap(node.value);\n\t\tnode.value = Undef.wrap(element);\n\t\tnode.key = key;\n\n\t\t// balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\t// needs rotate\n\t\t\t\tconst d1 = stack[i][0];\n\t\t\t\tconst d2 = stack[i + 1][0];\n\n\t\t\t\tif (d1 === Dir.Right && d2 === Dir.Right) {\n\t\t\t\t\t//right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Left) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else if (d1 === Dir.Right && d2 === Dir.Left) {\n\t\t\t\t\t// right, left -> double rotate right, left\n\t\t\t\t\tnode.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Right) {\n\t\t\t\t\t// left, right -> double rotate left, right\n\t\t\t\t\tnode.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\n\t\t\t\t// patch path to parent\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = stack[0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn oldElement;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn Undef.unwrap(this._getNode(key)?.value);\n\t}\n\n\tprivate _getNode(key: K) {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\thas(key: K): boolean {\n\t\tconst node = this._getNode(key);\n\t\treturn !(node?.value === undefined && node?.mid === undefined);\n\t}\n\n\tdelete(key: K): void {\n\t\treturn this._delete(key, false);\n\t}\n\n\tdeleteSuperstr(key: K): void {\n\t\treturn this._delete(key, true);\n\t}\n\n\tprivate _delete(key: K, superStr: boolean): void {\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\t// node not found\n\t\t\treturn;\n\t\t}\n\n\t\tif (superStr) {\n\t\t\t// removing children, reset height\n\t\t\tnode.left = undefined;\n\t\t\tnode.mid = undefined;\n\t\t\tnode.right = undefined;\n\t\t\tnode.height = 1;\n\t\t} else {\n\t\t\t// removing element\n\t\t\tnode.key = undefined;\n\t\t\tnode.value = undefined;\n\t\t}\n\n\t\t// BST node removal\n\t\tif (!node.mid && !node.value) {\n\t\t\tif (node.left && node.right) {\n\t\t\t\t// full node\n\t\t\t\t// replace deleted-node with the min-node of the right branch.\n\t\t\t\t// If there is no true min-node leave things as they are\n\t\t\t\tconst stack2: typeof stack = [[Dir.Right, node]];\n\t\t\t\tconst min = this._min(node.right, stack2);\n\n\t\t\t\tif (min.key) {\n\n\t\t\t\t\tnode.key = min.key;\n\t\t\t\t\tnode.value = min.value;\n\t\t\t\t\tnode.segment = min.segment;\n\n\t\t\t\t\t// remove NODE (inorder successor can only have right child)\n\t\t\t\t\tconst newChild = min.right;\n\t\t\t\t\tif (stack2.length > 1) {\n\t\t\t\t\t\tconst [dir, parent] = stack2[stack2.length - 1];\n\t\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\t\tcase Dir.Left: parent.left = newChild; break;\n\t\t\t\t\t\t\tcase Dir.Mid: assert(false);\n\t\t\t\t\t\t\tcase Dir.Right: assert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.right = newChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// balance right branch and UPDATE parent pointer for stack\n\t\t\t\t\tconst newChild2 = this._balanceByStack(stack2)!;\n\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\tconst [dir, parent] = stack[stack.length - 1];\n\t\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\t\tcase Dir.Left: parent.left = newChild2; break;\n\t\t\t\t\t\t\tcase Dir.Mid: parent.mid = newChild2; break;\n\t\t\t\t\t\t\tcase Dir.Right: parent.right = newChild2; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._root = newChild2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// empty or half empty\n\t\t\t\tconst newChild = node.left ?? node.right;\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tconst [dir, parent] = stack[stack.length - 1];\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase Dir.Left: parent.left = newChild; break;\n\t\t\t\t\t\tcase Dir.Mid: parent.mid = newChild; break;\n\t\t\t\t\t\tcase Dir.Right: parent.right = newChild; break;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = newChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// AVL balance\n\t\tthis._root = this._balanceByStack(stack) ?? this._root;\n\t}\n\n\tprivate _min(node: TernarySearchTreeNode<K, V>, stack: [Dir, TernarySearchTreeNode<K, V>][]): TernarySearchTreeNode<K, V> {\n\t\twhile (node.left) {\n\t\t\tstack.push([Dir.Left, node]);\n\t\t\tnode = node.left;\n\t\t}\n\t\treturn node;\n\t}\n\n\tprivate _balanceByStack(stack: [Dir, TernarySearchTreeNode<K, V>][]) {\n\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf > 1) {\n\t\t\t\t// right heavy\n\t\t\t\tif (node.right!.balanceFactor() >= 0) {\n\t\t\t\t\t// right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t} else {\n\t\t\t\t\t// right, left -> double rotate\n\t\t\t\t\tnode.right = node.right!.rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t}\n\n\t\t\t} else if (bf < -1) {\n\t\t\t\t// left heavy\n\t\t\t\tif (node.left!.balanceFactor() <= 0) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t} else {\n\t\t\t\t\t// left, right -> double rotate\n\t\t\t\t\tnode.left = node.left!.rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch path to parent\n\t\t\tif (i > 0) {\n\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn stack[0][1];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tfindSubstr(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: V | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = Undef.unwrap(node.value) || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && Undef.unwrap(node.value) || candidate;\n\t}\n\n\tfindSuperstr(key: K): IterableIterator<[K, V]> | undefined {\n\t\treturn this._findSuperstrOrElement(key, false);\n\t}\n\n\tprivate _findSuperstrOrElement(key: K, allowValue: true): IterableIterator<[K, V]> | V | undefined;\n\tprivate _findSuperstrOrElement(key: K, allowValue: false): IterableIterator<[K, V]> | undefined;\n\tprivate _findSuperstrOrElement(key: K, allowValue: boolean): IterableIterator<[K, V]> | V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tif (allowValue) {\n\t\t\t\t\t\treturn Undef.unwrap(node.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this._entries(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\thasElementOrSubtree(key: K): boolean {\n\t\treturn this._findSuperstrOrElement(key, true) !== undefined;\n\t}\n\n\tforEach(callback: (value: V, index: K) => unknown): void {\n\t\tfor (const [key, value] of this) {\n\t\t\tcallback(value, key);\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\tyield* this._entries(this._root);\n\t}\n\n\tprivate _entries(node: TernarySearchTreeNode<K, V> | undefined): IterableIterator<[K, V]> {\n\t\tconst result: [K, V][] = [];\n\t\tthis._dfsEntries(node, result);\n\t\treturn result[Symbol.iterator]();\n\t}\n\n\tprivate _dfsEntries(node: TernarySearchTreeNode<K, V> | undefined, bucket: [K, V][]) {\n\t\t// DFS\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.left) {\n\t\t\tthis._dfsEntries(node.left, bucket);\n\t\t}\n\t\tif (node.value !== undefined) {\n\t\t\tbucket.push([node.key!, Undef.unwrap(node.value)!]);\n\t\t}\n\t\tif (node.mid) {\n\t\t\tthis._dfsEntries(node.mid, bucket);\n\t\t}\n\t\tif (node.right) {\n\t\t\tthis._dfsEntries(node.right, bucket);\n\t\t}\n\t}\n\n\t// for debug/testing\n\t_isBalanced(): boolean {\n\t\tconst nodeIsBalanced = (node: TernarySearchTreeNode<unknown, unknown> | undefined): boolean => {\n\t\t\tif (!node) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn nodeIsBalanced(node.left) && nodeIsBalanced(node.right);\n\t\t};\n\t\treturn nodeIsBalanced(this._root);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { shuffle } from './arrays.js';\nimport { assert } from './assert.js';\nimport { CharCode } from './charCode.js';\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';\nimport { URI } from './uri.js';\n\nexport interface IKeyIterator<K> {\n\treset(key: K): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator<string> {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class ConfigKeysIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Period) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _valueLen!: number;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _splitOnBackslash: boolean = true,\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\tthis._value = key;\n\t\tthis._valueLen = key.length;\n\t\tfor (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n\t\t\tconst ch = this._value.charCodeAt(pos);\n\t\t\tif (!(ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._valueLen;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._valueLen; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nconst enum UriIteratorState {\n\tScheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n\tprivate _pathIterator!: PathIterator;\n\tprivate _value!: URI;\n\tprivate _states: UriIteratorState[] = [];\n\tprivate _stateIdx: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _ignorePathCasing: (uri: URI) => boolean,\n\t\tprivate readonly _ignoreQueryAndFragment: (uri: URI) => boolean) { }\n\n\treset(key: URI): this {\n\t\tthis._value = key;\n\t\tthis._states = [];\n\t\tif (this._value.scheme) {\n\t\t\tthis._states.push(UriIteratorState.Scheme);\n\t\t}\n\t\tif (this._value.authority) {\n\t\t\tthis._states.push(UriIteratorState.Authority);\n\t\t}\n\t\tif (this._value.path) {\n\t\t\tthis._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n\t\t\tthis._pathIterator.reset(key.path);\n\t\t\tif (this._pathIterator.value()) {\n\t\t\t\tthis._states.push(UriIteratorState.Path);\n\t\t\t}\n\t\t}\n\t\tif (!this._ignoreQueryAndFragment(key)) {\n\t\t\tif (this._value.query) {\n\t\t\t\tthis._states.push(UriIteratorState.Query);\n\t\t\t}\n\t\t\tif (this._value.fragment) {\n\t\t\t\tthis._states.push(UriIteratorState.Fragment);\n\t\t\t}\n\t\t}\n\t\tthis._stateIdx = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n\t\t\tthis._pathIterator.next();\n\t\t} else {\n\t\t\tthis._stateIdx += 1;\n\t\t}\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n\t\t\t|| this._stateIdx < this._states.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn compareIgnoreCase(a, this._value.scheme);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn compareIgnoreCase(a, this._value.authority);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.cmp(a);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn compare(a, this._value.query);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn compare(a, this._value.fragment);\n\t\t}\n\t\tthrow new Error();\n\t}\n\n\tvalue(): string {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn this._value.scheme;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn this._value.authority;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.value();\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn this._value.query;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn this._value.fragment;\n\t\t}\n\t\tthrow new Error();\n\t}\n}\n\nabstract class Undef {\n\n\tstatic readonly Val: unique symbol = Symbol('undefined_placeholder');\n\n\tstatic wrap<V>(value: V | undefined): V | typeof Undef.Val {\n\t\treturn value === undefined ? Undef.Val : value;\n\t}\n\n\tstatic unwrap<V>(value: V | typeof Undef.Val): V | undefined {\n\t\treturn value === Undef.Val ? undefined : value;\n\t}\n}\n\nclass TernarySearchTreeNode<K, V> {\n\theight: number = 1;\n\tsegment!: string;\n\tvalue: V | typeof Undef.Val | undefined = undefined;\n\tkey: K | undefined = undefined;\n\tleft: TernarySearchTreeNode<K, V> | undefined = undefined;\n\tmid: TernarySearchTreeNode<K, V> | undefined = undefined;\n\tright: TernarySearchTreeNode<K, V> | undefined = undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && this.value === undefined;\n\t}\n\n\trotateLeft() {\n\t\tconst tmp = this.right!;\n\t\tthis.right = tmp.left;\n\t\ttmp.left = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\trotateRight() {\n\t\tconst tmp = this.left!;\n\t\tthis.left = tmp.right;\n\t\ttmp.right = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\tupdateHeight() {\n\t\tthis.height = 1 + Math.max(this.heightLeft, this.heightRight);\n\t}\n\n\tbalanceFactor() {\n\t\treturn this.heightRight - this.heightLeft;\n\t}\n\n\tget heightLeft() {\n\t\treturn this.left?.height ?? 0;\n\t}\n\n\tget heightRight() {\n\t\treturn this.right?.height ?? 0;\n\t}\n}\n\nconst enum Dir {\n\tLeft = -1,\n\tMid = 0,\n\tRight = 1\n}\n\nexport class TernarySearchTree<K, V> {\n\n\tstatic forUris<E>(ignorePathCasing: (key: URI) => boolean = () => false, ignoreQueryAndFragment: (key: URI) => boolean = () => false): TernarySearchTree<URI, E> {\n\t\treturn new TernarySearchTree<URI, E>(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));\n\t}\n\n\tstatic forPaths<E>(ignorePathCasing = false): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new PathIterator(undefined, !ignorePathCasing));\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new StringIterator());\n\t}\n\n\tstatic forConfigKeys<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new ConfigKeysIterator());\n\t}\n\n\tprivate _iter: IKeyIterator<K>;\n\tprivate _root: TernarySearchTreeNode<K, V> | undefined;\n\n\tconstructor(segments: IKeyIterator<K>) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\t/**\n\t * Fill the tree with the same value of the given keys\n\t */\n\tfill(element: V, keys: readonly K[]): void;\n\t/**\n\t * Fill the tree with given [key,value]-tuples\n\t */\n\tfill(values: readonly [K, V][]): void;\n\tfill(values: readonly [K, V][] | V, keys?: readonly K[]): void {\n\t\tif (keys) {\n\t\t\tconst arr = keys.slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const k of arr) {\n\t\t\t\tthis.set(k, (<V>values));\n\t\t\t}\n\t\t} else {\n\t\t\tconst arr = (<[K, V][]>values).slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const entry of arr) {\n\t\t\t\tthis.set(entry[0], entry[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key: K, element: V): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<K, V>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<K, V>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\n\t\t// find insert_node\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// set value\n\t\tconst oldElement = Undef.unwrap(node.value);\n\t\tnode.value = Undef.wrap(element);\n\t\tnode.key = key;\n\n\t\t// balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\t// needs rotate\n\t\t\t\tconst d1 = stack[i][0];\n\t\t\t\tconst d2 = stack[i + 1][0];\n\n\t\t\t\tif (d1 === Dir.Right && d2 === Dir.Right) {\n\t\t\t\t\t//right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Left) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else if (d1 === Dir.Right && d2 === Dir.Left) {\n\t\t\t\t\t// right, left -> double rotate right, left\n\t\t\t\t\tnode.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Right) {\n\t\t\t\t\t// left, right -> double rotate left, right\n\t\t\t\t\tnode.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\n\t\t\t\t// patch path to parent\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = stack[0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn oldElement;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn Undef.unwrap(this._getNode(key)?.value);\n\t}\n\n\tprivate _getNode(key: K) {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\thas(key: K): boolean {\n\t\tconst node = this._getNode(key);\n\t\treturn !(node?.value === undefined && node?.mid === undefined);\n\t}\n\n\tdelete(key: K): void {\n\t\treturn this._delete(key, false);\n\t}\n\n\tdeleteSuperstr(key: K): void {\n\t\treturn this._delete(key, true);\n\t}\n\n\tprivate _delete(key: K, superStr: boolean): void {\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\t// node not found\n\t\t\treturn;\n\t\t}\n\n\t\tif (superStr) {\n\t\t\t// removing children, reset height\n\t\t\tnode.left = undefined;\n\t\t\tnode.mid = undefined;\n\t\t\tnode.right = undefined;\n\t\t\tnode.height = 1;\n\t\t} else {\n\t\t\t// removing element\n\t\t\tnode.key = undefined;\n\t\t\tnode.value = undefined;\n\t\t}\n\n\t\t// BST node removal\n\t\tif (!node.mid && !node.value) {\n\t\t\tif (node.left && node.right) {\n\t\t\t\t// full node\n\t\t\t\t// replace deleted-node with the min-node of the right branch.\n\t\t\t\t// If there is no true min-node leave things as they are\n\t\t\t\tconst stack2: typeof stack = [[Dir.Right, node]];\n\t\t\t\tconst min = this._min(node.right, stack2);\n\n\t\t\t\tif (min.key) {\n\n\t\t\t\t\tnode.key = min.key;\n\t\t\t\t\tnode.value = min.value;\n\t\t\t\t\tnode.segment = min.segment;\n\n\t\t\t\t\t// remove NODE (inorder successor can only have right child)\n\t\t\t\t\tconst newChild = min.right;\n\t\t\t\t\tif (stack2.length > 1) {\n\t\t\t\t\t\tconst [dir, parent] = stack2[stack2.length - 1];\n\t\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\t\tcase Dir.Left: parent.left = newChild; break;\n\t\t\t\t\t\t\tcase Dir.Mid: assert(false);\n\t\t\t\t\t\t\tcase Dir.Right: assert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.right = newChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// balance right branch and UPDATE parent pointer for stack\n\t\t\t\t\tconst newChild2 = this._balanceByStack(stack2)!;\n\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\tconst [dir, parent] = stack[stack.length - 1];\n\t\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\t\tcase Dir.Left: parent.left = newChild2; break;\n\t\t\t\t\t\t\tcase Dir.Mid: parent.mid = newChild2; break;\n\t\t\t\t\t\t\tcase Dir.Right: parent.right = newChild2; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._root = newChild2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// empty or half empty\n\t\t\t\tconst newChild = node.left ?? node.right;\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tconst [dir, parent] = stack[stack.length - 1];\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase Dir.Left: parent.left = newChild; break;\n\t\t\t\t\t\tcase Dir.Mid: parent.mid = newChild; break;\n\t\t\t\t\t\tcase Dir.Right: parent.right = newChild; break;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = newChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// AVL balance\n\t\tthis._root = this._balanceByStack(stack) ?? this._root;\n\t}\n\n\tprivate _min(node: TernarySearchTreeNode<K, V>, stack: [Dir, TernarySearchTreeNode<K, V>][]): TernarySearchTreeNode<K, V> {\n\t\twhile (node.left) {\n\t\t\tstack.push([Dir.Left, node]);\n\t\t\tnode = node.left;\n\t\t}\n\t\treturn node;\n\t}\n\n\tprivate _balanceByStack(stack: [Dir, TernarySearchTreeNode<K, V>][]) {\n\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf > 1) {\n\t\t\t\t// right heavy\n\t\t\t\tif (node.right!.balanceFactor() >= 0) {\n\t\t\t\t\t// right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t} else {\n\t\t\t\t\t// right, left -> double rotate\n\t\t\t\t\tnode.right = node.right!.rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t}\n\n\t\t\t} else if (bf < -1) {\n\t\t\t\t// left heavy\n\t\t\t\tif (node.left!.balanceFactor() <= 0) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t} else {\n\t\t\t\t\t// left, right -> double rotate\n\t\t\t\t\tnode.left = node.left!.rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch path to parent\n\t\t\tif (i > 0) {\n\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn stack[0][1];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tfindSubstr(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: V | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = Undef.unwrap(node.value) || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && Undef.unwrap(node.value) || candidate;\n\t}\n\n\tfindSuperstr(key: K): IterableIterator<[K, V]> | undefined {\n\t\treturn this._findSuperstrOrElement(key, false);\n\t}\n\n\tprivate _findSuperstrOrElement(key: K, allowValue: true): IterableIterator<[K, V]> | V | undefined;\n\tprivate _findSuperstrOrElement(key: K, allowValue: false): IterableIterator<[K, V]> | undefined;\n\tprivate _findSuperstrOrElement(key: K, allowValue: boolean): IterableIterator<[K, V]> | V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tif (allowValue) {\n\t\t\t\t\t\treturn Undef.unwrap(node.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this._entries(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\thasElementOrSubtree(key: K): boolean {\n\t\treturn this._findSuperstrOrElement(key, true) !== undefined;\n\t}\n\n\tforEach(callback: (value: V, index: K) => unknown): void {\n\t\tfor (const [key, value] of this) {\n\t\t\tcallback(value, key);\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\tyield* this._entries(this._root);\n\t}\n\n\tprivate _entries(node: TernarySearchTreeNode<K, V> | undefined): IterableIterator<[K, V]> {\n\t\tconst result: [K, V][] = [];\n\t\tthis._dfsEntries(node, result);\n\t\treturn result[Symbol.iterator]();\n\t}\n\n\tprivate _dfsEntries(node: TernarySearchTreeNode<K, V> | undefined, bucket: [K, V][]) {\n\t\t// DFS\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.left) {\n\t\t\tthis._dfsEntries(node.left, bucket);\n\t\t}\n\t\tif (node.value !== undefined) {\n\t\t\tbucket.push([node.key!, Undef.unwrap(node.value)!]);\n\t\t}\n\t\tif (node.mid) {\n\t\t\tthis._dfsEntries(node.mid, bucket);\n\t\t}\n\t\tif (node.right) {\n\t\t\tthis._dfsEntries(node.right, bucket);\n\t\t}\n\t}\n\n\t// for debug/testing\n\t_isBalanced(): boolean {\n\t\tconst nodeIsBalanced = (node: TernarySearchTreeNode<unknown, unknown> | undefined): boolean => {\n\t\t\tif (!node) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn nodeIsBalanced(node.left) && nodeIsBalanced(node.right);\n\t\t};\n\t\treturn nodeIsBalanced(this._root);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as descriptors from './descriptors.js';\nimport { ServiceCollection } from './serviceCollection.js';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: DI_TARGET_OBJ): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n\n\texport interface DI_TARGET_OBJ extends Function {\n\t\t[DI_TARGET]: Function;\n\t\t[DI_DEPENDENCIES]: { id: ServiceIdentifier<any>; index: number }[];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n\tgetIfExists<T>(id: ServiceIdentifier<T>): T | undefined;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\nexport type GetLeadingNonServiceArgs<TArgs extends any[]> =\n\tTArgs extends [] ? []\n\t: TArgs extends [...infer TFirst, BrandedService] ? GetLeadingNonServiceArgs<TFirst>\n\t: TArgs;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => unknown, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t *\n\t * NOTE that the returned child is `disposable` and should be disposed when not used\n\t * anymore. This will also dispose all the services that this service has created.\n\t */\n\tcreateChild(services: ServiceCollection, store?: DisposableStore): IInstantiationService;\n\n\t/**\n\t * Disposes this instantiation service.\n\t *\n\t * - Will dispose all services that this instantiation service has created.\n\t * - Will dispose all its children but not its parent.\n\t * - Will NOT dispose services-instances that this service has been created with\n\t * - Will NOT dispose consumer-instances this service has created\n\t */\n\tdispose(): void;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\n\nfunction storeServiceDependency(id: ServiceIdentifier<unknown>, target: Function, index: number): void {\n\tif ((target as _util.DI_TARGET_OBJ)[_util.DI_TARGET] === target) {\n\t\t(target as _util.DI_TARGET_OBJ)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as _util.DI_TARGET_OBJ)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as _util.DI_TARGET_OBJ)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t} as ServiceIdentifier<T>;\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(serviceIdentifier: ServiceIdentifier<T1>): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as descriptors from './descriptors.js';\nimport { ServiceCollection } from './serviceCollection.js';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: DI_TARGET_OBJ): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n\n\texport interface DI_TARGET_OBJ extends Function {\n\t\t[DI_TARGET]: Function;\n\t\t[DI_DEPENDENCIES]: { id: ServiceIdentifier<any>; index: number }[];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n\tgetIfExists<T>(id: ServiceIdentifier<T>): T | undefined;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\nexport type GetLeadingNonServiceArgs<TArgs extends any[]> =\n\tTArgs extends [] ? []\n\t: TArgs extends [...infer TFirst, BrandedService] ? GetLeadingNonServiceArgs<TFirst>\n\t: TArgs;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => unknown, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t *\n\t * NOTE that the returned child is `disposable` and should be disposed when not used\n\t * anymore. This will also dispose all the services that this service has created.\n\t */\n\tcreateChild(services: ServiceCollection, store?: DisposableStore): IInstantiationService;\n\n\t/**\n\t * Disposes this instantiation service.\n\t *\n\t * - Will dispose all services that this instantiation service has created.\n\t * - Will dispose all its children but not its parent.\n\t * - Will NOT dispose services-instances that this service has been created with\n\t * - Will NOT dispose consumer-instances this service has created\n\t */\n\tdispose(): void;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\n\nfunction storeServiceDependency(id: ServiceIdentifier<unknown>, target: Function, index: number): void {\n\tif ((target as _util.DI_TARGET_OBJ)[_util.DI_TARGET] === target) {\n\t\t(target as _util.DI_TARGET_OBJ)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as _util.DI_TARGET_OBJ)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as _util.DI_TARGET_OBJ)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t} as ServiceIdentifier<T>;\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(serviceIdentifier: ServiceIdentifier<T1>): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { IExpression, IRelativePattern } from '../../../base/common/glob.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';\nimport { sep } from '../../../base/common/path.js';\nimport { ReadableStreamEvents } from '../../../base/common/stream.js';\nimport { startsWithIgnoreCase } from '../../../base/common/strings.js';\nimport { isNumber } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { isWeb } from '../../../base/common/platform.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { IMarkdownString } from '../../../base/common/htmlContent.js';\nimport { Lazy } from '../../../base/common/lazy.js';\n\n//#region file service & providers\n\nexport const IFileService = createDecorator<IFileService>('fileService');\n\nexport interface IFileService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that is fired when a file system provider is added or removed\n\t */\n\treadonly onDidChangeFileSystemProviderRegistrations: Event<IFileSystemProviderRegistrationEvent>;\n\n\t/**\n\t * An event that is fired when a registered file system provider changes its capabilities.\n\t */\n\treadonly onDidChangeFileSystemProviderCapabilities: Event<IFileSystemProviderCapabilitiesChangeEvent>;\n\n\t/**\n\t * An event that is fired when a file system provider is about to be activated. Listeners\n\t * can join this event with a long running promise to help in the activation process.\n\t */\n\treadonly onWillActivateFileSystemProvider: Event<IFileSystemProviderActivationEvent>;\n\n\t/**\n\t * Registers a file system provider for a certain scheme.\n\t */\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable;\n\n\t/**\n\t * Returns a file system provider for a certain scheme.\n\t */\n\tgetProvider(scheme: string): IFileSystemProvider | undefined;\n\n\t/**\n\t * Tries to activate a provider with the given scheme.\n\t */\n\tactivateProvider(scheme: string): Promise<void>;\n\n\t/**\n\t * Checks if this file service can handle the given resource by\n\t * first activating any extension that wants to be activated\n\t * on the provided resource scheme to include extensions that\n\t * contribute file system providers for the given resource.\n\t */\n\tcanHandleResource(resource: URI): Promise<boolean>;\n\n\t/**\n\t * Checks if the file service has a registered provider for the\n\t * provided resource.\n\t *\n\t * Note: this does NOT account for contributed providers from\n\t * extensions that have not been activated yet. To include those,\n\t * consider to call `await fileService.canHandleResource(resource)`.\n\t */\n\thasProvider(resource: URI): boolean;\n\n\t/**\n\t * Checks if the provider for the provided resource has the provided file system capability.\n\t */\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean;\n\n\t/**\n\t * List the schemes and capabilities for registered file system providers\n\t */\n\tlistCapabilities(): Iterable<{ scheme: string; capabilities: FileSystemProviderCapabilities }>;\n\n\t/**\n\t * Allows to listen for file changes. The event will fire for every file within the opened workspace\n\t * (if any) as well as all files that have been watched explicitly using the #watch() API.\n\t */\n\treadonly onDidFilesChange: Event<FileChangesEvent>;\n\n\t/**\n\t * An event that is fired upon successful completion of a certain file operation.\n\t */\n\treadonly onDidRunOperation: Event<FileOperationEvent>;\n\n\t/**\n\t * Resolve the properties of a file/folder identified by the resource. For a folder, children\n\t * information is resolved as well depending on the provided options. Use `stat()` method if\n\t * you do not need children information.\n\t *\n\t * If the optional parameter \"resolveTo\" is specified in options, the stat service is asked\n\t * to provide a stat object that should contain the full graph of folders up to all of the\n\t * target resources.\n\t *\n\t * If the optional parameter \"resolveSingleChildDescendants\" is specified in options,\n\t * the stat service is asked to automatically resolve child folders that only\n\t * contain a single element.\n\t *\n\t * If the optional parameter \"resolveMetadata\" is specified in options,\n\t * the stat will contain metadata information such as size, mtime and etag.\n\t */\n\tresolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tresolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\n\t/**\n\t * Same as `resolve()` but supports resolving multiple resources in parallel.\n\t *\n\t * If one of the resolve targets fails to resolve returns a fake `IFileStat` instead of\n\t * making the whole call fail.\n\t */\n\tresolveAll(toResolve: { resource: URI; options: IResolveMetadataFileOptions }[]): Promise<IFileStatResult[]>;\n\tresolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]>;\n\n\t/**\n\t * Same as `resolve()` but without resolving the children of a folder if the\n\t * resource is pointing to a folder.\n\t */\n\tstat(resource: URI): Promise<IFileStatWithPartialMetadata>;\n\n\t/**\n\t * Attempts to resolve the real path of the provided resource. The real path can be\n\t * different from the resource path for example when it is a symlink.\n\t *\n\t * Will return `undefined` if the real path cannot be resolved.\n\t */\n\trealpath(resource: URI): Promise<URI | undefined>;\n\n\t/**\n\t * Finds out if a file/folder identified by the resource exists.\n\t */\n\texists(resource: URI): Promise<boolean>;\n\n\t/**\n\t * Read the contents of the provided resource unbuffered.\n\t */\n\treadFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent>;\n\n\t/**\n\t * Read the contents of the provided resource buffered as stream.\n\t */\n\treadFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent>;\n\n\t/**\n\t * Updates the content replacing its previous value.\n\t *\n\t * Emits a `FileOperation.WRITE` file operation event when successful.\n\t */\n\twriteFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Moves the file/folder to a new path identified by the resource.\n\t *\n\t * The optional parameter overwrite can be set to replace an existing file at the location.\n\t *\n\t * Emits a `FileOperation.MOVE` file operation event when successful.\n\t */\n\tmove(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a move operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;\n\n\t/**\n\t * Copies the file/folder to a path identified by the resource. A folder is copied\n\t * recursively.\n\t *\n\t * Emits a `FileOperation.COPY` file operation event when successful.\n\t */\n\tcopy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a copy operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;\n\n\t/**\n\t * Clones a file to a path identified by the resource. Folders are not supported.\n\t *\n\t * If the target path exists, it will be overwritten.\n\t */\n\tcloneFile(source: URI, target: URI): Promise<void>;\n\n\t/**\n\t * Creates a new file with the given path and optional contents. The returned promise\n\t * will have the stat model object as a result.\n\t *\n\t * The optional parameter content can be used as value to fill into the new file.\n\t *\n\t * Emits a `FileOperation.CREATE` file operation event when successful.\n\t */\n\tcreateFile(resource: URI, bufferOrReadableOrStream?: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: ICreateFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a file create operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true>;\n\n\t/**\n\t * Creates a new folder with the given path. The returned promise\n\t * will have the stat model object as a result.\n\t *\n\t * Emits a `FileOperation.CREATE` file operation event when successful.\n\t */\n\tcreateFolder(resource: URI): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Deletes the provided file. The optional useTrash parameter allows to\n\t * move the file to trash. The optional recursive parameter allows to delete\n\t * non-empty folders recursively.\n\t *\n\t * Emits a `FileOperation.DELETE` file operation event when successful.\n\t */\n\tdel(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void>;\n\n\t/**\n\t * Find out if a delete operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true>;\n\n\t/**\n\t * An event that signals an error when watching for file changes.\n\t */\n\treadonly onDidWatchError: Event<Error>;\n\n\t/**\n\t * Allows to start a watcher that reports file/folder change events on the provided resource.\n\t *\n\t * The watcher runs correlated and thus, file events will be reported on the returned\n\t * `IFileSystemWatcher` and not on the generic `IFileService.onDidFilesChange` event.\n\t *\n\t * Note: only non-recursive file watching supports event correlation for now.\n\t */\n\tcreateWatcher(resource: URI, options: IWatchOptionsWithoutCorrelation & { recursive: false }): IFileSystemWatcher;\n\n\t/**\n\t * Allows to start a watcher that reports file/folder change events on the provided resource.\n\t *\n\t * The watcher runs uncorrelated and thus will report all events from `IFileService.onDidFilesChange`.\n\t * This means, most listeners in the application will receive your events. It is encouraged to\n\t * use correlated watchers (via `IWatchOptionsWithCorrelation`) to limit events to your listener.\n\t*/\n\twatch(resource: URI, options?: IWatchOptionsWithoutCorrelation): IDisposable;\n\n\t/**\n\t * Frees up any resources occupied by this service.\n\t */\n\tdispose(): void;\n}\n\nexport interface IFileOverwriteOptions {\n\n\t/**\n\t * Set to `true` to overwrite a file if it exists. Will\n\t * throw an error otherwise if the file does exist.\n\t */\n\treadonly overwrite: boolean;\n}\n\nexport interface IFileUnlockOptions {\n\n\t/**\n\t * Set to `true` to try to remove any write locks the file might\n\t * have. A file that is write locked will throw an error for any\n\t * attempt to write to unless `unlock: true` is provided.\n\t */\n\treadonly unlock: boolean;\n}\n\nexport interface IFileAtomicReadOptions {\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `readFile` method is not running in parallel with\n\t * any `write` operations in the same process.\n\t *\n\t * Typically you should not need to use this flag but if\n\t * for example you are quickly reading a file right after\n\t * a file event occurred and the file changes a lot, there\n\t * is a chance that a read returns an empty or partial file\n\t * because a pending write has not finished yet.\n\t *\n\t * Note: this does not prevent the file from being written\n\t * to from a different process. If you need such atomic\n\t * operations, you better use a real database as storage.\n\t */\n\treadonly atomic: boolean;\n}\n\nexport interface IFileAtomicOptions {\n\n\t/**\n\t * The postfix is used to create a temporary file based\n\t * on the original resource. The resulting temporary\n\t * file will be in the same folder as the resource and\n\t * have `postfix` appended to the resource name.\n\t *\n\t * Example: given a file resource `file:///some/path/foo.txt`\n\t * and a postfix `.vsctmp`, the temporary file will be\n\t * created as `file:///some/path/foo.txt.vsctmp`.\n\t */\n\treadonly postfix: string;\n}\n\nexport interface IFileAtomicWriteOptions {\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `writeFile` method updates the target file atomically\n\t * by first writing to a temporary file in the same folder\n\t * and then renaming it over the target.\n\t */\n\treadonly atomic: IFileAtomicOptions | false;\n}\n\nexport interface IFileAtomicDeleteOptions {\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `delete` method deletes the target atomically by\n\t * first renaming it to a temporary resource in the same\n\t * folder and then deleting it.\n\t */\n\treadonly atomic: IFileAtomicOptions | false;\n}\n\nexport interface IFileReadLimits {\n\n\t/**\n\t * If the file exceeds the given size, an error of kind\n\t * `FILE_TOO_LARGE` will be thrown.\n\t */\n\tsize?: number;\n}\n\nexport interface IFileReadStreamOptions {\n\n\t/**\n\t * Is an integer specifying where to begin reading from in the file. If position is undefined,\n\t * data will be read from the current file position.\n\t */\n\treadonly position?: number;\n\n\t/**\n\t * Is an integer specifying how many bytes to read from the file. By default, all bytes\n\t * will be read.\n\t */\n\treadonly length?: number;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport interface IFileWriteOptions extends IFileOverwriteOptions, IFileUnlockOptions, IFileAtomicWriteOptions {\n\n\t/**\n\t * Set to `true` to create a file when it does not exist. Will\n\t * throw an error otherwise if the file does not exist.\n\t */\n\treadonly create: boolean;\n}\n\nexport type IFileOpenOptions = IFileOpenForReadOptions | IFileOpenForWriteOptions;\n\nexport function isFileOpenForWriteOptions(options: IFileOpenOptions): options is IFileOpenForWriteOptions {\n\treturn options.create === true;\n}\n\nexport interface IFileOpenForReadOptions {\n\n\t/**\n\t * A hint that the file should be opened for reading only.\n\t */\n\treadonly create: false;\n}\n\nexport interface IFileOpenForWriteOptions extends IFileUnlockOptions {\n\n\t/**\n\t * A hint that the file should be opened for reading and writing.\n\t */\n\treadonly create: true;\n}\n\nexport interface IFileDeleteOptions {\n\n\t/**\n\t * Set to `true` to recursively delete any children of the file. This\n\t * only applies to folders and can lead to an error unless provided\n\t * if the folder is not empty.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * Set to `true` to attempt to move the file to trash\n\t * instead of deleting it permanently from disk.\n\t *\n\t * This option maybe not be supported on all providers.\n\t */\n\treadonly useTrash: boolean;\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `delete` method deletes the target atomically by\n\t * first renaming it to a temporary resource in the same\n\t * folder and then deleting it.\n\t *\n\t * This option maybe not be supported on all providers.\n\t */\n\treadonly atomic: IFileAtomicOptions | false;\n}\n\nexport enum FileType {\n\n\t/**\n\t * File is unknown (neither file, directory nor symbolic link).\n\t */\n\tUnknown = 0,\n\n\t/**\n\t * File is a normal file.\n\t */\n\tFile = 1,\n\n\t/**\n\t * File is a directory.\n\t */\n\tDirectory = 2,\n\n\t/**\n\t * File is a symbolic link.\n\t *\n\t * Note: even when the file is a symbolic link, you can test for\n\t * `FileType.File` and `FileType.Directory` to know the type of\n\t * the target the link points to.\n\t */\n\tSymbolicLink = 64\n}\n\nexport enum FilePermission {\n\n\t/**\n\t * File is readonly. Components like editors should not\n\t * offer to edit the contents.\n\t */\n\tReadonly = 1,\n\n\t/**\n\t * File is locked. Components like editors should offer\n\t * to edit the contents and ask the user upon saving to\n\t * remove the lock.\n\t */\n\tLocked = 2\n}\n\nexport interface IStat {\n\n\t/**\n\t * The file type.\n\t */\n\treadonly type: FileType;\n\n\t/**\n\t * The last modification date represented as millis from unix epoch.\n\t */\n\treadonly mtime: number;\n\n\t/**\n\t * The creation date represented as millis from unix epoch.\n\t */\n\treadonly ctime: number;\n\n\t/**\n\t * The size of the file in bytes.\n\t */\n\treadonly size: number;\n\n\t/**\n\t * The file permissions.\n\t */\n\treadonly permissions?: FilePermission;\n}\n\nexport interface IWatchOptionsWithoutCorrelation {\n\n\t/**\n\t * Set to `true` to watch for changes recursively in a folder\n\t * and all of its children.\n\t */\n\trecursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t * Paths can be relative or absolute and when relative are\n\t * resolved against the watched folder. Glob patterns are\n\t * always matched relative to the watched folder.\n\t */\n\texcludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t * Paths can be relative or absolute and when relative are\n\t * resolved against the watched folder. Glob patterns are\n\t * always matched relative to the watched folder.\n\t */\n\tincludes?: Array<string | IRelativePattern>;\n\n\t/**\n\t * If provided, allows to filter the events that the watcher should consider\n\t * for emitting. If not provided, all events are emitted.\n\t *\n\t * For example, to emit added and updated events, set to:\n\t * `FileChangeFilter.ADDED | FileChangeFilter.UPDATED`.\n\t */\n\tfilter?: FileChangeFilter;\n}\n\nexport interface IWatchOptions extends IWatchOptionsWithoutCorrelation {\n\n\t/**\n\t * If provided, file change events from the watcher that\n\t * are a result of this watch request will carry the same\n\t * id.\n\t */\n\treadonly correlationId?: number;\n}\n\nexport const enum FileChangeFilter {\n\tUPDATED = 1 << 1,\n\tADDED = 1 << 2,\n\tDELETED = 1 << 3\n}\n\nexport interface IWatchOptionsWithCorrelation extends IWatchOptions {\n\treadonly correlationId: number;\n}\n\nexport interface IFileSystemWatcher extends IDisposable {\n\n\t/**\n\t * An event which fires on file/folder change only for changes\n\t * that correlate to the watch request with matching correlation\n\t * identifier.\n\t */\n\treadonly onDidChange: Event<FileChangesEvent>;\n}\n\nexport function isFileSystemWatcher(thing: unknown): thing is IFileSystemWatcher {\n\tconst candidate = thing as IFileSystemWatcher | undefined;\n\n\treturn !!candidate && typeof candidate.onDidChange === 'function';\n}\n\nexport const enum FileSystemProviderCapabilities {\n\n\t/**\n\t * No capabilities.\n\t */\n\tNone = 0,\n\n\t/**\n\t * Provider supports unbuffered read/write.\n\t */\n\tFileReadWrite = 1 << 1,\n\n\t/**\n\t * Provider supports open/read/write/close low level file operations.\n\t */\n\tFileOpenReadWriteClose = 1 << 2,\n\n\t/**\n\t * Provider supports stream based reading.\n\t */\n\tFileReadStream = 1 << 4,\n\n\t/**\n\t * Provider supports copy operation.\n\t */\n\tFileFolderCopy = 1 << 3,\n\n\t/**\n\t * Provider is path case sensitive.\n\t */\n\tPathCaseSensitive = 1 << 10,\n\n\t/**\n\t * All files of the provider are readonly.\n\t */\n\tReadonly = 1 << 11,\n\n\t/**\n\t * Provider supports to delete via trash.\n\t */\n\tTrash = 1 << 12,\n\n\t/**\n\t * Provider support to unlock files for writing.\n\t */\n\tFileWriteUnlock = 1 << 13,\n\n\t/**\n\t * Provider support to read files atomically. This implies the\n\t * provider provides the `FileReadWrite` capability too.\n\t */\n\tFileAtomicRead = 1 << 14,\n\n\t/**\n\t * Provider support to write files atomically. This implies the\n\t * provider provides the `FileReadWrite` capability too.\n\t */\n\tFileAtomicWrite = 1 << 15,\n\n\t/**\n\t * Provider support to delete atomically.\n\t */\n\tFileAtomicDelete = 1 << 16,\n\n\t/**\n\t * Provider support to clone files atomically.\n\t */\n\tFileClone = 1 << 17,\n\n\t/**\n\t * Provider support to resolve real paths.\n\t */\n\tFileRealpath = 1 << 18\n}\n\nexport interface IFileSystemProvider {\n\n\treadonly capabilities: FileSystemProviderCapabilities;\n\treadonly onDidChangeCapabilities: Event<void>;\n\n\treadonly onDidChangeFile: Event<readonly IFileChange[]>;\n\treadonly onDidWatchError?: Event<string>;\n\twatch(resource: URI, opts: IWatchOptions): IDisposable;\n\n\tstat(resource: URI): Promise<IStat>;\n\tmkdir(resource: URI): Promise<void>;\n\treaddir(resource: URI): Promise<[string, FileType][]>;\n\tdelete(resource: URI, opts: IFileDeleteOptions): Promise<void>;\n\n\trename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;\n\tcopy?(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;\n\n\treadFile?(resource: URI): Promise<Uint8Array>;\n\twriteFile?(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;\n\n\treadFileStream?(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n\n\topen?(resource: URI, opts: IFileOpenOptions): Promise<number>;\n\tclose?(fd: number): Promise<void>;\n\tread?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\twrite?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n\tcloneFile?(from: URI, to: URI): Promise<void>;\n}\n\nexport interface IFileSystemProviderWithFileReadWriteCapability extends IFileSystemProvider {\n\treadFile(resource: URI): Promise<Uint8Array>;\n\twriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;\n}\n\nexport function hasReadWriteCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileReadWriteCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);\n}\n\nexport interface IFileSystemProviderWithFileFolderCopyCapability extends IFileSystemProvider {\n\tcopy(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;\n}\n\nexport function hasFileFolderCopyCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileFolderCopyCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);\n}\n\nexport interface IFileSystemProviderWithFileCloneCapability extends IFileSystemProvider {\n\tcloneFile(from: URI, to: URI): Promise<void>;\n}\n\nexport function hasFileCloneCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileCloneCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileClone);\n}\n\nexport interface IFileSystemProviderWithFileRealpathCapability extends IFileSystemProvider {\n\trealpath(resource: URI): Promise<string>;\n}\n\nexport function hasFileRealpathCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileRealpathCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileRealpath);\n}\n\nexport interface IFileSystemProviderWithOpenReadWriteCloseCapability extends IFileSystemProvider {\n\topen(resource: URI, opts: IFileOpenOptions): Promise<number>;\n\tclose(fd: number): Promise<void>;\n\tread(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport function hasOpenReadWriteCloseCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithOpenReadWriteCloseCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);\n}\n\nexport interface IFileSystemProviderWithFileReadStreamCapability extends IFileSystemProvider {\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n}\n\nexport function hasFileReadStreamCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileReadStreamCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);\n}\n\nexport interface IFileSystemProviderWithFileAtomicReadCapability extends IFileSystemProvider {\n\treadFile(resource: URI, opts?: IFileAtomicReadOptions): Promise<Uint8Array>;\n\tenforceAtomicReadFile?(resource: URI): boolean;\n}\n\nexport function hasFileAtomicReadCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileAtomicReadCapability {\n\tif (!hasReadWriteCapability(provider)) {\n\t\treturn false; // we require the `FileReadWrite` capability too\n\t}\n\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicRead);\n}\n\nexport interface IFileSystemProviderWithFileAtomicWriteCapability extends IFileSystemProvider {\n\twriteFile(resource: URI, contents: Uint8Array, opts?: IFileAtomicWriteOptions): Promise<void>;\n\tenforceAtomicWriteFile?(resource: URI): IFileAtomicOptions | false;\n}\n\nexport function hasFileAtomicWriteCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileAtomicWriteCapability {\n\tif (!hasReadWriteCapability(provider)) {\n\t\treturn false; // we require the `FileReadWrite` capability too\n\t}\n\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicWrite);\n}\n\nexport interface IFileSystemProviderWithFileAtomicDeleteCapability extends IFileSystemProvider {\n\tdelete(resource: URI, opts: IFileAtomicDeleteOptions): Promise<void>;\n\tenforceAtomicDelete?(resource: URI): IFileAtomicOptions | false;\n}\n\nexport function hasFileAtomicDeleteCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileAtomicDeleteCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicDelete);\n}\n\nexport interface IFileSystemProviderWithReadonlyCapability extends IFileSystemProvider {\n\n\treadonly capabilities: FileSystemProviderCapabilities.Readonly & FileSystemProviderCapabilities;\n\n\t/**\n\t * An optional message to show in the UI to explain why the file system is readonly.\n\t */\n\treadonly readOnlyMessage?: IMarkdownString;\n}\n\nexport function hasReadonlyCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithReadonlyCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.Readonly);\n}\n\nexport enum FileSystemProviderErrorCode {\n\tFileExists = 'EntryExists',\n\tFileNotFound = 'EntryNotFound',\n\tFileNotADirectory = 'EntryNotADirectory',\n\tFileIsADirectory = 'EntryIsADirectory',\n\tFileExceedsStorageQuota = 'EntryExceedsStorageQuota',\n\tFileTooLarge = 'EntryTooLarge',\n\tFileWriteLocked = 'EntryWriteLocked',\n\tNoPermissions = 'NoPermissions',\n\tUnavailable = 'Unavailable',\n\tUnknown = 'Unknown'\n}\n\nexport interface IFileSystemProviderError extends Error {\n\treadonly name: string;\n\treadonly code: FileSystemProviderErrorCode;\n}\n\nexport class FileSystemProviderError extends Error implements IFileSystemProviderError {\n\n\tstatic create(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n\t\tconst providerError = new FileSystemProviderError(error.toString(), code);\n\t\tmarkAsFileSystemProviderError(providerError, code);\n\n\t\treturn providerError;\n\t}\n\n\tprivate constructor(message: string, readonly code: FileSystemProviderErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function createFileSystemProviderError(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n\treturn FileSystemProviderError.create(error, code);\n}\n\nexport function ensureFileSystemProviderError(error?: Error): Error {\n\tif (!error) {\n\t\treturn createFileSystemProviderError(localize('unknownError', \"Unknown Error\"), FileSystemProviderErrorCode.Unknown); // https://github.com/microsoft/vscode/issues/72798\n\t}\n\n\treturn error;\n}\n\nexport function markAsFileSystemProviderError(error: Error, code: FileSystemProviderErrorCode): Error {\n\terror.name = code ? `${code} (FileSystemError)` : `FileSystemError`;\n\n\treturn error;\n}\n\nexport function toFileSystemProviderErrorCode(error: Error | undefined | null): FileSystemProviderErrorCode {\n\n\t// Guard against abuse\n\tif (!error) {\n\t\treturn FileSystemProviderErrorCode.Unknown;\n\t}\n\n\t// FileSystemProviderError comes with the code\n\tif (error instanceof FileSystemProviderError) {\n\t\treturn error.code;\n\t}\n\n\t// Any other error, check for name match by assuming that the error\n\t// went through the markAsFileSystemProviderError() method\n\tconst match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\n\tif (!match) {\n\t\treturn FileSystemProviderErrorCode.Unknown;\n\t}\n\n\tswitch (match[1]) {\n\t\tcase FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;\n\t\tcase FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;\n\t\tcase FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;\n\t\tcase FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;\n\t\tcase FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;\n\t\tcase FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;\n\t\tcase FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;\n\t\tcase FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;\n\t}\n\n\treturn FileSystemProviderErrorCode.Unknown;\n}\n\nexport function toFileOperationResult(error: Error): FileOperationResult {\n\n\t// FileSystemProviderError comes with the result already\n\tif (error instanceof FileOperationError) {\n\t\treturn error.fileOperationResult;\n\t}\n\n\t// Otherwise try to find from code\n\tswitch (toFileSystemProviderErrorCode(error)) {\n\t\tcase FileSystemProviderErrorCode.FileNotFound:\n\t\t\treturn FileOperationResult.FILE_NOT_FOUND;\n\t\tcase FileSystemProviderErrorCode.FileIsADirectory:\n\t\t\treturn FileOperationResult.FILE_IS_DIRECTORY;\n\t\tcase FileSystemProviderErrorCode.FileNotADirectory:\n\t\t\treturn FileOperationResult.FILE_NOT_DIRECTORY;\n\t\tcase FileSystemProviderErrorCode.FileWriteLocked:\n\t\t\treturn FileOperationResult.FILE_WRITE_LOCKED;\n\t\tcase FileSystemProviderErrorCode.NoPermissions:\n\t\t\treturn FileOperationResult.FILE_PERMISSION_DENIED;\n\t\tcase FileSystemProviderErrorCode.FileExists:\n\t\t\treturn FileOperationResult.FILE_MOVE_CONFLICT;\n\t\tcase FileSystemProviderErrorCode.FileTooLarge:\n\t\t\treturn FileOperationResult.FILE_TOO_LARGE;\n\t\tdefault:\n\t\t\treturn FileOperationResult.FILE_OTHER_ERROR;\n\t}\n}\n\nexport interface IFileSystemProviderRegistrationEvent {\n\treadonly added: boolean;\n\treadonly scheme: string;\n\treadonly provider?: IFileSystemProvider;\n}\n\nexport interface IFileSystemProviderCapabilitiesChangeEvent {\n\treadonly provider: IFileSystemProvider;\n\treadonly scheme: string;\n}\n\nexport interface IFileSystemProviderActivationEvent {\n\treadonly scheme: string;\n\tjoin(promise: Promise<void>): void;\n}\n\nexport const enum FileOperation {\n\tCREATE,\n\tDELETE,\n\tMOVE,\n\tCOPY,\n\tWRITE\n}\n\nexport interface IFileOperationEvent {\n\n\treadonly resource: URI;\n\treadonly operation: FileOperation;\n\n\tisOperation(operation: FileOperation.DELETE | FileOperation.WRITE): boolean;\n\tisOperation(operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY): this is IFileOperationEventWithMetadata;\n}\n\nexport interface IFileOperationEventWithMetadata extends IFileOperationEvent {\n\treadonly target: IFileStatWithMetadata;\n}\n\nexport class FileOperationEvent implements IFileOperationEvent {\n\n\tconstructor(resource: URI, operation: FileOperation.DELETE | FileOperation.WRITE);\n\tconstructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: IFileStatWithMetadata);\n\tconstructor(readonly resource: URI, readonly operation: FileOperation, readonly target?: IFileStatWithMetadata) { }\n\n\tisOperation(operation: FileOperation.DELETE | FileOperation.WRITE): boolean;\n\tisOperation(operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY): this is IFileOperationEventWithMetadata;\n\tisOperation(operation: FileOperation): boolean {\n\t\treturn this.operation === operation;\n\t}\n}\n\n/**\n * Possible changes that can occur to a file.\n */\nexport const enum FileChangeType {\n\tUPDATED,\n\tADDED,\n\tDELETED\n}\n\n/**\n * Identifies a single change in a file.\n */\nexport interface IFileChange {\n\n\t/**\n\t * The type of change that occurred to the file.\n\t */\n\ttype: FileChangeType;\n\n\t/**\n\t * The unified resource identifier of the file that changed.\n\t */\n\treadonly resource: URI;\n\n\t/**\n\t * If provided when starting the file watcher, the correlation\n\t * identifier will match the original file watching request as\n\t * a way to identify the original component that is interested\n\t * in the change.\n\t */\n\treadonly cId?: number;\n}\n\nexport class FileChangesEvent {\n\n\tprivate static readonly MIXED_CORRELATION = null;\n\n\tprivate readonly correlationId: number | undefined | typeof FileChangesEvent.MIXED_CORRELATION = undefined;\n\n\tconstructor(changes: readonly IFileChange[], private readonly ignorePathCasing: boolean) {\n\t\tfor (const change of changes) {\n\n\t\t\t// Split by type\n\t\t\tswitch (change.type) {\n\t\t\t\tcase FileChangeType.ADDED:\n\t\t\t\t\tthis.rawAdded.push(change.resource);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\t\tthis.rawUpdated.push(change.resource);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.DELETED:\n\t\t\t\t\tthis.rawDeleted.push(change.resource);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Figure out events correlation\n\t\t\tif (this.correlationId !== FileChangesEvent.MIXED_CORRELATION) {\n\t\t\t\tif (typeof change.cId === 'number') {\n\t\t\t\t\tif (this.correlationId === undefined) {\n\t\t\t\t\t\tthis.correlationId = change.cId; \t\t\t\t\t\t\t// correlation not yet set, just take it\n\t\t\t\t\t} else if (this.correlationId !== change.cId) {\n\t\t\t\t\t\tthis.correlationId = FileChangesEvent.MIXED_CORRELATION;\t// correlation mismatch, we have mixed correlation\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.correlationId !== undefined) {\n\t\t\t\t\t\tthis.correlationId = FileChangesEvent.MIXED_CORRELATION;\t// correlation mismatch, we have mixed correlation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly added = new Lazy(() => {\n\t\tconst added = TernarySearchTree.forUris<boolean>(() => this.ignorePathCasing);\n\t\tadded.fill(this.rawAdded.map(resource => [resource, true]));\n\n\t\treturn added;\n\t});\n\n\tprivate readonly updated = new Lazy(() => {\n\t\tconst updated = TernarySearchTree.forUris<boolean>(() => this.ignorePathCasing);\n\t\tupdated.fill(this.rawUpdated.map(resource => [resource, true]));\n\n\t\treturn updated;\n\t});\n\n\tprivate readonly deleted = new Lazy(() => {\n\t\tconst deleted = TernarySearchTree.forUris<boolean>(() => this.ignorePathCasing);\n\t\tdeleted.fill(this.rawDeleted.map(resource => [resource, true]));\n\n\t\treturn deleted;\n\t});\n\n\t/**\n\t * Find out if the file change events match the provided resource.\n\t *\n\t * Note: when passing `FileChangeType.DELETED`, we consider a match\n\t * also when the parent of the resource got deleted.\n\t */\n\tcontains(resource: URI, ...types: FileChangeType[]): boolean {\n\t\treturn this.doContains(resource, { includeChildren: false }, ...types);\n\t}\n\n\t/**\n\t * Find out if the file change events either match the provided\n\t * resource, or contain a child of this resource.\n\t */\n\taffects(resource: URI, ...types: FileChangeType[]): boolean {\n\t\treturn this.doContains(resource, { includeChildren: true }, ...types);\n\t}\n\n\tprivate doContains(resource: URI, options: { includeChildren: boolean }, ...types: FileChangeType[]): boolean {\n\t\tif (!resource) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasTypesFilter = types.length > 0;\n\n\t\t// Added\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.ADDED)) {\n\t\t\tif (this.added.value.get(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.added.value.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Updated\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.UPDATED)) {\n\t\t\tif (this.updated.value.get(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.updated.value.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Deleted\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.DELETED)) {\n\t\t\tif (this.deleted.value.findSubstr(resource) /* deleted also considers parent folders */) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.deleted.value.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns if this event contains added files.\n\t */\n\tgotAdded(): boolean {\n\t\treturn this.rawAdded.length > 0;\n\t}\n\n\t/**\n\t * Returns if this event contains deleted files.\n\t */\n\tgotDeleted(): boolean {\n\t\treturn this.rawDeleted.length > 0;\n\t}\n\n\t/**\n\t * Returns if this event contains updated files.\n\t */\n\tgotUpdated(): boolean {\n\t\treturn this.rawUpdated.length > 0;\n\t}\n\n\t/**\n\t * Returns if this event contains changes that correlate to the\n\t * provided `correlationId`.\n\t *\n\t * File change event correlation is an advanced watch feature that\n\t * allows to  identify from which watch request the events originate\n\t * from. This correlation allows to route events specifically\n\t * only to the requestor and not emit them to all listeners.\n\t */\n\tcorrelates(correlationId: number): boolean {\n\t\treturn this.correlationId === correlationId;\n\t}\n\n\t/**\n\t * Figure out if the event contains changes that correlate to one\n\t * correlation identifier.\n\t *\n\t * File change event correlation is an advanced watch feature that\n\t * allows to  identify from which watch request the events originate\n\t * from. This correlation allows to route events specifically\n\t * only to the requestor and not emit them to all listeners.\n\t */\n\thasCorrelation(): boolean {\n\t\treturn typeof this.correlationId === 'number';\n\t}\n\n\t/**\n\t * @deprecated use the `contains` or `affects` method to efficiently find\n\t * out if the event relates to a given resource. these methods ensure:\n\t * - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\treadonly rawAdded: URI[] = [];\n\n\t/**\n\t* @deprecated use the `contains` or `affects` method to efficiently find\n\t* out if the event relates to a given resource. these methods ensure:\n\t* - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t* - correctly handles `FileChangeType.DELETED` events\n\t*/\n\treadonly rawUpdated: URI[] = [];\n\n\t/**\n\t* @deprecated use the `contains` or `affects` method to efficiently find\n\t* out if the event relates to a given resource. these methods ensure:\n\t* - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t* - correctly handles `FileChangeType.DELETED` events\n\t*/\n\treadonly rawDeleted: URI[] = [];\n}\n\nexport function isParent(path: string, candidate: string, ignoreCase?: boolean): boolean {\n\tif (!path || !candidate || path === candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== sep) {\n\t\tcandidate += sep;\n\t}\n\n\tif (ignoreCase) {\n\t\treturn startsWithIgnoreCase(path, candidate);\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport interface IBaseFileStat {\n\n\t/**\n\t * The unified resource identifier of this file or folder.\n\t */\n\treadonly resource: URI;\n\n\t/**\n\t * The name which is the last segment\n\t * of the {{path}}.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * The size of the file.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly size?: number;\n\n\t/**\n\t * The last modification date represented as millis from unix epoch.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly mtime?: number;\n\n\t/**\n\t * The creation date represented as millis from unix epoch.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly ctime?: number;\n\n\t/**\n\t * A unique identifier that represents the\n\t * current state of the file or directory.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly etag?: string;\n\n\t/**\n\t * File is readonly. Components like editors should not\n\t * offer to edit the contents.\n\t */\n\treadonly readonly?: boolean;\n\n\t/**\n\t * File is locked. Components like editors should offer\n\t * to edit the contents and ask the user upon saving to\n\t * remove the lock.\n\t */\n\treadonly locked?: boolean;\n}\n\nexport interface IBaseFileStatWithMetadata extends Required<IBaseFileStat> { }\n\n/**\n * A file resource with meta information and resolved children if any.\n */\nexport interface IFileStat extends IBaseFileStat {\n\n\t/**\n\t * The resource is a file.\n\t */\n\treadonly isFile: boolean;\n\n\t/**\n\t * The resource is a directory.\n\t */\n\treadonly isDirectory: boolean;\n\n\t/**\n\t * The resource is a symbolic link. Note: even when the\n\t * file is a symbolic link, you can test for `FileType.File`\n\t * and `FileType.Directory` to know the type of the target\n\t * the link points to.\n\t */\n\treadonly isSymbolicLink: boolean;\n\n\t/**\n\t * The children of the file stat or undefined if none.\n\t */\n\tchildren: IFileStat[] | undefined;\n}\n\nexport interface IFileStatWithMetadata extends IFileStat, IBaseFileStatWithMetadata {\n\treadonly mtime: number;\n\treadonly ctime: number;\n\treadonly etag: string;\n\treadonly size: number;\n\treadonly readonly: boolean;\n\treadonly locked: boolean;\n\treadonly children: IFileStatWithMetadata[] | undefined;\n}\n\nexport interface IFileStatResult {\n\treadonly stat?: IFileStat;\n\treadonly success: boolean;\n}\n\nexport interface IFileStatResultWithMetadata extends IFileStatResult {\n\treadonly stat?: IFileStatWithMetadata;\n}\n\nexport interface IFileStatWithPartialMetadata extends Omit<IFileStatWithMetadata, 'children'> { }\n\nexport interface IFileContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The content of a file as buffer.\n\t */\n\treadonly value: VSBuffer;\n}\n\nexport interface IFileStreamContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The content of a file as stream.\n\t */\n\treadonly value: VSBufferReadableStream;\n}\n\nexport interface IBaseReadFileOptions extends IFileReadStreamOptions {\n\n\t/**\n\t * The optional etag parameter allows to return early from resolving the resource if\n\t * the contents on disk match the etag. This prevents accumulated reading of resources\n\t * that have been read already with the same etag.\n\t * It is the task of the caller to makes sure to handle this error case from the promise.\n\t */\n\treadonly etag?: string;\n}\n\nexport interface IReadFileStreamOptions extends IBaseReadFileOptions { }\n\nexport interface IReadFileOptions extends IBaseReadFileOptions {\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `readFile` method is not running in parallel with\n\t * any `write` operations in the same process.\n\t *\n\t * Typically you should not need to use this flag but if\n\t * for example you are quickly reading a file right after\n\t * a file event occurred and the file changes a lot, there\n\t * is a chance that a read returns an empty or partial file\n\t * because a pending write has not finished yet.\n\t *\n\t * Note: this does not prevent the file from being written\n\t * to from a different process. If you need such atomic\n\t * operations, you better use a real database as storage.\n\t */\n\treadonly atomic?: boolean;\n}\n\nexport interface IWriteFileOptions {\n\n\t/**\n\t * The last known modification time of the file. This can be used to prevent dirty writes.\n\t */\n\treadonly mtime?: number;\n\n\t/**\n\t * The etag of the file. This can be used to prevent dirty writes.\n\t */\n\treadonly etag?: string;\n\n\t/**\n\t * Whether to attempt to unlock a file before writing.\n\t */\n\treadonly unlock?: boolean;\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `writeFile` method updates the target file atomically\n\t * by first writing to a temporary file in the same folder\n\t * and then renaming it over the target.\n\t */\n\treadonly atomic?: IFileAtomicOptions | false;\n}\n\nexport interface IResolveFileOptions {\n\n\t/**\n\t * Automatically continue resolving children of a directory until the provided resources\n\t * are found.\n\t */\n\treadonly resolveTo?: readonly URI[];\n\n\t/**\n\t * Automatically continue resolving children of a directory if the number of children is 1.\n\t */\n\treadonly resolveSingleChildDescendants?: boolean;\n\n\t/**\n\t * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact\n\t * on performance and thus should only be used when these values are required.\n\t */\n\treadonly resolveMetadata?: boolean;\n}\n\nexport interface IResolveMetadataFileOptions extends IResolveFileOptions {\n\treadonly resolveMetadata: true;\n}\n\nexport interface ICreateFileOptions {\n\n\t/**\n\t * Overwrite the file to create if it already exists on disk. Otherwise\n\t * an error will be thrown (FILE_MODIFIED_SINCE).\n\t */\n\treadonly overwrite?: boolean;\n}\n\nexport class FileOperationError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly fileOperationResult: FileOperationResult,\n\t\treadonly options?: IReadFileOptions | IWriteFileOptions | ICreateFileOptions\n\t) {\n\t\tsuper(message);\n\t}\n}\n\nexport class TooLargeFileOperationError extends FileOperationError {\n\tconstructor(\n\t\tmessage: string,\n\t\toverride readonly fileOperationResult: FileOperationResult.FILE_TOO_LARGE,\n\t\treadonly size: number,\n\t\toptions?: IReadFileOptions\n\t) {\n\t\tsuper(message, fileOperationResult, options);\n\t}\n}\n\nexport class NotModifiedSinceFileOperationError extends FileOperationError {\n\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly stat: IFileStatWithMetadata,\n\t\toptions?: IReadFileOptions\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n\t}\n}\n\nexport const enum FileOperationResult {\n\tFILE_IS_DIRECTORY,\n\tFILE_NOT_FOUND,\n\tFILE_NOT_MODIFIED_SINCE,\n\tFILE_MODIFIED_SINCE,\n\tFILE_MOVE_CONFLICT,\n\tFILE_WRITE_LOCKED,\n\tFILE_PERMISSION_DENIED,\n\tFILE_TOO_LARGE,\n\tFILE_INVALID_PATH,\n\tFILE_NOT_DIRECTORY,\n\tFILE_OTHER_ERROR\n}\n\n//#endregion\n\n//#region Settings\n\nexport const AutoSaveConfiguration = {\n\tOFF: 'off',\n\tAFTER_DELAY: 'afterDelay',\n\tON_FOCUS_CHANGE: 'onFocusChange',\n\tON_WINDOW_CHANGE: 'onWindowChange'\n};\n\nexport const HotExitConfiguration = {\n\tOFF: 'off',\n\tON_EXIT: 'onExit',\n\tON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'\n};\n\nexport const FILES_ASSOCIATIONS_CONFIG = 'files.associations';\nexport const FILES_EXCLUDE_CONFIG = 'files.exclude';\nexport const FILES_READONLY_INCLUDE_CONFIG = 'files.readonlyInclude';\nexport const FILES_READONLY_EXCLUDE_CONFIG = 'files.readonlyExclude';\nexport const FILES_READONLY_FROM_PERMISSIONS_CONFIG = 'files.readonlyFromPermissions';\n\nexport interface IGlobPatterns {\n\t[filepattern: string]: boolean;\n}\n\nexport interface IFilesConfiguration {\n\tfiles?: IFilesConfigurationNode;\n}\n\nexport interface IFilesConfigurationNode {\n\tassociations: { [filepattern: string]: string };\n\texclude: IExpression;\n\twatcherExclude: IGlobPatterns;\n\twatcherInclude: string[];\n\tencoding: string;\n\tautoGuessEncoding: boolean;\n\tcandidateGuessEncodings: string[];\n\tdefaultLanguage: string;\n\ttrimTrailingWhitespace: boolean;\n\tautoSave: string;\n\tautoSaveDelay: number;\n\tautoSaveWorkspaceFilesOnly: boolean;\n\tautoSaveWhenNoErrors: boolean;\n\teol: string;\n\tenableTrash: boolean;\n\thotExit: string;\n\tsaveConflictResolution: 'askUser' | 'overwriteFileOnDisk';\n\treadonlyInclude: IGlobPatterns;\n\treadonlyExclude: IGlobPatterns;\n\treadonlyFromPermissions: boolean;\n}\n\n//#endregion\n\n//#region Utilities\n\nexport enum FileKind {\n\tFILE,\n\tFOLDER,\n\tROOT_FOLDER\n}\n\n/**\n * A hint to disable etag checking for reading/writing.\n */\nexport const ETAG_DISABLED = '';\n\nexport function etag(stat: { mtime: number; size: number }): string;\nexport function etag(stat: { mtime: number | undefined; size: number | undefined }): string | undefined;\nexport function etag(stat: { mtime: number | undefined; size: number | undefined }): string | undefined {\n\tif (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\n\t\treturn undefined;\n\t}\n\n\treturn stat.mtime.toString(29) + stat.size.toString(31);\n}\n\nexport async function whenProviderRegistered(file: URI, fileService: IFileService): Promise<void> {\n\tif (fileService.hasProvider(URI.from({ scheme: file.scheme }))) {\n\t\treturn;\n\t}\n\n\treturn new Promise(resolve => {\n\t\tconst disposable = fileService.onDidChangeFileSystemProviderRegistrations(e => {\n\t\t\tif (e.scheme === file.scheme && e.added) {\n\t\t\t\tdisposable.dispose();\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Helper to format a raw byte size into a human readable label.\n */\nexport class ByteSize {\n\n\tstatic readonly KB = 1024;\n\tstatic readonly MB = ByteSize.KB * ByteSize.KB;\n\tstatic readonly GB = ByteSize.MB * ByteSize.KB;\n\tstatic readonly TB = ByteSize.GB * ByteSize.KB;\n\n\tstatic formatSize(size: number): string {\n\t\tif (!isNumber(size)) {\n\t\t\tsize = 0;\n\t\t}\n\n\t\tif (size < ByteSize.KB) {\n\t\t\treturn localize('sizeB', \"{0}B\", size.toFixed(0));\n\t\t}\n\n\t\tif (size < ByteSize.MB) {\n\t\t\treturn localize('sizeKB', \"{0}KB\", (size / ByteSize.KB).toFixed(2));\n\t\t}\n\n\t\tif (size < ByteSize.GB) {\n\t\t\treturn localize('sizeMB', \"{0}MB\", (size / ByteSize.MB).toFixed(2));\n\t\t}\n\n\t\tif (size < ByteSize.TB) {\n\t\t\treturn localize('sizeGB', \"{0}GB\", (size / ByteSize.GB).toFixed(2));\n\t\t}\n\n\t\treturn localize('sizeTB', \"{0}TB\", (size / ByteSize.TB).toFixed(2));\n\t}\n}\n\n// File limits\n\nexport function getLargeFileConfirmationLimit(remoteAuthority?: string): number;\nexport function getLargeFileConfirmationLimit(uri?: URI): number;\nexport function getLargeFileConfirmationLimit(arg?: string | URI): number {\n\tconst isRemote = typeof arg === 'string' || arg?.scheme === Schemas.vscodeRemote;\n\tconst isLocal = typeof arg !== 'string' && arg?.scheme === Schemas.file;\n\n\tif (isLocal) {\n\t\t// Local almost has no limit in file size\n\t\treturn 1024 * ByteSize.MB;\n\t}\n\n\tif (isRemote) {\n\t\t// With a remote, pick a low limit to avoid\n\t\t// potentially costly file transfers\n\t\treturn 10 * ByteSize.MB;\n\t}\n\n\tif (isWeb) {\n\t\t// Web: we cannot know for sure if a cost\n\t\t// is associated with the file transfer\n\t\t// so we pick a reasonably small limit\n\t\treturn 50 * ByteSize.MB;\n\t}\n\n\t// Local desktop: almost no limit in file size\n\treturn 1024 * ByteSize.MB;\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { GLOBSTAR, IRelativePattern, parse, ParsedPattern } from '../../../base/common/glob.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isAbsolute } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { FileChangeFilter, FileChangeType, IFileChange, isParent } from './files.js';\n\ninterface IWatchRequest {\n\n\t/**\n\t * The path to watch.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\treadonly excludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\treadonly includes?: Array<string | IRelativePattern>;\n\n\t/**\n\t * If provided, file change events from the watcher that\n\t * are a result of this watch request will carry the same\n\t * id.\n\t */\n\treadonly correlationId?: number;\n\n\t/**\n\t * If provided, allows to filter the events that the watcher should consider\n\t * for emitting. If not provided, all events are emitted.\n\t *\n\t * For example, to emit added and updated events, set to:\n\t * `FileChangeFilter.ADDED | FileChangeFilter.UPDATED`.\n\t */\n\treadonly filter?: FileChangeFilter;\n}\n\nexport interface IWatchRequestWithCorrelation extends IWatchRequest {\n\treadonly correlationId: number;\n}\n\nexport function isWatchRequestWithCorrelation(request: IWatchRequest): request is IWatchRequestWithCorrelation {\n\treturn typeof request.correlationId === 'number';\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\treadonly recursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be recursive.\n\t */\n\treadonly recursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport function isRecursiveWatchRequest(request: IWatchRequest): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest = IRecursiveWatchRequest | INonRecursiveWatchRequest;\n\nexport interface IWatcherErrorEvent {\n\treadonly error: string;\n\treadonly request?: IUniversalWatchRequest;\n}\n\nexport interface IWatcher {\n\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<IWatcherErrorEvent>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherWithSubscribe extends IRecursiveWatcher {\n\n\t/**\n\t * Subscribe to file events for the given path. The callback is called\n\t * whenever a file event occurs for the path. If the watcher failed,\n\t * the error parameter is set to `true`.\n\t *\n\t * @returns an `IDisposable` to stop listening to events or `undefined`\n\t * if no events can be watched for the path given the current set of\n\t * recursive watch requests.\n\t */\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined;\n}\n\nexport interface IRecursiveWatcherOptions {\n\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly usePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly pollingInterval?: number;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(new MutableDisposable());\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\treadonly type: string;\n\t\t\treadonly restartOnError: boolean;\n\t\t}\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n\t\tdisposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n\t\tdisposables.add(this.watcher.onDidError(e => this.onError(e.error, e.request)));\n\t}\n\n\tprotected onError(error: string, failedRequest?: IUniversalWatchRequest): void {\n\n\t\t// Restart on error (up to N times, if possible)\n\t\tif (this.canRestart(error, failedRequest)) {\n\t\t\tif (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n\t\t\t\tthis.error(`restarting watcher after unexpected error: ${error}`);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(`gave up attempting to restart watcher after unexpected error: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart otherwise, report the error\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate canRestart(error: string, failedRequest?: IUniversalWatchRequest): boolean {\n\t\tif (!this.options.restartOnError) {\n\t\t\treturn false; // disabled by options\n\t\t}\n\n\t\tif (failedRequest) {\n\t\t\t// do not treat a failing request as a reason to restart the entire\n\t\t\t// watcher. it is possible that from a large amount of watch requests\n\t\t\t// some fail and we would constantly restart all requests only because\n\t\t\t// of that. rather, continue the watcher and leave the failed request\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\terror.indexOf('No space left on device') !== -1 ||\n\t\t\terror.indexOf('EMFILE') !== -1\n\t\t) {\n\t\t\t// do not restart when the error indicates that the system is running\n\t\t\t// out of handles for file watching. this is not recoverable anyway\n\t\t\t// and needs changes to the system before continuing\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\tprotected trace(message: string) {\n\t\tthis.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\toverride dispose(): void {\n\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'node.js', restartOnError: false });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'universal', restartOnError: true });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): IUniversalWatcher;\n}\n\nexport interface ILogMessage {\n\treadonly type: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\treadonly message: string;\n}\n\nexport function reviveFileChanges(changes: IFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: URI.revive(change.resource),\n\t\tcId: change.cId\n\t}));\n}\n\nexport function coalesceEvents(changes: IFileChange[]): IFileChange[] {\n\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(path: string, pattern: string | IRelativePattern): string | IRelativePattern {\n\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(path: string, patterns: Array<string | IRelativePattern>): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\n\tprivate readonly coalesced = new Set<IFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IFileChange>();\n\n\tprivate toKey(event: IFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.resource.fsPath;\n\t\t}\n\n\t\treturn event.resource.fsPath.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (existingEvent.resource.fsPath !== event.resource.fsPath && (event.type === FileChangeType.DELETED || event.type === FileChangeType.ADDED)) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IFileChange[] {\n\t\tconst addOrChangeEvents: IFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced).filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.resource.fsPath.length - e2.resource.fsPath.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(deletedPath => isParent(e.resource.fsPath, deletedPath, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.resource.fsPath);\n\n\t\t\treturn true;\n\t\t}).concat(addOrChangeEvents);\n\t}\n}\n\nexport function isFiltered(event: IFileChange, filter: FileChangeFilter | undefined): boolean {\n\tif (typeof filter === 'number') {\n\t\tswitch (event.type) {\n\t\t\tcase FileChangeType.ADDED:\n\t\t\t\treturn (filter & FileChangeFilter.ADDED) === 0;\n\t\t\tcase FileChangeType.DELETED:\n\t\t\t\treturn (filter & FileChangeFilter.DELETED) === 0;\n\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\treturn (filter & FileChangeFilter.UPDATED) === 0;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function requestFilterToString(filter: FileChangeFilter | undefined): string {\n\tif (typeof filter === 'number') {\n\t\tconst filters = [];\n\t\tif (filter & FileChangeFilter.ADDED) {\n\t\t\tfilters.push('Added');\n\t\t}\n\t\tif (filter & FileChangeFilter.DELETED) {\n\t\t\tfilters.push('Deleted');\n\t\t}\n\t\tif (filter & FileChangeFilter.UPDATED) {\n\t\t\tfilters.push('Updated');\n\t\t}\n\n\t\tif (filters.length === 0) {\n\t\t\treturn '<all>';\n\t\t}\n\n\t\treturn `[${filters.join(', ')}]`;\n\t}\n\n\treturn '<none>';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { GLOBSTAR, IRelativePattern, parse, ParsedPattern } from '../../../base/common/glob.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isAbsolute } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { FileChangeFilter, FileChangeType, IFileChange, isParent } from './files.js';\n\ninterface IWatchRequest {\n\n\t/**\n\t * The path to watch.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\treadonly excludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\treadonly includes?: Array<string | IRelativePattern>;\n\n\t/**\n\t * If provided, file change events from the watcher that\n\t * are a result of this watch request will carry the same\n\t * id.\n\t */\n\treadonly correlationId?: number;\n\n\t/**\n\t * If provided, allows to filter the events that the watcher should consider\n\t * for emitting. If not provided, all events are emitted.\n\t *\n\t * For example, to emit added and updated events, set to:\n\t * `FileChangeFilter.ADDED | FileChangeFilter.UPDATED`.\n\t */\n\treadonly filter?: FileChangeFilter;\n}\n\nexport interface IWatchRequestWithCorrelation extends IWatchRequest {\n\treadonly correlationId: number;\n}\n\nexport function isWatchRequestWithCorrelation(request: IWatchRequest): request is IWatchRequestWithCorrelation {\n\treturn typeof request.correlationId === 'number';\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\treadonly recursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be recursive.\n\t */\n\treadonly recursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport function isRecursiveWatchRequest(request: IWatchRequest): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest = IRecursiveWatchRequest | INonRecursiveWatchRequest;\n\nexport interface IWatcherErrorEvent {\n\treadonly error: string;\n\treadonly request?: IUniversalWatchRequest;\n}\n\nexport interface IWatcher {\n\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<IWatcherErrorEvent>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherWithSubscribe extends IRecursiveWatcher {\n\n\t/**\n\t * Subscribe to file events for the given path. The callback is called\n\t * whenever a file event occurs for the path. If the watcher failed,\n\t * the error parameter is set to `true`.\n\t *\n\t * @returns an `IDisposable` to stop listening to events or `undefined`\n\t * if no events can be watched for the path given the current set of\n\t * recursive watch requests.\n\t */\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined;\n}\n\nexport interface IRecursiveWatcherOptions {\n\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly usePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\treadonly pollingInterval?: number;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(new MutableDisposable());\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\treadonly type: string;\n\t\t\treadonly restartOnError: boolean;\n\t\t}\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n\t\tdisposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n\t\tdisposables.add(this.watcher.onDidError(e => this.onError(e.error, e.request)));\n\t}\n\n\tprotected onError(error: string, failedRequest?: IUniversalWatchRequest): void {\n\n\t\t// Restart on error (up to N times, if possible)\n\t\tif (this.canRestart(error, failedRequest)) {\n\t\t\tif (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n\t\t\t\tthis.error(`restarting watcher after unexpected error: ${error}`);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(`gave up attempting to restart watcher after unexpected error: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart otherwise, report the error\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate canRestart(error: string, failedRequest?: IUniversalWatchRequest): boolean {\n\t\tif (!this.options.restartOnError) {\n\t\t\treturn false; // disabled by options\n\t\t}\n\n\t\tif (failedRequest) {\n\t\t\t// do not treat a failing request as a reason to restart the entire\n\t\t\t// watcher. it is possible that from a large amount of watch requests\n\t\t\t// some fail and we would constantly restart all requests only because\n\t\t\t// of that. rather, continue the watcher and leave the failed request\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\terror.indexOf('No space left on device') !== -1 ||\n\t\t\terror.indexOf('EMFILE') !== -1\n\t\t) {\n\t\t\t// do not restart when the error indicates that the system is running\n\t\t\t// out of handles for file watching. this is not recoverable anyway\n\t\t\t// and needs changes to the system before continuing\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\tprotected trace(message: string) {\n\t\tthis.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\toverride dispose(): void {\n\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'node.js', restartOnError: false });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'universal', restartOnError: true });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): IUniversalWatcher;\n}\n\nexport interface ILogMessage {\n\treadonly type: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\treadonly message: string;\n}\n\nexport function reviveFileChanges(changes: IFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: URI.revive(change.resource),\n\t\tcId: change.cId\n\t}));\n}\n\nexport function coalesceEvents(changes: IFileChange[]): IFileChange[] {\n\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(path: string, pattern: string | IRelativePattern): string | IRelativePattern {\n\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(path: string, patterns: Array<string | IRelativePattern>): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\n\tprivate readonly coalesced = new Set<IFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IFileChange>();\n\n\tprivate toKey(event: IFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.resource.fsPath;\n\t\t}\n\n\t\treturn event.resource.fsPath.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (existingEvent.resource.fsPath !== event.resource.fsPath && (event.type === FileChangeType.DELETED || event.type === FileChangeType.ADDED)) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IFileChange[] {\n\t\tconst addOrChangeEvents: IFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced).filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.resource.fsPath.length - e2.resource.fsPath.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(deletedPath => isParent(e.resource.fsPath, deletedPath, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.resource.fsPath);\n\n\t\t\treturn true;\n\t\t}).concat(addOrChangeEvents);\n\t}\n}\n\nexport function isFiltered(event: IFileChange, filter: FileChangeFilter | undefined): boolean {\n\tif (typeof filter === 'number') {\n\t\tswitch (event.type) {\n\t\t\tcase FileChangeType.ADDED:\n\t\t\t\treturn (filter & FileChangeFilter.ADDED) === 0;\n\t\t\tcase FileChangeType.DELETED:\n\t\t\t\treturn (filter & FileChangeFilter.DELETED) === 0;\n\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\treturn (filter & FileChangeFilter.UPDATED) === 0;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function requestFilterToString(filter: FileChangeFilter | undefined): string {\n\tif (typeof filter === 'number') {\n\t\tconst filters = [];\n\t\tif (filter & FileChangeFilter.ADDED) {\n\t\t\tfilters.push('Added');\n\t\t}\n\t\tif (filter & FileChangeFilter.DELETED) {\n\t\t\tfilters.push('Deleted');\n\t\t}\n\t\tif (filter & FileChangeFilter.UPDATED) {\n\t\t\tfilters.push('Updated');\n\t\t}\n\n\t\tif (filters.length === 0) {\n\t\t\treturn '<all>';\n\t\t}\n\n\t\treturn `[${filters.join(', ')}]`;\n\t}\n\n\treturn '<none>';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watch, promises } from 'fs';\nimport { RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { isEqual, isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { Disposable, DisposableStore, IDisposable, thenRegisterOrDispose, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { basename, dirname, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh } from '../../../../../base/common/platform.js';\nimport { joinPath } from '../../../../../base/common/resources.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { Promises } from '../../../../../base/node/pfs.js';\nimport { FileChangeFilter, FileChangeType, IFileChange } from '../../../common/files.js';\nimport { ILogMessage, coalesceEvents, INonRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, isWatchRequestWithCorrelation } from '../../../common/watcher.js';\nimport { Lazy } from '../../../../../base/common/lazy.js';\nimport { ParsedPattern } from '../../../../../base/common/glob.js';\n\nexport class NodeJSFileWatcherLibrary extends Disposable {\n\n\t// A delay in reacting to file deletes to support\n\t// atomic save operations where a tool may chose\n\t// to delete a file before creating it again for\n\t// an update.\n\tprivate static readonly FILE_DELETE_HANDLER_DELAY = 100;\n\n\t// A delay for collecting file changes from node.js\n\t// before collecting them for coalescing and emitting\n\t// Same delay as used for the recursive watcher.\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// These numbers are a bit more aggressive compared to the\n\t// recursive watcher because we can have many individual\n\t// node.js watchers per request.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 100,\t// only process up to 100 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 10000 \t// ...but never buffering more than 10000 events in memory\n\t\t},\n\t\tevents => this.onDidFilesChange(events)\n\t));\n\n\t// Aggregate file changes over FILE_CHANGES_HANDLER_DELAY\n\t// to coalesce events and reduce spam.\n\tprivate readonly fileChangesAggregator = this._register(new RunOnceWorker<IFileChange>(events => this.handleFileChanges(events), NodeJSFileWatcherLibrary.FILE_CHANGES_HANDLER_DELAY));\n\n\tprivate readonly excludes: ParsedPattern[];\n\tprivate readonly includes: ParsedPattern[] | undefined;\n\tprivate readonly filter: FileChangeFilter | undefined;\n\n\tprivate readonly cts = new CancellationTokenSource();\n\n\tprivate readonly realPath = new Lazy(async () => {\n\n\t\t// This property is intentionally `Lazy` and not using `realcase()` as the counterpart\n\t\t// in the recursive watcher because of the amount of paths this watcher is dealing with.\n\t\t// We try as much as possible to avoid even needing `realpath()` if we can because even\n\t\t// that method does an `lstat()` per segment of the path.\n\n\t\tlet result = this.request.path;\n\n\t\ttry {\n\t\t\tresult = await Promises.realpath(this.request.path);\n\n\t\t\tif (this.request.path !== result) {\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link (original: ${this.request.path}, real: ${result})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn result;\n\t});\n\n\treadonly ready: Promise<void>;\n\n\tprivate _isReusingRecursiveWatcher = false;\n\tget isReusingRecursiveWatcher(): boolean { return this._isReusingRecursiveWatcher; }\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tconstructor(\n\t\tprivate readonly request: INonRecursiveWatchRequest,\n\t\tprivate readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined,\n\t\tprivate readonly onDidFilesChange: (changes: IFileChange[]) => void,\n\t\tprivate readonly onDidWatchFail?: () => void,\n\t\tprivate readonly onLogMessage?: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging?: boolean\n\t) {\n\t\tsuper();\n\n\t\tthis.excludes = parseWatcherPatterns(this.request.path, this.request.excludes);\n\t\tthis.includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\t\tthis.filter = isWatchRequestWithCorrelation(this.request) ? this.request.filter : undefined; // filtering is only enabled when correlating because watchers are otherwise potentially reused\n\n\t\tthis.ready = this.watch();\n\t}\n\n\tprivate async watch(): Promise<void> {\n\t\ttry {\n\t\t\tconst stat = await promises.stat(this.request.path);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._register(await this.doWatch(stat.isDirectory()));\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.error(error);\n\t\t\t} else {\n\t\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${error})`);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate notifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis.onDidWatchFail?.();\n\t}\n\n\tprivate async doWatch(isDirectory: boolean): Promise<IDisposable> {\n\t\tconst disposables = new DisposableStore();\n\n\t\tif (this.doWatchWithExistingWatcher(isDirectory, disposables)) {\n\t\t\tthis.trace(`reusing an existing recursive watcher for ${this.request.path}`);\n\t\t\tthis._isReusingRecursiveWatcher = true;\n\t\t} else {\n\t\t\tthis._isReusingRecursiveWatcher = false;\n\t\t\tawait this.doWatchWithNodeJS(isDirectory, disposables);\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate doWatchWithExistingWatcher(isDirectory: boolean, disposables: DisposableStore): boolean {\n\t\tif (isDirectory) {\n\t\t\t// Recursive watcher re-use is currently not enabled for when\n\t\t\t// folders are watched. this is because the dispatching in the\n\t\t\t// recursive watcher for non-recurive requests is optimized for\n\t\t\t// file changes  where we really only match on the exact path\n\t\t\t// and not child paths.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst resource = URI.file(this.request.path);\n\t\tconst subscription = this.recursiveWatcher?.subscribe(this.request.path, async (error, change) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tawait thenRegisterOrDispose(this.doWatch(isDirectory), disposables);\n\t\t\t} else if (change) {\n\t\t\t\tif (typeof change.cId === 'number' || typeof this.request.correlationId === 'number') {\n\t\t\t\t\t// Re-emit this change with the correlation id of the request\n\t\t\t\t\t// so that the client can correlate the event with the request\n\t\t\t\t\t// properly. Without correlation, we do not have to do that\n\t\t\t\t\t// because the event will appear on the global listener already.\n\t\t\t\t\tthis.onFileChange({ resource, type: change.type, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async doWatchWithNodeJS(isDirectory: boolean, disposables: DisposableStore): Promise<void> {\n\t\tconst realPath = await this.realPath.value;\n\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// macOS: watching samba shares can crash VSCode so we do\n\t\t// a simple check for the file path pointing to /Volumes\n\t\t// (https://github.com/microsoft/vscode/issues/106879)\n\t\t// TODO@electron this needs a revisit when the crash is\n\t\t// fixed or mitigated upstream.\n\t\tif (isMacintosh && isEqualOrParent(realPath, '/Volumes/', true)) {\n\t\t\tthis.error(`Refusing to watch ${realPath} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource(this.cts.token);\n\t\tdisposables.add(toDisposable(() => cts.dispose(true)));\n\n\t\tconst watcherDisposables = new DisposableStore(); // we need a separate disposable store because we re-create the watcher from within in some cases\n\t\tdisposables.add(watcherDisposables);\n\n\t\ttry {\n\t\t\tconst requestResource = URI.file(this.request.path);\n\t\t\tconst pathBasename = basename(realPath);\n\n\t\t\t// Creating watcher can fail with an exception\n\t\t\tconst watcher = watch(realPath);\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\twatcher.removeAllListeners();\n\t\t\t\twatcher.close();\n\t\t\t}));\n\n\t\t\tthis.trace(`Started watching: '${realPath}'`);\n\n\t\t\t// Folder: resolve children to emit proper events\n\t\t\tconst folderChildren = new Set<string>();\n\t\t\tif (isDirectory) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const child of await Promises.readdir(realPath)) {\n\t\t\t\t\t\tfolderChildren.add(child);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\tfor (const [, disposable] of mapPathToStatDisposable) {\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t}\n\t\t\t\tmapPathToStatDisposable.clear();\n\t\t\t}));\n\n\t\t\twatcher.on('error', (code: number, signal: string) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${code}, ${signal})`);\n\n\t\t\t\tthis.notifyWatchFailed();\n\t\t\t});\n\n\t\t\twatcher.on('change', (type, raw) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn; // ignore if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(`[raw] [\"${type}\"] ${raw}`);\n\t\t\t\t}\n\n\t\t\t\t// Normalize file name\n\t\t\t\tlet changedFileName = '';\n\t\t\t\tif (raw) { // https://github.com/microsoft/vscode/issues/38191\n\t\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!changedFileName || (type !== 'change' && type !== 'rename')) {\n\t\t\t\t\treturn; // ignore unexpected events\n\t\t\t\t}\n\n\t\t\t\t// Folder\n\t\t\t\tif (isDirectory) {\n\n\t\t\t\t\t// Folder child added/deleted\n\t\t\t\t\tif (type === 'rename') {\n\n\t\t\t\t\t\t// Cancel any previous stats for this file if existing\n\t\t\t\t\t\tmapPathToStatDisposable.get(changedFileName)?.dispose();\n\n\t\t\t\t\t\t// Wait a bit and try see if the file still exists on disk\n\t\t\t\t\t\t// to decide on the resulting event\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFileName);\n\n\t\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t\t// folder path is being deleted:\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// -   macOS: not reported but events continue to\n\t\t\t\t\t\t\t//            work even when the folder is brought\n\t\t\t\t\t\t\t//            back, though it seems every change\n\t\t\t\t\t\t\t//            to a file is reported as \"rename\"\n\t\t\t\t\t\t\t// -   Linux: \"rename\" event is reported with the\n\t\t\t\t\t\t\t//            name of the folder and events stop\n\t\t\t\t\t\t\t//            working\n\t\t\t\t\t\t\t// - Windows: an EPERM error is thrown that we\n\t\t\t\t\t\t\t//            handle from the `on('error')` event\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// We do not re-attach the watcher after timeout\n\t\t\t\t\t\t\t// though as we do for file watches because for\n\t\t\t\t\t\t\t// file watching specifically we want to handle\n\t\t\t\t\t\t\t// the atomic-write cases where the file is being\n\t\t\t\t\t\t\t// deleted and recreated with different contents.\n\t\t\t\t\t\t\tif (isEqual(changedFileName, pathBasename, !isLinux) && !await Promises.exists(realPath)) {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In order to properly detect renames on a case-insensitive\n\t\t\t\t\t\t\t// file system, we need to use `existsChildStrictCase` helper\n\t\t\t\t\t\t\t// because otherwise we would wrongly assume a file exists\n\t\t\t\t\t\t\t// when it was renamed to same name but different case.\n\t\t\t\t\t\t\tconst fileExists = await this.existsChildStrictCase(join(realPath, changedFileName));\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t\t// File Exists: either 'added' or 'updated' if known before\n\t\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\t\ttype = FileChangeType.DELETED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\tmapPathToStatDisposable.set(changedFileName, toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folder child changed\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// File\n\t\t\t\telse {\n\n\t\t\t\t\t// File added/deleted\n\t\t\t\t\tif (type === 'rename' || !isEqual(changedFileName, pathBasename, !isLinux)) {\n\n\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t// file path is being deleted:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// -   macOS: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// -   Linux: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// - Windows: \"rename\" event is reported and events\n\t\t\t\t\t\t//            continue to work when file is restored\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// As opposed to folder watching, we re-attach the\n\t\t\t\t\t\t// watcher after brief timeout to support \"atomic save\"\n\t\t\t\t\t\t// operations where a tool may decide to delete a file\n\t\t\t\t\t\t// and then create it with the updated contents.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Different to folder watching, we emit a delete event\n\t\t\t\t\t\t// though we never detect when the file is brought back\n\t\t\t\t\t\t// because the watcher is disposed then.\n\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tconst fileExists = await Promises.exists(realPath);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\n\t\t\t\t\t\t\t\twatcherDisposables.add(await this.doWatch(false));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File seems to be really gone, so emit a deleted and failed event\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\t\twatcherDisposables.clear();\n\t\t\t\t\t\twatcherDisposables.add(toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// File changed\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${error.toString()})`);\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate onWatchedPathDeleted(resource: URI): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted');\n\n\t\t// Emit events and flush in case the watcher gets disposed\n\t\tthis.onFileChange({ resource, type: FileChangeType.DELETED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\tthis.fileChangesAggregator.flush();\n\n\t\tthis.notifyWatchFailed();\n\t}\n\n\tprivate onFileChange(event: IFileChange, skipIncludeExcludeChecks = false): void {\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.traceWithCorrelation(`${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t}\n\n\t\t// Add to aggregator unless excluded or not included (not if explicitly disabled)\n\t\tif (!skipIncludeExcludeChecks && this.excludes.some(exclude => exclude(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (excluded) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else if (!skipIncludeExcludeChecks && this.includes && this.includes.length > 0 && !this.includes.some(include => include(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.fileChangesAggregator.work(event);\n\t\t}\n\t}\n\n\tprivate handleFileChanges(fileChanges: IFileChange[]): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedFileChanges = coalesceEvents(fileChanges);\n\n\t\t// Filter events: based on request filter property\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tfor (const event of coalescedFileChanges) {\n\t\t\tif (isFiltered(event, this.filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\tif (filteredEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tfor (const event of filteredEvents) {\n\t\t\t\tthis.traceWithCorrelation(` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t\t}\n\t\t}\n\n\t\t// Broadcast to clients via throttled emitter\n\t\tconst worked = this.throttledFileChangesEmitter.work(filteredEvents);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${filteredEvents.length}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async existsChildStrictCase(path: string): Promise<boolean> {\n\t\tif (isLinux) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\t\t\tconst children = await Promises.readdir(dirname(path));\n\n\t\t\treturn children.some(child => child === pathBasename);\n\t\t} catch (error) {\n\t\t\tthis.trace(error);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate error(error: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'error', message: `[File Watcher (node.js)] ${error}` });\n\t\t}\n\t}\n\n\tprivate warn(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'warn', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.onLogMessage?.({ type: 'trace', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate traceWithCorrelation(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.trace(`${message}${typeof this.request.correlationId === 'number' ? ` <${this.request.correlationId}> ` : ``}`);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.cts.dispose(true);\n\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Watch the provided `path` for changes and return\n * the data in chunks of `Uint8Array` for further use.\n */\nexport async function watchFileContents(path: string, onData: (chunk: Uint8Array) => void, onReady: () => void, token: CancellationToken, bufferSize = 512): Promise<void> {\n\tconst handle = await Promises.open(path, 'r');\n\tconst buffer = Buffer.allocUnsafe(bufferSize);\n\n\tconst cts = new CancellationTokenSource(token);\n\n\tlet error: Error | undefined = undefined;\n\tlet isReading = false;\n\n\tconst request: INonRecursiveWatchRequest = { path, excludes: [], recursive: false };\n\tconst watcher = new NodeJSFileWatcherLibrary(request, undefined, changes => {\n\t\t(async () => {\n\t\t\tfor (const { type } of changes) {\n\t\t\t\tif (type === FileChangeType.UPDATED) {\n\n\t\t\t\t\tif (isReading) {\n\t\t\t\t\t\treturn; // return early if we are already reading the output\n\t\t\t\t\t}\n\n\t\t\t\t\tisReading = true;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Consume the new contents of the file until finished\n\t\t\t\t\t\t// everytime there is a change event signalling a change\n\t\t\t\t\t\twhile (!cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\tconst { bytesRead } = await Promises.read(handle, buffer, 0, bufferSize, null);\n\t\t\t\t\t\t\tif (!bytesRead || cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tonData(buffer.slice(0, bytesRead));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\terror = new Error(err);\n\t\t\t\t\t\tcts.dispose(true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tisReading = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n\n\tawait watcher.ready;\n\tonReady();\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tcts.token.onCancellationRequested(async () => {\n\t\t\twatcher.dispose();\n\n\t\t\ttry {\n\t\t\t\tawait Promises.close(handle);\n\t\t\t} catch (err) {\n\t\t\t\terror = new Error(err);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watch, promises } from 'fs';\nimport { RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { isEqual, isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { Disposable, DisposableStore, IDisposable, thenRegisterOrDispose, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { basename, dirname, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh } from '../../../../../base/common/platform.js';\nimport { joinPath } from '../../../../../base/common/resources.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { Promises } from '../../../../../base/node/pfs.js';\nimport { FileChangeFilter, FileChangeType, IFileChange } from '../../../common/files.js';\nimport { ILogMessage, coalesceEvents, INonRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, isWatchRequestWithCorrelation } from '../../../common/watcher.js';\nimport { Lazy } from '../../../../../base/common/lazy.js';\nimport { ParsedPattern } from '../../../../../base/common/glob.js';\n\nexport class NodeJSFileWatcherLibrary extends Disposable {\n\n\t// A delay in reacting to file deletes to support\n\t// atomic save operations where a tool may chose\n\t// to delete a file before creating it again for\n\t// an update.\n\tprivate static readonly FILE_DELETE_HANDLER_DELAY = 100;\n\n\t// A delay for collecting file changes from node.js\n\t// before collecting them for coalescing and emitting\n\t// Same delay as used for the recursive watcher.\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// These numbers are a bit more aggressive compared to the\n\t// recursive watcher because we can have many individual\n\t// node.js watchers per request.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 100,\t// only process up to 100 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 10000 \t// ...but never buffering more than 10000 events in memory\n\t\t},\n\t\tevents => this.onDidFilesChange(events)\n\t));\n\n\t// Aggregate file changes over FILE_CHANGES_HANDLER_DELAY\n\t// to coalesce events and reduce spam.\n\tprivate readonly fileChangesAggregator = this._register(new RunOnceWorker<IFileChange>(events => this.handleFileChanges(events), NodeJSFileWatcherLibrary.FILE_CHANGES_HANDLER_DELAY));\n\n\tprivate readonly excludes: ParsedPattern[];\n\tprivate readonly includes: ParsedPattern[] | undefined;\n\tprivate readonly filter: FileChangeFilter | undefined;\n\n\tprivate readonly cts = new CancellationTokenSource();\n\n\tprivate readonly realPath = new Lazy(async () => {\n\n\t\t// This property is intentionally `Lazy` and not using `realcase()` as the counterpart\n\t\t// in the recursive watcher because of the amount of paths this watcher is dealing with.\n\t\t// We try as much as possible to avoid even needing `realpath()` if we can because even\n\t\t// that method does an `lstat()` per segment of the path.\n\n\t\tlet result = this.request.path;\n\n\t\ttry {\n\t\t\tresult = await Promises.realpath(this.request.path);\n\n\t\t\tif (this.request.path !== result) {\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link (original: ${this.request.path}, real: ${result})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn result;\n\t});\n\n\treadonly ready: Promise<void>;\n\n\tprivate _isReusingRecursiveWatcher = false;\n\tget isReusingRecursiveWatcher(): boolean { return this._isReusingRecursiveWatcher; }\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tconstructor(\n\t\tprivate readonly request: INonRecursiveWatchRequest,\n\t\tprivate readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined,\n\t\tprivate readonly onDidFilesChange: (changes: IFileChange[]) => void,\n\t\tprivate readonly onDidWatchFail?: () => void,\n\t\tprivate readonly onLogMessage?: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging?: boolean\n\t) {\n\t\tsuper();\n\n\t\tthis.excludes = parseWatcherPatterns(this.request.path, this.request.excludes);\n\t\tthis.includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\t\tthis.filter = isWatchRequestWithCorrelation(this.request) ? this.request.filter : undefined; // filtering is only enabled when correlating because watchers are otherwise potentially reused\n\n\t\tthis.ready = this.watch();\n\t}\n\n\tprivate async watch(): Promise<void> {\n\t\ttry {\n\t\t\tconst stat = await promises.stat(this.request.path);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._register(await this.doWatch(stat.isDirectory()));\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.error(error);\n\t\t\t} else {\n\t\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${error})`);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate notifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis.onDidWatchFail?.();\n\t}\n\n\tprivate async doWatch(isDirectory: boolean): Promise<IDisposable> {\n\t\tconst disposables = new DisposableStore();\n\n\t\tif (this.doWatchWithExistingWatcher(isDirectory, disposables)) {\n\t\t\tthis.trace(`reusing an existing recursive watcher for ${this.request.path}`);\n\t\t\tthis._isReusingRecursiveWatcher = true;\n\t\t} else {\n\t\t\tthis._isReusingRecursiveWatcher = false;\n\t\t\tawait this.doWatchWithNodeJS(isDirectory, disposables);\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate doWatchWithExistingWatcher(isDirectory: boolean, disposables: DisposableStore): boolean {\n\t\tif (isDirectory) {\n\t\t\t// Recursive watcher re-use is currently not enabled for when\n\t\t\t// folders are watched. this is because the dispatching in the\n\t\t\t// recursive watcher for non-recurive requests is optimized for\n\t\t\t// file changes  where we really only match on the exact path\n\t\t\t// and not child paths.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst resource = URI.file(this.request.path);\n\t\tconst subscription = this.recursiveWatcher?.subscribe(this.request.path, async (error, change) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tawait thenRegisterOrDispose(this.doWatch(isDirectory), disposables);\n\t\t\t} else if (change) {\n\t\t\t\tif (typeof change.cId === 'number' || typeof this.request.correlationId === 'number') {\n\t\t\t\t\t// Re-emit this change with the correlation id of the request\n\t\t\t\t\t// so that the client can correlate the event with the request\n\t\t\t\t\t// properly. Without correlation, we do not have to do that\n\t\t\t\t\t// because the event will appear on the global listener already.\n\t\t\t\t\tthis.onFileChange({ resource, type: change.type, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async doWatchWithNodeJS(isDirectory: boolean, disposables: DisposableStore): Promise<void> {\n\t\tconst realPath = await this.realPath.value;\n\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// macOS: watching samba shares can crash VSCode so we do\n\t\t// a simple check for the file path pointing to /Volumes\n\t\t// (https://github.com/microsoft/vscode/issues/106879)\n\t\t// TODO@electron this needs a revisit when the crash is\n\t\t// fixed or mitigated upstream.\n\t\tif (isMacintosh && isEqualOrParent(realPath, '/Volumes/', true)) {\n\t\t\tthis.error(`Refusing to watch ${realPath} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource(this.cts.token);\n\t\tdisposables.add(toDisposable(() => cts.dispose(true)));\n\n\t\tconst watcherDisposables = new DisposableStore(); // we need a separate disposable store because we re-create the watcher from within in some cases\n\t\tdisposables.add(watcherDisposables);\n\n\t\ttry {\n\t\t\tconst requestResource = URI.file(this.request.path);\n\t\t\tconst pathBasename = basename(realPath);\n\n\t\t\t// Creating watcher can fail with an exception\n\t\t\tconst watcher = watch(realPath);\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\twatcher.removeAllListeners();\n\t\t\t\twatcher.close();\n\t\t\t}));\n\n\t\t\tthis.trace(`Started watching: '${realPath}'`);\n\n\t\t\t// Folder: resolve children to emit proper events\n\t\t\tconst folderChildren = new Set<string>();\n\t\t\tif (isDirectory) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const child of await Promises.readdir(realPath)) {\n\t\t\t\t\t\tfolderChildren.add(child);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\tfor (const [, disposable] of mapPathToStatDisposable) {\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t}\n\t\t\t\tmapPathToStatDisposable.clear();\n\t\t\t}));\n\n\t\t\twatcher.on('error', (code: number, signal: string) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${code}, ${signal})`);\n\n\t\t\t\tthis.notifyWatchFailed();\n\t\t\t});\n\n\t\t\twatcher.on('change', (type, raw) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn; // ignore if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(`[raw] [\"${type}\"] ${raw}`);\n\t\t\t\t}\n\n\t\t\t\t// Normalize file name\n\t\t\t\tlet changedFileName = '';\n\t\t\t\tif (raw) { // https://github.com/microsoft/vscode/issues/38191\n\t\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!changedFileName || (type !== 'change' && type !== 'rename')) {\n\t\t\t\t\treturn; // ignore unexpected events\n\t\t\t\t}\n\n\t\t\t\t// Folder\n\t\t\t\tif (isDirectory) {\n\n\t\t\t\t\t// Folder child added/deleted\n\t\t\t\t\tif (type === 'rename') {\n\n\t\t\t\t\t\t// Cancel any previous stats for this file if existing\n\t\t\t\t\t\tmapPathToStatDisposable.get(changedFileName)?.dispose();\n\n\t\t\t\t\t\t// Wait a bit and try see if the file still exists on disk\n\t\t\t\t\t\t// to decide on the resulting event\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFileName);\n\n\t\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t\t// folder path is being deleted:\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// -   macOS: not reported but events continue to\n\t\t\t\t\t\t\t//            work even when the folder is brought\n\t\t\t\t\t\t\t//            back, though it seems every change\n\t\t\t\t\t\t\t//            to a file is reported as \"rename\"\n\t\t\t\t\t\t\t// -   Linux: \"rename\" event is reported with the\n\t\t\t\t\t\t\t//            name of the folder and events stop\n\t\t\t\t\t\t\t//            working\n\t\t\t\t\t\t\t// - Windows: an EPERM error is thrown that we\n\t\t\t\t\t\t\t//            handle from the `on('error')` event\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// We do not re-attach the watcher after timeout\n\t\t\t\t\t\t\t// though as we do for file watches because for\n\t\t\t\t\t\t\t// file watching specifically we want to handle\n\t\t\t\t\t\t\t// the atomic-write cases where the file is being\n\t\t\t\t\t\t\t// deleted and recreated with different contents.\n\t\t\t\t\t\t\tif (isEqual(changedFileName, pathBasename, !isLinux) && !await Promises.exists(realPath)) {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In order to properly detect renames on a case-insensitive\n\t\t\t\t\t\t\t// file system, we need to use `existsChildStrictCase` helper\n\t\t\t\t\t\t\t// because otherwise we would wrongly assume a file exists\n\t\t\t\t\t\t\t// when it was renamed to same name but different case.\n\t\t\t\t\t\t\tconst fileExists = await this.existsChildStrictCase(join(realPath, changedFileName));\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t\t// File Exists: either 'added' or 'updated' if known before\n\t\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\t\ttype = FileChangeType.DELETED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\tmapPathToStatDisposable.set(changedFileName, toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folder child changed\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// File\n\t\t\t\telse {\n\n\t\t\t\t\t// File added/deleted\n\t\t\t\t\tif (type === 'rename' || !isEqual(changedFileName, pathBasename, !isLinux)) {\n\n\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t// file path is being deleted:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// -   macOS: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// -   Linux: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// - Windows: \"rename\" event is reported and events\n\t\t\t\t\t\t//            continue to work when file is restored\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// As opposed to folder watching, we re-attach the\n\t\t\t\t\t\t// watcher after brief timeout to support \"atomic save\"\n\t\t\t\t\t\t// operations where a tool may decide to delete a file\n\t\t\t\t\t\t// and then create it with the updated contents.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Different to folder watching, we emit a delete event\n\t\t\t\t\t\t// though we never detect when the file is brought back\n\t\t\t\t\t\t// because the watcher is disposed then.\n\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tconst fileExists = await Promises.exists(realPath);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\n\t\t\t\t\t\t\t\twatcherDisposables.add(await this.doWatch(false));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File seems to be really gone, so emit a deleted and failed event\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\t\twatcherDisposables.clear();\n\t\t\t\t\t\twatcherDisposables.add(toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// File changed\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${error.toString()})`);\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate onWatchedPathDeleted(resource: URI): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted');\n\n\t\t// Emit events and flush in case the watcher gets disposed\n\t\tthis.onFileChange({ resource, type: FileChangeType.DELETED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\tthis.fileChangesAggregator.flush();\n\n\t\tthis.notifyWatchFailed();\n\t}\n\n\tprivate onFileChange(event: IFileChange, skipIncludeExcludeChecks = false): void {\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.traceWithCorrelation(`${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t}\n\n\t\t// Add to aggregator unless excluded or not included (not if explicitly disabled)\n\t\tif (!skipIncludeExcludeChecks && this.excludes.some(exclude => exclude(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (excluded) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else if (!skipIncludeExcludeChecks && this.includes && this.includes.length > 0 && !this.includes.some(include => include(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.fileChangesAggregator.work(event);\n\t\t}\n\t}\n\n\tprivate handleFileChanges(fileChanges: IFileChange[]): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedFileChanges = coalesceEvents(fileChanges);\n\n\t\t// Filter events: based on request filter property\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tfor (const event of coalescedFileChanges) {\n\t\t\tif (isFiltered(event, this.filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\tif (filteredEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tfor (const event of filteredEvents) {\n\t\t\t\tthis.traceWithCorrelation(` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t\t}\n\t\t}\n\n\t\t// Broadcast to clients via throttled emitter\n\t\tconst worked = this.throttledFileChangesEmitter.work(filteredEvents);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${filteredEvents.length}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async existsChildStrictCase(path: string): Promise<boolean> {\n\t\tif (isLinux) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\t\t\tconst children = await Promises.readdir(dirname(path));\n\n\t\t\treturn children.some(child => child === pathBasename);\n\t\t} catch (error) {\n\t\t\tthis.trace(error);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate error(error: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'error', message: `[File Watcher (node.js)] ${error}` });\n\t\t}\n\t}\n\n\tprivate warn(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'warn', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.onLogMessage?.({ type: 'trace', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate traceWithCorrelation(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.trace(`${message}${typeof this.request.correlationId === 'number' ? ` <${this.request.correlationId}> ` : ``}`);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.cts.dispose(true);\n\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Watch the provided `path` for changes and return\n * the data in chunks of `Uint8Array` for further use.\n */\nexport async function watchFileContents(path: string, onData: (chunk: Uint8Array) => void, onReady: () => void, token: CancellationToken, bufferSize = 512): Promise<void> {\n\tconst handle = await Promises.open(path, 'r');\n\tconst buffer = Buffer.allocUnsafe(bufferSize);\n\n\tconst cts = new CancellationTokenSource(token);\n\n\tlet error: Error | undefined = undefined;\n\tlet isReading = false;\n\n\tconst request: INonRecursiveWatchRequest = { path, excludes: [], recursive: false };\n\tconst watcher = new NodeJSFileWatcherLibrary(request, undefined, changes => {\n\t\t(async () => {\n\t\t\tfor (const { type } of changes) {\n\t\t\t\tif (type === FileChangeType.UPDATED) {\n\n\t\t\t\t\tif (isReading) {\n\t\t\t\t\t\treturn; // return early if we are already reading the output\n\t\t\t\t\t}\n\n\t\t\t\t\tisReading = true;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Consume the new contents of the file until finished\n\t\t\t\t\t\t// everytime there is a change event signalling a change\n\t\t\t\t\t\twhile (!cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\tconst { bytesRead } = await Promises.read(handle, buffer, 0, bufferSize, null);\n\t\t\t\t\t\t\tif (!bytesRead || cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tonData(buffer.slice(0, bytesRead));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\terror = new Error(err);\n\t\t\t\t\t\tcts.dispose(true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tisReading = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n\n\tawait watcher.ready;\n\tonReady();\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tcts.token.onCancellationRequested(async () => {\n\t\t\twatcher.dispose();\n\n\t\t\ttry {\n\t\t\t\tawait Promises.close(handle);\n\t\t\t} catch (err) {\n\t\t\t\terror = new Error(err);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n","'use strict';\n\nfunction hasKey(obj, keys) {\n\tvar o = obj;\n\tkeys.slice(0, -1).forEach(function (key) {\n\t\to = o[key] || {};\n\t});\n\n\tvar key = keys[keys.length - 1];\n\treturn key in o;\n}\n\nfunction isNumber(x) {\n\tif (typeof x === 'number') { return true; }\n\tif ((/^0x[0-9a-f]+$/i).test(x)) { return true; }\n\treturn (/^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/).test(x);\n}\n\nfunction isConstructorOrProto(obj, key) {\n\treturn (key === 'constructor' && typeof obj[key] === 'function') || key === '__proto__';\n}\n\nmodule.exports = function (args, opts) {\n\tif (!opts) { opts = {}; }\n\n\tvar flags = {\n\t\tbools: {},\n\t\tstrings: {},\n\t\tunknownFn: null,\n\t};\n\n\tif (typeof opts.unknown === 'function') {\n\t\tflags.unknownFn = opts.unknown;\n\t}\n\n\tif (typeof opts.boolean === 'boolean' && opts.boolean) {\n\t\tflags.allBools = true;\n\t} else {\n\t\t[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n\t\t\tflags.bools[key] = true;\n\t\t});\n\t}\n\n\tvar aliases = {};\n\n\tfunction aliasIsBoolean(key) {\n\t\treturn aliases[key].some(function (x) {\n\t\t\treturn flags.bools[x];\n\t\t});\n\t}\n\n\tObject.keys(opts.alias || {}).forEach(function (key) {\n\t\taliases[key] = [].concat(opts.alias[key]);\n\t\taliases[key].forEach(function (x) {\n\t\t\taliases[x] = [key].concat(aliases[key].filter(function (y) {\n\t\t\t\treturn x !== y;\n\t\t\t}));\n\t\t});\n\t});\n\n\t[].concat(opts.string).filter(Boolean).forEach(function (key) {\n\t\tflags.strings[key] = true;\n\t\tif (aliases[key]) {\n\t\t\t[].concat(aliases[key]).forEach(function (k) {\n\t\t\t\tflags.strings[k] = true;\n\t\t\t});\n\t\t}\n\t});\n\n\tvar defaults = opts.default || {};\n\n\tvar argv = { _: [] };\n\n\tfunction argDefined(key, arg) {\n\t\treturn (flags.allBools && (/^--[^=]+$/).test(arg))\n\t\t\t|| flags.strings[key]\n\t\t\t|| flags.bools[key]\n\t\t\t|| aliases[key];\n\t}\n\n\tfunction setKey(obj, keys, value) {\n\t\tvar o = obj;\n\t\tfor (var i = 0; i < keys.length - 1; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (isConstructorOrProto(o, key)) { return; }\n\t\t\tif (o[key] === undefined) { o[key] = {}; }\n\t\t\tif (\n\t\t\t\to[key] === Object.prototype\n\t\t\t\t|| o[key] === Number.prototype\n\t\t\t\t|| o[key] === String.prototype\n\t\t\t) {\n\t\t\t\to[key] = {};\n\t\t\t}\n\t\t\tif (o[key] === Array.prototype) { o[key] = []; }\n\t\t\to = o[key];\n\t\t}\n\n\t\tvar lastKey = keys[keys.length - 1];\n\t\tif (isConstructorOrProto(o, lastKey)) { return; }\n\t\tif (\n\t\t\to === Object.prototype\n\t\t\t|| o === Number.prototype\n\t\t\t|| o === String.prototype\n\t\t) {\n\t\t\to = {};\n\t\t}\n\t\tif (o === Array.prototype) { o = []; }\n\t\tif (o[lastKey] === undefined || flags.bools[lastKey] || typeof o[lastKey] === 'boolean') {\n\t\t\to[lastKey] = value;\n\t\t} else if (Array.isArray(o[lastKey])) {\n\t\t\to[lastKey].push(value);\n\t\t} else {\n\t\t\to[lastKey] = [o[lastKey], value];\n\t\t}\n\t}\n\n\tfunction setArg(key, val, arg) {\n\t\tif (arg && flags.unknownFn && !argDefined(key, arg)) {\n\t\t\tif (flags.unknownFn(arg) === false) { return; }\n\t\t}\n\n\t\tvar value = !flags.strings[key] && isNumber(val)\n\t\t\t? Number(val)\n\t\t\t: val;\n\t\tsetKey(argv, key.split('.'), value);\n\n\t\t(aliases[key] || []).forEach(function (x) {\n\t\t\tsetKey(argv, x.split('.'), value);\n\t\t});\n\t}\n\n\tObject.keys(flags.bools).forEach(function (key) {\n\t\tsetArg(key, defaults[key] === undefined ? false : defaults[key]);\n\t});\n\n\tvar notFlags = [];\n\n\tif (args.indexOf('--') !== -1) {\n\t\tnotFlags = args.slice(args.indexOf('--') + 1);\n\t\targs = args.slice(0, args.indexOf('--'));\n\t}\n\n\tfor (var i = 0; i < args.length; i++) {\n\t\tvar arg = args[i];\n\t\tvar key;\n\t\tvar next;\n\n\t\tif ((/^--.+=/).test(arg)) {\n\t\t\t// Using [\\s\\S] instead of . because js doesn't support the\n\t\t\t// 'dotall' regex modifier. See:\n\t\t\t// http://stackoverflow.com/a/1068308/13216\n\t\t\tvar m = arg.match(/^--([^=]+)=([\\s\\S]*)$/);\n\t\t\tkey = m[1];\n\t\t\tvar value = m[2];\n\t\t\tif (flags.bools[key]) {\n\t\t\t\tvalue = value !== 'false';\n\t\t\t}\n\t\t\tsetArg(key, value, arg);\n\t\t} else if ((/^--no-.+/).test(arg)) {\n\t\t\tkey = arg.match(/^--no-(.+)/)[1];\n\t\t\tsetArg(key, false, arg);\n\t\t} else if ((/^--.+/).test(arg)) {\n\t\t\tkey = arg.match(/^--(.+)/)[1];\n\t\t\tnext = args[i + 1];\n\t\t\tif (\n\t\t\t\tnext !== undefined\n\t\t\t\t&& !(/^(-|--)[^-]/).test(next)\n\t\t\t\t&& !flags.bools[key]\n\t\t\t\t&& !flags.allBools\n\t\t\t\t&& (aliases[key] ? !aliasIsBoolean(key) : true)\n\t\t\t) {\n\t\t\t\tsetArg(key, next, arg);\n\t\t\t\ti += 1;\n\t\t\t} else if ((/^(true|false)$/).test(next)) {\n\t\t\t\tsetArg(key, next === 'true', arg);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tsetArg(key, flags.strings[key] ? '' : true, arg);\n\t\t\t}\n\t\t} else if ((/^-[^-]+/).test(arg)) {\n\t\t\tvar letters = arg.slice(1, -1).split('');\n\n\t\t\tvar broken = false;\n\t\t\tfor (var j = 0; j < letters.length; j++) {\n\t\t\t\tnext = arg.slice(j + 2);\n\n\t\t\t\tif (next === '-') {\n\t\t\t\t\tsetArg(letters[j], next, arg);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ((/[A-Za-z]/).test(letters[j]) && next[0] === '=') {\n\t\t\t\t\tsetArg(letters[j], next.slice(1), arg);\n\t\t\t\t\tbroken = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(/[A-Za-z]/).test(letters[j])\n\t\t\t\t\t&& (/-?\\d+(\\.\\d*)?(e-?\\d+)?$/).test(next)\n\t\t\t\t) {\n\t\t\t\t\tsetArg(letters[j], next, arg);\n\t\t\t\t\tbroken = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n\t\t\t\t\tsetArg(letters[j], arg.slice(j + 2), arg);\n\t\t\t\t\tbroken = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tsetArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkey = arg.slice(-1)[0];\n\t\t\tif (!broken && key !== '-') {\n\t\t\t\tif (\n\t\t\t\t\targs[i + 1]\n\t\t\t\t\t&& !(/^(-|--)[^-]/).test(args[i + 1])\n\t\t\t\t\t&& !flags.bools[key]\n\t\t\t\t\t&& (aliases[key] ? !aliasIsBoolean(key) : true)\n\t\t\t\t) {\n\t\t\t\t\tsetArg(key, args[i + 1], arg);\n\t\t\t\t\ti += 1;\n\t\t\t\t} else if (args[i + 1] && (/^(true|false)$/).test(args[i + 1])) {\n\t\t\t\t\tsetArg(key, args[i + 1] === 'true', arg);\n\t\t\t\t\ti += 1;\n\t\t\t\t} else {\n\t\t\t\t\tsetArg(key, flags.strings[key] ? '' : true, arg);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!flags.unknownFn || flags.unknownFn(arg) !== false) {\n\t\t\t\targv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg));\n\t\t\t}\n\t\t\tif (opts.stopEarly) {\n\t\t\t\targv._.push.apply(argv._, args.slice(i + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.keys(defaults).forEach(function (k) {\n\t\tif (!hasKey(argv, k.split('.'))) {\n\t\t\tsetKey(argv, k.split('.'), defaults[k]);\n\n\t\t\t(aliases[k] || []).forEach(function (x) {\n\t\t\t\tsetKey(argv, x.split('.'), defaults[k]);\n\t\t\t});\n\t\t}\n\t});\n\n\tif (opts['--']) {\n\t\targv['--'] = notFlags.slice();\n\t} else {\n\t\tnotFlags.forEach(function (k) {\n\t\t\targv._.push(k);\n\t\t});\n\t}\n\n\treturn argv;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport minimist from 'minimist';\nimport { isWindows } from '../../../base/common/platform.js';\nimport { localize } from '../../../nls.js';\nimport { NativeParsedArgs } from '../common/argv.js';\n\n/**\n * This code is also used by standalone cli's. Avoid adding any other dependencies.\n */\nconst helpCategories = {\n\to: localize('optionsUpperCase', \"Options\"),\n\te: localize('extensionsManagement', \"Extensions Management\"),\n\tt: localize('troubleshooting', \"Troubleshooting\"),\n\tm: localize('mcp', \"Model Context Protocol\")\n};\n\nexport interface Option<OptionType> {\n\ttype: OptionType;\n\talias?: string;\n\tdeprecates?: string[]; // old deprecated ids\n\targs?: string | string[];\n\tdescription?: string;\n\tdeprecationMessage?: string;\n\tallowEmptyValue?: boolean;\n\tcat?: keyof typeof helpCategories;\n\tglobal?: boolean;\n}\n\nexport interface Subcommand<T> {\n\ttype: 'subcommand';\n\tdescription?: string;\n\tdeprecationMessage?: string;\n\toptions: OptionDescriptions<Required<T>>;\n}\n\nexport type OptionDescriptions<T> = {\n\t[P in keyof T]:\n\tT[P] extends boolean | undefined ? Option<'boolean'> :\n\tT[P] extends string | undefined ? Option<'string'> :\n\tT[P] extends string[] | undefined ? Option<'string[]'> :\n\tSubcommand<T[P]>\n};\n\nexport const NATIVE_CLI_COMMANDS = ['tunnel', 'serve-web'] as const;\n\nexport const OPTIONS: OptionDescriptions<Required<NativeParsedArgs>> = {\n\t'chat': {\n\t\ttype: 'subcommand',\n\t\tdescription: 'Pass in a prompt to run in a chat session in the current working directory.',\n\t\toptions: {\n\t\t\t'_': { type: 'string[]', description: localize('prompt', \"The prompt to use as chat.\") },\n\t\t\t'mode': { type: 'string', cat: 'o', alias: 'm', args: 'mode', description: localize('chatMode', \"The mode to use for the chat session. Available options: 'ask', 'edit', 'agent', or the identifier of a custom mode. Defaults to 'agent'.\") },\n\t\t\t'add-file': { type: 'string[]', cat: 'o', alias: 'a', args: 'path', description: localize('addFile', \"Add files as context to the chat session.\") },\n\t\t\t'maximize': { type: 'boolean', cat: 'o', description: localize('chatMaximize', \"Maximize the chat session view.\") },\n\t\t\t'reuse-window': { type: 'boolean', cat: 'o', alias: 'r', description: localize('reuseWindowForChat', \"Force to use the last active window for the chat session.\") },\n\t\t\t'new-window': { type: 'boolean', cat: 'o', alias: 'n', description: localize('newWindowForChat', \"Force to open an empty window for the chat session.\") },\n\t\t\t'profile': { type: 'string', 'cat': 'o', args: 'profileName', description: localize('profileName', \"Opens the provided folder or workspace with the given profile and associates the profile with the workspace. If the profile does not exist, a new empty one is created.\") },\n\t\t\t'help': { type: 'boolean', alias: 'h', description: localize('help', \"Print usage.\") }\n\t\t}\n\t},\n\t'serve-web': {\n\t\ttype: 'subcommand',\n\t\tdescription: 'Run a server that displays the editor UI in browsers.',\n\t\toptions: {\n\t\t\t'cli-data-dir': { type: 'string', args: 'dir', description: localize('cliDataDir', \"Directory where CLI metadata should be stored.\") },\n\t\t\t'disable-telemetry': { type: 'boolean' },\n\t\t\t'telemetry-level': { type: 'string' },\n\t\t}\n\t},\n\t'tunnel': {\n\t\ttype: 'subcommand',\n\t\tdescription: 'Make the current machine accessible from vscode.dev or other machines through a secure tunnel.',\n\t\toptions: {\n\t\t\t'cli-data-dir': { type: 'string', args: 'dir', description: localize('cliDataDir', \"Directory where CLI metadata should be stored.\") },\n\t\t\t'disable-telemetry': { type: 'boolean' },\n\t\t\t'telemetry-level': { type: 'string' },\n\t\t\tuser: {\n\t\t\t\ttype: 'subcommand',\n\t\t\t\toptions: {\n\t\t\t\t\tlogin: {\n\t\t\t\t\t\ttype: 'subcommand',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tprovider: { type: 'string' },\n\t\t\t\t\t\t\t'access-token': { type: 'string' }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t'diff': { type: 'boolean', cat: 'o', alias: 'd', args: ['file', 'file'], description: localize('diff', \"Compare two files with each other.\") },\n\t'merge': { type: 'boolean', cat: 'o', alias: 'm', args: ['path1', 'path2', 'base', 'result'], description: localize('merge', \"Perform a three-way merge by providing paths for two modified versions of a file, the common origin of both modified versions and the output file to save merge results.\") },\n\t'add': { type: 'boolean', cat: 'o', alias: 'a', args: 'folder', description: localize('add', \"Add folder(s) to the last active window.\") },\n\t'remove': { type: 'boolean', cat: 'o', args: 'folder', description: localize('remove', \"Remove folder(s) from the last active window.\") },\n\t'goto': { type: 'boolean', cat: 'o', alias: 'g', args: 'file:line[:character]', description: localize('goto', \"Open a file at the path on the specified line and character position.\") },\n\t'new-window': { type: 'boolean', cat: 'o', alias: 'n', description: localize('newWindow', \"Force to open a new window.\") },\n\t'reuse-window': { type: 'boolean', cat: 'o', alias: 'r', description: localize('reuseWindow', \"Force to open a file or folder in an already opened window.\") },\n\t'wait': { type: 'boolean', cat: 'o', alias: 'w', description: localize('wait', \"Wait for the files to be closed before returning.\") },\n\t'waitMarkerFilePath': { type: 'string' },\n\t'locale': { type: 'string', cat: 'o', args: 'locale', description: localize('locale', \"The locale to use (e.g. en-US or zh-TW).\") },\n\t'user-data-dir': { type: 'string', cat: 'o', args: 'dir', description: localize('userDataDir', \"Specifies the directory that user data is kept in. Can be used to open multiple distinct instances of Code.\") },\n\t'profile': { type: 'string', 'cat': 'o', args: 'profileName', description: localize('profileName', \"Opens the provided folder or workspace with the given profile and associates the profile with the workspace. If the profile does not exist, a new empty one is created.\") },\n\t'help': { type: 'boolean', cat: 'o', alias: 'h', description: localize('help', \"Print usage.\") },\n\n\t'extensions-dir': { type: 'string', deprecates: ['extensionHomePath'], cat: 'e', args: 'dir', description: localize('extensionHomePath', \"Set the root path for extensions.\") },\n\t'extensions-download-dir': { type: 'string' },\n\t'builtin-extensions-dir': { type: 'string' },\n\t'list-extensions': { type: 'boolean', cat: 'e', description: localize('listExtensions', \"List the installed extensions.\") },\n\t'show-versions': { type: 'boolean', cat: 'e', description: localize('showVersions', \"Show versions of installed extensions, when using --list-extensions.\") },\n\t'category': { type: 'string', allowEmptyValue: true, cat: 'e', description: localize('category', \"Filters installed extensions by provided category, when using --list-extensions.\"), args: 'category' },\n\t'install-extension': { type: 'string[]', cat: 'e', args: 'ext-id | path', description: localize('installExtension', \"Installs or updates an extension. The argument is either an extension id or a path to a VSIX. The identifier of an extension is '${publisher}.${name}'. Use '--force' argument to update to latest version. To install a specific version provide '@${version}'. For example: 'vscode.csharp@1.2.3'.\") },\n\t'pre-release': { type: 'boolean', cat: 'e', description: localize('install prerelease', \"Installs the pre-release version of the extension, when using --install-extension\") },\n\t'uninstall-extension': { type: 'string[]', cat: 'e', args: 'ext-id', description: localize('uninstallExtension', \"Uninstalls an extension.\") },\n\t'update-extensions': { type: 'boolean', cat: 'e', description: localize('updateExtensions', \"Update the installed extensions.\") },\n\t'enable-proposed-api': { type: 'string[]', allowEmptyValue: true, cat: 'e', args: 'ext-id', description: localize('experimentalApis', \"Enables proposed API features for extensions. Can receive one or more extension IDs to enable individually.\") },\n\n\t'add-mcp': { type: 'string[]', cat: 'm', args: 'json', description: localize('addMcp', \"Adds a Model Context Protocol server definition to the user profile. Accepts JSON input in the form '{\\\"name\\\":\\\"server-name\\\",\\\"command\\\":...}'\") },\n\n\t'version': { type: 'boolean', cat: 't', alias: 'v', description: localize('version', \"Print version.\") },\n\t'verbose': { type: 'boolean', cat: 't', global: true, description: localize('verbose', \"Print verbose output (implies --wait).\") },\n\t'log': { type: 'string[]', cat: 't', args: 'level', global: true, description: localize('log', \"Log level to use. Default is 'info'. Allowed values are 'critical', 'error', 'warn', 'info', 'debug', 'trace', 'off'. You can also configure the log level of an extension by passing extension id and log level in the following format: '${publisher}.${name}:${logLevel}'. For example: 'vscode.csharp:trace'. Can receive one or more such entries.\") },\n\t'status': { type: 'boolean', alias: 's', cat: 't', description: localize('status', \"Print process usage and diagnostics information.\") },\n\t'prof-startup': { type: 'boolean', cat: 't', description: localize('prof-startup', \"Run CPU profiler during startup.\") },\n\t'prof-append-timers': { type: 'string' },\n\t'prof-duration-markers': { type: 'string[]' },\n\t'prof-duration-markers-file': { type: 'string' },\n\t'no-cached-data': { type: 'boolean' },\n\t'prof-startup-prefix': { type: 'string' },\n\t'prof-v8-extensions': { type: 'boolean' },\n\t'disable-extensions': { type: 'boolean', deprecates: ['disableExtensions'], cat: 't', description: localize('disableExtensions', \"Disable all installed extensions. This option is not persisted and is effective only when the command opens a new window.\") },\n\t'disable-extension': { type: 'string[]', cat: 't', args: 'ext-id', description: localize('disableExtension', \"Disable the provided extension. This option is not persisted and is effective only when the command opens a new window.\") },\n\t'sync': { type: 'string', cat: 't', description: localize('turn sync', \"Turn sync on or off.\"), args: ['on | off'] },\n\n\t'inspect-extensions': { type: 'string', allowEmptyValue: true, deprecates: ['debugPluginHost'], args: 'port', cat: 't', description: localize('inspect-extensions', \"Allow debugging and profiling of extensions. Check the developer tools for the connection URI.\") },\n\t'inspect-brk-extensions': { type: 'string', allowEmptyValue: true, deprecates: ['debugBrkPluginHost'], args: 'port', cat: 't', description: localize('inspect-brk-extensions', \"Allow debugging and profiling of extensions with the extension host being paused after start. Check the developer tools for the connection URI.\") },\n\t'disable-lcd-text': { type: 'boolean', cat: 't', description: localize('disableLCDText', \"Disable LCD font rendering.\") },\n\t'disable-gpu': { type: 'boolean', cat: 't', description: localize('disableGPU', \"Disable GPU hardware acceleration.\") },\n\t'disable-chromium-sandbox': { type: 'boolean', cat: 't', description: localize('disableChromiumSandbox', \"Use this option only when there is requirement to launch the application as sudo user on Linux or when running as an elevated user in an applocker environment on Windows.\") },\n\t'sandbox': { type: 'boolean' },\n\t'locate-shell-integration-path': { type: 'string', cat: 't', args: ['shell'], description: localize('locateShellIntegrationPath', \"Print the path to a terminal shell integration script. Allowed values are 'bash', 'pwsh', 'zsh' or 'fish'.\") },\n\t'telemetry': { type: 'boolean', cat: 't', description: localize('telemetry', \"Shows all telemetry events which VS code collects.\") },\n\n\t'remote': { type: 'string', allowEmptyValue: true },\n\t'folder-uri': { type: 'string[]', cat: 'o', args: 'uri' },\n\t'file-uri': { type: 'string[]', cat: 'o', args: 'uri' },\n\n\t'locate-extension': { type: 'string[]' },\n\t'extensionDevelopmentPath': { type: 'string[]' },\n\t'extensionDevelopmentKind': { type: 'string[]' },\n\t'extensionTestsPath': { type: 'string' },\n\t'extensionEnvironment': { type: 'string' },\n\t'debugId': { type: 'string' },\n\t'debugRenderer': { type: 'boolean' },\n\t'inspect-ptyhost': { type: 'string', allowEmptyValue: true },\n\t'inspect-brk-ptyhost': { type: 'string', allowEmptyValue: true },\n\t'inspect-search': { type: 'string', deprecates: ['debugSearch'], allowEmptyValue: true },\n\t'inspect-brk-search': { type: 'string', deprecates: ['debugBrkSearch'], allowEmptyValue: true },\n\t'inspect-sharedprocess': { type: 'string', allowEmptyValue: true },\n\t'inspect-brk-sharedprocess': { type: 'string', allowEmptyValue: true },\n\t'export-default-configuration': { type: 'string' },\n\t'export-policy-data': { type: 'string', allowEmptyValue: true },\n\t'install-source': { type: 'string' },\n\t'enable-smoke-test-driver': { type: 'boolean' },\n\t'logExtensionHostCommunication': { type: 'boolean' },\n\t'skip-release-notes': { type: 'boolean' },\n\t'skip-welcome': { type: 'boolean' },\n\t'disable-telemetry': { type: 'boolean' },\n\t'disable-updates': { type: 'boolean' },\n\t'transient': { type: 'boolean', cat: 't', description: localize('transient', \"Run with temporary data and extension directories, as if launched for the first time.\") },\n\t'use-inmemory-secretstorage': { type: 'boolean', deprecates: ['disable-keytar'] },\n\t'password-store': { type: 'string' },\n\t'disable-workspace-trust': { type: 'boolean' },\n\t'disable-crash-reporter': { type: 'boolean' },\n\t'crash-reporter-directory': { type: 'string' },\n\t'crash-reporter-id': { type: 'string' },\n\t'skip-add-to-recently-opened': { type: 'boolean' },\n\t'open-url': { type: 'boolean' },\n\t'file-write': { type: 'boolean' },\n\t'file-chmod': { type: 'boolean' },\n\t'install-builtin-extension': { type: 'string[]' },\n\t'force': { type: 'boolean' },\n\t'do-not-sync': { type: 'boolean' },\n\t'do-not-include-pack-dependencies': { type: 'boolean' },\n\t'trace': { type: 'boolean' },\n\t'trace-memory-infra': { type: 'boolean' },\n\t'trace-category-filter': { type: 'string' },\n\t'trace-options': { type: 'string' },\n\t'preserve-env': { type: 'boolean' },\n\t'force-user-env': { type: 'boolean' },\n\t'force-disable-user-env': { type: 'boolean' },\n\t'open-devtools': { type: 'boolean' },\n\t'disable-gpu-sandbox': { type: 'boolean' },\n\t'logsPath': { type: 'string' },\n\t'__enable-file-policy': { type: 'boolean' },\n\t'editSessionId': { type: 'string' },\n\t'continueOn': { type: 'string' },\n\t'enable-coi': { type: 'boolean' },\n\t'unresponsive-sample-interval': { type: 'string' },\n\t'unresponsive-sample-period': { type: 'string' },\n\t'enable-rdp-display-tracking': { type: 'boolean' },\n\t'disable-layout-restore': { type: 'boolean' },\n\t'disable-experiments': { type: 'boolean' },\n\n\t// chromium flags\n\t'no-proxy-server': { type: 'boolean' },\n\t// Minimist incorrectly parses keys that start with `--no`\n\t// https://github.com/substack/minimist/blob/aeb3e27dae0412de5c0494e9563a5f10c82cc7a9/index.js#L118-L121\n\t// If --no-sandbox is passed via cli wrapper it will be treated as --sandbox which is incorrect, we use\n\t// the alias here to make sure --no-sandbox is always respected.\n\t// For https://github.com/microsoft/vscode/issues/128279\n\t'no-sandbox': { type: 'boolean', alias: 'sandbox' },\n\t'proxy-server': { type: 'string' },\n\t'proxy-bypass-list': { type: 'string' },\n\t'proxy-pac-url': { type: 'string' },\n\t'js-flags': { type: 'string' }, // chrome js flags\n\t'inspect': { type: 'string', allowEmptyValue: true },\n\t'inspect-brk': { type: 'string', allowEmptyValue: true },\n\t'nolazy': { type: 'boolean' }, // node inspect\n\t'force-device-scale-factor': { type: 'string' },\n\t'force-renderer-accessibility': { type: 'boolean' },\n\t'ignore-certificate-errors': { type: 'boolean' },\n\t'allow-insecure-localhost': { type: 'boolean' },\n\t'log-net-log': { type: 'string' },\n\t'vmodule': { type: 'string' },\n\t'_urls': { type: 'string[]' },\n\t'disable-dev-shm-usage': { type: 'boolean' },\n\t'profile-temp': { type: 'boolean' },\n\t'ozone-platform': { type: 'string' },\n\t'enable-tracing': { type: 'string' },\n\t'trace-startup-format': { type: 'string' },\n\t'trace-startup-file': { type: 'string' },\n\t'trace-startup-duration': { type: 'string' },\n\t'xdg-portal-required-version': { type: 'string' },\n\n\t_: { type: 'string[]' } // main arguments\n};\n\nexport interface ErrorReporter {\n\tonUnknownOption(id: string): void;\n\tonMultipleValues(id: string, usedValue: string): void;\n\tonEmptyValue(id: string): void;\n\tonDeprecatedOption(deprecatedId: string, message: string): void;\n\n\tgetSubcommandReporter?(command: string): ErrorReporter;\n}\n\nconst ignoringReporter = {\n\tonUnknownOption: () => { },\n\tonMultipleValues: () => { },\n\tonEmptyValue: () => { },\n\tonDeprecatedOption: () => { }\n};\n\nexport function parseArgs<T>(args: string[], options: OptionDescriptions<T>, errorReporter: ErrorReporter = ignoringReporter): T {\n\t// Find the first non-option arg, which also isn't the value for a previous `--flag`\n\tconst firstPossibleCommand = args.find((a, i) => a.length > 0 && a[0] !== '-' && options.hasOwnProperty(a) && options[a as T].type === 'subcommand');\n\n\tconst alias: { [key: string]: string } = {};\n\tconst stringOptions: string[] = ['_'];\n\tconst booleanOptions: string[] = [];\n\tconst globalOptions: Record<string, Option<'boolean'> | Option<'string'> | Option<'string[]'>> = {};\n\tlet command: Subcommand<Record<string, unknown>> | undefined = undefined;\n\tfor (const optionId in options) {\n\t\tconst o = options[optionId];\n\t\tif (o.type === 'subcommand') {\n\t\t\tif (optionId === firstPossibleCommand) {\n\t\t\t\tcommand = o;\n\t\t\t}\n\t\t} else {\n\t\t\tif (o.alias) {\n\t\t\t\talias[optionId] = o.alias;\n\t\t\t}\n\n\t\t\tif (o.type === 'string' || o.type === 'string[]') {\n\t\t\t\tstringOptions.push(optionId);\n\t\t\t\tif (o.deprecates) {\n\t\t\t\t\tstringOptions.push(...o.deprecates);\n\t\t\t\t}\n\t\t\t} else if (o.type === 'boolean') {\n\t\t\t\tbooleanOptions.push(optionId);\n\t\t\t\tif (o.deprecates) {\n\t\t\t\t\tbooleanOptions.push(...o.deprecates);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (o.global) {\n\t\t\t\tglobalOptions[optionId] = o;\n\t\t\t}\n\t\t}\n\t}\n\tif (command && firstPossibleCommand) {\n\t\tconst options: Record<string, Option<'boolean'> | Option<'string'> | Option<'string[]'> | Subcommand<Record<string, unknown>>> = globalOptions;\n\t\tfor (const optionId in command.options) {\n\t\t\toptions[optionId] = command.options[optionId];\n\t\t}\n\t\tconst newArgs = args.filter(a => a !== firstPossibleCommand);\n\t\tconst reporter = errorReporter.getSubcommandReporter ? errorReporter.getSubcommandReporter(firstPossibleCommand) : undefined;\n\t\tconst subcommandOptions = parseArgs(newArgs, options as OptionDescriptions<Record<string, unknown>>, reporter);\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\treturn <T>{\n\t\t\t[firstPossibleCommand]: subcommandOptions,\n\t\t\t_: []\n\t\t};\n\t}\n\n\n\t// remove aliases to avoid confusion\n\tconst parsedArgs = minimist(args, { string: stringOptions, boolean: booleanOptions, alias });\n\n\tconst cleanedArgs: Record<string, unknown> = {};\n\tconst remainingArgs: Record<string, unknown> = parsedArgs;\n\n\t// https://github.com/microsoft/vscode/issues/58177, https://github.com/microsoft/vscode/issues/106617\n\tcleanedArgs._ = parsedArgs._.map(arg => String(arg)).filter(arg => arg.length > 0);\n\n\tdelete remainingArgs._;\n\n\tfor (const optionId in options) {\n\t\tconst o = options[optionId];\n\t\tif (o.type === 'subcommand') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (o.alias) {\n\t\t\tdelete remainingArgs[o.alias];\n\t\t}\n\n\t\tlet val = remainingArgs[optionId];\n\t\tif (o.deprecates) {\n\t\t\tfor (const deprecatedId of o.deprecates) {\n\t\t\t\tif (remainingArgs.hasOwnProperty(deprecatedId)) {\n\t\t\t\t\tif (!val) {\n\t\t\t\t\t\tval = remainingArgs[deprecatedId];\n\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\terrorReporter.onDeprecatedOption(deprecatedId, o.deprecationMessage || localize('deprecated.useInstead', 'Use {0} instead.', optionId));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete remainingArgs[deprecatedId];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof val !== 'undefined') {\n\t\t\tif (o.type === 'string[]') {\n\t\t\t\tif (!Array.isArray(val)) {\n\t\t\t\t\tval = [val];\n\t\t\t\t}\n\t\t\t\tif (!o.allowEmptyValue) {\n\t\t\t\t\tconst sanitized = (val as string[]).filter((v: string) => v.length > 0);\n\t\t\t\t\tif (sanitized.length !== (val as string[]).length) {\n\t\t\t\t\t\terrorReporter.onEmptyValue(optionId);\n\t\t\t\t\t\tval = sanitized.length > 0 ? sanitized : undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (o.type === 'string') {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\tval = val.pop(); // take the last\n\t\t\t\t\terrorReporter.onMultipleValues(optionId, val as string);\n\t\t\t\t} else if (!val && !o.allowEmptyValue) {\n\t\t\t\t\terrorReporter.onEmptyValue(optionId);\n\t\t\t\t\tval = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcleanedArgs[optionId] = val;\n\n\t\t\tif (o.deprecationMessage) {\n\t\t\t\terrorReporter.onDeprecatedOption(optionId, o.deprecationMessage);\n\t\t\t}\n\t\t}\n\t\tdelete remainingArgs[optionId];\n\t}\n\n\tfor (const key in remainingArgs) {\n\t\terrorReporter.onUnknownOption(key);\n\t}\n\n\treturn cleanedArgs as T;\n}\n\nfunction formatUsage(optionId: string, option: Option<'boolean'> | Option<'string'> | Option<'string[]'>) {\n\tlet args = '';\n\tif (option.args) {\n\t\tif (Array.isArray(option.args)) {\n\t\t\targs = ` <${option.args.join('> <')}>`;\n\t\t} else {\n\t\t\targs = ` <${option.args}>`;\n\t\t}\n\t}\n\tif (option.alias) {\n\t\treturn `-${option.alias} --${optionId}${args}`;\n\t}\n\treturn `--${optionId}${args}`;\n}\n\n// exported only for testing\nexport function formatOptions(options: OptionDescriptions<unknown> | Record<string, Option<'boolean'> | Option<'string'> | Option<'string[]'>>, columns: number): string[] {\n\tconst usageTexts: [string, string][] = [];\n\tfor (const optionId in options) {\n\t\tconst o = options[optionId as keyof typeof options] as Option<'boolean'> | Option<'string'> | Option<'string[]'>;\n\t\tconst usageText = formatUsage(optionId, o);\n\t\tusageTexts.push([usageText, o.description!]);\n\t}\n\treturn formatUsageTexts(usageTexts, columns);\n}\n\nfunction formatUsageTexts(usageTexts: [string, string][], columns: number) {\n\tconst maxLength = usageTexts.reduce((previous, e) => Math.max(previous, e[0].length), 12);\n\tconst argLength = maxLength + 2/*left padding*/ + 1/*right padding*/;\n\tif (columns - argLength < 25) {\n\t\t// Use a condensed version on narrow terminals\n\t\treturn usageTexts.reduce<string[]>((r, ut) => r.concat([`  ${ut[0]}`, `      ${ut[1]}`]), []);\n\t}\n\tconst descriptionColumns = columns - argLength - 1;\n\tconst result: string[] = [];\n\tfor (const ut of usageTexts) {\n\t\tconst usage = ut[0];\n\t\tconst wrappedDescription = wrapText(ut[1], descriptionColumns);\n\t\tconst keyPadding = indent(argLength - usage.length - 2/*left padding*/);\n\t\tresult.push('  ' + usage + keyPadding + wrappedDescription[0]);\n\t\tfor (let i = 1; i < wrappedDescription.length; i++) {\n\t\t\tresult.push(indent(argLength) + wrappedDescription[i]);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction indent(count: number): string {\n\treturn ' '.repeat(count);\n}\n\nfunction wrapText(text: string, columns: number): string[] {\n\tconst lines: string[] = [];\n\twhile (text.length) {\n\t\tlet index = text.length < columns ? text.length : text.lastIndexOf(' ', columns);\n\t\tif (index === 0) {\n\t\t\tindex = columns;\n\t\t}\n\t\tconst line = text.slice(0, index).trim();\n\t\ttext = text.slice(index).trimStart();\n\t\tlines.push(line);\n\t}\n\treturn lines;\n}\n\nexport function buildHelpMessage(productName: string, executableName: string, version: string, options: OptionDescriptions<unknown> | Record<string, Option<'boolean'> | Option<'string'> | Option<'string[]'> | Subcommand<Record<string, unknown>>>, capabilities?: { noPipe?: boolean; noInputFiles?: boolean; isChat?: boolean }): string {\n\tconst columns = (process.stdout).isTTY && (process.stdout).columns || 80;\n\tconst inputFiles = capabilities?.noInputFiles ? '' : capabilities?.isChat ? ` [${localize('cliPrompt', 'prompt')}]` : ` [${localize('paths', 'paths')}...]`;\n\tconst subcommand = capabilities?.isChat ? ' chat' : '';\n\n\tconst help = [`${productName} ${version}`];\n\thelp.push('');\n\thelp.push(`${localize('usage', \"Usage\")}: ${executableName}${subcommand} [${localize('options', \"options\")}]${inputFiles}`);\n\thelp.push('');\n\tif (capabilities?.noPipe !== true) {\n\t\thelp.push(buildStdinMessage(executableName, capabilities?.isChat));\n\t\thelp.push('');\n\t}\n\tconst optionsByCategory: { [P in keyof typeof helpCategories]?: Record<string, Option<'boolean'> | Option<'string'> | Option<'string[]'>> } = {};\n\tconst subcommands: { command: string; description: string }[] = [];\n\tfor (const optionId in options) {\n\t\tconst o = options[optionId as keyof typeof options] as Option<'boolean'> | Option<'string'> | Option<'string[]'> | Subcommand<Record<string, unknown>>;\n\t\tif (o.type === 'subcommand') {\n\t\t\tif (o.description) {\n\t\t\t\tsubcommands.push({ command: optionId, description: o.description });\n\t\t\t}\n\t\t} else if (o.description && o.cat) {\n\t\t\tconst cat = o.cat;\n\t\t\tlet optionsByCat = optionsByCategory[cat];\n\t\t\tif (!optionsByCat) {\n\t\t\t\toptionsByCategory[cat] = optionsByCat = {};\n\t\t\t}\n\t\t\toptionsByCat[optionId] = o;\n\t\t}\n\t}\n\n\tfor (const helpCategoryKey in optionsByCategory) {\n\t\tconst key = <keyof typeof helpCategories>helpCategoryKey;\n\n\t\tconst categoryOptions = optionsByCategory[key];\n\t\tif (categoryOptions) {\n\t\t\thelp.push(helpCategories[key]);\n\t\t\thelp.push(...formatOptions(categoryOptions, columns));\n\t\t\thelp.push('');\n\t\t}\n\t}\n\n\tif (subcommands.length) {\n\t\thelp.push(localize('subcommands', \"Subcommands\"));\n\t\thelp.push(...formatUsageTexts(subcommands.map(s => [s.command, s.description]), columns));\n\t\thelp.push('');\n\t}\n\n\treturn help.join('\\n');\n}\n\nexport function buildStdinMessage(executableName: string, isChat?: boolean): string {\n\tlet example: string;\n\tif (isWindows) {\n\t\tif (isChat) {\n\t\t\texample = `echo Hello World | ${executableName} chat <prompt> -`;\n\t\t} else {\n\t\t\texample = `echo Hello World | ${executableName} -`;\n\t\t}\n\t} else {\n\t\tif (isChat) {\n\t\t\texample = `ps aux | grep code | ${executableName} chat <prompt> -`;\n\t\t} else {\n\t\t\texample = `ps aux | grep code | ${executableName} -`;\n\t\t}\n\t}\n\n\treturn localize('stdinUsage', \"To read from stdin, append '-' (e.g. '{0}')\", example);\n}\n\nexport function buildVersionMessage(version: string | undefined, commit: string | undefined): string {\n\treturn `${version || localize('unknownVersion', \"Unknown version\")}\\n${commit || localize('unknownCommit', \"Unknown commit\")}\\n${process.arch}`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { IProcessEnvironment } from '../../../base/common/platform.js';\nimport { localize } from '../../../nls.js';\nimport { NativeParsedArgs } from '../common/argv.js';\nimport { ErrorReporter, NATIVE_CLI_COMMANDS, OPTIONS, parseArgs } from './argv.js';\n\nfunction parseAndValidate(cmdLineArgs: string[], reportWarnings: boolean): NativeParsedArgs {\n\tconst onMultipleValues = (id: string, val: string) => {\n\t\tconsole.warn(localize('multipleValues', \"Option '{0}' is defined more than once. Using value '{1}'.\", id, val));\n\t};\n\tconst onEmptyValue = (id: string) => {\n\t\tconsole.warn(localize('emptyValue', \"Option '{0}' requires a non empty value. Ignoring the option.\", id));\n\t};\n\tconst onDeprecatedOption = (deprecatedOption: string, message: string) => {\n\t\tconsole.warn(localize('deprecatedArgument', \"Option '{0}' is deprecated: {1}\", deprecatedOption, message));\n\t};\n\tconst getSubcommandReporter = (command: string) => ({\n\t\tonUnknownOption: (id: string) => {\n\t\t\tif (!(NATIVE_CLI_COMMANDS as readonly string[]).includes(command)) {\n\t\t\t\tconsole.warn(localize('unknownSubCommandOption', \"Warning: '{0}' is not in the list of known options for subcommand '{1}'\", id, command));\n\t\t\t}\n\t\t},\n\t\tonMultipleValues,\n\t\tonEmptyValue,\n\t\tonDeprecatedOption,\n\t\tgetSubcommandReporter: (NATIVE_CLI_COMMANDS as readonly string[]).includes(command) ? getSubcommandReporter : undefined\n\t});\n\tconst errorReporter: ErrorReporter = {\n\t\tonUnknownOption: (id) => {\n\t\t\tconsole.warn(localize('unknownOption', \"Warning: '{0}' is not in the list of known options, but still passed to Electron/Chromium.\", id));\n\t\t},\n\t\tonMultipleValues,\n\t\tonEmptyValue,\n\t\tonDeprecatedOption,\n\t\tgetSubcommandReporter\n\t};\n\n\tconst args = parseArgs(cmdLineArgs, OPTIONS, reportWarnings ? errorReporter : undefined);\n\tif (args.goto) {\n\t\targs._.forEach(arg => assert(/^(\\w:)?[^:]+(:\\d*){0,2}:?$/.test(arg), localize('gotoValidation', \"Arguments in `--goto` mode should be in the format of `FILE(:LINE(:CHARACTER))`.\")));\n\t}\n\n\treturn args;\n}\n\nfunction stripAppPath(argv: string[]): string[] | undefined {\n\tconst index = argv.findIndex(a => !/^-/.test(a));\n\n\tif (index > -1) {\n\t\treturn [...argv.slice(0, index), ...argv.slice(index + 1)];\n\t}\n\treturn undefined;\n}\n\n/**\n * Use this to parse raw code process.argv such as: `Electron . --verbose --wait`\n */\nexport function parseMainProcessArgv(processArgv: string[]): NativeParsedArgs {\n\tlet [, ...args] = processArgv;\n\n\t// If dev, remove the first non-option argument: it's the app location\n\tif (process.env['VSCODE_DEV']) {\n\t\targs = stripAppPath(args) || [];\n\t}\n\n\t// If called from CLI, don't report warnings as they are already reported.\n\tconst reportWarnings = !isLaunchedFromCli(process.env);\n\treturn parseAndValidate(args, reportWarnings);\n}\n\n/**\n * Use this to parse raw code CLI process.argv such as: `Electron cli.js . --verbose --wait`\n */\nexport function parseCLIProcessArgv(processArgv: string[]): NativeParsedArgs {\n\tlet [, , ...args] = processArgv; // remove the first non-option argument: it's always the app location\n\n\t// If dev, remove the first non-option argument: it's the app location\n\tif (process.env['VSCODE_DEV']) {\n\t\targs = stripAppPath(args) || [];\n\t}\n\n\treturn parseAndValidate(args, true);\n}\n\nexport function addArg(argv: string[], ...args: string[]): string[] {\n\tconst endOfArgsMarkerIndex = argv.indexOf('--');\n\tif (endOfArgsMarkerIndex === -1) {\n\t\targv.push(...args);\n\t} else {\n\t\t// if the we have an argument \"--\" (end of argument marker)\n\t\t// we cannot add arguments at the end. rather, we add\n\t\t// arguments before the \"--\" marker.\n\t\targv.splice(endOfArgsMarkerIndex, 0, ...args);\n\t}\n\n\treturn argv;\n}\n\nexport function isLaunchedFromCli(env: IProcessEnvironment): boolean {\n\treturn env['VSCODE_CLI'] === '1';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This code is also used by standalone cli's. Avoid adding dependencies to keep the size of the cli small.\n */\nimport { exec } from 'child_process';\nimport { isWindows } from '../common/platform.js';\n\nconst windowsTerminalEncodings = {\n\t'437': 'cp437', // United States\n\t'850': 'cp850', // Multilingual(Latin I)\n\t'852': 'cp852', // Slavic(Latin II)\n\t'855': 'cp855', // Cyrillic(Russian)\n\t'857': 'cp857', // Turkish\n\t'860': 'cp860', // Portuguese\n\t'861': 'cp861', // Icelandic\n\t'863': 'cp863', // Canadian - French\n\t'865': 'cp865', // Nordic\n\t'866': 'cp866', // Russian\n\t'869': 'cp869', // Modern Greek\n\t'936': 'cp936', // Simplified Chinese\n\t'1252': 'cp1252' // West European Latin\n};\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\t'ibm866': 'cp866',\n\t'big5': 'cp950'\n};\n\nconst UTF8 = 'utf8';\n\nexport async function resolveTerminalEncoding(verbose?: boolean): Promise<string> {\n\tlet rawEncodingPromise: Promise<string | undefined>;\n\n\t// Support a global environment variable to win over other mechanics\n\tconst cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];\n\tif (cliEncodingEnv) {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Found VSCODE_CLI_ENCODING variable: ${cliEncodingEnv}`);\n\t\t}\n\n\t\trawEncodingPromise = Promise.resolve(cliEncodingEnv);\n\t}\n\n\t// Windows: educated guess\n\telse if (isWindows) {\n\t\trawEncodingPromise = new Promise<string | undefined>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"chcp\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('chcp', (err, stdout, stderr) => {\n\t\t\t\tif (stdout) {\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tconsole.log(`Output from \"chcp\" command is: ${stdout}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings) as Array<keyof typeof windowsTerminalEncodings>;\n\t\t\t\t\tfor (const key of windowsTerminalEncodingKeys) {\n\t\t\t\t\t\tif (stdout.indexOf(key) >= 0) {\n\t\t\t\t\t\t\treturn resolve(windowsTerminalEncodings[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\t// Linux/Mac: use \"locale charmap\" command\n\telse {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"locale charmap\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('locale charmap', (err, stdout, stderr) => resolve(stdout));\n\t\t});\n\t}\n\n\tconst rawEncoding = await rawEncodingPromise;\n\tif (verbose) {\n\t\tconsole.log(`Detected raw terminal encoding: ${rawEncoding}`);\n\t}\n\n\tif (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === UTF8) {\n\t\treturn UTF8;\n\t}\n\n\treturn toIconvLiteEncoding(rawEncoding);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This code is also used by standalone cli's. Avoid adding dependencies to keep the size of the cli small.\n */\nimport { exec } from 'child_process';\nimport { isWindows } from '../common/platform.js';\n\nconst windowsTerminalEncodings = {\n\t'437': 'cp437', // United States\n\t'850': 'cp850', // Multilingual(Latin I)\n\t'852': 'cp852', // Slavic(Latin II)\n\t'855': 'cp855', // Cyrillic(Russian)\n\t'857': 'cp857', // Turkish\n\t'860': 'cp860', // Portuguese\n\t'861': 'cp861', // Icelandic\n\t'863': 'cp863', // Canadian - French\n\t'865': 'cp865', // Nordic\n\t'866': 'cp866', // Russian\n\t'869': 'cp869', // Modern Greek\n\t'936': 'cp936', // Simplified Chinese\n\t'1252': 'cp1252' // West European Latin\n};\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\t'ibm866': 'cp866',\n\t'big5': 'cp950'\n};\n\nconst UTF8 = 'utf8';\n\nexport async function resolveTerminalEncoding(verbose?: boolean): Promise<string> {\n\tlet rawEncodingPromise: Promise<string | undefined>;\n\n\t// Support a global environment variable to win over other mechanics\n\tconst cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];\n\tif (cliEncodingEnv) {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Found VSCODE_CLI_ENCODING variable: ${cliEncodingEnv}`);\n\t\t}\n\n\t\trawEncodingPromise = Promise.resolve(cliEncodingEnv);\n\t}\n\n\t// Windows: educated guess\n\telse if (isWindows) {\n\t\trawEncodingPromise = new Promise<string | undefined>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"chcp\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('chcp', (err, stdout, stderr) => {\n\t\t\t\tif (stdout) {\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tconsole.log(`Output from \"chcp\" command is: ${stdout}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings) as Array<keyof typeof windowsTerminalEncodings>;\n\t\t\t\t\tfor (const key of windowsTerminalEncodingKeys) {\n\t\t\t\t\t\tif (stdout.indexOf(key) >= 0) {\n\t\t\t\t\t\t\treturn resolve(windowsTerminalEncodings[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\t// Linux/Mac: use \"locale charmap\" command\n\telse {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"locale charmap\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('locale charmap', (err, stdout, stderr) => resolve(stdout));\n\t\t});\n\t}\n\n\tconst rawEncoding = await rawEncodingPromise;\n\tif (verbose) {\n\t\tconsole.log(`Detected raw terminal encoding: ${rawEncoding}`);\n\t}\n\n\tif (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === UTF8) {\n\t\treturn UTF8;\n\t}\n\n\treturn toIconvLiteEncoding(rawEncoding);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { Queue } from '../../../base/common/async.js';\nimport { randomPath } from '../../../base/common/extpath.js';\nimport { resolveTerminalEncoding } from '../../../base/node/terminalEncoding.js';\n\nexport function hasStdinWithoutTty() {\n\ttry {\n\t\treturn !process.stdin.isTTY; // Via https://twitter.com/MylesBorins/status/782009479382626304\n\t} catch {\n\t\t// Windows workaround for https://github.com/nodejs/node/issues/11656\n\t}\n\treturn false;\n}\n\nexport function stdinDataListener(durationinMs: number): Promise<boolean> {\n\treturn new Promise(resolve => {\n\t\tconst dataListener = () => resolve(true);\n\n\t\t// wait for 1s maximum...\n\t\tsetTimeout(() => {\n\t\t\tprocess.stdin.removeListener('data', dataListener);\n\n\t\t\tresolve(false);\n\t\t}, durationinMs);\n\n\t\t// ...but finish early if we detect data\n\t\tprocess.stdin.once('data', dataListener);\n\t});\n}\n\nexport function getStdinFilePath(): string {\n\treturn randomPath(tmpdir(), 'code-stdin', 3);\n}\n\nasync function createStdInFile(targetPath: string) {\n\tawait fs.promises.appendFile(targetPath, '');\n\tawait fs.promises.chmod(targetPath, 0o600); // Ensure the file is only read/writable by the user: https://github.com/microsoft/vscode-remote-release/issues/9048\n}\n\nexport async function readFromStdin(targetPath: string, verbose: boolean, onEnd?: Function): Promise<void> {\n\n\tlet [encoding, iconv] = await Promise.all([\n\t\tresolveTerminalEncoding(verbose),\t\t// respect terminal encoding when piping into file\n\t\timport('@vscode/iconv-lite-umd'),\t\t// lazy load encoding module for usage\n\t\tcreateStdInFile(targetPath) \t\t\t// make sure file exists right away (https://github.com/microsoft/vscode/issues/155341)\n\t]);\n\n\tif (!iconv.default.encodingExists(encoding)) {\n\t\tconsole.log(`Unsupported terminal encoding: ${encoding}, falling back to UTF-8.`);\n\t\tencoding = 'utf8';\n\t}\n\n\t// Use a `Queue` to be able to use `appendFile`\n\t// which helps file watchers to be aware of the\n\t// changes because each append closes the underlying\n\t// file descriptor.\n\t// (https://github.com/microsoft/vscode/issues/148952)\n\n\tconst appendFileQueue = new Queue();\n\n\tconst decoder = iconv.default.getDecoder(encoding);\n\n\tprocess.stdin.on('data', chunk => {\n\t\tconst chunkStr = decoder.write(chunk);\n\t\tappendFileQueue.queue(() => fs.promises.appendFile(targetPath, chunkStr));\n\t});\n\n\tprocess.stdin.on('end', () => {\n\t\tconst end = decoder.end();\n\n\t\tappendFileQueue.queue(async () => {\n\t\t\ttry {\n\t\t\t\tif (typeof end === 'string') {\n\t\t\t\t\tawait fs.promises.appendFile(targetPath, end);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tonEnd?.();\n\t\t\t}\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { Queue } from '../../../base/common/async.js';\nimport { randomPath } from '../../../base/common/extpath.js';\nimport { resolveTerminalEncoding } from '../../../base/node/terminalEncoding.js';\n\nexport function hasStdinWithoutTty() {\n\ttry {\n\t\treturn !process.stdin.isTTY; // Via https://twitter.com/MylesBorins/status/782009479382626304\n\t} catch {\n\t\t// Windows workaround for https://github.com/nodejs/node/issues/11656\n\t}\n\treturn false;\n}\n\nexport function stdinDataListener(durationinMs: number): Promise<boolean> {\n\treturn new Promise(resolve => {\n\t\tconst dataListener = () => resolve(true);\n\n\t\t// wait for 1s maximum...\n\t\tsetTimeout(() => {\n\t\t\tprocess.stdin.removeListener('data', dataListener);\n\n\t\t\tresolve(false);\n\t\t}, durationinMs);\n\n\t\t// ...but finish early if we detect data\n\t\tprocess.stdin.once('data', dataListener);\n\t});\n}\n\nexport function getStdinFilePath(): string {\n\treturn randomPath(tmpdir(), 'code-stdin', 3);\n}\n\nasync function createStdInFile(targetPath: string) {\n\tawait fs.promises.appendFile(targetPath, '');\n\tawait fs.promises.chmod(targetPath, 0o600); // Ensure the file is only read/writable by the user: https://github.com/microsoft/vscode-remote-release/issues/9048\n}\n\nexport async function readFromStdin(targetPath: string, verbose: boolean, onEnd?: Function): Promise<void> {\n\n\tlet [encoding, iconv] = await Promise.all([\n\t\tresolveTerminalEncoding(verbose),\t\t// respect terminal encoding when piping into file\n\t\timport('@vscode/iconv-lite-umd'),\t\t// lazy load encoding module for usage\n\t\tcreateStdInFile(targetPath) \t\t\t// make sure file exists right away (https://github.com/microsoft/vscode/issues/155341)\n\t]);\n\n\tif (!iconv.default.encodingExists(encoding)) {\n\t\tconsole.log(`Unsupported terminal encoding: ${encoding}, falling back to UTF-8.`);\n\t\tencoding = 'utf8';\n\t}\n\n\t// Use a `Queue` to be able to use `appendFile`\n\t// which helps file watchers to be aware of the\n\t// changes because each append closes the underlying\n\t// file descriptor.\n\t// (https://github.com/microsoft/vscode/issues/148952)\n\n\tconst appendFileQueue = new Queue();\n\n\tconst decoder = iconv.default.getDecoder(encoding);\n\n\tprocess.stdin.on('data', chunk => {\n\t\tconst chunkStr = decoder.write(chunk);\n\t\tappendFileQueue.queue(() => fs.promises.appendFile(targetPath, chunkStr));\n\t});\n\n\tprocess.stdin.on('end', () => {\n\t\tconst end = decoder.end();\n\n\t\tappendFileQueue.queue(async () => {\n\t\t\ttry {\n\t\t\t\tif (typeof end === 'string') {\n\t\t\t\t\tawait fs.promises.appendFile(targetPath, end);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tonEnd?.();\n\t\t\t}\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { writeFileSync } from 'fs';\nimport { tmpdir } from 'os';\nimport { randomPath } from '../../../base/common/extpath.js';\n\nexport function createWaitMarkerFileSync(verbose?: boolean): string | undefined {\n\tconst randomWaitMarkerPath = randomPath(tmpdir());\n\n\ttry {\n\t\twriteFileSync(randomWaitMarkerPath, ''); // use built-in fs to avoid dragging in more dependencies\n\t\tif (verbose) {\n\t\t\tconsole.log(`Marker file for --wait created: ${randomWaitMarkerPath}`);\n\t\t}\n\t\treturn randomWaitMarkerPath;\n\t} catch (err) {\n\t\tif (verbose) {\n\t\t\tconsole.error(`Failed to create marker file for --wait: ${err}`);\n\t\t}\n\t\treturn undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { writeFileSync } from 'fs';\nimport { tmpdir } from 'os';\nimport { randomPath } from '../../../base/common/extpath.js';\n\nexport function createWaitMarkerFileSync(verbose?: boolean): string | undefined {\n\tconst randomWaitMarkerPath = randomPath(tmpdir());\n\n\ttry {\n\t\twriteFileSync(randomWaitMarkerPath, ''); // use built-in fs to avoid dragging in more dependencies\n\t\tif (verbose) {\n\t\t\tconsole.log(`Marker file for --wait created: ${randomWaitMarkerPath}`);\n\t\t}\n\t\treturn randomWaitMarkerPath;\n\t} catch (err) {\n\t\tif (verbose) {\n\t\t\tconsole.error(`Failed to create marker file for --wait: ${err}`);\n\t\t}\n\t\treturn undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { env } from '../../../base/common/process.js';\nimport { IProductConfiguration } from '../../../base/common/product.js';\nimport { ISandboxConfiguration } from '../../../base/parts/sandbox/common/sandboxTypes.js';\n\n/**\n * @deprecated It is preferred that you use `IProductService` if you can. This\n * allows web embedders to override our defaults. But for things like `product.quality`,\n * the use is fine because that property is not overridable.\n */\nlet product: IProductConfiguration;\n\n// Native sandbox environment\nconst vscodeGlobal = (globalThis as { vscode?: { context?: { configuration(): ISandboxConfiguration | undefined } } }).vscode;\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.context !== 'undefined') {\n\tconst configuration: ISandboxConfiguration | undefined = vscodeGlobal.context.configuration();\n\tif (configuration) {\n\t\tproduct = configuration.product;\n\t} else {\n\t\tthrow new Error('Sandbox: unable to resolve product configuration from preload script.');\n\t}\n}\n// _VSCODE environment\nelse if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {\n\t// Obtain values from product.json and package.json-data\n\tproduct = globalThis._VSCODE_PRODUCT_JSON as unknown as IProductConfiguration;\n\n\t// Running out of sources\n\tif (env['VSCODE_DEV']) {\n\t\tObject.assign(product, {\n\t\t\tnameShort: `${product.nameShort} Dev`,\n\t\t\tnameLong: `${product.nameLong} Dev`,\n\t\t\tdataFolderName: `${product.dataFolderName}-dev`,\n\t\t\tserverDataFolderName: product.serverDataFolderName ? `${product.serverDataFolderName}-dev` : undefined\n\t\t});\n\t}\n\n\t// Version is added during built time, but we still\n\t// want to have it running out of sources so we\n\t// read it from package.json only when we need it.\n\tif (!product.version) {\n\t\tconst pkg = globalThis._VSCODE_PACKAGE_JSON as { version: string };\n\n\t\tObject.assign(product, {\n\t\t\tversion: pkg.version\n\t\t});\n\t}\n}\n\n// Web environment or unknown\nelse {\n\n\t// Built time configuration (do NOT modify)\n\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\tproduct = { /*BUILD->INSERT_PRODUCT_CONFIGURATION*/ } as unknown as IProductConfiguration;\n\n\t// Running out of sources\n\tif (Object.keys(product).length === 0) {\n\t\tObject.assign(product, {\n\t\t\tversion: '1.104.0-dev',\n\t\t\tnameShort: 'Code - OSS Dev',\n\t\t\tnameLong: 'Code - OSS Dev',\n\t\t\tapplicationName: 'code-oss',\n\t\t\tdataFolderName: '.vscode-oss',\n\t\t\turlProtocol: 'code-oss',\n\t\t\treportIssueUrl: 'https://github.com/microsoft/vscode/issues/new',\n\t\t\tlicenseName: 'MIT',\n\t\t\tlicenseUrl: 'https://github.com/microsoft/vscode/blob/main/LICENSE.txt',\n\t\t\tserverLicenseUrl: 'https://github.com/microsoft/vscode/blob/main/LICENSE.txt'\n\t\t});\n\t}\n}\n\nexport default product;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { env } from '../../../base/common/process.js';\nimport { IProductConfiguration } from '../../../base/common/product.js';\nimport { ISandboxConfiguration } from '../../../base/parts/sandbox/common/sandboxTypes.js';\n\n/**\n * @deprecated It is preferred that you use `IProductService` if you can. This\n * allows web embedders to override our defaults. But for things like `product.quality`,\n * the use is fine because that property is not overridable.\n */\nlet product: IProductConfiguration;\n\n// Native sandbox environment\nconst vscodeGlobal = (globalThis as { vscode?: { context?: { configuration(): ISandboxConfiguration | undefined } } }).vscode;\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.context !== 'undefined') {\n\tconst configuration: ISandboxConfiguration | undefined = vscodeGlobal.context.configuration();\n\tif (configuration) {\n\t\tproduct = configuration.product;\n\t} else {\n\t\tthrow new Error('Sandbox: unable to resolve product configuration from preload script.');\n\t}\n}\n// _VSCODE environment\nelse if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {\n\t// Obtain values from product.json and package.json-data\n\tproduct = globalThis._VSCODE_PRODUCT_JSON as unknown as IProductConfiguration;\n\n\t// Running out of sources\n\tif (env['VSCODE_DEV']) {\n\t\tObject.assign(product, {\n\t\t\tnameShort: `${product.nameShort} Dev`,\n\t\t\tnameLong: `${product.nameLong} Dev`,\n\t\t\tdataFolderName: `${product.dataFolderName}-dev`,\n\t\t\tserverDataFolderName: product.serverDataFolderName ? `${product.serverDataFolderName}-dev` : undefined\n\t\t});\n\t}\n\n\t// Version is added during built time, but we still\n\t// want to have it running out of sources so we\n\t// read it from package.json only when we need it.\n\tif (!product.version) {\n\t\tconst pkg = globalThis._VSCODE_PACKAGE_JSON as { version: string };\n\n\t\tObject.assign(product, {\n\t\t\tversion: pkg.version\n\t\t});\n\t}\n}\n\n// Web environment or unknown\nelse {\n\n\t// Built time configuration (do NOT modify)\n\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\tproduct = { /*BUILD->INSERT_PRODUCT_CONFIGURATION*/ } as unknown as IProductConfiguration;\n\n\t// Running out of sources\n\tif (Object.keys(product).length === 0) {\n\t\tObject.assign(product, {\n\t\t\tversion: '1.104.0-dev',\n\t\t\tnameShort: 'Code - OSS Dev',\n\t\t\tnameLong: 'Code - OSS Dev',\n\t\t\tapplicationName: 'code-oss',\n\t\t\tdataFolderName: '.vscode-oss',\n\t\t\turlProtocol: 'code-oss',\n\t\t\treportIssueUrl: 'https://github.com/microsoft/vscode/issues/new',\n\t\t\tlicenseName: 'MIT',\n\t\t\tlicenseUrl: 'https://github.com/microsoft/vscode/blob/main/LICENSE.txt',\n\t\t\tserverLicenseUrl: 'https://github.com/microsoft/vscode/blob/main/LICENSE.txt'\n\t\t});\n\t}\n}\n\nexport default product;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { basename, isAbsolute, join } from '../../../base/common/path.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nexport interface IV8Profile {\n\tnodes: IV8ProfileNode[];\n\tsamples?: number[];\n\ttimeDeltas?: number[];\n\tstartTime: number;\n\tendTime: number;\n}\n\nexport interface IV8ProfileNode {\n\tid: number;\n\thitCount?: number;\n\tchildren?: number[];\n\tcallFrame: IV8CallFrame;\n\tdeoptReason?: string;\n\tpositionTicks?: { line: number; ticks: number }[];\n}\n\nexport interface IV8CallFrame {\n\turl: string;\n\tscriptId: string;\n\tfunctionName: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport const IV8InspectProfilingService = createDecorator<IV8InspectProfilingService>('IV8InspectProfilingService');\n\nexport interface IV8InspectProfilingService {\n\n\t_serviceBrand: undefined;\n\n\tstartProfiling(options: { host: string; port: number }): Promise<string>;\n\n\tstopProfiling(sessionId: string): Promise<IV8Profile>;\n}\n\n\nexport namespace Utils {\n\n\texport function isValidProfile(profile: IV8Profile): profile is Required<IV8Profile> {\n\t\treturn Boolean(profile.samples && profile.timeDeltas);\n\t}\n\n\texport function rewriteAbsolutePaths(profile: IV8Profile, replace: string = 'noAbsolutePaths') {\n\t\tfor (const node of profile.nodes) {\n\t\t\tif (node.callFrame && node.callFrame.url) {\n\t\t\t\tif (isAbsolute(node.callFrame.url) || /^\\w[\\w\\d+.-]*:\\/\\/\\/?/.test(node.callFrame.url)) {\n\t\t\t\t\tnode.callFrame.url = join(replace, basename(node.callFrame.url));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn profile;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { basename, isAbsolute, join } from '../../../base/common/path.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nexport interface IV8Profile {\n\tnodes: IV8ProfileNode[];\n\tsamples?: number[];\n\ttimeDeltas?: number[];\n\tstartTime: number;\n\tendTime: number;\n}\n\nexport interface IV8ProfileNode {\n\tid: number;\n\thitCount?: number;\n\tchildren?: number[];\n\tcallFrame: IV8CallFrame;\n\tdeoptReason?: string;\n\tpositionTicks?: { line: number; ticks: number }[];\n}\n\nexport interface IV8CallFrame {\n\turl: string;\n\tscriptId: string;\n\tfunctionName: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport const IV8InspectProfilingService = createDecorator<IV8InspectProfilingService>('IV8InspectProfilingService');\n\nexport interface IV8InspectProfilingService {\n\n\t_serviceBrand: undefined;\n\n\tstartProfiling(options: { host: string; port: number }): Promise<string>;\n\n\tstopProfiling(sessionId: string): Promise<IV8Profile>;\n}\n\n\nexport namespace Utils {\n\n\texport function isValidProfile(profile: IV8Profile): profile is Required<IV8Profile> {\n\t\treturn Boolean(profile.samples && profile.timeDeltas);\n\t}\n\n\texport function rewriteAbsolutePaths(profile: IV8Profile, replace: string = 'noAbsolutePaths') {\n\t\tfor (const node of profile.nodes) {\n\t\t\tif (node.callFrame && node.callFrame.url) {\n\t\t\t\tif (isAbsolute(node.callFrame.url) || /^\\w[\\w\\d+.-]*:\\/\\/\\/?/.test(node.callFrame.url)) {\n\t\t\t\t\tnode.callFrame.url = join(replace, basename(node.callFrame.url));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn profile;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function getUNCHostAllowlist(): string[] {\n\tconst allowlist = processUNCHostAllowlist();\n\tif (allowlist) {\n\t\treturn Array.from(allowlist);\n\t}\n\n\treturn [];\n}\n\nfunction processUNCHostAllowlist(): Set<string> | undefined {\n\n\t// The property `process.uncHostAllowlist` is not available in official node.js\n\t// releases, only in our own builds, so we have to probe for availability\n\n\treturn (process as unknown as { uncHostAllowlist?: Set<string> }).uncHostAllowlist;\n}\n\nexport function addUNCHostToAllowlist(allowedHost: string | string[]): void {\n\tif (process.platform !== 'win32') {\n\t\treturn;\n\t}\n\n\tconst allowlist = processUNCHostAllowlist();\n\tif (allowlist) {\n\t\tif (typeof allowedHost === 'string') {\n\t\t\tallowlist.add(allowedHost.toLowerCase()); // UNC hosts are case-insensitive\n\t\t} else {\n\t\t\tfor (const host of toSafeStringArray(allowedHost)) {\n\t\t\t\taddUNCHostToAllowlist(host);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction toSafeStringArray(arg0: unknown): string[] {\n\tconst allowedUNCHosts = new Set<string>();\n\n\tif (Array.isArray(arg0)) {\n\t\tfor (const host of arg0) {\n\t\t\tif (typeof host === 'string') {\n\t\t\t\tallowedUNCHosts.add(host);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Array.from(allowedUNCHosts);\n}\n\nexport function getUNCHost(maybeUNCPath: string | undefined | null): string | undefined {\n\tif (typeof maybeUNCPath !== 'string') {\n\t\treturn undefined; // require a valid string\n\t}\n\n\tconst uncRoots = [\n\t\t'\\\\\\\\.\\\\UNC\\\\',\t// DOS Device paths (https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats)\n\t\t'\\\\\\\\?\\\\UNC\\\\',\n\t\t'\\\\\\\\'\t\t\t// standard UNC path\n\t];\n\n\tlet host = undefined;\n\n\tfor (const uncRoot of uncRoots) {\n\t\tconst indexOfUNCRoot = maybeUNCPath.indexOf(uncRoot);\n\t\tif (indexOfUNCRoot !== 0) {\n\t\t\tcontinue; // not matching any of our expected UNC roots\n\t\t}\n\n\t\tconst indexOfUNCPath = maybeUNCPath.indexOf('\\\\', uncRoot.length);\n\t\tif (indexOfUNCPath === -1) {\n\t\t\tcontinue; // no path component found\n\t\t}\n\n\t\tconst hostCandidate = maybeUNCPath.substring(uncRoot.length, indexOfUNCPath);\n\t\tif (hostCandidate) {\n\t\t\thost = hostCandidate;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn host;\n}\n\nexport function disableUNCAccessRestrictions(): void {\n\tif (process.platform !== 'win32') {\n\t\treturn;\n\t}\n\n\t(process as unknown as { restrictUNCAccess?: boolean }).restrictUNCAccess = false;\n}\n\nexport function isUNCAccessRestrictionsDisabled(): boolean {\n\tif (process.platform !== 'win32') {\n\t\treturn true;\n\t}\n\n\treturn (process as unknown as { restrictUNCAccess?: boolean }).restrictUNCAccess === false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function getUNCHostAllowlist(): string[] {\n\tconst allowlist = processUNCHostAllowlist();\n\tif (allowlist) {\n\t\treturn Array.from(allowlist);\n\t}\n\n\treturn [];\n}\n\nfunction processUNCHostAllowlist(): Set<string> | undefined {\n\n\t// The property `process.uncHostAllowlist` is not available in official node.js\n\t// releases, only in our own builds, so we have to probe for availability\n\n\treturn (process as unknown as { uncHostAllowlist?: Set<string> }).uncHostAllowlist;\n}\n\nexport function addUNCHostToAllowlist(allowedHost: string | string[]): void {\n\tif (process.platform !== 'win32') {\n\t\treturn;\n\t}\n\n\tconst allowlist = processUNCHostAllowlist();\n\tif (allowlist) {\n\t\tif (typeof allowedHost === 'string') {\n\t\t\tallowlist.add(allowedHost.toLowerCase()); // UNC hosts are case-insensitive\n\t\t} else {\n\t\t\tfor (const host of toSafeStringArray(allowedHost)) {\n\t\t\t\taddUNCHostToAllowlist(host);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction toSafeStringArray(arg0: unknown): string[] {\n\tconst allowedUNCHosts = new Set<string>();\n\n\tif (Array.isArray(arg0)) {\n\t\tfor (const host of arg0) {\n\t\t\tif (typeof host === 'string') {\n\t\t\t\tallowedUNCHosts.add(host);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Array.from(allowedUNCHosts);\n}\n\nexport function getUNCHost(maybeUNCPath: string | undefined | null): string | undefined {\n\tif (typeof maybeUNCPath !== 'string') {\n\t\treturn undefined; // require a valid string\n\t}\n\n\tconst uncRoots = [\n\t\t'\\\\\\\\.\\\\UNC\\\\',\t// DOS Device paths (https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats)\n\t\t'\\\\\\\\?\\\\UNC\\\\',\n\t\t'\\\\\\\\'\t\t\t// standard UNC path\n\t];\n\n\tlet host = undefined;\n\n\tfor (const uncRoot of uncRoots) {\n\t\tconst indexOfUNCRoot = maybeUNCPath.indexOf(uncRoot);\n\t\tif (indexOfUNCRoot !== 0) {\n\t\t\tcontinue; // not matching any of our expected UNC roots\n\t\t}\n\n\t\tconst indexOfUNCPath = maybeUNCPath.indexOf('\\\\', uncRoot.length);\n\t\tif (indexOfUNCPath === -1) {\n\t\t\tcontinue; // no path component found\n\t\t}\n\n\t\tconst hostCandidate = maybeUNCPath.substring(uncRoot.length, indexOfUNCPath);\n\t\tif (hostCandidate) {\n\t\t\thost = hostCandidate;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn host;\n}\n\nexport function disableUNCAccessRestrictions(): void {\n\tif (process.platform !== 'win32') {\n\t\treturn;\n\t}\n\n\t(process as unknown as { restrictUNCAccess?: boolean }).restrictUNCAccess = false;\n}\n\nexport function isUNCAccessRestrictionsDisabled(): boolean {\n\tif (process.platform !== 'win32') {\n\t\treturn true;\n\t}\n\n\treturn (process as unknown as { restrictUNCAccess?: boolean }).restrictUNCAccess === false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, spawn, SpawnOptions, StdioOptions } from 'child_process';\nimport { chmodSync, existsSync, readFileSync, statSync, truncateSync, unlinkSync } from 'fs';\nimport { homedir, release, tmpdir } from 'os';\nimport type { ProfilingSession, Target } from 'v8-inspect-profiler';\nimport { Event } from '../../base/common/event.js';\nimport { isAbsolute, resolve, join, dirname } from '../../base/common/path.js';\nimport { IProcessEnvironment, isMacintosh, isWindows } from '../../base/common/platform.js';\nimport { randomPort } from '../../base/common/ports.js';\nimport { whenDeleted, writeFileSync } from '../../base/node/pfs.js';\nimport { findFreePort } from '../../base/node/ports.js';\nimport { watchFileContents } from '../../platform/files/node/watcher/nodejs/nodejsWatcherLib.js';\nimport { NativeParsedArgs } from '../../platform/environment/common/argv.js';\nimport { buildHelpMessage, buildStdinMessage, buildVersionMessage, NATIVE_CLI_COMMANDS, OPTIONS } from '../../platform/environment/node/argv.js';\nimport { addArg, parseCLIProcessArgv } from '../../platform/environment/node/argvHelper.js';\nimport { getStdinFilePath, hasStdinWithoutTty, readFromStdin, stdinDataListener } from '../../platform/environment/node/stdin.js';\nimport { createWaitMarkerFileSync } from '../../platform/environment/node/wait.js';\nimport product from '../../platform/product/common/product.js';\nimport { CancellationTokenSource } from '../../base/common/cancellation.js';\nimport { isUNC, randomPath } from '../../base/common/extpath.js';\nimport { Utils } from '../../platform/profiling/common/profiling.js';\nimport { FileAccess } from '../../base/common/network.js';\nimport { cwd } from '../../base/common/process.js';\nimport { addUNCHostToAllowlist } from '../../base/node/unc.js';\nimport { URI } from '../../base/common/uri.js';\nimport { DeferredPromise } from '../../base/common/async.js';\n\nfunction shouldSpawnCliProcess(argv: NativeParsedArgs): boolean {\n\treturn !!argv['install-source']\n\t\t|| !!argv['list-extensions']\n\t\t|| !!argv['install-extension']\n\t\t|| !!argv['uninstall-extension']\n\t\t|| !!argv['update-extensions']\n\t\t|| !!argv['locate-extension']\n\t\t|| !!argv['add-mcp']\n\t\t|| !!argv['telemetry'];\n}\n\nexport async function main(argv: string[]): Promise<void> {\n\tlet args: NativeParsedArgs;\n\n\ttry {\n\t\targs = parseCLIProcessArgv(argv);\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t\treturn;\n\t}\n\n\tfor (const subcommand of NATIVE_CLI_COMMANDS) {\n\t\tif (args[subcommand]) {\n\t\t\tif (!product.tunnelApplicationName) {\n\t\t\t\tconsole.error(`'${subcommand}' command not supported in ${product.applicationName}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst env: IProcessEnvironment = {\n\t\t\t\t...process.env\n\t\t\t};\n\t\t\t// bootstrap-esm.js determines the electron environment based\n\t\t\t// on the following variable. For the server we need to unset\n\t\t\t// it to prevent importing any electron specific modules.\n\t\t\t// Refs https://github.com/microsoft/vscode/issues/221883\n\t\t\tdelete env['ELECTRON_RUN_AS_NODE'];\n\n\t\t\tconst tunnelArgs = argv.slice(argv.indexOf(subcommand) + 1); // all arguments behind `tunnel`\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tlet tunnelProcess: ChildProcess;\n\t\t\t\tconst stdio: StdioOptions = ['ignore', 'pipe', 'pipe'];\n\t\t\t\tif (process.env['VSCODE_DEV']) {\n\t\t\t\t\ttunnelProcess = spawn('cargo', ['run', '--', subcommand, ...tunnelArgs], { cwd: join(getAppRoot(), 'cli'), stdio, env });\n\t\t\t\t} else {\n\t\t\t\t\tconst appPath = process.platform === 'darwin'\n\t\t\t\t\t\t// ./Contents/MacOS/Electron => ./Contents/Resources/app/bin/code-tunnel-insiders\n\t\t\t\t\t\t? join(dirname(dirname(process.execPath)), 'Resources', 'app')\n\t\t\t\t\t\t: dirname(process.execPath);\n\t\t\t\t\tconst tunnelCommand = join(appPath, 'bin', `${product.tunnelApplicationName}${isWindows ? '.exe' : ''}`);\n\t\t\t\t\ttunnelProcess = spawn(tunnelCommand, [subcommand, ...tunnelArgs], { cwd: cwd(), stdio, env });\n\t\t\t\t}\n\n\t\t\t\ttunnelProcess.stdout!.pipe(process.stdout);\n\t\t\t\ttunnelProcess.stderr!.pipe(process.stderr);\n\t\t\t\ttunnelProcess.on('exit', resolve);\n\t\t\t\ttunnelProcess.on('error', reject);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Help (general)\n\tif (args.help) {\n\t\tconst executable = `${product.applicationName}${isWindows ? '.exe' : ''}`;\n\t\tconsole.log(buildHelpMessage(product.nameLong, executable, product.version, OPTIONS));\n\t}\n\n\t// Help (chat)\n\telse if (args.chat?.help) {\n\t\tconst executable = `${product.applicationName}${isWindows ? '.exe' : ''}`;\n\t\tconsole.log(buildHelpMessage(product.nameLong, executable, product.version, OPTIONS.chat.options, { isChat: true }));\n\t}\n\n\t// Version Info\n\telse if (args.version) {\n\t\tconsole.log(buildVersionMessage(product.version, product.commit));\n\t}\n\n\t// Shell integration\n\telse if (args['locate-shell-integration-path']) {\n\t\tlet file: string;\n\t\tswitch (args['locate-shell-integration-path']) {\n\t\t\t// Usage: `[[ \"$TERM_PROGRAM\" == \"vscode\" ]] && . \"$(code --locate-shell-integration-path bash)\"`\n\t\t\tcase 'bash': file = 'shellIntegration-bash.sh'; break;\n\t\t\t// Usage: `if ($env:TERM_PROGRAM -eq \"vscode\") { . \"$(code --locate-shell-integration-path pwsh)\" }`\n\t\t\tcase 'pwsh': file = 'shellIntegration.ps1'; break;\n\t\t\t// Usage: `[[ \"$TERM_PROGRAM\" == \"vscode\" ]] && . \"$(code --locate-shell-integration-path zsh)\"`\n\t\t\tcase 'zsh': file = 'shellIntegration-rc.zsh'; break;\n\t\t\t// Usage: `string match -q \"$TERM_PROGRAM\" \"vscode\"; and . (code --locate-shell-integration-path fish)`\n\t\t\tcase 'fish': file = 'shellIntegration.fish'; break;\n\t\t\tdefault: throw new Error('Error using --locate-shell-integration-path: Invalid shell type');\n\t\t}\n\t\tconsole.log(join(getAppRoot(), 'out', 'vs', 'workbench', 'contrib', 'terminal', 'common', 'scripts', file));\n\t}\n\n\t// Extensions Management\n\telse if (shouldSpawnCliProcess(args)) {\n\n\t\t// We do not bundle `cliProcessMain.js` into this file because\n\t\t// it is rather large and only needed for very few CLI operations.\n\t\t// This has the downside that we need to know if we run OSS or\n\t\t// built, because our location on disk is different if built.\n\n\t\tlet cliProcessMain: string;\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\tcliProcessMain = './cliProcessMain.js';\n\t\t} else {\n\t\t\tcliProcessMain = './vs/code/node/cliProcessMain.js';\n\t\t}\n\n\t\tconst cli = await import(cliProcessMain);\n\t\tawait cli.main(args);\n\n\t\treturn;\n\t}\n\n\t// Write File\n\telse if (args['file-write']) {\n\t\tconst argsFile = args._[0];\n\t\tif (!argsFile || !isAbsolute(argsFile) || !existsSync(argsFile) || !statSync(argsFile).isFile()) {\n\t\t\tthrow new Error('Using --file-write with invalid arguments.');\n\t\t}\n\n\t\tlet source: string | undefined;\n\t\tlet target: string | undefined;\n\t\ttry {\n\t\t\tconst argsContents: { source: string; target: string } = JSON.parse(readFileSync(argsFile, 'utf8'));\n\t\t\tsource = argsContents.source;\n\t\t\ttarget = argsContents.target;\n\t\t} catch (error) {\n\t\t\tthrow new Error('Using --file-write with invalid arguments.');\n\t\t}\n\n\t\t// Windows: set the paths as allowed UNC paths given\n\t\t// they are explicitly provided by the user as arguments\n\t\tif (isWindows) {\n\t\t\tfor (const path of [source, target]) {\n\t\t\t\tif (typeof path === 'string' && isUNC(path)) {\n\t\t\t\t\taddUNCHostToAllowlist(URI.file(path).authority);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Validate\n\t\tif (\n\t\t\t!source || !target || source === target ||\t\t\t\t// make sure source and target are provided and are not the same\n\t\t\t!isAbsolute(source) || !isAbsolute(target) ||\t\t\t// make sure both source and target are absolute paths\n\t\t\t!existsSync(source) || !statSync(source).isFile() ||\t// make sure source exists as file\n\t\t\t!existsSync(target) || !statSync(target).isFile()\t\t// make sure target exists as file\n\t\t) {\n\t\t\tthrow new Error('Using --file-write with invalid arguments.');\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Check for readonly status and chmod if so if we are told so\n\t\t\tlet targetMode = 0;\n\t\t\tlet restoreMode = false;\n\t\t\tif (args['file-chmod']) {\n\t\t\t\ttargetMode = statSync(target).mode;\n\t\t\t\tif (!(targetMode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\tchmodSync(target, targetMode | 0o200);\n\t\t\t\t\trestoreMode = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Write source to target\n\t\t\tconst data = readFileSync(source);\n\t\t\tif (isWindows) {\n\t\t\t\t// On Windows we use a different strategy of saving the file\n\t\t\t\t// by first truncating the file and then writing with r+ mode.\n\t\t\t\t// This helps to save hidden files on Windows\n\t\t\t\t// (see https://github.com/microsoft/vscode/issues/931) and\n\t\t\t\t// prevent removing alternate data streams\n\t\t\t\t// (see https://github.com/microsoft/vscode/issues/6363)\n\t\t\t\ttruncateSync(target, 0);\n\t\t\t\twriteFileSync(target, data, { flag: 'r+' });\n\t\t\t} else {\n\t\t\t\twriteFileSync(target, data);\n\t\t\t}\n\n\t\t\t// Restore previous mode as needed\n\t\t\tif (restoreMode) {\n\t\t\t\tchmodSync(target, targetMode);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\terror.message = `Error using --file-write: ${error.message}`;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// Just Code\n\telse {\n\t\tconst env: IProcessEnvironment = {\n\t\t\t...process.env,\n\t\t\t'ELECTRON_NO_ATTACH_CONSOLE': '1'\n\t\t};\n\n\t\tdelete env['ELECTRON_RUN_AS_NODE'];\n\n\t\tconst processCallbacks: ((child: ChildProcess) => Promise<void>)[] = [];\n\n\t\tif (args.verbose) {\n\t\t\tenv['ELECTRON_ENABLE_LOGGING'] = '1';\n\t\t}\n\n\t\tif (args.verbose || args.status) {\n\t\t\tprocessCallbacks.push(async child => {\n\t\t\t\tchild.stdout?.on('data', (data: Buffer) => console.log(data.toString('utf8').trim()));\n\t\t\t\tchild.stderr?.on('data', (data: Buffer) => console.log(data.toString('utf8').trim()));\n\n\t\t\t\tawait Event.toPromise(Event.fromNodeEventEmitter(child, 'exit'));\n\t\t\t});\n\t\t}\n\n\t\t// Handle --transient option\n\t\tif (args['transient']) {\n\t\t\tconst tempParentDir = randomPath(tmpdir(), 'vscode');\n\t\t\tconst tempUserDataDir = join(tempParentDir, 'data');\n\t\t\tconst tempExtensionsDir = join(tempParentDir, 'extensions');\n\n\t\t\taddArg(argv, '--user-data-dir', tempUserDataDir);\n\t\t\taddArg(argv, '--extensions-dir', tempExtensionsDir);\n\n\t\t\tconsole.log(`State is temporarily stored. Relaunch this state with: ${product.applicationName} --user-data-dir \"${tempUserDataDir}\" --extensions-dir \"${tempExtensionsDir}\"`);\n\t\t}\n\n\t\tconst hasReadStdinArg = args._.some(arg => arg === '-') || args.chat?._.some(arg => arg === '-');\n\t\tif (hasReadStdinArg) {\n\t\t\t// remove the \"-\" argument when we read from stdin\n\t\t\targs._ = args._.filter(a => a !== '-');\n\t\t\targv = argv.filter(a => a !== '-');\n\t\t}\n\n\t\tlet stdinFilePath: string | undefined;\n\t\tif (hasStdinWithoutTty()) {\n\n\t\t\t// Read from stdin: we require a single \"-\" argument to be passed in order to start reading from\n\t\t\t// stdin. We do this because there is no reliable way to find out if data is piped to stdin. Just\n\t\t\t// checking for stdin being connected to a TTY is not enough (https://github.com/microsoft/vscode/issues/40351)\n\n\t\t\tif (hasReadStdinArg) {\n\t\t\t\tstdinFilePath = getStdinFilePath();\n\n\t\t\t\ttry {\n\t\t\t\t\tconst readFromStdinDone = new DeferredPromise<void>();\n\t\t\t\t\tawait readFromStdin(stdinFilePath, !!args.verbose, () => readFromStdinDone.complete());\n\t\t\t\t\tif (!args.wait) {\n\n\t\t\t\t\t\t// if `--wait` is not provided, we keep this process alive\n\t\t\t\t\t\t// for at least as long as the stdin stream is open to\n\t\t\t\t\t\t// ensure that we read all the data.\n\t\t\t\t\t\t// the downside is that the Code CLI process will then not\n\t\t\t\t\t\t// terminate until stdin is closed, but users can always\n\t\t\t\t\t\t// pass `--wait` to prevent that from happening (this is\n\t\t\t\t\t\t// actually what we enforced until v1.85.x but then was\n\t\t\t\t\t\t// changed to not enforce it anymore).\n\t\t\t\t\t\t// a solution in the future would possibly be to exit, when\n\t\t\t\t\t\t// the Code process exits. this would require some careful\n\t\t\t\t\t\t// solution though in case Code is already running and this\n\t\t\t\t\t\t// is a second instance telling the first instance what to\n\t\t\t\t\t\t// open.\n\n\t\t\t\t\t\tprocessCallbacks.push(() => readFromStdinDone.p);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (args.chat) {\n\t\t\t\t\t\t// Make sure to add tmp file as context to chat\n\t\t\t\t\t\taddArg(argv, '--add-file', stdinFilePath);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Make sure to open tmp file as editor but ignore\n\t\t\t\t\t\t// it in the \"recently open\" list\n\t\t\t\t\t\taddArg(argv, stdinFilePath);\n\t\t\t\t\t\taddArg(argv, '--skip-add-to-recently-opened');\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log(`Reading from stdin via: ${stdinFilePath}`);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(`Failed to create file to read via stdin: ${e.toString()}`);\n\t\t\t\t\tstdinFilePath = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// If the user pipes data via stdin but forgot to add the \"-\" argument, help by printing a message\n\t\t\t\t// if we detect that data flows into via stdin after a certain timeout.\n\t\t\t\tprocessCallbacks.push(_ => stdinDataListener(1000).then(dataReceived => {\n\t\t\t\t\tif (dataReceived) {\n\t\t\t\t\t\tconsole.log(buildStdinMessage(product.applicationName, !!args.chat));\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tconst isMacOSBigSurOrNewer = isMacintosh && release() > '20.0.0';\n\n\t\t// If we are started with --wait create a random temporary file\n\t\t// and pass it over to the starting instance. We can use this file\n\t\t// to wait for it to be deleted to monitor that the edited file\n\t\t// is closed and then exit the waiting process.\n\t\tlet waitMarkerFilePath: string | undefined;\n\t\tif (args.wait) {\n\t\t\twaitMarkerFilePath = createWaitMarkerFileSync(args.verbose);\n\t\t\tif (waitMarkerFilePath) {\n\t\t\t\taddArg(argv, '--waitMarkerFilePath', waitMarkerFilePath);\n\t\t\t}\n\n\t\t\t// When running with --wait, we want to continue running CLI process\n\t\t\t// until either:\n\t\t\t// - the wait marker file has been deleted (e.g. when closing the editor)\n\t\t\t// - the launched process terminates (e.g. due to a crash)\n\t\t\tprocessCallbacks.push(async child => {\n\t\t\t\tlet childExitPromise;\n\t\t\t\tif (isMacOSBigSurOrNewer) {\n\t\t\t\t\t// On Big Sur, we resolve the following promise only when the child,\n\t\t\t\t\t// i.e. the open command, exited with a signal or error. Otherwise, we\n\t\t\t\t\t// wait for the marker file to be deleted or for the child to error.\n\t\t\t\t\tchildExitPromise = new Promise<void>(resolve => {\n\t\t\t\t\t\t// Only resolve this promise if the child (i.e. open) exited with an error\n\t\t\t\t\t\tchild.on('exit', (code, signal) => {\n\t\t\t\t\t\t\tif (code !== 0 || signal) {\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// On other platforms, we listen for exit in case the child exits before the\n\t\t\t\t\t// marker file is deleted.\n\t\t\t\t\tchildExitPromise = Event.toPromise(Event.fromNodeEventEmitter(child, 'exit'));\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\twhenDeleted(waitMarkerFilePath!),\n\t\t\t\t\t\tEvent.toPromise(Event.fromNodeEventEmitter(child, 'error')),\n\t\t\t\t\t\tchildExitPromise\n\t\t\t\t\t]);\n\t\t\t\t} finally {\n\t\t\t\t\tif (stdinFilePath) {\n\t\t\t\t\t\tunlinkSync(stdinFilePath); // Make sure to delete the tmp stdin file if we have any\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// If we have been started with `--prof-startup` we need to find free ports to profile\n\t\t// the main process, the renderer, and the extension host. We also disable v8 cached data\n\t\t// to get better profile traces. Last, we listen on stdout for a signal that tells us to\n\t\t// stop profiling.\n\t\tif (args['prof-startup']) {\n\t\t\tconst profileHost = '127.0.0.1';\n\t\t\tconst portMain = await findFreePort(randomPort(), 10, 3000);\n\t\t\tconst portRenderer = await findFreePort(portMain + 1, 10, 3000);\n\t\t\tconst portExthost = await findFreePort(portRenderer + 1, 10, 3000);\n\n\t\t\t// fail the operation when one of the ports couldn't be acquired.\n\t\t\tif (portMain * portRenderer * portExthost === 0) {\n\t\t\t\tthrow new Error('Failed to find free ports for profiler. Make sure to shutdown all instances of the editor first.');\n\t\t\t}\n\n\t\t\tconst filenamePrefix = randomPath(homedir(), 'prof');\n\n\t\t\taddArg(argv, `--inspect-brk=${profileHost}:${portMain}`);\n\t\t\taddArg(argv, `--remote-debugging-port=${profileHost}:${portRenderer}`);\n\t\t\taddArg(argv, `--inspect-brk-extensions=${profileHost}:${portExthost}`);\n\t\t\taddArg(argv, `--prof-startup-prefix`, filenamePrefix);\n\t\t\taddArg(argv, `--no-cached-data`);\n\n\t\t\twriteFileSync(filenamePrefix, argv.slice(-6).join('|'));\n\n\t\t\tprocessCallbacks.push(async _child => {\n\n\t\t\t\tclass Profiler {\n\t\t\t\t\tstatic async start(name: string, filenamePrefix: string, opts: { port: number; tries?: number; target?: (targets: Target[]) => Target }) {\n\t\t\t\t\t\tconst profiler = await import('v8-inspect-profiler');\n\n\t\t\t\t\t\tlet session: ProfilingSession;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsession = await profiler.startProfiling({ ...opts, host: profileHost });\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tconsole.error(`FAILED to start profiling for '${name}' on port '${opts.port}'`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tasync stop() {\n\t\t\t\t\t\t\t\tif (!session) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet suffix = '';\n\t\t\t\t\t\t\t\tconst result = await session.stop();\n\t\t\t\t\t\t\t\tif (!process.env['VSCODE_DEV']) {\n\t\t\t\t\t\t\t\t\t// when running from a not-development-build we remove\n\t\t\t\t\t\t\t\t\t// absolute filenames because we don't want to reveal anything\n\t\t\t\t\t\t\t\t\t// about users. We also append the `.txt` suffix to make it\n\t\t\t\t\t\t\t\t\t// easier to attach these files to GH issues\n\t\t\t\t\t\t\t\t\tresult.profile = Utils.rewriteAbsolutePaths(result.profile, 'piiRemoved');\n\t\t\t\t\t\t\t\t\tsuffix = '.txt';\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twriteFileSync(`${filenamePrefix}.${name}.cpuprofile${suffix}`, JSON.stringify(result.profile, undefined, 4));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// load and start profiler\n\t\t\t\t\tconst mainProfileRequest = Profiler.start('main', filenamePrefix, { port: portMain });\n\t\t\t\t\tconst extHostProfileRequest = Profiler.start('extHost', filenamePrefix, { port: portExthost, tries: 300 });\n\t\t\t\t\tconst rendererProfileRequest = Profiler.start('renderer', filenamePrefix, {\n\t\t\t\t\t\tport: portRenderer,\n\t\t\t\t\t\ttries: 200,\n\t\t\t\t\t\ttarget: function (targets) {\n\t\t\t\t\t\t\treturn targets.filter(target => {\n\t\t\t\t\t\t\t\tif (!target.webSocketDebuggerUrl) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (target.type === 'page') {\n\t\t\t\t\t\t\t\t\treturn target.url.indexOf('workbench/workbench.html') > 0 || target.url.indexOf('workbench/workbench-dev.html') > 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tconst main = await mainProfileRequest;\n\t\t\t\t\tconst extHost = await extHostProfileRequest;\n\t\t\t\t\tconst renderer = await rendererProfileRequest;\n\n\t\t\t\t\t// wait for the renderer to delete the marker file\n\t\t\t\t\tawait whenDeleted(filenamePrefix);\n\n\t\t\t\t\t// stop profiling\n\t\t\t\t\tawait main.stop();\n\t\t\t\t\tawait renderer.stop();\n\t\t\t\t\tawait extHost.stop();\n\n\t\t\t\t\t// re-create the marker file to signal that profiling is done\n\t\t\t\t\twriteFileSync(filenamePrefix, '');\n\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('Failed to profile startup. Make sure to quit Code first.');\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst options: SpawnOptions = {\n\t\t\tdetached: true,\n\t\t\tenv\n\t\t};\n\n\t\tif (!args.verbose) {\n\t\t\toptions['stdio'] = 'ignore';\n\t\t}\n\n\t\tlet child: ChildProcess;\n\t\tif (!isMacOSBigSurOrNewer) {\n\t\t\tif (!args.verbose && args.status) {\n\t\t\t\toptions['stdio'] = ['ignore', 'pipe', 'ignore']; // restore ability to see output when --status is used\n\t\t\t}\n\n\t\t\t// We spawn process.execPath directly\n\t\t\tchild = spawn(process.execPath, argv.slice(2), options);\n\t\t} else {\n\t\t\t// On Big Sur, we spawn using the open command to obtain behavior\n\t\t\t// similar to if the app was launched from the dock\n\t\t\t// https://github.com/microsoft/vscode/issues/102975\n\n\t\t\t// The following args are for the open command itself, rather than for VS Code:\n\t\t\t// -n creates a new instance.\n\t\t\t//    Without -n, the open command re-opens the existing instance as-is.\n\t\t\t// -g starts the new instance in the background.\n\t\t\t//    Later, Electron brings the instance to the foreground.\n\t\t\t//    This way, Mac does not automatically try to foreground the new instance, which causes\n\t\t\t//    focusing issues when the new instance only sends data to a previous instance and then closes.\n\t\t\tconst spawnArgs = ['-n', '-g'];\n\t\t\t// -a opens the given application.\n\t\t\tspawnArgs.push('-a', process.execPath); // -a: opens a specific application\n\n\t\t\tif (args.verbose || args.status) {\n\t\t\t\tspawnArgs.push('--wait-apps'); // `open --wait-apps`: blocks until the launched app is closed (even if they were already running)\n\n\t\t\t\t// The open command only allows for redirecting stderr and stdout to files,\n\t\t\t\t// so we make it redirect those to temp files, and then use a logger to\n\t\t\t\t// redirect the file output to the console\n\t\t\t\tfor (const outputType of args.verbose ? ['stdout', 'stderr'] : ['stdout']) {\n\n\t\t\t\t\t// Tmp file to target output to\n\t\t\t\t\tconst tmpName = randomPath(tmpdir(), `code-${outputType}`);\n\t\t\t\t\twriteFileSync(tmpName, '');\n\t\t\t\t\tspawnArgs.push(`--${outputType}`, tmpName);\n\n\t\t\t\t\t// Listener to redirect content to stdout/stderr\n\t\t\t\t\tprocessCallbacks.push(async child => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst stream = outputType === 'stdout' ? process.stdout : process.stderr;\n\n\t\t\t\t\t\t\tconst cts = new CancellationTokenSource();\n\t\t\t\t\t\t\tchild.on('close', () => {\n\t\t\t\t\t\t\t\t// We must dispose the token to stop watching,\n\t\t\t\t\t\t\t\t// but the watcher might still be reading data.\n\t\t\t\t\t\t\t\tsetTimeout(() => cts.dispose(true), 200);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait watchFileContents(tmpName, chunk => stream.write(chunk), () => { /* ignore */ }, cts.token);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tunlinkSync(tmpName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const e in env) {\n\t\t\t\t// Ignore the _ env var, because the open command\n\t\t\t\t// ignores it anyway.\n\t\t\t\t// Pass the rest of the env vars in to fix\n\t\t\t\t// https://github.com/microsoft/vscode/issues/134696.\n\t\t\t\tif (e !== '_') {\n\t\t\t\t\tspawnArgs.push('--env');\n\t\t\t\t\tspawnArgs.push(`${e}=${env[e]}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tspawnArgs.push('--args', ...argv.slice(2)); // pass on our arguments\n\n\t\t\tif (env['VSCODE_DEV']) {\n\t\t\t\t// If we're in development mode, replace the . arg with the\n\t\t\t\t// vscode source arg. Because the OSS app isn't bundled,\n\t\t\t\t// it needs the full vscode source arg to launch properly.\n\t\t\t\tconst curdir = '.';\n\t\t\t\tconst launchDirIndex = spawnArgs.indexOf(curdir);\n\t\t\t\tif (launchDirIndex !== -1) {\n\t\t\t\t\tspawnArgs[launchDirIndex] = resolve(curdir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We already passed over the env variables\n\t\t\t// using the --env flags, so we can leave them out here.\n\t\t\t// Also, we don't need to pass env._, which is different from argv._\n\t\t\tchild = spawn('open', spawnArgs, { ...options, env: {} });\n\t\t}\n\n\t\tawait Promise.all(processCallbacks.map(callback => callback(child)));\n\t}\n}\n\nfunction getAppRoot() {\n\treturn dirname(FileAccess.asFileUri('').fsPath);\n}\n\nfunction eventuallyExit(code: number): void {\n\tsetTimeout(() => process.exit(code), 0);\n}\n\nmain(process.argv)\n\t.then(() => eventuallyExit(0))\n\t.then(null, err => {\n\t\tconsole.error(err.message || err.stack || err);\n\t\teventuallyExit(1);\n\t});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, spawn, SpawnOptions, StdioOptions } from 'child_process';\nimport { chmodSync, existsSync, readFileSync, statSync, truncateSync, unlinkSync } from 'fs';\nimport { homedir, release, tmpdir } from 'os';\nimport type { ProfilingSession, Target } from 'v8-inspect-profiler';\nimport { Event } from '../../base/common/event.js';\nimport { isAbsolute, resolve, join, dirname } from '../../base/common/path.js';\nimport { IProcessEnvironment, isMacintosh, isWindows } from '../../base/common/platform.js';\nimport { randomPort } from '../../base/common/ports.js';\nimport { whenDeleted, writeFileSync } from '../../base/node/pfs.js';\nimport { findFreePort } from '../../base/node/ports.js';\nimport { watchFileContents } from '../../platform/files/node/watcher/nodejs/nodejsWatcherLib.js';\nimport { NativeParsedArgs } from '../../platform/environment/common/argv.js';\nimport { buildHelpMessage, buildStdinMessage, buildVersionMessage, NATIVE_CLI_COMMANDS, OPTIONS } from '../../platform/environment/node/argv.js';\nimport { addArg, parseCLIProcessArgv } from '../../platform/environment/node/argvHelper.js';\nimport { getStdinFilePath, hasStdinWithoutTty, readFromStdin, stdinDataListener } from '../../platform/environment/node/stdin.js';\nimport { createWaitMarkerFileSync } from '../../platform/environment/node/wait.js';\nimport product from '../../platform/product/common/product.js';\nimport { CancellationTokenSource } from '../../base/common/cancellation.js';\nimport { isUNC, randomPath } from '../../base/common/extpath.js';\nimport { Utils } from '../../platform/profiling/common/profiling.js';\nimport { FileAccess } from '../../base/common/network.js';\nimport { cwd } from '../../base/common/process.js';\nimport { addUNCHostToAllowlist } from '../../base/node/unc.js';\nimport { URI } from '../../base/common/uri.js';\nimport { DeferredPromise } from '../../base/common/async.js';\n\nfunction shouldSpawnCliProcess(argv: NativeParsedArgs): boolean {\n\treturn !!argv['install-source']\n\t\t|| !!argv['list-extensions']\n\t\t|| !!argv['install-extension']\n\t\t|| !!argv['uninstall-extension']\n\t\t|| !!argv['update-extensions']\n\t\t|| !!argv['locate-extension']\n\t\t|| !!argv['add-mcp']\n\t\t|| !!argv['telemetry'];\n}\n\nexport async function main(argv: string[]): Promise<void> {\n\tlet args: NativeParsedArgs;\n\n\ttry {\n\t\targs = parseCLIProcessArgv(argv);\n\t} catch (err) {\n\t\tconsole.error(err.message);\n\t\treturn;\n\t}\n\n\tfor (const subcommand of NATIVE_CLI_COMMANDS) {\n\t\tif (args[subcommand]) {\n\t\t\tif (!product.tunnelApplicationName) {\n\t\t\t\tconsole.error(`'${subcommand}' command not supported in ${product.applicationName}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst env: IProcessEnvironment = {\n\t\t\t\t...process.env\n\t\t\t};\n\t\t\t// bootstrap-esm.js determines the electron environment based\n\t\t\t// on the following variable. For the server we need to unset\n\t\t\t// it to prevent importing any electron specific modules.\n\t\t\t// Refs https://github.com/microsoft/vscode/issues/221883\n\t\t\tdelete env['ELECTRON_RUN_AS_NODE'];\n\n\t\t\tconst tunnelArgs = argv.slice(argv.indexOf(subcommand) + 1); // all arguments behind `tunnel`\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tlet tunnelProcess: ChildProcess;\n\t\t\t\tconst stdio: StdioOptions = ['ignore', 'pipe', 'pipe'];\n\t\t\t\tif (process.env['VSCODE_DEV']) {\n\t\t\t\t\ttunnelProcess = spawn('cargo', ['run', '--', subcommand, ...tunnelArgs], { cwd: join(getAppRoot(), 'cli'), stdio, env });\n\t\t\t\t} else {\n\t\t\t\t\tconst appPath = process.platform === 'darwin'\n\t\t\t\t\t\t// ./Contents/MacOS/Electron => ./Contents/Resources/app/bin/code-tunnel-insiders\n\t\t\t\t\t\t? join(dirname(dirname(process.execPath)), 'Resources', 'app')\n\t\t\t\t\t\t: dirname(process.execPath);\n\t\t\t\t\tconst tunnelCommand = join(appPath, 'bin', `${product.tunnelApplicationName}${isWindows ? '.exe' : ''}`);\n\t\t\t\t\ttunnelProcess = spawn(tunnelCommand, [subcommand, ...tunnelArgs], { cwd: cwd(), stdio, env });\n\t\t\t\t}\n\n\t\t\t\ttunnelProcess.stdout!.pipe(process.stdout);\n\t\t\t\ttunnelProcess.stderr!.pipe(process.stderr);\n\t\t\t\ttunnelProcess.on('exit', resolve);\n\t\t\t\ttunnelProcess.on('error', reject);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Help (general)\n\tif (args.help) {\n\t\tconst executable = `${product.applicationName}${isWindows ? '.exe' : ''}`;\n\t\tconsole.log(buildHelpMessage(product.nameLong, executable, product.version, OPTIONS));\n\t}\n\n\t// Help (chat)\n\telse if (args.chat?.help) {\n\t\tconst executable = `${product.applicationName}${isWindows ? '.exe' : ''}`;\n\t\tconsole.log(buildHelpMessage(product.nameLong, executable, product.version, OPTIONS.chat.options, { isChat: true }));\n\t}\n\n\t// Version Info\n\telse if (args.version) {\n\t\tconsole.log(buildVersionMessage(product.version, product.commit));\n\t}\n\n\t// Shell integration\n\telse if (args['locate-shell-integration-path']) {\n\t\tlet file: string;\n\t\tswitch (args['locate-shell-integration-path']) {\n\t\t\t// Usage: `[[ \"$TERM_PROGRAM\" == \"vscode\" ]] && . \"$(code --locate-shell-integration-path bash)\"`\n\t\t\tcase 'bash': file = 'shellIntegration-bash.sh'; break;\n\t\t\t// Usage: `if ($env:TERM_PROGRAM -eq \"vscode\") { . \"$(code --locate-shell-integration-path pwsh)\" }`\n\t\t\tcase 'pwsh': file = 'shellIntegration.ps1'; break;\n\t\t\t// Usage: `[[ \"$TERM_PROGRAM\" == \"vscode\" ]] && . \"$(code --locate-shell-integration-path zsh)\"`\n\t\t\tcase 'zsh': file = 'shellIntegration-rc.zsh'; break;\n\t\t\t// Usage: `string match -q \"$TERM_PROGRAM\" \"vscode\"; and . (code --locate-shell-integration-path fish)`\n\t\t\tcase 'fish': file = 'shellIntegration.fish'; break;\n\t\t\tdefault: throw new Error('Error using --locate-shell-integration-path: Invalid shell type');\n\t\t}\n\t\tconsole.log(join(getAppRoot(), 'out', 'vs', 'workbench', 'contrib', 'terminal', 'common', 'scripts', file));\n\t}\n\n\t// Extensions Management\n\telse if (shouldSpawnCliProcess(args)) {\n\n\t\t// We do not bundle `cliProcessMain.js` into this file because\n\t\t// it is rather large and only needed for very few CLI operations.\n\t\t// This has the downside that we need to know if we run OSS or\n\t\t// built, because our location on disk is different if built.\n\n\t\tlet cliProcessMain: string;\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\tcliProcessMain = './cliProcessMain.js';\n\t\t} else {\n\t\t\tcliProcessMain = './vs/code/node/cliProcessMain.js';\n\t\t}\n\n\t\tconst cli = await import(cliProcessMain);\n\t\tawait cli.main(args);\n\n\t\treturn;\n\t}\n\n\t// Write File\n\telse if (args['file-write']) {\n\t\tconst argsFile = args._[0];\n\t\tif (!argsFile || !isAbsolute(argsFile) || !existsSync(argsFile) || !statSync(argsFile).isFile()) {\n\t\t\tthrow new Error('Using --file-write with invalid arguments.');\n\t\t}\n\n\t\tlet source: string | undefined;\n\t\tlet target: string | undefined;\n\t\ttry {\n\t\t\tconst argsContents: { source: string; target: string } = JSON.parse(readFileSync(argsFile, 'utf8'));\n\t\t\tsource = argsContents.source;\n\t\t\ttarget = argsContents.target;\n\t\t} catch (error) {\n\t\t\tthrow new Error('Using --file-write with invalid arguments.');\n\t\t}\n\n\t\t// Windows: set the paths as allowed UNC paths given\n\t\t// they are explicitly provided by the user as arguments\n\t\tif (isWindows) {\n\t\t\tfor (const path of [source, target]) {\n\t\t\t\tif (typeof path === 'string' && isUNC(path)) {\n\t\t\t\t\taddUNCHostToAllowlist(URI.file(path).authority);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Validate\n\t\tif (\n\t\t\t!source || !target || source === target ||\t\t\t\t// make sure source and target are provided and are not the same\n\t\t\t!isAbsolute(source) || !isAbsolute(target) ||\t\t\t// make sure both source and target are absolute paths\n\t\t\t!existsSync(source) || !statSync(source).isFile() ||\t// make sure source exists as file\n\t\t\t!existsSync(target) || !statSync(target).isFile()\t\t// make sure target exists as file\n\t\t) {\n\t\t\tthrow new Error('Using --file-write with invalid arguments.');\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Check for readonly status and chmod if so if we are told so\n\t\t\tlet targetMode = 0;\n\t\t\tlet restoreMode = false;\n\t\t\tif (args['file-chmod']) {\n\t\t\t\ttargetMode = statSync(target).mode;\n\t\t\t\tif (!(targetMode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\tchmodSync(target, targetMode | 0o200);\n\t\t\t\t\trestoreMode = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Write source to target\n\t\t\tconst data = readFileSync(source);\n\t\t\tif (isWindows) {\n\t\t\t\t// On Windows we use a different strategy of saving the file\n\t\t\t\t// by first truncating the file and then writing with r+ mode.\n\t\t\t\t// This helps to save hidden files on Windows\n\t\t\t\t// (see https://github.com/microsoft/vscode/issues/931) and\n\t\t\t\t// prevent removing alternate data streams\n\t\t\t\t// (see https://github.com/microsoft/vscode/issues/6363)\n\t\t\t\ttruncateSync(target, 0);\n\t\t\t\twriteFileSync(target, data, { flag: 'r+' });\n\t\t\t} else {\n\t\t\t\twriteFileSync(target, data);\n\t\t\t}\n\n\t\t\t// Restore previous mode as needed\n\t\t\tif (restoreMode) {\n\t\t\t\tchmodSync(target, targetMode);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\terror.message = `Error using --file-write: ${error.message}`;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// Just Code\n\telse {\n\t\tconst env: IProcessEnvironment = {\n\t\t\t...process.env,\n\t\t\t'ELECTRON_NO_ATTACH_CONSOLE': '1'\n\t\t};\n\n\t\tdelete env['ELECTRON_RUN_AS_NODE'];\n\n\t\tconst processCallbacks: ((child: ChildProcess) => Promise<void>)[] = [];\n\n\t\tif (args.verbose) {\n\t\t\tenv['ELECTRON_ENABLE_LOGGING'] = '1';\n\t\t}\n\n\t\tif (args.verbose || args.status) {\n\t\t\tprocessCallbacks.push(async child => {\n\t\t\t\tchild.stdout?.on('data', (data: Buffer) => console.log(data.toString('utf8').trim()));\n\t\t\t\tchild.stderr?.on('data', (data: Buffer) => console.log(data.toString('utf8').trim()));\n\n\t\t\t\tawait Event.toPromise(Event.fromNodeEventEmitter(child, 'exit'));\n\t\t\t});\n\t\t}\n\n\t\t// Handle --transient option\n\t\tif (args['transient']) {\n\t\t\tconst tempParentDir = randomPath(tmpdir(), 'vscode');\n\t\t\tconst tempUserDataDir = join(tempParentDir, 'data');\n\t\t\tconst tempExtensionsDir = join(tempParentDir, 'extensions');\n\n\t\t\taddArg(argv, '--user-data-dir', tempUserDataDir);\n\t\t\taddArg(argv, '--extensions-dir', tempExtensionsDir);\n\n\t\t\tconsole.log(`State is temporarily stored. Relaunch this state with: ${product.applicationName} --user-data-dir \"${tempUserDataDir}\" --extensions-dir \"${tempExtensionsDir}\"`);\n\t\t}\n\n\t\tconst hasReadStdinArg = args._.some(arg => arg === '-') || args.chat?._.some(arg => arg === '-');\n\t\tif (hasReadStdinArg) {\n\t\t\t// remove the \"-\" argument when we read from stdin\n\t\t\targs._ = args._.filter(a => a !== '-');\n\t\t\targv = argv.filter(a => a !== '-');\n\t\t}\n\n\t\tlet stdinFilePath: string | undefined;\n\t\tif (hasStdinWithoutTty()) {\n\n\t\t\t// Read from stdin: we require a single \"-\" argument to be passed in order to start reading from\n\t\t\t// stdin. We do this because there is no reliable way to find out if data is piped to stdin. Just\n\t\t\t// checking for stdin being connected to a TTY is not enough (https://github.com/microsoft/vscode/issues/40351)\n\n\t\t\tif (hasReadStdinArg) {\n\t\t\t\tstdinFilePath = getStdinFilePath();\n\n\t\t\t\ttry {\n\t\t\t\t\tconst readFromStdinDone = new DeferredPromise<void>();\n\t\t\t\t\tawait readFromStdin(stdinFilePath, !!args.verbose, () => readFromStdinDone.complete());\n\t\t\t\t\tif (!args.wait) {\n\n\t\t\t\t\t\t// if `--wait` is not provided, we keep this process alive\n\t\t\t\t\t\t// for at least as long as the stdin stream is open to\n\t\t\t\t\t\t// ensure that we read all the data.\n\t\t\t\t\t\t// the downside is that the Code CLI process will then not\n\t\t\t\t\t\t// terminate until stdin is closed, but users can always\n\t\t\t\t\t\t// pass `--wait` to prevent that from happening (this is\n\t\t\t\t\t\t// actually what we enforced until v1.85.x but then was\n\t\t\t\t\t\t// changed to not enforce it anymore).\n\t\t\t\t\t\t// a solution in the future would possibly be to exit, when\n\t\t\t\t\t\t// the Code process exits. this would require some careful\n\t\t\t\t\t\t// solution though in case Code is already running and this\n\t\t\t\t\t\t// is a second instance telling the first instance what to\n\t\t\t\t\t\t// open.\n\n\t\t\t\t\t\tprocessCallbacks.push(() => readFromStdinDone.p);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (args.chat) {\n\t\t\t\t\t\t// Make sure to add tmp file as context to chat\n\t\t\t\t\t\taddArg(argv, '--add-file', stdinFilePath);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Make sure to open tmp file as editor but ignore\n\t\t\t\t\t\t// it in the \"recently open\" list\n\t\t\t\t\t\taddArg(argv, stdinFilePath);\n\t\t\t\t\t\taddArg(argv, '--skip-add-to-recently-opened');\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log(`Reading from stdin via: ${stdinFilePath}`);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(`Failed to create file to read via stdin: ${e.toString()}`);\n\t\t\t\t\tstdinFilePath = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// If the user pipes data via stdin but forgot to add the \"-\" argument, help by printing a message\n\t\t\t\t// if we detect that data flows into via stdin after a certain timeout.\n\t\t\t\tprocessCallbacks.push(_ => stdinDataListener(1000).then(dataReceived => {\n\t\t\t\t\tif (dataReceived) {\n\t\t\t\t\t\tconsole.log(buildStdinMessage(product.applicationName, !!args.chat));\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tconst isMacOSBigSurOrNewer = isMacintosh && release() > '20.0.0';\n\n\t\t// If we are started with --wait create a random temporary file\n\t\t// and pass it over to the starting instance. We can use this file\n\t\t// to wait for it to be deleted to monitor that the edited file\n\t\t// is closed and then exit the waiting process.\n\t\tlet waitMarkerFilePath: string | undefined;\n\t\tif (args.wait) {\n\t\t\twaitMarkerFilePath = createWaitMarkerFileSync(args.verbose);\n\t\t\tif (waitMarkerFilePath) {\n\t\t\t\taddArg(argv, '--waitMarkerFilePath', waitMarkerFilePath);\n\t\t\t}\n\n\t\t\t// When running with --wait, we want to continue running CLI process\n\t\t\t// until either:\n\t\t\t// - the wait marker file has been deleted (e.g. when closing the editor)\n\t\t\t// - the launched process terminates (e.g. due to a crash)\n\t\t\tprocessCallbacks.push(async child => {\n\t\t\t\tlet childExitPromise;\n\t\t\t\tif (isMacOSBigSurOrNewer) {\n\t\t\t\t\t// On Big Sur, we resolve the following promise only when the child,\n\t\t\t\t\t// i.e. the open command, exited with a signal or error. Otherwise, we\n\t\t\t\t\t// wait for the marker file to be deleted or for the child to error.\n\t\t\t\t\tchildExitPromise = new Promise<void>(resolve => {\n\t\t\t\t\t\t// Only resolve this promise if the child (i.e. open) exited with an error\n\t\t\t\t\t\tchild.on('exit', (code, signal) => {\n\t\t\t\t\t\t\tif (code !== 0 || signal) {\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// On other platforms, we listen for exit in case the child exits before the\n\t\t\t\t\t// marker file is deleted.\n\t\t\t\t\tchildExitPromise = Event.toPromise(Event.fromNodeEventEmitter(child, 'exit'));\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\twhenDeleted(waitMarkerFilePath!),\n\t\t\t\t\t\tEvent.toPromise(Event.fromNodeEventEmitter(child, 'error')),\n\t\t\t\t\t\tchildExitPromise\n\t\t\t\t\t]);\n\t\t\t\t} finally {\n\t\t\t\t\tif (stdinFilePath) {\n\t\t\t\t\t\tunlinkSync(stdinFilePath); // Make sure to delete the tmp stdin file if we have any\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// If we have been started with `--prof-startup` we need to find free ports to profile\n\t\t// the main process, the renderer, and the extension host. We also disable v8 cached data\n\t\t// to get better profile traces. Last, we listen on stdout for a signal that tells us to\n\t\t// stop profiling.\n\t\tif (args['prof-startup']) {\n\t\t\tconst profileHost = '127.0.0.1';\n\t\t\tconst portMain = await findFreePort(randomPort(), 10, 3000);\n\t\t\tconst portRenderer = await findFreePort(portMain + 1, 10, 3000);\n\t\t\tconst portExthost = await findFreePort(portRenderer + 1, 10, 3000);\n\n\t\t\t// fail the operation when one of the ports couldn't be acquired.\n\t\t\tif (portMain * portRenderer * portExthost === 0) {\n\t\t\t\tthrow new Error('Failed to find free ports for profiler. Make sure to shutdown all instances of the editor first.');\n\t\t\t}\n\n\t\t\tconst filenamePrefix = randomPath(homedir(), 'prof');\n\n\t\t\taddArg(argv, `--inspect-brk=${profileHost}:${portMain}`);\n\t\t\taddArg(argv, `--remote-debugging-port=${profileHost}:${portRenderer}`);\n\t\t\taddArg(argv, `--inspect-brk-extensions=${profileHost}:${portExthost}`);\n\t\t\taddArg(argv, `--prof-startup-prefix`, filenamePrefix);\n\t\t\taddArg(argv, `--no-cached-data`);\n\n\t\t\twriteFileSync(filenamePrefix, argv.slice(-6).join('|'));\n\n\t\t\tprocessCallbacks.push(async _child => {\n\n\t\t\t\tclass Profiler {\n\t\t\t\t\tstatic async start(name: string, filenamePrefix: string, opts: { port: number; tries?: number; target?: (targets: Target[]) => Target }) {\n\t\t\t\t\t\tconst profiler = await import('v8-inspect-profiler');\n\n\t\t\t\t\t\tlet session: ProfilingSession;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsession = await profiler.startProfiling({ ...opts, host: profileHost });\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tconsole.error(`FAILED to start profiling for '${name}' on port '${opts.port}'`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tasync stop() {\n\t\t\t\t\t\t\t\tif (!session) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet suffix = '';\n\t\t\t\t\t\t\t\tconst result = await session.stop();\n\t\t\t\t\t\t\t\tif (!process.env['VSCODE_DEV']) {\n\t\t\t\t\t\t\t\t\t// when running from a not-development-build we remove\n\t\t\t\t\t\t\t\t\t// absolute filenames because we don't want to reveal anything\n\t\t\t\t\t\t\t\t\t// about users. We also append the `.txt` suffix to make it\n\t\t\t\t\t\t\t\t\t// easier to attach these files to GH issues\n\t\t\t\t\t\t\t\t\tresult.profile = Utils.rewriteAbsolutePaths(result.profile, 'piiRemoved');\n\t\t\t\t\t\t\t\t\tsuffix = '.txt';\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twriteFileSync(`${filenamePrefix}.${name}.cpuprofile${suffix}`, JSON.stringify(result.profile, undefined, 4));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// load and start profiler\n\t\t\t\t\tconst mainProfileRequest = Profiler.start('main', filenamePrefix, { port: portMain });\n\t\t\t\t\tconst extHostProfileRequest = Profiler.start('extHost', filenamePrefix, { port: portExthost, tries: 300 });\n\t\t\t\t\tconst rendererProfileRequest = Profiler.start('renderer', filenamePrefix, {\n\t\t\t\t\t\tport: portRenderer,\n\t\t\t\t\t\ttries: 200,\n\t\t\t\t\t\ttarget: function (targets) {\n\t\t\t\t\t\t\treturn targets.filter(target => {\n\t\t\t\t\t\t\t\tif (!target.webSocketDebuggerUrl) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (target.type === 'page') {\n\t\t\t\t\t\t\t\t\treturn target.url.indexOf('workbench/workbench.html') > 0 || target.url.indexOf('workbench/workbench-dev.html') > 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tconst main = await mainProfileRequest;\n\t\t\t\t\tconst extHost = await extHostProfileRequest;\n\t\t\t\t\tconst renderer = await rendererProfileRequest;\n\n\t\t\t\t\t// wait for the renderer to delete the marker file\n\t\t\t\t\tawait whenDeleted(filenamePrefix);\n\n\t\t\t\t\t// stop profiling\n\t\t\t\t\tawait main.stop();\n\t\t\t\t\tawait renderer.stop();\n\t\t\t\t\tawait extHost.stop();\n\n\t\t\t\t\t// re-create the marker file to signal that profiling is done\n\t\t\t\t\twriteFileSync(filenamePrefix, '');\n\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error('Failed to profile startup. Make sure to quit Code first.');\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst options: SpawnOptions = {\n\t\t\tdetached: true,\n\t\t\tenv\n\t\t};\n\n\t\tif (!args.verbose) {\n\t\t\toptions['stdio'] = 'ignore';\n\t\t}\n\n\t\tlet child: ChildProcess;\n\t\tif (!isMacOSBigSurOrNewer) {\n\t\t\tif (!args.verbose && args.status) {\n\t\t\t\toptions['stdio'] = ['ignore', 'pipe', 'ignore']; // restore ability to see output when --status is used\n\t\t\t}\n\n\t\t\t// We spawn process.execPath directly\n\t\t\tchild = spawn(process.execPath, argv.slice(2), options);\n\t\t} else {\n\t\t\t// On Big Sur, we spawn using the open command to obtain behavior\n\t\t\t// similar to if the app was launched from the dock\n\t\t\t// https://github.com/microsoft/vscode/issues/102975\n\n\t\t\t// The following args are for the open command itself, rather than for VS Code:\n\t\t\t// -n creates a new instance.\n\t\t\t//    Without -n, the open command re-opens the existing instance as-is.\n\t\t\t// -g starts the new instance in the background.\n\t\t\t//    Later, Electron brings the instance to the foreground.\n\t\t\t//    This way, Mac does not automatically try to foreground the new instance, which causes\n\t\t\t//    focusing issues when the new instance only sends data to a previous instance and then closes.\n\t\t\tconst spawnArgs = ['-n', '-g'];\n\t\t\t// -a opens the given application.\n\t\t\tspawnArgs.push('-a', process.execPath); // -a: opens a specific application\n\n\t\t\tif (args.verbose || args.status) {\n\t\t\t\tspawnArgs.push('--wait-apps'); // `open --wait-apps`: blocks until the launched app is closed (even if they were already running)\n\n\t\t\t\t// The open command only allows for redirecting stderr and stdout to files,\n\t\t\t\t// so we make it redirect those to temp files, and then use a logger to\n\t\t\t\t// redirect the file output to the console\n\t\t\t\tfor (const outputType of args.verbose ? ['stdout', 'stderr'] : ['stdout']) {\n\n\t\t\t\t\t// Tmp file to target output to\n\t\t\t\t\tconst tmpName = randomPath(tmpdir(), `code-${outputType}`);\n\t\t\t\t\twriteFileSync(tmpName, '');\n\t\t\t\t\tspawnArgs.push(`--${outputType}`, tmpName);\n\n\t\t\t\t\t// Listener to redirect content to stdout/stderr\n\t\t\t\t\tprocessCallbacks.push(async child => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst stream = outputType === 'stdout' ? process.stdout : process.stderr;\n\n\t\t\t\t\t\t\tconst cts = new CancellationTokenSource();\n\t\t\t\t\t\t\tchild.on('close', () => {\n\t\t\t\t\t\t\t\t// We must dispose the token to stop watching,\n\t\t\t\t\t\t\t\t// but the watcher might still be reading data.\n\t\t\t\t\t\t\t\tsetTimeout(() => cts.dispose(true), 200);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait watchFileContents(tmpName, chunk => stream.write(chunk), () => { /* ignore */ }, cts.token);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tunlinkSync(tmpName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const e in env) {\n\t\t\t\t// Ignore the _ env var, because the open command\n\t\t\t\t// ignores it anyway.\n\t\t\t\t// Pass the rest of the env vars in to fix\n\t\t\t\t// https://github.com/microsoft/vscode/issues/134696.\n\t\t\t\tif (e !== '_') {\n\t\t\t\t\tspawnArgs.push('--env');\n\t\t\t\t\tspawnArgs.push(`${e}=${env[e]}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tspawnArgs.push('--args', ...argv.slice(2)); // pass on our arguments\n\n\t\t\tif (env['VSCODE_DEV']) {\n\t\t\t\t// If we're in development mode, replace the . arg with the\n\t\t\t\t// vscode source arg. Because the OSS app isn't bundled,\n\t\t\t\t// it needs the full vscode source arg to launch properly.\n\t\t\t\tconst curdir = '.';\n\t\t\t\tconst launchDirIndex = spawnArgs.indexOf(curdir);\n\t\t\t\tif (launchDirIndex !== -1) {\n\t\t\t\t\tspawnArgs[launchDirIndex] = resolve(curdir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We already passed over the env variables\n\t\t\t// using the --env flags, so we can leave them out here.\n\t\t\t// Also, we don't need to pass env._, which is different from argv._\n\t\t\tchild = spawn('open', spawnArgs, { ...options, env: {} });\n\t\t}\n\n\t\tawait Promise.all(processCallbacks.map(callback => callback(child)));\n\t}\n}\n\nfunction getAppRoot() {\n\treturn dirname(FileAccess.asFileUri('').fsPath);\n}\n\nfunction eventuallyExit(code: number): void {\n\tsetTimeout(() => process.exit(code), 0);\n}\n\nmain(process.argv)\n\t.then(() => eventuallyExit(0))\n\t.then(null, err => {\n\t\tconsole.error(err.message || err.stack || err);\n\t\teventuallyExit(1);\n\t});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// Delete `VSCODE_CWD` very early. We have seen\n// reports where `code .` would use the wrong\n// current working directory due to our variable\n// somehow escaping to the parent shell\n// (https://github.com/microsoft/vscode/issues/126399)\ndelete process.env['VSCODE_CWD'];\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// Delete `VSCODE_CWD` very early. We have seen\n// reports where `code .` would use the wrong\n// current working directory due to our variable\n// somehow escaping to the parent shell\n// (https://github.com/microsoft/vscode/issues/126399)\ndelete process.env['VSCODE_CWD'];\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'node:path';\nimport * as fs from 'node:fs';\nimport { createRequire } from 'node:module';\nimport type { IProductConfiguration } from './vs/base/common/product.js';\n\nconst require = createRequire(import.meta.url);\nconst isWindows = process.platform === 'win32';\n\n// increase number of stack frames(from 10, https://github.com/v8/v8/wiki/Stack-Trace-API)\nError.stackTraceLimit = 100;\n\nif (!process.env['VSCODE_HANDLES_SIGPIPE']) {\n\t// Workaround for Electron not installing a handler to ignore SIGPIPE\n\t// (https://github.com/electron/electron/issues/13254)\n\tlet didLogAboutSIGPIPE = false;\n\tprocess.on('SIGPIPE', () => {\n\t\t// See https://github.com/microsoft/vscode-remote-release/issues/6543\n\t\t// In certain situations, the console itself can be in a broken pipe state\n\t\t// so logging SIGPIPE to the console will cause an infinite async loop\n\t\tif (!didLogAboutSIGPIPE) {\n\t\t\tdidLogAboutSIGPIPE = true;\n\t\t\tconsole.error(new Error(`Unexpected SIGPIPE`));\n\t\t}\n\t});\n}\n\n// Setup current working directory in all our node & electron processes\n// - Windows: call `process.chdir()` to always set application folder as cwd\n// -  all OS: store the `process.cwd()` inside `VSCODE_CWD` for consistent lookups\nfunction setupCurrentWorkingDirectory(): void {\n\ttry {\n\n\t\t// Store the `process.cwd()` inside `VSCODE_CWD`\n\t\t// for consistent lookups, but make sure to only\n\t\t// do this once unless defined already from e.g.\n\t\t// a parent process.\n\t\tif (typeof process.env['VSCODE_CWD'] !== 'string') {\n\t\t\tprocess.env['VSCODE_CWD'] = process.cwd();\n\t\t}\n\n\t\t// Windows: always set application folder as current working dir\n\t\tif (process.platform === 'win32') {\n\t\t\tprocess.chdir(path.dirname(process.execPath));\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err);\n\t}\n}\n\nsetupCurrentWorkingDirectory();\n\n/**\n * Add support for redirecting the loading of node modules\n *\n * Note: only applies when running out of sources.\n */\nexport function devInjectNodeModuleLookupPath(injectPath: string): void {\n\tif (!process.env['VSCODE_DEV']) {\n\t\treturn; // only applies running out of sources\n\t}\n\n\tif (!injectPath) {\n\t\tthrow new Error('Missing injectPath');\n\t}\n\n\t// register a loader hook\n\tconst Module = require('node:module');\n\tModule.register('./bootstrap-import.js', { parentURL: import.meta.url, data: injectPath });\n}\n\nexport function removeGlobalNodeJsModuleLookupPaths(): void {\n\tif (typeof process?.versions?.electron === 'string') {\n\t\treturn; // Electron disables global search paths in https://github.com/electron/electron/blob/3186c2f0efa92d275dc3d57b5a14a60ed3846b0e/shell/common/node_bindings.cc#L653\n\t}\n\n\tconst Module = require('module');\n\tconst globalPaths = Module.globalPaths;\n\n\tconst originalResolveLookupPaths = Module._resolveLookupPaths;\n\n\tModule._resolveLookupPaths = function (moduleName: string, parent: unknown): string[] {\n\t\tconst paths = originalResolveLookupPaths(moduleName, parent);\n\t\tif (Array.isArray(paths)) {\n\t\t\tlet commonSuffixLength = 0;\n\t\t\twhile (commonSuffixLength < paths.length && paths[paths.length - 1 - commonSuffixLength] === globalPaths[globalPaths.length - 1 - commonSuffixLength]) {\n\t\t\t\tcommonSuffixLength++;\n\t\t\t}\n\n\t\t\treturn paths.slice(0, paths.length - commonSuffixLength);\n\t\t}\n\n\t\treturn paths;\n\t};\n\n\tconst originalNodeModulePaths = Module._nodeModulePaths;\n\tModule._nodeModulePaths = function (from: string): string[] {\n\t\tlet paths: string[] = originalNodeModulePaths(from);\n\t\tif (!isWindows) {\n\t\t\treturn paths;\n\t\t}\n\n\t\t// On Windows, remove drive(s) and users' home directory from search paths,\n\t\t// UNLESS 'from' is explicitly set to one of those.\n\t\tconst isDrive = (p: string) => p.length >= 3 && p.endsWith(':\\\\');\n\n\t\tif (!isDrive(from)) {\n\t\t\tpaths = paths.filter(p => !isDrive(path.dirname(p)));\n\t\t}\n\n\t\tif (process.env.HOMEDRIVE && process.env.HOMEPATH) {\n\t\t\tconst userDir = path.dirname(path.join(process.env.HOMEDRIVE, process.env.HOMEPATH));\n\n\t\t\tconst isUsersDir = (p: string) => path.relative(p, userDir).length === 0;\n\n\t\t\t// Check if 'from' is the same as 'userDir'\n\t\t\tif (!isUsersDir(from)) {\n\t\t\t\tpaths = paths.filter(p => !isUsersDir(path.dirname(p)));\n\t\t\t}\n\t\t}\n\n\t\treturn paths;\n\t};\n}\n\n/**\n * Helper to enable portable mode.\n */\nexport function configurePortable(product: Partial<IProductConfiguration>): { portableDataPath: string; isPortable: boolean } {\n\tconst appRoot = path.dirname(import.meta.dirname);\n\n\tfunction getApplicationPath(): string {\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\treturn appRoot;\n\t\t}\n\n\t\tif (process.platform === 'darwin') {\n\t\t\treturn path.dirname(path.dirname(path.dirname(appRoot)));\n\t\t}\n\n\t\treturn path.dirname(path.dirname(appRoot));\n\t}\n\n\tfunction getPortableDataPath(): string {\n\t\tif (process.env['VSCODE_PORTABLE']) {\n\t\t\treturn process.env['VSCODE_PORTABLE'];\n\t\t}\n\n\t\tif (process.platform === 'win32' || process.platform === 'linux') {\n\t\t\treturn path.join(getApplicationPath(), 'data');\n\t\t}\n\n\t\tconst portableDataName = product.portable || `${product.applicationName}-portable-data`;\n\t\treturn path.join(path.dirname(getApplicationPath()), portableDataName);\n\t}\n\n\tconst portableDataPath = getPortableDataPath();\n\tconst isPortable = !('target' in product) && fs.existsSync(portableDataPath);\n\tconst portableTempPath = path.join(portableDataPath, 'tmp');\n\tconst isTempPortable = isPortable && fs.existsSync(portableTempPath);\n\n\tif (isPortable) {\n\t\tprocess.env['VSCODE_PORTABLE'] = portableDataPath;\n\t} else {\n\t\tdelete process.env['VSCODE_PORTABLE'];\n\t}\n\n\tif (isTempPortable) {\n\t\tif (process.platform === 'win32') {\n\t\t\tprocess.env['TMP'] = portableTempPath;\n\t\t\tprocess.env['TEMP'] = portableTempPath;\n\t\t} else {\n\t\t\tprocess.env['TMPDIR'] = portableTempPath;\n\t\t}\n\t}\n\n\treturn {\n\t\tportableDataPath,\n\t\tisPortable\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'node:path';\nimport * as fs from 'node:fs';\nimport { createRequire } from 'node:module';\nimport type { IProductConfiguration } from './vs/base/common/product.js';\n\nconst require = createRequire(import.meta.url);\nconst isWindows = process.platform === 'win32';\n\n// increase number of stack frames(from 10, https://github.com/v8/v8/wiki/Stack-Trace-API)\nError.stackTraceLimit = 100;\n\nif (!process.env['VSCODE_HANDLES_SIGPIPE']) {\n\t// Workaround for Electron not installing a handler to ignore SIGPIPE\n\t// (https://github.com/electron/electron/issues/13254)\n\tlet didLogAboutSIGPIPE = false;\n\tprocess.on('SIGPIPE', () => {\n\t\t// See https://github.com/microsoft/vscode-remote-release/issues/6543\n\t\t// In certain situations, the console itself can be in a broken pipe state\n\t\t// so logging SIGPIPE to the console will cause an infinite async loop\n\t\tif (!didLogAboutSIGPIPE) {\n\t\t\tdidLogAboutSIGPIPE = true;\n\t\t\tconsole.error(new Error(`Unexpected SIGPIPE`));\n\t\t}\n\t});\n}\n\n// Setup current working directory in all our node & electron processes\n// - Windows: call `process.chdir()` to always set application folder as cwd\n// -  all OS: store the `process.cwd()` inside `VSCODE_CWD` for consistent lookups\nfunction setupCurrentWorkingDirectory(): void {\n\ttry {\n\n\t\t// Store the `process.cwd()` inside `VSCODE_CWD`\n\t\t// for consistent lookups, but make sure to only\n\t\t// do this once unless defined already from e.g.\n\t\t// a parent process.\n\t\tif (typeof process.env['VSCODE_CWD'] !== 'string') {\n\t\t\tprocess.env['VSCODE_CWD'] = process.cwd();\n\t\t}\n\n\t\t// Windows: always set application folder as current working dir\n\t\tif (process.platform === 'win32') {\n\t\t\tprocess.chdir(path.dirname(process.execPath));\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err);\n\t}\n}\n\nsetupCurrentWorkingDirectory();\n\n/**\n * Add support for redirecting the loading of node modules\n *\n * Note: only applies when running out of sources.\n */\nexport function devInjectNodeModuleLookupPath(injectPath: string): void {\n\tif (!process.env['VSCODE_DEV']) {\n\t\treturn; // only applies running out of sources\n\t}\n\n\tif (!injectPath) {\n\t\tthrow new Error('Missing injectPath');\n\t}\n\n\t// register a loader hook\n\tconst Module = require('node:module');\n\tModule.register('./bootstrap-import.js', { parentURL: import.meta.url, data: injectPath });\n}\n\nexport function removeGlobalNodeJsModuleLookupPaths(): void {\n\tif (typeof process?.versions?.electron === 'string') {\n\t\treturn; // Electron disables global search paths in https://github.com/electron/electron/blob/3186c2f0efa92d275dc3d57b5a14a60ed3846b0e/shell/common/node_bindings.cc#L653\n\t}\n\n\tconst Module = require('module');\n\tconst globalPaths = Module.globalPaths;\n\n\tconst originalResolveLookupPaths = Module._resolveLookupPaths;\n\n\tModule._resolveLookupPaths = function (moduleName: string, parent: unknown): string[] {\n\t\tconst paths = originalResolveLookupPaths(moduleName, parent);\n\t\tif (Array.isArray(paths)) {\n\t\t\tlet commonSuffixLength = 0;\n\t\t\twhile (commonSuffixLength < paths.length && paths[paths.length - 1 - commonSuffixLength] === globalPaths[globalPaths.length - 1 - commonSuffixLength]) {\n\t\t\t\tcommonSuffixLength++;\n\t\t\t}\n\n\t\t\treturn paths.slice(0, paths.length - commonSuffixLength);\n\t\t}\n\n\t\treturn paths;\n\t};\n\n\tconst originalNodeModulePaths = Module._nodeModulePaths;\n\tModule._nodeModulePaths = function (from: string): string[] {\n\t\tlet paths: string[] = originalNodeModulePaths(from);\n\t\tif (!isWindows) {\n\t\t\treturn paths;\n\t\t}\n\n\t\t// On Windows, remove drive(s) and users' home directory from search paths,\n\t\t// UNLESS 'from' is explicitly set to one of those.\n\t\tconst isDrive = (p: string) => p.length >= 3 && p.endsWith(':\\\\');\n\n\t\tif (!isDrive(from)) {\n\t\t\tpaths = paths.filter(p => !isDrive(path.dirname(p)));\n\t\t}\n\n\t\tif (process.env.HOMEDRIVE && process.env.HOMEPATH) {\n\t\t\tconst userDir = path.dirname(path.join(process.env.HOMEDRIVE, process.env.HOMEPATH));\n\n\t\t\tconst isUsersDir = (p: string) => path.relative(p, userDir).length === 0;\n\n\t\t\t// Check if 'from' is the same as 'userDir'\n\t\t\tif (!isUsersDir(from)) {\n\t\t\t\tpaths = paths.filter(p => !isUsersDir(path.dirname(p)));\n\t\t\t}\n\t\t}\n\n\t\treturn paths;\n\t};\n}\n\n/**\n * Helper to enable portable mode.\n */\nexport function configurePortable(product: Partial<IProductConfiguration>): { portableDataPath: string; isPortable: boolean } {\n\tconst appRoot = path.dirname(import.meta.dirname);\n\n\tfunction getApplicationPath(): string {\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\treturn appRoot;\n\t\t}\n\n\t\tif (process.platform === 'darwin') {\n\t\t\treturn path.dirname(path.dirname(path.dirname(appRoot)));\n\t\t}\n\n\t\treturn path.dirname(path.dirname(appRoot));\n\t}\n\n\tfunction getPortableDataPath(): string {\n\t\tif (process.env['VSCODE_PORTABLE']) {\n\t\t\treturn process.env['VSCODE_PORTABLE'];\n\t\t}\n\n\t\tif (process.platform === 'win32' || process.platform === 'linux') {\n\t\t\treturn path.join(getApplicationPath(), 'data');\n\t\t}\n\n\t\tconst portableDataName = product.portable || `${product.applicationName}-portable-data`;\n\t\treturn path.join(path.dirname(getApplicationPath()), portableDataName);\n\t}\n\n\tconst portableDataPath = getPortableDataPath();\n\tconst isPortable = !('target' in product) && fs.existsSync(portableDataPath);\n\tconst portableTempPath = path.join(portableDataPath, 'tmp');\n\tconst isTempPortable = isPortable && fs.existsSync(portableTempPath);\n\n\tif (isPortable) {\n\t\tprocess.env['VSCODE_PORTABLE'] = portableDataPath;\n\t} else {\n\t\tdelete process.env['VSCODE_PORTABLE'];\n\t}\n\n\tif (isTempPortable) {\n\t\tif (process.platform === 'win32') {\n\t\t\tprocess.env['TMP'] = portableTempPath;\n\t\t\tprocess.env['TEMP'] = portableTempPath;\n\t\t} else {\n\t\t\tprocess.env['TMPDIR'] = portableTempPath;\n\t\t}\n\t}\n\n\treturn {\n\t\tportableDataPath,\n\t\tisPortable\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'node:fs';\nimport { register } from 'node:module';\nimport { product, pkg } from './bootstrap-meta.js';\nimport './bootstrap-node.js';\nimport * as performance from './vs/base/common/performance.js';\nimport { INLSConfiguration } from './vs/nls.js';\n\n// Install a hook to module resolution to map 'fs' to 'original-fs'\nif (process.env['ELECTRON_RUN_AS_NODE'] || process.versions['electron']) {\n\tconst jsCode = `\n\texport async function resolve(specifier, context, nextResolve) {\n\t\tif (specifier === 'fs') {\n\t\t\treturn {\n\t\t\t\tformat: 'builtin',\n\t\t\t\tshortCircuit: true,\n\t\t\t\turl: 'node:original-fs'\n\t\t\t};\n\t\t}\n\n\t\t// Defer to the next hook in the chain, which would be the\n\t\t// Node.js default resolve if this is the last user-specified loader.\n\t\treturn nextResolve(specifier, context);\n\t}`;\n\tregister(`data:text/javascript;base64,${Buffer.from(jsCode).toString('base64')}`, import.meta.url);\n}\n\n// Prepare globals that are needed for running\nglobalThis._VSCODE_PRODUCT_JSON = { ...product };\nglobalThis._VSCODE_PACKAGE_JSON = { ...pkg };\nglobalThis._VSCODE_FILE_ROOT = import.meta.dirname;\n\n//#region NLS helpers\n\nlet setupNLSResult: Promise<INLSConfiguration | undefined> | undefined = undefined;\n\nfunction setupNLS(): Promise<INLSConfiguration | undefined> {\n\tif (!setupNLSResult) {\n\t\tsetupNLSResult = doSetupNLS();\n\t}\n\n\treturn setupNLSResult;\n}\n\nasync function doSetupNLS(): Promise<INLSConfiguration | undefined> {\n\tperformance.mark('code/willLoadNls');\n\n\tlet nlsConfig: INLSConfiguration | undefined = undefined;\n\n\tlet messagesFile: string | undefined;\n\tif (process.env['VSCODE_NLS_CONFIG']) {\n\t\ttry {\n\t\t\tnlsConfig = JSON.parse(process.env['VSCODE_NLS_CONFIG']);\n\t\t\tif (nlsConfig?.languagePack?.messagesFile) {\n\t\t\t\tmessagesFile = nlsConfig.languagePack.messagesFile;\n\t\t\t} else if (nlsConfig?.defaultMessagesFile) {\n\t\t\t\tmessagesFile = nlsConfig.defaultMessagesFile;\n\t\t\t}\n\n\t\t\tglobalThis._VSCODE_NLS_LANGUAGE = nlsConfig?.resolvedLanguage;\n\t\t} catch (e) {\n\t\t\tconsole.error(`Error reading VSCODE_NLS_CONFIG from environment: ${e}`);\n\t\t}\n\t}\n\n\tif (\n\t\tprocess.env['VSCODE_DEV'] ||\t// no NLS support in dev mode\n\t\t!messagesFile\t\t\t\t\t// no NLS messages file\n\t) {\n\t\treturn undefined;\n\t}\n\n\ttry {\n\t\tglobalThis._VSCODE_NLS_MESSAGES = JSON.parse((await fs.promises.readFile(messagesFile)).toString());\n\t} catch (error) {\n\t\tconsole.error(`Error reading NLS messages file ${messagesFile}: ${error}`);\n\n\t\t// Mark as corrupt: this will re-create the language pack cache next startup\n\t\tif (nlsConfig?.languagePack?.corruptMarkerFile) {\n\t\t\ttry {\n\t\t\t\tawait fs.promises.writeFile(nlsConfig.languagePack.corruptMarkerFile, 'corrupted');\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Error writing corrupted NLS marker file: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Fallback to the default message file to ensure english translation at least\n\t\tif (nlsConfig?.defaultMessagesFile && nlsConfig.defaultMessagesFile !== messagesFile) {\n\t\t\ttry {\n\t\t\t\tglobalThis._VSCODE_NLS_MESSAGES = JSON.parse((await fs.promises.readFile(nlsConfig.defaultMessagesFile)).toString());\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Error reading default NLS messages file ${nlsConfig.defaultMessagesFile}: ${error}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tperformance.mark('code/didLoadNls');\n\n\treturn nlsConfig;\n}\n\n//#endregion\n\nexport async function bootstrapESM(): Promise<void> {\n\n\t// NLS\n\tawait setupNLS();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'node:fs';\nimport { register } from 'node:module';\nimport { product, pkg } from './bootstrap-meta.js';\nimport './bootstrap-node.js';\nimport * as performance from './vs/base/common/performance.js';\nimport { INLSConfiguration } from './vs/nls.js';\n\n// Install a hook to module resolution to map 'fs' to 'original-fs'\nif (process.env['ELECTRON_RUN_AS_NODE'] || process.versions['electron']) {\n\tconst jsCode = `\n\texport async function resolve(specifier, context, nextResolve) {\n\t\tif (specifier === 'fs') {\n\t\t\treturn {\n\t\t\t\tformat: 'builtin',\n\t\t\t\tshortCircuit: true,\n\t\t\t\turl: 'node:original-fs'\n\t\t\t};\n\t\t}\n\n\t\t// Defer to the next hook in the chain, which would be the\n\t\t// Node.js default resolve if this is the last user-specified loader.\n\t\treturn nextResolve(specifier, context);\n\t}`;\n\tregister(`data:text/javascript;base64,${Buffer.from(jsCode).toString('base64')}`, import.meta.url);\n}\n\n// Prepare globals that are needed for running\nglobalThis._VSCODE_PRODUCT_JSON = { ...product };\nglobalThis._VSCODE_PACKAGE_JSON = { ...pkg };\nglobalThis._VSCODE_FILE_ROOT = import.meta.dirname;\n\n//#region NLS helpers\n\nlet setupNLSResult: Promise<INLSConfiguration | undefined> | undefined = undefined;\n\nfunction setupNLS(): Promise<INLSConfiguration | undefined> {\n\tif (!setupNLSResult) {\n\t\tsetupNLSResult = doSetupNLS();\n\t}\n\n\treturn setupNLSResult;\n}\n\nasync function doSetupNLS(): Promise<INLSConfiguration | undefined> {\n\tperformance.mark('code/willLoadNls');\n\n\tlet nlsConfig: INLSConfiguration | undefined = undefined;\n\n\tlet messagesFile: string | undefined;\n\tif (process.env['VSCODE_NLS_CONFIG']) {\n\t\ttry {\n\t\t\tnlsConfig = JSON.parse(process.env['VSCODE_NLS_CONFIG']);\n\t\t\tif (nlsConfig?.languagePack?.messagesFile) {\n\t\t\t\tmessagesFile = nlsConfig.languagePack.messagesFile;\n\t\t\t} else if (nlsConfig?.defaultMessagesFile) {\n\t\t\t\tmessagesFile = nlsConfig.defaultMessagesFile;\n\t\t\t}\n\n\t\t\tglobalThis._VSCODE_NLS_LANGUAGE = nlsConfig?.resolvedLanguage;\n\t\t} catch (e) {\n\t\t\tconsole.error(`Error reading VSCODE_NLS_CONFIG from environment: ${e}`);\n\t\t}\n\t}\n\n\tif (\n\t\tprocess.env['VSCODE_DEV'] ||\t// no NLS support in dev mode\n\t\t!messagesFile\t\t\t\t\t// no NLS messages file\n\t) {\n\t\treturn undefined;\n\t}\n\n\ttry {\n\t\tglobalThis._VSCODE_NLS_MESSAGES = JSON.parse((await fs.promises.readFile(messagesFile)).toString());\n\t} catch (error) {\n\t\tconsole.error(`Error reading NLS messages file ${messagesFile}: ${error}`);\n\n\t\t// Mark as corrupt: this will re-create the language pack cache next startup\n\t\tif (nlsConfig?.languagePack?.corruptMarkerFile) {\n\t\t\ttry {\n\t\t\t\tawait fs.promises.writeFile(nlsConfig.languagePack.corruptMarkerFile, 'corrupted');\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Error writing corrupted NLS marker file: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Fallback to the default message file to ensure english translation at least\n\t\tif (nlsConfig?.defaultMessagesFile && nlsConfig.defaultMessagesFile !== messagesFile) {\n\t\t\ttry {\n\t\t\t\tglobalThis._VSCODE_NLS_MESSAGES = JSON.parse((await fs.promises.readFile(nlsConfig.defaultMessagesFile)).toString());\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Error reading default NLS messages file ${nlsConfig.defaultMessagesFile}: ${error}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tperformance.mark('code/didLoadNls');\n\n\treturn nlsConfig;\n}\n\n//#endregion\n\nexport async function bootstrapESM(): Promise<void> {\n\n\t// NLS\n\tawait setupNLS();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createRequire } from 'node:module';\nimport type { IProductConfiguration } from './vs/base/common/product.js';\n\nconst require = createRequire(import.meta.url);\n\nlet productObj: Partial<IProductConfiguration> & { BUILD_INSERT_PRODUCT_CONFIGURATION?: string } = { BUILD_INSERT_PRODUCT_CONFIGURATION: 'BUILD_INSERT_PRODUCT_CONFIGURATION' }; // DO NOT MODIFY, PATCHED DURING BUILD\nif (productObj['BUILD_INSERT_PRODUCT_CONFIGURATION']) {\n\tproductObj = require('../product.json'); // Running out of sources\n}\n\nlet pkgObj = { BUILD_INSERT_PACKAGE_CONFIGURATION: 'BUILD_INSERT_PACKAGE_CONFIGURATION' }; // DO NOT MODIFY, PATCHED DURING BUILD\nif (pkgObj['BUILD_INSERT_PACKAGE_CONFIGURATION']) {\n\tpkgObj = require('../package.json'); // Running out of sources\n}\n\nlet productOverridesObj = {};\nif (process.env['VSCODE_DEV']) {\n\ttry {\n\t\tproductOverridesObj = require('../product.overrides.json');\n\t\tproductObj = Object.assign(productObj, productOverridesObj);\n\t} catch (error) { /* ignore */ }\n}\n\nexport const product = productObj;\nexport const pkg = pkgObj;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createRequire } from 'node:module';\nimport type { IProductConfiguration } from './vs/base/common/product.js';\n\nconst require = createRequire(import.meta.url);\n\nlet productObj: Partial<IProductConfiguration> & { BUILD_INSERT_PRODUCT_CONFIGURATION?: string } = { BUILD_INSERT_PRODUCT_CONFIGURATION: 'BUILD_INSERT_PRODUCT_CONFIGURATION' }; // DO NOT MODIFY, PATCHED DURING BUILD\nif (productObj['BUILD_INSERT_PRODUCT_CONFIGURATION']) {\n\tproductObj = require('../product.json'); // Running out of sources\n}\n\nlet pkgObj = { BUILD_INSERT_PACKAGE_CONFIGURATION: 'BUILD_INSERT_PACKAGE_CONFIGURATION' }; // DO NOT MODIFY, PATCHED DURING BUILD\nif (pkgObj['BUILD_INSERT_PACKAGE_CONFIGURATION']) {\n\tpkgObj = require('../package.json'); // Running out of sources\n}\n\nlet productOverridesObj = {};\nif (process.env['VSCODE_DEV']) {\n\ttry {\n\t\tproductOverridesObj = require('../product.overrides.json');\n\t\tproductObj = Object.assign(productObj, productOverridesObj);\n\t} catch (error) { /* ignore */ }\n}\n\nexport const product = productObj;\nexport const pkg = pkgObj;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { INodeProcess } from './platform.js';\n\nfunction _definePolyfillMarks(timeOrigin?: number) {\n\tconst _data: [string?, number?] = [];\n\tif (typeof timeOrigin === 'number') {\n\t\t_data.push('code/timeOrigin', timeOrigin);\n\t}\n\n\tfunction mark(name: string, markOptions?: { startTime?: number }) {\n\t\t_data.push(name, markOptions?.startTime ?? Date.now());\n\t}\n\tfunction getMarks() {\n\t\tconst result = [];\n\t\tfor (let i = 0; i < _data.length; i += 2) {\n\t\t\tresult.push({\n\t\t\t\tname: _data[i],\n\t\t\t\tstartTime: _data[i + 1],\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\treturn { mark, getMarks };\n}\n\ndeclare const process: INodeProcess;\n\ninterface IPerformanceEntry {\n\treadonly name: string;\n\treadonly startTime: number;\n}\n\ninterface IPerformanceTiming {\n\treadonly navigationStart?: number;\n\treadonly redirectStart?: number;\n\treadonly fetchStart?: number;\n}\n\ninterface IPerformance {\n\tmark(name: string, markOptions?: { startTime?: number }): void;\n\tgetEntriesByType(type: string): IPerformanceEntry[];\n\treadonly timeOrigin: number;\n\treadonly timing: IPerformanceTiming;\n\treadonly nodeTiming?: any;\n}\n\ndeclare const performance: IPerformance;\n\nfunction _define() {\n\n\t// Identify browser environment when following property is not present\n\t// https://nodejs.org/dist/latest-v16.x/docs/api/perf_hooks.html#performancenodetiming\n\t// @ts-ignore\n\tif (typeof performance === 'object' && typeof performance.mark === 'function' && !performance.nodeTiming) {\n\t\t// in a browser context, reuse performance-util\n\n\t\tif (typeof performance.timeOrigin !== 'number' && !performance.timing) {\n\t\t\t// safari & webworker: because there is no timeOrigin and no workaround\n\t\t\t// we use the `Date.now`-based polyfill.\n\t\t\treturn _definePolyfillMarks();\n\n\t\t} else {\n\t\t\t// use \"native\" performance for mark and getMarks\n\t\t\treturn {\n\t\t\t\tmark(name: string, markOptions?: { startTime?: number }) {\n\t\t\t\t\tperformance.mark(name, markOptions);\n\t\t\t\t},\n\t\t\t\tgetMarks() {\n\t\t\t\t\tlet timeOrigin = performance.timeOrigin;\n\t\t\t\t\tif (typeof timeOrigin !== 'number') {\n\t\t\t\t\t\t// safari: there is no timerOrigin but in renderers there is the timing-property\n\t\t\t\t\t\t// see https://bugs.webkit.org/show_bug.cgi?id=174862\n\t\t\t\t\t\ttimeOrigin = (performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart) ?? 0;\n\t\t\t\t\t}\n\t\t\t\t\tconst result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];\n\t\t\t\t\tfor (const entry of performance.getEntriesByType('mark')) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\tname: entry.name,\n\t\t\t\t\t\t\tstartTime: Math.round(timeOrigin + entry.startTime)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t} else if (typeof process === 'object') {\n\t\t// node.js: use the normal polyfill but add the timeOrigin\n\t\t// from the node perf_hooks API as very first mark\n\t\tconst timeOrigin = performance?.timeOrigin;\n\t\treturn _definePolyfillMarks(timeOrigin);\n\n\t} else {\n\t\t// unknown environment\n\t\tconsole.trace('perf-util loaded in UNKNOWN environment');\n\t\treturn _definePolyfillMarks();\n\t}\n}\n\nfunction _factory(sharedObj: any) {\n\tif (!sharedObj.MonacoPerformanceMarks) {\n\t\tsharedObj.MonacoPerformanceMarks = _define();\n\t}\n\treturn sharedObj.MonacoPerformanceMarks;\n}\n\nconst perf = _factory(globalThis);\n\nexport const mark: (name: string, markOptions?: { startTime?: number }) => void = perf.mark;\n\nexport interface PerformanceMark {\n\treadonly name: string;\n\treadonly startTime: number;\n}\n\n/**\n * Returns all marks, sorted by `startTime`.\n */\nexport const getMarks: () => PerformanceMark[] = perf.getMarks;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { INodeProcess } from './platform.js';\n\nfunction _definePolyfillMarks(timeOrigin?: number) {\n\tconst _data: [string?, number?] = [];\n\tif (typeof timeOrigin === 'number') {\n\t\t_data.push('code/timeOrigin', timeOrigin);\n\t}\n\n\tfunction mark(name: string, markOptions?: { startTime?: number }) {\n\t\t_data.push(name, markOptions?.startTime ?? Date.now());\n\t}\n\tfunction getMarks() {\n\t\tconst result = [];\n\t\tfor (let i = 0; i < _data.length; i += 2) {\n\t\t\tresult.push({\n\t\t\t\tname: _data[i],\n\t\t\t\tstartTime: _data[i + 1],\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\treturn { mark, getMarks };\n}\n\ndeclare const process: INodeProcess;\n\ninterface IPerformanceEntry {\n\treadonly name: string;\n\treadonly startTime: number;\n}\n\ninterface IPerformanceTiming {\n\treadonly navigationStart?: number;\n\treadonly redirectStart?: number;\n\treadonly fetchStart?: number;\n}\n\ninterface IPerformance {\n\tmark(name: string, markOptions?: { startTime?: number }): void;\n\tgetEntriesByType(type: string): IPerformanceEntry[];\n\treadonly timeOrigin: number;\n\treadonly timing: IPerformanceTiming;\n\treadonly nodeTiming?: any;\n}\n\ndeclare const performance: IPerformance;\n\nfunction _define() {\n\n\t// Identify browser environment when following property is not present\n\t// https://nodejs.org/dist/latest-v16.x/docs/api/perf_hooks.html#performancenodetiming\n\t// @ts-ignore\n\tif (typeof performance === 'object' && typeof performance.mark === 'function' && !performance.nodeTiming) {\n\t\t// in a browser context, reuse performance-util\n\n\t\tif (typeof performance.timeOrigin !== 'number' && !performance.timing) {\n\t\t\t// safari & webworker: because there is no timeOrigin and no workaround\n\t\t\t// we use the `Date.now`-based polyfill.\n\t\t\treturn _definePolyfillMarks();\n\n\t\t} else {\n\t\t\t// use \"native\" performance for mark and getMarks\n\t\t\treturn {\n\t\t\t\tmark(name: string, markOptions?: { startTime?: number }) {\n\t\t\t\t\tperformance.mark(name, markOptions);\n\t\t\t\t},\n\t\t\t\tgetMarks() {\n\t\t\t\t\tlet timeOrigin = performance.timeOrigin;\n\t\t\t\t\tif (typeof timeOrigin !== 'number') {\n\t\t\t\t\t\t// safari: there is no timerOrigin but in renderers there is the timing-property\n\t\t\t\t\t\t// see https://bugs.webkit.org/show_bug.cgi?id=174862\n\t\t\t\t\t\ttimeOrigin = (performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart) ?? 0;\n\t\t\t\t\t}\n\t\t\t\t\tconst result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];\n\t\t\t\t\tfor (const entry of performance.getEntriesByType('mark')) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\tname: entry.name,\n\t\t\t\t\t\t\tstartTime: Math.round(timeOrigin + entry.startTime)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t} else if (typeof process === 'object') {\n\t\t// node.js: use the normal polyfill but add the timeOrigin\n\t\t// from the node perf_hooks API as very first mark\n\t\tconst timeOrigin = performance?.timeOrigin;\n\t\treturn _definePolyfillMarks(timeOrigin);\n\n\t} else {\n\t\t// unknown environment\n\t\tconsole.trace('perf-util loaded in UNKNOWN environment');\n\t\treturn _definePolyfillMarks();\n\t}\n}\n\nfunction _factory(sharedObj: any) {\n\tif (!sharedObj.MonacoPerformanceMarks) {\n\t\tsharedObj.MonacoPerformanceMarks = _define();\n\t}\n\treturn sharedObj.MonacoPerformanceMarks;\n}\n\nconst perf = _factory(globalThis);\n\nexport const mark: (name: string, markOptions?: { startTime?: number }) => void = perf.mark;\n\nexport interface PerformanceMark {\n\treadonly name: string;\n\treadonly startTime: number;\n}\n\n/**\n * Returns all marks, sorted by `startTime`.\n */\nexport const getMarks: () => PerformanceMark[] = perf.getMarks;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { join } from '../common/path.js';\nimport { promises } from 'fs';\nimport { mark } from '../common/performance.js';\nimport { ILanguagePacks, INLSConfiguration } from '../../nls.js';\nimport { Promises } from './pfs.js';\n\nexport interface IResolveNLSConfigurationContext {\n\n\t/**\n\t * Location where `nls.messages.json` and `nls.keys.json` are stored.\n\t */\n\treadonly nlsMetadataPath: string;\n\n\t/**\n\t * Path to the user data directory. Used as a cache for\n\t * language packs converted to the format we need.\n\t */\n\treadonly userDataPath: string;\n\n\t/**\n\t * Commit of the running application. Can be `undefined`\n\t * when not built.\n\t */\n\treadonly commit: string | undefined;\n\n\t/**\n\t * Locale as defined in `argv.json` or `app.getLocale()`.\n\t */\n\treadonly userLocale: string;\n\n\t/**\n\t * Locale as defined by the OS (e.g. `app.getPreferredSystemLanguages()`).\n\t */\n\treadonly osLocale: string;\n}\n\nexport async function resolveNLSConfiguration({ userLocale, osLocale, userDataPath, commit, nlsMetadataPath }: IResolveNLSConfigurationContext): Promise<INLSConfiguration> {\n\tmark('code/willGenerateNls');\n\n\tif (\n\t\tprocess.env['VSCODE_DEV'] ||\n\t\tuserLocale === 'pseudo' ||\n\t\tuserLocale.startsWith('en') ||\n\t\t!commit ||\n\t\t!userDataPath\n\t) {\n\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t}\n\n\ttry {\n\t\tconst languagePacks = await getLanguagePackConfigurations(userDataPath);\n\t\tif (!languagePacks) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst resolvedLanguage = resolveLanguagePackLanguage(languagePacks, userLocale);\n\t\tif (!resolvedLanguage) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst languagePack = languagePacks[resolvedLanguage];\n\t\tconst mainLanguagePackPath = languagePack?.translations?.['vscode'];\n\t\tif (\n\t\t\t!languagePack ||\n\t\t\ttypeof languagePack.hash !== 'string' ||\n\t\t\t!languagePack.translations ||\n\t\t\ttypeof mainLanguagePackPath !== 'string' ||\n\t\t\t!(await Promises.exists(mainLanguagePackPath))\n\t\t) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst languagePackId = `${languagePack.hash}.${resolvedLanguage}`;\n\t\tconst globalLanguagePackCachePath = join(userDataPath, 'clp', languagePackId);\n\t\tconst commitLanguagePackCachePath = join(globalLanguagePackCachePath, commit);\n\t\tconst languagePackMessagesFile = join(commitLanguagePackCachePath, 'nls.messages.json');\n\t\tconst translationsConfigFile = join(globalLanguagePackCachePath, 'tcf.json');\n\t\tconst languagePackCorruptMarkerFile = join(globalLanguagePackCachePath, 'corrupted.info');\n\n\t\tif (await Promises.exists(languagePackCorruptMarkerFile)) {\n\t\t\tawait promises.rm(globalLanguagePackCachePath, { recursive: true, force: true, maxRetries: 3 }); // delete corrupted cache folder\n\t\t}\n\n\t\tconst result: INLSConfiguration = {\n\t\t\tuserLocale,\n\t\t\tosLocale,\n\t\t\tresolvedLanguage,\n\t\t\tdefaultMessagesFile: join(nlsMetadataPath, 'nls.messages.json'),\n\t\t\tlanguagePack: {\n\t\t\t\ttranslationsConfigFile,\n\t\t\t\tmessagesFile: languagePackMessagesFile,\n\t\t\t\tcorruptMarkerFile: languagePackCorruptMarkerFile\n\t\t\t},\n\n\t\t\t// NLS: below properties are a relic from old times only used by vscode-nls and deprecated\n\t\t\tlocale: userLocale,\n\t\t\tavailableLanguages: { '*': resolvedLanguage },\n\t\t\t_languagePackId: languagePackId,\n\t\t\t_languagePackSupport: true,\n\t\t\t_translationsConfigFile: translationsConfigFile,\n\t\t\t_cacheRoot: globalLanguagePackCachePath,\n\t\t\t_resolvedLanguagePackCoreLocation: commitLanguagePackCachePath,\n\t\t\t_corruptedFile: languagePackCorruptMarkerFile\n\t\t};\n\n\t\tif (await Promises.exists(languagePackMessagesFile)) {\n\t\t\ttouch(commitLanguagePackCachePath).catch(() => { }); // We don't wait for this. No big harm if we can't touch\n\t\t\tmark('code/didGenerateNls');\n\t\t\treturn result;\n\t\t}\n\n\t\tconst [\n\t\t\tnlsDefaultKeys,\n\t\t\tnlsDefaultMessages,\n\t\t\tnlsPackdata\n\t\t]:\n\t\t\t[Array<[string, string[]]>, string[], { contents: Record<string, Record<string, string>> }]\n\t\t\t//      ^moduleId ^nlsKeys                               ^moduleId      ^nlsKey ^nlsValue\n\t\t\t= await Promise.all([\n\t\t\t\tpromises.readFile(join(nlsMetadataPath, 'nls.keys.json'), 'utf-8').then(content => JSON.parse(content)),\n\t\t\t\tpromises.readFile(join(nlsMetadataPath, 'nls.messages.json'), 'utf-8').then(content => JSON.parse(content)),\n\t\t\t\tpromises.readFile(mainLanguagePackPath, 'utf-8').then(content => JSON.parse(content)),\n\t\t\t]);\n\n\t\tconst nlsResult: string[] = [];\n\n\t\t// We expect NLS messages to be in a flat array in sorted order as they\n\t\t// where produced during build time. We use `nls.keys.json` to know the\n\t\t// right order and then lookup the related message from the translation.\n\t\t// If a translation does not exist, we fallback to the default message.\n\n\t\tlet nlsIndex = 0;\n\t\tfor (const [moduleId, nlsKeys] of nlsDefaultKeys) {\n\t\t\tconst moduleTranslations = nlsPackdata.contents[moduleId];\n\t\t\tfor (const nlsKey of nlsKeys) {\n\t\t\t\tnlsResult.push(moduleTranslations?.[nlsKey] || nlsDefaultMessages[nlsIndex]);\n\t\t\t\tnlsIndex++;\n\t\t\t}\n\t\t}\n\n\t\tawait promises.mkdir(commitLanguagePackCachePath, { recursive: true });\n\n\t\tawait Promise.all([\n\t\t\tpromises.writeFile(languagePackMessagesFile, JSON.stringify(nlsResult), 'utf-8'),\n\t\t\tpromises.writeFile(translationsConfigFile, JSON.stringify(languagePack.translations), 'utf-8')\n\t\t]);\n\n\t\tmark('code/didGenerateNls');\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconsole.error('Generating translation files failed.', error);\n\t}\n\n\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n}\n\n/**\n * The `languagepacks.json` file is a JSON file that contains all metadata\n * about installed language extensions per language. Specifically, for\n * core (`vscode`) and all extensions it supports, it points to the related\n * translation files.\n *\n * The file is updated whenever a new language pack is installed or removed.\n */\nasync function getLanguagePackConfigurations(userDataPath: string): Promise<ILanguagePacks | undefined> {\n\tconst configFile = join(userDataPath, 'languagepacks.json');\n\ttry {\n\t\treturn JSON.parse(await promises.readFile(configFile, 'utf-8'));\n\t} catch (err) {\n\t\treturn undefined; // Do nothing. If we can't read the file we have no language pack config.\n\t}\n}\n\nfunction resolveLanguagePackLanguage(languagePacks: ILanguagePacks, locale: string | undefined): string | undefined {\n\ttry {\n\t\twhile (locale) {\n\t\t\tif (languagePacks[locale]) {\n\t\t\t\treturn locale;\n\t\t\t}\n\n\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\tif (index > 0) {\n\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.error('Resolving language pack configuration failed.', error);\n\t}\n\n\treturn undefined;\n}\n\nfunction defaultNLSConfiguration(userLocale: string, osLocale: string, nlsMetadataPath: string): INLSConfiguration {\n\tmark('code/didGenerateNls');\n\n\treturn {\n\t\tuserLocale,\n\t\tosLocale,\n\t\tresolvedLanguage: 'en',\n\t\tdefaultMessagesFile: join(nlsMetadataPath, 'nls.messages.json'),\n\n\t\t// NLS: below 2 are a relic from old times only used by vscode-nls and deprecated\n\t\tlocale: userLocale,\n\t\tavailableLanguages: {}\n\t};\n}\n\n//#region fs helpers\n\nfunction touch(path: string): Promise<void> {\n\tconst date = new Date();\n\n\treturn promises.utimes(path, date, date);\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { join } from '../common/path.js';\nimport { promises } from 'fs';\nimport { mark } from '../common/performance.js';\nimport { ILanguagePacks, INLSConfiguration } from '../../nls.js';\nimport { Promises } from './pfs.js';\n\nexport interface IResolveNLSConfigurationContext {\n\n\t/**\n\t * Location where `nls.messages.json` and `nls.keys.json` are stored.\n\t */\n\treadonly nlsMetadataPath: string;\n\n\t/**\n\t * Path to the user data directory. Used as a cache for\n\t * language packs converted to the format we need.\n\t */\n\treadonly userDataPath: string;\n\n\t/**\n\t * Commit of the running application. Can be `undefined`\n\t * when not built.\n\t */\n\treadonly commit: string | undefined;\n\n\t/**\n\t * Locale as defined in `argv.json` or `app.getLocale()`.\n\t */\n\treadonly userLocale: string;\n\n\t/**\n\t * Locale as defined by the OS (e.g. `app.getPreferredSystemLanguages()`).\n\t */\n\treadonly osLocale: string;\n}\n\nexport async function resolveNLSConfiguration({ userLocale, osLocale, userDataPath, commit, nlsMetadataPath }: IResolveNLSConfigurationContext): Promise<INLSConfiguration> {\n\tmark('code/willGenerateNls');\n\n\tif (\n\t\tprocess.env['VSCODE_DEV'] ||\n\t\tuserLocale === 'pseudo' ||\n\t\tuserLocale.startsWith('en') ||\n\t\t!commit ||\n\t\t!userDataPath\n\t) {\n\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t}\n\n\ttry {\n\t\tconst languagePacks = await getLanguagePackConfigurations(userDataPath);\n\t\tif (!languagePacks) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst resolvedLanguage = resolveLanguagePackLanguage(languagePacks, userLocale);\n\t\tif (!resolvedLanguage) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst languagePack = languagePacks[resolvedLanguage];\n\t\tconst mainLanguagePackPath = languagePack?.translations?.['vscode'];\n\t\tif (\n\t\t\t!languagePack ||\n\t\t\ttypeof languagePack.hash !== 'string' ||\n\t\t\t!languagePack.translations ||\n\t\t\ttypeof mainLanguagePackPath !== 'string' ||\n\t\t\t!(await Promises.exists(mainLanguagePackPath))\n\t\t) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst languagePackId = `${languagePack.hash}.${resolvedLanguage}`;\n\t\tconst globalLanguagePackCachePath = join(userDataPath, 'clp', languagePackId);\n\t\tconst commitLanguagePackCachePath = join(globalLanguagePackCachePath, commit);\n\t\tconst languagePackMessagesFile = join(commitLanguagePackCachePath, 'nls.messages.json');\n\t\tconst translationsConfigFile = join(globalLanguagePackCachePath, 'tcf.json');\n\t\tconst languagePackCorruptMarkerFile = join(globalLanguagePackCachePath, 'corrupted.info');\n\n\t\tif (await Promises.exists(languagePackCorruptMarkerFile)) {\n\t\t\tawait promises.rm(globalLanguagePackCachePath, { recursive: true, force: true, maxRetries: 3 }); // delete corrupted cache folder\n\t\t}\n\n\t\tconst result: INLSConfiguration = {\n\t\t\tuserLocale,\n\t\t\tosLocale,\n\t\t\tresolvedLanguage,\n\t\t\tdefaultMessagesFile: join(nlsMetadataPath, 'nls.messages.json'),\n\t\t\tlanguagePack: {\n\t\t\t\ttranslationsConfigFile,\n\t\t\t\tmessagesFile: languagePackMessagesFile,\n\t\t\t\tcorruptMarkerFile: languagePackCorruptMarkerFile\n\t\t\t},\n\n\t\t\t// NLS: below properties are a relic from old times only used by vscode-nls and deprecated\n\t\t\tlocale: userLocale,\n\t\t\tavailableLanguages: { '*': resolvedLanguage },\n\t\t\t_languagePackId: languagePackId,\n\t\t\t_languagePackSupport: true,\n\t\t\t_translationsConfigFile: translationsConfigFile,\n\t\t\t_cacheRoot: globalLanguagePackCachePath,\n\t\t\t_resolvedLanguagePackCoreLocation: commitLanguagePackCachePath,\n\t\t\t_corruptedFile: languagePackCorruptMarkerFile\n\t\t};\n\n\t\tif (await Promises.exists(languagePackMessagesFile)) {\n\t\t\ttouch(commitLanguagePackCachePath).catch(() => { }); // We don't wait for this. No big harm if we can't touch\n\t\t\tmark('code/didGenerateNls');\n\t\t\treturn result;\n\t\t}\n\n\t\tconst [\n\t\t\tnlsDefaultKeys,\n\t\t\tnlsDefaultMessages,\n\t\t\tnlsPackdata\n\t\t]:\n\t\t\t[Array<[string, string[]]>, string[], { contents: Record<string, Record<string, string>> }]\n\t\t\t//      ^moduleId ^nlsKeys                               ^moduleId      ^nlsKey ^nlsValue\n\t\t\t= await Promise.all([\n\t\t\t\tpromises.readFile(join(nlsMetadataPath, 'nls.keys.json'), 'utf-8').then(content => JSON.parse(content)),\n\t\t\t\tpromises.readFile(join(nlsMetadataPath, 'nls.messages.json'), 'utf-8').then(content => JSON.parse(content)),\n\t\t\t\tpromises.readFile(mainLanguagePackPath, 'utf-8').then(content => JSON.parse(content)),\n\t\t\t]);\n\n\t\tconst nlsResult: string[] = [];\n\n\t\t// We expect NLS messages to be in a flat array in sorted order as they\n\t\t// where produced during build time. We use `nls.keys.json` to know the\n\t\t// right order and then lookup the related message from the translation.\n\t\t// If a translation does not exist, we fallback to the default message.\n\n\t\tlet nlsIndex = 0;\n\t\tfor (const [moduleId, nlsKeys] of nlsDefaultKeys) {\n\t\t\tconst moduleTranslations = nlsPackdata.contents[moduleId];\n\t\t\tfor (const nlsKey of nlsKeys) {\n\t\t\t\tnlsResult.push(moduleTranslations?.[nlsKey] || nlsDefaultMessages[nlsIndex]);\n\t\t\t\tnlsIndex++;\n\t\t\t}\n\t\t}\n\n\t\tawait promises.mkdir(commitLanguagePackCachePath, { recursive: true });\n\n\t\tawait Promise.all([\n\t\t\tpromises.writeFile(languagePackMessagesFile, JSON.stringify(nlsResult), 'utf-8'),\n\t\t\tpromises.writeFile(translationsConfigFile, JSON.stringify(languagePack.translations), 'utf-8')\n\t\t]);\n\n\t\tmark('code/didGenerateNls');\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconsole.error('Generating translation files failed.', error);\n\t}\n\n\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n}\n\n/**\n * The `languagepacks.json` file is a JSON file that contains all metadata\n * about installed language extensions per language. Specifically, for\n * core (`vscode`) and all extensions it supports, it points to the related\n * translation files.\n *\n * The file is updated whenever a new language pack is installed or removed.\n */\nasync function getLanguagePackConfigurations(userDataPath: string): Promise<ILanguagePacks | undefined> {\n\tconst configFile = join(userDataPath, 'languagepacks.json');\n\ttry {\n\t\treturn JSON.parse(await promises.readFile(configFile, 'utf-8'));\n\t} catch (err) {\n\t\treturn undefined; // Do nothing. If we can't read the file we have no language pack config.\n\t}\n}\n\nfunction resolveLanguagePackLanguage(languagePacks: ILanguagePacks, locale: string | undefined): string | undefined {\n\ttry {\n\t\twhile (locale) {\n\t\t\tif (languagePacks[locale]) {\n\t\t\t\treturn locale;\n\t\t\t}\n\n\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\tif (index > 0) {\n\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.error('Resolving language pack configuration failed.', error);\n\t}\n\n\treturn undefined;\n}\n\nfunction defaultNLSConfiguration(userLocale: string, osLocale: string, nlsMetadataPath: string): INLSConfiguration {\n\tmark('code/didGenerateNls');\n\n\treturn {\n\t\tuserLocale,\n\t\tosLocale,\n\t\tresolvedLanguage: 'en',\n\t\tdefaultMessagesFile: join(nlsMetadataPath, 'nls.messages.json'),\n\n\t\t// NLS: below 2 are a relic from old times only used by vscode-nls and deprecated\n\t\tlocale: userLocale,\n\t\tavailableLanguages: {}\n\t};\n}\n\n//#region fs helpers\n\nfunction touch(path: string): Promise<void> {\n\tconst date = new Date();\n\n\treturn promises.utimes(path, date, date);\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport './bootstrap-cli.js'; // this MUST come before other imports as it changes global state\nimport { configurePortable } from './bootstrap-node.js';\nimport { bootstrapESM } from './bootstrap-esm.js';\nimport { resolveNLSConfiguration } from './vs/base/node/nls.js';\nimport { product } from './bootstrap-meta.js';\n\n// NLS\nconst nlsConfiguration = await resolveNLSConfiguration({ userLocale: 'en', osLocale: 'en', commit: product.commit, userDataPath: '', nlsMetadataPath: import.meta.dirname });\nprocess.env['VSCODE_NLS_CONFIG'] = JSON.stringify(nlsConfiguration); // required for `bootstrap-esm` to pick up NLS messages\n\n// Enable portable support\nconfigurePortable(product);\n\n// Signal processes that we got launched as CLI\nprocess.env['VSCODE_CLI'] = '1';\n\n// Bootstrap ESM\nawait bootstrapESM();\n\n// Load Server\nawait import('./vs/code/node/cli.js');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport './bootstrap-cli.js'; // this MUST come before other imports as it changes global state\nimport { configurePortable } from './bootstrap-node.js';\nimport { bootstrapESM } from './bootstrap-esm.js';\nimport { resolveNLSConfiguration } from './vs/base/node/nls.js';\nimport { product } from './bootstrap-meta.js';\n\n// NLS\nconst nlsConfiguration = await resolveNLSConfiguration({ userLocale: 'en', osLocale: 'en', commit: product.commit, userDataPath: '', nlsMetadataPath: import.meta.dirname });\nprocess.env['VSCODE_NLS_CONFIG'] = JSON.stringify(nlsConfiguration); // required for `bootstrap-esm` to pick up NLS messages\n\n// Enable portable support\nconfigurePortable(product);\n\n// Signal processes that we got launched as CLI\nprocess.env['VSCODE_CLI'] = '1';\n\n// Bootstrap ESM\nawait bootstrapESM();\n\n// Load Server\nawait import('./vs/code/node/cli.js');\n"],"mappings":"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","names":["result","isWindows","Platform","Language","OperatingSystem","isWindows","path","isPathSeparator","_format","sep","join","relative","dirname","isAbsolute","fromLen","toLen","length","i","cwd","start","CompareResult","_a","Touch","touch","Iterable","_empty","from","i","Event","map","filter","equals","buffer","id","resolve","count","errorHandler","CancellationToken","LazyValueState","GraphemeBreakType","CodePoint","map","isPathSeparator","path","sep","pos","isWindows","join","path","isWindows","product","Schemas","join","COI","isEqual","isEqualOrParent","basename","extname","dirname","relativePath","relative","isWindows","path","sep","DataUri","resolve","token","extUri","timeout","DeferredOutcome","Promises","promises","AsyncIterableSourceState","normalize","fs","path","isWindows","join","resolve","writeFile","writeFileSync","realpath","normalizePath","Promises","RimRafMode","SymlinkSupport","error","stat","buffer","timeout","resolve","dispose","init_ports","path","basename","pattern","parse","resultExpression","withBasenames","allPaths","basenames","patterns","UriIteratorState","Dir","node","id","_util","path","FileType","FilePermission","FileChangeFilter","FileSystemProviderCapabilities","FileSystemProviderErrorCode","FileOperation","FileChangeType","FileOperationResult","FileKind","path","parse","promises","path","Promises","resolve","join","type","dirname","key","isNumber","arg","value","i","options","minimist","isWindows","assert","id","isWindows","resolve","fs","tmpdir","resolve","writeFileSync","tmpdir","product","vscodeGlobal","pkg","Utils","join","existsSync","tmpdir","env","resolve","join","dirname","isWindows","path","writeFileSync","child","filenamePrefix","main","init_ports","require","product","fs","createRequire","require","mark","getMarks","error","promises","Promises","join","promises","path"],"file":"cli.js"}