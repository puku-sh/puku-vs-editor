/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*//******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

export function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

export var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

export function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

export function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

export function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

export function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};

export function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};

export function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
};

export function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

export function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

export function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

export function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

export var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

export function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

export function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

export function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
export function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
export function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

export function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

export function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

export function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

export function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

export function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

export function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

export function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

export function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

export function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

export function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

export function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

export function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;

}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

export function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    function next() {
        while (env.stack.length) {
            var rec = env.stack.pop();
            try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
            }
            catch (e) {
                fail(e);
            }
        }
        if (env.hasError) throw env.error;
    }
    return next();
}

export default {
    __extends: __extends,
    __assign: __assign,
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __spreadArray: __spreadArray,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet,
    __classPrivateFieldIn: __classPrivateFieldIn,
    __addDisposableResource: __addDisposableResource,
    __disposeResources: __disposeResources,
};


// out-build/vs/base/common/lazy.js
var LazyValueState;
(function(LazyValueState2) {
  LazyValueState2[LazyValueState2["Uninitialized"] = 0] = "Uninitialized";
  LazyValueState2[LazyValueState2["Running"] = 1] = "Running";
  LazyValueState2[LazyValueState2["Completed"] = 2] = "Completed";
})(LazyValueState || (LazyValueState = {}));
var Lazy = class {
  constructor(executor) {
    this.executor = executor;
    this._state = LazyValueState.Uninitialized;
  }
  /**
   * True if the lazy value has been resolved.
   */
  get hasValue() {
    return this._state === LazyValueState.Completed;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  get value() {
    if (this._state === LazyValueState.Uninitialized) {
      this._state = LazyValueState.Running;
      try {
        this._value = this.executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._state = LazyValueState.Completed;
      }
    } else if (this._state === LazyValueState.Running) {
      throw new Error("Cannot read the value of a lazy that is being initialized");
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
};

// out-build/vs/base/common/errors.js
var ErrorHandler = class {
  constructor() {
    this.listeners = [];
    this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        if (e.stack) {
          if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
            throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
          }
          throw new Error(e.message + "\n\n" + e.stack);
        }
        throw e;
      }, 0);
    };
  }
  addListener(listener) {
    this.listeners.push(listener);
    return () => {
      this._removeListener(listener);
    };
  }
  emit(e) {
    this.listeners.forEach((listener) => {
      listener(e);
    });
  }
  _removeListener(listener) {
    this.listeners.splice(this.listeners.indexOf(listener), 1);
  }
  setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
    this.unexpectedErrorHandler = newUnexpectedErrorHandler;
  }
  getUnexpectedErrorHandler() {
    return this.unexpectedErrorHandler;
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e);
    this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
};
var errorHandler = new ErrorHandler();
function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
  errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
}
function onBugIndicatingError(e) {
  errorHandler.onUnexpectedError(e);
  return void 0;
}
function onUnexpectedError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedError(e);
  }
  return void 0;
}
function onUnexpectedExternalError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedExternalError(e);
  }
  return void 0;
}
function transformErrorForSerialization(error) {
  if (error instanceof Error) {
    const { name: name2, message, cause } = error;
    const stack = error.stacktrace || error.stack;
    return {
      $isError: true,
      name: name2,
      message,
      stack,
      noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error),
      cause: cause ? transformErrorForSerialization(cause) : void 0,
      code: error.code
    };
  }
  return error;
}
function transformErrorFromSerialization(data2) {
  let error;
  if (data2.noTelemetry) {
    error = new ErrorNoTelemetry();
  } else {
    error = new Error();
    error.name = data2.name;
  }
  error.message = data2.message;
  error.stack = data2.stack;
  if (data2.code) {
    error.code = data2.code;
  }
  if (data2.cause) {
    error.cause = transformErrorFromSerialization(data2.cause);
  }
  return error;
}
var canceledName = "Canceled";
function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
var CancellationError = class extends Error {
  constructor() {
    super(canceledName);
    this.name = this.message;
  }
};
var PendingMigrationError = class _PendingMigrationError extends Error {
  static {
    this._name = "PendingMigrationError";
  }
  static is(error) {
    return error instanceof _PendingMigrationError || error instanceof Error && error.name === _PendingMigrationError._name;
  }
  constructor(message) {
    super(message);
    this.name = _PendingMigrationError._name;
  }
};
function canceled() {
  const error = new Error(canceledName);
  error.name = error.message;
  return error;
}
function illegalArgument(name2) {
  if (name2) {
    return new Error(`Illegal argument: ${name2}`);
  } else {
    return new Error("Illegal argument");
  }
}
function illegalState(name2) {
  if (name2) {
    return new Error(`Illegal state: ${name2}`);
  } else {
    return new Error("Illegal state");
  }
}
var ReadonlyError = class extends TypeError {
  constructor(name2) {
    super(name2 ? `${name2} is read-only and cannot be changed` : "Cannot change read-only property");
  }
};
var NotImplementedError = class extends Error {
  constructor(message) {
    super("NotImplemented");
    if (message) {
      this.message = message;
    }
  }
};
var NotSupportedError = class extends Error {
  constructor(message) {
    super("NotSupported");
    if (message) {
      this.message = message;
    }
  }
};
var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
  constructor(msg) {
    super(msg);
    this.name = "CodeExpectedError";
  }
  static fromError(err) {
    if (err instanceof _ErrorNoTelemetry) {
      return err;
    }
    const result = new _ErrorNoTelemetry();
    result.message = err.message;
    result.stack = err.stack;
    return result;
  }
  static isErrorNoTelemetry(err) {
    return err.name === "CodeExpectedError";
  }
};
var BugIndicatingError = class _BugIndicatingError extends Error {
  constructor(message) {
    super(message || "An unexpected bug occurred.");
    Object.setPrototypeOf(this, _BugIndicatingError.prototype);
  }
};

// out-build/vs/base/common/arraysFind.js
function findLast(array, predicate, fromIndex = array.length - 1) {
  const idx = findLastIdx(array, predicate, fromIndex);
  if (idx === -1) {
    return void 0;
  }
  return array[idx];
}
function findLastIdx(array, predicate, fromIndex = array.length - 1) {
  for (let i = fromIndex; i >= 0; i--) {
    const element = array[i];
    if (predicate(element, i)) {
      return i;
    }
  }
  return -1;
}
function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      i = k + 1;
    } else {
      j = k;
    }
  }
  return i - 1;
}
var MonotonousArray = class _MonotonousArray {
  static {
    this.assertInvariants = false;
  }
  constructor(_array) {
    this._array = _array;
    this._findLastMonotonousLastIdx = 0;
  }
  /**
   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
   */
  findLastMonotonous(predicate) {
    if (_MonotonousArray.assertInvariants) {
      if (this._prevFindLastPredicate) {
        for (const item of this._array) {
          if (this._prevFindLastPredicate(item) && !predicate(item)) {
            throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
          }
        }
      }
      this._prevFindLastPredicate = predicate;
    }
    const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
    this._findLastMonotonousLastIdx = idx + 1;
    return idx === -1 ? void 0 : this._array[idx];
  }
};

// out-build/vs/base/common/arrays.js
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one === other) {
    return true;
  }
  if (!one || !other) {
    return false;
  }
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function groupBy(data2, compare4) {
  const result = [];
  let currentGroup = void 0;
  for (const element of data2.slice(0).sort(compare4)) {
    if (!currentGroup || compare4(currentGroup[0], element) !== 0) {
      currentGroup = [element];
      result.push(currentGroup);
    } else {
      currentGroup.push(element);
    }
  }
  return result;
}
function sortedDiff(before, after, compare4) {
  const result = [];
  function pushSplice(start, deleteCount, toInsert) {
    if (deleteCount === 0 && toInsert.length === 0) {
      return;
    }
    const latest = result[result.length - 1];
    if (latest && latest.start + latest.deleteCount === start) {
      latest.deleteCount += deleteCount;
      latest.toInsert.push(...toInsert);
    } else {
      result.push({ start, deleteCount, toInsert });
    }
  }
  let beforeIdx = 0;
  let afterIdx = 0;
  while (true) {
    if (beforeIdx === before.length) {
      pushSplice(beforeIdx, 0, after.slice(afterIdx));
      break;
    }
    if (afterIdx === after.length) {
      pushSplice(beforeIdx, before.length - beforeIdx, []);
      break;
    }
    const beforeElement = before[beforeIdx];
    const afterElement = after[afterIdx];
    const n = compare4(beforeElement, afterElement);
    if (n === 0) {
      beforeIdx += 1;
      afterIdx += 1;
    } else if (n < 0) {
      pushSplice(beforeIdx, 1, []);
      beforeIdx += 1;
    } else if (n > 0) {
      pushSplice(beforeIdx, 0, [afterElement]);
      afterIdx += 1;
    }
  }
  return result;
}
function delta(before, after, compare4) {
  const splices = sortedDiff(before, after, compare4);
  const removed = [];
  const added = [];
  for (const splice of splices) {
    removed.push(...before.slice(splice.start, splice.start + splice.deleteCount));
    added.push(...splice.toInsert);
  }
  return { removed, added };
}
function coalesce(array) {
  return array.filter((e) => !!e);
}
function coalesceInPlace(array) {
  let to = 0;
  for (let i = 0; i < array.length; i++) {
    if (!!array[i]) {
      array[to] = array[i];
      to += 1;
    }
  }
  array.length = to;
}
function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
  return Array.isArray(obj) && obj.length > 0;
}
function distinct(array, keyFn = (value) => value) {
  const seen = /* @__PURE__ */ new Set();
  return array.filter((element) => {
    const key = keyFn(element);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}
function shuffle(array, _seed) {
  let rand;
  if (typeof _seed === "number") {
    let seed = _seed;
    rand = () => {
      const x = Math.sin(seed++) * 179426549;
      return x - Math.floor(x);
    };
  } else {
    rand = Math.random;
  }
  for (let i = array.length - 1; i > 0; i -= 1) {
    const j = Math.floor(rand() * (i + 1));
    const temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
}
function mapArrayOrNot(items, fn) {
  return Array.isArray(items) ? items.map(fn) : fn(items);
}
function asArray(x) {
  return Array.isArray(x) ? x : [x];
}
var CompareResult;
(function(CompareResult2) {
  function isLessThan(result) {
    return result < 0;
  }
  CompareResult2.isLessThan = isLessThan;
  function isLessThanOrEqual(result) {
    return result <= 0;
  }
  CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
  function isGreaterThan(result) {
    return result > 0;
  }
  CompareResult2.isGreaterThan = isGreaterThan;
  function isNeitherLessOrGreaterThan(result) {
    return result === 0;
  }
  CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
  CompareResult2.greaterThan = 1;
  CompareResult2.lessThan = -1;
  CompareResult2.neitherLessOrGreaterThan = 0;
})(CompareResult || (CompareResult = {}));
function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
var numberComparator = (a, b) => a - b;
var CallbackIterable = class _CallbackIterable {
  static {
    this.empty = new _CallbackIterable((_callback) => {
    });
  }
  constructor(iterate) {
    this.iterate = iterate;
  }
  forEach(handler) {
    this.iterate((item) => {
      handler(item);
      return true;
    });
  }
  toArray() {
    const result = [];
    this.iterate((item) => {
      result.push(item);
      return true;
    });
    return result;
  }
  filter(predicate) {
    return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
  }
  map(mapFn) {
    return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
  }
  some(predicate) {
    let result = false;
    this.iterate((item) => {
      result = predicate(item);
      return !result;
    });
    return result;
  }
  findFirst(predicate) {
    let result;
    this.iterate((item) => {
      if (predicate(item)) {
        result = item;
        return false;
      }
      return true;
    });
    return result;
  }
  findLast(predicate) {
    let result;
    this.iterate((item) => {
      if (predicate(item)) {
        result = item;
      }
      return true;
    });
    return result;
  }
  findLastMaxBy(comparator) {
    let result;
    let first = true;
    this.iterate((item) => {
      if (first || CompareResult.isGreaterThan(comparator(item, result))) {
        first = false;
        result = item;
      }
      return true;
    });
    return result;
  }
};

// out-build/vs/base/common/collections.js
var _a;
function groupBy2(data2, groupFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const element of data2) {
    const key = groupFn(element);
    let target = result[key];
    if (!target) {
      target = result[key] = [];
    }
    target.push(element);
  }
  return result;
}
function diffSets(before, after) {
  const removed = [];
  const added = [];
  for (const element of before) {
    if (!after.has(element)) {
      removed.push(element);
    }
  }
  for (const element of after) {
    if (!before.has(element)) {
      added.push(element);
    }
  }
  return { removed, added };
}
var SetWithKey = class {
  static {
    _a = Symbol.toStringTag;
  }
  constructor(values, toKey) {
    this.toKey = toKey;
    this._map = /* @__PURE__ */ new Map();
    this[_a] = "SetWithKey";
    for (const value of values) {
      this.add(value);
    }
  }
  get size() {
    return this._map.size;
  }
  add(value) {
    const key = this.toKey(value);
    this._map.set(key, value);
    return this;
  }
  delete(value) {
    return this._map.delete(this.toKey(value));
  }
  has(value) {
    return this._map.has(this.toKey(value));
  }
  *entries() {
    for (const entry of this._map.values()) {
      yield [entry, entry];
    }
  }
  keys() {
    return this.values();
  }
  *values() {
    for (const entry of this._map.values()) {
      yield entry;
    }
  }
  clear() {
    this._map.clear();
  }
  forEach(callbackfn, thisArg) {
    this._map.forEach((entry) => callbackfn.call(thisArg, entry, entry, this));
  }
  [Symbol.iterator]() {
    return this.values();
  }
};

// out-build/vs/base/common/map.js
var _a2;
var _b;
var _c;
function getOrSet(map, key, value) {
  let result = map.get(key);
  if (result === void 0) {
    result = value;
    map.set(key, result);
  }
  return result;
}
var ResourceMapEntry = class {
  constructor(uri, value) {
    this.uri = uri;
    this.value = value;
  }
};
function isEntries(arg) {
  return Array.isArray(arg);
}
var ResourceMap = class _ResourceMap {
  static {
    this.defaultToKey = (resource) => resource.toString();
  }
  constructor(arg, toKey) {
    this[_a2] = "ResourceMap";
    if (arg instanceof _ResourceMap) {
      this.map = new Map(arg.map);
      this.toKey = toKey ?? _ResourceMap.defaultToKey;
    } else if (isEntries(arg)) {
      this.map = /* @__PURE__ */ new Map();
      this.toKey = toKey ?? _ResourceMap.defaultToKey;
      for (const [resource, value] of arg) {
        this.set(resource, value);
      }
    } else {
      this.map = /* @__PURE__ */ new Map();
      this.toKey = arg ?? _ResourceMap.defaultToKey;
    }
  }
  set(resource, value) {
    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
    return this;
  }
  get(resource) {
    return this.map.get(this.toKey(resource))?.value;
  }
  has(resource) {
    return this.map.has(this.toKey(resource));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(resource) {
    return this.map.delete(this.toKey(resource));
  }
  forEach(clb, thisArg) {
    if (typeof thisArg !== "undefined") {
      clb = clb.bind(thisArg);
    }
    for (const [_, entry] of this.map) {
      clb(entry.value, entry.uri, this);
    }
  }
  *values() {
    for (const entry of this.map.values()) {
      yield entry.value;
    }
  }
  *keys() {
    for (const entry of this.map.values()) {
      yield entry.uri;
    }
  }
  *entries() {
    for (const entry of this.map.values()) {
      yield [entry.uri, entry.value];
    }
  }
  *[(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
    for (const [, entry] of this.map) {
      yield [entry.uri, entry.value];
    }
  }
};
var ResourceSet = class {
  constructor(entriesOrKey, toKey) {
    this[_b] = "ResourceSet";
    if (!entriesOrKey || typeof entriesOrKey === "function") {
      this._map = new ResourceMap(entriesOrKey);
    } else {
      this._map = new ResourceMap(toKey);
      entriesOrKey.forEach(this.add, this);
    }
  }
  get size() {
    return this._map.size;
  }
  add(value) {
    this._map.set(value, value);
    return this;
  }
  clear() {
    this._map.clear();
  }
  delete(value) {
    return this._map.delete(value);
  }
  forEach(callbackfn, thisArg) {
    this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
  }
  has(value) {
    return this._map.has(value);
  }
  entries() {
    return this._map.entries();
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.keys();
  }
  [(_b = Symbol.toStringTag, Symbol.iterator)]() {
    return this.keys();
  }
};
var Touch;
(function(Touch2) {
  Touch2[Touch2["None"] = 0] = "None";
  Touch2[Touch2["AsOld"] = 1] = "AsOld";
  Touch2[Touch2["AsNew"] = 2] = "AsNew";
})(Touch || (Touch = {}));
var LinkedMap = class {
  constructor() {
    this[_c] = "LinkedMap";
    this._map = /* @__PURE__ */ new Map();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state = 0;
  }
  clear() {
    this._map.clear();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    return this._head?.value;
  }
  get last() {
    return this._tail?.value;
  }
  has(key) {
    return this._map.has(key);
  }
  get(key, touch = 0) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    if (touch !== 0) {
      this.touch(item, touch);
    }
    return item.value;
  }
  set(key, value, touch = 0) {
    let item = this._map.get(key);
    if (item) {
      item.value = value;
      if (touch !== 0) {
        this.touch(item, touch);
      }
    } else {
      item = { key, value, next: void 0, previous: void 0 };
      switch (touch) {
        case 0:
          this.addItemLast(item);
          break;
        case 1:
          this.addItemFirst(item);
          break;
        case 2:
          this.addItemLast(item);
          break;
        default:
          this.addItemLast(item);
          break;
      }
      this._map.set(key, item);
      this._size++;
    }
    return this;
  }
  delete(key) {
    return !!this.remove(key);
  }
  remove(key) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    this._map.delete(key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  shift() {
    if (!this._head && !this._tail) {
      return void 0;
    }
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    const item = this._head;
    this._map.delete(item.key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  forEach(callbackfn, thisArg) {
    const state = this._state;
    let current = this._head;
    while (current) {
      if (thisArg) {
        callbackfn.bind(thisArg)(current.value, current.key, this);
      } else {
        callbackfn(current.value, current.key, this);
      }
      if (this._state !== state) {
        throw new Error(`LinkedMap got modified during iteration.`);
      }
      current = current.next;
    }
  }
  keys() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: current.key, done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  values() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: current.value, done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  entries() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: [current.key, current.value], done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  [(_c = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(newSize) {
    if (newSize >= this.size) {
      return;
    }
    if (newSize === 0) {
      this.clear();
      return;
    }
    let current = this._head;
    let currentSize = this.size;
    while (current && currentSize > newSize) {
      this._map.delete(current.key);
      current = current.next;
      currentSize--;
    }
    this._head = current;
    this._size = currentSize;
    if (current) {
      current.previous = void 0;
    }
    this._state++;
  }
  trimNew(newSize) {
    if (newSize >= this.size) {
      return;
    }
    if (newSize === 0) {
      this.clear();
      return;
    }
    let current = this._tail;
    let currentSize = this.size;
    while (current && currentSize > newSize) {
      this._map.delete(current.key);
      current = current.previous;
      currentSize--;
    }
    this._tail = current;
    this._size = currentSize;
    if (current) {
      current.next = void 0;
    }
    this._state++;
  }
  addItemFirst(item) {
    if (!this._head && !this._tail) {
      this._tail = item;
    } else if (!this._head) {
      throw new Error("Invalid list");
    } else {
      item.next = this._head;
      this._head.previous = item;
    }
    this._head = item;
    this._state++;
  }
  addItemLast(item) {
    if (!this._head && !this._tail) {
      this._head = item;
    } else if (!this._tail) {
      throw new Error("Invalid list");
    } else {
      item.previous = this._tail;
      this._tail.next = item;
    }
    this._tail = item;
    this._state++;
  }
  removeItem(item) {
    if (item === this._head && item === this._tail) {
      this._head = void 0;
      this._tail = void 0;
    } else if (item === this._head) {
      if (!item.next) {
        throw new Error("Invalid list");
      }
      item.next.previous = void 0;
      this._head = item.next;
    } else if (item === this._tail) {
      if (!item.previous) {
        throw new Error("Invalid list");
      }
      item.previous.next = void 0;
      this._tail = item.previous;
    } else {
      const next = item.next;
      const previous = item.previous;
      if (!next || !previous) {
        throw new Error("Invalid list");
      }
      next.previous = previous;
      previous.next = next;
    }
    item.next = void 0;
    item.previous = void 0;
    this._state++;
  }
  touch(item, touch) {
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    if (touch !== 1 && touch !== 2) {
      return;
    }
    if (touch === 1) {
      if (item === this._head) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._tail) {
        previous.next = void 0;
        this._tail = previous;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.previous = void 0;
      item.next = this._head;
      this._head.previous = item;
      this._head = item;
      this._state++;
    } else if (touch === 2) {
      if (item === this._tail) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._head) {
        next.previous = void 0;
        this._head = next;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = this._tail;
      this._tail.next = item;
      this._tail = item;
      this._state++;
    }
  }
  toJSON() {
    const data2 = [];
    this.forEach((value, key) => {
      data2.push([key, value]);
    });
    return data2;
  }
  fromJSON(data2) {
    this.clear();
    for (const [key, value] of data2) {
      this.set(key, value);
    }
  }
};
var Cache = class extends LinkedMap {
  constructor(limit, ratio = 1) {
    super();
    this._limit = limit;
    this._ratio = Math.min(Math.max(0, ratio), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(limit) {
    this._limit = limit;
    this.checkTrim();
  }
  get ratio() {
    return this._ratio;
  }
  set ratio(ratio) {
    this._ratio = Math.min(Math.max(0, ratio), 1);
    this.checkTrim();
  }
  get(key, touch = 2) {
    return super.get(key, touch);
  }
  peek(key) {
    return super.get(
      key,
      0
      /* Touch.None */
    );
  }
  set(key, value) {
    super.set(
      key,
      value,
      2
      /* Touch.AsNew */
    );
    return this;
  }
  checkTrim() {
    if (this.size > this._limit) {
      this.trim(Math.round(this._limit * this._ratio));
    }
  }
};
var LRUCache = class extends Cache {
  constructor(limit, ratio = 1) {
    super(limit, ratio);
  }
  trim(newSize) {
    this.trimOld(newSize);
  }
  set(key, value) {
    super.set(key, value);
    this.checkTrim();
    return this;
  }
};
var SetMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(key, value) {
    let values = this.map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      this.map.set(key, values);
    }
    values.add(value);
  }
  delete(key, value) {
    const values = this.map.get(key);
    if (!values) {
      return;
    }
    values.delete(value);
    if (values.size === 0) {
      this.map.delete(key);
    }
  }
  forEach(key, fn) {
    const values = this.map.get(key);
    if (!values) {
      return;
    }
    values.forEach(fn);
  }
  get(key) {
    const values = this.map.get(key);
    if (!values) {
      return /* @__PURE__ */ new Set();
    }
    return values;
  }
};

// out-build/vs/base/common/functional.js
function createSingleCallFunction(fn, fnDidRunCallback) {
  const _this = this;
  let didCall = false;
  let result;
  return function() {
    if (didCall) {
      return result;
    }
    didCall = true;
    if (fnDidRunCallback) {
      try {
        result = fn.apply(_this, arguments);
      } finally {
        fnDidRunCallback();
      }
    } else {
      result = fn.apply(_this, arguments);
    }
    return result;
  };
}

// out-build/vs/base/common/assert.js
function ok(value, message) {
  if (!value) {
    throw new Error(message ? `Assertion failed (${message})` : "Assertion Failed");
  }
}
function assertNever(value, message = "Unreachable") {
  throw new Error(message);
}
function assert(condition, messageOrError = "unexpected state") {
  if (!condition) {
    const errorToThrow = typeof messageOrError === "string" ? new BugIndicatingError(`Assertion Failed: ${messageOrError}`) : messageOrError;
    throw errorToThrow;
  }
}
function assertFn(condition) {
  if (!condition()) {
    debugger;
    condition();
    onUnexpectedError(new BugIndicatingError("Assertion Failed"));
  }
}

// out-build/vs/base/common/types.js
function isString(str) {
  return typeof str === "string";
}
function isStringArray(value) {
  return isArrayOf(value, isString);
}
function isArrayOf(value, check) {
  return Array.isArray(value) && value.every(check);
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function isTypedArray(obj) {
  const TypedArray = Object.getPrototypeOf(Uint8Array);
  return typeof obj === "object" && obj instanceof TypedArray;
}
function isNumber(obj) {
  return typeof obj === "number" && !isNaN(obj);
}
function isIterable(obj) {
  return !!obj && typeof obj[Symbol.iterator] === "function";
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function isDefined(arg) {
  return !isUndefinedOrNull(arg);
}
function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function assertType(condition, type) {
  if (!condition) {
    throw new Error(type ? `Unexpected type, expected '${type}'` : "Unexpected type");
  }
}
function assertReturnsDefined(arg) {
  assert(arg !== null && arg !== void 0, "Argument is `undefined` or `null`.");
  return arg;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmptyObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  for (const key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function isFunction(obj) {
  return typeof obj === "function";
}
function validateConstraints(args, constraints) {
  const len = Math.min(args.length, constraints.length);
  for (let i = 0; i < len; i++) {
    validateConstraint(args[i], constraints[i]);
  }
}
function validateConstraint(arg, constraint) {
  if (isString(constraint)) {
    if (typeof arg !== constraint) {
      throw new Error(`argument does not match constraint: typeof ${constraint}`);
    }
  } else if (isFunction(constraint)) {
    try {
      if (arg instanceof constraint) {
        return;
      }
    } catch {
    }
    if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
      return;
    }
    if (constraint.length === 1 && constraint.call(void 0, arg) === true) {
      return;
    }
    throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
  }
}
function hasKey(x, key) {
  for (const k in key) {
    if (!(k in x)) {
      return false;
    }
  }
  return true;
}

// out-build/vs/base/common/iterator.js
var Iterable;
(function(Iterable2) {
  function is(thing) {
    return !!thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
  }
  Iterable2.is = is;
  const _empty2 = Object.freeze([]);
  function empty() {
    return _empty2;
  }
  Iterable2.empty = empty;
  function* single(element) {
    yield element;
  }
  Iterable2.single = single;
  function wrap(iterableOrElement) {
    if (is(iterableOrElement)) {
      return iterableOrElement;
    } else {
      return single(iterableOrElement);
    }
  }
  Iterable2.wrap = wrap;
  function from(iterable) {
    return iterable ?? _empty2;
  }
  Iterable2.from = from;
  function* reverse(array) {
    for (let i = array.length - 1; i >= 0; i--) {
      yield array[i];
    }
  }
  Iterable2.reverse = reverse;
  function isEmpty(iterable) {
    return !iterable || iterable[Symbol.iterator]().next().done === true;
  }
  Iterable2.isEmpty = isEmpty;
  function first(iterable) {
    return iterable[Symbol.iterator]().next().value;
  }
  Iterable2.first = first;
  function some(iterable, predicate) {
    let i = 0;
    for (const element of iterable) {
      if (predicate(element, i++)) {
        return true;
      }
    }
    return false;
  }
  Iterable2.some = some;
  function every(iterable, predicate) {
    let i = 0;
    for (const element of iterable) {
      if (!predicate(element, i++)) {
        return false;
      }
    }
    return true;
  }
  Iterable2.every = every;
  function find(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return element;
      }
    }
    return void 0;
  }
  Iterable2.find = find;
  function* filter2(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        yield element;
      }
    }
  }
  Iterable2.filter = filter2;
  function* map(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
      yield fn(element, index++);
    }
  }
  Iterable2.map = map;
  function* flatMap(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
      yield* fn(element, index++);
    }
  }
  Iterable2.flatMap = flatMap;
  function* concat(...iterables) {
    for (const item of iterables) {
      if (isIterable(item)) {
        yield* item;
      } else {
        yield item;
      }
    }
  }
  Iterable2.concat = concat;
  function reduce(iterable, reducer, initialValue) {
    let value = initialValue;
    for (const element of iterable) {
      value = reducer(value, element);
    }
    return value;
  }
  Iterable2.reduce = reduce;
  function length(iterable) {
    let count2 = 0;
    for (const _ of iterable) {
      count2++;
    }
    return count2;
  }
  Iterable2.length = length;
  function* slice(arr, from2, to = arr.length) {
    if (from2 < -arr.length) {
      from2 = 0;
    }
    if (from2 < 0) {
      from2 += arr.length;
    }
    if (to < 0) {
      to += arr.length;
    } else if (to > arr.length) {
      to = arr.length;
    }
    for (; from2 < to; from2++) {
      yield arr[from2];
    }
  }
  Iterable2.slice = slice;
  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
    const consumed = [];
    if (atMost === 0) {
      return [consumed, iterable];
    }
    const iterator = iterable[Symbol.iterator]();
    for (let i = 0; i < atMost; i++) {
      const next = iterator.next();
      if (next.done) {
        return [consumed, Iterable2.empty()];
      }
      consumed.push(next.value);
    }
    return [consumed, { [Symbol.iterator]() {
      return iterator;
    } }];
  }
  Iterable2.consume = consume;
  async function asyncToArray(iterable) {
    const result = [];
    for await (const item of iterable) {
      result.push(item);
    }
    return result;
  }
  Iterable2.asyncToArray = asyncToArray;
  async function asyncToArrayFlat(iterable) {
    let result = [];
    for await (const item of iterable) {
      result = result.concat(item);
    }
    return result;
  }
  Iterable2.asyncToArrayFlat = asyncToArrayFlat;
})(Iterable || (Iterable = {}));

// out-build/vs/base/common/lifecycle.js
var TRACK_DISPOSABLES = false;
var disposableTracker = null;
var DisposableTracker = class _DisposableTracker {
  constructor() {
    this.livingDisposables = /* @__PURE__ */ new Map();
  }
  static {
    this.idx = 0;
  }
  getDisposableData(d) {
    let val = this.livingDisposables.get(d);
    if (!val) {
      val = { parent: null, source: null, isSingleton: false, value: d, idx: _DisposableTracker.idx++ };
      this.livingDisposables.set(d, val);
    }
    return val;
  }
  trackDisposable(d) {
    const data2 = this.getDisposableData(d);
    if (!data2.source) {
      data2.source = new Error().stack;
    }
  }
  setParent(child, parent) {
    const data2 = this.getDisposableData(child);
    data2.parent = parent;
  }
  markAsDisposed(x) {
    this.livingDisposables.delete(x);
  }
  markAsSingleton(disposable) {
    this.getDisposableData(disposable).isSingleton = true;
  }
  getRootParent(data2, cache2) {
    const cacheValue = cache2.get(data2);
    if (cacheValue) {
      return cacheValue;
    }
    const result = data2.parent ? this.getRootParent(this.getDisposableData(data2.parent), cache2) : data2;
    cache2.set(data2, result);
    return result;
  }
  getTrackedDisposables() {
    const rootParentCache = /* @__PURE__ */ new Map();
    const leaking = [...this.livingDisposables.entries()].filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton).flatMap(([k]) => k);
    return leaking;
  }
  computeLeakingDisposables(maxReported = 10, preComputedLeaks) {
    let uncoveredLeakingObjs;
    if (preComputedLeaks) {
      uncoveredLeakingObjs = preComputedLeaks;
    } else {
      const rootParentCache = /* @__PURE__ */ new Map();
      const leakingObjects = [...this.livingDisposables.values()].filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);
      if (leakingObjects.length === 0) {
        return;
      }
      const leakingObjsSet = new Set(leakingObjects.map((o) => o.value));
      uncoveredLeakingObjs = leakingObjects.filter((l) => {
        return !(l.parent && leakingObjsSet.has(l.parent));
      });
      if (uncoveredLeakingObjs.length === 0) {
        throw new Error("There are cyclic diposable chains!");
      }
    }
    if (!uncoveredLeakingObjs) {
      return void 0;
    }
    function getStackTracePath(leaking) {
      function removePrefix(array, linesToRemove) {
        while (array.length > 0 && linesToRemove.some((regexp) => typeof regexp === "string" ? regexp === array[0] : array[0].match(regexp))) {
          array.shift();
        }
      }
      const lines = leaking.source.split("\n").map((p) => p.trim().replace("at ", "")).filter((l) => l !== "");
      removePrefix(lines, ["Error", /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]);
      return lines.reverse();
    }
    const stackTraceStarts = new SetMap();
    for (const leaking of uncoveredLeakingObjs) {
      const stackTracePath = getStackTracePath(leaking);
      for (let i2 = 0; i2 <= stackTracePath.length; i2++) {
        stackTraceStarts.add(stackTracePath.slice(0, i2).join("\n"), leaking);
      }
    }
    uncoveredLeakingObjs.sort(compareBy((l) => l.idx, numberComparator));
    let message = "";
    let i = 0;
    for (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {
      i++;
      const stackTracePath = getStackTracePath(leaking);
      const stackTraceFormattedLines = [];
      for (let i2 = 0; i2 < stackTracePath.length; i2++) {
        let line = stackTracePath[i2];
        const starts = stackTraceStarts.get(stackTracePath.slice(0, i2 + 1).join("\n"));
        line = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;
        const prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i2).join("\n"));
        const continuations = groupBy2([...prevStarts].map((d) => getStackTracePath(d)[i2]), (v) => v);
        delete continuations[stackTracePath[i2]];
        for (const [cont, set] of Object.entries(continuations)) {
          if (set) {
            stackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);
          }
        }
        stackTraceFormattedLines.unshift(line);
      }
      message += `


==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================
${stackTraceFormattedLines.join("\n")}
============================================================

`;
    }
    if (uncoveredLeakingObjs.length > maxReported) {
      message += `


... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables

`;
    }
    return { leaks: uncoveredLeakingObjs, details: message };
  }
};
function setDisposableTracker(tracker) {
  disposableTracker = tracker;
}
if (TRACK_DISPOSABLES) {
  const __is_disposable_tracked__ = "__is_disposable_tracked__";
  setDisposableTracker(new class {
    trackDisposable(x) {
      const stack = new Error("Potentially leaked disposable").stack;
      setTimeout(() => {
        if (!x[__is_disposable_tracked__]) {
          console.log(stack);
        }
      }, 3e3);
    }
    setParent(child, parent) {
      if (child && child !== Disposable.None) {
        try {
          child[__is_disposable_tracked__] = true;
        } catch {
        }
      }
    }
    markAsDisposed(disposable) {
      if (disposable && disposable !== Disposable.None) {
        try {
          disposable[__is_disposable_tracked__] = true;
        } catch {
        }
      }
    }
    markAsSingleton(disposable) {
    }
  }());
}
function trackDisposable(x) {
  disposableTracker?.trackDisposable(x);
  return x;
}
function markAsDisposed(disposable) {
  disposableTracker?.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
  disposableTracker?.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
  if (!disposableTracker) {
    return;
  }
  for (const child of children) {
    disposableTracker.setParent(child, parent);
  }
}
function markAsSingleton(singleton) {
  disposableTracker?.markAsSingleton(singleton);
  return singleton;
}
function isDisposable(thing) {
  return typeof thing === "object" && thing !== null && typeof thing.dispose === "function" && thing.dispose.length === 0;
}
function dispose(arg) {
  if (Iterable.is(arg)) {
    const errors = [];
    for (const d of arg) {
      if (d) {
        try {
          d.dispose();
        } catch (e) {
          errors.push(e);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      throw new AggregateError(errors, "Encountered errors while disposing of store");
    }
    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    arg.dispose();
    return arg;
  }
}
function combinedDisposable(...disposables) {
  const parent = toDisposable(() => dispose(disposables));
  setParentOfDisposables(disposables, parent);
  return parent;
}
var FunctionDisposable = class {
  constructor(fn) {
    this._isDisposed = false;
    this._fn = fn;
    trackDisposable(this);
  }
  dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._fn) {
      throw new Error(`Unbound disposable context: Need to use an arrow function to preserve the value of this`);
    }
    this._isDisposed = true;
    markAsDisposed(this);
    this._fn();
  }
};
function toDisposable(fn) {
  return new FunctionDisposable(fn);
}
var DisposableStore = class _DisposableStore {
  static {
    this.DISABLE_DISPOSED_WARNING = false;
  }
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set();
    this._isDisposed = false;
    trackDisposable(this);
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    markAsDisposed(this);
    this._isDisposed = true;
    this.clear();
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size === 0) {
      return;
    }
    try {
      dispose(this._toDispose);
    } finally {
      this._toDispose.clear();
    }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(o) {
    if (!o || o === Disposable.None) {
      return o;
    }
    if (o === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    setParentOfDisposable(o, this);
    if (this._isDisposed) {
      if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
      }
    } else {
      this._toDispose.add(o);
    }
    return o;
  }
  /**
   * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the
   * disposable even when the disposable is not part in the store.
   */
  delete(o) {
    if (!o) {
      return;
    }
    if (o === this) {
      throw new Error("Cannot dispose a disposable on itself!");
    }
    this._toDispose.delete(o);
    o.dispose();
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(o) {
    if (!o) {
      return;
    }
    if (this._toDispose.has(o)) {
      this._toDispose.delete(o);
      setParentOfDisposable(o, null);
    }
  }
  assertNotDisposed() {
    if (this._isDisposed) {
      onUnexpectedError(new BugIndicatingError("Object disposed"));
    }
  }
};
var Disposable = class {
  static {
    this.None = Object.freeze({ dispose() {
    } });
  }
  constructor() {
    this._store = new DisposableStore();
    trackDisposable(this);
    setParentOfDisposable(this._store, this);
  }
  dispose() {
    markAsDisposed(this);
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(o) {
    if (o === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    return this._store.add(o);
  }
};
var MutableDisposable = class {
  constructor() {
    this._isDisposed = false;
    trackDisposable(this);
  }
  /**
   * Get the currently held disposable value, or `undefined` if this MutableDisposable has been disposed
   */
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  /**
   * Set a new disposable value.
   *
   * Behaviour:
   * - If the MutableDisposable has been disposed, the setter is a no-op.
   * - If the new value is strictly equal to the current value, the setter is a no-op.
   * - Otherwise the previous value (if any) is disposed and the new value is stored.
   *
   * Related helpers:
   * - clear() resets the value to `undefined` (and disposes the previous value).
   * - clearAndLeak() returns the old value without disposing it and removes its parent.
   */
  set value(value) {
    if (this._isDisposed || value === this._value) {
      return;
    }
    this._value?.dispose();
    if (value) {
      setParentOfDisposable(value, this);
    }
    this._value = value;
  }
  /**
   * Resets the stored value and disposed of the previously stored value.
   */
  clear() {
    this.value = void 0;
  }
  dispose() {
    this._isDisposed = true;
    markAsDisposed(this);
    this._value?.dispose();
    this._value = void 0;
  }
  /**
   * Clears the value, but does not dispose it.
   * The old value is returned.
  */
  clearAndLeak() {
    const oldValue = this._value;
    this._value = void 0;
    if (oldValue) {
      setParentOfDisposable(oldValue, null);
    }
    return oldValue;
  }
};
var DisposableMap = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map();
    this._isDisposed = false;
    trackDisposable(this);
  }
  /**
   * Disposes of all stored values and mark this object as disposed.
   *
   * Trying to use this object after it has been disposed of is an error.
   */
  dispose() {
    markAsDisposed(this);
    this._isDisposed = true;
    this.clearAndDisposeAll();
  }
  /**
   * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
   */
  clearAndDisposeAll() {
    if (!this._store.size) {
      return;
    }
    try {
      dispose(this._store.values());
    } finally {
      this._store.clear();
    }
  }
  has(key) {
    return this._store.has(key);
  }
  get size() {
    return this._store.size;
  }
  get(key) {
    return this._store.get(key);
  }
  set(key, value, skipDisposeOnOverwrite = false) {
    if (this._isDisposed) {
      console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
    }
    if (!skipDisposeOnOverwrite) {
      this._store.get(key)?.dispose();
    }
    this._store.set(key, value);
    setParentOfDisposable(value, this);
  }
  /**
   * Delete the value stored for `key` from this map and also dispose of it.
   */
  deleteAndDispose(key) {
    this._store.get(key)?.dispose();
    this._store.delete(key);
  }
  /**
   * Delete the value stored for `key` from this map but return it. The caller is
   * responsible for disposing of the value.
   */
  deleteAndLeak(key) {
    const value = this._store.get(key);
    if (value) {
      setParentOfDisposable(value, null);
    }
    this._store.delete(key);
    return value;
  }
  keys() {
    return this._store.keys();
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
};

// out-build/vs/base/common/stream.js
function newWriteableStream(reducer, options2) {
  return new WriteableStreamImpl(reducer, options2);
}
var WriteableStreamImpl = class {
  /**
   * @param reducer a function that reduces the buffered data into a single object;
   * 				  because some objects can be complex and non-reducible, we also
   * 				  allow passing the explicit `null` value to skip the reduce step
   * @param options stream options
   */
  constructor(reducer, options2) {
    this.reducer = reducer;
    this.options = options2;
    this.state = {
      flowing: false,
      ended: false,
      destroyed: false
    };
    this.buffer = {
      data: [],
      error: []
    };
    this.listeners = {
      data: [],
      error: [],
      end: []
    };
    this.pendingWritePromises = [];
  }
  pause() {
    if (this.state.destroyed) {
      return;
    }
    this.state.flowing = false;
  }
  resume() {
    if (this.state.destroyed) {
      return;
    }
    if (!this.state.flowing) {
      this.state.flowing = true;
      this.flowData();
      this.flowErrors();
      this.flowEnd();
    }
  }
  write(data2) {
    if (this.state.destroyed) {
      return;
    }
    if (this.state.flowing) {
      this.emitData(data2);
    } else {
      this.buffer.data.push(data2);
      if (typeof this.options?.highWaterMark === "number" && this.buffer.data.length > this.options.highWaterMark) {
        return new Promise((resolve2) => this.pendingWritePromises.push(resolve2));
      }
    }
  }
  error(error) {
    if (this.state.destroyed) {
      return;
    }
    if (this.state.flowing) {
      this.emitError(error);
    } else {
      this.buffer.error.push(error);
    }
  }
  end(result) {
    if (this.state.destroyed) {
      return;
    }
    if (typeof result !== "undefined") {
      this.write(result);
    }
    if (this.state.flowing) {
      this.emitEnd();
      this.destroy();
    } else {
      this.state.ended = true;
    }
  }
  emitData(data2) {
    this.listeners.data.slice(0).forEach((listener) => listener(data2));
  }
  emitError(error) {
    if (this.listeners.error.length === 0) {
      onUnexpectedError(error);
    } else {
      this.listeners.error.slice(0).forEach((listener) => listener(error));
    }
  }
  emitEnd() {
    this.listeners.end.slice(0).forEach((listener) => listener());
  }
  on(event, callback) {
    if (this.state.destroyed) {
      return;
    }
    switch (event) {
      case "data":
        this.listeners.data.push(callback);
        this.resume();
        break;
      case "end":
        this.listeners.end.push(callback);
        if (this.state.flowing && this.flowEnd()) {
          this.destroy();
        }
        break;
      case "error":
        this.listeners.error.push(callback);
        if (this.state.flowing) {
          this.flowErrors();
        }
        break;
    }
  }
  removeListener(event, callback) {
    if (this.state.destroyed) {
      return;
    }
    let listeners = void 0;
    switch (event) {
      case "data":
        listeners = this.listeners.data;
        break;
      case "end":
        listeners = this.listeners.end;
        break;
      case "error":
        listeners = this.listeners.error;
        break;
    }
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index >= 0) {
        listeners.splice(index, 1);
      }
    }
  }
  flowData() {
    if (this.buffer.data.length === 0) {
      return;
    }
    if (typeof this.reducer === "function") {
      const fullDataBuffer = this.reducer(this.buffer.data);
      this.emitData(fullDataBuffer);
    } else {
      for (const data2 of this.buffer.data) {
        this.emitData(data2);
      }
    }
    this.buffer.data.length = 0;
    const pendingWritePromises = [...this.pendingWritePromises];
    this.pendingWritePromises.length = 0;
    pendingWritePromises.forEach((pendingWritePromise) => pendingWritePromise());
  }
  flowErrors() {
    if (this.listeners.error.length > 0) {
      for (const error of this.buffer.error) {
        this.emitError(error);
      }
      this.buffer.error.length = 0;
    }
  }
  flowEnd() {
    if (this.state.ended) {
      this.emitEnd();
      return this.listeners.end.length > 0;
    }
    return false;
  }
  destroy() {
    if (!this.state.destroyed) {
      this.state.destroyed = true;
      this.state.ended = true;
      this.buffer.data.length = 0;
      this.buffer.error.length = 0;
      this.listeners.data.length = 0;
      this.listeners.error.length = 0;
      this.listeners.end.length = 0;
      this.pendingWritePromises.length = 0;
    }
  }
};
function consumeReadable(readable, reducer) {
  const chunks = [];
  let chunk;
  while ((chunk = readable.read()) !== null) {
    chunks.push(chunk);
  }
  return reducer(chunks);
}
function consumeStream(stream, reducer) {
  return new Promise((resolve2, reject) => {
    const chunks = [];
    listenStream(stream, {
      onData: (chunk) => {
        if (reducer) {
          chunks.push(chunk);
        }
      },
      onError: (error) => {
        if (reducer) {
          reject(error);
        } else {
          resolve2(void 0);
        }
      },
      onEnd: () => {
        if (reducer) {
          resolve2(reducer(chunks));
        } else {
          resolve2(void 0);
        }
      }
    });
  });
}
function listenStream(stream, listener, token) {
  stream.on("error", (error) => {
    if (!token?.isCancellationRequested) {
      listener.onError(error);
    }
  });
  stream.on("end", () => {
    if (!token?.isCancellationRequested) {
      listener.onEnd();
    }
  });
  stream.on("data", (data2) => {
    if (!token?.isCancellationRequested) {
      listener.onData(data2);
    }
  });
}
function toStream(t, reducer) {
  const stream = newWriteableStream(reducer);
  stream.end(t);
  return stream;
}

// out-build/vs/base/common/buffer.js
var hasBuffer = typeof Buffer !== "undefined";
var indexOfTable = new Lazy(() => new Uint8Array(256));
var textEncoder;
var textDecoder;
var VSBuffer = class _VSBuffer {
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static alloc(byteLength) {
    if (hasBuffer) {
      return new _VSBuffer(Buffer.allocUnsafe(byteLength));
    } else {
      return new _VSBuffer(new Uint8Array(byteLength));
    }
  }
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */
  static wrap(actual) {
    if (hasBuffer && !Buffer.isBuffer(actual)) {
      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
    }
    return new _VSBuffer(actual);
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static fromString(source, options2) {
    const dontUseNodeBuffer = options2?.dontUseNodeBuffer || false;
    if (!dontUseNodeBuffer && hasBuffer) {
      return new _VSBuffer(Buffer.from(source));
    } else {
      if (!textEncoder) {
        textEncoder = new TextEncoder();
      }
      return new _VSBuffer(textEncoder.encode(source));
    }
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static fromByteArray(source) {
    const result = _VSBuffer.alloc(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      result.buffer[i] = source[i];
    }
    return result;
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static concat(buffers, totalLength) {
    if (typeof totalLength === "undefined") {
      totalLength = 0;
      for (let i = 0, len = buffers.length; i < len; i++) {
        totalLength += buffers[i].byteLength;
      }
    }
    const ret = _VSBuffer.alloc(totalLength);
    let offset = 0;
    for (let i = 0, len = buffers.length; i < len; i++) {
      const element = buffers[i];
      ret.set(element, offset);
      offset += element.byteLength;
    }
    return ret;
  }
  static isNativeBuffer(buffer) {
    return hasBuffer && Buffer.isBuffer(buffer);
  }
  constructor(buffer) {
    this.buffer = buffer;
    this.byteLength = this.buffer.byteLength;
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  clone() {
    const result = _VSBuffer.alloc(this.byteLength);
    result.set(this);
    return result;
  }
  toString() {
    if (hasBuffer) {
      return this.buffer.toString();
    } else {
      if (!textDecoder) {
        textDecoder = new TextDecoder(void 0, { ignoreBOM: true });
      }
      return textDecoder.decode(this.buffer);
    }
  }
  slice(start, end) {
    return new _VSBuffer(this.buffer.subarray(start, end));
  }
  set(array, offset) {
    if (array instanceof _VSBuffer) {
      this.buffer.set(array.buffer, offset);
    } else if (array instanceof Uint8Array) {
      this.buffer.set(array, offset);
    } else if (array instanceof ArrayBuffer) {
      this.buffer.set(new Uint8Array(array), offset);
    } else if (ArrayBuffer.isView(array)) {
      this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
    } else {
      throw new Error(`Unknown argument 'array'`);
    }
  }
  readUInt32BE(offset) {
    return readUInt32BE(this.buffer, offset);
  }
  writeUInt32BE(value, offset) {
    writeUInt32BE(this.buffer, value, offset);
  }
  readUInt32LE(offset) {
    return readUInt32LE(this.buffer, offset);
  }
  writeUInt32LE(value, offset) {
    writeUInt32LE(this.buffer, value, offset);
  }
  readUInt8(offset) {
    return readUInt8(this.buffer, offset);
  }
  writeUInt8(value, offset) {
    writeUInt8(this.buffer, value, offset);
  }
  indexOf(subarray, offset = 0) {
    return binaryIndexOf(this.buffer, subarray instanceof _VSBuffer ? subarray.buffer : subarray, offset);
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (this.byteLength !== other.byteLength) {
      return false;
    }
    return this.buffer.every((value, index) => value === other.buffer[index]);
  }
};
function binaryIndexOf(haystack, needle, offset = 0) {
  const needleLen = needle.byteLength;
  const haystackLen = haystack.byteLength;
  if (needleLen === 0) {
    return 0;
  }
  if (needleLen === 1) {
    return haystack.indexOf(needle[0]);
  }
  if (needleLen > haystackLen - offset) {
    return -1;
  }
  const table = indexOfTable.value;
  table.fill(needle.length);
  for (let i2 = 0; i2 < needle.length; i2++) {
    table[needle[i2]] = needle.length - i2 - 1;
  }
  let i = offset + needle.length - 1;
  let j = i;
  let result = -1;
  while (i < haystackLen) {
    if (haystack[i] === needle[j]) {
      if (j === 0) {
        result = i;
        break;
      }
      i--;
      j--;
    } else {
      i += Math.max(needle.length - j, table[haystack[i]]);
      j = needle.length - 1;
    }
  }
  return result;
}
function readUInt16LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}
function writeUInt16LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
}
function readUInt32BE(source, offset) {
  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];
}
function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}
function readUInt32LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0 | source[offset + 2] << 16 >>> 0 | source[offset + 3] << 24 >>> 0;
}
function writeUInt32LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
  value = value >>> 8;
  destination[offset + 2] = value & 255;
  value = value >>> 8;
  destination[offset + 3] = value & 255;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}
function readableToBuffer(readable) {
  return consumeReadable(readable, (chunks) => VSBuffer.concat(chunks));
}
function streamToBuffer(stream) {
  return consumeStream(stream, (chunks) => VSBuffer.concat(chunks));
}
function bufferToStream(buffer) {
  return toStream(buffer, (chunks) => VSBuffer.concat(chunks));
}
function decodeBase64(encoded) {
  let building = 0;
  let remainder = 0;
  let bufi = 0;
  const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));
  const append = (value) => {
    switch (remainder) {
      case 3:
        buffer[bufi++] = building | value;
        remainder = 0;
        break;
      case 2:
        buffer[bufi++] = building | value >>> 2;
        building = value << 6;
        remainder = 3;
        break;
      case 1:
        buffer[bufi++] = building | value >>> 4;
        building = value << 4;
        remainder = 2;
        break;
      default:
        building = value << 2;
        remainder = 1;
    }
  };
  for (let i = 0; i < encoded.length; i++) {
    const code = encoded.charCodeAt(i);
    if (code >= 65 && code <= 90) {
      append(code - 65);
    } else if (code >= 97 && code <= 122) {
      append(code - 97 + 26);
    } else if (code >= 48 && code <= 57) {
      append(code - 48 + 52);
    } else if (code === 43 || code === 45) {
      append(62);
    } else if (code === 47 || code === 95) {
      append(63);
    } else if (code === 61) {
      break;
    } else {
      throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
    }
  }
  const unpadded = bufi;
  while (remainder > 0) {
    append(0);
  }
  return VSBuffer.wrap(buffer).slice(0, unpadded);
}
var base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64UrlSafeAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
function encodeBase64({ buffer }, padded = true, urlSafe = false) {
  const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
  let output = "";
  const remainder = buffer.byteLength % 3;
  let i = 0;
  for (; i < buffer.byteLength - remainder; i += 3) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    const c = buffer[i + 2];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 63];
    output += dictionary[(b << 2 | c >>> 6) & 63];
    output += dictionary[c & 63];
  }
  if (remainder === 1) {
    const a = buffer[i + 0];
    output += dictionary[a >>> 2];
    output += dictionary[a << 4 & 63];
    if (padded) {
      output += "==";
    }
  } else if (remainder === 2) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 63];
    output += dictionary[b << 2 & 63];
    if (padded) {
      output += "=";
    }
  }
  return output;
}
var hexChars = "0123456789abcdef";
function encodeHex({ buffer }) {
  let result = "";
  for (let i = 0; i < buffer.length; i++) {
    const byte = buffer[i];
    result += hexChars[byte >>> 4];
    result += hexChars[byte & 15];
  }
  return result;
}
function decodeHex(hex) {
  if (hex.length % 2 !== 0) {
    throw new SyntaxError("Hex string must have an even length");
  }
  const out = new Uint8Array(hex.length >> 1);
  for (let i = 0; i < hex.length; ) {
    out[i >> 1] = decodeHexChar(hex, i++) << 4 | decodeHexChar(hex, i++);
  }
  return VSBuffer.wrap(out);
}
function decodeHexChar(str, position) {
  const s = str.charCodeAt(position);
  if (s >= 48 && s <= 57) {
    return s - 48;
  } else if (s >= 97 && s <= 102) {
    return s - 87;
  } else if (s >= 65 && s <= 70) {
    return s - 55;
  } else {
    throw new SyntaxError(`Invalid hex character at position ${position}`);
  }
}

// out-build/vs/base/common/linkedList.js
var Node = class _Node {
  static {
    this.Undefined = new _Node(void 0);
  }
  constructor(element) {
    this.element = element;
    this.next = _Node.Undefined;
    this.prev = _Node.Undefined;
  }
};
var LinkedList = class {
  constructor() {
    this._first = Node.Undefined;
    this._last = Node.Undefined;
    this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Node.Undefined;
  }
  clear() {
    let node = this._first;
    while (node !== Node.Undefined) {
      const next = node.next;
      node.prev = Node.Undefined;
      node.next = Node.Undefined;
      node = next;
    }
    this._first = Node.Undefined;
    this._last = Node.Undefined;
    this._size = 0;
  }
  unshift(element) {
    return this._insert(element, false);
  }
  push(element) {
    return this._insert(element, true);
  }
  _insert(element, atTheEnd) {
    const newNode = new Node(element);
    if (this._first === Node.Undefined) {
      this._first = newNode;
      this._last = newNode;
    } else if (atTheEnd) {
      const oldLast = this._last;
      this._last = newNode;
      newNode.prev = oldLast;
      oldLast.next = newNode;
    } else {
      const oldFirst = this._first;
      this._first = newNode;
      newNode.next = oldFirst;
      oldFirst.prev = newNode;
    }
    this._size += 1;
    let didRemove = false;
    return () => {
      if (!didRemove) {
        didRemove = true;
        this._remove(newNode);
      }
    };
  }
  shift() {
    if (this._first === Node.Undefined) {
      return void 0;
    } else {
      const res = this._first.element;
      this._remove(this._first);
      return res;
    }
  }
  pop() {
    if (this._last === Node.Undefined) {
      return void 0;
    } else {
      const res = this._last.element;
      this._remove(this._last);
      return res;
    }
  }
  peek() {
    if (this._last === Node.Undefined) {
      return void 0;
    } else {
      const res = this._last.element;
      return res;
    }
  }
  _remove(node) {
    if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
      const anchor = node.prev;
      anchor.next = node.next;
      node.next.prev = anchor;
    } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
      this._first = Node.Undefined;
      this._last = Node.Undefined;
    } else if (node.next === Node.Undefined) {
      this._last = this._last.prev;
      this._last.next = Node.Undefined;
    } else if (node.prev === Node.Undefined) {
      this._first = this._first.next;
      this._first.prev = Node.Undefined;
    }
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let node = this._first;
    while (node !== Node.Undefined) {
      yield node.element;
      node = node.next;
    }
  }
};

// out-build/vs/base/common/stopwatch.js
var performanceNow = globalThis.performance.now.bind(globalThis.performance);
var StopWatch = class _StopWatch {
  static create(highResolution) {
    return new _StopWatch(highResolution);
  }
  constructor(highResolution) {
    this._now = highResolution === false ? Date.now : performanceNow;
    this._startTime = this._now();
    this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now();
    this._stopTime = -1;
  }
  elapsed() {
    if (this._stopTime !== -1) {
      return this._stopTime - this._startTime;
    }
    return this._now() - this._startTime;
  }
};

// out-build/vs/base/common/event.js
var _enableDisposeWithListenerWarning = false;
var _enableSnapshotPotentialLeakWarning = false;
var Event;
(function(Event2) {
  Event2.None = () => Disposable.None;
  function _addLeakageTraceLogic(options2) {
    if (_enableSnapshotPotentialLeakWarning) {
      const { onDidAddListener: origListenerDidAdd } = options2;
      const stack = Stacktrace.create();
      let count2 = 0;
      options2.onDidAddListener = () => {
        if (++count2 === 2) {
          console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
          stack.print();
        }
        origListenerDidAdd?.();
      };
    }
  }
  function defer(event, disposable) {
    return debounce2(event, () => void 0, 0, void 0, true, void 0, disposable);
  }
  Event2.defer = defer;
  function once(event) {
    return (listener, thisArgs = null, disposables) => {
      let didFire = false;
      let result = void 0;
      result = event((e) => {
        if (didFire) {
          return;
        } else if (result) {
          result.dispose();
        } else {
          didFire = true;
        }
        return listener.call(thisArgs, e);
      }, null, disposables);
      if (didFire) {
        result.dispose();
      }
      return result;
    };
  }
  Event2.once = once;
  function onceIf(event, condition) {
    return Event2.once(Event2.filter(event, condition));
  }
  Event2.onceIf = onceIf;
  function map(event, map2, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
  }
  Event2.map = map;
  function forEach(event, each, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => {
      each(i);
      listener.call(thisArgs, i);
    }, null, disposables), disposable);
  }
  Event2.forEach = forEach;
  function filter2(event, filter3, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((e) => filter3(e) && listener.call(thisArgs, e), null, disposables), disposable);
  }
  Event2.filter = filter2;
  function signal(event) {
    return event;
  }
  Event2.signal = signal;
  function any(...events) {
    return (listener, thisArgs = null, disposables) => {
      const disposable = combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e))));
      return addAndReturnDisposable(disposable, disposables);
    };
  }
  Event2.any = any;
  function reduce(event, merge, initial, disposable) {
    let output = initial;
    return map(event, (e) => {
      output = merge(output, e);
      return output;
    }, disposable);
  }
  Event2.reduce = reduce;
  function snapshot(event, disposable) {
    let listener;
    const options2 = {
      onWillAddFirstListener() {
        listener = event(emitter.fire, emitter);
      },
      onDidRemoveLastListener() {
        listener?.dispose();
      }
    };
    if (!disposable) {
      _addLeakageTraceLogic(options2);
    }
    const emitter = new Emitter(options2);
    disposable?.add(emitter);
    return emitter.event;
  }
  function addAndReturnDisposable(d, store) {
    if (store instanceof Array) {
      store.push(d);
    } else if (store) {
      store.add(d);
    }
    return d;
  }
  function debounce2(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
    let subscription;
    let output = void 0;
    let handle = void 0;
    let numDebouncedCalls = 0;
    let doFire;
    const options2 = {
      leakWarningThreshold,
      onWillAddFirstListener() {
        subscription = event((cur) => {
          numDebouncedCalls++;
          output = merge(output, cur);
          if (leading && !handle) {
            emitter.fire(output);
            output = void 0;
          }
          doFire = () => {
            const _output = output;
            output = void 0;
            handle = void 0;
            if (!leading || numDebouncedCalls > 1) {
              emitter.fire(_output);
            }
            numDebouncedCalls = 0;
          };
          if (typeof delay === "number") {
            if (handle) {
              clearTimeout(handle);
            }
            handle = setTimeout(doFire, delay);
          } else {
            if (handle === void 0) {
              handle = null;
              queueMicrotask(doFire);
            }
          }
        });
      },
      onWillRemoveListener() {
        if (flushOnListenerRemove && numDebouncedCalls > 0) {
          doFire?.();
        }
      },
      onDidRemoveLastListener() {
        doFire = void 0;
        subscription.dispose();
      }
    };
    if (!disposable) {
      _addLeakageTraceLogic(options2);
    }
    const emitter = new Emitter(options2);
    disposable?.add(emitter);
    return emitter.event;
  }
  Event2.debounce = debounce2;
  function accumulate(event, delay = 0, disposable) {
    return Event2.debounce(event, (last, e) => {
      if (!last) {
        return [e];
      }
      last.push(e);
      return last;
    }, delay, void 0, true, void 0, disposable);
  }
  Event2.accumulate = accumulate;
  function latch(event, equals3 = (a, b) => a === b, disposable) {
    let firstCall = true;
    let cache2;
    return filter2(event, (value) => {
      const shouldEmit = firstCall || !equals3(value, cache2);
      firstCall = false;
      cache2 = value;
      return shouldEmit;
    }, disposable);
  }
  Event2.latch = latch;
  function split(event, isT, disposable) {
    return [
      Event2.filter(event, isT, disposable),
      Event2.filter(event, (e) => !isT(e), disposable)
    ];
  }
  Event2.split = split;
  function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
    let buffer2 = _buffer.slice();
    let listener = event((e) => {
      if (buffer2) {
        buffer2.push(e);
      } else {
        emitter.fire(e);
      }
    });
    if (disposable) {
      disposable.add(listener);
    }
    const flush = () => {
      buffer2?.forEach((e) => emitter.fire(e));
      buffer2 = null;
    };
    const emitter = new Emitter({
      onWillAddFirstListener() {
        if (!listener) {
          listener = event((e) => emitter.fire(e));
          if (disposable) {
            disposable.add(listener);
          }
        }
      },
      onDidAddFirstListener() {
        if (buffer2) {
          if (flushAfterTimeout) {
            setTimeout(flush);
          } else {
            flush();
          }
        }
      },
      onDidRemoveLastListener() {
        if (listener) {
          listener.dispose();
        }
        listener = null;
      }
    });
    if (disposable) {
      disposable.add(emitter);
    }
    return emitter.event;
  }
  Event2.buffer = buffer;
  function chain(event, sythensize) {
    const fn = (listener, thisArgs, disposables) => {
      const cs = sythensize(new ChainableSynthesis());
      return event(function(value) {
        const result = cs.evaluate(value);
        if (result !== HaltChainable) {
          listener.call(thisArgs, result);
        }
      }, void 0, disposables);
    };
    return fn;
  }
  Event2.chain = chain;
  const HaltChainable = Symbol("HaltChainable");
  class ChainableSynthesis {
    constructor() {
      this.steps = [];
    }
    map(fn) {
      this.steps.push(fn);
      return this;
    }
    forEach(fn) {
      this.steps.push((v) => {
        fn(v);
        return v;
      });
      return this;
    }
    filter(fn) {
      this.steps.push((v) => fn(v) ? v : HaltChainable);
      return this;
    }
    reduce(merge, initial) {
      let last = initial;
      this.steps.push((v) => {
        last = merge(last, v);
        return last;
      });
      return this;
    }
    latch(equals3 = (a, b) => a === b) {
      let firstCall = true;
      let cache2;
      this.steps.push((value) => {
        const shouldEmit = firstCall || !equals3(value, cache2);
        firstCall = false;
        cache2 = value;
        return shouldEmit ? value : HaltChainable;
      });
      return this;
    }
    evaluate(value) {
      for (const step of this.steps) {
        value = step(value);
        if (value === HaltChainable) {
          break;
        }
      }
      return value;
    }
  }
  function fromNodeEventEmitter(emitter, eventName, map2 = (id2) => id2) {
    const fn = (...args) => result.fire(map2(...args));
    const onFirstListenerAdd = () => emitter.on(eventName, fn);
    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
    return result.event;
  }
  Event2.fromNodeEventEmitter = fromNodeEventEmitter;
  function fromDOMEventEmitter(emitter, eventName, map2 = (id2) => id2) {
    const fn = (...args) => result.fire(map2(...args));
    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
    return result.event;
  }
  Event2.fromDOMEventEmitter = fromDOMEventEmitter;
  function toPromise(event, disposables) {
    let cancelRef;
    let listener;
    const promise = new Promise((resolve2) => {
      listener = once(event)(resolve2);
      addToDisposables(listener, disposables);
      cancelRef = () => {
        disposeAndRemove(listener, disposables);
      };
    });
    promise.cancel = cancelRef;
    if (disposables) {
      promise.finally(() => disposeAndRemove(listener, disposables));
    }
    return promise;
  }
  Event2.toPromise = toPromise;
  function forward(from, to) {
    return from((e) => to.fire(e));
  }
  Event2.forward = forward;
  function runAndSubscribe(event, handler, initial) {
    handler(initial);
    return event((e) => handler(e));
  }
  Event2.runAndSubscribe = runAndSubscribe;
  class EmitterObserver {
    constructor(_observable, store) {
      this._observable = _observable;
      this._counter = 0;
      this._hasChanged = false;
      const options2 = {
        onWillAddFirstListener: () => {
          _observable.addObserver(this);
          this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          _observable.removeObserver(this);
        }
      };
      if (!store) {
        _addLeakageTraceLogic(options2);
      }
      this.emitter = new Emitter(options2);
      if (store) {
        store.add(this.emitter);
      }
    }
    beginUpdate(_observable) {
      this._counter++;
    }
    handlePossibleChange(_observable) {
    }
    handleChange(_observable, _change) {
      this._hasChanged = true;
    }
    endUpdate(_observable) {
      this._counter--;
      if (this._counter === 0) {
        this._observable.reportChanges();
        if (this._hasChanged) {
          this._hasChanged = false;
          this.emitter.fire(this._observable.get());
        }
      }
    }
  }
  function fromObservable(obs, store) {
    const observer = new EmitterObserver(obs, store);
    return observer.emitter.event;
  }
  Event2.fromObservable = fromObservable;
  function fromObservableLight(observable) {
    return (listener, thisArgs, disposables) => {
      let count2 = 0;
      let didChange = false;
      const observer = {
        beginUpdate() {
          count2++;
        },
        endUpdate() {
          count2--;
          if (count2 === 0) {
            observable.reportChanges();
            if (didChange) {
              didChange = false;
              listener.call(thisArgs);
            }
          }
        },
        handlePossibleChange() {
        },
        handleChange() {
          didChange = true;
        }
      };
      observable.addObserver(observer);
      observable.reportChanges();
      const disposable = {
        dispose() {
          observable.removeObserver(observer);
        }
      };
      addToDisposables(disposable, disposables);
      return disposable;
    };
  }
  Event2.fromObservableLight = fromObservableLight;
})(Event || (Event = {}));
var EventProfiling = class _EventProfiling {
  static {
    this.all = /* @__PURE__ */ new Set();
  }
  static {
    this._idPool = 0;
  }
  constructor(name2) {
    this.listenerCount = 0;
    this.invocationCount = 0;
    this.elapsedOverall = 0;
    this.durations = [];
    this.name = `${name2}_${_EventProfiling._idPool++}`;
    _EventProfiling.all.add(this);
  }
  start(listenerCount) {
    this._stopWatch = new StopWatch();
    this.listenerCount = listenerCount;
  }
  stop() {
    if (this._stopWatch) {
      const elapsed = this._stopWatch.elapsed();
      this.durations.push(elapsed);
      this.elapsedOverall += elapsed;
      this.invocationCount += 1;
      this._stopWatch = void 0;
    }
  }
};
var _globalLeakWarningThreshold = -1;
var LeakageMonitor = class _LeakageMonitor {
  static {
    this._idPool = 1;
  }
  constructor(_errorHandler, threshold, name2 = (_LeakageMonitor._idPool++).toString(16).padStart(3, "0")) {
    this._errorHandler = _errorHandler;
    this.threshold = threshold;
    this.name = name2;
    this._warnCountdown = 0;
  }
  dispose() {
    this._stacks?.clear();
  }
  check(stack, listenerCount) {
    const threshold = this.threshold;
    if (threshold <= 0 || listenerCount < threshold) {
      return void 0;
    }
    if (!this._stacks) {
      this._stacks = /* @__PURE__ */ new Map();
    }
    const count2 = this._stacks.get(stack.value) || 0;
    this._stacks.set(stack.value, count2 + 1);
    this._warnCountdown -= 1;
    if (this._warnCountdown <= 0) {
      this._warnCountdown = threshold * 0.5;
      const [topStack, topCount] = this.getMostFrequentStack();
      const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;
      console.warn(message);
      console.warn(topStack);
      const error = new ListenerLeakError(message, topStack);
      this._errorHandler(error);
    }
    return () => {
      const count3 = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count3 - 1);
    };
  }
  getMostFrequentStack() {
    if (!this._stacks) {
      return void 0;
    }
    let topStack;
    let topCount = 0;
    for (const [stack, count2] of this._stacks) {
      if (!topStack || topCount < count2) {
        topStack = [stack, count2];
        topCount = count2;
      }
    }
    return topStack;
  }
};
var Stacktrace = class _Stacktrace {
  static create() {
    const err = new Error();
    return new _Stacktrace(err.stack ?? "");
  }
  constructor(value) {
    this.value = value;
  }
  print() {
    console.warn(this.value.split("\n").slice(2).join("\n"));
  }
};
var ListenerLeakError = class extends Error {
  constructor(message, stack) {
    super(message);
    this.name = "ListenerLeakError";
    this.stack = stack;
  }
};
var ListenerRefusalError = class extends Error {
  constructor(message, stack) {
    super(message);
    this.name = "ListenerRefusalError";
    this.stack = stack;
  }
};
var id = 0;
var UniqueContainer = class {
  constructor(value) {
    this.value = value;
    this.id = id++;
  }
};
var compactionThreshold = 2;
var forEachListener = (listeners, fn) => {
  if (listeners instanceof UniqueContainer) {
    fn(listeners);
  } else {
    for (let i = 0; i < listeners.length; i++) {
      const l = listeners[i];
      if (l) {
        fn(l);
      }
    }
  }
};
var Emitter = class {
  constructor(options2) {
    this._size = 0;
    this._options = options2;
    this._leakageMon = _globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold ? new LeakageMonitor(options2?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) : void 0;
    this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : void 0;
    this._deliveryQueue = this._options?.deliveryQueue;
  }
  dispose() {
    if (!this._disposed) {
      this._disposed = true;
      if (this._deliveryQueue?.current === this) {
        this._deliveryQueue.reset();
      }
      if (this._listeners) {
        if (_enableDisposeWithListenerWarning) {
          const listeners = this._listeners;
          queueMicrotask(() => {
            forEachListener(listeners, (l) => l.stack?.print());
          });
        }
        this._listeners = void 0;
        this._size = 0;
      }
      this._options?.onDidRemoveLastListener?.();
      this._leakageMon?.dispose();
    }
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    this._event ??= (callback, thisArgs, disposables) => {
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(message);
        const tuple = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1];
        const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);
        const errorHandler2 = this._options?.onListenerError || onUnexpectedError;
        errorHandler2(error);
        return Disposable.None;
      }
      if (this._disposed) {
        return Disposable.None;
      }
      if (thisArgs) {
        callback = callback.bind(thisArgs);
      }
      const contained = new UniqueContainer(callback);
      let removeMonitor;
      let stack;
      if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
        contained.stack = Stacktrace.create();
        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
      }
      if (_enableDisposeWithListenerWarning) {
        contained.stack = stack ?? Stacktrace.create();
      }
      if (!this._listeners) {
        this._options?.onWillAddFirstListener?.(this);
        this._listeners = contained;
        this._options?.onDidAddFirstListener?.(this);
      } else if (this._listeners instanceof UniqueContainer) {
        this._deliveryQueue ??= new EventDeliveryQueuePrivate();
        this._listeners = [this._listeners, contained];
      } else {
        this._listeners.push(contained);
      }
      this._options?.onDidAddListener?.(this);
      this._size++;
      const result = toDisposable(() => {
        removeMonitor?.();
        this._removeListener(contained);
      });
      addToDisposables(result, disposables);
      return result;
    };
    return this._event;
  }
  _removeListener(listener) {
    this._options?.onWillRemoveListener?.(this);
    if (!this._listeners) {
      return;
    }
    if (this._size === 1) {
      this._listeners = void 0;
      this._options?.onDidRemoveLastListener?.(this);
      this._size = 0;
      return;
    }
    const listeners = this._listeners;
    const index = listeners.indexOf(listener);
    if (index === -1) {
      console.log("disposed?", this._disposed);
      console.log("size?", this._size);
      console.log("arr?", JSON.stringify(this._listeners));
      throw new Error("Attempted to dispose unknown listener");
    }
    this._size--;
    listeners[index] = void 0;
    const adjustDeliveryQueue = this._deliveryQueue.current === this;
    if (this._size * compactionThreshold <= listeners.length) {
      let n = 0;
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]) {
          listeners[n++] = listeners[i];
        } else if (adjustDeliveryQueue && n < this._deliveryQueue.end) {
          this._deliveryQueue.end--;
          if (n < this._deliveryQueue.i) {
            this._deliveryQueue.i--;
          }
        }
      }
      listeners.length = n;
    }
  }
  _deliver(listener, value) {
    if (!listener) {
      return;
    }
    const errorHandler2 = this._options?.onListenerError || onUnexpectedError;
    if (!errorHandler2) {
      listener.value(value);
      return;
    }
    try {
      listener.value(value);
    } catch (e) {
      errorHandler2(e);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(dq) {
    const listeners = dq.current._listeners;
    while (dq.i < dq.end) {
      this._deliver(listeners[dq.i++], dq.value);
    }
    dq.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(event) {
    if (this._deliveryQueue?.current) {
      this._deliverQueue(this._deliveryQueue);
      this._perfMon?.stop();
    }
    this._perfMon?.start(this._size);
    if (!this._listeners) {
    } else if (this._listeners instanceof UniqueContainer) {
      this._deliver(this._listeners, event);
    } else {
      const dq = this._deliveryQueue;
      dq.enqueue(this, event, this._listeners.length);
      this._deliverQueue(dq);
    }
    this._perfMon?.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
};
var EventDeliveryQueuePrivate = class {
  constructor() {
    this.i = -1;
    this.end = 0;
  }
  enqueue(emitter, value, end) {
    this.i = 0;
    this.end = end;
    this.current = emitter;
    this.value = value;
  }
  reset() {
    this.i = this.end;
    this.current = void 0;
    this.value = void 0;
  }
};
var AsyncEmitter = class extends Emitter {
  async fireAsync(data2, token, promiseJoin) {
    if (!this._listeners) {
      return;
    }
    if (!this._asyncDeliveryQueue) {
      this._asyncDeliveryQueue = new LinkedList();
    }
    forEachListener(this._listeners, (listener) => this._asyncDeliveryQueue.push([listener.value, data2]));
    while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {
      const [listener, data3] = this._asyncDeliveryQueue.shift();
      const thenables = [];
      const event = {
        ...data3,
        token,
        waitUntil: (p) => {
          if (Object.isFrozen(thenables)) {
            throw new Error("waitUntil can NOT be called asynchronous");
          }
          if (promiseJoin) {
            p = promiseJoin(p, listener);
          }
          thenables.push(p);
        }
      };
      try {
        listener(event);
      } catch (e) {
        onUnexpectedError(e);
        continue;
      }
      Object.freeze(thenables);
      await Promise.allSettled(thenables).then((values) => {
        for (const value of values) {
          if (value.status === "rejected") {
            onUnexpectedError(value.reason);
          }
        }
      });
    }
  }
};
var PauseableEmitter = class extends Emitter {
  get isPaused() {
    return this._isPaused !== 0;
  }
  constructor(options2) {
    super(options2);
    this._isPaused = 0;
    this._eventQueue = new LinkedList();
    this._mergeFn = options2?.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0) {
      if (this._mergeFn) {
        if (this._eventQueue.size > 0) {
          const events = Array.from(this._eventQueue);
          this._eventQueue.clear();
          super.fire(this._mergeFn(events));
        }
      } else {
        while (!this._isPaused && this._eventQueue.size !== 0) {
          super.fire(this._eventQueue.shift());
        }
      }
    }
  }
  fire(event) {
    if (this._size) {
      if (this._isPaused !== 0) {
        this._eventQueue.push(event);
      } else {
        super.fire(event);
      }
    }
  }
};
var DebounceEmitter = class extends PauseableEmitter {
  constructor(options2) {
    super(options2);
    this._delay = options2.delay ?? 100;
  }
  fire(event) {
    if (!this._handle) {
      this.pause();
      this._handle = setTimeout(() => {
        this._handle = void 0;
        this.resume();
      }, this._delay);
    }
    super.fire(event);
  }
};
var MicrotaskEmitter = class extends Emitter {
  constructor(options2) {
    super(options2);
    this._queuedEvents = [];
    this._mergeFn = options2?.merge;
  }
  fire(event) {
    if (!this.hasListeners()) {
      return;
    }
    this._queuedEvents.push(event);
    if (this._queuedEvents.length === 1) {
      queueMicrotask(() => {
        if (this._mergeFn) {
          super.fire(this._mergeFn(this._queuedEvents));
        } else {
          this._queuedEvents.forEach((e) => super.fire(e));
        }
        this._queuedEvents = [];
      });
    }
  }
};
function addToDisposables(result, disposables) {
  if (disposables instanceof DisposableStore) {
    disposables.add(result);
  } else if (Array.isArray(disposables)) {
    disposables.push(result);
  }
}
function disposeAndRemove(result, disposables) {
  if (disposables instanceof DisposableStore) {
    disposables.delete(result);
  } else if (Array.isArray(disposables)) {
    const index = disposables.indexOf(result);
    if (index !== -1) {
      disposables.splice(index, 1);
    }
  }
  result.dispose();
}

// out-build/vs/workbench/services/extensions/common/extensionHostProtocol.js
var UIKind;
(function(UIKind2) {
  UIKind2[UIKind2["Desktop"] = 1] = "Desktop";
  UIKind2[UIKind2["Web"] = 2] = "Web";
})(UIKind || (UIKind = {}));
var ExtensionHostExitCode;
(function(ExtensionHostExitCode2) {
  ExtensionHostExitCode2[ExtensionHostExitCode2["VersionMismatch"] = 55] = "VersionMismatch";
  ExtensionHostExitCode2[ExtensionHostExitCode2["UnexpectedError"] = 81] = "UnexpectedError";
})(ExtensionHostExitCode || (ExtensionHostExitCode = {}));
var MessageType;
(function(MessageType3) {
  MessageType3[MessageType3["Initialized"] = 0] = "Initialized";
  MessageType3[MessageType3["Ready"] = 1] = "Ready";
  MessageType3[MessageType3["Terminate"] = 2] = "Terminate";
})(MessageType || (MessageType = {}));
function createMessageOfType(type) {
  const result = VSBuffer.alloc(1);
  switch (type) {
    case 0:
      result.writeUInt8(1, 0);
      break;
    case 1:
      result.writeUInt8(2, 0);
      break;
    case 2:
      result.writeUInt8(3, 0);
      break;
  }
  return result;
}
function isMessageOfType(message, type) {
  if (message.byteLength !== 1) {
    return false;
  }
  switch (message.readUInt8(0)) {
    case 1:
      return type === 0;
    case 2:
      return type === 1;
    case 3:
      return type === 2;
    default:
      return false;
  }
}
var NativeLogMarkers;
(function(NativeLogMarkers2) {
  NativeLogMarkers2["Start"] = "START_NATIVE_LOG";
  NativeLogMarkers2["End"] = "END_NATIVE_LOG";
})(NativeLogMarkers || (NativeLogMarkers = {}));

// out-build/vs/base/common/performance.js
function _definePolyfillMarks(timeOrigin) {
  const _data = [];
  if (typeof timeOrigin === "number") {
    _data.push("code/timeOrigin", timeOrigin);
  }
  function mark2(name2, markOptions) {
    _data.push(name2, markOptions?.startTime ?? Date.now());
  }
  function getMarks2() {
    const result = [];
    for (let i = 0; i < _data.length; i += 2) {
      result.push({
        name: _data[i],
        startTime: _data[i + 1]
      });
    }
    return result;
  }
  return { mark: mark2, getMarks: getMarks2 };
}
function _define() {
  if (typeof performance === "object" && typeof performance.mark === "function" && !performance.nodeTiming) {
    if (typeof performance.timeOrigin !== "number" && !performance.timing) {
      return _definePolyfillMarks();
    } else {
      return {
        mark(name2, markOptions) {
          performance.mark(name2, markOptions);
        },
        getMarks() {
          let timeOrigin = performance.timeOrigin;
          if (typeof timeOrigin !== "number") {
            timeOrigin = (performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart) ?? 0;
          }
          const result = [{ name: "code/timeOrigin", startTime: Math.round(timeOrigin) }];
          for (const entry of performance.getEntriesByType("mark")) {
            result.push({
              name: entry.name,
              startTime: Math.round(timeOrigin + entry.startTime)
            });
          }
          return result;
        }
      };
    }
  } else if (typeof process === "object") {
    const timeOrigin = performance?.timeOrigin;
    return _definePolyfillMarks(timeOrigin);
  } else {
    console.trace("perf-util loaded in UNKNOWN environment");
    return _definePolyfillMarks();
  }
}
function _factory(sharedObj) {
  if (!sharedObj.MonacoPerformanceMarks) {
    sharedObj.MonacoPerformanceMarks = _define();
  }
  return sharedObj.MonacoPerformanceMarks;
}
var perf = _factory(globalThis);
var mark = perf.mark;
var getMarks = perf.getMarks;

// out-build/vs/nls.messages.js
function getNLSMessages() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function getNLSLanguage() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}

// out-build/vs/nls.js
var isPseudo = getNLSLanguage() === "pseudo" || typeof document !== "undefined" && document.location && typeof document.location.hash === "string" && document.location.hash.indexOf("pseudo=true") >= 0;
function _format(message, args) {
  let result;
  if (args.length === 0) {
    result = message;
  } else {
    result = message.replace(/\{(\d+)\}/g, (match2, rest) => {
      const index = rest[0];
      const arg = args[index];
      let result2 = match2;
      if (typeof arg === "string") {
        result2 = arg;
      } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
        result2 = String(arg);
      }
      return result2;
    });
  }
  if (isPseudo) {
    result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
  }
  return result;
}
function localize(data2, message, ...args) {
  if (typeof data2 === "number") {
    return _format(lookupMessage(data2, message), args);
  }
  return _format(message, args);
}
function lookupMessage(index, fallback) {
  const message = getNLSMessages()?.[index];
  if (typeof message !== "string") {
    if (typeof fallback === "string") {
      return fallback;
    }
    throw new Error(`!!! NLS MISSING: ${index} !!!`);
  }
  return message;
}
function localize2(data2, originalMessage, ...args) {
  let message;
  if (typeof data2 === "number") {
    message = lookupMessage(data2, originalMessage);
  } else {
    message = originalMessage;
  }
  const value = _format(message, args);
  return {
    value,
    original: originalMessage === message ? value : _format(originalMessage, args)
  };
}

// out-build/vs/base/common/platform.js
var LANGUAGE_DEFAULT = "en";
var _isWindows = false;
var _isMacintosh = false;
var _isLinux = false;
var _isLinuxSnap = false;
var _isNative = false;
var _isWeb = false;
var _isElectron = false;
var _isIOS = false;
var _isCI = false;
var _isMobile = false;
var _locale = void 0;
var _language = LANGUAGE_DEFAULT;
var _platformLocale = LANGUAGE_DEFAULT;
var _translationsConfigFile = void 0;
var _userAgent = void 0;
var $globalThis = globalThis;
var nodeProcess = void 0;
if (typeof $globalThis.vscode !== "undefined" && typeof $globalThis.vscode.process !== "undefined") {
  nodeProcess = $globalThis.vscode.process;
} else if (typeof process !== "undefined" && typeof process?.versions?.node === "string") {
  nodeProcess = process;
}
var isElectronProcess = typeof nodeProcess?.versions?.electron === "string";
var isElectronRenderer = isElectronProcess && nodeProcess?.type === "renderer";
if (typeof nodeProcess === "object") {
  _isWindows = nodeProcess.platform === "win32";
  _isMacintosh = nodeProcess.platform === "darwin";
  _isLinux = nodeProcess.platform === "linux";
  _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
  _isElectron = isElectronProcess;
  _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"] || !!nodeProcess.env["GITHUB_WORKSPACE"];
  _locale = LANGUAGE_DEFAULT;
  _language = LANGUAGE_DEFAULT;
  const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
  if (rawNlsConfig) {
    try {
      const nlsConfig = JSON.parse(rawNlsConfig);
      _locale = nlsConfig.userLocale;
      _platformLocale = nlsConfig.osLocale;
      _language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;
      _translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;
    } catch (e) {
    }
  }
  _isNative = true;
} else if (typeof navigator === "object" && !isElectronRenderer) {
  _userAgent = navigator.userAgent;
  _isWindows = _userAgent.indexOf("Windows") >= 0;
  _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
  _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
  _isLinux = _userAgent.indexOf("Linux") >= 0;
  _isMobile = _userAgent?.indexOf("Mobi") >= 0;
  _isWeb = true;
  _language = getNLSLanguage() || LANGUAGE_DEFAULT;
  _locale = navigator.language.toLowerCase();
  _platformLocale = _locale;
} else {
  console.error("Unable to resolve platform.");
}
var Platform;
(function(Platform2) {
  Platform2[Platform2["Web"] = 0] = "Web";
  Platform2[Platform2["Mac"] = 1] = "Mac";
  Platform2[Platform2["Linux"] = 2] = "Linux";
  Platform2[Platform2["Windows"] = 3] = "Windows";
})(Platform || (Platform = {}));
function PlatformToString(platform3) {
  switch (platform3) {
    case 0:
      return "Web";
    case 1:
      return "Mac";
    case 2:
      return "Linux";
    case 3:
      return "Windows";
  }
}
var _platform = 0;
if (_isMacintosh) {
  _platform = 1;
} else if (_isWindows) {
  _platform = 3;
} else if (_isLinux) {
  _platform = 2;
}
var isWindows = _isWindows;
var isMacintosh = _isMacintosh;
var isLinux = _isLinux;
var isNative = _isNative;
var isWeb = _isWeb;
var isWebWorker = _isWeb && typeof $globalThis.importScripts === "function";
var webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;
var isIOS = _isIOS;
var isMobile = _isMobile;
var isCI = _isCI;
var userAgent = _userAgent;
var language = _language;
var Language;
(function(Language2) {
  function value() {
    return language;
  }
  Language2.value = value;
  function isDefaultVariant() {
    if (language.length === 2) {
      return language === "en";
    } else if (language.length >= 3) {
      return language[0] === "e" && language[1] === "n" && language[2] === "-";
    } else {
      return false;
    }
  }
  Language2.isDefaultVariant = isDefaultVariant;
  function isDefault() {
    return language === "en";
  }
  Language2.isDefault = isDefault;
})(Language || (Language = {}));
var setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
var setTimeout0 = (() => {
  if (setTimeout0IsFaster) {
    const pending = [];
    $globalThis.addEventListener("message", (e) => {
      if (e.data && e.data.vscodeScheduleAsyncWork) {
        for (let i = 0, len = pending.length; i < len; i++) {
          const candidate = pending[i];
          if (candidate.id === e.data.vscodeScheduleAsyncWork) {
            pending.splice(i, 1);
            candidate.callback();
            return;
          }
        }
      }
    });
    let lastId = 0;
    return (callback) => {
      const myId = ++lastId;
      pending.push({
        id: myId,
        callback
      });
      $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
    };
  }
  return (callback) => setTimeout(callback);
})();
var OperatingSystem;
(function(OperatingSystem2) {
  OperatingSystem2[OperatingSystem2["Windows"] = 1] = "Windows";
  OperatingSystem2[OperatingSystem2["Macintosh"] = 2] = "Macintosh";
  OperatingSystem2[OperatingSystem2["Linux"] = 3] = "Linux";
})(OperatingSystem || (OperatingSystem = {}));
var OS = _isMacintosh || _isIOS ? 2 : _isWindows ? 1 : 3;
var _isLittleEndian = true;
var _isLittleEndianComputed = false;
function isLittleEndian() {
  if (!_isLittleEndianComputed) {
    _isLittleEndianComputed = true;
    const test = new Uint8Array(2);
    test[0] = 1;
    test[1] = 2;
    const view = new Uint16Array(test.buffer);
    _isLittleEndian = view[0] === (2 << 8) + 1;
  }
  return _isLittleEndian;
}
var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

// out-build/vs/base/common/process.js
var safeProcess;
var vscodeGlobal = globalThis.vscode;
if (typeof vscodeGlobal !== "undefined" && typeof vscodeGlobal.process !== "undefined") {
  const sandboxProcess = vscodeGlobal.process;
  safeProcess = {
    get platform() {
      return sandboxProcess.platform;
    },
    get arch() {
      return sandboxProcess.arch;
    },
    get env() {
      return sandboxProcess.env;
    },
    cwd() {
      return sandboxProcess.cwd();
    }
  };
} else if (typeof process !== "undefined" && typeof process?.versions?.node === "string") {
  safeProcess = {
    get platform() {
      return process.platform;
    },
    get arch() {
      return process.arch;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.env["VSCODE_CWD"] || process.cwd();
    }
  };
} else {
  safeProcess = {
    // Supported
    get platform() {
      return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
    },
    get arch() {
      return void 0;
    },
    // Unsupported
    get env() {
      return {};
    },
    cwd() {
      return "/";
    }
  };
}
var cwd = safeProcess.cwd;
var env = safeProcess.env;
var platform = safeProcess.platform;
var arch = safeProcess.arch;

// out-build/vs/base/common/path.js
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;
var ErrorInvalidArgType = class extends Error {
  constructor(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && expected.indexOf("not ") === 0) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    const type = name2.indexOf(".") !== -1 ? "property" : "argument";
    let msg = `The "${name2}" ${type} ${determiner} of type ${expected}`;
    msg += `. Received type ${typeof actual}`;
    super(msg);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function validateObject(pathObject, name2) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ErrorInvalidArgType(name2, "Object", pathObject);
  }
}
function validateString(value, name2) {
  if (typeof value !== "string") {
    throw new ErrorInvalidArgType(name2, "string", value);
  }
}
var platformIsWin32 = platform === "win32";
function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (isPathSeparator3(code)) {
      break;
    } else {
      code = CHAR_FORWARD_SLASH;
    }
    if (isPathSeparator3(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path.slice(lastSlash + 1, i)}`;
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function formatExt(ext) {
  return ext ? `${ext[0] === "." ? "" : "."}${ext}` : "";
}
function _format2(sep2, pathObject) {
  validateObject(pathObject, "pathObject");
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || `${pathObject.name || ""}${formatExt(pathObject.ext)}`;
  if (!dir) {
    return base;
  }
  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
}
var win32 = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1; i--) {
      let path;
      if (i >= 0) {
        path = pathSegments[i];
        validateString(path, `paths[${i}]`);
        if (path.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path = cwd();
      } else {
        path = env[`=${resolvedDevice}`] || cwd();
        if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          path = `${resolvedDevice}\\`;
        }
      }
      const len = path.length;
      let rootEnd = 0;
      let device = "";
      let isAbsolute2 = false;
      const code = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          rootEnd = 1;
          isAbsolute2 = true;
        }
      } else if (isPathSeparator(code)) {
        isAbsolute2 = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len || j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute2 = true;
          rootEnd = 3;
        }
      }
      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
        } else {
          resolvedDevice = device;
        }
      }
      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0) {
          break;
        }
      } else {
        resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute2;
        if (isAbsolute2 && resolvedDevice.length > 0) {
          break;
        }
      }
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
  },
  normalize(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code = path.charCodeAt(0);
    if (len === 1) {
      return isPosixPathSeparator(code) ? "\\" : path;
    }
    if (isPathSeparator(code)) {
      isAbsolute2 = true;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            }
            if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      device = path.slice(0, 2);
      rootEnd = 2;
      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
        isAbsolute2 = true;
        rootEnd = 3;
      }
    }
    let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator) : "";
    if (tail.length === 0 && !isAbsolute2) {
      tail = ".";
    }
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
      tail += "\\";
    }
    if (!isAbsolute2 && device === void 0 && path.includes(":")) {
      if (tail.length >= 2 && isWindowsDeviceRoot(tail.charCodeAt(0)) && tail.charCodeAt(1) === CHAR_COLON) {
        return `.\\${tail}`;
      }
      let index = path.indexOf(":");
      do {
        if (index === len - 1 || isPathSeparator(path.charCodeAt(index + 1))) {
          return `.\\${tail}`;
        }
      } while ((index = path.indexOf(":", index + 1)) !== -1);
    }
    if (device === void 0) {
      return isAbsolute2 ? `\\${tail}` : tail;
    }
    return isAbsolute2 ? `${device}\\${tail}` : `${device}${tail}`;
  },
  isAbsolute(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return false;
    }
    const code = path.charCodeAt(0);
    return isPathSeparator(code) || // Possible device root
    len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined;
    let firstPart;
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = firstPart = arg;
        } else {
          joined += `\\${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    let needsReplace = true;
    let slashCount = 0;
    if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;
      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) {
            ++slashCount;
          } else {
            needsReplace = false;
          }
        }
      }
    }
    if (needsReplace) {
      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
        slashCount++;
      }
      if (slashCount >= 2) {
        joined = `\\${joined.slice(slashCount)}`;
      }
    }
    return win32.normalize(joined);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    const fromOrig = win32.resolve(from);
    const toOrig = win32.resolve(to);
    if (fromOrig === toOrig) {
      return "";
    }
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) {
      return "";
    }
    if (fromOrig.length !== from.length || toOrig.length !== to.length) {
      const fromSplit = fromOrig.split("\\");
      const toSplit = toOrig.split("\\");
      if (fromSplit[fromSplit.length - 1] === "") {
        fromSplit.pop();
      }
      if (toSplit[toSplit.length - 1] === "") {
        toSplit.pop();
      }
      const fromLen2 = fromSplit.length;
      const toLen2 = toSplit.length;
      const length2 = fromLen2 < toLen2 ? fromLen2 : toLen2;
      let i2;
      for (i2 = 0; i2 < length2; i2++) {
        if (fromSplit[i2].toLowerCase() !== toSplit[i2].toLowerCase()) {
          break;
        }
      }
      if (i2 === 0) {
        return toOrig;
      } else if (i2 === length2) {
        if (toLen2 > length2) {
          return toSplit.slice(i2).join("\\");
        }
        if (fromLen2 > length2) {
          return "..\\".repeat(fromLen2 - 1 - i2) + "..";
        }
        return "";
      }
      return "..\\".repeat(fromLen2 - i2) + toSplit.slice(i2).join("\\");
    }
    let fromStart = 0;
    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
      fromStart++;
    }
    let fromEnd = from.length;
    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
      fromEnd--;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      toStart++;
    }
    let toEnd = to.length;
    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
      toEnd--;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_BACKWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i !== length) {
      if (lastCommonSep === -1) {
        return toOrig;
      }
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        }
        if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
        out += out.length === 0 ? ".." : "\\..";
      }
    }
    toStart += lastCommonSep;
    if (out.length > 0) {
      return `${out}${toOrig.slice(toStart, toEnd)}`;
    }
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      ++toStart;
    }
    return toOrig.slice(toStart, toEnd);
  },
  toNamespacedPath(path) {
    if (typeof path !== "string" || path.length === 0) {
      return path;
    }
    const resolvedPath = win32.resolve(path);
    if (resolvedPath.length <= 2) {
      return path;
    }
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code = resolvedPath.charCodeAt(2);
        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
      return `\\\\?\\${resolvedPath}`;
    }
    return resolvedPath;
  },
  dirname(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = -1;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len === 1) {
      return isPathSeparator(code) ? path : ".";
    }
    if (isPathSeparator(code)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
      offset = rootEnd;
    }
    let end = -1;
    let matchedSlash = true;
    for (let i = len - 1; i >= offset; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      if (rootEnd === -1) {
        return ".";
      }
      end = rootEnd;
    }
    return path.slice(0, end);
  },
  basename(path, suffix) {
    if (suffix !== void 0) {
      validateString(suffix, "suffix");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
      start = 2;
    }
    if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path) {
        return "";
      }
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === suffix.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= start; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
      start = startPart = 2;
    }
    for (let i = path.length - 1; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format2.bind(null, "\\"),
  parse(path) {
    validateString(path, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0) {
      return ret;
    }
    const len = path.length;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len === 1) {
      if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
      }
      ret.base = ret.name = path;
      return ret;
    }
    if (isPathSeparator(code)) {
      rootEnd = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      if (len <= 2) {
        ret.root = ret.dir = path;
        return ret;
      }
      rootEnd = 2;
      if (isPathSeparator(path.charCodeAt(2))) {
        if (len === 3) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 3;
      }
    }
    if (rootEnd > 0) {
      ret.root = path.slice(0, rootEnd);
    }
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= rootEnd; --i) {
      code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(startPart, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0 && startPart !== rootEnd) {
      ret.dir = path.slice(0, startPart - 1);
    } else {
      ret.dir = ret.root;
    }
    return ret;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
};
var posixCwd = (() => {
  if (platformIsWin32) {
    const regexp = /\\/g;
    return () => {
      const cwd2 = cwd().replace(regexp, "/");
      return cwd2.slice(cwd2.indexOf("/"));
    };
  }
  return () => cwd();
})();
var posix = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= 0 && !resolvedAbsolute; i--) {
      const path = pathSegments[i];
      validateString(path, `paths[${i}]`);
      if (path.length === 0) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    if (!resolvedAbsolute) {
      const cwd2 = posixCwd();
      resolvedPath = `${cwd2}/${resolvedPath}`;
      resolvedAbsolute = cwd2.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    }
    return resolvedPath.length > 0 ? resolvedPath : ".";
  },
  normalize(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
    path = normalizeString(path, !isAbsolute2, "/", isPosixPathSeparator);
    if (path.length === 0) {
      if (isAbsolute2) {
        return "/";
      }
      return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator) {
      path += "/";
    }
    return isAbsolute2 ? `/${path}` : path;
  },
  isAbsolute(path) {
    validateString(path, "path");
    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    const path = [];
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        path.push(arg);
      }
    }
    if (path.length === 0) {
      return ".";
    }
    return posix.normalize(path.join("/"));
  },
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) {
      return "";
    }
    const fromStart = 1;
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    const toStart = 1;
    const toLen = to.length - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          return to.slice(toStart + i + 1);
        }
        if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        out += out.length === 0 ? ".." : "/..";
      }
    }
    return `${out}${to.slice(toStart + lastCommonSep)}`;
  },
  toNamespacedPath(path) {
    return path;
  },
  dirname(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let end = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      return hasRoot ? "/" : ".";
    }
    if (hasRoot && end === 1) {
      return "//";
    }
    return path.slice(0, end);
  },
  basename(path, suffix) {
    if (suffix !== void 0) {
      validateString(suffix, "suffix");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path) {
        return "";
      }
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === suffix.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= 0; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const char = path[i];
      if (char === "/") {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (char === ".") {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format2.bind(null, "/"),
  parse(path) {
    validateString(path, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0) {
      return ret;
    }
    const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let start;
    if (isAbsolute2) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(start2, end);
      } else {
        ret.name = path.slice(start2, startDot);
        ret.base = path.slice(start2, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0) {
      ret.dir = path.slice(0, startPart - 1);
    } else if (isAbsolute2) {
      ret.dir = "/";
    }
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
var isAbsolute = platformIsWin32 ? win32.isAbsolute : posix.isAbsolute;
var join = platformIsWin32 ? win32.join : posix.join;
var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
var relative = platformIsWin32 ? win32.relative : posix.relative;
var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
var basename = platformIsWin32 ? win32.basename : posix.basename;
var extname = platformIsWin32 ? win32.extname : posix.extname;
var format = platformIsWin32 ? win32.format : posix.format;
var parse = platformIsWin32 ? win32.parse : posix.parse;
var toNamespacedPath = platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath;
var sep = platformIsWin32 ? win32.sep : posix.sep;
var delimiter = platformIsWin32 ? win32.delimiter : posix.delimiter;

// out-build/vs/base/common/uri.js
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path) {
        path = _slash;
      } else if (path[0] !== _slash) {
        path = _slash + path;
      }
      break;
  }
  return path;
}
var _empty = "";
var _slash = "/";
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = class _URI {
  static isUri(thing) {
    if (thing instanceof _URI) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
  }
  /**
   * @internal
   */
  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
    if (typeof schemeOrData === "object") {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty;
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;
      _validateUri(this, _strict);
    }
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return uriToFsPath(this, false);
  }
  // ---- modify to new -------------------------
  with(change) {
    if (!change) {
      return this;
    }
    let { scheme, authority, path, query, fragment } = change;
    if (scheme === void 0) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }
    if (authority === void 0) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }
    if (path === void 0) {
      path = this.path;
    } else if (path === null) {
      path = _empty;
    }
    if (query === void 0) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }
    if (fragment === void 0) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }
    if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }
    return new Uri(scheme, authority, path, query, fragment);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(value, _strict = false) {
    const match2 = _regexp.exec(value);
    if (!match2) {
      return new Uri(_empty, _empty, _empty, _empty, _empty);
    }
    return new Uri(match2[2] || _empty, percentDecode(match2[4] || _empty), percentDecode(match2[5] || _empty), percentDecode(match2[7] || _empty), percentDecode(match2[9] || _empty), _strict);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(path) {
    let authority = _empty;
    if (isWindows) {
      path = path.replace(/\\/g, _slash);
    }
    if (path[0] === _slash && path[1] === _slash) {
      const idx = path.indexOf(_slash, 2);
      if (idx === -1) {
        authority = path.substring(2);
        path = _slash;
      } else {
        authority = path.substring(2, idx);
        path = path.substring(idx) || _slash;
      }
    }
    return new Uri("file", authority, path, _empty, _empty);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(components, strict) {
    const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
    return result;
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(uri, ...pathFragment) {
    if (!uri.path) {
      throw new Error(`[UriError]: cannot call joinPath on URI without path`);
    }
    let newPath;
    if (isWindows && uri.scheme === "file") {
      newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
    } else {
      newPath = posix.join(uri.path, ...pathFragment);
    }
    return uri.with({ path: newPath });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(skipEncoding = false) {
    return _asFormatted(this, skipEncoding);
  }
  toJSON() {
    return this;
  }
  static revive(data2) {
    if (!data2) {
      return data2;
    } else if (data2 instanceof _URI) {
      return data2;
    } else {
      const result = new Uri(data2);
      result._formatted = data2.external ?? null;
      result._fsPath = data2._sep === _pathSepMarker ? data2.fsPath ?? null : null;
      return result;
    }
  }
  [Symbol.for("debug.description")]() {
    return `URI(${this.toString()})`;
  }
};
function isUriComponents(thing) {
  if (!thing || typeof thing !== "object") {
    return false;
  }
  return typeof thing.scheme === "string" && (typeof thing.authority === "string" || typeof thing.authority === "undefined") && (typeof thing.path === "string" || typeof thing.path === "undefined") && (typeof thing.query === "string" || typeof thing.query === "undefined") && (typeof thing.fragment === "string" || typeof thing.fragment === "undefined");
}
var _pathSepMarker = isWindows ? 1 : void 0;
var Uri = class extends URI {
  constructor() {
    super(...arguments);
    this._formatted = null;
    this._fsPath = null;
  }
  get fsPath() {
    if (!this._fsPath) {
      this._fsPath = uriToFsPath(this, false);
    }
    return this._fsPath;
  }
  toString(skipEncoding = false) {
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }
      return this._formatted;
    } else {
      return _asFormatted(this, true);
    }
  }
  toJSON() {
    const res = {
      $mid: 1
      /* MarshalledId.Uri */
    };
    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }
    if (this._formatted) {
      res.external = this._formatted;
    }
    if (this.path) {
      res.path = this.path;
    }
    if (this.scheme) {
      res.scheme = this.scheme;
    }
    if (this.authority) {
      res.authority = this.authority;
    }
    if (this.query) {
      res.query = this.query;
    }
    if (this.fragment) {
      res.fragment = this.fragment;
    }
    return res;
  }
};
var encodeTable = {
  [
    58
    /* CharCode.Colon */
  ]: "%3A",
  // gen-delims
  [
    47
    /* CharCode.Slash */
  ]: "%2F",
  [
    63
    /* CharCode.QuestionMark */
  ]: "%3F",
  [
    35
    /* CharCode.Hash */
  ]: "%23",
  [
    91
    /* CharCode.OpenSquareBracket */
  ]: "%5B",
  [
    93
    /* CharCode.CloseSquareBracket */
  ]: "%5D",
  [
    64
    /* CharCode.AtSign */
  ]: "%40",
  [
    33
    /* CharCode.ExclamationMark */
  ]: "%21",
  // sub-delims
  [
    36
    /* CharCode.DollarSign */
  ]: "%24",
  [
    38
    /* CharCode.Ampersand */
  ]: "%26",
  [
    39
    /* CharCode.SingleQuote */
  ]: "%27",
  [
    40
    /* CharCode.OpenParen */
  ]: "%28",
  [
    41
    /* CharCode.CloseParen */
  ]: "%29",
  [
    42
    /* CharCode.Asterisk */
  ]: "%2A",
  [
    43
    /* CharCode.Plus */
  ]: "%2B",
  [
    44
    /* CharCode.Comma */
  ]: "%2C",
  [
    59
    /* CharCode.Semicolon */
  ]: "%3B",
  [
    61
    /* CharCode.Equals */
  ]: "%3D",
  [
    32
    /* CharCode.Space */
  ]: "%20"
};
function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
  let res = void 0;
  let nativeEncodePos = -1;
  for (let pos = 0; pos < uriComponent.length; pos++) {
    const code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      const escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
  let res = void 0;
  for (let pos = 0; pos < path.length; pos++) {
    const code = path.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path[pos];
      }
    }
  }
  return res !== void 0 ? res : path;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  let value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  let res = "";
  let { scheme, authority, path, query, fragment } = uri;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    let idx = authority.indexOf("@");
    if (idx !== -1) {
      const userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false, false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false, true);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.lastIndexOf(":");
    if (idx === -1) {
      res += encoder(authority, false, true);
    } else {
      res += encoder(authority.substr(0, idx), false, true);
      res += authority.substr(idx);
    }
  }
  if (path) {
    if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
      const code = path.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
      const code = path.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
      }
    }
    res += encoder(path, true, false);
  }
  if (query) {
    res += "?";
    res += encoder(query, false, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, (match2) => decodeURIComponentGraceful(match2));
}

// out-build/vs/workbench/services/extensions/common/proxyIdentifier.js
var ProxyIdentifier = class _ProxyIdentifier {
  static {
    this.count = 0;
  }
  constructor(sid) {
    this._proxyIdentifierBrand = void 0;
    this.sid = sid;
    this.nid = ++_ProxyIdentifier.count;
  }
};
var identifiers = [];
function createProxyIdentifier(identifier) {
  const result = new ProxyIdentifier(identifier);
  identifiers[result.nid] = result;
  return result;
}
function getStringIdentifierForProxy(nid) {
  return identifiers[nid].sid;
}
var SerializableObjectWithBuffers = class {
  constructor(value) {
    this.value = value;
  }
};

// out-build/vs/workbench/api/common/extHost.protocol.js
var TextEditorRevealType;
(function(TextEditorRevealType3) {
  TextEditorRevealType3[TextEditorRevealType3["Default"] = 0] = "Default";
  TextEditorRevealType3[TextEditorRevealType3["InCenter"] = 1] = "InCenter";
  TextEditorRevealType3[TextEditorRevealType3["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
  TextEditorRevealType3[TextEditorRevealType3["AtTop"] = 3] = "AtTop";
})(TextEditorRevealType || (TextEditorRevealType = {}));
var TabInputKind;
(function(TabInputKind2) {
  TabInputKind2[TabInputKind2["UnknownInput"] = 0] = "UnknownInput";
  TabInputKind2[TabInputKind2["TextInput"] = 1] = "TextInput";
  TabInputKind2[TabInputKind2["TextDiffInput"] = 2] = "TextDiffInput";
  TabInputKind2[TabInputKind2["TextMergeInput"] = 3] = "TextMergeInput";
  TabInputKind2[TabInputKind2["NotebookInput"] = 4] = "NotebookInput";
  TabInputKind2[TabInputKind2["NotebookDiffInput"] = 5] = "NotebookDiffInput";
  TabInputKind2[TabInputKind2["CustomEditorInput"] = 6] = "CustomEditorInput";
  TabInputKind2[TabInputKind2["WebviewEditorInput"] = 7] = "WebviewEditorInput";
  TabInputKind2[TabInputKind2["TerminalEditorInput"] = 8] = "TerminalEditorInput";
  TabInputKind2[TabInputKind2["InteractiveEditorInput"] = 9] = "InteractiveEditorInput";
  TabInputKind2[TabInputKind2["ChatEditorInput"] = 10] = "ChatEditorInput";
  TabInputKind2[TabInputKind2["MultiDiffEditorInput"] = 11] = "MultiDiffEditorInput";
})(TabInputKind || (TabInputKind = {}));
var TabModelOperationKind;
(function(TabModelOperationKind2) {
  TabModelOperationKind2[TabModelOperationKind2["TAB_OPEN"] = 0] = "TAB_OPEN";
  TabModelOperationKind2[TabModelOperationKind2["TAB_CLOSE"] = 1] = "TAB_CLOSE";
  TabModelOperationKind2[TabModelOperationKind2["TAB_UPDATE"] = 2] = "TAB_UPDATE";
  TabModelOperationKind2[TabModelOperationKind2["TAB_MOVE"] = 3] = "TAB_MOVE";
})(TabModelOperationKind || (TabModelOperationKind = {}));
var WebviewEditorCapabilities;
(function(WebviewEditorCapabilities2) {
  WebviewEditorCapabilities2[WebviewEditorCapabilities2["Editable"] = 0] = "Editable";
  WebviewEditorCapabilities2[WebviewEditorCapabilities2["SupportsHotExit"] = 1] = "SupportsHotExit";
})(WebviewEditorCapabilities || (WebviewEditorCapabilities = {}));
var WebviewMessageArrayBufferViewType;
(function(WebviewMessageArrayBufferViewType2) {
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Int8Array"] = 1] = "Int8Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Uint8Array"] = 2] = "Uint8Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Uint8ClampedArray"] = 3] = "Uint8ClampedArray";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Int16Array"] = 4] = "Int16Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Uint16Array"] = 5] = "Uint16Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Int32Array"] = 6] = "Int32Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Uint32Array"] = 7] = "Uint32Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Float32Array"] = 8] = "Float32Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["Float64Array"] = 9] = "Float64Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["BigInt64Array"] = 10] = "BigInt64Array";
  WebviewMessageArrayBufferViewType2[WebviewMessageArrayBufferViewType2["BigUint64Array"] = 11] = "BigUint64Array";
})(WebviewMessageArrayBufferViewType || (WebviewMessageArrayBufferViewType = {}));
var CellOutputKind;
(function(CellOutputKind2) {
  CellOutputKind2[CellOutputKind2["Text"] = 1] = "Text";
  CellOutputKind2[CellOutputKind2["Error"] = 2] = "Error";
  CellOutputKind2[CellOutputKind2["Rich"] = 3] = "Rich";
})(CellOutputKind || (CellOutputKind = {}));
var NotebookEditorRevealType;
(function(NotebookEditorRevealType3) {
  NotebookEditorRevealType3[NotebookEditorRevealType3["Default"] = 0] = "Default";
  NotebookEditorRevealType3[NotebookEditorRevealType3["InCenter"] = 1] = "InCenter";
  NotebookEditorRevealType3[NotebookEditorRevealType3["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
  NotebookEditorRevealType3[NotebookEditorRevealType3["AtTop"] = 3] = "AtTop";
})(NotebookEditorRevealType || (NotebookEditorRevealType = {}));
var CandidatePortSource;
(function(CandidatePortSource2) {
  CandidatePortSource2[CandidatePortSource2["None"] = 0] = "None";
  CandidatePortSource2[CandidatePortSource2["Process"] = 1] = "Process";
  CandidatePortSource2[CandidatePortSource2["Output"] = 2] = "Output";
  CandidatePortSource2[CandidatePortSource2["Hybrid"] = 3] = "Hybrid";
})(CandidatePortSource || (CandidatePortSource = {}));
var IdObject = class _IdObject {
  static {
    this._n = 0;
  }
  static mixin(object) {
    object._id = _IdObject._n++;
    return object;
  }
};
var ISuggestDataDtoField;
(function(ISuggestDataDtoField2) {
  ISuggestDataDtoField2["label"] = "a";
  ISuggestDataDtoField2["kind"] = "b";
  ISuggestDataDtoField2["detail"] = "c";
  ISuggestDataDtoField2["documentation"] = "d";
  ISuggestDataDtoField2["sortText"] = "e";
  ISuggestDataDtoField2["filterText"] = "f";
  ISuggestDataDtoField2["preselect"] = "g";
  ISuggestDataDtoField2["insertText"] = "h";
  ISuggestDataDtoField2["insertTextRules"] = "i";
  ISuggestDataDtoField2["range"] = "j";
  ISuggestDataDtoField2["commitCharacters"] = "k";
  ISuggestDataDtoField2["additionalTextEdits"] = "l";
  ISuggestDataDtoField2["kindModifier"] = "m";
  ISuggestDataDtoField2["commandIdent"] = "n";
  ISuggestDataDtoField2["commandId"] = "o";
  ISuggestDataDtoField2["commandArguments"] = "p";
})(ISuggestDataDtoField || (ISuggestDataDtoField = {}));
var ISuggestResultDtoField;
(function(ISuggestResultDtoField2) {
  ISuggestResultDtoField2["defaultRanges"] = "a";
  ISuggestResultDtoField2["completions"] = "b";
  ISuggestResultDtoField2["isIncomplete"] = "c";
  ISuggestResultDtoField2["duration"] = "d";
})(ISuggestResultDtoField || (ISuggestResultDtoField = {}));
var ExtHostTestingResource;
(function(ExtHostTestingResource2) {
  ExtHostTestingResource2[ExtHostTestingResource2["Workspace"] = 0] = "Workspace";
  ExtHostTestingResource2[ExtHostTestingResource2["TextDocument"] = 1] = "TextDocument";
})(ExtHostTestingResource || (ExtHostTestingResource = {}));
var MainContext = {
  MainThreadAuthentication: createProxyIdentifier("MainThreadAuthentication"),
  MainThreadBulkEdits: createProxyIdentifier("MainThreadBulkEdits"),
  MainThreadLanguageModels: createProxyIdentifier("MainThreadLanguageModels"),
  MainThreadEmbeddings: createProxyIdentifier("MainThreadEmbeddings"),
  MainThreadChatAgents2: createProxyIdentifier("MainThreadChatAgents2"),
  MainThreadCodeMapper: createProxyIdentifier("MainThreadCodeMapper"),
  MainThreadLanguageModelTools: createProxyIdentifier("MainThreadChatSkills"),
  MainThreadClipboard: createProxyIdentifier("MainThreadClipboard"),
  MainThreadCommands: createProxyIdentifier("MainThreadCommands"),
  MainThreadComments: createProxyIdentifier("MainThreadComments"),
  MainThreadConfiguration: createProxyIdentifier("MainThreadConfiguration"),
  MainThreadConsole: createProxyIdentifier("MainThreadConsole"),
  MainThreadDebugService: createProxyIdentifier("MainThreadDebugService"),
  MainThreadDecorations: createProxyIdentifier("MainThreadDecorations"),
  MainThreadDiagnostics: createProxyIdentifier("MainThreadDiagnostics"),
  MainThreadDialogs: createProxyIdentifier("MainThreadDiaglogs"),
  MainThreadDocuments: createProxyIdentifier("MainThreadDocuments"),
  MainThreadDocumentContentProviders: createProxyIdentifier("MainThreadDocumentContentProviders"),
  MainThreadTextEditors: createProxyIdentifier("MainThreadTextEditors"),
  MainThreadEditorInsets: createProxyIdentifier("MainThreadEditorInsets"),
  MainThreadEditorTabs: createProxyIdentifier("MainThreadEditorTabs"),
  MainThreadErrors: createProxyIdentifier("MainThreadErrors"),
  MainThreadTreeViews: createProxyIdentifier("MainThreadTreeViews"),
  MainThreadDownloadService: createProxyIdentifier("MainThreadDownloadService"),
  MainThreadLanguageFeatures: createProxyIdentifier("MainThreadLanguageFeatures"),
  MainThreadLanguages: createProxyIdentifier("MainThreadLanguages"),
  MainThreadLogger: createProxyIdentifier("MainThreadLogger"),
  MainThreadMessageService: createProxyIdentifier("MainThreadMessageService"),
  MainThreadOutputService: createProxyIdentifier("MainThreadOutputService"),
  MainThreadProgress: createProxyIdentifier("MainThreadProgress"),
  MainThreadQuickDiff: createProxyIdentifier("MainThreadQuickDiff"),
  MainThreadQuickOpen: createProxyIdentifier("MainThreadQuickOpen"),
  MainThreadStatusBar: createProxyIdentifier("MainThreadStatusBar"),
  MainThreadSecretState: createProxyIdentifier("MainThreadSecretState"),
  MainThreadStorage: createProxyIdentifier("MainThreadStorage"),
  MainThreadSpeech: createProxyIdentifier("MainThreadSpeechProvider"),
  MainThreadTelemetry: createProxyIdentifier("MainThreadTelemetry"),
  MainThreadTerminalService: createProxyIdentifier("MainThreadTerminalService"),
  MainThreadTerminalShellIntegration: createProxyIdentifier("MainThreadTerminalShellIntegration"),
  MainThreadWebviews: createProxyIdentifier("MainThreadWebviews"),
  MainThreadWebviewPanels: createProxyIdentifier("MainThreadWebviewPanels"),
  MainThreadWebviewViews: createProxyIdentifier("MainThreadWebviewViews"),
  MainThreadCustomEditors: createProxyIdentifier("MainThreadCustomEditors"),
  MainThreadUrls: createProxyIdentifier("MainThreadUrls"),
  MainThreadUriOpeners: createProxyIdentifier("MainThreadUriOpeners"),
  MainThreadProfileContentHandlers: createProxyIdentifier("MainThreadProfileContentHandlers"),
  MainThreadWorkspace: createProxyIdentifier("MainThreadWorkspace"),
  MainThreadFileSystem: createProxyIdentifier("MainThreadFileSystem"),
  MainThreadFileSystemEventService: createProxyIdentifier("MainThreadFileSystemEventService"),
  MainThreadExtensionService: createProxyIdentifier("MainThreadExtensionService"),
  MainThreadSCM: createProxyIdentifier("MainThreadSCM"),
  MainThreadSearch: createProxyIdentifier("MainThreadSearch"),
  MainThreadShare: createProxyIdentifier("MainThreadShare"),
  MainThreadTask: createProxyIdentifier("MainThreadTask"),
  MainThreadWindow: createProxyIdentifier("MainThreadWindow"),
  MainThreadLabelService: createProxyIdentifier("MainThreadLabelService"),
  MainThreadNotebook: createProxyIdentifier("MainThreadNotebook"),
  MainThreadNotebookDocuments: createProxyIdentifier("MainThreadNotebookDocumentsShape"),
  MainThreadNotebookEditors: createProxyIdentifier("MainThreadNotebookEditorsShape"),
  MainThreadNotebookKernels: createProxyIdentifier("MainThreadNotebookKernels"),
  MainThreadNotebookRenderers: createProxyIdentifier("MainThreadNotebookRenderers"),
  MainThreadInteractive: createProxyIdentifier("MainThreadInteractive"),
  MainThreadTheming: createProxyIdentifier("MainThreadTheming"),
  MainThreadTunnelService: createProxyIdentifier("MainThreadTunnelService"),
  MainThreadManagedSockets: createProxyIdentifier("MainThreadManagedSockets"),
  MainThreadTimeline: createProxyIdentifier("MainThreadTimeline"),
  MainThreadTesting: createProxyIdentifier("MainThreadTesting"),
  MainThreadLocalization: createProxyIdentifier("MainThreadLocalizationShape"),
  MainThreadMcp: createProxyIdentifier("MainThreadMcpShape"),
  MainThreadAiRelatedInformation: createProxyIdentifier("MainThreadAiRelatedInformation"),
  MainThreadAiEmbeddingVector: createProxyIdentifier("MainThreadAiEmbeddingVector"),
  MainThreadChatStatus: createProxyIdentifier("MainThreadChatStatus"),
  MainThreadAiSettingsSearch: createProxyIdentifier("MainThreadAiSettingsSearch"),
  MainThreadDataChannels: createProxyIdentifier("MainThreadDataChannels"),
  MainThreadChatSessions: createProxyIdentifier("MainThreadChatSessions"),
  MainThreadChatOutputRenderer: createProxyIdentifier("MainThreadChatOutputRenderer"),
  MainThreadChatContext: createProxyIdentifier("MainThreadChatContext")
};
var ExtHostContext = {
  ExtHostCodeMapper: createProxyIdentifier("ExtHostCodeMapper"),
  ExtHostCommands: createProxyIdentifier("ExtHostCommands"),
  ExtHostConfiguration: createProxyIdentifier("ExtHostConfiguration"),
  ExtHostDiagnostics: createProxyIdentifier("ExtHostDiagnostics"),
  ExtHostDebugService: createProxyIdentifier("ExtHostDebugService"),
  ExtHostDecorations: createProxyIdentifier("ExtHostDecorations"),
  ExtHostDocumentsAndEditors: createProxyIdentifier("ExtHostDocumentsAndEditors"),
  ExtHostDocuments: createProxyIdentifier("ExtHostDocuments"),
  ExtHostDocumentContentProviders: createProxyIdentifier("ExtHostDocumentContentProviders"),
  ExtHostDocumentSaveParticipant: createProxyIdentifier("ExtHostDocumentSaveParticipant"),
  ExtHostEditors: createProxyIdentifier("ExtHostEditors"),
  ExtHostTreeViews: createProxyIdentifier("ExtHostTreeViews"),
  ExtHostFileSystem: createProxyIdentifier("ExtHostFileSystem"),
  ExtHostFileSystemInfo: createProxyIdentifier("ExtHostFileSystemInfo"),
  ExtHostFileSystemEventService: createProxyIdentifier("ExtHostFileSystemEventService"),
  ExtHostLanguages: createProxyIdentifier("ExtHostLanguages"),
  ExtHostLanguageFeatures: createProxyIdentifier("ExtHostLanguageFeatures"),
  ExtHostQuickOpen: createProxyIdentifier("ExtHostQuickOpen"),
  ExtHostQuickDiff: createProxyIdentifier("ExtHostQuickDiff"),
  ExtHostStatusBar: createProxyIdentifier("ExtHostStatusBar"),
  ExtHostShare: createProxyIdentifier("ExtHostShare"),
  ExtHostExtensionService: createProxyIdentifier("ExtHostExtensionService"),
  ExtHostLogLevelServiceShape: createProxyIdentifier("ExtHostLogLevelServiceShape"),
  ExtHostTerminalService: createProxyIdentifier("ExtHostTerminalService"),
  ExtHostTerminalShellIntegration: createProxyIdentifier("ExtHostTerminalShellIntegration"),
  ExtHostSCM: createProxyIdentifier("ExtHostSCM"),
  ExtHostSearch: createProxyIdentifier("ExtHostSearch"),
  ExtHostTask: createProxyIdentifier("ExtHostTask"),
  ExtHostWorkspace: createProxyIdentifier("ExtHostWorkspace"),
  ExtHostWindow: createProxyIdentifier("ExtHostWindow"),
  ExtHostWebviews: createProxyIdentifier("ExtHostWebviews"),
  ExtHostWebviewPanels: createProxyIdentifier("ExtHostWebviewPanels"),
  ExtHostCustomEditors: createProxyIdentifier("ExtHostCustomEditors"),
  ExtHostWebviewViews: createProxyIdentifier("ExtHostWebviewViews"),
  ExtHostEditorInsets: createProxyIdentifier("ExtHostEditorInsets"),
  ExtHostEditorTabs: createProxyIdentifier("ExtHostEditorTabs"),
  ExtHostProgress: createProxyIdentifier("ExtHostProgress"),
  ExtHostComments: createProxyIdentifier("ExtHostComments"),
  ExtHostSecretState: createProxyIdentifier("ExtHostSecretState"),
  ExtHostStorage: createProxyIdentifier("ExtHostStorage"),
  ExtHostUrls: createProxyIdentifier("ExtHostUrls"),
  ExtHostUriOpeners: createProxyIdentifier("ExtHostUriOpeners"),
  ExtHostChatOutputRenderer: createProxyIdentifier("ExtHostChatOutputRenderer"),
  ExtHostProfileContentHandlers: createProxyIdentifier("ExtHostProfileContentHandlers"),
  ExtHostOutputService: createProxyIdentifier("ExtHostOutputService"),
  ExtHostLabelService: createProxyIdentifier("ExtHostLabelService"),
  ExtHostNotebook: createProxyIdentifier("ExtHostNotebook"),
  ExtHostNotebookDocuments: createProxyIdentifier("ExtHostNotebookDocuments"),
  ExtHostNotebookEditors: createProxyIdentifier("ExtHostNotebookEditors"),
  ExtHostNotebookKernels: createProxyIdentifier("ExtHostNotebookKernels"),
  ExtHostNotebookRenderers: createProxyIdentifier("ExtHostNotebookRenderers"),
  ExtHostNotebookDocumentSaveParticipant: createProxyIdentifier("ExtHostNotebookDocumentSaveParticipant"),
  ExtHostInteractive: createProxyIdentifier("ExtHostInteractive"),
  ExtHostChatAgents2: createProxyIdentifier("ExtHostChatAgents"),
  ExtHostLanguageModelTools: createProxyIdentifier("ExtHostChatSkills"),
  ExtHostChatProvider: createProxyIdentifier("ExtHostChatProvider"),
  ExtHostChatContext: createProxyIdentifier("ExtHostChatContext"),
  ExtHostSpeech: createProxyIdentifier("ExtHostSpeech"),
  ExtHostEmbeddings: createProxyIdentifier("ExtHostEmbeddings"),
  ExtHostAiRelatedInformation: createProxyIdentifier("ExtHostAiRelatedInformation"),
  ExtHostAiEmbeddingVector: createProxyIdentifier("ExtHostAiEmbeddingVector"),
  ExtHostAiSettingsSearch: createProxyIdentifier("ExtHostAiSettingsSearch"),
  ExtHostTheming: createProxyIdentifier("ExtHostTheming"),
  ExtHostTunnelService: createProxyIdentifier("ExtHostTunnelService"),
  ExtHostManagedSockets: createProxyIdentifier("ExtHostManagedSockets"),
  ExtHostAuthentication: createProxyIdentifier("ExtHostAuthentication"),
  ExtHostTimeline: createProxyIdentifier("ExtHostTimeline"),
  ExtHostTesting: createProxyIdentifier("ExtHostTesting"),
  ExtHostTelemetry: createProxyIdentifier("ExtHostTelemetry"),
  ExtHostLocalization: createProxyIdentifier("ExtHostLocalization"),
  ExtHostMcp: createProxyIdentifier("ExtHostMcp"),
  ExtHostDataChannels: createProxyIdentifier("ExtHostDataChannels"),
  ExtHostChatSessions: createProxyIdentifier("ExtHostChatSessions")
};

// out-build/vs/base/common/cancellation.js
var shortcutEvent = Object.freeze(function(callback, context) {
  const handle = setTimeout(callback.bind(context), 0);
  return { dispose() {
    clearTimeout(handle);
  } };
});
var CancellationToken;
(function(CancellationToken2) {
  function isCancellationToken(thing) {
    if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
      return true;
    }
    if (thing instanceof MutableToken) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
  }
  CancellationToken2.isCancellationToken = isCancellationToken;
  CancellationToken2.None = Object.freeze({
    isCancellationRequested: false,
    onCancellationRequested: Event.None
  });
  CancellationToken2.Cancelled = Object.freeze({
    isCancellationRequested: true,
    onCancellationRequested: shortcutEvent
  });
})(CancellationToken || (CancellationToken = {}));
var MutableToken = class {
  constructor() {
    this._isCancelled = false;
    this._emitter = null;
  }
  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;
      if (this._emitter) {
        this._emitter.fire(void 0);
        this.dispose();
      }
    }
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    if (this._isCancelled) {
      return shortcutEvent;
    }
    if (!this._emitter) {
      this._emitter = new Emitter();
    }
    return this._emitter.event;
  }
  dispose() {
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
};
var CancellationTokenSource = class {
  constructor(parent) {
    this._token = void 0;
    this._parentListener = void 0;
    this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
  }
  get token() {
    if (!this._token) {
      this._token = new MutableToken();
    }
    return this._token;
  }
  cancel() {
    if (!this._token) {
      this._token = CancellationToken.Cancelled;
    } else if (this._token instanceof MutableToken) {
      this._token.cancel();
    }
  }
  dispose(cancel = false) {
    if (cancel) {
      this.cancel();
    }
    this._parentListener?.dispose();
    if (!this._token) {
      this._token = CancellationToken.None;
    } else if (this._token instanceof MutableToken) {
      this._token.dispose();
    }
  }
};

// out-build/vs/base/common/cache.js
function identity(t) {
  return t;
}
var LRUCachedFunction = class {
  constructor(arg1, arg2) {
    this.lastCache = void 0;
    this.lastArgKey = void 0;
    if (typeof arg1 === "function") {
      this._fn = arg1;
      this._computeKey = identity;
    } else {
      this._fn = arg2;
      this._computeKey = arg1.getCacheKey;
    }
  }
  get(arg) {
    const key = this._computeKey(arg);
    if (this.lastArgKey !== key) {
      this.lastArgKey = key;
      this.lastCache = this._fn(arg);
    }
    return this.lastCache;
  }
};

// out-build/vs/base/common/strings.js
function isFalsyOrWhitespace(str) {
  if (!str || typeof str !== "string") {
    return true;
  }
  return str.trim().length === 0;
}
var _format2Regexp = /{([^}]+)}/g;
function format2(template, values) {
  if (Object.keys(values).length === 0) {
    return template;
  }
  return template.replace(_format2Regexp, (match2, group) => values[group] ?? match2);
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function count(value, substr) {
  let result = 0;
  let index = value.indexOf(substr);
  while (index !== -1) {
    result++;
    index = value.indexOf(substr, index + substr.length);
  }
  return result;
}
function ltrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length;
  let offset = 0;
  if (needleLen === 1) {
    const ch = needle.charCodeAt(0);
    while (offset < haystack.length && haystack.charCodeAt(offset) === ch) {
      offset++;
    }
  } else {
    while (haystack.startsWith(needle, offset)) {
      offset += needleLen;
    }
  }
  return haystack.substring(offset);
}
function rtrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length, haystackLen = haystack.length;
  if (needleLen === 1) {
    let end = haystackLen;
    const ch = needle.charCodeAt(0);
    while (end > 0 && haystack.charCodeAt(end - 1) === ch) {
      end--;
    }
    return haystack.substring(0, end);
  }
  let offset = haystackLen;
  while (offset > 0 && haystack.endsWith(needle, offset)) {
    offset -= needleLen;
  }
  return haystack.substring(0, offset);
}
function createRegExp(searchString, isRegex, options2 = {}) {
  if (!searchString) {
    throw new Error("Cannot create regex from empty string");
  }
  if (!isRegex) {
    searchString = escapeRegExpCharacters(searchString);
  }
  if (options2.wholeWord) {
    if (!/\B/.test(searchString.charAt(0))) {
      searchString = "\\b" + searchString;
    }
    if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
      searchString = searchString + "\\b";
    }
  }
  let modifiers = "";
  if (options2.global) {
    modifiers += "g";
  }
  if (!options2.matchCase) {
    modifiers += "i";
  }
  if (options2.multiline) {
    modifiers += "m";
  }
  if (options2.unicode) {
    modifiers += "u";
  }
  return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
  if (regexp.source === "^" || regexp.source === "^$" || regexp.source === "$" || regexp.source === "^\\s*$") {
    return false;
  }
  const match2 = regexp.exec("");
  return !!(match2 && regexp.lastIndex === 0);
}
function splitLines(str) {
  return str.split(/\r\n|\r|\n/);
}
function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
  for (let i = startIndex; i >= 0; i--) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function compare(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    const codeA = a.charCodeAt(aStart);
    const codeB = b.charCodeAt(bStart);
    if (codeA < codeB) {
      return -1;
    } else if (codeA > codeB) {
      return 1;
    }
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function compareIgnoreCase(a, b) {
  return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);
    if (codeA === codeB) {
      continue;
    }
    if (codeA >= 128 || codeB >= 128) {
      return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
    }
    if (isLowerAsciiLetter(codeA)) {
      codeA -= 32;
    }
    if (isLowerAsciiLetter(codeB)) {
      codeB -= 32;
    }
    const diff2 = codeA - codeB;
    if (diff2 === 0) {
      continue;
    }
    return diff2;
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function isLowerAsciiLetter(code) {
  return code >= 97 && code <= 122;
}
function equalsIgnoreCase(a, b) {
  return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, candidate) {
  const len = candidate.length;
  return len <= str.length && compareSubstringIgnoreCase(str, candidate, 0, len) === 0;
}
function endsWithIgnoreCase(str, candidate) {
  const len = str.length;
  const start = len - candidate.length;
  return start >= 0 && compareSubstringIgnoreCase(str, candidate, start, len) === 0;
}
function commonPrefixLength(a, b) {
  const len = Math.min(a.length, b.length);
  let i;
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(i) !== b.charCodeAt(i)) {
      return i;
    }
  }
  return len;
}
function isHighSurrogate(charCode) {
  return 55296 <= charCode && charCode <= 56319;
}
function isLowSurrogate(charCode) {
  return 56320 <= charCode && charCode <= 57343;
}
function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);
  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);
    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }
  return charCode;
}
function getPrevCodePoint(str, offset) {
  const charCode = str.charCodeAt(offset - 1);
  if (isLowSurrogate(charCode) && offset > 1) {
    const prevCharCode = str.charCodeAt(offset - 2);
    if (isHighSurrogate(prevCharCode)) {
      return computeCodePoint(prevCharCode, charCode);
    }
  }
  return charCode;
}
var CodePointIterator = class {
  get offset() {
    return this._offset;
  }
  constructor(str, offset = 0) {
    this._str = str;
    this._len = str.length;
    this._offset = offset;
  }
  setOffset(offset) {
    this._offset = offset;
  }
  prevCodePoint() {
    const codePoint = getPrevCodePoint(this._str, this._offset);
    this._offset -= codePoint >= 65536 ? 2 : 1;
    return codePoint;
  }
  nextCodePoint() {
    const codePoint = getNextCodePoint(this._str, this._len, this._offset);
    this._offset += codePoint >= 65536 ? 2 : 1;
    return codePoint;
  }
  eol() {
    return this._offset >= this._len;
  }
};
var GraphemeIterator = class {
  get offset() {
    return this._iterator.offset;
  }
  constructor(str, offset = 0) {
    this._iterator = new CodePointIterator(str, offset);
  }
  nextGraphemeLength() {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const iterator = this._iterator;
    const initialOffset = iterator.offset;
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
    while (!iterator.eol()) {
      const offset = iterator.offset;
      const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
      if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
        iterator.setOffset(offset);
        break;
      }
      graphemeBreakType = nextGraphemeBreakType;
    }
    return iterator.offset - initialOffset;
  }
  prevGraphemeLength() {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const iterator = this._iterator;
    const initialOffset = iterator.offset;
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
    while (iterator.offset > 0) {
      const offset = iterator.offset;
      const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
      if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
        iterator.setOffset(offset);
        break;
      }
      graphemeBreakType = prevGraphemeBreakType;
    }
    return initialOffset - iterator.offset;
  }
  eol() {
    return this._iterator.eol();
  }
};
function nextCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.nextGraphemeLength();
}
var CONTAINS_RTL = void 0;
function makeContainsRtl() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
function containsRTL(str) {
  if (!CONTAINS_RTL) {
    CONTAINS_RTL = makeContainsRtl();
  }
  return CONTAINS_RTL.test(str);
}
var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
function isBasicASCII(str) {
  return IS_BASIC_ASCII.test(str);
}
var UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/;
function containsUnusualLineTerminators(str) {
  return UNUSUAL_LINE_TERMINATORS.test(str);
}
var CSI_SEQUENCE = /(?:\x1b\[|\x9b)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/;
var OSC_SEQUENCE = /(?:\x1b\]|\x9d).*?(?:\x1b\\|\x07|\x9c)/;
var ESC_SEQUENCE = /\x1b(?:[ #%\(\)\*\+\-\.\/]?[a-zA-Z0-9\|}~@])/;
var CONTROL_SEQUENCES = new RegExp("(?:" + [
  CSI_SEQUENCE.source,
  OSC_SEQUENCE.source,
  ESC_SEQUENCE.source
].join("|") + ")", "g");
var UTF8_BOM_CHARACTER = String.fromCharCode(
  65279
  /* CharCode.UTF8_BOM */
);
function startsWithUTF8BOM(str) {
  return !!(str && str.length > 0 && str.charCodeAt(0) === 65279);
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
  if (!target) {
    return false;
  }
  if (ignoreEscapedChars) {
    target = target.replace(/\\./g, "");
  }
  return target.toLowerCase() !== target;
}
function getNLines(str, n = 1) {
  if (n === 0) {
    return "";
  }
  let idx = -1;
  do {
    idx = str.indexOf("\n", idx + 1);
    n--;
  } while (n > 0 && idx >= 0);
  if (idx === -1) {
    return str;
  }
  if (str[idx - 1] === "\r") {
    idx--;
  }
  return str.substr(0, idx);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
  if (breakTypeA === 0) {
    return breakTypeB !== 5 && breakTypeB !== 7;
  }
  if (breakTypeA === 2) {
    if (breakTypeB === 3) {
      return false;
    }
  }
  if (breakTypeA === 4 || breakTypeA === 2 || breakTypeA === 3) {
    return true;
  }
  if (breakTypeB === 4 || breakTypeB === 2 || breakTypeB === 3) {
    return true;
  }
  if (breakTypeA === 8) {
    if (breakTypeB === 8 || breakTypeB === 9 || breakTypeB === 11 || breakTypeB === 12) {
      return false;
    }
  }
  if (breakTypeA === 11 || breakTypeA === 9) {
    if (breakTypeB === 9 || breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeA === 12 || breakTypeA === 10) {
    if (breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeB === 5 || breakTypeB === 13) {
    return false;
  }
  if (breakTypeB === 7) {
    return false;
  }
  if (breakTypeA === 1) {
    return false;
  }
  if (breakTypeA === 13 && breakTypeB === 14) {
    return false;
  }
  if (breakTypeA === 6 && breakTypeB === 6) {
    return false;
  }
  return true;
}
var GraphemeBreakType;
(function(GraphemeBreakType2) {
  GraphemeBreakType2[GraphemeBreakType2["Other"] = 0] = "Other";
  GraphemeBreakType2[GraphemeBreakType2["Prepend"] = 1] = "Prepend";
  GraphemeBreakType2[GraphemeBreakType2["CR"] = 2] = "CR";
  GraphemeBreakType2[GraphemeBreakType2["LF"] = 3] = "LF";
  GraphemeBreakType2[GraphemeBreakType2["Control"] = 4] = "Control";
  GraphemeBreakType2[GraphemeBreakType2["Extend"] = 5] = "Extend";
  GraphemeBreakType2[GraphemeBreakType2["Regional_Indicator"] = 6] = "Regional_Indicator";
  GraphemeBreakType2[GraphemeBreakType2["SpacingMark"] = 7] = "SpacingMark";
  GraphemeBreakType2[GraphemeBreakType2["L"] = 8] = "L";
  GraphemeBreakType2[GraphemeBreakType2["V"] = 9] = "V";
  GraphemeBreakType2[GraphemeBreakType2["T"] = 10] = "T";
  GraphemeBreakType2[GraphemeBreakType2["LV"] = 11] = "LV";
  GraphemeBreakType2[GraphemeBreakType2["LVT"] = 12] = "LVT";
  GraphemeBreakType2[GraphemeBreakType2["ZWJ"] = 13] = "ZWJ";
  GraphemeBreakType2[GraphemeBreakType2["Extended_Pictographic"] = 14] = "Extended_Pictographic";
})(GraphemeBreakType || (GraphemeBreakType = {}));
var GraphemeBreakTree = class _GraphemeBreakTree {
  static {
    this._INSTANCE = null;
  }
  static getInstance() {
    if (!_GraphemeBreakTree._INSTANCE) {
      _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
    }
    return _GraphemeBreakTree._INSTANCE;
  }
  constructor() {
    this._data = getGraphemeBreakRawData();
  }
  getGraphemeBreakType(codePoint) {
    if (codePoint < 32) {
      if (codePoint === 10) {
        return 3;
      }
      if (codePoint === 13) {
        return 2;
      }
      return 4;
    }
    if (codePoint < 127) {
      return 0;
    }
    const data2 = this._data;
    const nodeCount = data2.length / 3;
    let nodeIndex = 1;
    while (nodeIndex <= nodeCount) {
      if (codePoint < data2[3 * nodeIndex]) {
        nodeIndex = 2 * nodeIndex;
      } else if (codePoint > data2[3 * nodeIndex + 1]) {
        nodeIndex = 2 * nodeIndex + 1;
      } else {
        return data2[3 * nodeIndex + 2];
      }
    }
    return 0;
  }
};
function getGraphemeBreakRawData() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
var CodePoint;
(function(CodePoint2) {
  CodePoint2[CodePoint2["zwj"] = 8205] = "zwj";
  CodePoint2[CodePoint2["emojiVariantSelector"] = 65039] = "emojiVariantSelector";
  CodePoint2[CodePoint2["enclosingKeyCap"] = 8419] = "enclosingKeyCap";
  CodePoint2[CodePoint2["space"] = 32] = "space";
})(CodePoint || (CodePoint = {}));
var AmbiguousCharacters = class _AmbiguousCharacters {
  static {
    this.ambiguousCharacterData = new Lazy(() => {
      return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"cs":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"es":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"fr":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"it":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ja":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],"ko":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pt-BR":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ru":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"zh-hans":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],"zh-hant":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}');
    });
  }
  static {
    this.cache = new LRUCachedFunction((localesStr) => {
      const locales = localesStr.split(",");
      function arrayToMap(arr) {
        const result = /* @__PURE__ */ new Map();
        for (let i = 0; i < arr.length; i += 2) {
          result.set(arr[i], arr[i + 1]);
        }
        return result;
      }
      function mergeMaps(map1, map2) {
        const result = new Map(map1);
        for (const [key, value] of map2) {
          result.set(key, value);
        }
        return result;
      }
      function intersectMaps(map1, map2) {
        if (!map1) {
          return map2;
        }
        const result = /* @__PURE__ */ new Map();
        for (const [key, value] of map1) {
          if (map2.has(key)) {
            result.set(key, value);
          }
        }
        return result;
      }
      const data2 = this.ambiguousCharacterData.value;
      let filteredLocales = locales.filter((l) => !l.startsWith("_") && Object.hasOwn(data2, l));
      if (filteredLocales.length === 0) {
        filteredLocales = ["_default"];
      }
      let languageSpecificMap = void 0;
      for (const locale of filteredLocales) {
        const map2 = arrayToMap(data2[locale]);
        languageSpecificMap = intersectMaps(languageSpecificMap, map2);
      }
      const commonMap = arrayToMap(data2["_common"]);
      const map = mergeMaps(commonMap, languageSpecificMap);
      return new _AmbiguousCharacters(map);
    });
  }
  static getInstance(locales) {
    return _AmbiguousCharacters.cache.get(Array.from(locales).join(","));
  }
  static {
    this._locales = new Lazy(() => Object.keys(_AmbiguousCharacters.ambiguousCharacterData.value).filter((k) => !k.startsWith("_")));
  }
  static getLocales() {
    return _AmbiguousCharacters._locales.value;
  }
  constructor(confusableDictionary) {
    this.confusableDictionary = confusableDictionary;
  }
  isAmbiguous(codePoint) {
    return this.confusableDictionary.has(codePoint);
  }
  containsAmbiguousCharacter(str) {
    for (let i = 0; i < str.length; i++) {
      const codePoint = str.codePointAt(i);
      if (typeof codePoint === "number" && this.isAmbiguous(codePoint)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(codePoint) {
    return this.confusableDictionary.get(codePoint);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
var InvisibleCharacters = class _InvisibleCharacters {
  static getRawData() {
    return JSON.parse('{"_common":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],"cs":[173,8203,12288],"de":[173,8203,12288],"es":[8203,12288],"fr":[173,8203,12288],"it":[160,173,12288],"ja":[173],"ko":[173,12288],"pl":[173,8203,12288],"pt-BR":[173,8203,12288],"qps-ploc":[160,173,8203,12288],"ru":[173,12288],"tr":[160,173,8203,12288],"zh-hans":[160,173,8203,12288],"zh-hant":[173,12288]}');
  }
  static {
    this._data = void 0;
  }
  static getData() {
    if (!this._data) {
      this._data = new Set([...Object.values(_InvisibleCharacters.getRawData())].flat());
    }
    return this._data;
  }
  static isInvisibleCharacter(codePoint) {
    return _InvisibleCharacters.getData().has(codePoint);
  }
  static containsInvisibleCharacter(str) {
    for (let i = 0; i < str.length; i++) {
      const codePoint = str.codePointAt(i);
      if (typeof codePoint === "number" && (_InvisibleCharacters.isInvisibleCharacter(codePoint) || codePoint === 32)) {
        return true;
      }
    }
    return false;
  }
  static get codePoints() {
    return _InvisibleCharacters.getData();
  }
};

// out-build/vs/base/common/extpath.js
function isPathSeparator2(code) {
  return code === 47 || code === 92;
}
function toSlashes(osPath) {
  return osPath.replace(/[\\/]/g, posix.sep);
}
function toPosixPath(osPath) {
  if (osPath.indexOf("/") === -1) {
    osPath = toSlashes(osPath);
  }
  if (/^[a-zA-Z]:(\/|$)/.test(osPath)) {
    osPath = "/" + osPath;
  }
  return osPath;
}
function getRoot(path, sep2 = posix.sep) {
  if (!path) {
    return "";
  }
  const len = path.length;
  const firstLetter = path.charCodeAt(0);
  if (isPathSeparator2(firstLetter)) {
    if (isPathSeparator2(path.charCodeAt(1))) {
      if (!isPathSeparator2(path.charCodeAt(2))) {
        let pos2 = 3;
        const start = pos2;
        for (; pos2 < len; pos2++) {
          if (isPathSeparator2(path.charCodeAt(pos2))) {
            break;
          }
        }
        if (start !== pos2 && !isPathSeparator2(path.charCodeAt(pos2 + 1))) {
          pos2 += 1;
          for (; pos2 < len; pos2++) {
            if (isPathSeparator2(path.charCodeAt(pos2))) {
              return path.slice(0, pos2 + 1).replace(/[\\/]/g, sep2);
            }
          }
        }
      }
    }
    return sep2;
  } else if (isWindowsDriveLetter(firstLetter)) {
    if (path.charCodeAt(1) === 58) {
      if (isPathSeparator2(path.charCodeAt(2))) {
        return path.slice(0, 2) + sep2;
      } else {
        return path.slice(0, 2);
      }
    }
  }
  let pos = path.indexOf("://");
  if (pos !== -1) {
    pos += 3;
    for (; pos < len; pos++) {
      if (isPathSeparator2(path.charCodeAt(pos))) {
        return path.slice(0, pos + 1);
      }
    }
  }
  return "";
}
var WINDOWS_INVALID_FILE_CHARS = /[\\/:\*\?"<>\|]/g;
var UNIX_INVALID_FILE_CHARS = /[/]/g;
var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
function isValidBasename(name2, isWindowsOS = isWindows) {
  const invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;
  if (!name2 || name2.length === 0 || /^\s+$/.test(name2)) {
    return false;
  }
  invalidFileChars.lastIndex = 0;
  if (invalidFileChars.test(name2)) {
    return false;
  }
  if (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name2)) {
    return false;
  }
  if (name2 === "." || name2 === "..") {
    return false;
  }
  if (isWindowsOS && name2[name2.length - 1] === ".") {
    return false;
  }
  if (isWindowsOS && name2.length !== name2.trim().length) {
    return false;
  }
  if (name2.length > 255) {
    return false;
  }
  return true;
}
function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {
  if (base === parentCandidate) {
    return true;
  }
  if (!base || !parentCandidate) {
    return false;
  }
  if (parentCandidate.length > base.length) {
    return false;
  }
  if (ignoreCase) {
    const beginsWith = startsWithIgnoreCase(base, parentCandidate);
    if (!beginsWith) {
      return false;
    }
    if (parentCandidate.length === base.length) {
      return true;
    }
    let sepOffset = parentCandidate.length;
    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
      sepOffset--;
    }
    return base.charAt(sepOffset) === separator;
  }
  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
    parentCandidate += separator;
  }
  return base.indexOf(parentCandidate) === 0;
}
function isWindowsDriveLetter(char0) {
  return char0 >= 65 && char0 <= 90 || char0 >= 97 && char0 <= 122;
}
function hasDriveLetter(path, isWindowsOS = isWindows) {
  if (isWindowsOS) {
    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58;
  }
  return false;
}

// out-build/vs/base/common/network.js
var Schemas;
(function(Schemas2) {
  Schemas2.inMemory = "inmemory";
  Schemas2.vscode = "vscode";
  Schemas2.internal = "private";
  Schemas2.walkThrough = "walkThrough";
  Schemas2.walkThroughSnippet = "walkThroughSnippet";
  Schemas2.http = "http";
  Schemas2.https = "https";
  Schemas2.file = "file";
  Schemas2.mailto = "mailto";
  Schemas2.untitled = "untitled";
  Schemas2.data = "data";
  Schemas2.command = "command";
  Schemas2.vscodeRemote = "vscode-remote";
  Schemas2.vscodeRemoteResource = "vscode-remote-resource";
  Schemas2.vscodeManagedRemoteResource = "vscode-managed-remote-resource";
  Schemas2.vscodeUserData = "vscode-userdata";
  Schemas2.vscodeCustomEditor = "vscode-custom-editor";
  Schemas2.vscodeNotebookCell = "vscode-notebook-cell";
  Schemas2.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata";
  Schemas2.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff";
  Schemas2.vscodeNotebookCellOutput = "vscode-notebook-cell-output";
  Schemas2.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff";
  Schemas2.vscodeNotebookMetadata = "vscode-notebook-metadata";
  Schemas2.vscodeInteractiveInput = "vscode-interactive-input";
  Schemas2.vscodeSettings = "vscode-settings";
  Schemas2.vscodeWorkspaceTrust = "vscode-workspace-trust";
  Schemas2.vscodeTerminal = "vscode-terminal";
  Schemas2.vscodeChatCodeBlock = "vscode-chat-code-block";
  Schemas2.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block";
  Schemas2.vscodeChatEditor = "vscode-chat-editor";
  Schemas2.vscodeChatInput = "chatSessionInput";
  Schemas2.vscodeLocalChatSession = "vscode-chat-session";
  Schemas2.webviewPanel = "webview-panel";
  Schemas2.vscodeWebview = "vscode-webview";
  Schemas2.extension = "extension";
  Schemas2.vscodeFileResource = "vscode-file";
  Schemas2.tmp = "tmp";
  Schemas2.vsls = "vsls";
  Schemas2.vscodeSourceControl = "vscode-scm";
  Schemas2.commentsInput = "comment";
  Schemas2.codeSetting = "code-setting";
  Schemas2.outputChannel = "output";
  Schemas2.accessibleView = "accessible-view";
  Schemas2.chatEditingSnapshotScheme = "chat-editing-snapshot-text-model";
  Schemas2.chatEditingModel = "chat-editing-text-model";
  Schemas2.copilotPr = "copilot-pr";
})(Schemas || (Schemas = {}));
function matchesScheme(target, scheme) {
  if (URI.isUri(target)) {
    return equalsIgnoreCase(target.scheme, scheme);
  } else {
    return startsWithIgnoreCase(target, scheme + ":");
  }
}
function matchesSomeScheme(target, ...schemes) {
  return schemes.some((scheme) => matchesScheme(target, scheme));
}
var connectionTokenQueryName = "tkn";
var RemoteAuthoritiesImpl = class {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null);
    this._ports = /* @__PURE__ */ Object.create(null);
    this._connectionTokens = /* @__PURE__ */ Object.create(null);
    this._preferredWebSchema = "http";
    this._delegate = null;
    this._serverRootPath = "/";
  }
  setPreferredWebSchema(schema2) {
    this._preferredWebSchema = schema2;
  }
  setDelegate(delegate) {
    this._delegate = delegate;
  }
  setServerRootPath(product2, serverBasePath) {
    this._serverRootPath = posix.join(serverBasePath ?? "/", getServerProductSegment(product2));
  }
  getServerRootPath() {
    return this._serverRootPath;
  }
  get _remoteResourcesPath() {
    return posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);
  }
  set(authority, host, port) {
    this._hosts[authority] = host;
    this._ports[authority] = port;
  }
  setConnectionToken(authority, connectionToken) {
    this._connectionTokens[authority] = connectionToken;
  }
  getPreferredWebSchema() {
    return this._preferredWebSchema;
  }
  rewrite(uri) {
    if (this._delegate) {
      try {
        return this._delegate(uri);
      } catch (err) {
        onUnexpectedError(err);
        return uri;
      }
    }
    const authority = uri.authority;
    let host = this._hosts[authority];
    if (host && host.indexOf(":") !== -1 && host.indexOf("[") === -1) {
      host = `[${host}]`;
    }
    const port = this._ports[authority];
    const connectionToken = this._connectionTokens[authority];
    let query = `path=${encodeURIComponent(uri.path)}`;
    if (typeof connectionToken === "string") {
      query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
    }
    return URI.from({
      scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
      authority: `${host}:${port}`,
      path: this._remoteResourcesPath,
      query
    });
  }
};
var RemoteAuthorities = new RemoteAuthoritiesImpl();
function getServerProductSegment(product2) {
  return `${product2.quality ?? "oss"}-${product2.commit ?? "dev"}`;
}
var nodeModulesPath = "vs/../../node_modules";
var nodeModulesAsarPath = "vs/../../node_modules.asar";
var VSCODE_AUTHORITY = "vscode-app";
var FileAccessImpl = class _FileAccessImpl {
  static {
    this.FALLBACK_AUTHORITY = VSCODE_AUTHORITY;
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  asBrowserUri(resourcePath) {
    const uri = this.toUri(resourcePath);
    return this.uriToBrowserUri(uri);
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(uri) {
    if (uri.scheme === Schemas.vscodeRemote) {
      return RemoteAuthorities.rewrite(uri);
    }
    if (
      // ...only ever for `file` resources
      uri.scheme === Schemas.file && // ...and we run in native environments
      (isNative || // ...or web worker extensions on desktop
      webWorkerOrigin === `${Schemas.vscodeFileResource}://${_FileAccessImpl.FALLBACK_AUTHORITY}`)
    ) {
      return uri.with({
        scheme: Schemas.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: uri.authority || _FileAccessImpl.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      });
    }
    return uri;
  }
  /**
   * Returns the `file` URI to use in contexts where node.js
   * is responsible for loading.
   */
  asFileUri(resourcePath) {
    const uri = this.toUri(resourcePath);
    return this.uriToFileUri(uri);
  }
  /**
   * Returns the `file` URI to use in contexts where node.js
   * is responsible for loading.
   */
  uriToFileUri(uri) {
    if (uri.scheme === Schemas.vscodeFileResource) {
      return uri.with({
        scheme: Schemas.file,
        // Only preserve the `authority` if it is different from
        // our fallback authority. This ensures we properly preserve
        // Windows UNC paths that come with their own authority.
        authority: uri.authority !== _FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,
        query: null,
        fragment: null
      });
    }
    return uri;
  }
  toUri(uriOrModule) {
    if (URI.isUri(uriOrModule)) {
      return uriOrModule;
    }
    if (globalThis._VSCODE_FILE_ROOT) {
      const rootUriOrPath = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(rootUriOrPath)) {
        return URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);
      }
      const modulePath = join(rootUriOrPath, uriOrModule);
      return URI.file(modulePath);
    }
    throw new Error("Cannot determine URI for module id!");
  }
};
var FileAccess = new FileAccessImpl();
var CacheControlheaders = Object.freeze({
  "Cache-Control": "no-cache, no-store"
});
var DocumentPolicyheaders = Object.freeze({
  "Document-Policy": "include-js-call-stacks-in-crash-reports"
});
var COI;
(function(COI2) {
  const coiHeaders = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  COI2.CoopAndCoep = Object.freeze(coiHeaders.get("3"));
  const coiSearchParamName = "vscode-coi";
  function getHeadersFromQuery(url) {
    let params;
    if (typeof url === "string") {
      params = new URL(url).searchParams;
    } else if (url instanceof URL) {
      params = url.searchParams;
    } else if (URI.isUri(url)) {
      params = new URL(url.toString(true)).searchParams;
    }
    const value = params?.get(coiSearchParamName);
    if (!value) {
      return void 0;
    }
    return coiHeaders.get(value);
  }
  COI2.getHeadersFromQuery = getHeadersFromQuery;
  function addSearchParam(urlOrSearch, coop, coep) {
    if (!globalThis.crossOriginIsolated) {
      return;
    }
    const value = coop && coep ? "3" : coep ? "2" : "1";
    if (urlOrSearch instanceof URLSearchParams) {
      urlOrSearch.set(coiSearchParamName, value);
    } else {
      urlOrSearch[coiSearchParamName] = value;
    }
  }
  COI2.addSearchParam = addSearchParam;
})(COI || (COI = {}));

// out-build/vs/base/common/resources.js
function originalFSPath(uri) {
  return uriToFsPath(uri, true);
}
var ExtUri = class {
  constructor(_ignorePathCasing) {
    this._ignorePathCasing = _ignorePathCasing;
  }
  compare(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return 0;
    }
    return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
  }
  isEqual(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return true;
    }
    if (!uri1 || !uri2) {
      return false;
    }
    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
  }
  getComparisonKey(uri, ignoreFragment = false) {
    return uri.with({
      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : void 0,
      fragment: ignoreFragment ? null : void 0
    }).toString();
  }
  ignorePathCasing(uri) {
    return this._ignorePathCasing(uri);
  }
  isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
    if (base.scheme === parentCandidate.scheme) {
      if (base.scheme === Schemas.file) {
        return isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
      }
      if (isEqualAuthority(base.authority, parentCandidate.authority)) {
        return isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), "/") && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
      }
    }
    return false;
  }
  // --- path math
  joinPath(resource, ...pathFragment) {
    return URI.joinPath(resource, ...pathFragment);
  }
  basenameOrAuthority(resource) {
    return basename2(resource) || resource.authority;
  }
  basename(resource) {
    return posix.basename(resource.path);
  }
  extname(resource) {
    return posix.extname(resource.path);
  }
  dirname(resource) {
    if (resource.path.length === 0) {
      return resource;
    }
    let dirname3;
    if (resource.scheme === Schemas.file) {
      dirname3 = URI.file(dirname(originalFSPath(resource))).path;
    } else {
      dirname3 = posix.dirname(resource.path);
      if (resource.authority && dirname3.length && dirname3.charCodeAt(0) !== 47) {
        console.error(`dirname("${resource.toString})) resulted in a relative path`);
        dirname3 = "/";
      }
    }
    return resource.with({
      path: dirname3
    });
  }
  normalizePath(resource) {
    if (!resource.path.length) {
      return resource;
    }
    let normalizedPath;
    if (resource.scheme === Schemas.file) {
      normalizedPath = URI.file(normalize(originalFSPath(resource))).path;
    } else {
      normalizedPath = posix.normalize(resource.path);
    }
    return resource.with({
      path: normalizedPath
    });
  }
  relativePath(from, to) {
    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
      return void 0;
    }
    if (from.scheme === Schemas.file) {
      const relativePath2 = relative(originalFSPath(from), originalFSPath(to));
      return isWindows ? toSlashes(relativePath2) : relativePath2;
    }
    let fromPath = from.path || "/";
    const toPath = to.path || "/";
    if (this._ignorePathCasing(from)) {
      let i = 0;
      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
            break;
          }
        }
      }
      fromPath = toPath.substr(0, i) + fromPath.substr(i);
    }
    return posix.relative(fromPath, toPath);
  }
  resolvePath(base, path) {
    if (base.scheme === Schemas.file) {
      const newURI = URI.file(resolve(originalFSPath(base), path));
      return base.with({
        authority: newURI.authority,
        path: newURI.path
      });
    }
    path = toPosixPath(path);
    return base.with({
      path: posix.resolve(base.path, path)
    });
  }
  // --- misc
  isAbsolutePath(resource) {
    return !!resource.path && resource.path[0] === "/";
  }
  isEqualAuthority(a1, a2) {
    return a1 === a2 || a1 !== void 0 && a2 !== void 0 && equalsIgnoreCase(a1, a2);
  }
  hasTrailingPathSeparator(resource, sep2 = sep) {
    if (resource.scheme === Schemas.file) {
      const fsp = originalFSPath(resource);
      return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
    } else {
      const p = resource.path;
      return p.length > 1 && p.charCodeAt(p.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath);
    }
  }
  removeTrailingPathSeparator(resource, sep2 = sep) {
    if (hasTrailingPathSeparator(resource, sep2)) {
      return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });
    }
    return resource;
  }
  addTrailingPathSeparator(resource, sep2 = sep) {
    let isRootSep = false;
    if (resource.scheme === Schemas.file) {
      const fsp = originalFSPath(resource);
      isRootSep = fsp !== void 0 && fsp.length === getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
    } else {
      sep2 = "/";
      const p = resource.path;
      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47;
    }
    if (!isRootSep && !hasTrailingPathSeparator(resource, sep2)) {
      return resource.with({ path: resource.path + "/" });
    }
    return resource;
  }
};
var extUri = new ExtUri(() => false);
var extUriBiasedIgnorePathCase = new ExtUri((uri) => {
  return uri.scheme === Schemas.file ? !isLinux : true;
});
var extUriIgnorePathCase = new ExtUri((_) => true);
var isEqual = extUri.isEqual.bind(extUri);
var isEqualOrParent2 = extUri.isEqualOrParent.bind(extUri);
var getComparisonKey = extUri.getComparisonKey.bind(extUri);
var basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
var basename2 = extUri.basename.bind(extUri);
var extname2 = extUri.extname.bind(extUri);
var dirname2 = extUri.dirname.bind(extUri);
var joinPath = extUri.joinPath.bind(extUri);
var normalizePath = extUri.normalizePath.bind(extUri);
var relativePath = extUri.relativePath.bind(extUri);
var resolvePath = extUri.resolvePath.bind(extUri);
var isAbsolutePath = extUri.isAbsolutePath.bind(extUri);
var isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
var hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
var removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
var addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
var DataUri;
(function(DataUri2) {
  DataUri2.META_DATA_LABEL = "label";
  DataUri2.META_DATA_DESCRIPTION = "description";
  DataUri2.META_DATA_SIZE = "size";
  DataUri2.META_DATA_MIME = "mime";
  function parseMetaData(dataUri) {
    const metadata = /* @__PURE__ */ new Map();
    const meta = dataUri.path.substring(dataUri.path.indexOf(";") + 1, dataUri.path.lastIndexOf(";"));
    meta.split(";").forEach((property) => {
      const [key, value] = property.split(":");
      if (key && value) {
        metadata.set(key, value);
      }
    });
    const mime = dataUri.path.substring(0, dataUri.path.indexOf(";"));
    if (mime) {
      metadata.set(DataUri2.META_DATA_MIME, mime);
    }
    return metadata;
  }
  DataUri2.parseMetaData = parseMetaData;
})(DataUri || (DataUri = {}));

// out-build/vs/base/common/symbols.js
var MicrotaskDelay = Symbol("MicrotaskDelay");

// out-build/vs/base/common/async.js
function isThenable(obj) {
  return !!obj && typeof obj.then === "function";
}
function createCancelablePromise(callback) {
  const source = new CancellationTokenSource();
  const thenable = callback(source.token);
  let isCancelled = false;
  const promise = new Promise((resolve2, reject) => {
    const subscription = source.token.onCancellationRequested(() => {
      isCancelled = true;
      subscription.dispose();
      reject(new CancellationError());
    });
    Promise.resolve(thenable).then((value) => {
      subscription.dispose();
      source.dispose();
      if (!isCancelled) {
        resolve2(value);
      } else if (isDisposable(value)) {
        value.dispose();
      }
    }, (err) => {
      subscription.dispose();
      source.dispose();
      reject(err);
    });
  });
  return new class {
    cancel() {
      source.cancel();
      source.dispose();
    }
    then(resolve2, reject) {
      return promise.then(resolve2, reject);
    }
    catch(reject) {
      return this.then(void 0, reject);
    }
    finally(onfinally) {
      return promise.finally(onfinally);
    }
  }();
}
function raceCancellation(promise, token, defaultValue) {
  return new Promise((resolve2, reject) => {
    const ref = token.onCancellationRequested(() => {
      ref.dispose();
      resolve2(defaultValue);
    });
    promise.then(resolve2, reject).finally(() => ref.dispose());
  });
}
function raceCancellationError(promise, token) {
  return new Promise((resolve2, reject) => {
    const ref = token.onCancellationRequested(() => {
      ref.dispose();
      reject(new CancellationError());
    });
    promise.then(resolve2, reject).finally(() => ref.dispose());
  });
}
function asPromise(callback) {
  return new Promise((resolve2, reject) => {
    const item = callback();
    if (isThenable(item)) {
      item.then(resolve2, reject);
    } else {
      resolve2(item);
    }
  });
}
function promiseWithResolvers() {
  let resolve2;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  return { promise, resolve: resolve2, reject };
}
var Throttler = class {
  constructor() {
    this.activePromise = null;
    this.queuedPromise = null;
    this.queuedPromiseFactory = null;
    this.cancellationTokenSource = new CancellationTokenSource();
  }
  queue(promiseFactory) {
    if (this.cancellationTokenSource.token.isCancellationRequested) {
      return Promise.reject(new Error("Throttler is disposed"));
    }
    if (this.activePromise) {
      this.queuedPromiseFactory = promiseFactory;
      if (!this.queuedPromise) {
        const onComplete = () => {
          this.queuedPromise = null;
          if (this.cancellationTokenSource.token.isCancellationRequested) {
            return;
          }
          const result = this.queue(this.queuedPromiseFactory);
          this.queuedPromiseFactory = null;
          return result;
        };
        this.queuedPromise = new Promise((resolve2) => {
          this.activePromise.then(onComplete, onComplete).then(resolve2);
        });
      }
      return new Promise((resolve2, reject) => {
        this.queuedPromise.then(resolve2, reject);
      });
    }
    this.activePromise = promiseFactory(this.cancellationTokenSource.token);
    return new Promise((resolve2, reject) => {
      this.activePromise.then((result) => {
        this.activePromise = null;
        resolve2(result);
      }, (err) => {
        this.activePromise = null;
        reject(err);
      });
    });
  }
  dispose() {
    this.cancellationTokenSource.cancel();
  }
};
var Sequencer = class {
  constructor() {
    this.current = Promise.resolve(null);
  }
  queue(promiseTask) {
    return this.current = this.current.then(() => promiseTask(), () => promiseTask());
  }
};
var SequencerByKey = class {
  constructor() {
    this.promiseMap = /* @__PURE__ */ new Map();
  }
  queue(key, promiseTask) {
    const runningPromise = this.promiseMap.get(key) ?? Promise.resolve();
    const newPromise = runningPromise.catch(() => {
    }).then(promiseTask).finally(() => {
      if (this.promiseMap.get(key) === newPromise) {
        this.promiseMap.delete(key);
      }
    });
    this.promiseMap.set(key, newPromise);
    return newPromise;
  }
  peek(key) {
    return this.promiseMap.get(key) || void 0;
  }
  keys() {
    return this.promiseMap.keys();
  }
};
var timeoutDeferred = (timeout2, fn) => {
  let scheduled = true;
  const handle = setTimeout(() => {
    scheduled = false;
    fn();
  }, timeout2);
  return {
    isTriggered: () => scheduled,
    dispose: () => {
      clearTimeout(handle);
      scheduled = false;
    }
  };
};
var microtaskDeferred = (fn) => {
  let scheduled = true;
  queueMicrotask(() => {
    if (scheduled) {
      scheduled = false;
      fn();
    }
  });
  return {
    isTriggered: () => scheduled,
    dispose: () => {
      scheduled = false;
    }
  };
};
var Delayer = class {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.deferred = null;
    this.completionPromise = null;
    this.doResolve = null;
    this.doReject = null;
    this.task = null;
  }
  trigger(task, delay = this.defaultDelay) {
    this.task = task;
    this.cancelTimeout();
    if (!this.completionPromise) {
      this.completionPromise = new Promise((resolve2, reject) => {
        this.doResolve = resolve2;
        this.doReject = reject;
      }).then(() => {
        this.completionPromise = null;
        this.doResolve = null;
        if (this.task) {
          const task2 = this.task;
          this.task = null;
          return task2();
        }
        return void 0;
      });
    }
    const fn = () => {
      this.deferred = null;
      this.doResolve?.(null);
    };
    this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);
    return this.completionPromise;
  }
  isTriggered() {
    return !!this.deferred?.isTriggered();
  }
  cancel() {
    this.cancelTimeout();
    if (this.completionPromise) {
      this.doReject?.(new CancellationError());
      this.completionPromise = null;
    }
  }
  cancelTimeout() {
    this.deferred?.dispose();
    this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
};
var ThrottledDelayer = class {
  constructor(defaultDelay) {
    this.delayer = new Delayer(defaultDelay);
    this.throttler = new Throttler();
  }
  trigger(promiseFactory, delay) {
    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);
  }
  isTriggered() {
    return this.delayer.isTriggered();
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose();
    this.throttler.dispose();
  }
};
var Barrier = class {
  constructor() {
    this._isOpen = false;
    this._promise = new Promise((c, e) => {
      this._completePromise = c;
    });
  }
  isOpen() {
    return this._isOpen;
  }
  open() {
    this._isOpen = true;
    this._completePromise(true);
  }
  wait() {
    return this._promise;
  }
};
function timeout(millis, token) {
  if (!token) {
    return createCancelablePromise((token2) => timeout(millis, token2));
  }
  return new Promise((resolve2, reject) => {
    const handle = setTimeout(() => {
      disposable.dispose();
      resolve2();
    }, millis);
    const disposable = token.onCancellationRequested(() => {
      clearTimeout(handle);
      disposable.dispose();
      reject(new CancellationError());
    });
  });
}
function disposableTimeout(handler, timeout2 = 0, store) {
  const timer = setTimeout(() => {
    handler();
    if (store) {
      disposable.dispose();
    }
  }, timeout2);
  const disposable = toDisposable(() => {
    clearTimeout(timer);
    store?.delete(disposable);
  });
  store?.add(disposable);
  return disposable;
}
var Limiter = class {
  constructor(maxDegreeOfParalellism) {
    this._size = 0;
    this._isDisposed = false;
    this.maxDegreeOfParalellism = maxDegreeOfParalellism;
    this.outstandingPromises = [];
    this.runningPromises = 0;
    this._onDrained = new Emitter();
  }
  /**
   *
   * @returns A promise that resolved when all work is done (onDrained) or when
   * there is nothing to do
   */
  whenIdle() {
    return this.size > 0 ? Event.toPromise(this.onDrained) : Promise.resolve();
  }
  get onDrained() {
    return this._onDrained.event;
  }
  get size() {
    return this._size;
  }
  queue(factory) {
    if (this._isDisposed) {
      throw new Error("Object has been disposed");
    }
    this._size++;
    return new Promise((c, e) => {
      this.outstandingPromises.push({ factory, c, e });
      this.consume();
    });
  }
  consume() {
    while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
      const iLimitedTask = this.outstandingPromises.shift();
      this.runningPromises++;
      const promise = iLimitedTask.factory();
      promise.then(iLimitedTask.c, iLimitedTask.e);
      promise.then(() => this.consumed(), () => this.consumed());
    }
  }
  consumed() {
    if (this._isDisposed) {
      return;
    }
    this.runningPromises--;
    if (--this._size === 0) {
      this._onDrained.fire();
    }
    if (this.outstandingPromises.length > 0) {
      this.consume();
    }
  }
  clear() {
    if (this._isDisposed) {
      throw new Error("Object has been disposed");
    }
    this.outstandingPromises.length = 0;
    this._size = this.runningPromises;
  }
  dispose() {
    this._isDisposed = true;
    this.outstandingPromises.length = 0;
    this._size = 0;
    this._onDrained.dispose();
  }
};
var Queue = class extends Limiter {
  constructor() {
    super(1);
  }
};
var ResourceQueue = class {
  constructor() {
    this.queues = /* @__PURE__ */ new Map();
    this.drainers = /* @__PURE__ */ new Set();
    this.drainListeners = void 0;
    this.drainListenerCount = 0;
  }
  async whenDrained() {
    if (this.isDrained()) {
      return;
    }
    const promise = new DeferredPromise();
    this.drainers.add(promise);
    return promise.p;
  }
  isDrained() {
    for (const [, queue] of this.queues) {
      if (queue.size > 0) {
        return false;
      }
    }
    return true;
  }
  queueSize(resource, extUri2 = extUri) {
    const key = extUri2.getComparisonKey(resource);
    return this.queues.get(key)?.size ?? 0;
  }
  queueFor(resource, factory, extUri2 = extUri) {
    const key = extUri2.getComparisonKey(resource);
    let queue = this.queues.get(key);
    if (!queue) {
      queue = new Queue();
      const drainListenerId = this.drainListenerCount++;
      const drainListener = Event.once(queue.onDrained)(() => {
        queue?.dispose();
        this.queues.delete(key);
        this.onDidQueueDrain();
        this.drainListeners?.deleteAndDispose(drainListenerId);
        if (this.drainListeners?.size === 0) {
          this.drainListeners.dispose();
          this.drainListeners = void 0;
        }
      });
      if (!this.drainListeners) {
        this.drainListeners = new DisposableMap();
      }
      this.drainListeners.set(drainListenerId, drainListener);
      this.queues.set(key, queue);
    }
    return queue.queue(factory);
  }
  onDidQueueDrain() {
    if (!this.isDrained()) {
      return;
    }
    this.releaseDrainers();
  }
  releaseDrainers() {
    for (const drainer of this.drainers) {
      drainer.complete();
    }
    this.drainers.clear();
  }
  dispose() {
    for (const [, queue] of this.queues) {
      queue.dispose();
    }
    this.queues.clear();
    this.releaseDrainers();
    this.drainListeners?.dispose();
  }
};
var IntervalTimer = class {
  constructor() {
    this.disposable = void 0;
    this.isDisposed = false;
  }
  cancel() {
    this.disposable?.dispose();
    this.disposable = void 0;
  }
  cancelAndSet(runner, interval, context = globalThis) {
    if (this.isDisposed) {
      throw new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);
    }
    this.cancel();
    const handle = context.setInterval(() => {
      runner();
    }, interval);
    this.disposable = toDisposable(() => {
      context.clearInterval(handle);
      this.disposable = void 0;
    });
  }
  dispose() {
    this.cancel();
    this.isDisposed = true;
  }
};
var RunOnceScheduler = class {
  constructor(runner, delay) {
    this.timeoutToken = void 0;
    this.runner = runner;
    this.timeout = delay;
    this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel();
    this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    if (this.isScheduled()) {
      clearTimeout(this.timeoutToken);
      this.timeoutToken = void 0;
    }
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(delay = this.timeout) {
    this.cancel();
    this.timeoutToken = setTimeout(this.timeoutHandler, delay);
  }
  get delay() {
    return this.timeout;
  }
  set delay(value) {
    this.timeout = value;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== void 0;
  }
  flush() {
    if (this.isScheduled()) {
      this.cancel();
      this.doRun();
    }
  }
  onTimeout() {
    this.timeoutToken = void 0;
    if (this.runner) {
      this.doRun();
    }
  }
  doRun() {
    this.runner?.();
  }
};
var runWhenGlobalIdle;
var _runWhenIdle;
(function() {
  const safeGlobal = globalThis;
  if (typeof safeGlobal.requestIdleCallback !== "function" || typeof safeGlobal.cancelIdleCallback !== "function") {
    _runWhenIdle = (_targetWindow, runner, timeout2) => {
      setTimeout0(() => {
        if (disposed) {
          return;
        }
        const end = Date.now() + 15;
        const deadline = {
          didTimeout: true,
          timeRemaining() {
            return Math.max(0, end - Date.now());
          }
        };
        runner(Object.freeze(deadline));
      });
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
        }
      };
    };
  } else {
    _runWhenIdle = (targetWindow, runner, timeout2) => {
      const handle = targetWindow.requestIdleCallback(runner, typeof timeout2 === "number" ? { timeout: timeout2 } : void 0);
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
          targetWindow.cancelIdleCallback(handle);
        }
      };
    };
  }
  runWhenGlobalIdle = (runner, timeout2) => _runWhenIdle(globalThis, runner, timeout2);
})();
var AbstractIdleValue = class {
  constructor(targetWindow, executor) {
    this._didRun = false;
    this._executor = () => {
      try {
        this._value = executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    };
    this._handle = _runWhenIdle(targetWindow, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (!this._didRun) {
      this._handle.dispose();
      this._executor();
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
};
var GlobalIdleValue = class extends AbstractIdleValue {
  constructor(executor) {
    super(globalThis, executor);
  }
};
var DeferredOutcome;
(function(DeferredOutcome2) {
  DeferredOutcome2[DeferredOutcome2["Resolved"] = 0] = "Resolved";
  DeferredOutcome2[DeferredOutcome2["Rejected"] = 1] = "Rejected";
})(DeferredOutcome || (DeferredOutcome = {}));
var DeferredPromise = class _DeferredPromise {
  static fromPromise(promise) {
    const deferred = new _DeferredPromise();
    deferred.settleWith(promise);
    return deferred;
  }
  get isRejected() {
    return this.outcome?.outcome === 1;
  }
  get isResolved() {
    return this.outcome?.outcome === 0;
  }
  get isSettled() {
    return !!this.outcome;
  }
  get value() {
    return this.outcome?.outcome === 0 ? this.outcome?.value : void 0;
  }
  constructor() {
    this.p = new Promise((c, e) => {
      this.completeCallback = c;
      this.errorCallback = e;
    });
  }
  complete(value) {
    if (this.isSettled) {
      return Promise.resolve();
    }
    return new Promise((resolve2) => {
      this.completeCallback(value);
      this.outcome = { outcome: 0, value };
      resolve2();
    });
  }
  error(err) {
    if (this.isSettled) {
      return Promise.resolve();
    }
    return new Promise((resolve2) => {
      this.errorCallback(err);
      this.outcome = { outcome: 1, value: err };
      resolve2();
    });
  }
  settleWith(promise) {
    return promise.then((value) => this.complete(value), (error) => this.error(error));
  }
  cancel() {
    return this.error(new CancellationError());
  }
};
var Promises;
(function(Promises2) {
  async function settled(promises) {
    let firstError = void 0;
    const result = await Promise.all(promises.map((promise) => promise.then((value) => value, (error) => {
      if (!firstError) {
        firstError = error;
      }
      return void 0;
    })));
    if (typeof firstError !== "undefined") {
      throw firstError;
    }
    return result;
  }
  Promises2.settled = settled;
  function withAsyncBody(bodyFn) {
    return new Promise(async (resolve2, reject) => {
      try {
        await bodyFn(resolve2, reject);
      } catch (error) {
        reject(error);
      }
    });
  }
  Promises2.withAsyncBody = withAsyncBody;
})(Promises || (Promises = {}));
var AsyncIterableSourceState;
(function(AsyncIterableSourceState2) {
  AsyncIterableSourceState2[AsyncIterableSourceState2["Initial"] = 0] = "Initial";
  AsyncIterableSourceState2[AsyncIterableSourceState2["DoneOK"] = 1] = "DoneOK";
  AsyncIterableSourceState2[AsyncIterableSourceState2["DoneError"] = 2] = "DoneError";
})(AsyncIterableSourceState || (AsyncIterableSourceState = {}));
var AsyncIterableObject = class _AsyncIterableObject {
  static fromArray(items) {
    return new _AsyncIterableObject((writer) => {
      writer.emitMany(items);
    });
  }
  static fromPromise(promise) {
    return new _AsyncIterableObject(async (emitter) => {
      emitter.emitMany(await promise);
    });
  }
  static fromPromisesResolveOrder(promises) {
    return new _AsyncIterableObject(async (emitter) => {
      await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));
    });
  }
  static merge(iterables) {
    return new _AsyncIterableObject(async (emitter) => {
      await Promise.all(iterables.map(async (iterable) => {
        for await (const item of iterable) {
          emitter.emitOne(item);
        }
      }));
    });
  }
  static {
    this.EMPTY = _AsyncIterableObject.fromArray([]);
  }
  constructor(executor, onReturn) {
    this._state = 0;
    this._results = [];
    this._error = null;
    this._onReturn = onReturn;
    this._onStateChanged = new Emitter();
    queueMicrotask(async () => {
      const writer = {
        emitOne: (item) => this.emitOne(item),
        emitMany: (items) => this.emitMany(items),
        reject: (error) => this.reject(error)
      };
      try {
        await Promise.resolve(executor(writer));
        this.resolve();
      } catch (err) {
        this.reject(err);
      } finally {
        writer.emitOne = void 0;
        writer.emitMany = void 0;
        writer.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let i = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2) {
            throw this._error;
          }
          if (i < this._results.length) {
            return { done: false, value: this._results[i++] };
          }
          if (this._state === 1) {
            return { done: true, value: void 0 };
          }
          await Event.toPromise(this._onStateChanged.event);
        } while (true);
      },
      return: async () => {
        this._onReturn?.();
        return { done: true, value: void 0 };
      }
    };
  }
  static map(iterable, mapFn) {
    return new _AsyncIterableObject(async (emitter) => {
      for await (const item of iterable) {
        emitter.emitOne(mapFn(item));
      }
    });
  }
  map(mapFn) {
    return _AsyncIterableObject.map(this, mapFn);
  }
  static filter(iterable, filterFn) {
    return new _AsyncIterableObject(async (emitter) => {
      for await (const item of iterable) {
        if (filterFn(item)) {
          emitter.emitOne(item);
        }
      }
    });
  }
  filter(filterFn) {
    return _AsyncIterableObject.filter(this, filterFn);
  }
  static coalesce(iterable) {
    return _AsyncIterableObject.filter(iterable, (item) => !!item);
  }
  coalesce() {
    return _AsyncIterableObject.coalesce(this);
  }
  static async toPromise(iterable) {
    const result = [];
    for await (const item of iterable) {
      result.push(item);
    }
    return result;
  }
  toPromise() {
    return _AsyncIterableObject.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(value) {
    if (this._state !== 0) {
      return;
    }
    this._results.push(value);
    this._onStateChanged.fire();
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(values) {
    if (this._state !== 0) {
      return;
    }
    this._results = this._results.concat(values);
    this._onStateChanged.fire();
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    if (this._state !== 0) {
      return;
    }
    this._state = 1;
    this._onStateChanged.fire();
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(error) {
    if (this._state !== 0) {
      return;
    }
    this._state = 2;
    this._error = error;
    this._onStateChanged.fire();
  }
};
var AsyncIterableSource = class {
  /**
   *
   * @param onReturn A function that will be called when consuming the async iterable
   * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.
   * This is NOT called when resolving this source by its owner.
   */
  constructor(onReturn) {
    this._deferred = new DeferredPromise();
    this._asyncIterable = new AsyncIterableObject((emitter) => {
      if (earlyError) {
        emitter.reject(earlyError);
        return;
      }
      if (earlyItems) {
        emitter.emitMany(earlyItems);
      }
      this._errorFn = (error) => emitter.reject(error);
      this._emitOneFn = (item) => emitter.emitOne(item);
      this._emitManyFn = (items) => emitter.emitMany(items);
      return this._deferred.p;
    }, onReturn);
    let earlyError;
    let earlyItems;
    this._errorFn = (error) => {
      if (!earlyError) {
        earlyError = error;
      }
    };
    this._emitOneFn = (item) => {
      if (!earlyItems) {
        earlyItems = [];
      }
      earlyItems.push(item);
    };
    this._emitManyFn = (items) => {
      if (!earlyItems) {
        earlyItems = items.slice();
      } else {
        items.forEach((item) => earlyItems.push(item));
      }
    };
  }
  get asyncIterable() {
    return this._asyncIterable;
  }
  resolve() {
    this._deferred.complete();
  }
  reject(error) {
    this._errorFn(error);
    this._deferred.complete();
  }
  emitOne(item) {
    this._emitOneFn(item);
  }
  emitMany(items) {
    this._emitManyFn(items);
  }
};
var ProducerConsumer = class {
  constructor() {
    this._unsatisfiedConsumers = [];
    this._unconsumedValues = [];
  }
  get hasFinalValue() {
    return !!this._finalValue;
  }
  produce(value) {
    this._ensureNoFinalValue();
    if (this._unsatisfiedConsumers.length > 0) {
      const deferred = this._unsatisfiedConsumers.shift();
      this._resolveOrRejectDeferred(deferred, value);
    } else {
      this._unconsumedValues.push(value);
    }
  }
  produceFinal(value) {
    this._ensureNoFinalValue();
    this._finalValue = value;
    for (const deferred of this._unsatisfiedConsumers) {
      this._resolveOrRejectDeferred(deferred, value);
    }
    this._unsatisfiedConsumers.length = 0;
  }
  _ensureNoFinalValue() {
    if (this._finalValue) {
      throw new BugIndicatingError("ProducerConsumer: cannot produce after final value has been set");
    }
  }
  _resolveOrRejectDeferred(deferred, value) {
    if (value.ok) {
      deferred.complete(value.value);
    } else {
      deferred.error(value.error);
    }
  }
  consume() {
    if (this._unconsumedValues.length > 0 || this._finalValue) {
      const value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift() : this._finalValue;
      if (value.ok) {
        return Promise.resolve(value.value);
      } else {
        return Promise.reject(value.error);
      }
    } else {
      const deferred = new DeferredPromise();
      this._unsatisfiedConsumers.push(deferred);
      return deferred.p;
    }
  }
};
var AsyncIterableProducer = class _AsyncIterableProducer {
  constructor(executor, _onReturn) {
    this._onReturn = _onReturn;
    this._producerConsumer = new ProducerConsumer();
    this._iterator = {
      next: () => this._producerConsumer.consume(),
      return: () => {
        this._onReturn?.();
        return Promise.resolve({ done: true, value: void 0 });
      },
      throw: async (e) => {
        this._finishError(e);
        return { done: true, value: void 0 };
      }
    };
    queueMicrotask(async () => {
      const p = executor({
        emitOne: (value) => this._producerConsumer.produce({ ok: true, value: { done: false, value } }),
        emitMany: (values) => {
          for (const value of values) {
            this._producerConsumer.produce({ ok: true, value: { done: false, value } });
          }
        },
        reject: (error) => this._finishError(error)
      });
      if (!this._producerConsumer.hasFinalValue) {
        try {
          await p;
          this._finishOk();
        } catch (error) {
          this._finishError(error);
        }
      }
    });
  }
  static fromArray(items) {
    return new _AsyncIterableProducer((writer) => {
      writer.emitMany(items);
    });
  }
  static fromPromise(promise) {
    return new _AsyncIterableProducer(async (emitter) => {
      emitter.emitMany(await promise);
    });
  }
  static fromPromisesResolveOrder(promises) {
    return new _AsyncIterableProducer(async (emitter) => {
      await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));
    });
  }
  static merge(iterables) {
    return new _AsyncIterableProducer(async (emitter) => {
      await Promise.all(iterables.map(async (iterable) => {
        for await (const item of iterable) {
          emitter.emitOne(item);
        }
      }));
    });
  }
  static {
    this.EMPTY = _AsyncIterableProducer.fromArray([]);
  }
  static map(iterable, mapFn) {
    return new _AsyncIterableProducer(async (emitter) => {
      for await (const item of iterable) {
        emitter.emitOne(mapFn(item));
      }
    });
  }
  static tee(iterable) {
    let emitter1;
    let emitter2;
    const defer = new DeferredPromise();
    const start = async () => {
      if (!emitter1 || !emitter2) {
        return;
      }
      try {
        for await (const item of iterable) {
          emitter1.emitOne(item);
          emitter2.emitOne(item);
        }
      } catch (err) {
        emitter1.reject(err);
        emitter2.reject(err);
      } finally {
        defer.complete();
      }
    };
    const p1 = new _AsyncIterableProducer(async (emitter) => {
      emitter1 = emitter;
      start();
      return defer.p;
    });
    const p2 = new _AsyncIterableProducer(async (emitter) => {
      emitter2 = emitter;
      start();
      return defer.p;
    });
    return [p1, p2];
  }
  map(mapFn) {
    return _AsyncIterableProducer.map(this, mapFn);
  }
  static coalesce(iterable) {
    return _AsyncIterableProducer.filter(iterable, (item) => !!item);
  }
  coalesce() {
    return _AsyncIterableProducer.coalesce(this);
  }
  static filter(iterable, filterFn) {
    return new _AsyncIterableProducer(async (emitter) => {
      for await (const item of iterable) {
        if (filterFn(item)) {
          emitter.emitOne(item);
        }
      }
    });
  }
  filter(filterFn) {
    return _AsyncIterableProducer.filter(this, filterFn);
  }
  _finishOk() {
    if (!this._producerConsumer.hasFinalValue) {
      this._producerConsumer.produceFinal({ ok: true, value: { done: true, value: void 0 } });
    }
  }
  _finishError(error) {
    if (!this._producerConsumer.hasFinalValue) {
      this._producerConsumer.produceFinal({ ok: false, error });
    }
  }
  [Symbol.asyncIterator]() {
    return this._iterator;
  }
};
var AsyncReaderEndOfStream = Symbol("AsyncReaderEndOfStream");

// out-build/vs/base/common/uriIpc.js
var DefaultURITransformer = new class {
  transformIncoming(uri) {
    return uri;
  }
  transformOutgoing(uri) {
    return uri;
  }
  transformOutgoingURI(uri) {
    return uri;
  }
  transformOutgoingScheme(scheme) {
    return scheme;
  }
}();
function _transformIncomingURIs(obj, transformer, revive2, depth) {
  if (!obj || depth > 200) {
    return null;
  }
  if (typeof obj === "object") {
    if (obj.$mid === 1) {
      return revive2 ? URI.revive(transformer.transformIncoming(obj)) : transformer.transformIncoming(obj);
    }
    if (obj instanceof VSBuffer) {
      return null;
    }
    for (const key in obj) {
      if (Object.hasOwnProperty.call(obj, key)) {
        const r = _transformIncomingURIs(obj[key], transformer, revive2, depth + 1);
        if (r !== null) {
          obj[key] = r;
        }
      }
    }
  }
  return null;
}
function transformIncomingURIs(obj, transformer) {
  const result = _transformIncomingURIs(obj, transformer, false, 0);
  if (result === null) {
    return obj;
  }
  return result;
}

// out-build/vs/workbench/services/extensions/common/lazyPromise.js
var LazyPromise = class {
  constructor() {
    this._actual = null;
    this._actualOk = null;
    this._actualErr = null;
    this._hasValue = false;
    this._value = null;
    this._hasErr = false;
    this._err = null;
  }
  get [Symbol.toStringTag]() {
    return this.toString();
  }
  _ensureActual() {
    if (!this._actual) {
      this._actual = new Promise((c, e) => {
        this._actualOk = c;
        this._actualErr = e;
        if (this._hasValue) {
          this._actualOk(this._value);
        }
        if (this._hasErr) {
          this._actualErr(this._err);
        }
      });
    }
    return this._actual;
  }
  resolveOk(value) {
    if (this._hasValue || this._hasErr) {
      return;
    }
    this._hasValue = true;
    this._value = value;
    if (this._actual) {
      this._actualOk(value);
    }
  }
  resolveErr(err) {
    if (this._hasValue || this._hasErr) {
      return;
    }
    this._hasErr = true;
    this._err = err;
    if (this._actual) {
      this._actualErr(err);
    } else {
      onUnexpectedError(err);
    }
  }
  then(success, error) {
    return this._ensureActual().then(success, error);
  }
  catch(error) {
    return this._ensureActual().then(void 0, error);
  }
  finally(callback) {
    return this._ensureActual().finally(callback);
  }
};
var CanceledLazyPromise = class extends LazyPromise {
  constructor() {
    super();
    this._hasErr = true;
    this._err = new CancellationError();
  }
};

// out-build/vs/workbench/services/extensions/common/rpcProtocol.js
var _a3;
function safeStringify(obj, replacer2) {
  try {
    return JSON.stringify(obj, replacer2);
  } catch (err) {
    return "null";
  }
}
var refSymbolName = "$$ref$$";
var undefinedRef = { [refSymbolName]: -1 };
function stringifyJsonWithBufferRefs(obj, replacer2 = null, useSafeStringify = false) {
  const foundBuffers = [];
  const serialized = (useSafeStringify ? safeStringify : JSON.stringify)(obj, (key, value) => {
    if (typeof value === "undefined") {
      return undefinedRef;
    } else if (typeof value === "object") {
      if (value instanceof VSBuffer) {
        const bufferIndex = foundBuffers.push(value) - 1;
        return { [refSymbolName]: bufferIndex };
      }
      if (replacer2) {
        return replacer2(key, value);
      }
    }
    return value;
  });
  return {
    jsonString: serialized,
    referencedBuffers: foundBuffers
  };
}
function parseJsonAndRestoreBufferRefs(jsonString, buffers, uriTransformer) {
  return JSON.parse(jsonString, (_key, value) => {
    if (value) {
      const ref = value[refSymbolName];
      if (typeof ref === "number") {
        return buffers[ref];
      }
      if (uriTransformer && value.$mid === 1) {
        return uriTransformer.transformIncoming(value);
      }
    }
    return value;
  });
}
function stringify(obj, replacer2) {
  return JSON.stringify(obj, replacer2);
}
function createURIReplacer(transformer) {
  if (!transformer) {
    return null;
  }
  return (key, value) => {
    if (value && value.$mid === 1) {
      return transformer.transformOutgoing(value);
    }
    return value;
  };
}
var RequestInitiator;
(function(RequestInitiator2) {
  RequestInitiator2[RequestInitiator2["LocalSide"] = 0] = "LocalSide";
  RequestInitiator2[RequestInitiator2["OtherSide"] = 1] = "OtherSide";
})(RequestInitiator || (RequestInitiator = {}));
var ResponsiveState;
(function(ResponsiveState2) {
  ResponsiveState2[ResponsiveState2["Responsive"] = 0] = "Responsive";
  ResponsiveState2[ResponsiveState2["Unresponsive"] = 1] = "Unresponsive";
})(ResponsiveState || (ResponsiveState = {}));
var noop = () => {
};
var _RPCProtocolSymbol = Symbol.for("rpcProtocol");
var _RPCProxySymbol = Symbol.for("rpcProxy");
var RPCProtocol = class _RPCProtocol extends Disposable {
  static {
    _a3 = _RPCProtocolSymbol;
  }
  static {
    this.UNRESPONSIVE_TIME = 3 * 1e3;
  }
  // 3s
  constructor(protocol, logger = null, transformer = null) {
    super();
    this[_a3] = true;
    this._onDidChangeResponsiveState = this._register(new Emitter());
    this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;
    this._protocol = protocol;
    this._logger = logger;
    this._uriTransformer = transformer;
    this._uriReplacer = createURIReplacer(this._uriTransformer);
    this._isDisposed = false;
    this._locals = [];
    this._proxies = [];
    for (let i = 0, len = ProxyIdentifier.count; i < len; i++) {
      this._locals[i] = null;
      this._proxies[i] = null;
    }
    this._lastMessageId = 0;
    this._cancelInvokedHandlers = /* @__PURE__ */ Object.create(null);
    this._pendingRPCReplies = {};
    this._responsiveState = 0;
    this._unacknowledgedCount = 0;
    this._unresponsiveTime = 0;
    this._asyncCheckUresponsive = this._register(new RunOnceScheduler(() => this._checkUnresponsive(), 1e3));
    this._register(this._protocol.onMessage((msg) => this._receiveOneMessage(msg)));
  }
  dispose() {
    this._isDisposed = true;
    Object.keys(this._pendingRPCReplies).forEach((msgId) => {
      const pending = this._pendingRPCReplies[msgId];
      delete this._pendingRPCReplies[msgId];
      pending.resolveErr(canceled());
    });
    super.dispose();
  }
  drain() {
    if (typeof this._protocol.drain === "function") {
      return this._protocol.drain();
    }
    return Promise.resolve();
  }
  _onWillSendRequest(req) {
    if (this._unacknowledgedCount === 0) {
      this._unresponsiveTime = Date.now() + _RPCProtocol.UNRESPONSIVE_TIME;
    }
    this._unacknowledgedCount++;
    if (!this._asyncCheckUresponsive.isScheduled()) {
      this._asyncCheckUresponsive.schedule();
    }
  }
  _onDidReceiveAcknowledge(req) {
    this._unresponsiveTime = Date.now() + _RPCProtocol.UNRESPONSIVE_TIME;
    this._unacknowledgedCount--;
    if (this._unacknowledgedCount === 0) {
      this._asyncCheckUresponsive.cancel();
    }
    this._setResponsiveState(
      0
      /* ResponsiveState.Responsive */
    );
  }
  _checkUnresponsive() {
    if (this._unacknowledgedCount === 0) {
      return;
    }
    if (Date.now() > this._unresponsiveTime) {
      this._setResponsiveState(
        1
        /* ResponsiveState.Unresponsive */
      );
    } else {
      this._asyncCheckUresponsive.schedule();
    }
  }
  _setResponsiveState(newResponsiveState) {
    if (this._responsiveState === newResponsiveState) {
      return;
    }
    this._responsiveState = newResponsiveState;
    this._onDidChangeResponsiveState.fire(this._responsiveState);
  }
  get responsiveState() {
    return this._responsiveState;
  }
  transformIncomingURIs(obj) {
    if (!this._uriTransformer) {
      return obj;
    }
    return transformIncomingURIs(obj, this._uriTransformer);
  }
  getProxy(identifier) {
    const { nid: rpcId, sid } = identifier;
    if (!this._proxies[rpcId]) {
      this._proxies[rpcId] = this._createProxy(rpcId, sid);
    }
    return this._proxies[rpcId];
  }
  _createProxy(rpcId, debugName) {
    const handler = {
      get: (target, name2) => {
        if (typeof name2 === "string" && !target[name2] && name2.charCodeAt(0) === 36) {
          target[name2] = (...myArgs) => {
            return this._remoteCall(rpcId, name2, myArgs);
          };
        }
        if (name2 === _RPCProxySymbol) {
          return debugName;
        }
        return target[name2];
      }
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), handler);
  }
  set(identifier, value) {
    this._locals[identifier.nid] = value;
    return value;
  }
  assertRegistered(identifiers2) {
    for (let i = 0, len = identifiers2.length; i < len; i++) {
      const identifier = identifiers2[i];
      if (!this._locals[identifier.nid]) {
        throw new Error(`Missing proxy instance ${identifier.sid}`);
      }
    }
  }
  _receiveOneMessage(rawmsg) {
    if (this._isDisposed) {
      return;
    }
    const msgLength = rawmsg.byteLength;
    const buff = MessageBuffer.read(rawmsg, 0);
    const messageType = buff.readUInt8();
    const req = buff.readUInt32();
    switch (messageType) {
      case 1:
      case 2: {
        let { rpcId, method, args } = MessageIO.deserializeRequestJSONArgs(buff);
        if (this._uriTransformer) {
          args = transformIncomingURIs(args, this._uriTransformer);
        }
        this._receiveRequest(msgLength, req, rpcId, method, args, messageType === 2);
        break;
      }
      case 3:
      case 4: {
        let { rpcId, method, args } = MessageIO.deserializeRequestMixedArgs(buff);
        if (this._uriTransformer) {
          args = transformIncomingURIs(args, this._uriTransformer);
        }
        this._receiveRequest(msgLength, req, rpcId, method, args, messageType === 4);
        break;
      }
      case 5: {
        this._logger?.logIncoming(msgLength, req, 0, `ack`);
        this._onDidReceiveAcknowledge(req);
        break;
      }
      case 6: {
        this._receiveCancel(msgLength, req);
        break;
      }
      case 7: {
        this._receiveReply(msgLength, req, void 0);
        break;
      }
      case 9: {
        let value = MessageIO.deserializeReplyOKJSON(buff);
        if (this._uriTransformer) {
          value = transformIncomingURIs(value, this._uriTransformer);
        }
        this._receiveReply(msgLength, req, value);
        break;
      }
      case 10: {
        const value = MessageIO.deserializeReplyOKJSONWithBuffers(buff, this._uriTransformer);
        this._receiveReply(msgLength, req, value);
        break;
      }
      case 8: {
        const value = MessageIO.deserializeReplyOKVSBuffer(buff);
        this._receiveReply(msgLength, req, value);
        break;
      }
      case 11: {
        let err = MessageIO.deserializeReplyErrError(buff);
        if (this._uriTransformer) {
          err = transformIncomingURIs(err, this._uriTransformer);
        }
        this._receiveReplyErr(msgLength, req, err);
        break;
      }
      case 12: {
        this._receiveReplyErr(msgLength, req, void 0);
        break;
      }
      default:
        console.error(`received unexpected message`);
        console.error(rawmsg);
    }
  }
  _receiveRequest(msgLength, req, rpcId, method, args, usesCancellationToken) {
    this._logger?.logIncoming(msgLength, req, 1, `receiveRequest ${getStringIdentifierForProxy(rpcId)}.${method}(`, args);
    const callId = String(req);
    let promise;
    let cancel;
    if (usesCancellationToken) {
      const cancellationTokenSource = new CancellationTokenSource();
      args.push(cancellationTokenSource.token);
      promise = this._invokeHandler(rpcId, method, args);
      cancel = () => cancellationTokenSource.cancel();
    } else {
      promise = this._invokeHandler(rpcId, method, args);
      cancel = noop;
    }
    this._cancelInvokedHandlers[callId] = cancel;
    const msg = MessageIO.serializeAcknowledged(req);
    this._logger?.logOutgoing(msg.byteLength, req, 1, `ack`);
    this._protocol.send(msg);
    promise.then((r) => {
      delete this._cancelInvokedHandlers[callId];
      const msg2 = MessageIO.serializeReplyOK(req, r, this._uriReplacer);
      this._logger?.logOutgoing(msg2.byteLength, req, 1, `reply:`, r);
      this._protocol.send(msg2);
    }, (err) => {
      delete this._cancelInvokedHandlers[callId];
      const msg2 = MessageIO.serializeReplyErr(req, err);
      this._logger?.logOutgoing(msg2.byteLength, req, 1, `replyErr:`, err);
      this._protocol.send(msg2);
    });
  }
  _receiveCancel(msgLength, req) {
    this._logger?.logIncoming(msgLength, req, 1, `receiveCancel`);
    const callId = String(req);
    this._cancelInvokedHandlers[callId]?.();
  }
  _receiveReply(msgLength, req, value) {
    this._logger?.logIncoming(msgLength, req, 0, `receiveReply:`, value);
    const callId = String(req);
    if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
      return;
    }
    const pendingReply = this._pendingRPCReplies[callId];
    delete this._pendingRPCReplies[callId];
    pendingReply.resolveOk(value);
  }
  _receiveReplyErr(msgLength, req, value) {
    this._logger?.logIncoming(msgLength, req, 0, `receiveReplyErr:`, value);
    const callId = String(req);
    if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
      return;
    }
    const pendingReply = this._pendingRPCReplies[callId];
    delete this._pendingRPCReplies[callId];
    let err = void 0;
    if (value) {
      if (value.$isError) {
        err = new Error();
        err.name = value.name;
        err.message = value.message;
        err.stack = value.stack;
      } else {
        err = value;
      }
    }
    pendingReply.resolveErr(err);
  }
  _invokeHandler(rpcId, methodName, args) {
    try {
      return Promise.resolve(this._doInvokeHandler(rpcId, methodName, args));
    } catch (err) {
      return Promise.reject(err);
    }
  }
  _doInvokeHandler(rpcId, methodName, args) {
    const actor = this._locals[rpcId];
    if (!actor) {
      throw new Error("Unknown actor " + getStringIdentifierForProxy(rpcId));
    }
    const method = actor[methodName];
    if (typeof method !== "function") {
      throw new Error("Unknown method " + methodName + " on actor " + getStringIdentifierForProxy(rpcId));
    }
    return method.apply(actor, args);
  }
  _remoteCall(rpcId, methodName, args) {
    if (this._isDisposed) {
      return new CanceledLazyPromise();
    }
    let cancellationToken = null;
    if (args.length > 0 && CancellationToken.isCancellationToken(args[args.length - 1])) {
      cancellationToken = args.pop();
    }
    if (cancellationToken && cancellationToken.isCancellationRequested) {
      return Promise.reject(canceled());
    }
    const serializedRequestArguments = MessageIO.serializeRequestArguments(args, this._uriReplacer);
    const req = ++this._lastMessageId;
    const callId = String(req);
    const result = new LazyPromise();
    const disposable = new DisposableStore();
    if (cancellationToken) {
      disposable.add(cancellationToken.onCancellationRequested(() => {
        const msg2 = MessageIO.serializeCancel(req);
        this._logger?.logOutgoing(msg2.byteLength, req, 0, `cancel`);
        this._protocol.send(msg2);
      }));
    }
    this._pendingRPCReplies[callId] = new PendingRPCReply(result, disposable);
    this._onWillSendRequest(req);
    const msg = MessageIO.serializeRequest(req, rpcId, methodName, serializedRequestArguments, !!cancellationToken);
    this._logger?.logOutgoing(msg.byteLength, req, 0, `request: ${getStringIdentifierForProxy(rpcId)}.${methodName}(`, args);
    this._protocol.send(msg);
    return result;
  }
};
var PendingRPCReply = class {
  constructor(_promise, _disposable) {
    this._promise = _promise;
    this._disposable = _disposable;
  }
  resolveOk(value) {
    this._promise.resolveOk(value);
    this._disposable.dispose();
  }
  resolveErr(err) {
    this._promise.resolveErr(err);
    this._disposable.dispose();
  }
};
var MessageBuffer = class _MessageBuffer {
  static alloc(type, req, messageSize) {
    const result = new _MessageBuffer(VSBuffer.alloc(
      messageSize + 1 + 4
      /* req */
    ), 0);
    result.writeUInt8(type);
    result.writeUInt32(req);
    return result;
  }
  static read(buff, offset) {
    return new _MessageBuffer(buff, offset);
  }
  get buffer() {
    return this._buff;
  }
  constructor(buff, offset) {
    this._buff = buff;
    this._offset = offset;
  }
  static sizeUInt8() {
    return 1;
  }
  static {
    this.sizeUInt32 = 4;
  }
  writeUInt8(n) {
    this._buff.writeUInt8(n, this._offset);
    this._offset += 1;
  }
  readUInt8() {
    const n = this._buff.readUInt8(this._offset);
    this._offset += 1;
    return n;
  }
  writeUInt32(n) {
    this._buff.writeUInt32BE(n, this._offset);
    this._offset += 4;
  }
  readUInt32() {
    const n = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    return n;
  }
  static sizeShortString(str) {
    return 1 + str.byteLength;
  }
  writeShortString(str) {
    this._buff.writeUInt8(str.byteLength, this._offset);
    this._offset += 1;
    this._buff.set(str, this._offset);
    this._offset += str.byteLength;
  }
  readShortString() {
    const strByteLength = this._buff.readUInt8(this._offset);
    this._offset += 1;
    const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
    const str = strBuff.toString();
    this._offset += strByteLength;
    return str;
  }
  static sizeLongString(str) {
    return 4 + str.byteLength;
  }
  writeLongString(str) {
    this._buff.writeUInt32BE(str.byteLength, this._offset);
    this._offset += 4;
    this._buff.set(str, this._offset);
    this._offset += str.byteLength;
  }
  readLongString() {
    const strByteLength = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
    const str = strBuff.toString();
    this._offset += strByteLength;
    return str;
  }
  writeBuffer(buff) {
    this._buff.writeUInt32BE(buff.byteLength, this._offset);
    this._offset += 4;
    this._buff.set(buff, this._offset);
    this._offset += buff.byteLength;
  }
  static sizeVSBuffer(buff) {
    return 4 + buff.byteLength;
  }
  writeVSBuffer(buff) {
    this._buff.writeUInt32BE(buff.byteLength, this._offset);
    this._offset += 4;
    this._buff.set(buff, this._offset);
    this._offset += buff.byteLength;
  }
  readVSBuffer() {
    const buffLength = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    const buff = this._buff.slice(this._offset, this._offset + buffLength);
    this._offset += buffLength;
    return buff;
  }
  static sizeMixedArray(arr) {
    let size = 0;
    size += 1;
    for (let i = 0, len = arr.length; i < len; i++) {
      const el = arr[i];
      size += 1;
      switch (el.type) {
        case 1:
          size += this.sizeLongString(el.value);
          break;
        case 2:
          size += this.sizeVSBuffer(el.value);
          break;
        case 3:
          size += this.sizeUInt32;
          size += this.sizeLongString(el.value);
          for (let i2 = 0; i2 < el.buffers.length; ++i2) {
            size += this.sizeVSBuffer(el.buffers[i2]);
          }
          break;
        case 4:
          break;
      }
    }
    return size;
  }
  writeMixedArray(arr) {
    this._buff.writeUInt8(arr.length, this._offset);
    this._offset += 1;
    for (let i = 0, len = arr.length; i < len; i++) {
      const el = arr[i];
      switch (el.type) {
        case 1:
          this.writeUInt8(
            1
            /* ArgType.String */
          );
          this.writeLongString(el.value);
          break;
        case 2:
          this.writeUInt8(
            2
            /* ArgType.VSBuffer */
          );
          this.writeVSBuffer(el.value);
          break;
        case 3:
          this.writeUInt8(
            3
            /* ArgType.SerializedObjectWithBuffers */
          );
          this.writeUInt32(el.buffers.length);
          this.writeLongString(el.value);
          for (let i2 = 0; i2 < el.buffers.length; ++i2) {
            this.writeBuffer(el.buffers[i2]);
          }
          break;
        case 4:
          this.writeUInt8(
            4
            /* ArgType.Undefined */
          );
          break;
      }
    }
  }
  readMixedArray() {
    const arrLen = this._buff.readUInt8(this._offset);
    this._offset += 1;
    const arr = new Array(arrLen);
    for (let i = 0; i < arrLen; i++) {
      const argType = this.readUInt8();
      switch (argType) {
        case 1:
          arr[i] = this.readLongString();
          break;
        case 2:
          arr[i] = this.readVSBuffer();
          break;
        case 3: {
          const bufferCount = this.readUInt32();
          const jsonString = this.readLongString();
          const buffers = [];
          for (let i2 = 0; i2 < bufferCount; ++i2) {
            buffers.push(this.readVSBuffer());
          }
          arr[i] = new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(jsonString, buffers, null));
          break;
        }
        case 4:
          arr[i] = void 0;
          break;
      }
    }
    return arr;
  }
};
var SerializedRequestArgumentType;
(function(SerializedRequestArgumentType2) {
  SerializedRequestArgumentType2[SerializedRequestArgumentType2["Simple"] = 0] = "Simple";
  SerializedRequestArgumentType2[SerializedRequestArgumentType2["Mixed"] = 1] = "Mixed";
})(SerializedRequestArgumentType || (SerializedRequestArgumentType = {}));
var MessageIO = class {
  static _useMixedArgSerialization(arr) {
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i] instanceof VSBuffer) {
        return true;
      }
      if (arr[i] instanceof SerializableObjectWithBuffers) {
        return true;
      }
      if (typeof arr[i] === "undefined") {
        return true;
      }
    }
    return false;
  }
  static serializeRequestArguments(args, replacer2) {
    if (this._useMixedArgSerialization(args)) {
      const massagedArgs = [];
      for (let i = 0, len = args.length; i < len; i++) {
        const arg = args[i];
        if (arg instanceof VSBuffer) {
          massagedArgs[i] = { type: 2, value: arg };
        } else if (typeof arg === "undefined") {
          massagedArgs[i] = {
            type: 4
            /* ArgType.Undefined */
          };
        } else if (arg instanceof SerializableObjectWithBuffers) {
          const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(arg.value, replacer2);
          massagedArgs[i] = { type: 3, value: VSBuffer.fromString(jsonString), buffers: referencedBuffers };
        } else {
          massagedArgs[i] = { type: 1, value: VSBuffer.fromString(stringify(arg, replacer2)) };
        }
      }
      return {
        type: 1,
        args: massagedArgs
      };
    }
    return {
      type: 0,
      args: stringify(args, replacer2)
    };
  }
  static serializeRequest(req, rpcId, method, serializedArgs, usesCancellationToken) {
    switch (serializedArgs.type) {
      case 0:
        return this._requestJSONArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
      case 1:
        return this._requestMixedArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
    }
  }
  static _requestJSONArgs(req, rpcId, method, args, usesCancellationToken) {
    const methodBuff = VSBuffer.fromString(method);
    const argsBuff = VSBuffer.fromString(args);
    let len = 0;
    len += MessageBuffer.sizeUInt8();
    len += MessageBuffer.sizeShortString(methodBuff);
    len += MessageBuffer.sizeLongString(argsBuff);
    const result = MessageBuffer.alloc(usesCancellationToken ? 2 : 1, req, len);
    result.writeUInt8(rpcId);
    result.writeShortString(methodBuff);
    result.writeLongString(argsBuff);
    return result.buffer;
  }
  static deserializeRequestJSONArgs(buff) {
    const rpcId = buff.readUInt8();
    const method = buff.readShortString();
    const args = buff.readLongString();
    return {
      rpcId,
      method,
      args: JSON.parse(args)
    };
  }
  static _requestMixedArgs(req, rpcId, method, args, usesCancellationToken) {
    const methodBuff = VSBuffer.fromString(method);
    let len = 0;
    len += MessageBuffer.sizeUInt8();
    len += MessageBuffer.sizeShortString(methodBuff);
    len += MessageBuffer.sizeMixedArray(args);
    const result = MessageBuffer.alloc(usesCancellationToken ? 4 : 3, req, len);
    result.writeUInt8(rpcId);
    result.writeShortString(methodBuff);
    result.writeMixedArray(args);
    return result.buffer;
  }
  static deserializeRequestMixedArgs(buff) {
    const rpcId = buff.readUInt8();
    const method = buff.readShortString();
    const rawargs = buff.readMixedArray();
    const args = new Array(rawargs.length);
    for (let i = 0, len = rawargs.length; i < len; i++) {
      const rawarg = rawargs[i];
      if (typeof rawarg === "string") {
        args[i] = JSON.parse(rawarg);
      } else {
        args[i] = rawarg;
      }
    }
    return {
      rpcId,
      method,
      args
    };
  }
  static serializeAcknowledged(req) {
    return MessageBuffer.alloc(5, req, 0).buffer;
  }
  static serializeCancel(req) {
    return MessageBuffer.alloc(6, req, 0).buffer;
  }
  static serializeReplyOK(req, res, replacer2) {
    if (typeof res === "undefined") {
      return this._serializeReplyOKEmpty(req);
    } else if (res instanceof VSBuffer) {
      return this._serializeReplyOKVSBuffer(req, res);
    } else if (res instanceof SerializableObjectWithBuffers) {
      const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(res.value, replacer2, true);
      return this._serializeReplyOKJSONWithBuffers(req, jsonString, referencedBuffers);
    } else {
      return this._serializeReplyOKJSON(req, safeStringify(res, replacer2));
    }
  }
  static _serializeReplyOKEmpty(req) {
    return MessageBuffer.alloc(7, req, 0).buffer;
  }
  static _serializeReplyOKVSBuffer(req, res) {
    let len = 0;
    len += MessageBuffer.sizeVSBuffer(res);
    const result = MessageBuffer.alloc(8, req, len);
    result.writeVSBuffer(res);
    return result.buffer;
  }
  static deserializeReplyOKVSBuffer(buff) {
    return buff.readVSBuffer();
  }
  static _serializeReplyOKJSON(req, res) {
    const resBuff = VSBuffer.fromString(res);
    let len = 0;
    len += MessageBuffer.sizeLongString(resBuff);
    const result = MessageBuffer.alloc(9, req, len);
    result.writeLongString(resBuff);
    return result.buffer;
  }
  static _serializeReplyOKJSONWithBuffers(req, res, buffers) {
    const resBuff = VSBuffer.fromString(res);
    let len = 0;
    len += MessageBuffer.sizeUInt32;
    len += MessageBuffer.sizeLongString(resBuff);
    for (const buffer of buffers) {
      len += MessageBuffer.sizeVSBuffer(buffer);
    }
    const result = MessageBuffer.alloc(10, req, len);
    result.writeUInt32(buffers.length);
    result.writeLongString(resBuff);
    for (const buffer of buffers) {
      result.writeBuffer(buffer);
    }
    return result.buffer;
  }
  static deserializeReplyOKJSON(buff) {
    const res = buff.readLongString();
    return JSON.parse(res);
  }
  static deserializeReplyOKJSONWithBuffers(buff, uriTransformer) {
    const bufferCount = buff.readUInt32();
    const res = buff.readLongString();
    const buffers = [];
    for (let i = 0; i < bufferCount; ++i) {
      buffers.push(buff.readVSBuffer());
    }
    return new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(res, buffers, uriTransformer));
  }
  static serializeReplyErr(req, err) {
    const errStr = err ? safeStringify(transformErrorForSerialization(err), null) : void 0;
    if (typeof errStr !== "string") {
      return this._serializeReplyErrEmpty(req);
    }
    const errBuff = VSBuffer.fromString(errStr);
    let len = 0;
    len += MessageBuffer.sizeLongString(errBuff);
    const result = MessageBuffer.alloc(11, req, len);
    result.writeLongString(errBuff);
    return result.buffer;
  }
  static deserializeReplyErrError(buff) {
    const err = buff.readLongString();
    return JSON.parse(err);
  }
  static _serializeReplyErrEmpty(req) {
    return MessageBuffer.alloc(12, req, 0).buffer;
  }
};
var MessageType2;
(function(MessageType3) {
  MessageType3[MessageType3["RequestJSONArgs"] = 1] = "RequestJSONArgs";
  MessageType3[MessageType3["RequestJSONArgsWithCancellation"] = 2] = "RequestJSONArgsWithCancellation";
  MessageType3[MessageType3["RequestMixedArgs"] = 3] = "RequestMixedArgs";
  MessageType3[MessageType3["RequestMixedArgsWithCancellation"] = 4] = "RequestMixedArgsWithCancellation";
  MessageType3[MessageType3["Acknowledged"] = 5] = "Acknowledged";
  MessageType3[MessageType3["Cancel"] = 6] = "Cancel";
  MessageType3[MessageType3["ReplyOKEmpty"] = 7] = "ReplyOKEmpty";
  MessageType3[MessageType3["ReplyOKVSBuffer"] = 8] = "ReplyOKVSBuffer";
  MessageType3[MessageType3["ReplyOKJSON"] = 9] = "ReplyOKJSON";
  MessageType3[MessageType3["ReplyOKJSONWithBuffers"] = 10] = "ReplyOKJSONWithBuffers";
  MessageType3[MessageType3["ReplyErrError"] = 11] = "ReplyErrError";
  MessageType3[MessageType3["ReplyErrEmpty"] = 12] = "ReplyErrEmpty";
})(MessageType2 || (MessageType2 = {}));
var ArgType;
(function(ArgType2) {
  ArgType2[ArgType2["String"] = 1] = "String";
  ArgType2[ArgType2["VSBuffer"] = 2] = "VSBuffer";
  ArgType2[ArgType2["SerializedObjectWithBuffers"] = 3] = "SerializedObjectWithBuffers";
  ArgType2[ArgType2["Undefined"] = 4] = "Undefined";
})(ArgType || (ArgType = {}));

// out-build/vs/platform/instantiation/common/instantiation.js
var _util;
(function(_util2) {
  _util2.serviceIds = /* @__PURE__ */ new Map();
  _util2.DI_TARGET = "$di$target";
  _util2.DI_DEPENDENCIES = "$di$dependencies";
  function getServiceDependencies(ctor) {
    return ctor[_util2.DI_DEPENDENCIES] || [];
  }
  _util2.getServiceDependencies = getServiceDependencies;
})(_util || (_util = {}));
var IInstantiationService = createDecorator("instantiationService");
function storeServiceDependency(id2, target, index) {
  if (target[_util.DI_TARGET] === target) {
    target[_util.DI_DEPENDENCIES].push({ id: id2, index });
  } else {
    target[_util.DI_DEPENDENCIES] = [{ id: id2, index }];
    target[_util.DI_TARGET] = target;
  }
}
function createDecorator(serviceId) {
  if (_util.serviceIds.has(serviceId)) {
    return _util.serviceIds.get(serviceId);
  }
  const id2 = function(target, key, index) {
    if (arguments.length !== 3) {
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    }
    storeServiceDependency(id2, target, index);
  };
  id2.toString = () => serviceId;
  _util.serviceIds.set(serviceId, id2);
  return id2;
}
function refineServiceDecorator(serviceIdentifier) {
  return serviceIdentifier;
}

// out-build/vs/platform/remote/common/remoteHosts.js
function getRemoteName(authority) {
  if (!authority) {
    return void 0;
  }
  const pos = authority.indexOf("+");
  if (pos < 0) {
    return authority;
  }
  return authority.substr(0, pos);
}

// out-build/vs/platform/extensions/common/extensions.js
var EXTENSION_CATEGORIES = [
  "AI",
  "Azure",
  "Chat",
  "Data Science",
  "Debuggers",
  "Extension Packs",
  "Education",
  "Formatters",
  "Keymaps",
  "Language Packs",
  "Linters",
  "Machine Learning",
  "Notebooks",
  "Programming Languages",
  "SCM Providers",
  "Snippets",
  "Testing",
  "Themes",
  "Visualization",
  "Other"
];
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2[ExtensionType2["System"] = 0] = "System";
  ExtensionType2[ExtensionType2["User"] = 1] = "User";
})(ExtensionType || (ExtensionType = {}));
var TargetPlatform;
(function(TargetPlatform2) {
  TargetPlatform2["WIN32_X64"] = "win32-x64";
  TargetPlatform2["WIN32_ARM64"] = "win32-arm64";
  TargetPlatform2["LINUX_X64"] = "linux-x64";
  TargetPlatform2["LINUX_ARM64"] = "linux-arm64";
  TargetPlatform2["LINUX_ARMHF"] = "linux-armhf";
  TargetPlatform2["ALPINE_X64"] = "alpine-x64";
  TargetPlatform2["ALPINE_ARM64"] = "alpine-arm64";
  TargetPlatform2["DARWIN_X64"] = "darwin-x64";
  TargetPlatform2["DARWIN_ARM64"] = "darwin-arm64";
  TargetPlatform2["WEB"] = "web";
  TargetPlatform2["UNIVERSAL"] = "universal";
  TargetPlatform2["UNKNOWN"] = "unknown";
  TargetPlatform2["UNDEFINED"] = "undefined";
})(TargetPlatform || (TargetPlatform = {}));
var ExtensionIdentifier = class {
  constructor(value) {
    this.value = value;
    this._lower = value.toLowerCase();
  }
  static equals(a, b) {
    if (typeof a === "undefined" || a === null) {
      return typeof b === "undefined" || b === null;
    }
    if (typeof b === "undefined" || b === null) {
      return false;
    }
    if (typeof a === "string" || typeof b === "string") {
      const aValue = typeof a === "string" ? a : a.value;
      const bValue = typeof b === "string" ? b : b.value;
      return equalsIgnoreCase(aValue, bValue);
    }
    return a._lower === b._lower;
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(id2) {
    if (typeof id2 === "string") {
      return id2.toLowerCase();
    }
    return id2._lower;
  }
};
var ExtensionIdentifierSet = class {
  get size() {
    return this._set.size;
  }
  constructor(iterable) {
    this._set = /* @__PURE__ */ new Set();
    if (iterable) {
      for (const value of iterable) {
        this.add(value);
      }
    }
  }
  add(id2) {
    this._set.add(ExtensionIdentifier.toKey(id2));
  }
  delete(extensionId) {
    return this._set.delete(ExtensionIdentifier.toKey(extensionId));
  }
  has(id2) {
    return this._set.has(ExtensionIdentifier.toKey(id2));
  }
};
var ExtensionIdentifierMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  clear() {
    this._map.clear();
  }
  delete(id2) {
    this._map.delete(ExtensionIdentifier.toKey(id2));
  }
  get(id2) {
    return this._map.get(ExtensionIdentifier.toKey(id2));
  }
  has(id2) {
    return this._map.has(ExtensionIdentifier.toKey(id2));
  }
  set(id2, value) {
    this._map.set(ExtensionIdentifier.toKey(id2), value);
  }
  values() {
    return this._map.values();
  }
  forEach(callbackfn) {
    this._map.forEach(callbackfn);
  }
  [Symbol.iterator]() {
    return this._map[Symbol.iterator]();
  }
};
var ExtensionError = class extends Error {
  constructor(extensionIdentifier, cause, message) {
    super(`Error in extension ${ExtensionIdentifier.toKey(extensionIdentifier)}: ${message ?? cause.message}`, { cause });
    this.name = "ExtensionError";
    this.extension = extensionIdentifier;
  }
};
var IBuiltinExtensionsScannerService = createDecorator("IBuiltinExtensionsScannerService");

// out-build/vs/base/common/errorMessage.js
function exceptionToErrorMessage(exception, verbose) {
  if (verbose && (exception.stack || exception.stacktrace)) {
    return localize(110, null, detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
  }
  return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
  if (Array.isArray(stack)) {
    return stack.join("\n");
  }
  return stack;
}
function detectSystemErrorMessage(exception) {
  if (exception.code === "ERR_UNC_HOST_NOT_ALLOWED") {
    return `${exception.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;
  }
  if (typeof exception.code === "string" && typeof exception.errno === "number" && typeof exception.syscall === "string") {
    return localize(111, null, exception.message);
  }
  return exception.message || localize(112, null);
}
function toErrorMessage(error = null, verbose = false) {
  if (!error) {
    return localize(113, null);
  }
  if (Array.isArray(error)) {
    const errors = coalesce(error);
    const msg = toErrorMessage(errors[0], verbose);
    if (errors.length > 1) {
      return localize(114, null, msg, errors.length);
    }
    return msg;
  }
  if (isString(error)) {
    return error;
  }
  if (error.detail) {
    const detail = error.detail;
    if (detail.error) {
      return exceptionToErrorMessage(detail.error, verbose);
    }
    if (detail.exception) {
      return exceptionToErrorMessage(detail.exception, verbose);
    }
  }
  if (error.stack) {
    return exceptionToErrorMessage(error, verbose);
  }
  if (error.message) {
    return error.message;
  }
  return localize(115, null);
}

// out-build/vs/base/common/hash.js
function hash(obj) {
  return doHash(obj, 0);
}
function doHash(obj, hashVal) {
  switch (typeof obj) {
    case "object":
      if (obj === null) {
        return numberHash(349, hashVal);
      } else if (Array.isArray(obj)) {
        return arrayHash(obj, hashVal);
      }
      return objectHash(obj, hashVal);
    case "string":
      return stringHash(obj, hashVal);
    case "boolean":
      return booleanHash(obj, hashVal);
    case "number":
      return numberHash(obj, hashVal);
    case "undefined":
      return numberHash(937, hashVal);
    default:
      return numberHash(617, hashVal);
  }
}
function numberHash(val, initialHashVal) {
  return (initialHashVal << 5) - initialHashVal + val | 0;
}
function booleanHash(b, initialHashVal) {
  return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
  hashVal = numberHash(149417, hashVal);
  for (let i = 0, length = s.length; i < length; i++) {
    hashVal = numberHash(s.charCodeAt(i), hashVal);
  }
  return hashVal;
}
function arrayHash(arr, initialHashVal) {
  initialHashVal = numberHash(104579, initialHashVal);
  return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
  initialHashVal = numberHash(181387, initialHashVal);
  return Object.keys(obj).sort().reduce((hashVal, key) => {
    hashVal = stringHash(key, hashVal);
    return doHash(obj[key], hashVal);
  }, initialHashVal);
}
var SHA1Constant;
(function(SHA1Constant2) {
  SHA1Constant2[SHA1Constant2["BLOCK_SIZE"] = 64] = "BLOCK_SIZE";
  SHA1Constant2[SHA1Constant2["UNICODE_REPLACEMENT"] = 65533] = "UNICODE_REPLACEMENT";
})(SHA1Constant || (SHA1Constant = {}));
function leftRotate(value, bits, totalBits = 32) {
  const delta3 = totalBits - bits;
  const mask = ~((1 << delta3) - 1);
  return (value << bits | (mask & value) >>> delta3) >>> 0;
}
function toHexString(bufferOrValue, bitsize = 32) {
  if (bufferOrValue instanceof ArrayBuffer) {
    return encodeHex(VSBuffer.wrap(new Uint8Array(bufferOrValue)));
  }
  return (bufferOrValue >>> 0).toString(16).padStart(bitsize / 4, "0");
}
var StringSHA1 = class _StringSHA1 {
  static {
    this._bigBlock32 = new DataView(new ArrayBuffer(320));
  }
  // 80 * 4 = 320
  constructor() {
    this._h0 = 1732584193;
    this._h1 = 4023233417;
    this._h2 = 2562383102;
    this._h3 = 271733878;
    this._h4 = 3285377520;
    this._buff = new Uint8Array(
      64 + 3
      /* to fit any utf-8 */
    );
    this._buffDV = new DataView(this._buff.buffer);
    this._buffLen = 0;
    this._totalLen = 0;
    this._leftoverHighSurrogate = 0;
    this._finished = false;
  }
  update(str) {
    const strLen = str.length;
    if (strLen === 0) {
      return;
    }
    const buff = this._buff;
    let buffLen = this._buffLen;
    let leftoverHighSurrogate = this._leftoverHighSurrogate;
    let charCode;
    let offset;
    if (leftoverHighSurrogate !== 0) {
      charCode = leftoverHighSurrogate;
      offset = -1;
      leftoverHighSurrogate = 0;
    } else {
      charCode = str.charCodeAt(0);
      offset = 0;
    }
    while (true) {
      let codePoint = charCode;
      if (isHighSurrogate(charCode)) {
        if (offset + 1 < strLen) {
          const nextCharCode = str.charCodeAt(offset + 1);
          if (isLowSurrogate(nextCharCode)) {
            offset++;
            codePoint = computeCodePoint(charCode, nextCharCode);
          } else {
            codePoint = 65533;
          }
        } else {
          leftoverHighSurrogate = charCode;
          break;
        }
      } else if (isLowSurrogate(charCode)) {
        codePoint = 65533;
      }
      buffLen = this._push(buff, buffLen, codePoint);
      offset++;
      if (offset < strLen) {
        charCode = str.charCodeAt(offset);
      } else {
        break;
      }
    }
    this._buffLen = buffLen;
    this._leftoverHighSurrogate = leftoverHighSurrogate;
  }
  _push(buff, buffLen, codePoint) {
    if (codePoint < 128) {
      buff[buffLen++] = codePoint;
    } else if (codePoint < 2048) {
      buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else if (codePoint < 65536) {
      buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else {
      buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
      buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    }
    if (buffLen >= 64) {
      this._step();
      buffLen -= 64;
      this._totalLen += 64;
      buff[0] = buff[64 + 0];
      buff[1] = buff[64 + 1];
      buff[2] = buff[64 + 2];
    }
    return buffLen;
  }
  digest() {
    if (!this._finished) {
      this._finished = true;
      if (this._leftoverHighSurrogate) {
        this._leftoverHighSurrogate = 0;
        this._buffLen = this._push(
          this._buff,
          this._buffLen,
          65533
          /* SHA1Constant.UNICODE_REPLACEMENT */
        );
      }
      this._totalLen += this._buffLen;
      this._wrapUp();
    }
    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128;
    this._buff.subarray(this._buffLen).fill(0);
    if (this._buffLen > 56) {
      this._step();
      this._buff.fill(0);
    }
    const ml = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
    this._buffDV.setUint32(60, ml % 4294967296, false);
    this._step();
  }
  _step() {
    const bigBlock32 = _StringSHA1._bigBlock32;
    const data2 = this._buffDV;
    for (let j = 0; j < 64; j += 4) {
      bigBlock32.setUint32(j, data2.getUint32(j, false), false);
    }
    for (let j = 64; j < 320; j += 4) {
      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
    }
    let a = this._h0;
    let b = this._h1;
    let c = this._h2;
    let d = this._h3;
    let e = this._h4;
    let f, k;
    let temp;
    for (let j = 0; j < 80; j++) {
      if (j < 20) {
        f = b & c | ~b & d;
        k = 1518500249;
      } else if (j < 40) {
        f = b ^ c ^ d;
        k = 1859775393;
      } else if (j < 60) {
        f = b & c | b & d | c & d;
        k = 2400959708;
      } else {
        f = b ^ c ^ d;
        k = 3395469782;
      }
      temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }
    this._h0 = this._h0 + a & 4294967295;
    this._h1 = this._h1 + b & 4294967295;
    this._h2 = this._h2 + c & 4294967295;
    this._h3 = this._h3 + d & 4294967295;
    this._h4 = this._h4 + e & 4294967295;
  }
};

// out-build/vs/platform/contextkey/common/scanner.js
var TokenType;
(function(TokenType3) {
  TokenType3[TokenType3["LParen"] = 0] = "LParen";
  TokenType3[TokenType3["RParen"] = 1] = "RParen";
  TokenType3[TokenType3["Neg"] = 2] = "Neg";
  TokenType3[TokenType3["Eq"] = 3] = "Eq";
  TokenType3[TokenType3["NotEq"] = 4] = "NotEq";
  TokenType3[TokenType3["Lt"] = 5] = "Lt";
  TokenType3[TokenType3["LtEq"] = 6] = "LtEq";
  TokenType3[TokenType3["Gt"] = 7] = "Gt";
  TokenType3[TokenType3["GtEq"] = 8] = "GtEq";
  TokenType3[TokenType3["RegexOp"] = 9] = "RegexOp";
  TokenType3[TokenType3["RegexStr"] = 10] = "RegexStr";
  TokenType3[TokenType3["True"] = 11] = "True";
  TokenType3[TokenType3["False"] = 12] = "False";
  TokenType3[TokenType3["In"] = 13] = "In";
  TokenType3[TokenType3["Not"] = 14] = "Not";
  TokenType3[TokenType3["And"] = 15] = "And";
  TokenType3[TokenType3["Or"] = 16] = "Or";
  TokenType3[TokenType3["Str"] = 17] = "Str";
  TokenType3[TokenType3["QuotedStr"] = 18] = "QuotedStr";
  TokenType3[TokenType3["Error"] = 19] = "Error";
  TokenType3[TokenType3["EOF"] = 20] = "EOF";
})(TokenType || (TokenType = {}));
function hintDidYouMean(...meant) {
  switch (meant.length) {
    case 1:
      return localize(1863, null, meant[0]);
    case 2:
      return localize(1864, null, meant[0], meant[1]);
    case 3:
      return localize(1865, null, meant[0], meant[1], meant[2]);
    default:
      return void 0;
  }
}
var hintDidYouForgetToOpenOrCloseQuote = localize(1866, null);
var hintDidYouForgetToEscapeSlash = localize(1867, null);
var Scanner = class _Scanner {
  constructor() {
    this._input = "";
    this._start = 0;
    this._current = 0;
    this._tokens = [];
    this._errors = [];
    this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
  }
  static getLexeme(token) {
    switch (token.type) {
      case 0:
        return "(";
      case 1:
        return ")";
      case 2:
        return "!";
      case 3:
        return token.isTripleEq ? "===" : "==";
      case 4:
        return token.isTripleEq ? "!==" : "!=";
      case 5:
        return "<";
      case 6:
        return "<=";
      case 7:
        return ">=";
      case 8:
        return ">=";
      case 9:
        return "=~";
      case 10:
        return token.lexeme;
      case 11:
        return "true";
      case 12:
        return "false";
      case 13:
        return "in";
      case 14:
        return "not";
      case 15:
        return "&&";
      case 16:
        return "||";
      case 17:
        return token.lexeme;
      case 18:
        return token.lexeme;
      case 19:
        return token.lexeme;
      case 20:
        return "EOF";
      default:
        throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
    }
  }
  static {
    this._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((ch) => ch.charCodeAt(0)));
  }
  static {
    this._keywords = /* @__PURE__ */ new Map([
      [
        "not",
        14
        /* TokenType.Not */
      ],
      [
        "in",
        13
        /* TokenType.In */
      ],
      [
        "false",
        12
        /* TokenType.False */
      ],
      [
        "true",
        11
        /* TokenType.True */
      ]
    ]);
  }
  get errors() {
    return this._errors;
  }
  reset(value) {
    this._input = value;
    this._start = 0;
    this._current = 0;
    this._tokens = [];
    this._errors = [];
    return this;
  }
  scan() {
    while (!this._isAtEnd()) {
      this._start = this._current;
      const ch = this._advance();
      switch (ch) {
        case 40:
          this._addToken(
            0
            /* TokenType.LParen */
          );
          break;
        case 41:
          this._addToken(
            1
            /* TokenType.RParen */
          );
          break;
        case 33:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const isTripleEq = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 4, offset: this._start, isTripleEq });
          } else {
            this._addToken(
              2
              /* TokenType.Neg */
            );
          }
          break;
        case 39:
          this._quotedString();
          break;
        case 47:
          this._regex();
          break;
        case 61:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const isTripleEq = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 3, offset: this._start, isTripleEq });
          } else if (this._match(
            126
            /* CharCode.Tilde */
          )) {
            this._addToken(
              9
              /* TokenType.RegexOp */
            );
          } else {
            this._error(hintDidYouMean("==", "=~"));
          }
          break;
        case 60:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 6 : 5
            /* TokenType.Lt */
          );
          break;
        case 62:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 8 : 7
            /* TokenType.Gt */
          );
          break;
        case 38:
          if (this._match(
            38
            /* CharCode.Ampersand */
          )) {
            this._addToken(
              15
              /* TokenType.And */
            );
          } else {
            this._error(hintDidYouMean("&&"));
          }
          break;
        case 124:
          if (this._match(
            124
            /* CharCode.Pipe */
          )) {
            this._addToken(
              16
              /* TokenType.Or */
            );
          } else {
            this._error(hintDidYouMean("||"));
          }
          break;
        // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.
        case 32:
        case 13:
        case 9:
        case 10:
        case 160:
          break;
        default:
          this._string();
      }
    }
    this._start = this._current;
    this._addToken(
      20
      /* TokenType.EOF */
    );
    return Array.from(this._tokens);
  }
  _match(expected) {
    if (this._isAtEnd()) {
      return false;
    }
    if (this._input.charCodeAt(this._current) !== expected) {
      return false;
    }
    this._current++;
    return true;
  }
  _advance() {
    return this._input.charCodeAt(this._current++);
  }
  _peek() {
    return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
  }
  _addToken(type) {
    this._tokens.push({ type, offset: this._start });
  }
  _error(additional) {
    const offset = this._start;
    const lexeme = this._input.substring(this._start, this._current);
    const errToken = { type: 19, offset: this._start, lexeme };
    this._errors.push({ offset, lexeme, additionalInfo: additional });
    this._tokens.push(errToken);
  }
  _string() {
    this.stringRe.lastIndex = this._start;
    const match2 = this.stringRe.exec(this._input);
    if (match2) {
      this._current = this._start + match2[0].length;
      const lexeme = this._input.substring(this._start, this._current);
      const keyword = _Scanner._keywords.get(lexeme);
      if (keyword) {
        this._addToken(keyword);
      } else {
        this._tokens.push({ type: 17, lexeme, offset: this._start });
      }
    }
  }
  // captures the lexeme without the leading and trailing '
  _quotedString() {
    while (this._peek() !== 39 && !this._isAtEnd()) {
      this._advance();
    }
    if (this._isAtEnd()) {
      this._error(hintDidYouForgetToOpenOrCloseQuote);
      return;
    }
    this._advance();
    this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
  }
  /*
   * Lexing a regex expression: /.../[igsmyu]*
   * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
   *
   * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
   */
  _regex() {
    let p = this._current;
    let inEscape = false;
    let inCharacterClass = false;
    while (true) {
      if (p >= this._input.length) {
        this._current = p;
        this._error(hintDidYouForgetToEscapeSlash);
        return;
      }
      const ch = this._input.charCodeAt(p);
      if (inEscape) {
        inEscape = false;
      } else if (ch === 47 && !inCharacterClass) {
        p++;
        break;
      } else if (ch === 91) {
        inCharacterClass = true;
      } else if (ch === 92) {
        inEscape = true;
      } else if (ch === 93) {
        inCharacterClass = false;
      }
      p++;
    }
    while (p < this._input.length && _Scanner._regexFlags.has(this._input.charCodeAt(p))) {
      p++;
    }
    this._current = p;
    const lexeme = this._input.substring(this._start, this._current);
    this._tokens.push({ type: 10, lexeme, offset: this._start });
  }
  _isAtEnd() {
    return this._current >= this._input.length;
  }
};

// out-build/vs/platform/contextkey/common/contextkey.js
var CONSTANT_VALUES = /* @__PURE__ */ new Map();
CONSTANT_VALUES.set("false", false);
CONSTANT_VALUES.set("true", true);
CONSTANT_VALUES.set("isMac", isMacintosh);
CONSTANT_VALUES.set("isLinux", isLinux);
CONSTANT_VALUES.set("isWindows", isWindows);
CONSTANT_VALUES.set("isWeb", isWeb);
CONSTANT_VALUES.set("isMacNative", isMacintosh && !isWeb);
CONSTANT_VALUES.set("isEdge", isEdge);
CONSTANT_VALUES.set("isFirefox", isFirefox);
CONSTANT_VALUES.set("isChrome", isChrome);
CONSTANT_VALUES.set("isSafari", isSafari);
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var ContextKeyExprType;
(function(ContextKeyExprType2) {
  ContextKeyExprType2[ContextKeyExprType2["False"] = 0] = "False";
  ContextKeyExprType2[ContextKeyExprType2["True"] = 1] = "True";
  ContextKeyExprType2[ContextKeyExprType2["Defined"] = 2] = "Defined";
  ContextKeyExprType2[ContextKeyExprType2["Not"] = 3] = "Not";
  ContextKeyExprType2[ContextKeyExprType2["Equals"] = 4] = "Equals";
  ContextKeyExprType2[ContextKeyExprType2["NotEquals"] = 5] = "NotEquals";
  ContextKeyExprType2[ContextKeyExprType2["And"] = 6] = "And";
  ContextKeyExprType2[ContextKeyExprType2["Regex"] = 7] = "Regex";
  ContextKeyExprType2[ContextKeyExprType2["NotRegex"] = 8] = "NotRegex";
  ContextKeyExprType2[ContextKeyExprType2["Or"] = 9] = "Or";
  ContextKeyExprType2[ContextKeyExprType2["In"] = 10] = "In";
  ContextKeyExprType2[ContextKeyExprType2["NotIn"] = 11] = "NotIn";
  ContextKeyExprType2[ContextKeyExprType2["Greater"] = 12] = "Greater";
  ContextKeyExprType2[ContextKeyExprType2["GreaterEquals"] = 13] = "GreaterEquals";
  ContextKeyExprType2[ContextKeyExprType2["Smaller"] = 14] = "Smaller";
  ContextKeyExprType2[ContextKeyExprType2["SmallerEquals"] = 15] = "SmallerEquals";
})(ContextKeyExprType || (ContextKeyExprType = {}));
var defaultConfig = {
  regexParsingWithErrorRecovery: true
};
var errorEmptyString = localize(1843, null);
var hintEmptyString = localize(1844, null);
var errorNoInAfterNot = localize(1845, null);
var errorClosingParenthesis = localize(1846, null);
var errorUnexpectedToken = localize(1847, null);
var hintUnexpectedToken = localize(1848, null);
var errorUnexpectedEOF = localize(1849, null);
var hintUnexpectedEOF = localize(1850, null);
var Parser = class _Parser2 {
  static {
    this._parseError = new Error();
  }
  get lexingErrors() {
    return this._scanner.errors;
  }
  get parsingErrors() {
    return this._parsingErrors;
  }
  constructor(_config = defaultConfig) {
    this._config = _config;
    this._scanner = new Scanner();
    this._tokens = [];
    this._current = 0;
    this._parsingErrors = [];
    this._flagsGYRe = /g|y/g;
  }
  /**
   * Parse a context key expression.
   *
   * @param input the expression to parse
   * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
   */
  parse(input) {
    if (input === "") {
      this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: "", additionalInfo: hintEmptyString });
      return void 0;
    }
    this._tokens = this._scanner.reset(input).scan();
    this._current = 0;
    this._parsingErrors = [];
    try {
      const expr = this._expr();
      if (!this._isAtEnd()) {
        const peek = this._peek();
        const additionalInfo = peek.type === 17 ? hintUnexpectedToken : void 0;
        this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });
        throw _Parser2._parseError;
      }
      return expr;
    } catch (e) {
      if (!(e === _Parser2._parseError)) {
        throw e;
      }
      return void 0;
    }
  }
  _expr() {
    return this._or();
  }
  _or() {
    const expr = [this._and()];
    while (this._matchOne(
      16
      /* TokenType.Or */
    )) {
      const right = this._and();
      expr.push(right);
    }
    return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);
  }
  _and() {
    const expr = [this._term()];
    while (this._matchOne(
      15
      /* TokenType.And */
    )) {
      const right = this._term();
      expr.push(right);
    }
    return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);
  }
  _term() {
    if (this._matchOne(
      2
      /* TokenType.Neg */
    )) {
      const peek = this._peek();
      switch (peek.type) {
        case 11:
          this._advance();
          return ContextKeyFalseExpr.INSTANCE;
        case 12:
          this._advance();
          return ContextKeyTrueExpr.INSTANCE;
        case 0: {
          this._advance();
          const expr = this._expr();
          this._consume(1, errorClosingParenthesis);
          return expr?.negate();
        }
        case 17:
          this._advance();
          return ContextKeyNotExpr.create(peek.lexeme);
        default:
          throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);
      }
    }
    return this._primary();
  }
  _primary() {
    const peek = this._peek();
    switch (peek.type) {
      case 11:
        this._advance();
        return ContextKeyExpr.true();
      case 12:
        this._advance();
        return ContextKeyExpr.false();
      case 0: {
        this._advance();
        const expr = this._expr();
        this._consume(1, errorClosingParenthesis);
        return expr;
      }
      case 17: {
        const key = peek.lexeme;
        this._advance();
        if (this._matchOne(
          9
          /* TokenType.RegexOp */
        )) {
          const expr = this._peek();
          if (!this._config.regexParsingWithErrorRecovery) {
            this._advance();
            if (expr.type !== 10) {
              throw this._errExpectedButGot(`REGEX`, expr);
            }
            const regexLexeme = expr.lexeme;
            const closingSlashIndex = regexLexeme.lastIndexOf("/");
            const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
            let regexp;
            try {
              regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
            } catch (e) {
              throw this._errExpectedButGot(`REGEX`, expr);
            }
            return ContextKeyRegexExpr.create(key, regexp);
          }
          switch (expr.type) {
            case 10:
            case 19: {
              const lexemeReconstruction = [expr.lexeme];
              this._advance();
              let followingToken = this._peek();
              let parenBalance = 0;
              for (let i = 0; i < expr.lexeme.length; i++) {
                if (expr.lexeme.charCodeAt(i) === 40) {
                  parenBalance++;
                } else if (expr.lexeme.charCodeAt(i) === 41) {
                  parenBalance--;
                }
              }
              while (!this._isAtEnd() && followingToken.type !== 15 && followingToken.type !== 16) {
                switch (followingToken.type) {
                  case 0:
                    parenBalance++;
                    break;
                  case 1:
                    parenBalance--;
                    break;
                  case 10:
                  case 18:
                    for (let i = 0; i < followingToken.lexeme.length; i++) {
                      if (followingToken.lexeme.charCodeAt(i) === 40) {
                        parenBalance++;
                      } else if (expr.lexeme.charCodeAt(i) === 41) {
                        parenBalance--;
                      }
                    }
                }
                if (parenBalance < 0) {
                  break;
                }
                lexemeReconstruction.push(Scanner.getLexeme(followingToken));
                this._advance();
                followingToken = this._peek();
              }
              const regexLexeme = lexemeReconstruction.join("");
              const closingSlashIndex = regexLexeme.lastIndexOf("/");
              const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
              let regexp;
              try {
                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
              } catch (e) {
                throw this._errExpectedButGot(`REGEX`, expr);
              }
              return ContextKeyExpr.regex(key, regexp);
            }
            case 18: {
              const serializedValue = expr.lexeme;
              this._advance();
              let regex = null;
              if (!isFalsyOrWhitespace(serializedValue)) {
                const start = serializedValue.indexOf("/");
                const end = serializedValue.lastIndexOf("/");
                if (start !== end && start >= 0) {
                  const value = serializedValue.slice(start + 1, end);
                  const caseIgnoreFlag = serializedValue[end + 1] === "i" ? "i" : "";
                  try {
                    regex = new RegExp(value, caseIgnoreFlag);
                  } catch (_e) {
                    throw this._errExpectedButGot(`REGEX`, expr);
                  }
                }
              }
              if (regex === null) {
                throw this._errExpectedButGot("REGEX", expr);
              }
              return ContextKeyRegexExpr.create(key, regex);
            }
            default:
              throw this._errExpectedButGot("REGEX", this._peek());
          }
        }
        if (this._matchOne(
          14
          /* TokenType.Not */
        )) {
          this._consume(13, errorNoInAfterNot);
          const right = this._value();
          return ContextKeyExpr.notIn(key, right);
        }
        const maybeOp = this._peek().type;
        switch (maybeOp) {
          case 3: {
            this._advance();
            const right = this._value();
            if (this._previous().type === 18) {
              return ContextKeyExpr.equals(key, right);
            }
            switch (right) {
              case "true":
                return ContextKeyExpr.has(key);
              case "false":
                return ContextKeyExpr.not(key);
              default:
                return ContextKeyExpr.equals(key, right);
            }
          }
          case 4: {
            this._advance();
            const right = this._value();
            if (this._previous().type === 18) {
              return ContextKeyExpr.notEquals(key, right);
            }
            switch (right) {
              case "true":
                return ContextKeyExpr.not(key);
              case "false":
                return ContextKeyExpr.has(key);
              default:
                return ContextKeyExpr.notEquals(key, right);
            }
          }
          // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number
          // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops
          case 5:
            this._advance();
            return ContextKeySmallerExpr.create(key, this._value());
          case 6:
            this._advance();
            return ContextKeySmallerEqualsExpr.create(key, this._value());
          case 7:
            this._advance();
            return ContextKeyGreaterExpr.create(key, this._value());
          case 8:
            this._advance();
            return ContextKeyGreaterEqualsExpr.create(key, this._value());
          case 13:
            this._advance();
            return ContextKeyExpr.in(key, this._value());
          default:
            return ContextKeyExpr.has(key);
        }
      }
      case 20:
        this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: "", additionalInfo: hintUnexpectedEOF });
        throw _Parser2._parseError;
      default:
        throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
    }
  }
  _value() {
    const token = this._peek();
    switch (token.type) {
      case 17:
      case 18:
        this._advance();
        return token.lexeme;
      case 11:
        this._advance();
        return "true";
      case 12:
        this._advance();
        return "false";
      case 13:
        this._advance();
        return "in";
      default:
        return "";
    }
  }
  _removeFlagsGY(flags) {
    return flags.replaceAll(this._flagsGYRe, "");
  }
  // careful: this can throw if current token is the initial one (ie index = 0)
  _previous() {
    return this._tokens[this._current - 1];
  }
  _matchOne(token) {
    if (this._check(token)) {
      this._advance();
      return true;
    }
    return false;
  }
  _advance() {
    if (!this._isAtEnd()) {
      this._current++;
    }
    return this._previous();
  }
  _consume(type, message) {
    if (this._check(type)) {
      return this._advance();
    }
    throw this._errExpectedButGot(message, this._peek());
  }
  _errExpectedButGot(expected, got, additionalInfo) {
    const message = localize(1851, null, expected, Scanner.getLexeme(got));
    const offset = got.offset;
    const lexeme = Scanner.getLexeme(got);
    this._parsingErrors.push({ message, offset, lexeme, additionalInfo });
    return _Parser2._parseError;
  }
  _check(type) {
    return this._peek().type === type;
  }
  _peek() {
    return this._tokens[this._current];
  }
  _isAtEnd() {
    return this._peek().type === 20;
  }
};
var ContextKeyExpr = class {
  static false() {
    return ContextKeyFalseExpr.INSTANCE;
  }
  static true() {
    return ContextKeyTrueExpr.INSTANCE;
  }
  static has(key) {
    return ContextKeyDefinedExpr.create(key);
  }
  static equals(key, value) {
    return ContextKeyEqualsExpr.create(key, value);
  }
  static notEquals(key, value) {
    return ContextKeyNotEqualsExpr.create(key, value);
  }
  static regex(key, value) {
    return ContextKeyRegexExpr.create(key, value);
  }
  static in(key, value) {
    return ContextKeyInExpr.create(key, value);
  }
  static notIn(key, value) {
    return ContextKeyNotInExpr.create(key, value);
  }
  static not(key) {
    return ContextKeyNotExpr.create(key);
  }
  static and(...expr) {
    return ContextKeyAndExpr.create(expr, null, true);
  }
  static or(...expr) {
    return ContextKeyOrExpr.create(expr, null, true);
  }
  static greater(key, value) {
    return ContextKeyGreaterExpr.create(key, value);
  }
  static greaterEquals(key, value) {
    return ContextKeyGreaterEqualsExpr.create(key, value);
  }
  static smaller(key, value) {
    return ContextKeySmallerExpr.create(key, value);
  }
  static smallerEquals(key, value) {
    return ContextKeySmallerEqualsExpr.create(key, value);
  }
  static {
    this._parser = new Parser({ regexParsingWithErrorRecovery: false });
  }
  static deserialize(serialized) {
    if (serialized === void 0 || serialized === null) {
      return void 0;
    }
    const expr = this._parser.parse(serialized);
    return expr;
  }
};
function validateWhenClauses(whenClauses) {
  const parser2 = new Parser({ regexParsingWithErrorRecovery: false });
  return whenClauses.map((whenClause) => {
    parser2.parse(whenClause);
    if (parser2.lexingErrors.length > 0) {
      return parser2.lexingErrors.map((se) => ({
        errorMessage: se.additionalInfo ? localize(1852, null, se.additionalInfo) : localize(1853, null),
        offset: se.offset,
        length: se.lexeme.length
      }));
    } else if (parser2.parsingErrors.length > 0) {
      return parser2.parsingErrors.map((pe) => ({
        errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,
        offset: pe.offset,
        length: pe.lexeme.length
      }));
    } else {
      return [];
    }
  });
}
function cmp(a, b) {
  return a.cmp(b);
}
var ContextKeyFalseExpr = class _ContextKeyFalseExpr {
  static {
    this.INSTANCE = new _ContextKeyFalseExpr();
  }
  constructor() {
    this.type = 0;
  }
  cmp(other) {
    return this.type - other.type;
  }
  equals(other) {
    return other.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return false;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  map(mapFnc) {
    return this;
  }
  negate() {
    return ContextKeyTrueExpr.INSTANCE;
  }
};
var ContextKeyTrueExpr = class _ContextKeyTrueExpr {
  static {
    this.INSTANCE = new _ContextKeyTrueExpr();
  }
  constructor() {
    this.type = 1;
  }
  cmp(other) {
    return this.type - other.type;
  }
  equals(other) {
    return other.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return true;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  map(mapFnc) {
    return this;
  }
  negate() {
    return ContextKeyFalseExpr.INSTANCE;
  }
};
var ContextKeyDefinedExpr = class _ContextKeyDefinedExpr {
  static create(key, negated = null) {
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return new _ContextKeyDefinedExpr(key, negated);
  }
  constructor(key, negated) {
    this.key = key;
    this.negated = negated;
    this.type = 2;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp1(this.key, other.key);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return !!context.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapDefined(this.key);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotExpr.create(this.key, this);
    }
    return this.negated;
  }
};
var ContextKeyEqualsExpr = class _ContextKeyEqualsExpr {
  static create(key, value, negated = null) {
    if (typeof value === "boolean") {
      return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);
    }
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      const trueValue = constantValue ? "true" : "false";
      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return new _ContextKeyEqualsExpr(key, value, negated);
  }
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 4;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      const trueValue = constantValue ? "true" : "false";
      return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return context.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapEquals(this.key, this.value);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyInExpr = class _ContextKeyInExpr {
  static create(key, valueKey) {
    return new _ContextKeyInExpr(key, valueKey);
  }
  constructor(key, valueKey) {
    this.key = key;
    this.valueKey = valueKey;
    this.type = 10;
    this.negated = null;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.valueKey, other.key, other.valueKey);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.valueKey === other.valueKey;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    const source = context.getValue(this.valueKey);
    const item = context.getValue(this.key);
    if (Array.isArray(source)) {
      return source.includes(item);
    }
    if (typeof item === "string" && typeof source === "object" && source !== null) {
      return hasOwnProperty2.call(source, item);
    }
    return false;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  map(mapFnc) {
    return mapFnc.mapIn(this.key, this.valueKey);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
    }
    return this.negated;
  }
};
var ContextKeyNotInExpr = class _ContextKeyNotInExpr {
  static create(key, valueKey) {
    return new _ContextKeyNotInExpr(key, valueKey);
  }
  constructor(key, valueKey) {
    this.key = key;
    this.valueKey = valueKey;
    this.type = 11;
    this._negated = ContextKeyInExpr.create(key, valueKey);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return this._negated.cmp(other._negated);
  }
  equals(other) {
    if (other.type === this.type) {
      return this._negated.equals(other._negated);
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return !this._negated.evaluate(context);
  }
  serialize() {
    return `${this.key} not in '${this.valueKey}'`;
  }
  keys() {
    return this._negated.keys();
  }
  map(mapFnc) {
    return mapFnc.mapNotIn(this.key, this.valueKey);
  }
  negate() {
    return this._negated;
  }
};
var ContextKeyNotEqualsExpr = class _ContextKeyNotEqualsExpr {
  static create(key, value, negated = null) {
    if (typeof value === "boolean") {
      if (value) {
        return ContextKeyNotExpr.create(key, negated);
      }
      return ContextKeyDefinedExpr.create(key, negated);
    }
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      const falseValue = constantValue ? "true" : "false";
      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return new _ContextKeyNotEqualsExpr(key, value, negated);
  }
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 5;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      const falseValue = constantValue ? "true" : "false";
      return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return context.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapNotEquals(this.key, this.value);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyNotExpr = class _ContextKeyNotExpr {
  static create(key, negated = null) {
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return new _ContextKeyNotExpr(key, negated);
  }
  constructor(key, negated) {
    this.key = key;
    this.negated = negated;
    this.type = 3;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp1(this.key, other.key);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return !context.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapNot(this.key);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyDefinedExpr.create(this.key, this);
    }
    return this.negated;
  }
};
function withFloatOrStr(value, callback) {
  if (typeof value === "string") {
    const n = parseFloat(value);
    if (!isNaN(n)) {
      value = n;
    }
  }
  if (typeof value === "string" || typeof value === "number") {
    return callback(value);
  }
  return ContextKeyFalseExpr.INSTANCE;
}
var ContextKeyGreaterExpr = class _ContextKeyGreaterExpr {
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeyGreaterExpr(key, value, negated));
  }
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 12;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapGreater(this.key, this.value);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyGreaterEqualsExpr = class _ContextKeyGreaterEqualsExpr {
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeyGreaterEqualsExpr(key, value, negated));
  }
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 13;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapGreaterEquals(this.key, this.value);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeySmallerExpr = class _ContextKeySmallerExpr {
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeySmallerExpr(key, value, negated));
  }
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 14;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapSmaller(this.key, this.value);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeySmallerEqualsExpr = class _ContextKeySmallerEqualsExpr {
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeySmallerEqualsExpr(key, value, negated));
  }
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 15;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapSmallerEquals(this.key, this.value);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyRegexExpr = class _ContextKeyRegexExpr {
  static create(key, regexp) {
    return new _ContextKeyRegexExpr(key, regexp);
  }
  constructor(key, regexp) {
    this.key = key;
    this.regexp = regexp;
    this.type = 7;
    this.negated = null;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    const thisSource = this.regexp ? this.regexp.source : "";
    const otherSource = other.regexp ? other.regexp.source : "";
    if (thisSource < otherSource) {
      return -1;
    }
    if (thisSource > otherSource) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      const thisSource = this.regexp ? this.regexp.source : "";
      const otherSource = other.regexp ? other.regexp.source : "";
      return this.key === other.key && thisSource === otherSource;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    const value = context.getValue(this.key);
    return this.regexp ? this.regexp.test(value) : false;
  }
  serialize() {
    const value = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
    return `${this.key} =~ ${value}`;
  }
  keys() {
    return [this.key];
  }
  map(mapFnc) {
    return mapFnc.mapRegex(this.key, this.regexp);
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotRegexExpr.create(this);
    }
    return this.negated;
  }
};
var ContextKeyNotRegexExpr = class _ContextKeyNotRegexExpr {
  static create(actual) {
    return new _ContextKeyNotRegexExpr(actual);
  }
  constructor(_actual) {
    this._actual = _actual;
    this.type = 8;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return this._actual.cmp(other._actual);
  }
  equals(other) {
    if (other.type === this.type) {
      return this._actual.equals(other._actual);
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return !this._actual.evaluate(context);
  }
  serialize() {
    return `!(${this._actual.serialize()})`;
  }
  keys() {
    return this._actual.keys();
  }
  map(mapFnc) {
    return new _ContextKeyNotRegexExpr(this._actual.map(mapFnc));
  }
  negate() {
    return this._actual;
  }
};
function eliminateConstantsInArray(arr) {
  let newArr = null;
  for (let i = 0, len = arr.length; i < len; i++) {
    const newExpr = arr[i].substituteConstants();
    if (arr[i] !== newExpr) {
      if (newArr === null) {
        newArr = [];
        for (let j = 0; j < i; j++) {
          newArr[j] = arr[j];
        }
      }
    }
    if (newArr !== null) {
      newArr[i] = newExpr;
    }
  }
  if (newArr === null) {
    return arr;
  }
  return newArr;
}
var ContextKeyAndExpr = class _ContextKeyAndExpr {
  static create(_expr, negated, extraRedundantCheck) {
    return _ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);
  }
  constructor(expr, negated) {
    this.expr = expr;
    this.negated = negated;
    this.type = 6;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.expr.length < other.expr.length) {
      return -1;
    }
    if (this.expr.length > other.expr.length) {
      return 1;
    }
    for (let i = 0, len = this.expr.length; i < len; i++) {
      const r = cmp(this.expr[i], other.expr[i]);
      if (r !== 0) {
        return r;
      }
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      if (this.expr.length !== other.expr.length) {
        return false;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (!this.expr[i].equals(other.expr[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  substituteConstants() {
    const exprArr = eliminateConstantsInArray(this.expr);
    if (exprArr === this.expr) {
      return this;
    }
    return _ContextKeyAndExpr.create(exprArr, this.negated, false);
  }
  evaluate(context) {
    for (let i = 0, len = this.expr.length; i < len; i++) {
      if (!this.expr[i].evaluate(context)) {
        return false;
      }
    }
    return true;
  }
  static _normalizeArr(arr, negated, extraRedundantCheck) {
    const expr = [];
    let hasTrue = false;
    for (const e of arr) {
      if (!e) {
        continue;
      }
      if (e.type === 1) {
        hasTrue = true;
        continue;
      }
      if (e.type === 0) {
        return ContextKeyFalseExpr.INSTANCE;
      }
      if (e.type === 6) {
        expr.push(...e.expr);
        continue;
      }
      expr.push(e);
    }
    if (expr.length === 0 && hasTrue) {
      return ContextKeyTrueExpr.INSTANCE;
    }
    if (expr.length === 0) {
      return void 0;
    }
    if (expr.length === 1) {
      return expr[0];
    }
    expr.sort(cmp);
    for (let i = 1; i < expr.length; i++) {
      if (expr[i - 1].equals(expr[i])) {
        expr.splice(i, 1);
        i--;
      }
    }
    if (expr.length === 1) {
      return expr[0];
    }
    while (expr.length > 1) {
      const lastElement = expr[expr.length - 1];
      if (lastElement.type !== 9) {
        break;
      }
      expr.pop();
      const secondToLastElement = expr.pop();
      const isFinished = expr.length === 0;
      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map((el) => _ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);
      if (resultElement) {
        expr.push(resultElement);
        expr.sort(cmp);
      }
    }
    if (expr.length === 1) {
      return expr[0];
    }
    if (extraRedundantCheck) {
      for (let i = 0; i < expr.length; i++) {
        for (let j = i + 1; j < expr.length; j++) {
          if (expr[i].negate().equals(expr[j])) {
            return ContextKeyFalseExpr.INSTANCE;
          }
        }
      }
      if (expr.length === 1) {
        return expr[0];
      }
    }
    return new _ContextKeyAndExpr(expr, negated);
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const result = [];
    for (const expr of this.expr) {
      result.push(...expr.keys());
    }
    return result;
  }
  map(mapFnc) {
    return new _ContextKeyAndExpr(this.expr.map((expr) => expr.map(mapFnc)), null);
  }
  negate() {
    if (!this.negated) {
      const result = [];
      for (const expr of this.expr) {
        result.push(expr.negate());
      }
      this.negated = ContextKeyOrExpr.create(result, this, true);
    }
    return this.negated;
  }
};
var ContextKeyOrExpr = class _ContextKeyOrExpr {
  static create(_expr, negated, extraRedundantCheck) {
    return _ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
  }
  constructor(expr, negated) {
    this.expr = expr;
    this.negated = negated;
    this.type = 9;
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.expr.length < other.expr.length) {
      return -1;
    }
    if (this.expr.length > other.expr.length) {
      return 1;
    }
    for (let i = 0, len = this.expr.length; i < len; i++) {
      const r = cmp(this.expr[i], other.expr[i]);
      if (r !== 0) {
        return r;
      }
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      if (this.expr.length !== other.expr.length) {
        return false;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (!this.expr[i].equals(other.expr[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  substituteConstants() {
    const exprArr = eliminateConstantsInArray(this.expr);
    if (exprArr === this.expr) {
      return this;
    }
    return _ContextKeyOrExpr.create(exprArr, this.negated, false);
  }
  evaluate(context) {
    for (let i = 0, len = this.expr.length; i < len; i++) {
      if (this.expr[i].evaluate(context)) {
        return true;
      }
    }
    return false;
  }
  static _normalizeArr(arr, negated, extraRedundantCheck) {
    let expr = [];
    let hasFalse = false;
    if (arr) {
      for (let i = 0, len = arr.length; i < len; i++) {
        const e = arr[i];
        if (!e) {
          continue;
        }
        if (e.type === 0) {
          hasFalse = true;
          continue;
        }
        if (e.type === 1) {
          return ContextKeyTrueExpr.INSTANCE;
        }
        if (e.type === 9) {
          expr = expr.concat(e.expr);
          continue;
        }
        expr.push(e);
      }
      if (expr.length === 0 && hasFalse) {
        return ContextKeyFalseExpr.INSTANCE;
      }
      expr.sort(cmp);
    }
    if (expr.length === 0) {
      return void 0;
    }
    if (expr.length === 1) {
      return expr[0];
    }
    for (let i = 1; i < expr.length; i++) {
      if (expr[i - 1].equals(expr[i])) {
        expr.splice(i, 1);
        i--;
      }
    }
    if (expr.length === 1) {
      return expr[0];
    }
    if (extraRedundantCheck) {
      for (let i = 0; i < expr.length; i++) {
        for (let j = i + 1; j < expr.length; j++) {
          if (expr[i].negate().equals(expr[j])) {
            return ContextKeyTrueExpr.INSTANCE;
          }
        }
      }
      if (expr.length === 1) {
        return expr[0];
      }
    }
    return new _ContextKeyOrExpr(expr, negated);
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const result = [];
    for (const expr of this.expr) {
      result.push(...expr.keys());
    }
    return result;
  }
  map(mapFnc) {
    return new _ContextKeyOrExpr(this.expr.map((expr) => expr.map(mapFnc)), null);
  }
  negate() {
    if (!this.negated) {
      const result = [];
      for (const expr of this.expr) {
        result.push(expr.negate());
      }
      while (result.length > 1) {
        const LEFT = result.shift();
        const RIGHT = result.shift();
        const all = [];
        for (const left of getTerminals(LEFT)) {
          for (const right of getTerminals(RIGHT)) {
            all.push(ContextKeyAndExpr.create([left, right], null, false));
          }
        }
        result.unshift(_ContextKeyOrExpr.create(all, null, false));
      }
      this.negated = _ContextKeyOrExpr.create(result, this, true);
    }
    return this.negated;
  }
};
var RawContextKey = class _RawContextKey extends ContextKeyDefinedExpr {
  static {
    this._info = [];
  }
  static all() {
    return _RawContextKey._info.values();
  }
  constructor(key, defaultValue, metaOrHide) {
    super(key, null);
    this._defaultValue = defaultValue;
    if (typeof metaOrHide === "object") {
      _RawContextKey._info.push({ ...metaOrHide, key });
    } else if (metaOrHide !== true) {
      _RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== void 0 ? typeof defaultValue : void 0 });
    }
  }
  bindTo(target) {
    return target.createKey(this.key, this._defaultValue);
  }
  getValue(target) {
    return target.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(value) {
    return ContextKeyEqualsExpr.create(this.key, value);
  }
  notEqualsTo(value) {
    return ContextKeyNotEqualsExpr.create(this.key, value);
  }
  greater(value) {
    return ContextKeyGreaterExpr.create(this.key, value);
  }
};
var IContextKeyService = createDecorator("contextKeyService");
function cmp1(key1, key2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  return 0;
}
function cmp2(key1, value1, key2, value2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  if (value1 < value2) {
    return -1;
  }
  if (value1 > value2) {
    return 1;
  }
  return 0;
}
function getTerminals(node) {
  if (node.type === 9) {
    return node.expr;
  }
  return [node];
}

// out-build/vs/platform/log/common/log.js
var ILogService = createDecorator("logService");
var ILoggerService = createDecorator("loggerService");
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Off"] = 0] = "Off";
  LogLevel2[LogLevel2["Trace"] = 1] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 2] = "Debug";
  LogLevel2[LogLevel2["Info"] = 3] = "Info";
  LogLevel2[LogLevel2["Warning"] = 4] = "Warning";
  LogLevel2[LogLevel2["Error"] = 5] = "Error";
})(LogLevel || (LogLevel = {}));
var DEFAULT_LOG_LEVEL = LogLevel.Info;
function canLog(loggerLevel, messageLevel) {
  return loggerLevel !== LogLevel.Off && loggerLevel <= messageLevel;
}
function log(logger, level, message) {
  switch (level) {
    case LogLevel.Trace:
      logger.trace(message);
      break;
    case LogLevel.Debug:
      logger.debug(message);
      break;
    case LogLevel.Info:
      logger.info(message);
      break;
    case LogLevel.Warning:
      logger.warn(message);
      break;
    case LogLevel.Error:
      logger.error(message);
      break;
    case LogLevel.Off:
      break;
    default:
      throw new Error(`Invalid log level ${level}`);
  }
}
function format3(args, verbose = false) {
  let result = "";
  for (let i = 0; i < args.length; i++) {
    let a = args[i];
    if (a instanceof Error) {
      a = toErrorMessage(a, verbose);
    }
    if (typeof a === "object") {
      try {
        a = JSON.stringify(a);
      } catch (e) {
      }
    }
    result += (i > 0 ? " " : "") + a;
  }
  return result;
}
var AbstractLogger = class extends Disposable {
  constructor() {
    super(...arguments);
    this.level = DEFAULT_LOG_LEVEL;
    this._onDidChangeLogLevel = this._register(new Emitter());
  }
  get onDidChangeLogLevel() {
    return this._onDidChangeLogLevel.event;
  }
  setLevel(level) {
    if (this.level !== level) {
      this.level = level;
      this._onDidChangeLogLevel.fire(this.level);
    }
  }
  getLevel() {
    return this.level;
  }
  checkLogLevel(level) {
    return canLog(this.level, level);
  }
  canLog(level) {
    if (this._store.isDisposed) {
      return false;
    }
    return this.checkLogLevel(level);
  }
};
var AbstractMessageLogger = class extends AbstractLogger {
  constructor(logAlways) {
    super();
    this.logAlways = logAlways;
  }
  checkLogLevel(level) {
    return this.logAlways || super.checkLogLevel(level);
  }
  trace(message, ...args) {
    if (this.canLog(LogLevel.Trace)) {
      this.log(LogLevel.Trace, format3([message, ...args], true));
    }
  }
  debug(message, ...args) {
    if (this.canLog(LogLevel.Debug)) {
      this.log(LogLevel.Debug, format3([message, ...args]));
    }
  }
  info(message, ...args) {
    if (this.canLog(LogLevel.Info)) {
      this.log(LogLevel.Info, format3([message, ...args]));
    }
  }
  warn(message, ...args) {
    if (this.canLog(LogLevel.Warning)) {
      this.log(LogLevel.Warning, format3([message, ...args]));
    }
  }
  error(message, ...args) {
    if (this.canLog(LogLevel.Error)) {
      if (message instanceof Error) {
        const array = Array.prototype.slice.call(arguments);
        array[0] = message.stack;
        this.log(LogLevel.Error, format3(array));
      } else {
        this.log(LogLevel.Error, format3([message, ...args]));
      }
    }
  }
  flush() {
  }
};
var MultiplexLogger = class extends AbstractLogger {
  constructor(loggers) {
    super();
    this.loggers = loggers;
    if (loggers.length) {
      this.setLevel(loggers[0].getLevel());
    }
  }
  setLevel(level) {
    for (const logger of this.loggers) {
      logger.setLevel(level);
    }
    super.setLevel(level);
  }
  trace(message, ...args) {
    for (const logger of this.loggers) {
      logger.trace(message, ...args);
    }
  }
  debug(message, ...args) {
    for (const logger of this.loggers) {
      logger.debug(message, ...args);
    }
  }
  info(message, ...args) {
    for (const logger of this.loggers) {
      logger.info(message, ...args);
    }
  }
  warn(message, ...args) {
    for (const logger of this.loggers) {
      logger.warn(message, ...args);
    }
  }
  error(message, ...args) {
    for (const logger of this.loggers) {
      logger.error(message, ...args);
    }
  }
  flush() {
    for (const logger of this.loggers) {
      logger.flush();
    }
  }
  dispose() {
    for (const logger of this.loggers) {
      logger.dispose();
    }
    super.dispose();
  }
};
var AbstractLoggerService = class extends Disposable {
  constructor(logLevel, logsHome, loggerResources) {
    super();
    this.logLevel = logLevel;
    this.logsHome = logsHome;
    this._loggers = new ResourceMap();
    this._onDidChangeLoggers = this._register(new Emitter());
    this.onDidChangeLoggers = this._onDidChangeLoggers.event;
    this._onDidChangeLogLevel = this._register(new Emitter());
    this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    if (loggerResources) {
      for (const loggerResource of loggerResources) {
        this._loggers.set(loggerResource.resource, { logger: void 0, info: loggerResource });
      }
    }
  }
  getLoggerEntry(resourceOrId) {
    if (isString(resourceOrId)) {
      return [...this._loggers.values()].find((logger) => logger.info.id === resourceOrId);
    }
    return this._loggers.get(resourceOrId);
  }
  getLogger(resourceOrId) {
    return this.getLoggerEntry(resourceOrId)?.logger;
  }
  createLogger(idOrResource, options2) {
    const resource = this.toResource(idOrResource);
    const id2 = isString(idOrResource) ? idOrResource : options2?.id ?? hash(resource.toString()).toString(16);
    let logger = this._loggers.get(resource)?.logger;
    const logLevel = options2?.logLevel === "always" ? LogLevel.Trace : options2?.logLevel;
    if (!logger) {
      logger = this.doCreateLogger(resource, logLevel ?? this.getLogLevel(resource) ?? this.logLevel, { ...options2, id: id2 });
    }
    const loggerEntry = {
      logger,
      info: {
        resource,
        id: id2,
        logLevel,
        name: options2?.name,
        hidden: options2?.hidden,
        group: options2?.group,
        extensionId: options2?.extensionId,
        when: options2?.when
      }
    };
    this.registerLogger(loggerEntry.info);
    this._loggers.set(resource, loggerEntry);
    return logger;
  }
  toResource(idOrResource) {
    return isString(idOrResource) ? joinPath(this.logsHome, `${idOrResource}.log`) : idOrResource;
  }
  setLogLevel(arg1, arg2) {
    if (URI.isUri(arg1)) {
      const resource = arg1;
      const logLevel = arg2;
      const logger = this._loggers.get(resource);
      if (logger && logLevel !== logger.info.logLevel) {
        logger.info.logLevel = logLevel === this.logLevel ? void 0 : logLevel;
        logger.logger?.setLevel(logLevel);
        this._loggers.set(logger.info.resource, logger);
        this._onDidChangeLogLevel.fire([resource, logLevel]);
      }
    } else {
      this.logLevel = arg1;
      for (const [resource, logger] of this._loggers.entries()) {
        if (this._loggers.get(resource)?.info.logLevel === void 0) {
          logger.logger?.setLevel(this.logLevel);
        }
      }
      this._onDidChangeLogLevel.fire(this.logLevel);
    }
  }
  setVisibility(resourceOrId, visibility) {
    const logger = this.getLoggerEntry(resourceOrId);
    if (logger && visibility !== !logger.info.hidden) {
      logger.info.hidden = !visibility;
      this._loggers.set(logger.info.resource, logger);
      this._onDidChangeVisibility.fire([logger.info.resource, visibility]);
    }
  }
  getLogLevel(resource) {
    let logLevel;
    if (resource) {
      logLevel = this._loggers.get(resource)?.info.logLevel;
    }
    return logLevel ?? this.logLevel;
  }
  registerLogger(resource) {
    const existing = this._loggers.get(resource.resource);
    if (existing) {
      if (existing.info.hidden !== resource.hidden) {
        this.setVisibility(resource.resource, !resource.hidden);
      }
    } else {
      this._loggers.set(resource.resource, { info: resource, logger: void 0 });
      this._onDidChangeLoggers.fire({ added: [resource], removed: [] });
    }
  }
  deregisterLogger(idOrResource) {
    const resource = this.toResource(idOrResource);
    const existing = this._loggers.get(resource);
    if (existing) {
      if (existing.logger) {
        existing.logger.dispose();
      }
      this._loggers.delete(resource);
      this._onDidChangeLoggers.fire({ added: [], removed: [existing.info] });
    }
  }
  *getRegisteredLoggers() {
    for (const entry of this._loggers.values()) {
      yield entry.info;
    }
  }
  getRegisteredLogger(resource) {
    return this._loggers.get(resource)?.info;
  }
  dispose() {
    this._loggers.forEach((logger) => logger.logger?.dispose());
    this._loggers.clear();
    super.dispose();
  }
};
function LogLevelToString(logLevel) {
  switch (logLevel) {
    case LogLevel.Trace:
      return "trace";
    case LogLevel.Debug:
      return "debug";
    case LogLevel.Info:
      return "info";
    case LogLevel.Warning:
      return "warn";
    case LogLevel.Error:
      return "error";
    case LogLevel.Off:
      return "off";
  }
}
function parseLogLevel(logLevel) {
  switch (logLevel) {
    case "trace":
      return LogLevel.Trace;
    case "debug":
      return LogLevel.Debug;
    case "info":
      return LogLevel.Info;
    case "warn":
      return LogLevel.Warning;
    case "error":
      return LogLevel.Error;
    case "critical":
      return LogLevel.Error;
    case "off":
      return LogLevel.Off;
  }
  return void 0;
}
var CONTEXT_LOG_LEVEL = new RawContextKey("logLevel", LogLevelToString(LogLevel.Info));

// out-build/vs/platform/instantiation/common/descriptors.js
var SyncDescriptor = class {
  constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
    this.ctor = ctor;
    this.staticArguments = staticArguments;
    this.supportsDelayedInstantiation = supportsDelayedInstantiation;
  }
};

// out-build/vs/platform/instantiation/common/extensions.js
var _registry = [];
var InstantiationType;
(function(InstantiationType2) {
  InstantiationType2[InstantiationType2["Eager"] = 0] = "Eager";
  InstantiationType2[InstantiationType2["Delayed"] = 1] = "Delayed";
})(InstantiationType || (InstantiationType = {}));
function registerSingleton(id2, ctorOrDescriptor, supportsDelayedInstantiation) {
  if (!(ctorOrDescriptor instanceof SyncDescriptor)) {
    ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));
  }
  _registry.push([id2, ctorOrDescriptor]);
}
function getSingletonServiceDescriptors() {
  return _registry;
}

// out-build/vs/platform/instantiation/common/serviceCollection.js
var ServiceCollection = class {
  constructor(...entries) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [id2, service] of entries) {
      this.set(id2, service);
    }
  }
  set(id2, instanceOrDescriptor) {
    const result = this._entries.get(id2);
    this._entries.set(id2, instanceOrDescriptor);
    return result;
  }
  has(id2) {
    return this._entries.has(id2);
  }
  get(id2) {
    return this._entries.get(id2);
  }
};

// out-build/vs/workbench/api/common/extHostInitDataService.js
var IExtHostInitDataService = createDecorator("IExtHostInitDataService");

// out-build/vs/platform/instantiation/common/graph.js
var Node2 = class {
  constructor(key, data2) {
    this.key = key;
    this.data = data2;
    this.incoming = /* @__PURE__ */ new Map();
    this.outgoing = /* @__PURE__ */ new Map();
  }
};
var Graph = class {
  constructor(_hashFn) {
    this._hashFn = _hashFn;
    this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const ret = [];
    for (const node of this._nodes.values()) {
      if (node.outgoing.size === 0) {
        ret.push(node);
      }
    }
    return ret;
  }
  insertEdge(from, to) {
    const fromNode = this.lookupOrInsertNode(from);
    const toNode = this.lookupOrInsertNode(to);
    fromNode.outgoing.set(toNode.key, toNode);
    toNode.incoming.set(fromNode.key, fromNode);
  }
  removeNode(data2) {
    const key = this._hashFn(data2);
    this._nodes.delete(key);
    for (const node of this._nodes.values()) {
      node.outgoing.delete(key);
      node.incoming.delete(key);
    }
  }
  lookupOrInsertNode(data2) {
    const key = this._hashFn(data2);
    let node = this._nodes.get(key);
    if (!node) {
      node = new Node2(key, data2);
      this._nodes.set(key, node);
    }
    return node;
  }
  lookup(data2) {
    return this._nodes.get(this._hashFn(data2));
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const data2 = [];
    for (const [key, value] of this._nodes) {
      data2.push(`${key}
	(-> incoming)[${[...value.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...value.outgoing.keys()].join(",")}]
`);
    }
    return data2.join("\n");
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [id2, node] of this._nodes) {
      const seen = /* @__PURE__ */ new Set([id2]);
      const res = this._findCycle(node, seen);
      if (res) {
        return res;
      }
    }
    return void 0;
  }
  _findCycle(node, seen) {
    for (const [id2, outgoing] of node.outgoing) {
      if (seen.has(id2)) {
        return [...seen, id2].join(" -> ");
      }
      seen.add(id2);
      const value = this._findCycle(outgoing, seen);
      if (value) {
        return value;
      }
      seen.delete(id2);
    }
    return void 0;
  }
};

// out-build/vs/platform/instantiation/common/instantiationService.js
var _enableAllTracing = false;
var CyclicDependencyError = class extends Error {
  constructor(graph) {
    super("cyclic dependency between services");
    this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${graph.toString()}`;
  }
};
var InstantiationService = class _InstantiationService {
  constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {
    this._services = _services;
    this._strict = _strict;
    this._parent = _parent;
    this._enableTracing = _enableTracing;
    this._isDisposed = false;
    this._servicesToMaybeDispose = /* @__PURE__ */ new Set();
    this._children = /* @__PURE__ */ new Set();
    this._activeInstantiations = /* @__PURE__ */ new Set();
    this._services.set(IInstantiationService, this);
    this._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph((e) => e) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = true;
      dispose(this._children);
      this._children.clear();
      for (const candidate of this._servicesToMaybeDispose) {
        if (isDisposable(candidate)) {
          candidate.dispose();
        }
      }
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed) {
      throw new Error("InstantiationService has been disposed");
    }
  }
  createChild(services, store) {
    this._throwIfDisposed();
    const that = this;
    const result = new class extends _InstantiationService {
      dispose() {
        that._children.delete(result);
        super.dispose();
      }
    }(services, this._strict, this, this._enableTracing);
    this._children.add(result);
    store?.add(result);
    return result;
  }
  invokeFunction(fn, ...args) {
    this._throwIfDisposed();
    const _trace = Trace.traceInvocation(this._enableTracing, fn);
    let _done = false;
    try {
      const accessor = {
        get: (id2) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id2, _trace);
          if (!result) {
            throw new Error(`[invokeFunction] unknown service '${id2}'`);
          }
          return result;
        },
        getIfExists: (id2) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id2, _trace);
          return result;
        }
      };
      return fn(accessor, ...args);
    } finally {
      _done = true;
      _trace.stop();
    }
  }
  createInstance(ctorOrDescriptor, ...rest) {
    this._throwIfDisposed();
    let _trace;
    let result;
    if (ctorOrDescriptor instanceof SyncDescriptor) {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);
      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);
    } else {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);
      result = this._createInstance(ctorOrDescriptor, rest, _trace);
    }
    _trace.stop();
    return result;
  }
  _createInstance(ctor, args = [], _trace) {
    const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
    const serviceArgs = [];
    for (const dependency of serviceDependencies) {
      const service = this._getOrCreateServiceInstance(dependency.id, _trace);
      if (!service) {
        this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);
      }
      serviceArgs.push(service);
    }
    const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
    if (args.length !== firstServiceArgPos) {
      console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);
      const delta3 = firstServiceArgPos - args.length;
      if (delta3 > 0) {
        args = args.concat(new Array(delta3));
      } else {
        args = args.slice(0, firstServiceArgPos);
      }
    }
    return Reflect.construct(ctor, args.concat(serviceArgs));
  }
  _setCreatedServiceInstance(id2, instance) {
    if (this._services.get(id2) instanceof SyncDescriptor) {
      this._services.set(id2, instance);
    } else if (this._parent) {
      this._parent._setCreatedServiceInstance(id2, instance);
    } else {
      throw new Error("illegalState - setting UNKNOWN service instance");
    }
  }
  _getServiceInstanceOrDescriptor(id2) {
    const instanceOrDesc = this._services.get(id2);
    if (!instanceOrDesc && this._parent) {
      return this._parent._getServiceInstanceOrDescriptor(id2);
    } else {
      return instanceOrDesc;
    }
  }
  _getOrCreateServiceInstance(id2, _trace) {
    if (this._globalGraph && this._globalGraphImplicitDependency) {
      this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id2));
    }
    const thing = this._getServiceInstanceOrDescriptor(id2);
    if (thing instanceof SyncDescriptor) {
      return this._safeCreateAndCacheServiceInstance(id2, thing, _trace.branch(id2, true));
    } else {
      _trace.branch(id2, false);
      return thing;
    }
  }
  _safeCreateAndCacheServiceInstance(id2, desc, _trace) {
    if (this._activeInstantiations.has(id2)) {
      throw new Error(`illegal state - RECURSIVELY instantiating service '${id2}'`);
    }
    this._activeInstantiations.add(id2);
    try {
      return this._createAndCacheServiceInstance(id2, desc, _trace);
    } finally {
      this._activeInstantiations.delete(id2);
    }
  }
  _createAndCacheServiceInstance(id2, desc, _trace) {
    const graph = new Graph((data2) => data2.id.toString());
    let cycleCount = 0;
    const stack = [{ id: id2, desc, _trace }];
    const seen = /* @__PURE__ */ new Set();
    while (stack.length) {
      const item = stack.pop();
      if (seen.has(String(item.id))) {
        continue;
      }
      seen.add(String(item.id));
      graph.lookupOrInsertNode(item);
      if (cycleCount++ > 1e3) {
        throw new CyclicDependencyError(graph);
      }
      for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
        if (!instanceOrDesc) {
          this._throwIfStrict(`[createInstance] ${id2} depends on ${dependency.id} which is NOT registered.`, true);
        }
        this._globalGraph?.insertEdge(String(item.id), String(dependency.id));
        if (instanceOrDesc instanceof SyncDescriptor) {
          const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };
          graph.insertEdge(item, d);
          stack.push(d);
        }
      }
    }
    while (true) {
      const roots = graph.roots();
      if (roots.length === 0) {
        if (!graph.isEmpty()) {
          throw new CyclicDependencyError(graph);
        }
        break;
      }
      for (const { data: data2 } of roots) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data2.id);
        if (instanceOrDesc instanceof SyncDescriptor) {
          const instance = this._createServiceInstanceWithOwner(data2.id, data2.desc.ctor, data2.desc.staticArguments, data2.desc.supportsDelayedInstantiation, data2._trace);
          this._setCreatedServiceInstance(data2.id, instance);
        }
        graph.removeNode(data2);
      }
    }
    return this._getServiceInstanceOrDescriptor(id2);
  }
  _createServiceInstanceWithOwner(id2, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (this._services.get(id2) instanceof SyncDescriptor) {
      return this._createServiceInstance(id2, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);
    } else if (this._parent) {
      return this._parent._createServiceInstanceWithOwner(id2, ctor, args, supportsDelayedInstantiation, _trace);
    } else {
      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
  }
  _createServiceInstance(id2, ctor, args = [], supportsDelayedInstantiation, _trace, disposeBucket) {
    if (!supportsDelayedInstantiation) {
      const result = this._createInstance(ctor, args, _trace);
      disposeBucket.add(result);
      return result;
    } else {
      const child = new _InstantiationService(void 0, this._strict, this, this._enableTracing);
      child._globalGraphImplicitDependency = String(id2);
      const earlyListeners = /* @__PURE__ */ new Map();
      const idle = new GlobalIdleValue(() => {
        const result = child._createInstance(ctor, args, _trace);
        for (const [key, values] of earlyListeners) {
          const candidate = result[key];
          if (typeof candidate === "function") {
            for (const value of values) {
              value.disposable = candidate.apply(result, value.listener);
            }
          }
        }
        earlyListeners.clear();
        disposeBucket.add(result);
        return result;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(target, key) {
          if (!idle.isInitialized) {
            if (typeof key === "string" && (key.startsWith("onDid") || key.startsWith("onWill"))) {
              let list2 = earlyListeners.get(key);
              if (!list2) {
                list2 = new LinkedList();
                earlyListeners.set(key, list2);
              }
              const event = (callback, thisArg, disposables) => {
                if (idle.isInitialized) {
                  return idle.value[key](callback, thisArg, disposables);
                } else {
                  const entry = { listener: [callback, thisArg, disposables], disposable: void 0 };
                  const rm = list2.push(entry);
                  const result = toDisposable(() => {
                    rm();
                    entry.disposable?.dispose();
                  });
                  return result;
                }
              };
              return event;
            }
          }
          if (key in target) {
            return target[key];
          }
          const obj = idle.value;
          let prop = obj[key];
          if (typeof prop !== "function") {
            return prop;
          }
          prop = prop.bind(obj);
          target[key] = prop;
          return prop;
        },
        set(_target, p, value) {
          idle.value[p] = value;
          return true;
        },
        getPrototypeOf(_target) {
          return ctor.prototype;
        }
      });
    }
  }
  _throwIfStrict(msg, printWarning) {
    if (printWarning) {
      console.warn(msg);
    }
    if (this._strict) {
      throw new Error(msg);
    }
  }
};
var TraceType;
(function(TraceType2) {
  TraceType2[TraceType2["None"] = 0] = "None";
  TraceType2[TraceType2["Creation"] = 1] = "Creation";
  TraceType2[TraceType2["Invocation"] = 2] = "Invocation";
  TraceType2[TraceType2["Branch"] = 3] = "Branch";
})(TraceType || (TraceType = {}));
var Trace = class _Trace {
  static {
    this.all = /* @__PURE__ */ new Set();
  }
  static {
    this._None = new class extends _Trace {
      constructor() {
        super(0, null);
      }
      stop() {
      }
      branch() {
        return this;
      }
    }();
  }
  static traceInvocation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(2, ctor.name || new Error().stack.split("\n").slice(3, 4).join("\n"));
  }
  static traceCreation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(1, ctor.name);
  }
  static {
    this._totals = 0;
  }
  constructor(type, name2) {
    this.type = type;
    this.name = name2;
    this._start = Date.now();
    this._dep = [];
  }
  branch(id2, first) {
    const child = new _Trace(3, id2.toString());
    this._dep.push([id2, first, child]);
    return child;
  }
  stop() {
    const dur = Date.now() - this._start;
    _Trace._totals += dur;
    let causedCreation = false;
    function printChild(n, trace) {
      const res = [];
      const prefix = new Array(n + 1).join("	");
      for (const [id2, first, child] of trace._dep) {
        if (first && child) {
          causedCreation = true;
          res.push(`${prefix}CREATES -> ${id2}`);
          const nested = printChild(n + 1, child);
          if (nested) {
            res.push(nested);
          }
        } else {
          res.push(`${prefix}uses -> ${id2}`);
        }
      }
      return res.join("\n");
    }
    const lines = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${printChild(1, this)}`,
      `DONE, took ${dur.toFixed(2)}ms (grand total ${_Trace._totals.toFixed(2)}ms)`
    ];
    if (dur > 2 || causedCreation) {
      _Trace.all.add(lines.join("\n"));
    }
  }
};

// out-build/vs/workbench/api/common/extHostRpcService.js
var IExtHostRpcService = createDecorator("IExtHostRpcService");
var ExtHostRpcService = class {
  constructor(rpcProtocol) {
    this.getProxy = rpcProtocol.getProxy.bind(rpcProtocol);
    this.set = rpcProtocol.set.bind(rpcProtocol);
    this.dispose = rpcProtocol.dispose.bind(rpcProtocol);
    this.assertRegistered = rpcProtocol.assertRegistered.bind(rpcProtocol);
    this.drain = rpcProtocol.drain.bind(rpcProtocol);
  }
};

// out-build/vs/workbench/api/common/extHostUriTransformerService.js
var IURITransformerService = createDecorator("IURITransformerService");
var URITransformerService = class {
  constructor(delegate) {
    if (!delegate) {
      this.transformIncoming = (arg) => arg;
      this.transformOutgoing = (arg) => arg;
      this.transformOutgoingURI = (arg) => arg;
      this.transformOutgoingScheme = (arg) => arg;
    } else {
      this.transformIncoming = delegate.transformIncoming.bind(delegate);
      this.transformOutgoing = delegate.transformOutgoing.bind(delegate);
      this.transformOutgoingURI = delegate.transformOutgoingURI.bind(delegate);
      this.transformOutgoingScheme = delegate.transformOutgoingScheme.bind(delegate);
    }
  }
};

// out-build/vs/base/common/ternarySearchTree.js
var StringIterator = class {
  constructor() {
    this._value = "";
    this._pos = 0;
  }
  reset(key) {
    this._value = key;
    this._pos = 0;
    return this;
  }
  next() {
    this._pos += 1;
    return this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(a) {
    const aCode = a.charCodeAt(0);
    const thisCode = this._value.charCodeAt(this._pos);
    return aCode - thisCode;
  }
  value() {
    return this._value[this._pos];
  }
};
var ConfigKeysIterator = class {
  constructor(_caseSensitive = true) {
    this._caseSensitive = _caseSensitive;
  }
  reset(key) {
    this._value = key;
    this._from = 0;
    this._to = 0;
    return this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let justSeps = true;
    for (; this._to < this._value.length; this._to++) {
      const ch = this._value.charCodeAt(this._to);
      if (ch === 46) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }
    return this;
  }
  cmp(a) {
    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
};
var PathIterator = class {
  constructor(_splitOnBackslash = true, _caseSensitive = true) {
    this._splitOnBackslash = _splitOnBackslash;
    this._caseSensitive = _caseSensitive;
  }
  reset(key) {
    this._from = 0;
    this._to = 0;
    this._value = key;
    this._valueLen = key.length;
    for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {
      const ch = this._value.charCodeAt(pos);
      if (!(ch === 47 || this._splitOnBackslash && ch === 92)) {
        break;
      }
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let justSeps = true;
    for (; this._to < this._valueLen; this._to++) {
      const ch = this._value.charCodeAt(this._to);
      if (ch === 47 || this._splitOnBackslash && ch === 92) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }
    return this;
  }
  cmp(a) {
    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
};
var UriIteratorState;
(function(UriIteratorState2) {
  UriIteratorState2[UriIteratorState2["Scheme"] = 1] = "Scheme";
  UriIteratorState2[UriIteratorState2["Authority"] = 2] = "Authority";
  UriIteratorState2[UriIteratorState2["Path"] = 3] = "Path";
  UriIteratorState2[UriIteratorState2["Query"] = 4] = "Query";
  UriIteratorState2[UriIteratorState2["Fragment"] = 5] = "Fragment";
})(UriIteratorState || (UriIteratorState = {}));
var UriIterator = class {
  constructor(_ignorePathCasing, _ignoreQueryAndFragment) {
    this._ignorePathCasing = _ignorePathCasing;
    this._ignoreQueryAndFragment = _ignoreQueryAndFragment;
    this._states = [];
    this._stateIdx = 0;
  }
  reset(key) {
    this._value = key;
    this._states = [];
    if (this._value.scheme) {
      this._states.push(
        1
        /* UriIteratorState.Scheme */
      );
    }
    if (this._value.authority) {
      this._states.push(
        2
        /* UriIteratorState.Authority */
      );
    }
    if (this._value.path) {
      this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));
      this._pathIterator.reset(key.path);
      if (this._pathIterator.value()) {
        this._states.push(
          3
          /* UriIteratorState.Path */
        );
      }
    }
    if (!this._ignoreQueryAndFragment(key)) {
      if (this._value.query) {
        this._states.push(
          4
          /* UriIteratorState.Query */
        );
      }
      if (this._value.fragment) {
        this._states.push(
          5
          /* UriIteratorState.Fragment */
        );
      }
    }
    this._stateIdx = 0;
    return this;
  }
  next() {
    if (this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) {
      this._pathIterator.next();
    } else {
      this._stateIdx += 1;
    }
    return this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(a) {
    if (this._states[this._stateIdx] === 1) {
      return compareIgnoreCase(a, this._value.scheme);
    } else if (this._states[this._stateIdx] === 2) {
      return compareIgnoreCase(a, this._value.authority);
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.cmp(a);
    } else if (this._states[this._stateIdx] === 4) {
      return compare(a, this._value.query);
    } else if (this._states[this._stateIdx] === 5) {
      return compare(a, this._value.fragment);
    }
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1) {
      return this._value.scheme;
    } else if (this._states[this._stateIdx] === 2) {
      return this._value.authority;
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.value();
    } else if (this._states[this._stateIdx] === 4) {
      return this._value.query;
    } else if (this._states[this._stateIdx] === 5) {
      return this._value.fragment;
    }
    throw new Error();
  }
};
var Undef = class _Undef {
  static {
    this.Val = Symbol("undefined_placeholder");
  }
  static wrap(value) {
    return value === void 0 ? _Undef.Val : value;
  }
  static unwrap(value) {
    return value === _Undef.Val ? void 0 : value;
  }
};
var TernarySearchTreeNode = class {
  constructor() {
    this.height = 1;
    this.value = void 0;
    this.key = void 0;
    this.left = void 0;
    this.mid = void 0;
    this.right = void 0;
  }
  isEmpty() {
    return !this.left && !this.mid && !this.right && this.value === void 0;
  }
  rotateLeft() {
    const tmp = this.right;
    this.right = tmp.left;
    tmp.left = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }
  rotateRight() {
    const tmp = this.left;
    this.left = tmp.right;
    tmp.right = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    return this.left?.height ?? 0;
  }
  get heightRight() {
    return this.right?.height ?? 0;
  }
};
var Dir;
(function(Dir2) {
  Dir2[Dir2["Left"] = -1] = "Left";
  Dir2[Dir2["Mid"] = 0] = "Mid";
  Dir2[Dir2["Right"] = 1] = "Right";
})(Dir || (Dir = {}));
var TernarySearchTree = class _TernarySearchTree {
  static forUris(ignorePathCasing2 = () => false, ignoreQueryAndFragment = () => false) {
    return new _TernarySearchTree(new UriIterator(ignorePathCasing2, ignoreQueryAndFragment));
  }
  static forPaths(ignorePathCasing2 = false) {
    return new _TernarySearchTree(new PathIterator(void 0, !ignorePathCasing2));
  }
  static forStrings() {
    return new _TernarySearchTree(new StringIterator());
  }
  static forConfigKeys() {
    return new _TernarySearchTree(new ConfigKeysIterator());
  }
  constructor(segments) {
    this._iter = segments;
  }
  clear() {
    this._root = void 0;
  }
  fill(values, keys) {
    if (keys) {
      const arr = keys.slice(0);
      shuffle(arr);
      for (const k of arr) {
        this.set(k, values);
      }
    } else {
      const arr = values.slice(0);
      shuffle(arr);
      for (const entry of arr) {
        this.set(entry[0], entry[1]);
      }
    }
  }
  set(key, element) {
    const iter = this._iter.reset(key);
    let node;
    if (!this._root) {
      this._root = new TernarySearchTreeNode();
      this._root.segment = iter.value();
    }
    const stack = [];
    node = this._root;
    while (true) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        if (!node.left) {
          node.left = new TernarySearchTreeNode();
          node.left.segment = iter.value();
        }
        stack.push([-1, node]);
        node = node.left;
      } else if (val < 0) {
        if (!node.right) {
          node.right = new TernarySearchTreeNode();
          node.right.segment = iter.value();
        }
        stack.push([1, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        if (!node.mid) {
          node.mid = new TernarySearchTreeNode();
          node.mid.segment = iter.value();
        }
        stack.push([0, node]);
        node = node.mid;
      } else {
        break;
      }
    }
    const oldElement = Undef.unwrap(node.value);
    node.value = Undef.wrap(element);
    node.key = key;
    for (let i = stack.length - 1; i >= 0; i--) {
      const node2 = stack[i][1];
      node2.updateHeight();
      const bf = node2.balanceFactor();
      if (bf < -1 || bf > 1) {
        const d1 = stack[i][0];
        const d2 = stack[i + 1][0];
        if (d1 === 1 && d2 === 1) {
          stack[i][1] = node2.rotateLeft();
        } else if (d1 === -1 && d2 === -1) {
          stack[i][1] = node2.rotateRight();
        } else if (d1 === 1 && d2 === -1) {
          node2.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();
          stack[i][1] = node2.rotateLeft();
        } else if (d1 === -1 && d2 === 1) {
          node2.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();
          stack[i][1] = node2.rotateRight();
        } else {
          throw new Error();
        }
        if (i > 0) {
          switch (stack[i - 1][0]) {
            case -1:
              stack[i - 1][1].left = stack[i][1];
              break;
            case 1:
              stack[i - 1][1].right = stack[i][1];
              break;
            case 0:
              stack[i - 1][1].mid = stack[i][1];
              break;
          }
        } else {
          this._root = stack[0][1];
        }
      }
    }
    return oldElement;
  }
  get(key) {
    return Undef.unwrap(this._getNode(key)?.value);
  }
  _getNode(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        node = node.mid;
      } else {
        break;
      }
    }
    return node;
  }
  has(key) {
    const node = this._getNode(key);
    return !(node?.value === void 0 && node?.mid === void 0);
  }
  delete(key) {
    return this._delete(key, false);
  }
  deleteSuperstr(key) {
    return this._delete(key, true);
  }
  _delete(key, superStr) {
    const iter = this._iter.reset(key);
    const stack = [];
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        stack.push([-1, node]);
        node = node.left;
      } else if (val < 0) {
        stack.push([1, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        stack.push([0, node]);
        node = node.mid;
      } else {
        break;
      }
    }
    if (!node) {
      return;
    }
    if (superStr) {
      node.left = void 0;
      node.mid = void 0;
      node.right = void 0;
      node.height = 1;
    } else {
      node.key = void 0;
      node.value = void 0;
    }
    if (!node.mid && !node.value) {
      if (node.left && node.right) {
        const stack2 = [[1, node]];
        const min = this._min(node.right, stack2);
        if (min.key) {
          node.key = min.key;
          node.value = min.value;
          node.segment = min.segment;
          const newChild = min.right;
          if (stack2.length > 1) {
            const [dir, parent] = stack2[stack2.length - 1];
            switch (dir) {
              case -1:
                parent.left = newChild;
                break;
              case 0:
                assert(false);
              case 1:
                assert(false);
            }
          } else {
            node.right = newChild;
          }
          const newChild2 = this._balanceByStack(stack2);
          if (stack.length > 0) {
            const [dir, parent] = stack[stack.length - 1];
            switch (dir) {
              case -1:
                parent.left = newChild2;
                break;
              case 0:
                parent.mid = newChild2;
                break;
              case 1:
                parent.right = newChild2;
                break;
            }
          } else {
            this._root = newChild2;
          }
        }
      } else {
        const newChild = node.left ?? node.right;
        if (stack.length > 0) {
          const [dir, parent] = stack[stack.length - 1];
          switch (dir) {
            case -1:
              parent.left = newChild;
              break;
            case 0:
              parent.mid = newChild;
              break;
            case 1:
              parent.right = newChild;
              break;
          }
        } else {
          this._root = newChild;
        }
      }
    }
    this._root = this._balanceByStack(stack) ?? this._root;
  }
  _min(node, stack) {
    while (node.left) {
      stack.push([-1, node]);
      node = node.left;
    }
    return node;
  }
  _balanceByStack(stack) {
    for (let i = stack.length - 1; i >= 0; i--) {
      const node = stack[i][1];
      node.updateHeight();
      const bf = node.balanceFactor();
      if (bf > 1) {
        if (node.right.balanceFactor() >= 0) {
          stack[i][1] = node.rotateLeft();
        } else {
          node.right = node.right.rotateRight();
          stack[i][1] = node.rotateLeft();
        }
      } else if (bf < -1) {
        if (node.left.balanceFactor() <= 0) {
          stack[i][1] = node.rotateRight();
        } else {
          node.left = node.left.rotateLeft();
          stack[i][1] = node.rotateRight();
        }
      }
      if (i > 0) {
        switch (stack[i - 1][0]) {
          case -1:
            stack[i - 1][1].left = stack[i][1];
            break;
          case 1:
            stack[i - 1][1].right = stack[i][1];
            break;
          case 0:
            stack[i - 1][1].mid = stack[i][1];
            break;
        }
      } else {
        return stack[0][1];
      }
    }
    return void 0;
  }
  findSubstr(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    let candidate = void 0;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        candidate = Undef.unwrap(node.value) || candidate;
        node = node.mid;
      } else {
        break;
      }
    }
    return node && Undef.unwrap(node.value) || candidate;
  }
  findSuperstr(key) {
    return this._findSuperstrOrElement(key, false);
  }
  _findSuperstrOrElement(key, allowValue) {
    const iter = this._iter.reset(key);
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        node = node.mid;
      } else {
        if (!node.mid) {
          if (allowValue) {
            return Undef.unwrap(node.value);
          } else {
            return void 0;
          }
        } else {
          return this._entries(node.mid);
        }
      }
    }
    return void 0;
  }
  hasElementOrSubtree(key) {
    return this._findSuperstrOrElement(key, true) !== void 0;
  }
  forEach(callback) {
    for (const [key, value] of this) {
      callback(value, key);
    }
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(node) {
    const result = [];
    this._dfsEntries(node, result);
    return result[Symbol.iterator]();
  }
  _dfsEntries(node, bucket) {
    if (!node) {
      return;
    }
    if (node.left) {
      this._dfsEntries(node.left, bucket);
    }
    if (node.value !== void 0) {
      bucket.push([node.key, Undef.unwrap(node.value)]);
    }
    if (node.mid) {
      this._dfsEntries(node.mid, bucket);
    }
    if (node.right) {
      this._dfsEntries(node.right, bucket);
    }
  }
  // for debug/testing
  _isBalanced() {
    const nodeIsBalanced = (node) => {
      if (!node) {
        return true;
      }
      const bf = node.balanceFactor();
      if (bf < -1 || bf > 1) {
        return false;
      }
      return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);
    };
    return nodeIsBalanced(this._root);
  }
};

// out-build/vs/base/common/objects.js
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.entries(obj).forEach(([key, value]) => {
    result[key] = value && typeof value === "object" ? deepClone(value) : value;
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    const obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        const prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop) && !isTypedArray(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function cloneAndChange(obj, changer) {
  return _cloneAndChange(obj, changer, /* @__PURE__ */ new Set());
}
function _cloneAndChange(obj, changer, seen) {
  if (isUndefinedOrNull(obj)) {
    return obj;
  }
  const changed = changer(obj);
  if (typeof changed !== "undefined") {
    return changed;
  }
  if (Array.isArray(obj)) {
    const r1 = [];
    for (const e of obj) {
      r1.push(_cloneAndChange(e, changer, seen));
    }
    return r1;
  }
  if (isObject(obj)) {
    if (seen.has(obj)) {
      throw new Error("Cannot clone recursive data-structure");
    }
    seen.add(obj);
    const r2 = {};
    for (const i2 in obj) {
      if (_hasOwnProperty.call(obj, i2)) {
        r2[i2] = _cloneAndChange(obj[i2], changer, seen);
      }
    }
    seen.delete(obj);
    return r2;
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!isObject(destination)) {
    return source;
  }
  if (isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (isObject(destination[key]) && isObject(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals2(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals2(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals2(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function safeStringify2(obj) {
  const seen = /* @__PURE__ */ new Set();
  return JSON.stringify(obj, (key, value) => {
    if (isObject(value) || Array.isArray(value)) {
      if (seen.has(value)) {
        return "[Circular]";
      } else {
        seen.add(value);
      }
    }
    if (typeof value === "bigint") {
      return `[BigInt ${value.toString()}]`;
    }
    return value;
  });
}
function filter(obj, predicate) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    if (predicate(key, value)) {
      result[key] = value;
    }
  }
  return result;
}

// out-build/vs/base/common/numbers.js
var Counter = class {
  constructor() {
    this._next = 0;
  }
  getNext() {
    return this._next++;
  }
};

// out-build/vs/base/common/severity.js
var Severity;
(function(Severity3) {
  Severity3[Severity3["Ignore"] = 0] = "Ignore";
  Severity3[Severity3["Info"] = 1] = "Info";
  Severity3[Severity3["Warning"] = 2] = "Warning";
  Severity3[Severity3["Error"] = 3] = "Error";
})(Severity || (Severity = {}));
(function(Severity3) {
  const _error = "error";
  const _warning = "warning";
  const _warn = "warn";
  const _info = "info";
  const _ignore = "ignore";
  function fromValue(value) {
    if (!value) {
      return Severity3.Ignore;
    }
    if (equalsIgnoreCase(_error, value)) {
      return Severity3.Error;
    }
    if (equalsIgnoreCase(_warning, value) || equalsIgnoreCase(_warn, value)) {
      return Severity3.Warning;
    }
    if (equalsIgnoreCase(_info, value)) {
      return Severity3.Info;
    }
    return Severity3.Ignore;
  }
  Severity3.fromValue = fromValue;
  function toString(severity) {
    switch (severity) {
      case Severity3.Error:
        return _error;
      case Severity3.Warning:
        return _warning;
      case Severity3.Info:
        return _info;
      default:
        return _ignore;
    }
  }
  Severity3.toString = toString;
})(Severity || (Severity = {}));
var severity_default = Severity;

// out-build/vs/platform/notification/common/notification.js
var Severity2 = severity_default;
var INotificationService = createDecorator("notificationService");
var NotificationPriority;
(function(NotificationPriority2) {
  NotificationPriority2[NotificationPriority2["DEFAULT"] = 0] = "DEFAULT";
  NotificationPriority2[NotificationPriority2["OPTIONAL"] = 1] = "OPTIONAL";
  NotificationPriority2[NotificationPriority2["SILENT"] = 2] = "SILENT";
  NotificationPriority2[NotificationPriority2["URGENT"] = 3] = "URGENT";
})(NotificationPriority || (NotificationPriority = {}));
var NeverShowAgainScope;
(function(NeverShowAgainScope2) {
  NeverShowAgainScope2[NeverShowAgainScope2["WORKSPACE"] = 0] = "WORKSPACE";
  NeverShowAgainScope2[NeverShowAgainScope2["PROFILE"] = 1] = "PROFILE";
  NeverShowAgainScope2[NeverShowAgainScope2["APPLICATION"] = 2] = "APPLICATION";
})(NeverShowAgainScope || (NeverShowAgainScope = {}));
var NotificationsFilter;
(function(NotificationsFilter2) {
  NotificationsFilter2[NotificationsFilter2["OFF"] = 0] = "OFF";
  NotificationsFilter2[NotificationsFilter2["ERROR"] = 1] = "ERROR";
})(NotificationsFilter || (NotificationsFilter = {}));

// out-build/vs/platform/workspace/common/workspace.js
var IWorkspaceContextService = createDecorator("contextService");
function isSingleFolderWorkspaceIdentifier(obj) {
  const singleFolderIdentifier = obj;
  return typeof singleFolderIdentifier?.id === "string" && URI.isUri(singleFolderIdentifier.uri);
}
function isWorkspaceIdentifier(obj) {
  const workspaceIdentifier = obj;
  return typeof workspaceIdentifier?.id === "string" && URI.isUri(workspaceIdentifier.configPath);
}
var WorkbenchState;
(function(WorkbenchState2) {
  WorkbenchState2[WorkbenchState2["EMPTY"] = 1] = "EMPTY";
  WorkbenchState2[WorkbenchState2["FOLDER"] = 2] = "FOLDER";
  WorkbenchState2[WorkbenchState2["WORKSPACE"] = 3] = "WORKSPACE";
})(WorkbenchState || (WorkbenchState = {}));
var Workspace = class {
  get folders() {
    return this._folders;
  }
  set folders(folders) {
    this._folders = folders;
    this.updateFoldersMap();
  }
  constructor(_id, folders, _transient, _configuration, ignorePathCasing2) {
    this._id = _id;
    this._transient = _transient;
    this._configuration = _configuration;
    this.ignorePathCasing = ignorePathCasing2;
    this.foldersMap = TernarySearchTree.forUris(this.ignorePathCasing, () => true);
    this.folders = folders;
  }
  update(workspace) {
    this._id = workspace.id;
    this._configuration = workspace.configuration;
    this._transient = workspace.transient;
    this.ignorePathCasing = workspace.ignorePathCasing;
    this.folders = workspace.folders;
  }
  get id() {
    return this._id;
  }
  get transient() {
    return this._transient;
  }
  get configuration() {
    return this._configuration;
  }
  set configuration(configuration) {
    this._configuration = configuration;
  }
  getFolder(resource) {
    if (!resource) {
      return null;
    }
    return this.foldersMap.findSubstr(resource) || null;
  }
  updateFoldersMap() {
    this.foldersMap = TernarySearchTree.forUris(this.ignorePathCasing, () => true);
    for (const folder of this.folders) {
      this.foldersMap.set(folder.uri, folder);
    }
  }
  toJSON() {
    return { id: this.id, folders: this.folders, transient: this.transient, configuration: this.configuration };
  }
};
var WorkspaceFolder = class {
  constructor(data2, raw) {
    this.raw = raw;
    this.uri = data2.uri;
    this.index = data2.index;
    this.name = data2.name;
  }
  toResource(relativePath2) {
    return joinPath(this.uri, relativePath2);
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
};
function toWorkspaceFolder(resource) {
  return new WorkspaceFolder({ uri: resource, index: 0, name: basenameOrAuthority(resource) }, { uri: resource.toString() });
}
var WORKSPACE_EXTENSION = "code-workspace";
var WORKSPACE_SUFFIX = `.${WORKSPACE_EXTENSION}`;
var WORKSPACE_FILTER = [{ name: localize(2752, null), extensions: [WORKSPACE_EXTENSION] }];

// out-build/vs/workbench/api/common/extHostFileSystemInfo.js
var ExtHostFileSystemInfo = class {
  constructor() {
    this._systemSchemes = new Set(Object.keys(Schemas));
    this._providerInfo = /* @__PURE__ */ new Map();
    this.extUri = new ExtUri((uri) => {
      const capabilities = this._providerInfo.get(uri.scheme);
      if (capabilities === void 0) {
        return false;
      }
      if (capabilities & 1024) {
        return false;
      }
      return true;
    });
  }
  $acceptProviderInfos(uri, capabilities) {
    if (capabilities === null) {
      this._providerInfo.delete(uri.scheme);
    } else {
      this._providerInfo.set(uri.scheme, capabilities);
    }
  }
  isFreeScheme(scheme) {
    return !this._providerInfo.has(scheme) && !this._systemSchemes.has(scheme);
  }
  getCapabilities(scheme) {
    return this._providerInfo.get(scheme);
  }
};
var IExtHostFileSystemInfo = createDecorator("IExtHostFileSystemInfo");

// out-build/vs/base/common/uuid.js
var generateUuid = function() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID.bind(crypto);
  }
  const _data = new Uint8Array(16);
  const _hex = [];
  for (let i = 0; i < 256; i++) {
    _hex.push(i.toString(16).padStart(2, "0"));
  }
  return function generateUuid2() {
    crypto.getRandomValues(_data);
    _data[6] = _data[6] & 15 | 64;
    _data[8] = _data[8] & 63 | 128;
    let i = 0;
    let result = "";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    return result;
  };
}();

// out-build/vs/base/common/dataTransfer.js
var UriList = Object.freeze({
  // http://amundsen.com/hypermedia/urilist/
  create: (entries) => {
    return distinct(entries.map((x) => x.toString())).join("\r\n");
  },
  split: (str) => {
    return str.split("\r\n");
  },
  parse: (str) => {
    return UriList.split(str).filter((value) => !value.startsWith("#"));
  }
});

// out-build/vs/base/common/naturalLanguage/korean.js
var codeBuffer = new Uint32Array(10);
var HangulRangeStartCode;
(function(HangulRangeStartCode2) {
  HangulRangeStartCode2[HangulRangeStartCode2["InitialConsonant"] = 4352] = "InitialConsonant";
  HangulRangeStartCode2[HangulRangeStartCode2["Vowel"] = 4449] = "Vowel";
  HangulRangeStartCode2[HangulRangeStartCode2["FinalConsonant"] = 4520] = "FinalConsonant";
  HangulRangeStartCode2[HangulRangeStartCode2["CompatibilityJamo"] = 12593] = "CompatibilityJamo";
})(HangulRangeStartCode || (HangulRangeStartCode = {}));
var AsciiCode;
(function(AsciiCode2) {
  AsciiCode2[AsciiCode2["NUL"] = 0] = "NUL";
  AsciiCode2[AsciiCode2["A"] = 65] = "A";
  AsciiCode2[AsciiCode2["B"] = 66] = "B";
  AsciiCode2[AsciiCode2["C"] = 67] = "C";
  AsciiCode2[AsciiCode2["D"] = 68] = "D";
  AsciiCode2[AsciiCode2["E"] = 69] = "E";
  AsciiCode2[AsciiCode2["F"] = 70] = "F";
  AsciiCode2[AsciiCode2["G"] = 71] = "G";
  AsciiCode2[AsciiCode2["H"] = 72] = "H";
  AsciiCode2[AsciiCode2["I"] = 73] = "I";
  AsciiCode2[AsciiCode2["J"] = 74] = "J";
  AsciiCode2[AsciiCode2["K"] = 75] = "K";
  AsciiCode2[AsciiCode2["L"] = 76] = "L";
  AsciiCode2[AsciiCode2["M"] = 77] = "M";
  AsciiCode2[AsciiCode2["N"] = 78] = "N";
  AsciiCode2[AsciiCode2["O"] = 79] = "O";
  AsciiCode2[AsciiCode2["P"] = 80] = "P";
  AsciiCode2[AsciiCode2["Q"] = 81] = "Q";
  AsciiCode2[AsciiCode2["R"] = 82] = "R";
  AsciiCode2[AsciiCode2["S"] = 83] = "S";
  AsciiCode2[AsciiCode2["T"] = 84] = "T";
  AsciiCode2[AsciiCode2["U"] = 85] = "U";
  AsciiCode2[AsciiCode2["V"] = 86] = "V";
  AsciiCode2[AsciiCode2["W"] = 87] = "W";
  AsciiCode2[AsciiCode2["X"] = 88] = "X";
  AsciiCode2[AsciiCode2["Y"] = 89] = "Y";
  AsciiCode2[AsciiCode2["Z"] = 90] = "Z";
  AsciiCode2[AsciiCode2["a"] = 97] = "a";
  AsciiCode2[AsciiCode2["b"] = 98] = "b";
  AsciiCode2[AsciiCode2["c"] = 99] = "c";
  AsciiCode2[AsciiCode2["d"] = 100] = "d";
  AsciiCode2[AsciiCode2["e"] = 101] = "e";
  AsciiCode2[AsciiCode2["f"] = 102] = "f";
  AsciiCode2[AsciiCode2["g"] = 103] = "g";
  AsciiCode2[AsciiCode2["h"] = 104] = "h";
  AsciiCode2[AsciiCode2["i"] = 105] = "i";
  AsciiCode2[AsciiCode2["j"] = 106] = "j";
  AsciiCode2[AsciiCode2["k"] = 107] = "k";
  AsciiCode2[AsciiCode2["l"] = 108] = "l";
  AsciiCode2[AsciiCode2["m"] = 109] = "m";
  AsciiCode2[AsciiCode2["n"] = 110] = "n";
  AsciiCode2[AsciiCode2["o"] = 111] = "o";
  AsciiCode2[AsciiCode2["p"] = 112] = "p";
  AsciiCode2[AsciiCode2["q"] = 113] = "q";
  AsciiCode2[AsciiCode2["r"] = 114] = "r";
  AsciiCode2[AsciiCode2["s"] = 115] = "s";
  AsciiCode2[AsciiCode2["t"] = 116] = "t";
  AsciiCode2[AsciiCode2["u"] = 117] = "u";
  AsciiCode2[AsciiCode2["v"] = 118] = "v";
  AsciiCode2[AsciiCode2["w"] = 119] = "w";
  AsciiCode2[AsciiCode2["x"] = 120] = "x";
  AsciiCode2[AsciiCode2["y"] = 121] = "y";
  AsciiCode2[AsciiCode2["z"] = 122] = "z";
})(AsciiCode || (AsciiCode = {}));
var AsciiCodeCombo;
(function(AsciiCodeCombo2) {
  AsciiCodeCombo2[AsciiCodeCombo2["fa"] = 24934] = "fa";
  AsciiCodeCombo2[AsciiCodeCombo2["fg"] = 26470] = "fg";
  AsciiCodeCombo2[AsciiCodeCombo2["fq"] = 29030] = "fq";
  AsciiCodeCombo2[AsciiCodeCombo2["fr"] = 29286] = "fr";
  AsciiCodeCombo2[AsciiCodeCombo2["ft"] = 29798] = "ft";
  AsciiCodeCombo2[AsciiCodeCombo2["fv"] = 30310] = "fv";
  AsciiCodeCombo2[AsciiCodeCombo2["fx"] = 30822] = "fx";
  AsciiCodeCombo2[AsciiCodeCombo2["hk"] = 27496] = "hk";
  AsciiCodeCombo2[AsciiCodeCombo2["hl"] = 27752] = "hl";
  AsciiCodeCombo2[AsciiCodeCombo2["ho"] = 28520] = "ho";
  AsciiCodeCombo2[AsciiCodeCombo2["ml"] = 27757] = "ml";
  AsciiCodeCombo2[AsciiCodeCombo2["nj"] = 27246] = "nj";
  AsciiCodeCombo2[AsciiCodeCombo2["nl"] = 27758] = "nl";
  AsciiCodeCombo2[AsciiCodeCombo2["np"] = 28782] = "np";
  AsciiCodeCombo2[AsciiCodeCombo2["qt"] = 29809] = "qt";
  AsciiCodeCombo2[AsciiCodeCombo2["rt"] = 29810] = "rt";
  AsciiCodeCombo2[AsciiCodeCombo2["sg"] = 26483] = "sg";
  AsciiCodeCombo2[AsciiCodeCombo2["sw"] = 30579] = "sw";
})(AsciiCodeCombo || (AsciiCodeCombo = {}));
var modernConsonants = new Uint8Array([
  114,
  // 
  82,
  // 
  115,
  // 
  101,
  // 
  69,
  // 
  102,
  // 
  97,
  // 
  113,
  // 
  81,
  // 
  116,
  // 
  84,
  // 
  100,
  // 
  119,
  // 
  87,
  // 
  99,
  // 
  122,
  // 
  120,
  // 
  118,
  // 
  103
  // 
]);
var modernVowels = new Uint16Array([
  107,
  //  -> 
  111,
  //  -> 
  105,
  //  -> 
  79,
  //  -> 
  106,
  //  -> 
  112,
  //  -> 
  117,
  //  -> 
  80,
  //  -> 
  104,
  //  -> 
  27496,
  //  -> 
  28520,
  //  -> 
  27752,
  //  -> 
  121,
  //  -> 
  110,
  //  -> 
  27246,
  //  -> 
  28782,
  //  -> 
  27758,
  //  -> 
  98,
  //  -> 
  109,
  //  -> 
  27757,
  //  -> 
  108
  //  -> 
]);
var modernFinalConsonants = new Uint16Array([
  114,
  // 
  82,
  // 
  29810,
  // 
  115,
  // 
  30579,
  // 
  26483,
  // 
  101,
  // 
  102,
  // 
  29286,
  // 
  24934,
  // 
  29030,
  // 
  29798,
  // 
  30822,
  // 
  30310,
  // 
  26470,
  // 
  97,
  // 
  113,
  // 
  29809,
  // 
  116,
  // 
  84,
  // 
  100,
  // 
  119,
  // 
  99,
  // 
  122,
  // 
  120,
  // 
  118,
  // 
  103
  // 
]);
var compatibilityJamo = new Uint16Array([
  114,
  // 
  82,
  // 
  29810,
  // 
  115,
  // 
  30579,
  // 
  26483,
  // 
  101,
  // 
  69,
  // 
  102,
  // 
  29286,
  // 
  24934,
  // 
  29030,
  // 
  29798,
  // 
  30822,
  // 
  30310,
  // 
  26470,
  // 
  97,
  // 
  113,
  // 
  81,
  // 
  29809,
  // 
  116,
  // 
  84,
  // 
  100,
  // 
  119,
  // 
  87,
  // 
  99,
  // 
  122,
  // 
  120,
  // 
  118,
  // 
  103,
  // 
  107,
  // 
  111,
  // 
  105,
  // 
  79,
  // 
  106,
  // 
  112,
  // 
  117,
  // 
  80,
  // 
  104,
  // 
  27496,
  // 
  28520,
  // 
  27752,
  // 
  121,
  // 
  110,
  // 
  27246,
  // 
  28782,
  // 
  27758,
  // 
  98,
  // 
  109,
  // 
  27757,
  // 
  108
  // 
  // HF: Hangul Filler (everything after this is archaic)
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
]);

// out-build/vs/base/common/normalization.js
var nfcCache = new LRUCache(1e4);
var nfdCache = new LRUCache(1e4);
function normalizeNFD(str) {
  return normalize2(str, "NFD", nfdCache);
}
var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
function normalize2(str, form, normalizedCache) {
  if (!str) {
    return str;
  }
  const cached = normalizedCache.get(str);
  if (cached) {
    return cached;
  }
  let res;
  if (nonAsciiCharactersPattern.test(str)) {
    res = str.normalize(form);
  } else {
    res = str;
  }
  normalizedCache.set(str, res);
  return res;
}
var tryNormalizeToBase = function() {
  const cache2 = new LRUCache(1e4);
  const accentsRegex = /[\u0300-\u036f]/g;
  return function(str) {
    const cached = cache2.get(str);
    if (cached) {
      return cached;
    }
    const noAccents = normalizeNFD(str).replace(accentsRegex, "");
    const result = (noAccents.length === str.length ? noAccents : str).toLowerCase();
    cache2.set(str, result);
    return result;
  };
}();

// out-build/vs/base/common/filters.js
function or(...filter2) {
  return function(word, wordToMatchAgainst) {
    for (let i = 0, len = filter2.length; i < len; i++) {
      const match2 = filter2[i](word, wordToMatchAgainst);
      if (match2) {
        return match2;
      }
    }
    return null;
  };
}
var matchesStrictPrefix = _matchesPrefix.bind(void 0, false);
var matchesPrefix = _matchesPrefix.bind(void 0, true);
function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
    return null;
  }
  let matches;
  if (ignoreCase) {
    matches = startsWithIgnoreCase(wordToMatchAgainst, word);
  } else {
    matches = wordToMatchAgainst.indexOf(word) === 0;
  }
  if (!matches) {
    return null;
  }
  return word.length > 0 ? [{ start: 0, end: word.length }] : [];
}
function matchesContiguousSubString(word, wordToMatchAgainst) {
  if (word.length > wordToMatchAgainst.length) {
    return null;
  }
  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
  if (index === -1) {
    return null;
  }
  return [{ start: index, end: index + word.length }];
}
function matchesSubString(word, wordToMatchAgainst) {
  if (word.length > wordToMatchAgainst.length) {
    return null;
  }
  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
}
function _matchesSubString(word, wordToMatchAgainst, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === wordToMatchAgainst.length) {
    return null;
  } else {
    if (word[i] === wordToMatchAgainst[j]) {
      let result = null;
      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
        return join2({ start: j, end: j + 1 }, result);
      }
      return null;
    }
    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
  }
}
function isLower(code) {
  return 97 <= code && code <= 122;
}
function isUpper(code) {
  return 65 <= code && code <= 90;
}
function isNumber2(code) {
  return 48 <= code && code <= 57;
}
function isWhitespace(code) {
  return code === 32 || code === 9 || code === 10 || code === 13;
}
var wordSeparators = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => wordSeparators.add(s.charCodeAt(0)));
function isAlphanumeric(code) {
  return isLower(code) || isUpper(code) || isNumber2(code);
}
function join2(head, tail) {
  if (tail.length === 0) {
    tail = [head];
  } else if (head.end === tail[0].start) {
    tail[0].start = head.start;
  } else {
    tail.unshift(head);
  }
  return tail;
}
function nextAnchor(camelCaseWord, start) {
  for (let i = start; i < camelCaseWord.length; i++) {
    const c = camelCaseWord.charCodeAt(i);
    if (isUpper(c) || isNumber2(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {
      return i;
    }
  }
  return camelCaseWord.length;
}
function _matchesCamelCase(word, camelCaseWord, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === camelCaseWord.length) {
    return null;
  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {
    return null;
  } else {
    let result = null;
    let nextUpperIndex = j + 1;
    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
      nextUpperIndex++;
    }
    return result === null ? null : join2({ start: j, end: j + 1 }, result);
  }
}
function analyzeCamelCaseWord(word) {
  let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isAlphanumeric(code)) {
      alpha++;
    }
    if (isNumber2(code)) {
      numeric++;
    }
  }
  const upperPercent = upper / word.length;
  const lowerPercent = lower / word.length;
  const alphaPercent = alpha / word.length;
  const numericPercent = numeric / word.length;
  return { upperPercent, lowerPercent, alphaPercent, numericPercent };
}
function isUpperCaseWord(analysis) {
  const { upperPercent, lowerPercent } = analysis;
  return lowerPercent === 0 && upperPercent > 0.6;
}
function isCamelCaseWord(analysis) {
  const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;
  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
}
function isCamelCasePattern(word) {
  let upper = 0, lower = 0, code = 0, whitespace = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isWhitespace(code)) {
      whitespace++;
    }
  }
  if ((upper === 0 || lower === 0) && whitespace === 0) {
    return word.length <= 30;
  } else {
    return upper <= 5;
  }
}
function matchesCamelCase(word, camelCaseWord) {
  if (!camelCaseWord) {
    return null;
  }
  camelCaseWord = camelCaseWord.trim();
  if (camelCaseWord.length === 0) {
    return null;
  }
  if (!isCamelCasePattern(word)) {
    return null;
  }
  if (camelCaseWord.length > 60) {
    camelCaseWord = camelCaseWord.substring(0, 60);
  }
  const analysis = analyzeCamelCaseWord(camelCaseWord);
  if (!isCamelCaseWord(analysis)) {
    if (!isUpperCaseWord(analysis)) {
      return null;
    }
    camelCaseWord = camelCaseWord.toLowerCase();
  }
  let result = null;
  let i = 0;
  word = word.toLowerCase();
  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
    i = nextAnchor(camelCaseWord, i + 1);
  }
  return result;
}
var fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);
var fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);
var fuzzyRegExpCache = new LRUCache(1e4);
var _maxLen = 128;
function initTable() {
  const table = [];
  const row = [];
  for (let i = 0; i <= _maxLen; i++) {
    row[i] = 0;
  }
  for (let i = 0; i <= _maxLen; i++) {
    table.push(row.slice(0));
  }
  return table;
}
function initArr(maxLen) {
  const row = [];
  for (let i = 0; i <= maxLen; i++) {
    row[i] = 0;
  }
  return row;
}
var _minWordMatchPos = initArr(2 * _maxLen);
var _maxWordMatchPos = initArr(2 * _maxLen);
var _diag = initTable();
var _table = initTable();
var _arrows = initTable();
var Arrow;
(function(Arrow2) {
  Arrow2[Arrow2["Diag"] = 1] = "Diag";
  Arrow2[Arrow2["Left"] = 2] = "Left";
  Arrow2[Arrow2["LeftLeft"] = 3] = "LeftLeft";
})(Arrow || (Arrow = {}));
var FuzzyScore;
(function(FuzzyScore2) {
  FuzzyScore2.Default = [-100, 0];
  function isDefault(score2) {
    return !score2 || score2.length === 2 && score2[0] === -100 && score2[1] === 0;
  }
  FuzzyScore2.isDefault = isDefault;
})(FuzzyScore || (FuzzyScore = {}));
var FuzzyScoreOptions = class {
  static {
    this.default = { boostFullMatch: true, firstMatchCanBeWeak: false };
  }
  constructor(firstMatchCanBeWeak, boostFullMatch) {
    this.firstMatchCanBeWeak = firstMatchCanBeWeak;
    this.boostFullMatch = boostFullMatch;
  }
};

// out-build/vs/base/common/codiconsUtil.js
var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
function register(id2, fontCharacter) {
  if (isString(fontCharacter)) {
    const val = _codiconFontCharacters[fontCharacter];
    if (val === void 0) {
      throw new Error(`${id2} references an unknown codicon: ${fontCharacter}`);
    }
    fontCharacter = val;
  }
  _codiconFontCharacters[id2] = fontCharacter;
  return { id: id2 };
}
function getCodiconFontCharacters() {
  return _codiconFontCharacters;
}

// out-build/vs/base/common/codiconsLibrary.js
var codiconsLibrary = {
  add: register("add", 6e4),
  plus: register("plus", 6e4),
  gistNew: register("gist-new", 6e4),
  repoCreate: register("repo-create", 6e4),
  lightbulb: register("lightbulb", 60001),
  lightBulb: register("light-bulb", 60001),
  repo: register("repo", 60002),
  repoDelete: register("repo-delete", 60002),
  gistFork: register("gist-fork", 60003),
  repoForked: register("repo-forked", 60003),
  gitPullRequest: register("git-pull-request", 60004),
  gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
  recordKeys: register("record-keys", 60005),
  keyboard: register("keyboard", 60005),
  tag: register("tag", 60006),
  gitPullRequestLabel: register("git-pull-request-label", 60006),
  tagAdd: register("tag-add", 60006),
  tagRemove: register("tag-remove", 60006),
  person: register("person", 60007),
  personFollow: register("person-follow", 60007),
  personOutline: register("person-outline", 60007),
  personFilled: register("person-filled", 60007),
  sourceControl: register("source-control", 60008),
  mirror: register("mirror", 60009),
  mirrorPublic: register("mirror-public", 60009),
  star: register("star", 60010),
  starAdd: register("star-add", 60010),
  starDelete: register("star-delete", 60010),
  starEmpty: register("star-empty", 60010),
  comment: register("comment", 60011),
  commentAdd: register("comment-add", 60011),
  alert: register("alert", 60012),
  warning: register("warning", 60012),
  search: register("search", 60013),
  searchSave: register("search-save", 60013),
  logOut: register("log-out", 60014),
  signOut: register("sign-out", 60014),
  logIn: register("log-in", 60015),
  signIn: register("sign-in", 60015),
  eye: register("eye", 60016),
  eyeUnwatch: register("eye-unwatch", 60016),
  eyeWatch: register("eye-watch", 60016),
  circleFilled: register("circle-filled", 60017),
  primitiveDot: register("primitive-dot", 60017),
  closeDirty: register("close-dirty", 60017),
  debugBreakpoint: register("debug-breakpoint", 60017),
  debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
  debugHint: register("debug-hint", 60017),
  terminalDecorationSuccess: register("terminal-decoration-success", 60017),
  primitiveSquare: register("primitive-square", 60018),
  edit: register("edit", 60019),
  pencil: register("pencil", 60019),
  info: register("info", 60020),
  issueOpened: register("issue-opened", 60020),
  gistPrivate: register("gist-private", 60021),
  gitForkPrivate: register("git-fork-private", 60021),
  lock: register("lock", 60021),
  mirrorPrivate: register("mirror-private", 60021),
  close: register("close", 60022),
  removeClose: register("remove-close", 60022),
  x: register("x", 60022),
  repoSync: register("repo-sync", 60023),
  sync: register("sync", 60023),
  clone: register("clone", 60024),
  desktopDownload: register("desktop-download", 60024),
  beaker: register("beaker", 60025),
  microscope: register("microscope", 60025),
  vm: register("vm", 60026),
  deviceDesktop: register("device-desktop", 60026),
  file: register("file", 60027),
  more: register("more", 60028),
  ellipsis: register("ellipsis", 60028),
  kebabHorizontal: register("kebab-horizontal", 60028),
  mailReply: register("mail-reply", 60029),
  reply: register("reply", 60029),
  organization: register("organization", 60030),
  organizationFilled: register("organization-filled", 60030),
  organizationOutline: register("organization-outline", 60030),
  newFile: register("new-file", 60031),
  fileAdd: register("file-add", 60031),
  newFolder: register("new-folder", 60032),
  fileDirectoryCreate: register("file-directory-create", 60032),
  trash: register("trash", 60033),
  trashcan: register("trashcan", 60033),
  history: register("history", 60034),
  clock: register("clock", 60034),
  folder: register("folder", 60035),
  fileDirectory: register("file-directory", 60035),
  symbolFolder: register("symbol-folder", 60035),
  logoGithub: register("logo-github", 60036),
  markGithub: register("mark-github", 60036),
  github: register("github", 60036),
  terminal: register("terminal", 60037),
  console: register("console", 60037),
  repl: register("repl", 60037),
  zap: register("zap", 60038),
  symbolEvent: register("symbol-event", 60038),
  error: register("error", 60039),
  stop: register("stop", 60039),
  variable: register("variable", 60040),
  symbolVariable: register("symbol-variable", 60040),
  array: register("array", 60042),
  symbolArray: register("symbol-array", 60042),
  symbolModule: register("symbol-module", 60043),
  symbolPackage: register("symbol-package", 60043),
  symbolNamespace: register("symbol-namespace", 60043),
  symbolObject: register("symbol-object", 60043),
  symbolMethod: register("symbol-method", 60044),
  symbolFunction: register("symbol-function", 60044),
  symbolConstructor: register("symbol-constructor", 60044),
  symbolBoolean: register("symbol-boolean", 60047),
  symbolNull: register("symbol-null", 60047),
  symbolNumeric: register("symbol-numeric", 60048),
  symbolNumber: register("symbol-number", 60048),
  symbolStructure: register("symbol-structure", 60049),
  symbolStruct: register("symbol-struct", 60049),
  symbolParameter: register("symbol-parameter", 60050),
  symbolTypeParameter: register("symbol-type-parameter", 60050),
  symbolKey: register("symbol-key", 60051),
  symbolText: register("symbol-text", 60051),
  symbolReference: register("symbol-reference", 60052),
  goToFile: register("go-to-file", 60052),
  symbolEnum: register("symbol-enum", 60053),
  symbolValue: register("symbol-value", 60053),
  symbolRuler: register("symbol-ruler", 60054),
  symbolUnit: register("symbol-unit", 60054),
  activateBreakpoints: register("activate-breakpoints", 60055),
  archive: register("archive", 60056),
  arrowBoth: register("arrow-both", 60057),
  arrowDown: register("arrow-down", 60058),
  arrowLeft: register("arrow-left", 60059),
  arrowRight: register("arrow-right", 60060),
  arrowSmallDown: register("arrow-small-down", 60061),
  arrowSmallLeft: register("arrow-small-left", 60062),
  arrowSmallRight: register("arrow-small-right", 60063),
  arrowSmallUp: register("arrow-small-up", 60064),
  arrowUp: register("arrow-up", 60065),
  bell: register("bell", 60066),
  bold: register("bold", 60067),
  book: register("book", 60068),
  bookmark: register("bookmark", 60069),
  debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: register("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: register("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
  briefcase: register("briefcase", 60076),
  broadcast: register("broadcast", 60077),
  browser: register("browser", 60078),
  bug: register("bug", 60079),
  calendar: register("calendar", 60080),
  caseSensitive: register("case-sensitive", 60081),
  check: register("check", 60082),
  checklist: register("checklist", 60083),
  chevronDown: register("chevron-down", 60084),
  chevronLeft: register("chevron-left", 60085),
  chevronRight: register("chevron-right", 60086),
  chevronUp: register("chevron-up", 60087),
  chromeClose: register("chrome-close", 60088),
  chromeMaximize: register("chrome-maximize", 60089),
  chromeMinimize: register("chrome-minimize", 60090),
  chromeRestore: register("chrome-restore", 60091),
  circleOutline: register("circle-outline", 60092),
  circle: register("circle", 60092),
  debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: register("terminal-decoration-incomplete", 60092),
  circleSlash: register("circle-slash", 60093),
  circuitBoard: register("circuit-board", 60094),
  clearAll: register("clear-all", 60095),
  clippy: register("clippy", 60096),
  closeAll: register("close-all", 60097),
  cloudDownload: register("cloud-download", 60098),
  cloudUpload: register("cloud-upload", 60099),
  code: register("code", 60100),
  collapseAll: register("collapse-all", 60101),
  colorMode: register("color-mode", 60102),
  commentDiscussion: register("comment-discussion", 60103),
  creditCard: register("credit-card", 60105),
  dash: register("dash", 60108),
  dashboard: register("dashboard", 60109),
  database: register("database", 60110),
  debugContinue: register("debug-continue", 60111),
  debugDisconnect: register("debug-disconnect", 60112),
  debugPause: register("debug-pause", 60113),
  debugRestart: register("debug-restart", 60114),
  debugStart: register("debug-start", 60115),
  debugStepInto: register("debug-step-into", 60116),
  debugStepOut: register("debug-step-out", 60117),
  debugStepOver: register("debug-step-over", 60118),
  debugStop: register("debug-stop", 60119),
  debug: register("debug", 60120),
  deviceCameraVideo: register("device-camera-video", 60121),
  deviceCamera: register("device-camera", 60122),
  deviceMobile: register("device-mobile", 60123),
  diffAdded: register("diff-added", 60124),
  diffIgnored: register("diff-ignored", 60125),
  diffModified: register("diff-modified", 60126),
  diffRemoved: register("diff-removed", 60127),
  diffRenamed: register("diff-renamed", 60128),
  diff: register("diff", 60129),
  diffSidebyside: register("diff-sidebyside", 60129),
  discard: register("discard", 60130),
  editorLayout: register("editor-layout", 60131),
  emptyWindow: register("empty-window", 60132),
  exclude: register("exclude", 60133),
  extensions: register("extensions", 60134),
  eyeClosed: register("eye-closed", 60135),
  fileBinary: register("file-binary", 60136),
  fileCode: register("file-code", 60137),
  fileMedia: register("file-media", 60138),
  filePdf: register("file-pdf", 60139),
  fileSubmodule: register("file-submodule", 60140),
  fileSymlinkDirectory: register("file-symlink-directory", 60141),
  fileSymlinkFile: register("file-symlink-file", 60142),
  fileZip: register("file-zip", 60143),
  files: register("files", 60144),
  filter: register("filter", 60145),
  flame: register("flame", 60146),
  foldDown: register("fold-down", 60147),
  foldUp: register("fold-up", 60148),
  fold: register("fold", 60149),
  folderActive: register("folder-active", 60150),
  folderOpened: register("folder-opened", 60151),
  gear: register("gear", 60152),
  gift: register("gift", 60153),
  gistSecret: register("gist-secret", 60154),
  gist: register("gist", 60155),
  gitCommit: register("git-commit", 60156),
  gitCompare: register("git-compare", 60157),
  compareChanges: register("compare-changes", 60157),
  gitMerge: register("git-merge", 60158),
  githubAction: register("github-action", 60159),
  githubAlt: register("github-alt", 60160),
  globe: register("globe", 60161),
  grabber: register("grabber", 60162),
  graph: register("graph", 60163),
  gripper: register("gripper", 60164),
  heart: register("heart", 60165),
  home: register("home", 60166),
  horizontalRule: register("horizontal-rule", 60167),
  hubot: register("hubot", 60168),
  inbox: register("inbox", 60169),
  issueReopened: register("issue-reopened", 60171),
  issues: register("issues", 60172),
  italic: register("italic", 60173),
  jersey: register("jersey", 60174),
  json: register("json", 60175),
  kebabVertical: register("kebab-vertical", 60176),
  key: register("key", 60177),
  law: register("law", 60178),
  lightbulbAutofix: register("lightbulb-autofix", 60179),
  linkExternal: register("link-external", 60180),
  link: register("link", 60181),
  listOrdered: register("list-ordered", 60182),
  listUnordered: register("list-unordered", 60183),
  liveShare: register("live-share", 60184),
  loading: register("loading", 60185),
  location: register("location", 60186),
  mailRead: register("mail-read", 60187),
  mail: register("mail", 60188),
  markdown: register("markdown", 60189),
  megaphone: register("megaphone", 60190),
  mention: register("mention", 60191),
  milestone: register("milestone", 60192),
  gitPullRequestMilestone: register("git-pull-request-milestone", 60192),
  mortarBoard: register("mortar-board", 60193),
  move: register("move", 60194),
  multipleWindows: register("multiple-windows", 60195),
  mute: register("mute", 60196),
  noNewline: register("no-newline", 60197),
  note: register("note", 60198),
  octoface: register("octoface", 60199),
  openPreview: register("open-preview", 60200),
  package: register("package", 60201),
  paintcan: register("paintcan", 60202),
  pin: register("pin", 60203),
  play: register("play", 60204),
  run: register("run", 60204),
  plug: register("plug", 60205),
  preserveCase: register("preserve-case", 60206),
  preview: register("preview", 60207),
  project: register("project", 60208),
  pulse: register("pulse", 60209),
  question: register("question", 60210),
  quote: register("quote", 60211),
  radioTower: register("radio-tower", 60212),
  reactions: register("reactions", 60213),
  references: register("references", 60214),
  refresh: register("refresh", 60215),
  regex: register("regex", 60216),
  remoteExplorer: register("remote-explorer", 60217),
  remote: register("remote", 60218),
  remove: register("remove", 60219),
  replaceAll: register("replace-all", 60220),
  replace: register("replace", 60221),
  repoClone: register("repo-clone", 60222),
  repoForcePush: register("repo-force-push", 60223),
  repoPull: register("repo-pull", 60224),
  repoPush: register("repo-push", 60225),
  report: register("report", 60226),
  requestChanges: register("request-changes", 60227),
  rocket: register("rocket", 60228),
  rootFolderOpened: register("root-folder-opened", 60229),
  rootFolder: register("root-folder", 60230),
  rss: register("rss", 60231),
  ruby: register("ruby", 60232),
  saveAll: register("save-all", 60233),
  saveAs: register("save-as", 60234),
  save: register("save", 60235),
  screenFull: register("screen-full", 60236),
  screenNormal: register("screen-normal", 60237),
  searchStop: register("search-stop", 60238),
  server: register("server", 60240),
  settingsGear: register("settings-gear", 60241),
  settings: register("settings", 60242),
  shield: register("shield", 60243),
  smiley: register("smiley", 60244),
  sortPrecedence: register("sort-precedence", 60245),
  splitHorizontal: register("split-horizontal", 60246),
  splitVertical: register("split-vertical", 60247),
  squirrel: register("squirrel", 60248),
  starFull: register("star-full", 60249),
  starHalf: register("star-half", 60250),
  symbolClass: register("symbol-class", 60251),
  symbolColor: register("symbol-color", 60252),
  symbolConstant: register("symbol-constant", 60253),
  symbolEnumMember: register("symbol-enum-member", 60254),
  symbolField: register("symbol-field", 60255),
  symbolFile: register("symbol-file", 60256),
  symbolInterface: register("symbol-interface", 60257),
  symbolKeyword: register("symbol-keyword", 60258),
  symbolMisc: register("symbol-misc", 60259),
  symbolOperator: register("symbol-operator", 60260),
  symbolProperty: register("symbol-property", 60261),
  wrench: register("wrench", 60261),
  wrenchSubaction: register("wrench-subaction", 60261),
  symbolSnippet: register("symbol-snippet", 60262),
  tasklist: register("tasklist", 60263),
  telescope: register("telescope", 60264),
  textSize: register("text-size", 60265),
  threeBars: register("three-bars", 60266),
  thumbsdown: register("thumbsdown", 60267),
  thumbsup: register("thumbsup", 60268),
  tools: register("tools", 60269),
  triangleDown: register("triangle-down", 60270),
  triangleLeft: register("triangle-left", 60271),
  triangleRight: register("triangle-right", 60272),
  triangleUp: register("triangle-up", 60273),
  twitter: register("twitter", 60274),
  unfold: register("unfold", 60275),
  unlock: register("unlock", 60276),
  unmute: register("unmute", 60277),
  unverified: register("unverified", 60278),
  verified: register("verified", 60279),
  versions: register("versions", 60280),
  vmActive: register("vm-active", 60281),
  vmOutline: register("vm-outline", 60282),
  vmRunning: register("vm-running", 60283),
  watch: register("watch", 60284),
  whitespace: register("whitespace", 60285),
  wholeWord: register("whole-word", 60286),
  window: register("window", 60287),
  wordWrap: register("word-wrap", 60288),
  zoomIn: register("zoom-in", 60289),
  zoomOut: register("zoom-out", 60290),
  listFilter: register("list-filter", 60291),
  listFlat: register("list-flat", 60292),
  listSelection: register("list-selection", 60293),
  selection: register("selection", 60293),
  listTree: register("list-tree", 60294),
  debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: register("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: register("debug-stackframe-active", 60297),
  circleSmallFilled: register("circle-small-filled", 60298),
  debugStackframeDot: register("debug-stackframe-dot", 60298),
  terminalDecorationMark: register("terminal-decoration-mark", 60298),
  debugStackframe: register("debug-stackframe", 60299),
  debugStackframeFocused: register("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
  symbolString: register("symbol-string", 60301),
  debugReverseContinue: register("debug-reverse-continue", 60302),
  debugStepBack: register("debug-step-back", 60303),
  debugRestartFrame: register("debug-restart-frame", 60304),
  debugAlt: register("debug-alt", 60305),
  callIncoming: register("call-incoming", 60306),
  callOutgoing: register("call-outgoing", 60307),
  menu: register("menu", 60308),
  expandAll: register("expand-all", 60309),
  feedback: register("feedback", 60310),
  gitPullRequestReviewer: register("git-pull-request-reviewer", 60310),
  groupByRefType: register("group-by-ref-type", 60311),
  ungroupByRefType: register("ungroup-by-ref-type", 60312),
  account: register("account", 60313),
  gitPullRequestAssignee: register("git-pull-request-assignee", 60313),
  bellDot: register("bell-dot", 60314),
  debugConsole: register("debug-console", 60315),
  library: register("library", 60316),
  output: register("output", 60317),
  runAll: register("run-all", 60318),
  syncIgnored: register("sync-ignored", 60319),
  pinned: register("pinned", 60320),
  githubInverted: register("github-inverted", 60321),
  serverProcess: register("server-process", 60322),
  serverEnvironment: register("server-environment", 60323),
  pass: register("pass", 60324),
  issueClosed: register("issue-closed", 60324),
  stopCircle: register("stop-circle", 60325),
  playCircle: register("play-circle", 60326),
  record: register("record", 60327),
  debugAltSmall: register("debug-alt-small", 60328),
  vmConnect: register("vm-connect", 60329),
  cloud: register("cloud", 60330),
  merge: register("merge", 60331),
  export: register("export", 60332),
  graphLeft: register("graph-left", 60333),
  magnet: register("magnet", 60334),
  notebook: register("notebook", 60335),
  redo: register("redo", 60336),
  checkAll: register("check-all", 60337),
  pinnedDirty: register("pinned-dirty", 60338),
  passFilled: register("pass-filled", 60339),
  circleLargeFilled: register("circle-large-filled", 60340),
  circleLarge: register("circle-large", 60341),
  circleLargeOutline: register("circle-large-outline", 60341),
  combine: register("combine", 60342),
  gather: register("gather", 60342),
  table: register("table", 60343),
  variableGroup: register("variable-group", 60344),
  typeHierarchy: register("type-hierarchy", 60345),
  typeHierarchySub: register("type-hierarchy-sub", 60346),
  typeHierarchySuper: register("type-hierarchy-super", 60347),
  gitPullRequestCreate: register("git-pull-request-create", 60348),
  runAbove: register("run-above", 60349),
  runBelow: register("run-below", 60350),
  notebookTemplate: register("notebook-template", 60351),
  debugRerun: register("debug-rerun", 60352),
  workspaceTrusted: register("workspace-trusted", 60353),
  workspaceUntrusted: register("workspace-untrusted", 60354),
  workspaceUnknown: register("workspace-unknown", 60355),
  terminalCmd: register("terminal-cmd", 60356),
  terminalDebian: register("terminal-debian", 60357),
  terminalLinux: register("terminal-linux", 60358),
  terminalPowershell: register("terminal-powershell", 60359),
  terminalTmux: register("terminal-tmux", 60360),
  terminalUbuntu: register("terminal-ubuntu", 60361),
  terminalBash: register("terminal-bash", 60362),
  arrowSwap: register("arrow-swap", 60363),
  copy: register("copy", 60364),
  personAdd: register("person-add", 60365),
  filterFilled: register("filter-filled", 60366),
  wand: register("wand", 60367),
  debugLineByLine: register("debug-line-by-line", 60368),
  inspect: register("inspect", 60369),
  layers: register("layers", 60370),
  layersDot: register("layers-dot", 60371),
  layersActive: register("layers-active", 60372),
  compass: register("compass", 60373),
  compassDot: register("compass-dot", 60374),
  compassActive: register("compass-active", 60375),
  azure: register("azure", 60376),
  issueDraft: register("issue-draft", 60377),
  gitPullRequestClosed: register("git-pull-request-closed", 60378),
  gitPullRequestDraft: register("git-pull-request-draft", 60379),
  debugAll: register("debug-all", 60380),
  debugCoverage: register("debug-coverage", 60381),
  runErrors: register("run-errors", 60382),
  folderLibrary: register("folder-library", 60383),
  debugContinueSmall: register("debug-continue-small", 60384),
  beakerStop: register("beaker-stop", 60385),
  graphLine: register("graph-line", 60386),
  graphScatter: register("graph-scatter", 60387),
  pieChart: register("pie-chart", 60388),
  bracket: register("bracket", 60175),
  bracketDot: register("bracket-dot", 60389),
  bracketError: register("bracket-error", 60390),
  lockSmall: register("lock-small", 60391),
  azureDevops: register("azure-devops", 60392),
  verifiedFilled: register("verified-filled", 60393),
  newline: register("newline", 60394),
  layout: register("layout", 60395),
  layoutActivitybarLeft: register("layout-activitybar-left", 60396),
  layoutActivitybarRight: register("layout-activitybar-right", 60397),
  layoutPanelLeft: register("layout-panel-left", 60398),
  layoutPanelCenter: register("layout-panel-center", 60399),
  layoutPanelJustify: register("layout-panel-justify", 60400),
  layoutPanelRight: register("layout-panel-right", 60401),
  layoutPanel: register("layout-panel", 60402),
  layoutSidebarLeft: register("layout-sidebar-left", 60403),
  layoutSidebarRight: register("layout-sidebar-right", 60404),
  layoutStatusbar: register("layout-statusbar", 60405),
  layoutMenubar: register("layout-menubar", 60406),
  layoutCentered: register("layout-centered", 60407),
  target: register("target", 60408),
  indent: register("indent", 60409),
  recordSmall: register("record-small", 60410),
  errorSmall: register("error-small", 60411),
  terminalDecorationError: register("terminal-decoration-error", 60411),
  arrowCircleDown: register("arrow-circle-down", 60412),
  arrowCircleLeft: register("arrow-circle-left", 60413),
  arrowCircleRight: register("arrow-circle-right", 60414),
  arrowCircleUp: register("arrow-circle-up", 60415),
  layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
  layoutPanelOff: register("layout-panel-off", 60417),
  layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
  blank: register("blank", 60419),
  heartFilled: register("heart-filled", 60420),
  map: register("map", 60421),
  mapHorizontal: register("map-horizontal", 60421),
  foldHorizontal: register("fold-horizontal", 60421),
  mapFilled: register("map-filled", 60422),
  mapHorizontalFilled: register("map-horizontal-filled", 60422),
  foldHorizontalFilled: register("fold-horizontal-filled", 60422),
  circleSmall: register("circle-small", 60423),
  bellSlash: register("bell-slash", 60424),
  bellSlashDot: register("bell-slash-dot", 60425),
  commentUnresolved: register("comment-unresolved", 60426),
  gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
  searchFuzzy: register("search-fuzzy", 60429),
  commentDraft: register("comment-draft", 60430),
  send: register("send", 60431),
  sparkle: register("sparkle", 60432),
  insert: register("insert", 60433),
  mic: register("mic", 60434),
  thumbsdownFilled: register("thumbsdown-filled", 60435),
  thumbsupFilled: register("thumbsup-filled", 60436),
  coffee: register("coffee", 60437),
  snake: register("snake", 60438),
  game: register("game", 60439),
  vr: register("vr", 60440),
  chip: register("chip", 60441),
  piano: register("piano", 60442),
  music: register("music", 60443),
  micFilled: register("mic-filled", 60444),
  repoFetch: register("repo-fetch", 60445),
  copilot: register("copilot", 60446),
  lightbulbSparkle: register("lightbulb-sparkle", 60447),
  robot: register("robot", 60448),
  sparkleFilled: register("sparkle-filled", 60449),
  diffSingle: register("diff-single", 60450),
  diffMultiple: register("diff-multiple", 60451),
  surroundWith: register("surround-with", 60452),
  share: register("share", 60453),
  gitStash: register("git-stash", 60454),
  gitStashApply: register("git-stash-apply", 60455),
  gitStashPop: register("git-stash-pop", 60456),
  vscode: register("vscode", 60457),
  vscodeInsiders: register("vscode-insiders", 60458),
  codeOss: register("code-oss", 60459),
  runCoverage: register("run-coverage", 60460),
  runAllCoverage: register("run-all-coverage", 60461),
  coverage: register("coverage", 60462),
  githubProject: register("github-project", 60463),
  mapVertical: register("map-vertical", 60464),
  foldVertical: register("fold-vertical", 60464),
  mapVerticalFilled: register("map-vertical-filled", 60465),
  foldVerticalFilled: register("fold-vertical-filled", 60465),
  goToSearch: register("go-to-search", 60466),
  percentage: register("percentage", 60467),
  sortPercentage: register("sort-percentage", 60467),
  attach: register("attach", 60468),
  goToEditingSession: register("go-to-editing-session", 60469),
  editSession: register("edit-session", 60470),
  codeReview: register("code-review", 60471),
  copilotWarning: register("copilot-warning", 60472),
  python: register("python", 60473),
  copilotLarge: register("copilot-large", 60474),
  copilotWarningLarge: register("copilot-warning-large", 60475),
  keyboardTab: register("keyboard-tab", 60476),
  copilotBlocked: register("copilot-blocked", 60477),
  copilotNotConnected: register("copilot-not-connected", 60478),
  flag: register("flag", 60479),
  lightbulbEmpty: register("lightbulb-empty", 60480),
  symbolMethodArrow: register("symbol-method-arrow", 60481),
  copilotUnavailable: register("copilot-unavailable", 60482),
  repoPinned: register("repo-pinned", 60483),
  keyboardTabAbove: register("keyboard-tab-above", 60484),
  keyboardTabBelow: register("keyboard-tab-below", 60485),
  gitPullRequestDone: register("git-pull-request-done", 60486),
  mcp: register("mcp", 60487),
  extensionsLarge: register("extensions-large", 60488),
  layoutPanelDock: register("layout-panel-dock", 60489),
  layoutSidebarLeftDock: register("layout-sidebar-left-dock", 60490),
  layoutSidebarRightDock: register("layout-sidebar-right-dock", 60491),
  copilotInProgress: register("copilot-in-progress", 60492),
  copilotError: register("copilot-error", 60493),
  copilotSuccess: register("copilot-success", 60494),
  chatSparkle: register("chat-sparkle", 60495),
  searchSparkle: register("search-sparkle", 60496),
  editSparkle: register("edit-sparkle", 60497),
  copilotSnooze: register("copilot-snooze", 60498),
  sendToRemoteAgent: register("send-to-remote-agent", 60499),
  commentDiscussionSparkle: register("comment-discussion-sparkle", 60500),
  chatSparkleWarning: register("chat-sparkle-warning", 60501),
  chatSparkleError: register("chat-sparkle-error", 60502),
  collection: register("collection", 60503),
  newCollection: register("new-collection", 60504),
  thinking: register("thinking", 60505),
  build: register("build", 60506),
  commentDiscussionQuote: register("comment-discussion-quote", 60507),
  cursor: register("cursor", 60508),
  eraser: register("eraser", 60509),
  fileText: register("file-text", 60510),
  gitLens: register("git-lens", 60511),
  quotes: register("quotes", 60512),
  rename: register("rename", 60513),
  runWithDeps: register("run-with-deps", 60514),
  debugConnected: register("debug-connected", 60515),
  strikethrough: register("strikethrough", 60516),
  openInProduct: register("open-in-product", 60517),
  indexZero: register("index-zero", 60518),
  agent: register("agent", 60519),
  editCode: register("edit-code", 60520),
  repoSelected: register("repo-selected", 60521),
  skip: register("skip", 60522),
  mergeInto: register("merge-into", 60523),
  gitBranchChanges: register("git-branch-changes", 60524),
  gitBranchStagedChanges: register("git-branch-staged-changes", 60525),
  gitBranchConflicts: register("git-branch-conflicts", 60526),
  gitBranch: register("git-branch", 60527),
  gitBranchCreate: register("git-branch-create", 60527),
  gitBranchDelete: register("git-branch-delete", 60527),
  searchLarge: register("search-large", 60528),
  terminalGitBash: register("terminal-git-bash", 60529),
  windowActive: register("window-active", 60530),
  forward: register("forward", 60531),
  download: register("download", 60532)
};

// out-build/vs/base/common/codicons.js
var codiconsDerived = {
  dialogError: register("dialog-error", "error"),
  dialogWarning: register("dialog-warning", "warning"),
  dialogInfo: register("dialog-info", "info"),
  dialogClose: register("dialog-close", "close"),
  treeItemExpanded: register("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: register("tree-filter-clear", "close"),
  treeItemLoading: register("tree-item-loading", "loading"),
  menuSelection: register("menu-selection", "check"),
  menuSubmenu: register("menu-submenu", "chevron-right"),
  menuBarMore: register("menubar-more", "more"),
  scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
  toolBarMore: register("toolbar-more", "more"),
  quickInputBack: register("quick-input-back", "arrow-left"),
  dropDownButton: register("drop-down-button", 60084),
  symbolCustomColor: register("symbol-customcolor", 60252),
  exportIcon: register("export", 60332),
  workspaceUnspecified: register("workspace-unspecified", 60355),
  newLine: register("newline", 60394),
  thumbsDownFilled: register("thumbsdown-filled", 60435),
  thumbsUpFilled: register("thumbsup-filled", 60436),
  gitFetch: register("git-fetch", 60445),
  lightbulbSparkleAutofix: register("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: register("debug-breakpoint-pending", 60377)
};
var Codicon = {
  ...codiconsLibrary,
  ...codiconsDerived
};

// out-build/vs/base/common/themables.js
var ThemeColor;
(function(ThemeColor4) {
  function isThemeColor(obj) {
    return !!obj && typeof obj === "object" && typeof obj.id === "string";
  }
  ThemeColor4.isThemeColor = isThemeColor;
})(ThemeColor || (ThemeColor = {}));
var ThemeIcon;
(function(ThemeIcon4) {
  ThemeIcon4.iconNameSegment = "[A-Za-z0-9]+";
  ThemeIcon4.iconNameExpression = "[A-Za-z0-9-]+";
  ThemeIcon4.iconModifierExpression = "~[A-Za-z]+";
  ThemeIcon4.iconNameCharacter = "[A-Za-z0-9~-]";
  const ThemeIconIdRegex = new RegExp(`^(${ThemeIcon4.iconNameExpression})(${ThemeIcon4.iconModifierExpression})?$`);
  function asClassNameArray(icon) {
    const match2 = ThemeIconIdRegex.exec(icon.id);
    if (!match2) {
      return asClassNameArray(Codicon.error);
    }
    const [, id2, modifier] = match2;
    const classNames = ["codicon", "codicon-" + id2];
    if (modifier) {
      classNames.push("codicon-modifier-" + modifier.substring(1));
    }
    return classNames;
  }
  ThemeIcon4.asClassNameArray = asClassNameArray;
  function asClassName(icon) {
    return asClassNameArray(icon).join(" ");
  }
  ThemeIcon4.asClassName = asClassName;
  function asCSSSelector(icon) {
    return "." + asClassNameArray(icon).join(".");
  }
  ThemeIcon4.asCSSSelector = asCSSSelector;
  function isThemeIcon(obj) {
    return !!obj && typeof obj === "object" && typeof obj.id === "string" && (typeof obj.color === "undefined" || ThemeColor.isThemeColor(obj.color));
  }
  ThemeIcon4.isThemeIcon = isThemeIcon;
  const _regexFromString = new RegExp(`^\\$\\((${ThemeIcon4.iconNameExpression}(?:${ThemeIcon4.iconModifierExpression})?)\\)$`);
  function fromString(str) {
    const match2 = _regexFromString.exec(str);
    if (!match2) {
      return void 0;
    }
    const [, name2] = match2;
    return { id: name2 };
  }
  ThemeIcon4.fromString = fromString;
  function fromId(id2) {
    return { id: id2 };
  }
  ThemeIcon4.fromId = fromId;
  function modify(icon, modifier) {
    let id2 = icon.id;
    const tildeIndex = id2.lastIndexOf("~");
    if (tildeIndex !== -1) {
      id2 = id2.substring(0, tildeIndex);
    }
    if (modifier) {
      id2 = `${id2}~${modifier}`;
    }
    return { id: id2 };
  }
  ThemeIcon4.modify = modify;
  function getModifier(icon) {
    const tildeIndex = icon.id.lastIndexOf("~");
    if (tildeIndex !== -1) {
      return icon.id.substring(tildeIndex + 1);
    }
    return void 0;
  }
  ThemeIcon4.getModifier = getModifier;
  function isEqual2(ti1, ti2) {
    return ti1.id === ti2.id && ti1.color?.id === ti2.color?.id;
  }
  ThemeIcon4.isEqual = isEqual2;
  function isFile(icon) {
    return icon?.id === Codicon.file.id;
  }
  ThemeIcon4.isFile = isFile;
  function isFolder(icon) {
    return icon?.id === Codicon.folder.id;
  }
  ThemeIcon4.isFolder = isFolder;
})(ThemeIcon || (ThemeIcon = {}));

// out-build/vs/base/common/iconLabels.js
var iconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\)`, "g");
var escapeIconsRegex = new RegExp(`(\\\\)?${iconsRegex.source}`, "g");
function escapeIcons(text) {
  return text.replace(escapeIconsRegex, (match2, escaped) => escaped ? match2 : `\\${match2}`);
}
var markdownEscapedIconsRegex = new RegExp(`\\\\${iconsRegex.source}`, "g");
var stripIconsRegex = new RegExp(`(\\s)?(\\\\)?${iconsRegex.source}(\\s)?`, "g");
var _parseIconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameCharacter}+\\)`, "g");

// out-build/vs/base/common/htmlContent.js
var MarkdownStringTextNewlineStyle;
(function(MarkdownStringTextNewlineStyle2) {
  MarkdownStringTextNewlineStyle2[MarkdownStringTextNewlineStyle2["Paragraph"] = 0] = "Paragraph";
  MarkdownStringTextNewlineStyle2[MarkdownStringTextNewlineStyle2["Break"] = 1] = "Break";
})(MarkdownStringTextNewlineStyle || (MarkdownStringTextNewlineStyle = {}));
var MarkdownString = class _MarkdownString {
  static lift(dto) {
    const markdownString = new _MarkdownString(dto.value, dto);
    markdownString.uris = dto.uris;
    markdownString.baseUri = dto.baseUri ? URI.revive(dto.baseUri) : void 0;
    return markdownString;
  }
  constructor(value = "", isTrustedOrOptions = false) {
    this.value = value;
    if (typeof this.value !== "string") {
      throw illegalArgument("value");
    }
    if (typeof isTrustedOrOptions === "boolean") {
      this.isTrusted = isTrustedOrOptions;
      this.supportThemeIcons = false;
      this.supportHtml = false;
      this.supportAlertSyntax = false;
    } else {
      this.isTrusted = isTrustedOrOptions.isTrusted ?? void 0;
      this.supportThemeIcons = isTrustedOrOptions.supportThemeIcons ?? false;
      this.supportHtml = isTrustedOrOptions.supportHtml ?? false;
      this.supportAlertSyntax = isTrustedOrOptions.supportAlertSyntax ?? false;
    }
  }
  appendText(value, newlineStyle = 0) {
    this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? escapeIcons(value) : value).replace(/([ \t]+)/g, (_match, g1) => "&nbsp;".repeat(g1.length)).replace(/\>/gm, "\\>").replace(/\n/g, newlineStyle === 1 ? "\\\n" : "\n\n");
    return this;
  }
  appendMarkdown(value) {
    this.value += value;
    return this;
  }
  appendCodeblock(langId, code) {
    this.value += `
${appendEscapedMarkdownCodeBlockFence(code, langId)}
`;
    return this;
  }
  appendLink(target, label, title) {
    this.value += "[";
    this.value += this._escape(label, "]");
    this.value += "](";
    this.value += this._escape(String(target), ")");
    if (title) {
      this.value += ` "${this._escape(this._escape(title, '"'), ")")}"`;
    }
    this.value += ")";
    return this;
  }
  _escape(value, ch) {
    const r = new RegExp(escapeRegExpCharacters(ch), "g");
    return value.replace(r, (match2, offset) => {
      if (value.charAt(offset - 1) !== "\\") {
        return `\\${match2}`;
      } else {
        return match2;
      }
    });
  }
};
function isMarkdownString(thing) {
  if (thing instanceof MarkdownString) {
    return true;
  } else if (thing && typeof thing === "object") {
    return typeof thing.value === "string" && (typeof thing.isTrusted === "boolean" || typeof thing.isTrusted === "object" || thing.isTrusted === void 0) && (typeof thing.supportThemeIcons === "boolean" || thing.supportThemeIcons === void 0) && (typeof thing.supportAlertSyntax === "boolean" || thing.supportAlertSyntax === void 0);
  }
  return false;
}
function escapeMarkdownSyntaxTokens(text) {
  return text.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function appendEscapedMarkdownCodeBlockFence(code, langId) {
  const longestFenceLength = code.match(/^`+/gm)?.reduce((a, b) => a.length > b.length ? a : b).length ?? 0;
  const desiredFenceLength = longestFenceLength >= 3 ? longestFenceLength + 1 : 3;
  return [
    `${"`".repeat(desiredFenceLength)}${langId}`,
    code,
    `${"`".repeat(desiredFenceLength)}`
  ].join("\n");
}
function parseHrefAndDimensions(href) {
  const dimensions = [];
  const splitted = href.split("|").map((s) => s.trim());
  href = splitted[0];
  const parameters = splitted[1];
  if (parameters) {
    const heightFromParams = /height=(\d+)/.exec(parameters);
    const widthFromParams = /width=(\d+)/.exec(parameters);
    const height = heightFromParams ? heightFromParams[1] : "";
    const width = widthFromParams ? widthFromParams[1] : "";
    const widthIsFinite = isFinite(parseInt(width));
    const heightIsFinite = isFinite(parseInt(height));
    if (widthIsFinite) {
      dimensions.push(`width="${width}"`);
    }
    if (heightIsFinite) {
      dimensions.push(`height="${height}"`);
    }
  }
  return { href, dimensions };
}

// out-build/vs/base/common/marked/marked.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape$1(html2, encode) {
  if (encode) {
    if (escapeTest.test(html2)) {
      return html2.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html2)) {
      return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  let source = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(caret, "$1");
      source = source.replace(name2, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return href;
}
var noopTest = { exec: () => null };
function splitCells(tableRow, count2) {
  const row = tableRow.replace(/\|/g, (match2, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count2) {
    if (cells.length > count2) {
      cells.splice(count2);
    } else {
      while (cells.length < count2)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim2(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer2) {
  const href = link2.href;
  const title = link2.title ? escape$1(link2.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape$1(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var _Tokenizer = class {
  options;
  rules;
  // set by the lexer
  lexer;
  // set by the lexer
  constructor(options2) {
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim2(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim2(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: rtrim2(cap[0], "\n")
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      let lines = rtrim2(cap[0], "\n").split("\n");
      let raw = "";
      let text = "";
      const tokens = [];
      while (lines.length > 0) {
        let inBlockquote = false;
        const currentLines = [];
        let i;
        for (i = 0; i < lines.length; i++) {
          if (/^ {0,3}>/.test(lines[i])) {
            currentLines.push(lines[i]);
            inBlockquote = true;
          } else if (!inBlockquote) {
            currentLines.push(lines[i]);
          } else {
            break;
          }
        }
        lines = lines.slice(i);
        const currentRaw = currentLines.join("\n");
        const currentText = currentRaw.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, "\n    $1").replace(/^ {0,3}>[ \t]?/gm, "");
        raw = raw ? `${raw}
${currentRaw}` : currentRaw;
        text = text ? `${text}
${currentText}` : currentText;
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        this.lexer.blockTokens(currentText, tokens, true);
        this.lexer.state.top = top;
        if (lines.length === 0) {
          break;
        }
        const lastToken = tokens[tokens.length - 1];
        if (lastToken?.type === "code") {
          break;
        } else if (lastToken?.type === "blockquote") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.blockquote(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
          break;
        } else if (lastToken?.type === "list") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.list(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
          lines = newText.substring(tokens[tokens.length - 1].raw.length).split("\n");
          continue;
        }
      }
      return {
        type: "blockquote",
        raw,
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        let raw = "";
        let itemContents = "";
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let blankLine = !line.trim();
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else if (blankLine) {
          indent = cap[1].length + 1;
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        if (blankLine && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list2.raw += raw;
      }
      list2.items[list2.items.length - 1].raw = list2.items[list2.items.length - 1].raw.trimEnd();
      list2.items[list2.items.length - 1].text = list2.items[list2.items.length - 1].text.trimEnd();
      list2.raw = list2.raw.trimEnd();
      for (let i = 0; i < list2.items.length; i++) {
        this.lexer.state.top = false;
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (let i = 0; i < list2.items.length; i++) {
          list2.items[i].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!/[:|]/.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
    const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (/^ *-+: *$/.test(align)) {
        item.align.push("right");
      } else if (/^ *:-+: *$/.test(align)) {
        item.align.push("center");
      } else if (/^ *:-+ *$/.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (let i = 0; i < headers.length; i++) {
      item.header.push({
        text: headers[i],
        tokens: this.lexer.inline(headers[i]),
        header: true,
        align: item.align[i]
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell),
          header: false,
          align: item.align[i]
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape$1(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim2(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match2 = this.rules.inline.emStrongLDelim.exec(src);
    if (!match2)
      return;
    if (match2[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match2[1] || match2[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match2[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match2[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match2 = endReg.exec(maskedSrc)) != null) {
        rDelim = match2[1] || match2[2] || match2[3] || match2[4] || match2[5] || match2[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match2[3] || match2[4]) {
          delimTotal += rLength;
          continue;
        } else if (match2[5] || match2[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match2[0]][0].length;
        const raw = src.slice(0, lLength + match2.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape$1(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape$1(cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape$1(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape$1(cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? "";
        } while (prevCapZero !== cap[0]);
        text = escape$1(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = cap[0];
      } else {
        text = escape$1(cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var newline = /^(?: *(?:\n|$))+/;
var blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var bullet = /(?:[*+-]|\d{1,9}[.)])/;
var lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex();
var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var blockText = /^[^\n]+/;
var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
var blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockGfm = {
  ...blockNormal,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
};
var blockPedantic = {
  ...blockNormal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
};
var escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var br = /^( {2,}|\\)\n(?!\s*$)/;
var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var _punctuation = "\\p{P}\\p{S}";
var punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
var blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
var emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
var anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
var inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
var inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
};
var inlineGfm = {
  ...inlineNormal,
  escape: edit(escape).replace("])", "~|])").getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
var inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
var block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
var inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
var _Lexer = class __Lexer {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = [], lastParagraphClipped = false) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token;
    let lastToken;
    let cutSrc;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken?.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match2;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match2[0].slice(match2[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match2 = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match2.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  options;
  parser;
  // set by the parser
  constructor(options2) {
    this.options = options2 || _defaults;
  }
  space(token) {
    return "";
  }
  code({ text, lang, escaped }) {
    const langString = (lang || "").match(/^\S*/)?.[0];
    const code = text.replace(/\n$/, "") + "\n";
    if (!langString) {
      return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape$1(langString) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
  }
  blockquote({ tokens }) {
    const body = this.parser.parse(tokens);
    return `<blockquote>
${body}</blockquote>
`;
  }
  html({ text }) {
    return text;
  }
  heading({ tokens, depth }) {
    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
  }
  hr(token) {
    return "<hr>\n";
  }
  list(token) {
    const ordered = token.ordered;
    const start = token.start;
    let body = "";
    for (let j = 0; j < token.items.length; j++) {
      const item = token.items[j];
      body += this.listitem(item);
    }
    const type = ordered ? "ol" : "ul";
    const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
  }
  listitem(item) {
    let itemBody = "";
    if (item.task) {
      const checkbox = this.checkbox({ checked: !!item.checked });
      if (item.loose) {
        if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
          item.tokens[0].text = checkbox + " " + item.tokens[0].text;
          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
            item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
          }
        } else {
          item.tokens.unshift({
            type: "text",
            raw: checkbox + " ",
            text: checkbox + " "
          });
        }
      } else {
        itemBody += checkbox + " ";
      }
    }
    itemBody += this.parser.parse(item.tokens, !!item.loose);
    return `<li>${itemBody}</li>
`;
  }
  checkbox({ checked }) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens }) {
    return `<p>${this.parser.parseInline(tokens)}</p>
`;
  }
  table(token) {
    let header = "";
    let cell = "";
    for (let j = 0; j < token.header.length; j++) {
      cell += this.tablecell(token.header[j]);
    }
    header += this.tablerow({ text: cell });
    let body = "";
    for (let j = 0; j < token.rows.length; j++) {
      const row = token.rows[j];
      cell = "";
      for (let k = 0; k < row.length; k++) {
        cell += this.tablecell(row[k]);
      }
      body += this.tablerow({ text: cell });
    }
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow({ text }) {
    return `<tr>
${text}</tr>
`;
  }
  tablecell(token) {
    const content = this.parser.parseInline(token.tokens);
    const type = token.header ? "th" : "td";
    const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens }) {
    return `<strong>${this.parser.parseInline(tokens)}</strong>`;
  }
  em({ tokens }) {
    return `<em>${this.parser.parseInline(tokens)}</em>`;
  }
  codespan({ text }) {
    return `<code>${text}</code>`;
  }
  br(token) {
    return "<br>";
  }
  del({ tokens }) {
    return `<del>${this.parser.parseInline(tokens)}</del>`;
  }
  link({ href, title, tokens }) {
    const text = this.parser.parseInline(tokens);
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image({ href, title, text }) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ">";
    return out;
  }
  text(token) {
    return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong({ text }) {
    return text;
  }
  em({ text }) {
    return text;
  }
  codespan({ text }) {
    return text;
  }
  del({ text }) {
    return text;
  }
  html({ text }) {
    return text;
  }
  text({ text }) {
    return text;
  }
  link({ text }) {
    return "" + text;
  }
  image({ text }) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Parser = class __Parser {
  options;
  renderer;
  textRenderer;
  constructor(options2) {
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.renderer.parser = this;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
        const genericToken = anyToken;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "space": {
          out += this.renderer.space(token);
          continue;
        }
        case "hr": {
          out += this.renderer.hr(token);
          continue;
        }
        case "heading": {
          out += this.renderer.heading(token);
          continue;
        }
        case "code": {
          out += this.renderer.code(token);
          continue;
        }
        case "table": {
          out += this.renderer.table(token);
          continue;
        }
        case "blockquote": {
          out += this.renderer.blockquote(token);
          continue;
        }
        case "list": {
          out += this.renderer.list(token);
          continue;
        }
        case "html": {
          out += this.renderer.html(token);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(token);
          continue;
        }
        case "text": {
          let textToken = token;
          let body = this.renderer.text(textToken);
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + this.renderer.text(textToken);
          }
          if (top) {
            out += this.renderer.paragraph({
              type: "paragraph",
              raw: body,
              text: body,
              tokens: [{ type: "text", raw: body, text: body }]
            });
          } else {
            out += body;
          }
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "escape": {
          out += renderer.text(token);
          break;
        }
        case "html": {
          out += renderer.html(token);
          break;
        }
        case "link": {
          out += renderer.link(token);
          break;
        }
        case "image": {
          out += renderer.image(token);
          break;
        }
        case "strong": {
          out += renderer.strong(token);
          break;
        }
        case "em": {
          out += renderer.em(token);
          break;
        }
        case "codespan": {
          out += renderer.codespan(token);
          break;
        }
        case "br": {
          out += renderer.br(token);
          break;
        }
        case "del": {
          out += renderer.del(token);
          break;
        }
        case "text": {
          out += renderer.text(token);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _Hooks = class {
  options;
  constructor(options2) {
    this.options = options2 || _defaults;
  }
  static passThroughHooks = /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]);
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
};
var Marked = class {
  defaults = _getDefaults();
  options = this.setOptions;
  parse = this.parseMarkdown(_Lexer.lex, _Parser.parse);
  parseInline = this.parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
  Parser = _Parser;
  Renderer = _Renderer;
  TextRenderer = _TextRenderer;
  Lexer = _Lexer;
  Tokenizer = _Tokenizer;
  Hooks = _Hooks;
  constructor(...args) {
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (["options", "parser"].includes(prop)) {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (prop === "options") {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 ?? this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 ?? this.defaults);
  }
  parseMarkdown(lexer2, parser2) {
    const parse6 = (src, options2) => {
      const origOpt = { ...options2 };
      const opt = { ...this.defaults, ...origOpt };
      const throwError = this.onError(!!opt.silent, !!opt.async);
      if (this.defaults.async === true && origOpt.async === false) {
        return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      }
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer2(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser2(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e) {
        return throwError(e);
      }
    };
    return parse6;
  }
  onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// out-build/vs/base/common/marshalling.js
function stringify2(obj) {
  return JSON.stringify(obj, replacer);
}
function parse2(text) {
  let data2 = JSON.parse(text);
  data2 = revive(data2);
  return data2;
}
function replacer(key, value) {
  if (value instanceof RegExp) {
    return {
      $mid: 2,
      source: value.source,
      flags: value.flags
    };
  }
  return value;
}
function revive(obj, depth = 0) {
  if (!obj || depth > 200) {
    return obj;
  }
  if (typeof obj === "object") {
    switch (obj.$mid) {
      // eslint-disable-next-line local/code-no-any-casts
      case 1:
        return URI.revive(obj);
      // eslint-disable-next-line local/code-no-any-casts
      case 2:
        return new RegExp(obj.source, obj.flags);
      // eslint-disable-next-line local/code-no-any-casts
      case 17:
        return new Date(obj.source);
    }
    if (obj instanceof VSBuffer || obj instanceof Uint8Array) {
      return obj;
    }
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; ++i) {
        obj[i] = revive(obj[i], depth + 1);
      }
    } else {
      for (const key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
          obj[key] = revive(obj[key], depth + 1);
        }
      }
    }
  }
  return obj;
}

// out-build/vs/base/common/mime.js
var Mimes = Object.freeze({
  text: "text/plain",
  binary: "application/octet-stream",
  unknown: "application/unknown",
  markdown: "text/markdown",
  latex: "text/latex",
  uriList: "text/uri-list",
  html: "text/html"
});
var _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
function normalizeMimeType(mimeType, strict) {
  const match2 = _simplePattern.exec(mimeType);
  if (!match2) {
    return strict ? void 0 : mimeType;
  }
  return `${match2[1].toLowerCase()}/${match2[2].toLowerCase()}${match2[3] ?? ""}`;
}
function isTextStreamMime(mimeType) {
  return ["application/vnd.code.notebook.stdout", "application/vnd.code.notebook.stderr"].includes(mimeType);
}

// out-build/vs/base/common/prefixTree.js
var unset = Symbol("unset");
var WellDefinedPrefixTree = class {
  constructor() {
    this.root = new Node3();
    this._size = 0;
  }
  /** Tree size, not including the root. */
  get size() {
    return this._size;
  }
  /** Gets the top-level nodes of the tree */
  get nodes() {
    return this.root.children?.values() || Iterable.empty();
  }
  /** Gets the top-level nodes of the tree */
  get entries() {
    return this.root.children?.entries() || Iterable.empty();
  }
  /**
   * Inserts a new value in the prefix tree.
   * @param onNode - called for each node as we descend to the insertion point,
   * including the insertion point itself.
   */
  insert(key, value, onNode) {
    this.opNode(key, (n) => n._value = value, onNode);
  }
  /** Mutates a value in the prefix tree. */
  mutate(key, mutate) {
    this.opNode(key, (n) => n._value = mutate(n._value === unset ? void 0 : n._value));
  }
  /** Mutates nodes along the path in the prefix tree. */
  mutatePath(key, mutate) {
    this.opNode(key, () => {
    }, (n) => mutate(n));
  }
  /** Deletes a node from the prefix tree, returning the value it contained. */
  delete(key) {
    const path = this.getPathToKey(key);
    if (!path) {
      return;
    }
    let i = path.length - 1;
    const value = path[i].node._value;
    if (value === unset) {
      return;
    }
    this._size--;
    path[i].node._value = unset;
    for (; i > 0; i--) {
      const { node, part } = path[i];
      if (node.children?.size || node._value !== unset) {
        break;
      }
      path[i - 1].node.children.delete(part);
    }
    return value;
  }
  /** Deletes a subtree from the prefix tree, returning the values they contained. */
  *deleteRecursive(key) {
    const path = this.getPathToKey(key);
    if (!path) {
      return;
    }
    const subtree = path[path.length - 1].node;
    for (let i = path.length - 1; i > 0; i--) {
      const parent = path[i - 1];
      parent.node.children.delete(path[i].part);
      if (parent.node.children.size > 0 || parent.node._value !== unset) {
        break;
      }
    }
    for (const node of bfsIterate(subtree)) {
      if (node._value !== unset) {
        this._size--;
        yield node._value;
      }
    }
    if (subtree === this.root) {
      this.root._value = unset;
      this.root.children = void 0;
    }
  }
  /** Gets a value from the tree. */
  find(key) {
    let node = this.root;
    for (const segment of key) {
      const next = node.children?.get(segment);
      if (!next) {
        return void 0;
      }
      node = next;
    }
    return node._value === unset ? void 0 : node._value;
  }
  /** Gets whether the tree has the key, or a parent of the key, already inserted. */
  hasKeyOrParent(key) {
    let node = this.root;
    for (const segment of key) {
      const next = node.children?.get(segment);
      if (!next) {
        return false;
      }
      if (next._value !== unset) {
        return true;
      }
      node = next;
    }
    return false;
  }
  /** Gets whether the tree has the given key or any children. */
  hasKeyOrChildren(key) {
    let node = this.root;
    for (const segment of key) {
      const next = node.children?.get(segment);
      if (!next) {
        return false;
      }
      node = next;
    }
    return true;
  }
  /** Gets whether the tree has the given key. */
  hasKey(key) {
    let node = this.root;
    for (const segment of key) {
      const next = node.children?.get(segment);
      if (!next) {
        return false;
      }
      node = next;
    }
    return node._value !== unset;
  }
  getPathToKey(key) {
    const path = [{ part: "", node: this.root }];
    let i = 0;
    for (const part of key) {
      const node = path[i].node.children?.get(part);
      if (!node) {
        return;
      }
      path.push({ part, node });
      i++;
    }
    return path;
  }
  opNode(key, fn, onDescend) {
    let node = this.root;
    for (const part of key) {
      if (!node.children) {
        const next = new Node3();
        node.children = /* @__PURE__ */ new Map([[part, next]]);
        node = next;
      } else if (!node.children.has(part)) {
        const next = new Node3();
        node.children.set(part, next);
        node = next;
      } else {
        node = node.children.get(part);
      }
      onDescend?.(node);
    }
    const sizeBefore = node._value === unset ? 0 : 1;
    fn(node);
    const sizeAfter = node._value === unset ? 0 : 1;
    this._size += sizeAfter - sizeBefore;
  }
  /** Returns an iterable of the tree values in no defined order. */
  *values() {
    for (const { _value } of bfsIterate(this.root)) {
      if (_value !== unset) {
        yield _value;
      }
    }
  }
};
function* bfsIterate(root) {
  const stack = [root];
  while (stack.length > 0) {
    const node = stack.pop();
    yield node;
    if (node.children) {
      for (const child of node.children.values()) {
        stack.push(child);
      }
    }
  }
}
var Node3 = class {
  constructor() {
    this._value = unset;
  }
  get value() {
    return this._value === unset ? void 0 : this._value;
  }
  set value(value) {
    this._value = value === void 0 ? unset : value;
  }
};

// out-build/vs/editor/common/core/position.js
var Position = class _Position {
  constructor(lineNumber, column) {
    this.lineNumber = lineNumber;
    this.column = column;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(newLineNumber = this.lineNumber, newColumn = this.column) {
    if (newLineNumber === this.lineNumber && newColumn === this.column) {
      return this;
    } else {
      return new _Position(newLineNumber, newColumn);
    }
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(deltaLineNumber = 0, deltaColumn = 0) {
    return this.with(Math.max(1, this.lineNumber + deltaLineNumber), Math.max(1, this.column + deltaColumn));
  }
  /**
   * Test if this position equals other position
   */
  equals(other) {
    return _Position.equals(this, other);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(a, b) {
    if (!a && !b) {
      return true;
    }
    return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(other) {
    return _Position.isBefore(this, other);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(a, b) {
    if (a.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a.lineNumber) {
      return false;
    }
    return a.column < b.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(other) {
    return _Position.isBeforeOrEqual(this, other);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(a, b) {
    if (a.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a.lineNumber) {
      return false;
    }
    return a.column <= b.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(a, b) {
    const aLineNumber = a.lineNumber | 0;
    const bLineNumber = b.lineNumber | 0;
    if (aLineNumber === bLineNumber) {
      const aColumn = a.column | 0;
      const bColumn = b.column | 0;
      return aColumn - bColumn;
    }
    return aLineNumber - bLineNumber;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new _Position(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(pos) {
    return new _Position(pos.lineNumber, pos.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(obj) {
    return !!obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
};

// out-build/vs/editor/common/core/range.js
var Range = class _Range {
  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
      this.startLineNumber = endLineNumber;
      this.startColumn = endColumn;
      this.endLineNumber = startLineNumber;
      this.endColumn = startColumn;
    } else {
      this.startLineNumber = startLineNumber;
      this.startColumn = startColumn;
      this.endLineNumber = endLineNumber;
      this.endColumn = endColumn;
    }
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return _Range.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(range) {
    return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(position) {
    return _Range.containsPosition(this, position);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(range, position) {
    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
      return false;
    }
    if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
      return false;
    }
    if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(range, position) {
    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
      return false;
    }
    if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
      return false;
    }
    if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(range) {
    return _Range.containsRange(this, range);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(range, otherRange) {
    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(range) {
    return _Range.strictContainsRange(this, range);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(range, otherRange) {
    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(range) {
    return _Range.plusRange(this, range);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(a, b) {
    let startLineNumber;
    let startColumn;
    let endLineNumber;
    let endColumn;
    if (b.startLineNumber < a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = b.startColumn;
    } else if (b.startLineNumber === a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = Math.min(b.startColumn, a.startColumn);
    } else {
      startLineNumber = a.startLineNumber;
      startColumn = a.startColumn;
    }
    if (b.endLineNumber > a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = b.endColumn;
    } else if (b.endLineNumber === a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = Math.max(b.endColumn, a.endColumn);
    } else {
      endLineNumber = a.endLineNumber;
      endColumn = a.endColumn;
    }
    return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(range) {
    return _Range.intersectRanges(this, range);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(a, b) {
    let resultStartLineNumber = a.startLineNumber;
    let resultStartColumn = a.startColumn;
    let resultEndLineNumber = a.endLineNumber;
    let resultEndColumn = a.endColumn;
    const otherStartLineNumber = b.startLineNumber;
    const otherStartColumn = b.startColumn;
    const otherEndLineNumber = b.endLineNumber;
    const otherEndColumn = b.endColumn;
    if (resultStartLineNumber < otherStartLineNumber) {
      resultStartLineNumber = otherStartLineNumber;
      resultStartColumn = otherStartColumn;
    } else if (resultStartLineNumber === otherStartLineNumber) {
      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
    }
    if (resultEndLineNumber > otherEndLineNumber) {
      resultEndLineNumber = otherEndLineNumber;
      resultEndColumn = otherEndColumn;
    } else if (resultEndLineNumber === otherEndLineNumber) {
      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
    }
    if (resultStartLineNumber > resultEndLineNumber) {
      return null;
    }
    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
      return null;
    }
    return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(other) {
    return _Range.equalsRange(this, other);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(a, b) {
    if (!a && !b) {
      return true;
    }
    return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return _Range.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(range) {
    return new Position(range.endLineNumber, range.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return _Range.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(range) {
    return new Position(range.startLineNumber, range.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(endLineNumber, endColumn) {
    return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(startLineNumber, startColumn) {
    return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return _Range.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(range) {
    return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  collapseToEnd() {
    return _Range.collapseToEnd(this);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  static collapseToEnd(range) {
    return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
  }
  /**
   * Moves the range by the given amount of lines.
   */
  delta(lineCount) {
    return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
  }
  isSingleLine() {
    return this.startLineNumber === this.endLineNumber;
  }
  // ---
  static fromPositions(start, end = start) {
    return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  static lift(range) {
    if (!range) {
      return null;
    }
    return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(obj) {
    return !!obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(a, b) {
    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(a, b) {
    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if the two ranges are intersecting, but not touching at all.
   */
  static areOnlyIntersecting(a, b) {
    if (a.endLineNumber < b.startLineNumber - 1 || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn - 1) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber - 1 || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn - 1) {
      return false;
    }
    return true;
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(a, b) {
    if (a && b) {
      const aStartLineNumber = a.startLineNumber | 0;
      const bStartLineNumber = b.startLineNumber | 0;
      if (aStartLineNumber === bStartLineNumber) {
        const aStartColumn = a.startColumn | 0;
        const bStartColumn = b.startColumn | 0;
        if (aStartColumn === bStartColumn) {
          const aEndLineNumber = a.endLineNumber | 0;
          const bEndLineNumber = b.endLineNumber | 0;
          if (aEndLineNumber === bEndLineNumber) {
            const aEndColumn = a.endColumn | 0;
            const bEndColumn = b.endColumn | 0;
            return aEndColumn - bEndColumn;
          }
          return aEndLineNumber - bEndLineNumber;
        }
        return aStartColumn - bStartColumn;
      }
      return aStartLineNumber - bStartLineNumber;
    }
    const aExists = a ? 1 : 0;
    const bExists = b ? 1 : 0;
    return aExists - bExists;
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(a, b) {
    if (a.endLineNumber === b.endLineNumber) {
      if (a.endColumn === b.endColumn) {
        if (a.startLineNumber === b.startLineNumber) {
          return a.startColumn - b.startColumn;
        }
        return a.startLineNumber - b.startLineNumber;
      }
      return a.endColumn - b.endColumn;
    }
    return a.endLineNumber - b.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(range) {
    return range.endLineNumber > range.startLineNumber;
  }
  toJSON() {
    return this;
  }
};

// out-build/vs/editor/common/tokenizationRegistry.js
var TokenizationRegistry = class {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map();
    this._factories = /* @__PURE__ */ new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._colorMap = null;
  }
  handleChange(languageIds) {
    this._onDidChange.fire({
      changedLanguages: languageIds,
      changedColorMap: false
    });
  }
  register(languageId, support) {
    this._tokenizationSupports.set(languageId, support);
    this.handleChange([languageId]);
    return toDisposable(() => {
      if (this._tokenizationSupports.get(languageId) !== support) {
        return;
      }
      this._tokenizationSupports.delete(languageId);
      this.handleChange([languageId]);
    });
  }
  get(languageId) {
    return this._tokenizationSupports.get(languageId) || null;
  }
  registerFactory(languageId, factory) {
    this._factories.get(languageId)?.dispose();
    const myData = new TokenizationSupportFactoryData(this, languageId, factory);
    this._factories.set(languageId, myData);
    return toDisposable(() => {
      const v = this._factories.get(languageId);
      if (!v || v !== myData) {
        return;
      }
      this._factories.delete(languageId);
      v.dispose();
    });
  }
  async getOrCreate(languageId) {
    const tokenizationSupport = this.get(languageId);
    if (tokenizationSupport) {
      return tokenizationSupport;
    }
    const factory = this._factories.get(languageId);
    if (!factory || factory.isResolved) {
      return null;
    }
    await factory.resolve();
    return this.get(languageId);
  }
  isResolved(languageId) {
    const tokenizationSupport = this.get(languageId);
    if (tokenizationSupport) {
      return true;
    }
    const factory = this._factories.get(languageId);
    if (!factory || factory.isResolved) {
      return true;
    }
    return false;
  }
  setColorMap(colorMap) {
    this._colorMap = colorMap;
    this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: true
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    if (this._colorMap && this._colorMap.length > 2) {
      return this._colorMap[
        2
        /* ColorId.DefaultBackground */
      ];
    }
    return null;
  }
};
var TokenizationSupportFactoryData = class extends Disposable {
  get isResolved() {
    return this._isResolved;
  }
  constructor(_registry2, _languageId, _factory2) {
    super();
    this._registry = _registry2;
    this._languageId = _languageId;
    this._factory = _factory2;
    this._isDisposed = false;
    this._resolvePromise = null;
    this._isResolved = false;
  }
  dispose() {
    this._isDisposed = true;
    super.dispose();
  }
  async resolve() {
    if (!this._resolvePromise) {
      this._resolvePromise = this._create();
    }
    return this._resolvePromise;
  }
  async _create() {
    const value = await this._factory.tokenizationSupport;
    this._isResolved = true;
    if (value && !this._isDisposed) {
      this._register(this._registry.register(this._languageId, value));
    }
  }
};

// out-build/vs/editor/common/languages.js
var HoverVerbosityAction;
(function(HoverVerbosityAction3) {
  HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
  HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
})(HoverVerbosityAction || (HoverVerbosityAction = {}));
var CompletionItemKind;
(function(CompletionItemKind4) {
  CompletionItemKind4[CompletionItemKind4["Method"] = 0] = "Method";
  CompletionItemKind4[CompletionItemKind4["Function"] = 1] = "Function";
  CompletionItemKind4[CompletionItemKind4["Constructor"] = 2] = "Constructor";
  CompletionItemKind4[CompletionItemKind4["Field"] = 3] = "Field";
  CompletionItemKind4[CompletionItemKind4["Variable"] = 4] = "Variable";
  CompletionItemKind4[CompletionItemKind4["Class"] = 5] = "Class";
  CompletionItemKind4[CompletionItemKind4["Struct"] = 6] = "Struct";
  CompletionItemKind4[CompletionItemKind4["Interface"] = 7] = "Interface";
  CompletionItemKind4[CompletionItemKind4["Module"] = 8] = "Module";
  CompletionItemKind4[CompletionItemKind4["Property"] = 9] = "Property";
  CompletionItemKind4[CompletionItemKind4["Event"] = 10] = "Event";
  CompletionItemKind4[CompletionItemKind4["Operator"] = 11] = "Operator";
  CompletionItemKind4[CompletionItemKind4["Unit"] = 12] = "Unit";
  CompletionItemKind4[CompletionItemKind4["Value"] = 13] = "Value";
  CompletionItemKind4[CompletionItemKind4["Constant"] = 14] = "Constant";
  CompletionItemKind4[CompletionItemKind4["Enum"] = 15] = "Enum";
  CompletionItemKind4[CompletionItemKind4["EnumMember"] = 16] = "EnumMember";
  CompletionItemKind4[CompletionItemKind4["Keyword"] = 17] = "Keyword";
  CompletionItemKind4[CompletionItemKind4["Text"] = 18] = "Text";
  CompletionItemKind4[CompletionItemKind4["Color"] = 19] = "Color";
  CompletionItemKind4[CompletionItemKind4["File"] = 20] = "File";
  CompletionItemKind4[CompletionItemKind4["Reference"] = 21] = "Reference";
  CompletionItemKind4[CompletionItemKind4["Customcolor"] = 22] = "Customcolor";
  CompletionItemKind4[CompletionItemKind4["Folder"] = 23] = "Folder";
  CompletionItemKind4[CompletionItemKind4["TypeParameter"] = 24] = "TypeParameter";
  CompletionItemKind4[CompletionItemKind4["User"] = 25] = "User";
  CompletionItemKind4[CompletionItemKind4["Issue"] = 26] = "Issue";
  CompletionItemKind4[CompletionItemKind4["Tool"] = 27] = "Tool";
  CompletionItemKind4[CompletionItemKind4["Snippet"] = 28] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemKinds;
(function(CompletionItemKinds2) {
  const byKind = /* @__PURE__ */ new Map();
  byKind.set(0, Codicon.symbolMethod);
  byKind.set(1, Codicon.symbolFunction);
  byKind.set(2, Codicon.symbolConstructor);
  byKind.set(3, Codicon.symbolField);
  byKind.set(4, Codicon.symbolVariable);
  byKind.set(5, Codicon.symbolClass);
  byKind.set(6, Codicon.symbolStruct);
  byKind.set(7, Codicon.symbolInterface);
  byKind.set(8, Codicon.symbolModule);
  byKind.set(9, Codicon.symbolProperty);
  byKind.set(10, Codicon.symbolEvent);
  byKind.set(11, Codicon.symbolOperator);
  byKind.set(12, Codicon.symbolUnit);
  byKind.set(13, Codicon.symbolValue);
  byKind.set(15, Codicon.symbolEnum);
  byKind.set(14, Codicon.symbolConstant);
  byKind.set(15, Codicon.symbolEnum);
  byKind.set(16, Codicon.symbolEnumMember);
  byKind.set(17, Codicon.symbolKeyword);
  byKind.set(28, Codicon.symbolSnippet);
  byKind.set(18, Codicon.symbolText);
  byKind.set(19, Codicon.symbolColor);
  byKind.set(20, Codicon.symbolFile);
  byKind.set(21, Codicon.symbolReference);
  byKind.set(22, Codicon.symbolCustomColor);
  byKind.set(23, Codicon.symbolFolder);
  byKind.set(24, Codicon.symbolTypeParameter);
  byKind.set(25, Codicon.account);
  byKind.set(26, Codicon.issues);
  byKind.set(27, Codicon.tools);
  function toIcon(kind) {
    let codicon = byKind.get(kind);
    if (!codicon) {
      console.info("No codicon found for CompletionItemKind " + kind);
      codicon = Codicon.symbolProperty;
    }
    return codicon;
  }
  CompletionItemKinds2.toIcon = toIcon;
  function toLabel(kind) {
    switch (kind) {
      case 0:
        return localize(847, null);
      case 1:
        return localize(848, null);
      case 2:
        return localize(849, null);
      case 3:
        return localize(850, null);
      case 4:
        return localize(851, null);
      case 5:
        return localize(852, null);
      case 6:
        return localize(853, null);
      case 7:
        return localize(854, null);
      case 8:
        return localize(855, null);
      case 9:
        return localize(856, null);
      case 10:
        return localize(857, null);
      case 11:
        return localize(858, null);
      case 12:
        return localize(859, null);
      case 13:
        return localize(860, null);
      case 14:
        return localize(861, null);
      case 15:
        return localize(862, null);
      case 16:
        return localize(863, null);
      case 17:
        return localize(864, null);
      case 18:
        return localize(865, null);
      case 19:
        return localize(866, null);
      case 20:
        return localize(867, null);
      case 21:
        return localize(868, null);
      case 22:
        return localize(869, null);
      case 23:
        return localize(870, null);
      case 24:
        return localize(871, null);
      case 25:
        return localize(872, null);
      case 26:
        return localize(873, null);
      case 27:
        return localize(874, null);
      case 28:
        return localize(875, null);
      default:
        return "";
    }
  }
  CompletionItemKinds2.toLabel = toLabel;
  const data2 = /* @__PURE__ */ new Map();
  data2.set(
    "method",
    0
    /* CompletionItemKind.Method */
  );
  data2.set(
    "function",
    1
    /* CompletionItemKind.Function */
  );
  data2.set(
    "constructor",
    2
    /* CompletionItemKind.Constructor */
  );
  data2.set(
    "field",
    3
    /* CompletionItemKind.Field */
  );
  data2.set(
    "variable",
    4
    /* CompletionItemKind.Variable */
  );
  data2.set(
    "class",
    5
    /* CompletionItemKind.Class */
  );
  data2.set(
    "struct",
    6
    /* CompletionItemKind.Struct */
  );
  data2.set(
    "interface",
    7
    /* CompletionItemKind.Interface */
  );
  data2.set(
    "module",
    8
    /* CompletionItemKind.Module */
  );
  data2.set(
    "property",
    9
    /* CompletionItemKind.Property */
  );
  data2.set(
    "event",
    10
    /* CompletionItemKind.Event */
  );
  data2.set(
    "operator",
    11
    /* CompletionItemKind.Operator */
  );
  data2.set(
    "unit",
    12
    /* CompletionItemKind.Unit */
  );
  data2.set(
    "value",
    13
    /* CompletionItemKind.Value */
  );
  data2.set(
    "constant",
    14
    /* CompletionItemKind.Constant */
  );
  data2.set(
    "enum",
    15
    /* CompletionItemKind.Enum */
  );
  data2.set(
    "enum-member",
    16
    /* CompletionItemKind.EnumMember */
  );
  data2.set(
    "enumMember",
    16
    /* CompletionItemKind.EnumMember */
  );
  data2.set(
    "keyword",
    17
    /* CompletionItemKind.Keyword */
  );
  data2.set(
    "snippet",
    28
    /* CompletionItemKind.Snippet */
  );
  data2.set(
    "text",
    18
    /* CompletionItemKind.Text */
  );
  data2.set(
    "color",
    19
    /* CompletionItemKind.Color */
  );
  data2.set(
    "file",
    20
    /* CompletionItemKind.File */
  );
  data2.set(
    "reference",
    21
    /* CompletionItemKind.Reference */
  );
  data2.set(
    "customcolor",
    22
    /* CompletionItemKind.Customcolor */
  );
  data2.set(
    "folder",
    23
    /* CompletionItemKind.Folder */
  );
  data2.set(
    "type-parameter",
    24
    /* CompletionItemKind.TypeParameter */
  );
  data2.set(
    "typeParameter",
    24
    /* CompletionItemKind.TypeParameter */
  );
  data2.set(
    "account",
    25
    /* CompletionItemKind.User */
  );
  data2.set(
    "issue",
    26
    /* CompletionItemKind.Issue */
  );
  data2.set(
    "tool",
    27
    /* CompletionItemKind.Tool */
  );
  function fromString(value, strict) {
    let res = data2.get(value);
    if (typeof res === "undefined" && !strict) {
      res = 9;
    }
    return res;
  }
  CompletionItemKinds2.fromString = fromString;
})(CompletionItemKinds || (CompletionItemKinds = {}));
var CompletionItemTag;
(function(CompletionItemTag4) {
  CompletionItemTag4[CompletionItemTag4["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
var CompletionItemInsertTextRule;
(function(CompletionItemInsertTextRule2) {
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var PartialAcceptTriggerKind;
(function(PartialAcceptTriggerKind4) {
  PartialAcceptTriggerKind4[PartialAcceptTriggerKind4["Word"] = 0] = "Word";
  PartialAcceptTriggerKind4[PartialAcceptTriggerKind4["Line"] = 1] = "Line";
  PartialAcceptTriggerKind4[PartialAcceptTriggerKind4["Suggest"] = 2] = "Suggest";
})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));
var CompletionTriggerKind;
(function(CompletionTriggerKind4) {
  CompletionTriggerKind4[CompletionTriggerKind4["Invoke"] = 0] = "Invoke";
  CompletionTriggerKind4[CompletionTriggerKind4["TriggerCharacter"] = 1] = "TriggerCharacter";
  CompletionTriggerKind4[CompletionTriggerKind4["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
var InlineCompletionTriggerKind;
(function(InlineCompletionTriggerKind3) {
  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var InlineCompletionHintStyle;
(function(InlineCompletionHintStyle3) {
  InlineCompletionHintStyle3[InlineCompletionHintStyle3["Code"] = 1] = "Code";
  InlineCompletionHintStyle3[InlineCompletionHintStyle3["Label"] = 2] = "Label";
})(InlineCompletionHintStyle || (InlineCompletionHintStyle = {}));
var InlineCompletionEndOfLifeReasonKind;
(function(InlineCompletionEndOfLifeReasonKind3) {
  InlineCompletionEndOfLifeReasonKind3[InlineCompletionEndOfLifeReasonKind3["Accepted"] = 0] = "Accepted";
  InlineCompletionEndOfLifeReasonKind3[InlineCompletionEndOfLifeReasonKind3["Rejected"] = 1] = "Rejected";
  InlineCompletionEndOfLifeReasonKind3[InlineCompletionEndOfLifeReasonKind3["Ignored"] = 2] = "Ignored";
})(InlineCompletionEndOfLifeReasonKind || (InlineCompletionEndOfLifeReasonKind = {}));
var CodeActionTriggerType;
(function(CodeActionTriggerType2) {
  CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
  CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
})(CodeActionTriggerType || (CodeActionTriggerType = {}));
var DocumentPasteTriggerKind;
(function(DocumentPasteTriggerKind3) {
  DocumentPasteTriggerKind3[DocumentPasteTriggerKind3["Automatic"] = 0] = "Automatic";
  DocumentPasteTriggerKind3[DocumentPasteTriggerKind3["PasteAs"] = 1] = "PasteAs";
})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));
var SignatureHelpTriggerKind;
(function(SignatureHelpTriggerKind3) {
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind3) {
  DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
  DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
  DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
function isLocationLink(thing) {
  return !!thing && URI.isUri(thing.uri) && Range.isIRange(thing.range) && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));
}
function isLocation(thing) {
  return !!thing && URI.isUri(thing.uri) && Range.isIRange(thing.range);
}
var SymbolKind;
(function(SymbolKind4) {
  SymbolKind4[SymbolKind4["File"] = 0] = "File";
  SymbolKind4[SymbolKind4["Module"] = 1] = "Module";
  SymbolKind4[SymbolKind4["Namespace"] = 2] = "Namespace";
  SymbolKind4[SymbolKind4["Package"] = 3] = "Package";
  SymbolKind4[SymbolKind4["Class"] = 4] = "Class";
  SymbolKind4[SymbolKind4["Method"] = 5] = "Method";
  SymbolKind4[SymbolKind4["Property"] = 6] = "Property";
  SymbolKind4[SymbolKind4["Field"] = 7] = "Field";
  SymbolKind4[SymbolKind4["Constructor"] = 8] = "Constructor";
  SymbolKind4[SymbolKind4["Enum"] = 9] = "Enum";
  SymbolKind4[SymbolKind4["Interface"] = 10] = "Interface";
  SymbolKind4[SymbolKind4["Function"] = 11] = "Function";
  SymbolKind4[SymbolKind4["Variable"] = 12] = "Variable";
  SymbolKind4[SymbolKind4["Constant"] = 13] = "Constant";
  SymbolKind4[SymbolKind4["String"] = 14] = "String";
  SymbolKind4[SymbolKind4["Number"] = 15] = "Number";
  SymbolKind4[SymbolKind4["Boolean"] = 16] = "Boolean";
  SymbolKind4[SymbolKind4["Array"] = 17] = "Array";
  SymbolKind4[SymbolKind4["Object"] = 18] = "Object";
  SymbolKind4[SymbolKind4["Key"] = 19] = "Key";
  SymbolKind4[SymbolKind4["Null"] = 20] = "Null";
  SymbolKind4[SymbolKind4["EnumMember"] = 21] = "EnumMember";
  SymbolKind4[SymbolKind4["Struct"] = 22] = "Struct";
  SymbolKind4[SymbolKind4["Event"] = 23] = "Event";
  SymbolKind4[SymbolKind4["Operator"] = 24] = "Operator";
  SymbolKind4[SymbolKind4["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var symbolKindNames = {
  [
    17
    /* SymbolKind.Array */
  ]: localize(876, null),
  [
    16
    /* SymbolKind.Boolean */
  ]: localize(877, null),
  [
    4
    /* SymbolKind.Class */
  ]: localize(878, null),
  [
    13
    /* SymbolKind.Constant */
  ]: localize(879, null),
  [
    8
    /* SymbolKind.Constructor */
  ]: localize(880, null),
  [
    9
    /* SymbolKind.Enum */
  ]: localize(881, null),
  [
    21
    /* SymbolKind.EnumMember */
  ]: localize(882, null),
  [
    23
    /* SymbolKind.Event */
  ]: localize(883, null),
  [
    7
    /* SymbolKind.Field */
  ]: localize(884, null),
  [
    0
    /* SymbolKind.File */
  ]: localize(885, null),
  [
    11
    /* SymbolKind.Function */
  ]: localize(886, null),
  [
    10
    /* SymbolKind.Interface */
  ]: localize(887, null),
  [
    19
    /* SymbolKind.Key */
  ]: localize(888, null),
  [
    5
    /* SymbolKind.Method */
  ]: localize(889, null),
  [
    1
    /* SymbolKind.Module */
  ]: localize(890, null),
  [
    2
    /* SymbolKind.Namespace */
  ]: localize(891, null),
  [
    20
    /* SymbolKind.Null */
  ]: localize(892, null),
  [
    15
    /* SymbolKind.Number */
  ]: localize(893, null),
  [
    18
    /* SymbolKind.Object */
  ]: localize(894, null),
  [
    24
    /* SymbolKind.Operator */
  ]: localize(895, null),
  [
    3
    /* SymbolKind.Package */
  ]: localize(896, null),
  [
    6
    /* SymbolKind.Property */
  ]: localize(897, null),
  [
    14
    /* SymbolKind.String */
  ]: localize(898, null),
  [
    22
    /* SymbolKind.Struct */
  ]: localize(899, null),
  [
    25
    /* SymbolKind.TypeParameter */
  ]: localize(900, null),
  [
    12
    /* SymbolKind.Variable */
  ]: localize(901, null)
};
var SymbolTag;
(function(SymbolTag4) {
  SymbolTag4[SymbolTag4["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
var SymbolKinds;
(function(SymbolKinds2) {
  const byKind = /* @__PURE__ */ new Map();
  byKind.set(0, Codicon.symbolFile);
  byKind.set(1, Codicon.symbolModule);
  byKind.set(2, Codicon.symbolNamespace);
  byKind.set(3, Codicon.symbolPackage);
  byKind.set(4, Codicon.symbolClass);
  byKind.set(5, Codicon.symbolMethod);
  byKind.set(6, Codicon.symbolProperty);
  byKind.set(7, Codicon.symbolField);
  byKind.set(8, Codicon.symbolConstructor);
  byKind.set(9, Codicon.symbolEnum);
  byKind.set(10, Codicon.symbolInterface);
  byKind.set(11, Codicon.symbolFunction);
  byKind.set(12, Codicon.symbolVariable);
  byKind.set(13, Codicon.symbolConstant);
  byKind.set(14, Codicon.symbolString);
  byKind.set(15, Codicon.symbolNumber);
  byKind.set(16, Codicon.symbolBoolean);
  byKind.set(17, Codicon.symbolArray);
  byKind.set(18, Codicon.symbolObject);
  byKind.set(19, Codicon.symbolKey);
  byKind.set(20, Codicon.symbolNull);
  byKind.set(21, Codicon.symbolEnumMember);
  byKind.set(22, Codicon.symbolStruct);
  byKind.set(23, Codicon.symbolEvent);
  byKind.set(24, Codicon.symbolOperator);
  byKind.set(25, Codicon.symbolTypeParameter);
  function toIcon(kind) {
    let icon = byKind.get(kind);
    if (!icon) {
      console.info("No codicon found for SymbolKind " + kind);
      icon = Codicon.symbolProperty;
    }
    return icon;
  }
  SymbolKinds2.toIcon = toIcon;
  const byCompletionKind = /* @__PURE__ */ new Map();
  byCompletionKind.set(
    0,
    20
    /* CompletionItemKind.File */
  );
  byCompletionKind.set(
    1,
    8
    /* CompletionItemKind.Module */
  );
  byCompletionKind.set(
    2,
    8
    /* CompletionItemKind.Module */
  );
  byCompletionKind.set(
    3,
    8
    /* CompletionItemKind.Module */
  );
  byCompletionKind.set(
    4,
    5
    /* CompletionItemKind.Class */
  );
  byCompletionKind.set(
    5,
    0
    /* CompletionItemKind.Method */
  );
  byCompletionKind.set(
    6,
    9
    /* CompletionItemKind.Property */
  );
  byCompletionKind.set(
    7,
    3
    /* CompletionItemKind.Field */
  );
  byCompletionKind.set(
    8,
    2
    /* CompletionItemKind.Constructor */
  );
  byCompletionKind.set(
    9,
    15
    /* CompletionItemKind.Enum */
  );
  byCompletionKind.set(
    10,
    7
    /* CompletionItemKind.Interface */
  );
  byCompletionKind.set(
    11,
    1
    /* CompletionItemKind.Function */
  );
  byCompletionKind.set(
    12,
    4
    /* CompletionItemKind.Variable */
  );
  byCompletionKind.set(
    13,
    14
    /* CompletionItemKind.Constant */
  );
  byCompletionKind.set(
    14,
    18
    /* CompletionItemKind.Text */
  );
  byCompletionKind.set(
    15,
    13
    /* CompletionItemKind.Value */
  );
  byCompletionKind.set(
    16,
    13
    /* CompletionItemKind.Value */
  );
  byCompletionKind.set(
    17,
    13
    /* CompletionItemKind.Value */
  );
  byCompletionKind.set(
    18,
    13
    /* CompletionItemKind.Value */
  );
  byCompletionKind.set(
    19,
    17
    /* CompletionItemKind.Keyword */
  );
  byCompletionKind.set(
    20,
    13
    /* CompletionItemKind.Value */
  );
  byCompletionKind.set(
    21,
    16
    /* CompletionItemKind.EnumMember */
  );
  byCompletionKind.set(
    22,
    6
    /* CompletionItemKind.Struct */
  );
  byCompletionKind.set(
    23,
    10
    /* CompletionItemKind.Event */
  );
  byCompletionKind.set(
    24,
    11
    /* CompletionItemKind.Operator */
  );
  byCompletionKind.set(
    25,
    24
    /* CompletionItemKind.TypeParameter */
  );
  function toCompletionKind(kind) {
    let completionKind = byCompletionKind.get(kind);
    if (completionKind === void 0) {
      console.info("No completion kind found for SymbolKind " + kind);
      completionKind = 20;
    }
    return completionKind;
  }
  SymbolKinds2.toCompletionKind = toCompletionKind;
})(SymbolKinds || (SymbolKinds = {}));
var FoldingRangeKind = class _FoldingRangeKind {
  static {
    this.Comment = new _FoldingRangeKind("comment");
  }
  static {
    this.Imports = new _FoldingRangeKind("imports");
  }
  static {
    this.Region = new _FoldingRangeKind("region");
  }
  /**
   * Returns a {@link FoldingRangeKind} for the given value.
   *
   * @param value of the kind.
   */
  static fromValue(value) {
    switch (value) {
      case "comment":
        return _FoldingRangeKind.Comment;
      case "imports":
        return _FoldingRangeKind.Imports;
      case "region":
        return _FoldingRangeKind.Region;
    }
    return new _FoldingRangeKind(value);
  }
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(value) {
    this.value = value;
  }
};
var NewSymbolNameTag;
(function(NewSymbolNameTag3) {
  NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
})(NewSymbolNameTag || (NewSymbolNameTag = {}));
var NewSymbolNameTriggerKind;
(function(NewSymbolNameTriggerKind3) {
  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));
var Command;
(function(Command2) {
  function is(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return typeof obj.id === "string" && typeof obj.title === "string";
  }
  Command2.is = is;
})(Command || (Command = {}));
var CommentThreadCollapsibleState;
(function(CommentThreadCollapsibleState3) {
  CommentThreadCollapsibleState3[CommentThreadCollapsibleState3["Collapsed"] = 0] = "Collapsed";
  CommentThreadCollapsibleState3[CommentThreadCollapsibleState3["Expanded"] = 1] = "Expanded";
})(CommentThreadCollapsibleState || (CommentThreadCollapsibleState = {}));
var CommentThreadState;
(function(CommentThreadState3) {
  CommentThreadState3[CommentThreadState3["Unresolved"] = 0] = "Unresolved";
  CommentThreadState3[CommentThreadState3["Resolved"] = 1] = "Resolved";
})(CommentThreadState || (CommentThreadState = {}));
var CommentThreadApplicability;
(function(CommentThreadApplicability3) {
  CommentThreadApplicability3[CommentThreadApplicability3["Current"] = 0] = "Current";
  CommentThreadApplicability3[CommentThreadApplicability3["Outdated"] = 1] = "Outdated";
})(CommentThreadApplicability || (CommentThreadApplicability = {}));
var CommentMode;
(function(CommentMode3) {
  CommentMode3[CommentMode3["Editing"] = 0] = "Editing";
  CommentMode3[CommentMode3["Preview"] = 1] = "Preview";
})(CommentMode || (CommentMode = {}));
var CommentState;
(function(CommentState3) {
  CommentState3[CommentState3["Published"] = 0] = "Published";
  CommentState3[CommentState3["Draft"] = 1] = "Draft";
})(CommentState || (CommentState = {}));
var InlayHintKind;
(function(InlayHintKind4) {
  InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
  InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
var TokenizationRegistry2 = new TokenizationRegistry();
var ExternalUriOpenerPriority;
(function(ExternalUriOpenerPriority3) {
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["None"] = 0] = "None";
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Option"] = 1] = "Option";
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Default"] = 2] = "Default";
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Preferred"] = 3] = "Preferred";
})(ExternalUriOpenerPriority || (ExternalUriOpenerPriority = {}));

// out-build/vs/platform/markers/common/markers.js
var MarkerTag;
(function(MarkerTag2) {
  MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
  MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
var MarkerSeverity;
(function(MarkerSeverity2) {
  MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
  MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
  MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
  MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
(function(MarkerSeverity2) {
  function compare4(a, b) {
    return b - a;
  }
  MarkerSeverity2.compare = compare4;
  const _displayStrings = /* @__PURE__ */ Object.create(null);
  _displayStrings[MarkerSeverity2.Error] = localize(2168, null);
  _displayStrings[MarkerSeverity2.Warning] = localize(2169, null);
  _displayStrings[MarkerSeverity2.Info] = localize(2170, null);
  function toString(a) {
    return _displayStrings[a] || "";
  }
  MarkerSeverity2.toString = toString;
  const _displayStringsPlural = /* @__PURE__ */ Object.create(null);
  _displayStringsPlural[MarkerSeverity2.Error] = localize(2171, null);
  _displayStringsPlural[MarkerSeverity2.Warning] = localize(2172, null);
  _displayStringsPlural[MarkerSeverity2.Info] = localize(2173, null);
  function toStringPlural(a) {
    return _displayStringsPlural[a] || "";
  }
  MarkerSeverity2.toStringPlural = toStringPlural;
  function fromSeverity(severity) {
    switch (severity) {
      case severity_default.Error:
        return MarkerSeverity2.Error;
      case severity_default.Warning:
        return MarkerSeverity2.Warning;
      case severity_default.Info:
        return MarkerSeverity2.Info;
      case severity_default.Ignore:
        return MarkerSeverity2.Hint;
    }
  }
  MarkerSeverity2.fromSeverity = fromSeverity;
  function toSeverity(severity) {
    switch (severity) {
      case MarkerSeverity2.Error:
        return severity_default.Error;
      case MarkerSeverity2.Warning:
        return severity_default.Warning;
      case MarkerSeverity2.Info:
        return severity_default.Info;
      case MarkerSeverity2.Hint:
        return severity_default.Ignore;
    }
  }
  MarkerSeverity2.toSeverity = toSeverity;
})(MarkerSeverity || (MarkerSeverity = {}));
var IMarkerData;
(function(IMarkerData2) {
  const emptyString = "";
  function makeKey(markerData) {
    return makeKeyOptionalMessage(markerData, true);
  }
  IMarkerData2.makeKey = makeKey;
  function makeKeyOptionalMessage(markerData, useMessage) {
    const result = [emptyString];
    if (markerData.source) {
      result.push(markerData.source.replace("\xA6", "\\\xA6"));
    } else {
      result.push(emptyString);
    }
    if (markerData.code) {
      if (typeof markerData.code === "string") {
        result.push(markerData.code.replace("\xA6", "\\\xA6"));
      } else {
        result.push(markerData.code.value.replace("\xA6", "\\\xA6"));
      }
    } else {
      result.push(emptyString);
    }
    if (markerData.severity !== void 0 && markerData.severity !== null) {
      result.push(MarkerSeverity.toString(markerData.severity));
    } else {
      result.push(emptyString);
    }
    if (markerData.message && useMessage) {
      result.push(markerData.message.replace("\xA6", "\\\xA6"));
    } else {
      result.push(emptyString);
    }
    if (markerData.startLineNumber !== void 0 && markerData.startLineNumber !== null) {
      result.push(markerData.startLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.startColumn !== void 0 && markerData.startColumn !== null) {
      result.push(markerData.startColumn.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endLineNumber !== void 0 && markerData.endLineNumber !== null) {
      result.push(markerData.endLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endColumn !== void 0 && markerData.endColumn !== null) {
      result.push(markerData.endColumn.toString());
    } else {
      result.push(emptyString);
    }
    result.push(emptyString);
    return result.join("\xA6");
  }
  IMarkerData2.makeKeyOptionalMessage = makeKeyOptionalMessage;
})(IMarkerData || (IMarkerData = {}));
var IMarkerService = createDecorator("markerService");

// out-build/vs/platform/registry/common/platform.js
var RegistryImpl = class {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(id2, data2) {
    ok(isString(id2));
    ok(isObject(data2));
    ok(!this.data.has(id2), "There is already an extension with this id");
    this.data.set(id2, data2);
  }
  knows(id2) {
    return this.data.has(id2);
  }
  as(id2) {
    return this.data.get(id2) || null;
  }
  dispose() {
    this.data.forEach((value) => {
      if (isFunction(value.dispose)) {
        value.dispose();
      }
    });
    this.data.clear();
  }
};
var Registry = new RegistryImpl();

// out-build/vs/platform/files/common/files.js
var IFileService = createDecorator("fileService");
var FileType;
(function(FileType2) {
  FileType2[FileType2["Unknown"] = 0] = "Unknown";
  FileType2[FileType2["File"] = 1] = "File";
  FileType2[FileType2["Directory"] = 2] = "Directory";
  FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (FileType = {}));
var FilePermission;
(function(FilePermission2) {
  FilePermission2[FilePermission2["Readonly"] = 1] = "Readonly";
  FilePermission2[FilePermission2["Locked"] = 2] = "Locked";
})(FilePermission || (FilePermission = {}));
var FileChangeFilter;
(function(FileChangeFilter2) {
  FileChangeFilter2[FileChangeFilter2["UPDATED"] = 2] = "UPDATED";
  FileChangeFilter2[FileChangeFilter2["ADDED"] = 4] = "ADDED";
  FileChangeFilter2[FileChangeFilter2["DELETED"] = 8] = "DELETED";
})(FileChangeFilter || (FileChangeFilter = {}));
var FileSystemProviderCapabilities;
(function(FileSystemProviderCapabilities2) {
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["None"] = 0] = "None";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileReadWrite"] = 2] = "FileReadWrite";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileOpenReadWriteClose"] = 4] = "FileOpenReadWriteClose";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileReadStream"] = 16] = "FileReadStream";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileFolderCopy"] = 8] = "FileFolderCopy";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["PathCaseSensitive"] = 1024] = "PathCaseSensitive";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["Readonly"] = 2048] = "Readonly";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["Trash"] = 4096] = "Trash";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileWriteUnlock"] = 8192] = "FileWriteUnlock";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileAtomicRead"] = 16384] = "FileAtomicRead";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileAtomicWrite"] = 32768] = "FileAtomicWrite";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileAtomicDelete"] = 65536] = "FileAtomicDelete";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileClone"] = 131072] = "FileClone";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileRealpath"] = 262144] = "FileRealpath";
})(FileSystemProviderCapabilities || (FileSystemProviderCapabilities = {}));
var FileSystemProviderErrorCode;
(function(FileSystemProviderErrorCode2) {
  FileSystemProviderErrorCode2["FileExists"] = "EntryExists";
  FileSystemProviderErrorCode2["FileNotFound"] = "EntryNotFound";
  FileSystemProviderErrorCode2["FileNotADirectory"] = "EntryNotADirectory";
  FileSystemProviderErrorCode2["FileIsADirectory"] = "EntryIsADirectory";
  FileSystemProviderErrorCode2["FileExceedsStorageQuota"] = "EntryExceedsStorageQuota";
  FileSystemProviderErrorCode2["FileTooLarge"] = "EntryTooLarge";
  FileSystemProviderErrorCode2["FileWriteLocked"] = "EntryWriteLocked";
  FileSystemProviderErrorCode2["NoPermissions"] = "NoPermissions";
  FileSystemProviderErrorCode2["Unavailable"] = "Unavailable";
  FileSystemProviderErrorCode2["Unknown"] = "Unknown";
})(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}));
var FileSystemProviderError = class _FileSystemProviderError extends Error {
  static create(error, code) {
    const providerError = new _FileSystemProviderError(error.toString(), code);
    markAsFileSystemProviderError(providerError, code);
    return providerError;
  }
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
function markAsFileSystemProviderError(error, code) {
  error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
  return error;
}
function toFileSystemProviderErrorCode(error) {
  if (!error) {
    return FileSystemProviderErrorCode.Unknown;
  }
  if (error instanceof FileSystemProviderError) {
    return error.code;
  }
  const match2 = /^(.+) \(FileSystemError\)$/.exec(error.name);
  if (!match2) {
    return FileSystemProviderErrorCode.Unknown;
  }
  switch (match2[1]) {
    case FileSystemProviderErrorCode.FileExists:
      return FileSystemProviderErrorCode.FileExists;
    case FileSystemProviderErrorCode.FileIsADirectory:
      return FileSystemProviderErrorCode.FileIsADirectory;
    case FileSystemProviderErrorCode.FileNotADirectory:
      return FileSystemProviderErrorCode.FileNotADirectory;
    case FileSystemProviderErrorCode.FileNotFound:
      return FileSystemProviderErrorCode.FileNotFound;
    case FileSystemProviderErrorCode.FileTooLarge:
      return FileSystemProviderErrorCode.FileTooLarge;
    case FileSystemProviderErrorCode.FileWriteLocked:
      return FileSystemProviderErrorCode.FileWriteLocked;
    case FileSystemProviderErrorCode.NoPermissions:
      return FileSystemProviderErrorCode.NoPermissions;
    case FileSystemProviderErrorCode.Unavailable:
      return FileSystemProviderErrorCode.Unavailable;
  }
  return FileSystemProviderErrorCode.Unknown;
}
function toFileOperationResult(error) {
  if (error instanceof FileOperationError) {
    return error.fileOperationResult;
  }
  switch (toFileSystemProviderErrorCode(error)) {
    case FileSystemProviderErrorCode.FileNotFound:
      return 1;
    case FileSystemProviderErrorCode.FileIsADirectory:
      return 0;
    case FileSystemProviderErrorCode.FileNotADirectory:
      return 9;
    case FileSystemProviderErrorCode.FileWriteLocked:
      return 5;
    case FileSystemProviderErrorCode.NoPermissions:
      return 6;
    case FileSystemProviderErrorCode.FileExists:
      return 4;
    case FileSystemProviderErrorCode.FileTooLarge:
      return 7;
    default:
      return 10;
  }
}
var FileOperation;
(function(FileOperation2) {
  FileOperation2[FileOperation2["CREATE"] = 0] = "CREATE";
  FileOperation2[FileOperation2["DELETE"] = 1] = "DELETE";
  FileOperation2[FileOperation2["MOVE"] = 2] = "MOVE";
  FileOperation2[FileOperation2["COPY"] = 3] = "COPY";
  FileOperation2[FileOperation2["WRITE"] = 4] = "WRITE";
})(FileOperation || (FileOperation = {}));
var FileChangeType;
(function(FileChangeType3) {
  FileChangeType3[FileChangeType3["UPDATED"] = 0] = "UPDATED";
  FileChangeType3[FileChangeType3["ADDED"] = 1] = "ADDED";
  FileChangeType3[FileChangeType3["DELETED"] = 2] = "DELETED";
})(FileChangeType || (FileChangeType = {}));
var FileChangesEvent = class _FileChangesEvent {
  static {
    this.MIXED_CORRELATION = null;
  }
  constructor(changes, ignorePathCasing2) {
    this.ignorePathCasing = ignorePathCasing2;
    this.correlationId = void 0;
    this.added = new Lazy(() => {
      const added = TernarySearchTree.forUris(() => this.ignorePathCasing);
      added.fill(this.rawAdded.map((resource) => [resource, true]));
      return added;
    });
    this.updated = new Lazy(() => {
      const updated = TernarySearchTree.forUris(() => this.ignorePathCasing);
      updated.fill(this.rawUpdated.map((resource) => [resource, true]));
      return updated;
    });
    this.deleted = new Lazy(() => {
      const deleted = TernarySearchTree.forUris(() => this.ignorePathCasing);
      deleted.fill(this.rawDeleted.map((resource) => [resource, true]));
      return deleted;
    });
    this.rawAdded = [];
    this.rawUpdated = [];
    this.rawDeleted = [];
    for (const change of changes) {
      switch (change.type) {
        case 1:
          this.rawAdded.push(change.resource);
          break;
        case 0:
          this.rawUpdated.push(change.resource);
          break;
        case 2:
          this.rawDeleted.push(change.resource);
          break;
      }
      if (this.correlationId !== _FileChangesEvent.MIXED_CORRELATION) {
        if (typeof change.cId === "number") {
          if (this.correlationId === void 0) {
            this.correlationId = change.cId;
          } else if (this.correlationId !== change.cId) {
            this.correlationId = _FileChangesEvent.MIXED_CORRELATION;
          }
        } else {
          if (this.correlationId !== void 0) {
            this.correlationId = _FileChangesEvent.MIXED_CORRELATION;
          }
        }
      }
    }
  }
  /**
   * Find out if the file change events match the provided resource.
   *
   * Note: when passing `FileChangeType.DELETED`, we consider a match
   * also when the parent of the resource got deleted.
   */
  contains(resource, ...types) {
    return this.doContains(resource, { includeChildren: false }, ...types);
  }
  /**
   * Find out if the file change events either match the provided
   * resource, or contain a child of this resource.
   */
  affects(resource, ...types) {
    return this.doContains(resource, { includeChildren: true }, ...types);
  }
  doContains(resource, options2, ...types) {
    if (!resource) {
      return false;
    }
    const hasTypesFilter = types.length > 0;
    if (!hasTypesFilter || types.includes(
      1
      /* FileChangeType.ADDED */
    )) {
      if (this.added.value.get(resource)) {
        return true;
      }
      if (options2.includeChildren && this.added.value.findSuperstr(resource)) {
        return true;
      }
    }
    if (!hasTypesFilter || types.includes(
      0
      /* FileChangeType.UPDATED */
    )) {
      if (this.updated.value.get(resource)) {
        return true;
      }
      if (options2.includeChildren && this.updated.value.findSuperstr(resource)) {
        return true;
      }
    }
    if (!hasTypesFilter || types.includes(
      2
      /* FileChangeType.DELETED */
    )) {
      if (this.deleted.value.findSubstr(resource)) {
        return true;
      }
      if (options2.includeChildren && this.deleted.value.findSuperstr(resource)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns if this event contains added files.
   */
  gotAdded() {
    return this.rawAdded.length > 0;
  }
  /**
   * Returns if this event contains deleted files.
   */
  gotDeleted() {
    return this.rawDeleted.length > 0;
  }
  /**
   * Returns if this event contains updated files.
   */
  gotUpdated() {
    return this.rawUpdated.length > 0;
  }
  /**
   * Returns if this event contains changes that correlate to the
   * provided `correlationId`.
   *
   * File change event correlation is an advanced watch feature that
   * allows to  identify from which watch request the events originate
   * from. This correlation allows to route events specifically
   * only to the requestor and not emit them to all listeners.
   */
  correlates(correlationId) {
    return this.correlationId === correlationId;
  }
  /**
   * Figure out if the event contains changes that correlate to one
   * correlation identifier.
   *
   * File change event correlation is an advanced watch feature that
   * allows to  identify from which watch request the events originate
   * from. This correlation allows to route events specifically
   * only to the requestor and not emit them to all listeners.
   */
  hasCorrelation() {
    return typeof this.correlationId === "number";
  }
};
var FileOperationError = class extends Error {
  constructor(message, fileOperationResult, options2) {
    super(message);
    this.fileOperationResult = fileOperationResult;
    this.options = options2;
  }
};
var FileOperationResult;
(function(FileOperationResult2) {
  FileOperationResult2[FileOperationResult2["FILE_IS_DIRECTORY"] = 0] = "FILE_IS_DIRECTORY";
  FileOperationResult2[FileOperationResult2["FILE_NOT_FOUND"] = 1] = "FILE_NOT_FOUND";
  FileOperationResult2[FileOperationResult2["FILE_NOT_MODIFIED_SINCE"] = 2] = "FILE_NOT_MODIFIED_SINCE";
  FileOperationResult2[FileOperationResult2["FILE_MODIFIED_SINCE"] = 3] = "FILE_MODIFIED_SINCE";
  FileOperationResult2[FileOperationResult2["FILE_MOVE_CONFLICT"] = 4] = "FILE_MOVE_CONFLICT";
  FileOperationResult2[FileOperationResult2["FILE_WRITE_LOCKED"] = 5] = "FILE_WRITE_LOCKED";
  FileOperationResult2[FileOperationResult2["FILE_PERMISSION_DENIED"] = 6] = "FILE_PERMISSION_DENIED";
  FileOperationResult2[FileOperationResult2["FILE_TOO_LARGE"] = 7] = "FILE_TOO_LARGE";
  FileOperationResult2[FileOperationResult2["FILE_INVALID_PATH"] = 8] = "FILE_INVALID_PATH";
  FileOperationResult2[FileOperationResult2["FILE_NOT_DIRECTORY"] = 9] = "FILE_NOT_DIRECTORY";
  FileOperationResult2[FileOperationResult2["FILE_OTHER_ERROR"] = 10] = "FILE_OTHER_ERROR";
})(FileOperationResult || (FileOperationResult = {}));
var FileKind;
(function(FileKind2) {
  FileKind2[FileKind2["FILE"] = 0] = "FILE";
  FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
  FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
})(FileKind || (FileKind = {}));
var ETAG_DISABLED = "";
function etag(stat) {
  if (typeof stat.size !== "number" || typeof stat.mtime !== "number") {
    return void 0;
  }
  return stat.mtime.toString(29) + stat.size.toString(31);
}
var ByteSize = class _ByteSize {
  static {
    this.KB = 1024;
  }
  static {
    this.MB = _ByteSize.KB * _ByteSize.KB;
  }
  static {
    this.GB = _ByteSize.MB * _ByteSize.KB;
  }
  static {
    this.TB = _ByteSize.GB * _ByteSize.KB;
  }
  static formatSize(size) {
    if (!isNumber(size)) {
      size = 0;
    }
    if (size < _ByteSize.KB) {
      return localize(2079, null, size.toFixed(0));
    }
    if (size < _ByteSize.MB) {
      return localize(2080, null, (size / _ByteSize.KB).toFixed(2));
    }
    if (size < _ByteSize.GB) {
      return localize(2081, null, (size / _ByteSize.MB).toFixed(2));
    }
    if (size < _ByteSize.TB) {
      return localize(2082, null, (size / _ByteSize.GB).toFixed(2));
    }
    return localize(2083, null, (size / _ByteSize.TB).toFixed(2));
  }
};

// out-build/vs/base/common/actions.js
var Action = class extends Disposable {
  get onDidChange() {
    return this._onDidChange.event;
  }
  constructor(id2, label = "", cssClass = "", enabled = true, actionCallback) {
    super();
    this._onDidChange = this._register(new Emitter());
    this._enabled = true;
    this._id = id2;
    this._label = label;
    this._cssClass = cssClass;
    this._enabled = enabled;
    this._actionCallback = actionCallback;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(value) {
    this._setLabel(value);
  }
  _setLabel(value) {
    if (this._label !== value) {
      this._label = value;
      this._onDidChange.fire({ label: value });
    }
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(value) {
    this._setTooltip(value);
  }
  _setTooltip(value) {
    if (this._tooltip !== value) {
      this._tooltip = value;
      this._onDidChange.fire({ tooltip: value });
    }
  }
  get class() {
    return this._cssClass;
  }
  set class(value) {
    this._setClass(value);
  }
  _setClass(value) {
    if (this._cssClass !== value) {
      this._cssClass = value;
      this._onDidChange.fire({ class: value });
    }
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._setEnabled(value);
  }
  _setEnabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;
      this._onDidChange.fire({ enabled: value });
    }
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._setChecked(value);
  }
  _setChecked(value) {
    if (this._checked !== value) {
      this._checked = value;
      this._onDidChange.fire({ checked: value });
    }
  }
  async run(event, data2) {
    if (this._actionCallback) {
      await this._actionCallback(event);
    }
  }
};
var Separator = class _Separator {
  constructor() {
    this.id = _Separator.ID;
    this.label = "";
    this.tooltip = "";
    this.class = "separator";
    this.enabled = false;
    this.checked = false;
  }
  /**
   * Joins all non-empty lists of actions with separators.
   */
  static join(...actionLists) {
    let out = [];
    for (const list2 of actionLists) {
      if (!list2.length) {
      } else if (out.length) {
        out = [...out, new _Separator(), ...list2];
      } else {
        out = list2;
      }
    }
    return out;
  }
  static {
    this.ID = "vs.actions.separator";
  }
  async run() {
  }
};
var EmptySubmenuAction = class _EmptySubmenuAction extends Action {
  static {
    this.ID = "vs.actions.empty";
  }
  constructor() {
    super(_EmptySubmenuAction.ID, localize(44, null), void 0, false);
  }
};

// out-build/vs/workbench/common/editor.js
var EditorExtensions = {
  EditorPane: "workbench.contributions.editors",
  EditorFactory: "workbench.contributions.editor.inputFactories"
};
var DEFAULT_EDITOR_ASSOCIATION = {
  id: "default",
  displayName: localize(4454, null),
  providerDisplayName: localize(4455, null)
};
var TEXT_DIFF_EDITOR_ID = "workbench.editors.textDiffEditor";
var BINARY_DIFF_EDITOR_ID = "workbench.editors.binaryResourceDiffEditor";
var EditorPaneSelectionChangeReason;
(function(EditorPaneSelectionChangeReason2) {
  EditorPaneSelectionChangeReason2[EditorPaneSelectionChangeReason2["PROGRAMMATIC"] = 1] = "PROGRAMMATIC";
  EditorPaneSelectionChangeReason2[EditorPaneSelectionChangeReason2["USER"] = 2] = "USER";
  EditorPaneSelectionChangeReason2[EditorPaneSelectionChangeReason2["EDIT"] = 3] = "EDIT";
  EditorPaneSelectionChangeReason2[EditorPaneSelectionChangeReason2["NAVIGATION"] = 4] = "NAVIGATION";
  EditorPaneSelectionChangeReason2[EditorPaneSelectionChangeReason2["JUMP"] = 5] = "JUMP";
})(EditorPaneSelectionChangeReason || (EditorPaneSelectionChangeReason = {}));
var EditorPaneSelectionCompareResult;
(function(EditorPaneSelectionCompareResult2) {
  EditorPaneSelectionCompareResult2[EditorPaneSelectionCompareResult2["IDENTICAL"] = 1] = "IDENTICAL";
  EditorPaneSelectionCompareResult2[EditorPaneSelectionCompareResult2["SIMILAR"] = 2] = "SIMILAR";
  EditorPaneSelectionCompareResult2[EditorPaneSelectionCompareResult2["DIFFERENT"] = 3] = "DIFFERENT";
})(EditorPaneSelectionCompareResult || (EditorPaneSelectionCompareResult = {}));
function findViewStateForEditor(input, group, editorService) {
  for (const editorPane of editorService.visibleEditorPanes) {
    if (editorPane.group.id === group && input.matches(editorPane.input)) {
      return editorPane.getViewState();
    }
  }
  return void 0;
}
function isResourceEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return URI.isUri(candidate?.resource);
}
function isResourceDiffEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return candidate?.original !== void 0 && candidate.modified !== void 0;
}
function isResourceMultiDiffEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  if (!candidate) {
    return false;
  }
  if (candidate.resources && !Array.isArray(candidate.resources)) {
    return false;
  }
  return !!candidate.resources || !!candidate.multiDiffSource;
}
function isResourceSideBySideEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  if (isResourceDiffEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return candidate?.primary !== void 0 && candidate.secondary !== void 0;
}
function isResourceMergeEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return URI.isUri(candidate?.base?.resource) && URI.isUri(candidate?.input1?.resource) && URI.isUri(candidate?.input2?.resource) && URI.isUri(candidate?.result?.resource);
}
var Verbosity;
(function(Verbosity2) {
  Verbosity2[Verbosity2["SHORT"] = 0] = "SHORT";
  Verbosity2[Verbosity2["MEDIUM"] = 1] = "MEDIUM";
  Verbosity2[Verbosity2["LONG"] = 2] = "LONG";
})(Verbosity || (Verbosity = {}));
var SaveReason;
(function(SaveReason2) {
  SaveReason2[SaveReason2["EXPLICIT"] = 1] = "EXPLICIT";
  SaveReason2[SaveReason2["AUTO"] = 2] = "AUTO";
  SaveReason2[SaveReason2["FOCUS_CHANGE"] = 3] = "FOCUS_CHANGE";
  SaveReason2[SaveReason2["WINDOW_CHANGE"] = 4] = "WINDOW_CHANGE";
})(SaveReason || (SaveReason = {}));
var SaveSourceFactory = class {
  constructor() {
    this.mapIdToSaveSource = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a `SaveSource` with an identifier and label
   * to the registry so that it can be used in save operations.
   */
  registerSource(id2, label) {
    let sourceDescriptor = this.mapIdToSaveSource.get(id2);
    if (!sourceDescriptor) {
      sourceDescriptor = { source: id2, label };
      this.mapIdToSaveSource.set(id2, sourceDescriptor);
    }
    return sourceDescriptor.source;
  }
  getSourceLabel(source) {
    return this.mapIdToSaveSource.get(source)?.label ?? source;
  }
};
var SaveSourceRegistry = new SaveSourceFactory();
var EditorInputCapabilities;
(function(EditorInputCapabilities2) {
  EditorInputCapabilities2[EditorInputCapabilities2["None"] = 0] = "None";
  EditorInputCapabilities2[EditorInputCapabilities2["Readonly"] = 2] = "Readonly";
  EditorInputCapabilities2[EditorInputCapabilities2["Untitled"] = 4] = "Untitled";
  EditorInputCapabilities2[EditorInputCapabilities2["Singleton"] = 8] = "Singleton";
  EditorInputCapabilities2[EditorInputCapabilities2["RequiresTrust"] = 16] = "RequiresTrust";
  EditorInputCapabilities2[EditorInputCapabilities2["CanSplitInGroup"] = 32] = "CanSplitInGroup";
  EditorInputCapabilities2[EditorInputCapabilities2["ForceDescription"] = 64] = "ForceDescription";
  EditorInputCapabilities2[EditorInputCapabilities2["CanDropIntoEditor"] = 128] = "CanDropIntoEditor";
  EditorInputCapabilities2[EditorInputCapabilities2["MultipleEditors"] = 256] = "MultipleEditors";
  EditorInputCapabilities2[EditorInputCapabilities2["Scratchpad"] = 512] = "Scratchpad";
})(EditorInputCapabilities || (EditorInputCapabilities = {}));
var AbstractEditorInput = class extends Disposable {
};
function isEditorInput(editor) {
  return editor instanceof AbstractEditorInput;
}
function isEditorInputWithPreferredResource(editor) {
  const candidate = editor;
  return URI.isUri(candidate?.preferredResource);
}
function isSideBySideEditorInput(editor) {
  const candidate = editor;
  return isEditorInput(candidate?.primary) && isEditorInput(candidate?.secondary);
}
function isDiffEditorInput(editor) {
  const candidate = editor;
  return isEditorInput(candidate?.modified) && isEditorInput(candidate?.original);
}
var EditorCloseContext;
(function(EditorCloseContext2) {
  EditorCloseContext2[EditorCloseContext2["UNKNOWN"] = 0] = "UNKNOWN";
  EditorCloseContext2[EditorCloseContext2["REPLACE"] = 1] = "REPLACE";
  EditorCloseContext2[EditorCloseContext2["MOVE"] = 2] = "MOVE";
  EditorCloseContext2[EditorCloseContext2["UNPIN"] = 3] = "UNPIN";
})(EditorCloseContext || (EditorCloseContext = {}));
var GroupModelChangeKind;
(function(GroupModelChangeKind2) {
  GroupModelChangeKind2[GroupModelChangeKind2["GROUP_ACTIVE"] = 0] = "GROUP_ACTIVE";
  GroupModelChangeKind2[GroupModelChangeKind2["GROUP_INDEX"] = 1] = "GROUP_INDEX";
  GroupModelChangeKind2[GroupModelChangeKind2["GROUP_LABEL"] = 2] = "GROUP_LABEL";
  GroupModelChangeKind2[GroupModelChangeKind2["GROUP_LOCKED"] = 3] = "GROUP_LOCKED";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITORS_SELECTION"] = 4] = "EDITORS_SELECTION";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_OPEN"] = 5] = "EDITOR_OPEN";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_CLOSE"] = 6] = "EDITOR_CLOSE";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_MOVE"] = 7] = "EDITOR_MOVE";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_ACTIVE"] = 8] = "EDITOR_ACTIVE";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_LABEL"] = 9] = "EDITOR_LABEL";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_CAPABILITIES"] = 10] = "EDITOR_CAPABILITIES";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_PIN"] = 11] = "EDITOR_PIN";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_TRANSIENT"] = 12] = "EDITOR_TRANSIENT";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_STICKY"] = 13] = "EDITOR_STICKY";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_DIRTY"] = 14] = "EDITOR_DIRTY";
  GroupModelChangeKind2[GroupModelChangeKind2["EDITOR_WILL_DISPOSE"] = 15] = "EDITOR_WILL_DISPOSE";
})(GroupModelChangeKind || (GroupModelChangeKind = {}));
var SideBySideEditor;
(function(SideBySideEditor2) {
  SideBySideEditor2[SideBySideEditor2["PRIMARY"] = 1] = "PRIMARY";
  SideBySideEditor2[SideBySideEditor2["SECONDARY"] = 2] = "SECONDARY";
  SideBySideEditor2[SideBySideEditor2["BOTH"] = 3] = "BOTH";
  SideBySideEditor2[SideBySideEditor2["ANY"] = 4] = "ANY";
})(SideBySideEditor || (SideBySideEditor = {}));
var EditorResourceAccessorImpl = class {
  getOriginalUri(editor, options2) {
    if (!editor) {
      return void 0;
    }
    if (isResourceMergeEditorInput(editor)) {
      return EditorResourceAccessor.getOriginalUri(editor.result, options2);
    }
    if (options2?.supportSideBySide) {
      const { primary, secondary } = this.getSideEditors(editor);
      if (primary && secondary) {
        if (options2?.supportSideBySide === SideBySideEditor.BOTH) {
          return {
            primary: this.getOriginalUri(primary, { filterByScheme: options2.filterByScheme }),
            secondary: this.getOriginalUri(secondary, { filterByScheme: options2.filterByScheme })
          };
        } else if (options2?.supportSideBySide === SideBySideEditor.ANY) {
          return this.getOriginalUri(primary, { filterByScheme: options2.filterByScheme }) ?? this.getOriginalUri(secondary, { filterByScheme: options2.filterByScheme });
        }
        editor = options2.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
      }
    }
    if (isResourceDiffEditorInput(editor) || isResourceMultiDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {
      return void 0;
    }
    const originalResource = isEditorInputWithPreferredResource(editor) ? editor.preferredResource : editor.resource;
    if (!originalResource || !options2?.filterByScheme) {
      return originalResource;
    }
    return this.filterUri(originalResource, options2.filterByScheme);
  }
  getSideEditors(editor) {
    if (isSideBySideEditorInput(editor) || isResourceSideBySideEditorInput(editor)) {
      return { primary: editor.primary, secondary: editor.secondary };
    }
    if (isDiffEditorInput(editor) || isResourceDiffEditorInput(editor)) {
      return { primary: editor.modified, secondary: editor.original };
    }
    return { primary: void 0, secondary: void 0 };
  }
  getCanonicalUri(editor, options2) {
    if (!editor) {
      return void 0;
    }
    if (isResourceMergeEditorInput(editor)) {
      return EditorResourceAccessor.getCanonicalUri(editor.result, options2);
    }
    if (options2?.supportSideBySide) {
      const { primary, secondary } = this.getSideEditors(editor);
      if (primary && secondary) {
        if (options2?.supportSideBySide === SideBySideEditor.BOTH) {
          return {
            primary: this.getCanonicalUri(primary, { filterByScheme: options2.filterByScheme }),
            secondary: this.getCanonicalUri(secondary, { filterByScheme: options2.filterByScheme })
          };
        } else if (options2?.supportSideBySide === SideBySideEditor.ANY) {
          return this.getCanonicalUri(primary, { filterByScheme: options2.filterByScheme }) ?? this.getCanonicalUri(secondary, { filterByScheme: options2.filterByScheme });
        }
        editor = options2.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
      }
    }
    if (isResourceDiffEditorInput(editor) || isResourceMultiDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {
      return void 0;
    }
    const canonicalResource = editor.resource;
    if (!canonicalResource || !options2?.filterByScheme) {
      return canonicalResource;
    }
    return this.filterUri(canonicalResource, options2.filterByScheme);
  }
  filterUri(resource, filter2) {
    if (Array.isArray(filter2)) {
      if (filter2.some((scheme) => resource.scheme === scheme)) {
        return resource;
      }
    } else {
      if (filter2 === resource.scheme) {
        return resource;
      }
    }
    return void 0;
  }
};
var EditorCloseMethod;
(function(EditorCloseMethod2) {
  EditorCloseMethod2[EditorCloseMethod2["UNKNOWN"] = 0] = "UNKNOWN";
  EditorCloseMethod2[EditorCloseMethod2["KEYBOARD"] = 1] = "KEYBOARD";
  EditorCloseMethod2[EditorCloseMethod2["MOUSE"] = 2] = "MOUSE";
})(EditorCloseMethod || (EditorCloseMethod = {}));
var EditorResourceAccessor = new EditorResourceAccessorImpl();
var CloseDirection;
(function(CloseDirection2) {
  CloseDirection2[CloseDirection2["LEFT"] = 0] = "LEFT";
  CloseDirection2[CloseDirection2["RIGHT"] = 1] = "RIGHT";
})(CloseDirection || (CloseDirection = {}));
var EditorFactoryRegistry = class {
  constructor() {
    this.editorSerializerConstructors = /* @__PURE__ */ new Map();
    this.editorSerializerInstances = /* @__PURE__ */ new Map();
  }
  start(accessor) {
    const instantiationService = this.instantiationService = accessor.get(IInstantiationService);
    for (const [key, ctor] of this.editorSerializerConstructors) {
      this.createEditorSerializer(key, ctor, instantiationService);
    }
    this.editorSerializerConstructors.clear();
  }
  createEditorSerializer(editorTypeId, ctor, instantiationService) {
    const instance = instantiationService.createInstance(ctor);
    this.editorSerializerInstances.set(editorTypeId, instance);
  }
  registerFileEditorFactory(factory) {
    if (this.fileEditorFactory) {
      throw new Error("Can only register one file editor factory.");
    }
    this.fileEditorFactory = factory;
  }
  getFileEditorFactory() {
    return assertReturnsDefined(this.fileEditorFactory);
  }
  registerEditorSerializer(editorTypeId, ctor) {
    if (this.editorSerializerConstructors.has(editorTypeId) || this.editorSerializerInstances.has(editorTypeId)) {
      throw new Error(`A editor serializer with type ID '${editorTypeId}' was already registered.`);
    }
    if (!this.instantiationService) {
      this.editorSerializerConstructors.set(editorTypeId, ctor);
    } else {
      this.createEditorSerializer(editorTypeId, ctor, this.instantiationService);
    }
    return toDisposable(() => {
      this.editorSerializerConstructors.delete(editorTypeId);
      this.editorSerializerInstances.delete(editorTypeId);
    });
  }
  getEditorSerializer(arg1) {
    return this.editorSerializerInstances.get(typeof arg1 === "string" ? arg1 : arg1.typeId);
  }
};
Registry.add(EditorExtensions.EditorFactory, new EditorFactoryRegistry());
var EditorsOrder;
(function(EditorsOrder2) {
  EditorsOrder2[EditorsOrder2["MOST_RECENTLY_ACTIVE"] = 0] = "MOST_RECENTLY_ACTIVE";
  EditorsOrder2[EditorsOrder2["SEQUENTIAL"] = 1] = "SEQUENTIAL";
})(EditorsOrder || (EditorsOrder = {}));

// out-build/vs/workbench/contrib/chat/common/chatVariableEntries.js
var OmittedState;
(function(OmittedState2) {
  OmittedState2[OmittedState2["NotOmitted"] = 0] = "NotOmitted";
  OmittedState2[OmittedState2["Partial"] = 1] = "Partial";
  OmittedState2[OmittedState2["Full"] = 2] = "Full";
})(OmittedState || (OmittedState = {}));
var IDiagnosticVariableEntryFilterData;
(function(IDiagnosticVariableEntryFilterData2) {
  IDiagnosticVariableEntryFilterData2.icon = Codicon.error;
  function fromMarker(marker) {
    return {
      filterUri: marker.resource,
      owner: marker.owner,
      problemMessage: marker.message,
      filterRange: { startLineNumber: marker.startLineNumber, endLineNumber: marker.endLineNumber, startColumn: marker.startColumn, endColumn: marker.endColumn }
    };
  }
  IDiagnosticVariableEntryFilterData2.fromMarker = fromMarker;
  function toEntry(data2) {
    return {
      id: id2(data2),
      name: label(data2),
      icon: IDiagnosticVariableEntryFilterData2.icon,
      value: data2,
      kind: "diagnostic",
      ...data2
    };
  }
  IDiagnosticVariableEntryFilterData2.toEntry = toEntry;
  function id2(data2) {
    return [data2.filterUri, data2.owner, data2.filterSeverity, data2.filterRange?.startLineNumber, data2.filterRange?.startColumn].join(":");
  }
  IDiagnosticVariableEntryFilterData2.id = id2;
  function label(data2) {
    let TrimThreshold;
    (function(TrimThreshold2) {
      TrimThreshold2[TrimThreshold2["MaxChars"] = 30] = "MaxChars";
      TrimThreshold2[TrimThreshold2["MaxSpaceLookback"] = 10] = "MaxSpaceLookback";
    })(TrimThreshold || (TrimThreshold = {}));
    if (data2.problemMessage) {
      if (data2.problemMessage.length < 30) {
        return data2.problemMessage;
      }
      const lastSpace = data2.problemMessage.lastIndexOf(
        " ",
        30
        /* TrimThreshold.MaxChars */
      );
      if (lastSpace === -1 || lastSpace + 10 < 30) {
        return data2.problemMessage.substring(
          0,
          30
          /* TrimThreshold.MaxChars */
        ) + "\u2026";
      }
      return data2.problemMessage.substring(0, lastSpace) + "\u2026";
    }
    let labelStr = localize(6440, null);
    if (data2.filterUri) {
      labelStr = localize(6441, null, basename2(data2.filterUri));
    }
    return labelStr;
  }
  IDiagnosticVariableEntryFilterData2.label = label;
})(IDiagnosticVariableEntryFilterData || (IDiagnosticVariableEntryFilterData = {}));
var IChatRequestVariableEntry;
(function(IChatRequestVariableEntry2) {
  function toUri(entry) {
    return URI.isUri(entry.value) ? entry.value : isLocation(entry.value) ? entry.value.uri : void 0;
  }
  IChatRequestVariableEntry2.toUri = toUri;
})(IChatRequestVariableEntry || (IChatRequestVariableEntry = {}));
function isImageVariableEntry(obj) {
  return obj.kind === "image";
}
function isPromptFileVariableEntry(obj) {
  return obj.kind === "promptFile";
}
function isPromptTextVariableEntry(obj) {
  return obj.kind === "promptText";
}
var PromptFileVariableKind;
(function(PromptFileVariableKind2) {
  PromptFileVariableKind2["Instruction"] = "vscode.prompt.instructions.root";
  PromptFileVariableKind2["InstructionReference"] = "vscode.prompt.instructions";
  PromptFileVariableKind2["PromptFile"] = "vscode.prompt.file";
})(PromptFileVariableKind || (PromptFileVariableKind = {}));

// out-build/vs/workbench/contrib/chat/common/chatSessionsService.js
var ChatSessionStatus;
(function(ChatSessionStatus3) {
  ChatSessionStatus3[ChatSessionStatus3["Failed"] = 0] = "Failed";
  ChatSessionStatus3[ChatSessionStatus3["Completed"] = 1] = "Completed";
  ChatSessionStatus3[ChatSessionStatus3["InProgress"] = 2] = "InProgress";
})(ChatSessionStatus || (ChatSessionStatus = {}));
var localChatSessionType = "local";
var IChatSessionsService = createDecorator("chatSessionsService");

// out-build/vs/workbench/contrib/chat/common/constants.js
var ChatConfiguration;
(function(ChatConfiguration2) {
  ChatConfiguration2["AgentEnabled"] = "chat.agent.enabled";
  ChatConfiguration2["Edits2Enabled"] = "chat.edits2.enabled";
  ChatConfiguration2["ExtensionToolsEnabled"] = "chat.extensionTools.enabled";
  ChatConfiguration2["EditRequests"] = "chat.editRequests";
  ChatConfiguration2["GlobalAutoApprove"] = "chat.tools.global.autoApprove";
  ChatConfiguration2["AutoApproveEdits"] = "chat.tools.edits.autoApprove";
  ChatConfiguration2["AutoApprovedUrls"] = "chat.tools.urls.autoApprove";
  ChatConfiguration2["EligibleForAutoApproval"] = "chat.tools.eligibleForAutoApproval";
  ChatConfiguration2["EnableMath"] = "chat.math.enabled";
  ChatConfiguration2["CheckpointsEnabled"] = "chat.checkpoints.enabled";
  ChatConfiguration2["AgentSessionsViewLocation"] = "chat.agentSessionsViewLocation";
  ChatConfiguration2["ThinkingStyle"] = "chat.agent.thinkingStyle";
  ChatConfiguration2["TodosShowWidget"] = "chat.tools.todos.showWidget";
  ChatConfiguration2["ShowAgentSessionsViewDescription"] = "chat.showAgentSessionsViewDescription";
  ChatConfiguration2["EmptyStateHistoryEnabled"] = "chat.emptyState.history.enabled";
  ChatConfiguration2["NotifyWindowOnResponseReceived"] = "chat.notifyWindowOnResponseReceived";
  ChatConfiguration2["SubagentToolCustomAgents"] = "chat.customAgentInSubagent.enabled";
  ChatConfiguration2["ShowCodeBlockProgressAnimation"] = "chat.agent.codeBlockProgress";
})(ChatConfiguration || (ChatConfiguration = {}));
var ChatModeKind;
(function(ChatModeKind2) {
  ChatModeKind2["Ask"] = "ask";
  ChatModeKind2["Edit"] = "edit";
  ChatModeKind2["Agent"] = "agent";
})(ChatModeKind || (ChatModeKind = {}));
var ThinkingDisplayMode;
(function(ThinkingDisplayMode2) {
  ThinkingDisplayMode2["Collapsed"] = "collapsed";
  ThinkingDisplayMode2["CollapsedPreview"] = "collapsedPreview";
  ThinkingDisplayMode2["FixedScrolling"] = "fixedScrolling";
})(ThinkingDisplayMode || (ThinkingDisplayMode = {}));
var ChatAgentLocation;
(function(ChatAgentLocation2) {
  ChatAgentLocation2["Chat"] = "panel";
  ChatAgentLocation2["Terminal"] = "terminal";
  ChatAgentLocation2["Notebook"] = "notebook";
  ChatAgentLocation2["EditorInline"] = "editor";
})(ChatAgentLocation || (ChatAgentLocation = {}));
(function(ChatAgentLocation2) {
  function fromRaw(value) {
    switch (value) {
      case "panel":
        return ChatAgentLocation2.Chat;
      case "terminal":
        return ChatAgentLocation2.Terminal;
      case "notebook":
        return ChatAgentLocation2.Notebook;
      case "editor":
        return ChatAgentLocation2.EditorInline;
    }
    return ChatAgentLocation2.Chat;
  }
  ChatAgentLocation2.fromRaw = fromRaw;
})(ChatAgentLocation || (ChatAgentLocation = {}));
var chatAlwaysUnsupportedFileSchemes = /* @__PURE__ */ new Set([
  Schemas.vscodeChatEditor,
  Schemas.walkThrough,
  Schemas.vscodeLocalChatSession,
  Schemas.vscodeSettings,
  Schemas.webviewPanel,
  Schemas.vscodeUserData,
  Schemas.extension,
  "ccreq",
  "openai-codex"
  // Codex session custom editor scheme
]);
var CONTEXT_MODELS_EDITOR = new RawContextKey("inModelsEditor", false);
var CONTEXT_MODELS_SEARCH_FOCUS = new RawContextKey("inModelsSearch", false);

// out-build/vs/base/common/observableInternal/debugName.js
var DebugNameData = class {
  constructor(owner, debugNameSource, referenceFn) {
    this.owner = owner;
    this.debugNameSource = debugNameSource;
    this.referenceFn = referenceFn;
  }
  getDebugName(target) {
    return getDebugName(target, this);
  }
};
var countPerName = /* @__PURE__ */ new Map();
var cachedDebugName = /* @__PURE__ */ new WeakMap();
function getDebugName(target, data2) {
  const cached = cachedDebugName.get(target);
  if (cached) {
    return cached;
  }
  const dbgName = computeDebugName(target, data2);
  if (dbgName) {
    let count2 = countPerName.get(dbgName) ?? 0;
    count2++;
    countPerName.set(dbgName, count2);
    const result = count2 === 1 ? dbgName : `${dbgName}#${count2}`;
    cachedDebugName.set(target, result);
    return result;
  }
  return void 0;
}
function computeDebugName(self2, data2) {
  const cached = cachedDebugName.get(self2);
  if (cached) {
    return cached;
  }
  const ownerStr = data2.owner ? formatOwner(data2.owner) + `.` : "";
  let result;
  const debugNameSource = data2.debugNameSource;
  if (debugNameSource !== void 0) {
    if (typeof debugNameSource === "function") {
      result = debugNameSource();
      if (result !== void 0) {
        return ownerStr + result;
      }
    } else {
      return ownerStr + debugNameSource;
    }
  }
  const referenceFn = data2.referenceFn;
  if (referenceFn !== void 0) {
    result = getFunctionName(referenceFn);
    if (result !== void 0) {
      return ownerStr + result;
    }
  }
  if (data2.owner !== void 0) {
    const key = findKey(data2.owner, self2);
    if (key !== void 0) {
      return ownerStr + key;
    }
  }
  return void 0;
}
function findKey(obj, value) {
  for (const key in obj) {
    if (obj[key] === value) {
      return key;
    }
  }
  return void 0;
}
var countPerClassName = /* @__PURE__ */ new Map();
var ownerId = /* @__PURE__ */ new WeakMap();
function formatOwner(owner) {
  const id2 = ownerId.get(owner);
  if (id2) {
    return id2;
  }
  const className = getClassName(owner) ?? "Object";
  let count2 = countPerClassName.get(className) ?? 0;
  count2++;
  countPerClassName.set(className, count2);
  const result = count2 === 1 ? className : `${className}#${count2}`;
  ownerId.set(owner, result);
  return result;
}
function getClassName(obj) {
  const ctor = obj.constructor;
  if (ctor) {
    if (ctor.name === "Object") {
      return void 0;
    }
    return ctor.name;
  }
  return void 0;
}
function getFunctionName(fn) {
  const fnSrc = fn.toString();
  const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
  const match2 = regexp.exec(fnSrc);
  const result = match2 ? match2[1] : void 0;
  return result?.trim();
}

// out-build/vs/base/common/equals.js
var strictEquals = (a, b) => a === b;
function structuralEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (!structuralEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (a && typeof a === "object" && b && typeof b === "object") {
    if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
      const aObj = a;
      const bObj = b;
      const keysA = Object.keys(aObj);
      const keysB = Object.keys(bObj);
      const keysBSet = new Set(keysB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      for (const key of keysA) {
        if (!keysBSet.has(key)) {
          return false;
        }
        if (!structuralEquals(aObj[key], bObj[key])) {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}

// out-build/vs/base/common/observableInternal/base.js
function handleBugIndicatingErrorRecovery(message) {
  const err = new Error("BugIndicatingErrorRecovery: " + message);
  onUnexpectedError(err);
  console.error("recovered from an error that indicates a bug", err);
}

// out-build/vs/base/common/observableInternal/logging/logging.js
var globalObservableLogger;
function addLogger(logger) {
  if (!globalObservableLogger) {
    globalObservableLogger = logger;
  } else if (globalObservableLogger instanceof ComposedLogger) {
    globalObservableLogger.loggers.push(logger);
  } else {
    globalObservableLogger = new ComposedLogger([globalObservableLogger, logger]);
  }
}
function getLogger() {
  return globalObservableLogger;
}
var globalObservableLoggerFn = void 0;
function setLogObservableFn(fn) {
  globalObservableLoggerFn = fn;
}
function logObservable(obs) {
  if (globalObservableLoggerFn) {
    globalObservableLoggerFn(obs);
  }
}
var ComposedLogger = class {
  constructor(loggers) {
    this.loggers = loggers;
  }
  handleObservableCreated(observable, location2) {
    for (const logger of this.loggers) {
      logger.handleObservableCreated(observable, location2);
    }
  }
  handleOnListenerCountChanged(observable, newCount) {
    for (const logger of this.loggers) {
      logger.handleOnListenerCountChanged(observable, newCount);
    }
  }
  handleObservableUpdated(observable, info) {
    for (const logger of this.loggers) {
      logger.handleObservableUpdated(observable, info);
    }
  }
  handleAutorunCreated(autorun2, location2) {
    for (const logger of this.loggers) {
      logger.handleAutorunCreated(autorun2, location2);
    }
  }
  handleAutorunDisposed(autorun2) {
    for (const logger of this.loggers) {
      logger.handleAutorunDisposed(autorun2);
    }
  }
  handleAutorunDependencyChanged(autorun2, observable, change) {
    for (const logger of this.loggers) {
      logger.handleAutorunDependencyChanged(autorun2, observable, change);
    }
  }
  handleAutorunStarted(autorun2) {
    for (const logger of this.loggers) {
      logger.handleAutorunStarted(autorun2);
    }
  }
  handleAutorunFinished(autorun2) {
    for (const logger of this.loggers) {
      logger.handleAutorunFinished(autorun2);
    }
  }
  handleDerivedDependencyChanged(derived2, observable, change) {
    for (const logger of this.loggers) {
      logger.handleDerivedDependencyChanged(derived2, observable, change);
    }
  }
  handleDerivedCleared(observable) {
    for (const logger of this.loggers) {
      logger.handleDerivedCleared(observable);
    }
  }
  handleBeginTransaction(transaction2) {
    for (const logger of this.loggers) {
      logger.handleBeginTransaction(transaction2);
    }
  }
  handleEndTransaction(transaction2) {
    for (const logger of this.loggers) {
      logger.handleEndTransaction(transaction2);
    }
  }
};

// out-build/vs/base/common/observableInternal/transaction.js
function transaction(fn, getDebugName2) {
  const tx = new TransactionImpl(fn, getDebugName2);
  try {
    fn(tx);
  } finally {
    tx.finish();
  }
}
function subtransaction(tx, fn, getDebugName2) {
  if (!tx) {
    transaction(fn, getDebugName2);
  } else {
    fn(tx);
  }
}
var TransactionImpl = class {
  constructor(_fn, _getDebugName) {
    this._fn = _fn;
    this._getDebugName = _getDebugName;
    this._updatingObservers = [];
    getLogger()?.handleBeginTransaction(this);
  }
  getDebugName() {
    if (this._getDebugName) {
      return this._getDebugName();
    }
    return getFunctionName(this._fn);
  }
  updateObserver(observer, observable) {
    if (!this._updatingObservers) {
      handleBugIndicatingErrorRecovery("Transaction already finished!");
      transaction((tx) => {
        tx.updateObserver(observer, observable);
      });
      return;
    }
    this._updatingObservers.push({ observer, observable });
    observer.beginUpdate(observable);
  }
  finish() {
    const updatingObservers = this._updatingObservers;
    if (!updatingObservers) {
      handleBugIndicatingErrorRecovery("transaction.finish() has already been called!");
      return;
    }
    for (let i = 0; i < updatingObservers.length; i++) {
      const { observer, observable } = updatingObservers[i];
      observer.endUpdate(observable);
    }
    this._updatingObservers = null;
    getLogger()?.handleEndTransaction(this);
  }
  debugGetUpdatingObservers() {
    return this._updatingObservers;
  }
};

// out-build/vs/base/common/observableInternal/debugLocation.js
var DebugLocation;
(function(DebugLocation2) {
  let enabled = false;
  function enable() {
    enabled = true;
  }
  DebugLocation2.enable = enable;
  function ofCaller() {
    if (!enabled) {
      return void 0;
    }
    const Err = Error;
    const l = Err.stackTraceLimit;
    Err.stackTraceLimit = 3;
    const stack = new Error().stack;
    Err.stackTraceLimit = l;
    return DebugLocationImpl.fromStack(stack, 2);
  }
  DebugLocation2.ofCaller = ofCaller;
})(DebugLocation || (DebugLocation = {}));
var DebugLocationImpl = class _DebugLocationImpl {
  static fromStack(stack, parentIdx) {
    const lines = stack.split("\n");
    const location2 = parseLine(lines[parentIdx + 1]);
    if (location2) {
      return new _DebugLocationImpl(location2.fileName, location2.line, location2.column, location2.id);
    } else {
      return void 0;
    }
  }
  constructor(fileName, line, column, id2) {
    this.fileName = fileName;
    this.line = line;
    this.column = column;
    this.id = id2;
  }
};
function parseLine(stackLine) {
  const match2 = stackLine.match(/\((.*):(\d+):(\d+)\)/);
  if (match2) {
    return {
      fileName: match2[1],
      line: parseInt(match2[2]),
      column: parseInt(match2[3]),
      id: stackLine
    };
  }
  const match22 = stackLine.match(/at ([^\(\)]*):(\d+):(\d+)/);
  if (match22) {
    return {
      fileName: match22[1],
      line: parseInt(match22[2]),
      column: parseInt(match22[3]),
      id: stackLine
    };
  }
  return void 0;
}

// out-build/vs/base/common/observableInternal/observables/baseObservable.js
var _derived;
function _setDerivedOpts(derived2) {
  _derived = derived2;
}
var _recomputeInitiallyAndOnChange;
function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange2) {
  _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange2;
}
var _keepObserved;
function _setKeepObserved(keepObserved2) {
  _keepObserved = keepObserved2;
}
var _debugGetObservableGraph;
function _setDebugGetObservableGraph(debugGetObservableGraph2) {
  _debugGetObservableGraph = debugGetObservableGraph2;
}
var ConvenientObservable = class {
  get TChange() {
    return null;
  }
  reportChanges() {
    this.get();
  }
  /** @sealed */
  read(reader) {
    if (reader) {
      return reader.readObservable(this);
    } else {
      return this.get();
    }
  }
  map(fnOrOwner, fnOrUndefined, debugLocation = DebugLocation.ofCaller()) {
    const owner = fnOrUndefined === void 0 ? void 0 : fnOrOwner;
    const fn = fnOrUndefined === void 0 ? fnOrOwner : fnOrUndefined;
    return _derived({
      owner,
      debugName: () => {
        const name2 = getFunctionName(fn);
        if (name2 !== void 0) {
          return name2;
        }
        const regexp = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/;
        const match2 = regexp.exec(fn.toString());
        if (match2) {
          return `${this.debugName}.${match2[2]}`;
        }
        if (!owner) {
          return `${this.debugName} (mapped)`;
        }
        return void 0;
      },
      debugReferenceFn: fn
    }, (reader) => fn(this.read(reader), reader), debugLocation);
  }
  /**
   * @sealed
   * Converts an observable of an observable value into a direct observable of the value.
  */
  flatten() {
    return _derived({
      owner: void 0,
      debugName: () => `${this.debugName} (flattened)`
    }, (reader) => this.read(reader).read(reader));
  }
  recomputeInitiallyAndOnChange(store, handleValue) {
    store.add(_recomputeInitiallyAndOnChange(this, handleValue));
    return this;
  }
  /**
   * Ensures that this observable is observed. This keeps the cache alive.
   * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).
   * Use `recomputeInitiallyAndOnChange` for eager evaluation.
   */
  keepObserved(store) {
    store.add(_keepObserved(this));
    return this;
  }
  get debugValue() {
    return this.get();
  }
  get debug() {
    return new DebugHelper(this);
  }
};
var DebugHelper = class {
  constructor(observable) {
    this.observable = observable;
  }
  getDependencyGraph() {
    return _debugGetObservableGraph(this.observable, { type: "dependencies" });
  }
  getObserverGraph() {
    return _debugGetObservableGraph(this.observable, { type: "observers" });
  }
};
var BaseObservable = class extends ConvenientObservable {
  constructor(debugLocation) {
    super();
    this._observers = /* @__PURE__ */ new Set();
    getLogger()?.handleObservableCreated(this, debugLocation);
  }
  addObserver(observer) {
    const len = this._observers.size;
    this._observers.add(observer);
    if (len === 0) {
      this.onFirstObserverAdded();
    }
    if (len !== this._observers.size) {
      getLogger()?.handleOnListenerCountChanged(this, this._observers.size);
    }
  }
  removeObserver(observer) {
    const deleted = this._observers.delete(observer);
    if (deleted && this._observers.size === 0) {
      this.onLastObserverRemoved();
    }
    if (deleted) {
      getLogger()?.handleOnListenerCountChanged(this, this._observers.size);
    }
  }
  onFirstObserverAdded() {
  }
  onLastObserverRemoved() {
  }
  log() {
    const hadLogger = !!getLogger();
    logObservable(this);
    if (!hadLogger) {
      getLogger()?.handleObservableCreated(this, DebugLocation.ofCaller());
    }
    return this;
  }
  debugGetObservers() {
    return this._observers;
  }
};

// out-build/vs/base/common/observableInternal/observables/observableValue.js
function observableValue(nameOrOwner, initialValue, debugLocation = DebugLocation.ofCaller()) {
  let debugNameData;
  if (typeof nameOrOwner === "string") {
    debugNameData = new DebugNameData(void 0, nameOrOwner, void 0);
  } else {
    debugNameData = new DebugNameData(nameOrOwner, void 0, void 0);
  }
  return new ObservableValue(debugNameData, initialValue, strictEquals, debugLocation);
}
var ObservableValue = class extends BaseObservable {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "ObservableValue";
  }
  constructor(_debugNameData, initialValue, _equalityComparator, debugLocation) {
    super(debugLocation);
    this._debugNameData = _debugNameData;
    this._equalityComparator = _equalityComparator;
    this._value = initialValue;
    getLogger()?.handleObservableUpdated(this, { hadValue: false, newValue: initialValue, change: void 0, didChange: true, oldValue: void 0 });
  }
  get() {
    return this._value;
  }
  set(value, tx, change) {
    if (change === void 0 && this._equalityComparator(this._value, value)) {
      return;
    }
    let _tx;
    if (!tx) {
      tx = _tx = new TransactionImpl(() => {
      }, () => `Setting ${this.debugName}`);
    }
    try {
      const oldValue = this._value;
      this._setValue(value);
      getLogger()?.handleObservableUpdated(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });
      for (const observer of this._observers) {
        tx.updateObserver(observer, this);
        observer.handleChange(this, change);
      }
    } finally {
      if (_tx) {
        _tx.finish();
      }
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(newValue) {
    this._value = newValue;
  }
  debugGetState() {
    return {
      value: this._value
    };
  }
  debugSetValue(value) {
    this._value = value;
  }
};

// out-build/vs/base/common/observableInternal/observables/lazyObservableValue.js
var LazyObservableValue = class extends BaseObservable {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "LazyObservableValue";
  }
  constructor(_debugNameData, initialValue, _equalityComparator, debugLocation) {
    super(debugLocation);
    this._debugNameData = _debugNameData;
    this._equalityComparator = _equalityComparator;
    this._isUpToDate = true;
    this._deltas = [];
    this._updateCounter = 0;
    this._value = initialValue;
  }
  get() {
    this._update();
    return this._value;
  }
  _update() {
    if (this._isUpToDate) {
      return;
    }
    this._isUpToDate = true;
    if (this._deltas.length > 0) {
      for (const change of this._deltas) {
        getLogger()?.handleObservableUpdated(this, { change, didChange: true, oldValue: "(unknown)", newValue: this._value, hadValue: true });
        for (const observer of this._observers) {
          observer.handleChange(this, change);
        }
      }
      this._deltas.length = 0;
    } else {
      getLogger()?.handleObservableUpdated(this, { change: void 0, didChange: true, oldValue: "(unknown)", newValue: this._value, hadValue: true });
      for (const observer of this._observers) {
        observer.handleChange(this, void 0);
      }
    }
  }
  _beginUpdate() {
    this._updateCounter++;
    if (this._updateCounter === 1) {
      for (const observer of this._observers) {
        observer.beginUpdate(this);
      }
    }
  }
  _endUpdate() {
    this._updateCounter--;
    if (this._updateCounter === 0) {
      this._update();
      const observers = [...this._observers];
      for (const r of observers) {
        r.endUpdate(this);
      }
    }
  }
  addObserver(observer) {
    const shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCounter > 0;
    super.addObserver(observer);
    if (shouldCallBeginUpdate) {
      observer.beginUpdate(this);
    }
  }
  removeObserver(observer) {
    const shouldCallEndUpdate = this._observers.has(observer) && this._updateCounter > 0;
    super.removeObserver(observer);
    if (shouldCallEndUpdate) {
      observer.endUpdate(this);
    }
  }
  set(value, tx, change) {
    if (change === void 0 && this._equalityComparator(this._value, value)) {
      return;
    }
    let _tx;
    if (!tx) {
      tx = _tx = new TransactionImpl(() => {
      }, () => `Setting ${this.debugName}`);
    }
    try {
      this._isUpToDate = false;
      this._setValue(value);
      if (change !== void 0) {
        this._deltas.push(change);
      }
      tx.updateObserver({
        beginUpdate: () => this._beginUpdate(),
        endUpdate: () => this._endUpdate(),
        handleChange: (observable, change2) => {
        },
        handlePossibleChange: (observable) => {
        }
      }, this);
      if (this._updateCounter > 1) {
        for (const observer of this._observers) {
          observer.handlePossibleChange(this);
        }
      }
    } finally {
      if (_tx) {
        _tx.finish();
      }
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(newValue) {
    this._value = newValue;
  }
};

// out-build/vs/base/common/observableInternal/observables/observableValueOpts.js
function observableValueOpts(options2, initialValue, debugLocation = DebugLocation.ofCaller()) {
  if (options2.lazy) {
    return new LazyObservableValue(new DebugNameData(options2.owner, options2.debugName, void 0), initialValue, options2.equalsFn ?? strictEquals, debugLocation);
  }
  return new ObservableValue(new DebugNameData(options2.owner, options2.debugName, void 0), initialValue, options2.equalsFn ?? strictEquals, debugLocation);
}

// out-build/vs/base/common/observableInternal/reactions/autorunImpl.js
var AutorunState;
(function(AutorunState2) {
  AutorunState2[AutorunState2["dependenciesMightHaveChanged"] = 1] = "dependenciesMightHaveChanged";
  AutorunState2[AutorunState2["stale"] = 2] = "stale";
  AutorunState2[AutorunState2["upToDate"] = 3] = "upToDate";
})(AutorunState || (AutorunState = {}));
function autorunStateToString(state) {
  switch (state) {
    case 1:
      return "dependenciesMightHaveChanged";
    case 2:
      return "stale";
    case 3:
      return "upToDate";
    default:
      return "<unknown>";
  }
}
var AutorunObserver = class {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(_debugNameData, _runFn, _changeTracker, debugLocation) {
    this._debugNameData = _debugNameData;
    this._runFn = _runFn;
    this._changeTracker = _changeTracker;
    this._state = 2;
    this._updateCount = 0;
    this._disposed = false;
    this._dependencies = /* @__PURE__ */ new Set();
    this._dependenciesToBeRemoved = /* @__PURE__ */ new Set();
    this._isRunning = false;
    this._store = void 0;
    this._delayedStore = void 0;
    this._changeSummary = this._changeTracker?.createChangeSummary(void 0);
    getLogger()?.handleAutorunCreated(this, debugLocation);
    this._run();
    trackDisposable(this);
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    for (const o of this._dependencies) {
      o.removeObserver(this);
    }
    this._dependencies.clear();
    if (this._store !== void 0) {
      this._store.dispose();
    }
    if (this._delayedStore !== void 0) {
      this._delayedStore.dispose();
    }
    getLogger()?.handleAutorunDisposed(this);
    markAsDisposed(this);
  }
  _run() {
    const emptySet = this._dependenciesToBeRemoved;
    this._dependenciesToBeRemoved = this._dependencies;
    this._dependencies = emptySet;
    this._state = 3;
    try {
      if (!this._disposed) {
        getLogger()?.handleAutorunStarted(this);
        const changeSummary = this._changeSummary;
        const delayedStore = this._delayedStore;
        if (delayedStore !== void 0) {
          this._delayedStore = void 0;
        }
        try {
          this._isRunning = true;
          if (this._changeTracker) {
            this._changeTracker.beforeUpdate?.(this, changeSummary);
            this._changeSummary = this._changeTracker.createChangeSummary(changeSummary);
          }
          if (this._store !== void 0) {
            this._store.dispose();
            this._store = void 0;
          }
          this._runFn(this, changeSummary);
        } catch (e) {
          onBugIndicatingError(e);
        } finally {
          this._isRunning = false;
          if (delayedStore !== void 0) {
            delayedStore.dispose();
          }
        }
      }
    } finally {
      if (!this._disposed) {
        getLogger()?.handleAutorunFinished(this);
      }
      for (const o of this._dependenciesToBeRemoved) {
        o.removeObserver(this);
      }
      this._dependenciesToBeRemoved.clear();
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`;
  }
  // IObserver implementation
  beginUpdate(_observable) {
    if (this._state === 3) {
      this._state = 1;
    }
    this._updateCount++;
  }
  endUpdate(_observable) {
    try {
      if (this._updateCount === 1) {
        do {
          if (this._state === 1) {
            this._state = 3;
            for (const d of this._dependencies) {
              d.reportChanges();
              if (this._state === 2) {
                break;
              }
            }
          }
          if (this._state !== 3) {
            this._run();
          }
        } while (this._state !== 3);
      }
    } finally {
      this._updateCount--;
    }
    assertFn(() => this._updateCount >= 0);
  }
  handlePossibleChange(observable) {
    if (this._state === 3 && this._isDependency(observable)) {
      this._state = 1;
    }
  }
  handleChange(observable, change) {
    if (this._isDependency(observable)) {
      getLogger()?.handleAutorunDependencyChanged(this, observable, change);
      try {
        const shouldReact = this._changeTracker ? this._changeTracker.handleChange({
          changedObservable: observable,
          change,
          // eslint-disable-next-line local/code-no-any-casts
          didChange: (o) => o === observable
        }, this._changeSummary) : true;
        if (shouldReact) {
          this._state = 2;
        }
      } catch (e) {
        onBugIndicatingError(e);
      }
    }
  }
  _isDependency(observable) {
    return this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable);
  }
  // IReader implementation
  _ensureNoRunning() {
    if (!this._isRunning) {
      throw new BugIndicatingError("The reader object cannot be used outside its compute function!");
    }
  }
  readObservable(observable) {
    this._ensureNoRunning();
    if (this._disposed) {
      return observable.get();
    }
    observable.addObserver(this);
    const value = observable.get();
    this._dependencies.add(observable);
    this._dependenciesToBeRemoved.delete(observable);
    return value;
  }
  get store() {
    this._ensureNoRunning();
    if (this._disposed) {
      throw new BugIndicatingError("Cannot access store after dispose");
    }
    if (this._store === void 0) {
      this._store = new DisposableStore();
    }
    return this._store;
  }
  get delayedStore() {
    this._ensureNoRunning();
    if (this._disposed) {
      throw new BugIndicatingError("Cannot access store after dispose");
    }
    if (this._delayedStore === void 0) {
      this._delayedStore = new DisposableStore();
    }
    return this._delayedStore;
  }
  debugGetState() {
    return {
      isRunning: this._isRunning,
      updateCount: this._updateCount,
      dependencies: this._dependencies,
      state: this._state,
      stateStr: autorunStateToString(this._state)
    };
  }
  debugRerun() {
    if (!this._isRunning) {
      this._run();
    } else {
      this._state = 2;
    }
  }
};

// out-build/vs/base/common/observableInternal/reactions/autorun.js
function autorun(fn, debugLocation = DebugLocation.ofCaller()) {
  return new AutorunObserver(new DebugNameData(void 0, void 0, fn), fn, void 0, debugLocation);
}

// out-build/vs/base/common/observableInternal/observables/derivedImpl.js
var DerivedState;
(function(DerivedState2) {
  DerivedState2[DerivedState2["initial"] = 0] = "initial";
  DerivedState2[DerivedState2["dependenciesMightHaveChanged"] = 1] = "dependenciesMightHaveChanged";
  DerivedState2[DerivedState2["stale"] = 2] = "stale";
  DerivedState2[DerivedState2["upToDate"] = 3] = "upToDate";
})(DerivedState || (DerivedState = {}));
function derivedStateToString(state) {
  switch (state) {
    case 0:
      return "initial";
    case 1:
      return "dependenciesMightHaveChanged";
    case 2:
      return "stale";
    case 3:
      return "upToDate";
    default:
      return "<unknown>";
  }
}
var Derived = class extends BaseObservable {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(_debugNameData, _computeFn, _changeTracker, _handleLastObserverRemoved = void 0, _equalityComparator, debugLocation) {
    super(debugLocation);
    this._debugNameData = _debugNameData;
    this._computeFn = _computeFn;
    this._changeTracker = _changeTracker;
    this._handleLastObserverRemoved = _handleLastObserverRemoved;
    this._equalityComparator = _equalityComparator;
    this._state = 0;
    this._value = void 0;
    this._updateCount = 0;
    this._dependencies = /* @__PURE__ */ new Set();
    this._dependenciesToBeRemoved = /* @__PURE__ */ new Set();
    this._changeSummary = void 0;
    this._isUpdating = false;
    this._isComputing = false;
    this._didReportChange = false;
    this._isInBeforeUpdate = false;
    this._isReaderValid = false;
    this._store = void 0;
    this._delayedStore = void 0;
    this._removedObserverToCallEndUpdateOn = null;
    this._changeSummary = this._changeTracker?.createChangeSummary(void 0);
  }
  onLastObserverRemoved() {
    this._state = 0;
    this._value = void 0;
    getLogger()?.handleDerivedCleared(this);
    for (const d of this._dependencies) {
      d.removeObserver(this);
    }
    this._dependencies.clear();
    if (this._store !== void 0) {
      this._store.dispose();
      this._store = void 0;
    }
    if (this._delayedStore !== void 0) {
      this._delayedStore.dispose();
      this._delayedStore = void 0;
    }
    this._handleLastObserverRemoved?.();
  }
  get() {
    const checkEnabled = false;
    if (this._isComputing && checkEnabled) {
      throw new BugIndicatingError("Cyclic deriveds are not supported yet!");
    }
    if (this._observers.size === 0) {
      let result;
      try {
        this._isReaderValid = true;
        let changeSummary = void 0;
        if (this._changeTracker) {
          changeSummary = this._changeTracker.createChangeSummary(void 0);
          this._changeTracker.beforeUpdate?.(this, changeSummary);
        }
        result = this._computeFn(this, changeSummary);
      } finally {
        this._isReaderValid = false;
      }
      this.onLastObserverRemoved();
      return result;
    } else {
      do {
        if (this._state === 1) {
          for (const d of this._dependencies) {
            d.reportChanges();
            if (this._state === 2) {
              break;
            }
          }
        }
        if (this._state === 1) {
          this._state = 3;
        }
        if (this._state !== 3) {
          this._recompute();
        }
      } while (this._state !== 3);
      return this._value;
    }
  }
  _recompute() {
    let didChange = false;
    this._isComputing = true;
    this._didReportChange = false;
    const emptySet = this._dependenciesToBeRemoved;
    this._dependenciesToBeRemoved = this._dependencies;
    this._dependencies = emptySet;
    try {
      const changeSummary = this._changeSummary;
      this._isReaderValid = true;
      if (this._changeTracker) {
        this._isInBeforeUpdate = true;
        this._changeTracker.beforeUpdate?.(this, changeSummary);
        this._isInBeforeUpdate = false;
        this._changeSummary = this._changeTracker?.createChangeSummary(changeSummary);
      }
      const hadValue = this._state !== 0;
      const oldValue = this._value;
      this._state = 3;
      const delayedStore = this._delayedStore;
      if (delayedStore !== void 0) {
        this._delayedStore = void 0;
      }
      try {
        if (this._store !== void 0) {
          this._store.dispose();
          this._store = void 0;
        }
        this._value = this._computeFn(this, changeSummary);
      } finally {
        this._isReaderValid = false;
        for (const o of this._dependenciesToBeRemoved) {
          o.removeObserver(this);
        }
        this._dependenciesToBeRemoved.clear();
        if (delayedStore !== void 0) {
          delayedStore.dispose();
        }
      }
      didChange = this._didReportChange || hadValue && !this._equalityComparator(oldValue, this._value);
      getLogger()?.handleObservableUpdated(this, {
        oldValue,
        newValue: this._value,
        change: void 0,
        didChange,
        hadValue
      });
    } catch (e) {
      onBugIndicatingError(e);
    }
    this._isComputing = false;
    if (!this._didReportChange && didChange) {
      for (const r of this._observers) {
        r.handleChange(this, void 0);
      }
    } else {
      this._didReportChange = false;
    }
  }
  toString() {
    return `LazyDerived<${this.debugName}>`;
  }
  // IObserver Implementation
  beginUpdate(_observable) {
    if (this._isUpdating) {
      throw new BugIndicatingError("Cyclic deriveds are not supported yet!");
    }
    this._updateCount++;
    this._isUpdating = true;
    try {
      const propagateBeginUpdate = this._updateCount === 1;
      if (this._state === 3) {
        this._state = 1;
        if (!propagateBeginUpdate) {
          for (const r of this._observers) {
            r.handlePossibleChange(this);
          }
        }
      }
      if (propagateBeginUpdate) {
        for (const r of this._observers) {
          r.beginUpdate(this);
        }
      }
    } finally {
      this._isUpdating = false;
    }
  }
  endUpdate(_observable) {
    this._updateCount--;
    if (this._updateCount === 0) {
      const observers = [...this._observers];
      for (const r of observers) {
        r.endUpdate(this);
      }
      if (this._removedObserverToCallEndUpdateOn) {
        const observers2 = [...this._removedObserverToCallEndUpdateOn];
        this._removedObserverToCallEndUpdateOn = null;
        for (const r of observers2) {
          r.endUpdate(this);
        }
      }
    }
    assertFn(() => this._updateCount >= 0);
  }
  handlePossibleChange(observable) {
    if (this._state === 3 && this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable)) {
      this._state = 1;
      for (const r of this._observers) {
        r.handlePossibleChange(this);
      }
    }
  }
  handleChange(observable, change) {
    if (this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable) || this._isInBeforeUpdate) {
      getLogger()?.handleDerivedDependencyChanged(this, observable, change);
      let shouldReact = false;
      try {
        shouldReact = this._changeTracker ? this._changeTracker.handleChange({
          changedObservable: observable,
          change,
          // eslint-disable-next-line local/code-no-any-casts
          didChange: (o) => o === observable
        }, this._changeSummary) : true;
      } catch (e) {
        onBugIndicatingError(e);
      }
      const wasUpToDate = this._state === 3;
      if (shouldReact && (this._state === 1 || wasUpToDate)) {
        this._state = 2;
        if (wasUpToDate) {
          for (const r of this._observers) {
            r.handlePossibleChange(this);
          }
        }
      }
    }
  }
  // IReader Implementation
  _ensureReaderValid() {
    if (!this._isReaderValid) {
      throw new BugIndicatingError("The reader object cannot be used outside its compute function!");
    }
  }
  readObservable(observable) {
    this._ensureReaderValid();
    observable.addObserver(this);
    const value = observable.get();
    this._dependencies.add(observable);
    this._dependenciesToBeRemoved.delete(observable);
    return value;
  }
  reportChange(change) {
    this._ensureReaderValid();
    this._didReportChange = true;
    for (const r of this._observers) {
      r.handleChange(this, change);
    }
  }
  get store() {
    this._ensureReaderValid();
    if (this._store === void 0) {
      this._store = new DisposableStore();
    }
    return this._store;
  }
  get delayedStore() {
    this._ensureReaderValid();
    if (this._delayedStore === void 0) {
      this._delayedStore = new DisposableStore();
    }
    return this._delayedStore;
  }
  addObserver(observer) {
    const shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCount > 0;
    super.addObserver(observer);
    if (shouldCallBeginUpdate) {
      if (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {
        this._removedObserverToCallEndUpdateOn.delete(observer);
      } else {
        observer.beginUpdate(this);
      }
    }
  }
  removeObserver(observer) {
    if (this._observers.has(observer) && this._updateCount > 0) {
      if (!this._removedObserverToCallEndUpdateOn) {
        this._removedObserverToCallEndUpdateOn = /* @__PURE__ */ new Set();
      }
      this._removedObserverToCallEndUpdateOn.add(observer);
    }
    super.removeObserver(observer);
  }
  debugGetState() {
    return {
      state: this._state,
      stateStr: derivedStateToString(this._state),
      updateCount: this._updateCount,
      isComputing: this._isComputing,
      dependencies: this._dependencies,
      value: this._value
    };
  }
  debugSetValue(newValue) {
    this._value = newValue;
  }
  debugRecompute() {
    if (!this._isComputing) {
      this._recompute();
    } else {
      this._state = 2;
    }
  }
  setValue(newValue, tx, change) {
    this._value = newValue;
    const observers = this._observers;
    tx.updateObserver(this, this);
    for (const d of observers) {
      d.handleChange(this, change);
    }
  }
};

// out-build/vs/base/common/observableInternal/observables/derived.js
function derived(computeFnOrOwner, computeFn, debugLocation = DebugLocation.ofCaller()) {
  if (computeFn !== void 0) {
    return new Derived(new DebugNameData(computeFnOrOwner, void 0, computeFn), computeFn, void 0, void 0, strictEquals, debugLocation);
  }
  return new Derived(
    // eslint-disable-next-line local/code-no-any-casts
    new DebugNameData(void 0, void 0, computeFnOrOwner),
    // eslint-disable-next-line local/code-no-any-casts
    computeFnOrOwner,
    void 0,
    void 0,
    strictEquals,
    debugLocation
  );
}
function derivedOpts(options2, computeFn, debugLocation = DebugLocation.ofCaller()) {
  return new Derived(new DebugNameData(options2.owner, options2.debugName, options2.debugReferenceFn), computeFn, void 0, options2.onLastObserverRemoved, options2.equalsFn ?? strictEquals, debugLocation);
}
_setDerivedOpts(derivedOpts);

// out-build/vs/base/common/observableInternal/observables/observableFromEvent.js
function observableFromEvent(...args) {
  let owner;
  let event;
  let getValue;
  let debugLocation;
  if (args.length === 2) {
    [event, getValue] = args;
  } else {
    [owner, event, getValue, debugLocation] = args;
  }
  return new FromEventObservable(new DebugNameData(owner, void 0, getValue), event, getValue, () => FromEventObservable.globalTransaction, strictEquals, debugLocation ?? DebugLocation.ofCaller());
}
var FromEventObservable = class extends BaseObservable {
  constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator, debugLocation) {
    super(debugLocation);
    this._debugNameData = _debugNameData;
    this.event = event;
    this._getValue = _getValue;
    this._getTransaction = _getTransaction;
    this._equalityComparator = _equalityComparator;
    this._hasValue = false;
    this.handleEvent = (args) => {
      const newValue = this._getValue(args);
      const oldValue = this._value;
      const didChange = !this._hasValue || !this._equalityComparator(oldValue, newValue);
      let didRunTransaction = false;
      if (didChange) {
        this._value = newValue;
        if (this._hasValue) {
          didRunTransaction = true;
          subtransaction(this._getTransaction(), (tx) => {
            getLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: void 0, didChange, hadValue: this._hasValue });
            for (const o of this._observers) {
              tx.updateObserver(o, this);
              o.handleChange(this, void 0);
            }
          }, () => {
            const name2 = this.getDebugName();
            return "Event fired" + (name2 ? `: ${name2}` : "");
          });
        }
        this._hasValue = true;
      }
      if (!didRunTransaction) {
        getLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: void 0, didChange, hadValue: this._hasValue });
      }
    };
  }
  getDebugName() {
    return this._debugNameData.getDebugName(this);
  }
  get debugName() {
    const name2 = this.getDebugName();
    return "From Event" + (name2 ? `: ${name2}` : "");
  }
  onFirstObserverAdded() {
    this._subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this._subscription.dispose();
    this._subscription = void 0;
    this._hasValue = false;
    this._value = void 0;
  }
  get() {
    if (this._subscription) {
      if (!this._hasValue) {
        this.handleEvent(void 0);
      }
      return this._value;
    } else {
      const value = this._getValue(void 0);
      return value;
    }
  }
  debugSetValue(value) {
    this._value = value;
  }
  debugGetState() {
    return { value: this._value, hasValue: this._hasValue };
  }
};
(function(observableFromEvent2) {
  observableFromEvent2.Observer = FromEventObservable;
  function batchEventsGlobally(tx, fn) {
    let didSet = false;
    if (FromEventObservable.globalTransaction === void 0) {
      FromEventObservable.globalTransaction = tx;
      didSet = true;
    }
    try {
      fn();
    } finally {
      if (didSet) {
        FromEventObservable.globalTransaction = void 0;
      }
    }
  }
  observableFromEvent2.batchEventsGlobally = batchEventsGlobally;
})(observableFromEvent || (observableFromEvent = {}));

// out-build/vs/base/common/observableInternal/utils/utils.js
function keepObserved(observable) {
  const o = new KeepAliveObserver(false, void 0);
  observable.addObserver(o);
  return toDisposable(() => {
    observable.removeObserver(o);
  });
}
_setKeepObserved(keepObserved);
function recomputeInitiallyAndOnChange(observable, handleValue) {
  const o = new KeepAliveObserver(true, handleValue);
  observable.addObserver(o);
  try {
    o.beginUpdate(observable);
  } finally {
    o.endUpdate(observable);
  }
  return toDisposable(() => {
    observable.removeObserver(o);
  });
}
_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);
var KeepAliveObserver = class {
  constructor(_forceRecompute, _handleValue) {
    this._forceRecompute = _forceRecompute;
    this._handleValue = _handleValue;
    this._counter = 0;
  }
  beginUpdate(observable) {
    this._counter++;
  }
  endUpdate(observable) {
    if (this._counter === 1 && this._forceRecompute) {
      if (this._handleValue) {
        this._handleValue(observable.get());
      } else {
        observable.reportChanges();
      }
    }
    this._counter--;
  }
  handlePossibleChange(observable) {
  }
  handleChange(observable, change) {
  }
};

// out-build/vs/base/common/observableInternal/observables/constObservable.js
function constObservable(value) {
  return new ConstObservable(value);
}
var ConstObservable = class extends ConvenientObservable {
  constructor(value) {
    super();
    this.value = value;
  }
  get debugName() {
    return this.toString();
  }
  get() {
    return this.value;
  }
  addObserver(observer) {
  }
  removeObserver(observer) {
  }
  log() {
    return this;
  }
  toString() {
    return `Const: ${this.value}`;
  }
};

// out-build/vs/base/common/observableInternal/set.js
var ObservableSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Set();
    this._obs = observableValueOpts({ equalsFn: () => false }, this);
    this.observable = this._obs;
  }
  get size() {
    return this._data.size;
  }
  has(value) {
    return this._data.has(value);
  }
  add(value, tx) {
    const hadValue = this._data.has(value);
    if (!hadValue) {
      this._data.add(value);
      this._obs.set(this, tx);
    }
    return this;
  }
  delete(value, tx) {
    const result = this._data.delete(value);
    if (result) {
      this._obs.set(this, tx);
    }
    return result;
  }
  clear(tx) {
    if (this._data.size > 0) {
      this._data.clear();
      this._obs.set(this, tx);
    }
  }
  forEach(callbackfn, thisArg) {
    this._data.forEach((value, value2, _set) => {
      callbackfn.call(thisArg, value, value2, this);
    });
  }
  *entries() {
    for (const value of this._data) {
      yield [value, value];
    }
  }
  *keys() {
    yield* this._data.keys();
  }
  *values() {
    yield* this._data.values();
  }
  [Symbol.iterator]() {
    return this.values();
  }
  get [Symbol.toStringTag]() {
    return "ObservableSet";
  }
};

// out-build/vs/base/common/observableInternal/logging/consoleObservableLogger.js
var consoleObservableLogger;
function logObservableToConsole(obs) {
  if (!consoleObservableLogger) {
    consoleObservableLogger = new ConsoleObservableLogger();
    addLogger(consoleObservableLogger);
  }
  consoleObservableLogger.addFilteredObj(obs);
}
var ConsoleObservableLogger = class {
  constructor() {
    this.indentation = 0;
    this.changedObservablesSets = /* @__PURE__ */ new WeakMap();
  }
  addFilteredObj(obj) {
    if (!this._filteredObjects) {
      this._filteredObjects = /* @__PURE__ */ new Set();
    }
    this._filteredObjects.add(obj);
  }
  _isIncluded(obj) {
    return this._filteredObjects?.has(obj) ?? true;
  }
  textToConsoleArgs(text) {
    return consoleTextToArgs([
      normalText(repeat("|  ", this.indentation)),
      text
    ]);
  }
  formatInfo(info) {
    if (!info.hadValue) {
      return [
        normalText(` `),
        styled(formatValue(info.newValue, 60), {
          color: "green"
        }),
        normalText(` (initial)`)
      ];
    }
    return info.didChange ? [
      normalText(` `),
      styled(formatValue(info.oldValue, 70), {
        color: "red",
        strikeThrough: true
      }),
      normalText(` `),
      styled(formatValue(info.newValue, 60), {
        color: "green"
      })
    ] : [normalText(` (unchanged)`)];
  }
  handleObservableCreated(observable) {
    if (observable instanceof Derived) {
      const derived2 = observable;
      this.changedObservablesSets.set(derived2, /* @__PURE__ */ new Set());
      const debugTrackUpdating = false;
      if (debugTrackUpdating) {
        const updating = [];
        derived2.__debugUpdating = updating;
        const existingBeginUpdate = derived2.beginUpdate;
        derived2.beginUpdate = (obs) => {
          updating.push(obs);
          return existingBeginUpdate.apply(derived2, [obs]);
        };
        const existingEndUpdate = derived2.endUpdate;
        derived2.endUpdate = (obs) => {
          const idx = updating.indexOf(obs);
          if (idx === -1) {
            console.error("endUpdate called without beginUpdate", derived2.debugName, obs.debugName);
          }
          updating.splice(idx, 1);
          return existingEndUpdate.apply(derived2, [obs]);
        };
      }
    }
  }
  handleOnListenerCountChanged(observable, newCount) {
  }
  handleObservableUpdated(observable, info) {
    if (!this._isIncluded(observable)) {
      return;
    }
    if (observable instanceof Derived) {
      this._handleDerivedRecomputed(observable, info);
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("observable value changed"),
      styled(observable.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(info)
    ]));
  }
  formatChanges(changes) {
    if (changes.size === 0) {
      return void 0;
    }
    return styled(" (changed deps: " + [...changes].map((o) => o.debugName).join(", ") + ")", { color: "gray" });
  }
  handleDerivedDependencyChanged(derived2, observable, change) {
    if (!this._isIncluded(derived2)) {
      return;
    }
    this.changedObservablesSets.get(derived2)?.add(observable);
  }
  _handleDerivedRecomputed(derived2, info) {
    if (!this._isIncluded(derived2)) {
      return;
    }
    const changedObservables = this.changedObservablesSets.get(derived2);
    if (!changedObservables) {
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("derived recomputed"),
      styled(derived2.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(info),
      this.formatChanges(changedObservables),
      { data: [{ fn: derived2._debugNameData.referenceFn ?? derived2._computeFn }] }
    ]));
    changedObservables.clear();
  }
  handleDerivedCleared(derived2) {
    if (!this._isIncluded(derived2)) {
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("derived cleared"),
      styled(derived2.debugName, { color: "BlueViolet" })
    ]));
  }
  handleFromEventObservableTriggered(observable, info) {
    if (!this._isIncluded(observable)) {
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("observable from event triggered"),
      styled(observable.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(info),
      { data: [{ fn: observable._getValue }] }
    ]));
  }
  handleAutorunCreated(autorun2) {
    if (!this._isIncluded(autorun2)) {
      return;
    }
    this.changedObservablesSets.set(autorun2, /* @__PURE__ */ new Set());
  }
  handleAutorunDisposed(autorun2) {
  }
  handleAutorunDependencyChanged(autorun2, observable, change) {
    if (!this._isIncluded(autorun2)) {
      return;
    }
    this.changedObservablesSets.get(autorun2).add(observable);
  }
  handleAutorunStarted(autorun2) {
    const changedObservables = this.changedObservablesSets.get(autorun2);
    if (!changedObservables) {
      return;
    }
    if (this._isIncluded(autorun2)) {
      console.log(...this.textToConsoleArgs([
        formatKind("autorun"),
        styled(autorun2.debugName, { color: "BlueViolet" }),
        this.formatChanges(changedObservables),
        { data: [{ fn: autorun2._debugNameData.referenceFn ?? autorun2._runFn }] }
      ]));
    }
    changedObservables.clear();
    this.indentation++;
  }
  handleAutorunFinished(autorun2) {
    this.indentation--;
  }
  handleBeginTransaction(transaction2) {
    let transactionName = transaction2.getDebugName();
    if (transactionName === void 0) {
      transactionName = "";
    }
    if (this._isIncluded(transaction2)) {
      console.log(...this.textToConsoleArgs([
        formatKind("transaction"),
        styled(transactionName, { color: "BlueViolet" }),
        { data: [{ fn: transaction2._fn }] }
      ]));
    }
    this.indentation++;
  }
  handleEndTransaction() {
    this.indentation--;
  }
};
function consoleTextToArgs(text) {
  const styles = new Array();
  const data2 = [];
  let firstArg = "";
  function process2(t) {
    if ("length" in t) {
      for (const item of t) {
        if (item) {
          process2(item);
        }
      }
    } else if ("text" in t) {
      firstArg += `%c${t.text}`;
      styles.push(t.style);
      if (t.data) {
        data2.push(...t.data);
      }
    } else if ("data" in t) {
      data2.push(...t.data);
    }
  }
  process2(text);
  const result = [firstArg, ...styles];
  result.push(...data2);
  return result;
}
function normalText(text) {
  return styled(text, { color: "black" });
}
function formatKind(kind) {
  return styled(padStr(`${kind}: `, 10), { color: "black", bold: true });
}
function styled(text, options2 = {
  color: "black"
}) {
  function objToCss(styleObj) {
    return Object.entries(styleObj).reduce((styleString, [propName, propValue]) => {
      return `${styleString}${propName}:${propValue};`;
    }, "");
  }
  const style = {
    color: options2.color
  };
  if (options2.strikeThrough) {
    style["text-decoration"] = "line-through";
  }
  if (options2.bold) {
    style["font-weight"] = "bold";
  }
  return {
    text,
    style: objToCss(style)
  };
}
function formatValue(value, availableLen) {
  switch (typeof value) {
    case "number":
      return "" + value;
    case "string":
      if (value.length + 2 <= availableLen) {
        return `"${value}"`;
      }
      return `"${value.substr(0, availableLen - 7)}"+...`;
    case "boolean":
      return value ? "true" : "false";
    case "undefined":
      return "undefined";
    case "object":
      if (value === null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return formatArray(value, availableLen);
      }
      return formatObject(value, availableLen);
    case "symbol":
      return value.toString();
    case "function":
      return `[[Function${value.name ? " " + value.name : ""}]]`;
    default:
      return "" + value;
  }
}
function formatArray(value, availableLen) {
  let result = "[ ";
  let first = true;
  for (const val of value) {
    if (!first) {
      result += ", ";
    }
    if (result.length - 5 > availableLen) {
      result += "...";
      break;
    }
    first = false;
    result += `${formatValue(val, availableLen - result.length)}`;
  }
  result += " ]";
  return result;
}
function formatObject(value, availableLen) {
  if (typeof value.toString === "function" && value.toString !== Object.prototype.toString) {
    const val = value.toString();
    if (val.length <= availableLen) {
      return val;
    }
    return val.substring(0, availableLen - 3) + "...";
  }
  const className = getClassName(value);
  let result = className ? className + "(" : "{ ";
  let first = true;
  for (const [key, val] of Object.entries(value)) {
    if (!first) {
      result += ", ";
    }
    if (result.length - 5 > availableLen) {
      result += "...";
      break;
    }
    first = false;
    result += `${key}: ${formatValue(val, availableLen - result.length)}`;
  }
  result += className ? ")" : " }";
  return result;
}
function repeat(str, count2) {
  let result = "";
  for (let i = 1; i <= count2; i++) {
    result += str;
  }
  return result;
}
function padStr(str, length) {
  while (str.length < length) {
    str += " ";
  }
  return str;
}

// out-build/vs/base/common/observableInternal/logging/debugger/rpc.js
var SimpleTypedRpcConnection = class _SimpleTypedRpcConnection {
  static createHost(channelFactory, getHandler) {
    return new _SimpleTypedRpcConnection(channelFactory, getHandler);
  }
  static createClient(channelFactory, getHandler) {
    return new _SimpleTypedRpcConnection(channelFactory, getHandler);
  }
  constructor(_channelFactory, _getHandler) {
    this._channelFactory = _channelFactory;
    this._getHandler = _getHandler;
    this._channel = this._channelFactory({
      handleNotification: (notificationData) => {
        const m = notificationData;
        const fn = this._getHandler().notifications[m[0]];
        if (!fn) {
          throw new Error(`Unknown notification "${m[0]}"!`);
        }
        fn(...m[1]);
      },
      handleRequest: (requestData) => {
        const m = requestData;
        try {
          const result = this._getHandler().requests[m[0]](...m[1]);
          return { type: "result", value: result };
        } catch (e) {
          return { type: "error", value: e };
        }
      }
    });
    const requests = new Proxy({}, {
      get: (target, key) => {
        return async (...args) => {
          const result = await this._channel.sendRequest([key, args]);
          if (result.type === "error") {
            throw result.value;
          } else {
            return result.value;
          }
        };
      }
    });
    const notifications = new Proxy({}, {
      get: (target, key) => {
        return (...args) => {
          this._channel.sendNotification([key, args]);
        };
      }
    });
    this.api = { notifications, requests };
  }
};

// out-build/vs/base/common/observableInternal/logging/debugger/debuggerRpc.js
function registerDebugChannel(channelId, createClient) {
  const g = globalThis;
  let queuedNotifications = [];
  let curHost = void 0;
  const { channel, handler } = createChannelFactoryFromDebugChannel({
    sendNotification: (data2) => {
      if (curHost) {
        curHost.sendNotification(data2);
      } else {
        queuedNotifications.push(data2);
      }
    }
  });
  let curClient = void 0;
  (g.$$debugValueEditor_debugChannels ?? (g.$$debugValueEditor_debugChannels = {}))[channelId] = (host) => {
    curClient = createClient();
    curHost = host;
    for (const n of queuedNotifications) {
      host.sendNotification(n);
    }
    queuedNotifications = [];
    return handler;
  };
  return SimpleTypedRpcConnection.createClient(channel, () => {
    if (!curClient) {
      throw new Error("Not supported");
    }
    return curClient;
  });
}
function createChannelFactoryFromDebugChannel(host) {
  let h;
  const channel = (handler) => {
    h = handler;
    return {
      sendNotification: (data2) => {
        host.sendNotification(data2);
      },
      sendRequest: (data2) => {
        throw new Error("not supported");
      }
    };
  };
  return {
    channel,
    handler: {
      handleRequest: (data2) => {
        if (data2.type === "notification") {
          return h?.handleNotification(data2.data);
        } else {
          return h?.handleRequest(data2.data);
        }
      }
    }
  };
}

// out-build/vs/base/common/observableInternal/logging/debugger/utils.js
var Throttler2 = class {
  constructor() {
    this._timeout = void 0;
  }
  throttle(fn, timeoutMs) {
    if (this._timeout === void 0) {
      this._timeout = setTimeout(() => {
        this._timeout = void 0;
        fn();
      }, timeoutMs);
    }
  }
  dispose() {
    if (this._timeout !== void 0) {
      clearTimeout(this._timeout);
    }
  }
};
function deepAssign(target, source) {
  for (const key in source) {
    if (!!target[key] && typeof target[key] === "object" && !!source[key] && typeof source[key] === "object") {
      deepAssign(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}
function deepAssignDeleteNulls(target, source) {
  for (const key in source) {
    if (source[key] === null) {
      delete target[key];
    } else if (!!target[key] && typeof target[key] === "object" && !!source[key] && typeof source[key] === "object") {
      deepAssignDeleteNulls(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}

// out-build/vs/base/common/observableInternal/logging/debugger/devToolsLogger.js
var DevToolsLogger = class _DevToolsLogger {
  static {
    this._instance = void 0;
  }
  static getInstance() {
    if (_DevToolsLogger._instance === void 0) {
      _DevToolsLogger._instance = new _DevToolsLogger();
    }
    return _DevToolsLogger._instance;
  }
  getTransactionState() {
    const affected = [];
    const txs = [...this._activeTransactions];
    if (txs.length === 0) {
      return void 0;
    }
    const observerQueue = txs.flatMap((t) => t.debugGetUpdatingObservers() ?? []).map((o) => o.observer);
    const processedObservers = /* @__PURE__ */ new Set();
    while (observerQueue.length > 0) {
      const observer = observerQueue.shift();
      if (processedObservers.has(observer)) {
        continue;
      }
      processedObservers.add(observer);
      const state = this._getInfo(observer, (d) => {
        if (!processedObservers.has(d)) {
          observerQueue.push(d);
        }
      });
      if (state) {
        affected.push(state);
      }
    }
    return { names: txs.map((t) => t.getDebugName() ?? "tx"), affected };
  }
  _getObservableInfo(observable) {
    const info = this._instanceInfos.get(observable);
    if (!info) {
      onUnexpectedError(new BugIndicatingError("No info found"));
      return void 0;
    }
    return info;
  }
  _getAutorunInfo(autorun2) {
    const info = this._instanceInfos.get(autorun2);
    if (!info) {
      onUnexpectedError(new BugIndicatingError("No info found"));
      return void 0;
    }
    return info;
  }
  _getInfo(observer, queue) {
    if (observer instanceof Derived) {
      const observersToUpdate = [...observer.debugGetObservers()];
      for (const o of observersToUpdate) {
        queue(o);
      }
      const info = this._getObservableInfo(observer);
      if (!info) {
        return;
      }
      const observerState = observer.debugGetState();
      const base = { name: observer.debugName, instanceId: info.instanceId, updateCount: observerState.updateCount };
      const changedDependencies = [...info.changedObservables].map((o) => this._instanceInfos.get(o)?.instanceId).filter(isDefined);
      if (observerState.isComputing) {
        return { ...base, type: "observable/derived", state: "updating", changedDependencies, initialComputation: false };
      }
      switch (observerState.state) {
        case 0:
          return { ...base, type: "observable/derived", state: "noValue" };
        case 3:
          return { ...base, type: "observable/derived", state: "upToDate" };
        case 2:
          return { ...base, type: "observable/derived", state: "stale", changedDependencies };
        case 1:
          return { ...base, type: "observable/derived", state: "possiblyStale" };
      }
    } else if (observer instanceof AutorunObserver) {
      const info = this._getAutorunInfo(observer);
      if (!info) {
        return void 0;
      }
      const base = { name: observer.debugName, instanceId: info.instanceId, updateCount: info.updateCount };
      const changedDependencies = [...info.changedObservables].map((o) => this._instanceInfos.get(o).instanceId);
      if (observer.debugGetState().isRunning) {
        return { ...base, type: "autorun", state: "updating", changedDependencies };
      }
      switch (observer.debugGetState().state) {
        case 3:
          return { ...base, type: "autorun", state: "upToDate" };
        case 2:
          return { ...base, type: "autorun", state: "stale", changedDependencies };
        case 1:
          return { ...base, type: "autorun", state: "possiblyStale" };
      }
    }
    return void 0;
  }
  _formatObservable(obs) {
    const info = this._getObservableInfo(obs);
    if (!info) {
      return void 0;
    }
    return { name: obs.debugName, instanceId: info.instanceId };
  }
  _formatObserver(obs) {
    if (obs instanceof Derived) {
      return { name: obs.toString(), instanceId: this._getObservableInfo(obs)?.instanceId };
    }
    const autorunInfo = this._getAutorunInfo(obs);
    if (autorunInfo) {
      return { name: obs.toString(), instanceId: autorunInfo.instanceId };
    }
    return void 0;
  }
  constructor() {
    this._declarationId = 0;
    this._instanceId = 0;
    this._declarations = /* @__PURE__ */ new Map();
    this._instanceInfos = /* @__PURE__ */ new WeakMap();
    this._aliveInstances = /* @__PURE__ */ new Map();
    this._activeTransactions = /* @__PURE__ */ new Set();
    this._channel = registerDebugChannel("observableDevTools", () => {
      return {
        notifications: {
          setDeclarationIdFilter: (declarationIds) => {
          },
          logObservableValue: (observableId) => {
            console.log("logObservableValue", observableId);
          },
          flushUpdates: () => {
            this._flushUpdates();
          },
          resetUpdates: () => {
            this._pendingChanges = null;
            this._channel.api.notifications.handleChange(this._fullState, true);
          }
        },
        requests: {
          getDeclarations: () => {
            const result = {};
            for (const decl of this._declarations.values()) {
              result[decl.id] = decl;
            }
            return { decls: result };
          },
          getSummarizedInstances: () => {
            return null;
          },
          getObservableValueInfo: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            return {
              observers: [...obs.debugGetObservers()].map((d) => this._formatObserver(d)).filter(isDefined)
            };
          },
          getDerivedInfo: (instanceId) => {
            const d = this._aliveInstances.get(instanceId);
            return {
              dependencies: [...d.debugGetState().dependencies].map((d2) => this._formatObservable(d2)).filter(isDefined),
              observers: [...d.debugGetObservers()].map((d2) => this._formatObserver(d2)).filter(isDefined)
            };
          },
          getAutorunInfo: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            return {
              dependencies: [...obs.debugGetState().dependencies].map((d) => this._formatObservable(d)).filter(isDefined)
            };
          },
          getTransactionState: () => {
            return this.getTransactionState();
          },
          setValue: (instanceId, jsonValue) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs instanceof Derived) {
              obs.debugSetValue(jsonValue);
            } else if (obs instanceof ObservableValue) {
              obs.debugSetValue(jsonValue);
            } else if (obs instanceof FromEventObservable) {
              obs.debugSetValue(jsonValue);
            } else {
              throw new BugIndicatingError("Observable is not supported");
            }
            const observers = [...obs.debugGetObservers()];
            for (const d of observers) {
              d.beginUpdate(obs);
            }
            for (const d of observers) {
              d.handleChange(obs, void 0);
            }
            for (const d of observers) {
              d.endUpdate(obs);
            }
          },
          getValue: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs instanceof Derived) {
              return formatValue(obs.debugGetState().value, 200);
            } else if (obs instanceof ObservableValue) {
              return formatValue(obs.debugGetState().value, 200);
            }
            return void 0;
          },
          logValue: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs && "get" in obs) {
              console.log("Logged Value:", obs.get());
            } else {
              throw new BugIndicatingError("Observable is not supported");
            }
          },
          rerun: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs instanceof Derived) {
              obs.debugRecompute();
            } else if (obs instanceof AutorunObserver) {
              obs.debugRerun();
            } else {
              throw new BugIndicatingError("Observable is not supported");
            }
          }
        }
      };
    });
    this._pendingChanges = null;
    this._changeThrottler = new Throttler2();
    this._fullState = {};
    this._flushUpdates = () => {
      if (this._pendingChanges !== null) {
        this._channel.api.notifications.handleChange(this._pendingChanges, false);
        this._pendingChanges = null;
      }
    };
    DebugLocation.enable();
  }
  _handleChange(update) {
    deepAssignDeleteNulls(this._fullState, update);
    if (this._pendingChanges === null) {
      this._pendingChanges = update;
    } else {
      deepAssign(this._pendingChanges, update);
    }
    this._changeThrottler.throttle(this._flushUpdates, 10);
  }
  _getDeclarationId(type, location2) {
    if (!location2) {
      return -1;
    }
    let decInfo = this._declarations.get(location2.id);
    if (decInfo === void 0) {
      decInfo = {
        id: this._declarationId++,
        type,
        url: location2.fileName,
        line: location2.line,
        column: location2.column
      };
      this._declarations.set(location2.id, decInfo);
      this._handleChange({ decls: { [decInfo.id]: decInfo } });
    }
    return decInfo.id;
  }
  handleObservableCreated(observable, location2) {
    const declarationId = this._getDeclarationId("observable/value", location2);
    const info = {
      declarationId,
      instanceId: this._instanceId++,
      listenerCount: 0,
      lastValue: void 0,
      updateCount: 0,
      changedObservables: /* @__PURE__ */ new Set()
    };
    this._instanceInfos.set(observable, info);
  }
  handleOnListenerCountChanged(observable, newCount) {
    const info = this._getObservableInfo(observable);
    if (!info) {
      return;
    }
    if (info.listenerCount === 0 && newCount > 0) {
      const type = observable instanceof Derived ? "observable/derived" : "observable/value";
      this._aliveInstances.set(info.instanceId, observable);
      this._handleChange({
        instances: {
          [info.instanceId]: {
            instanceId: info.instanceId,
            declarationId: info.declarationId,
            formattedValue: info.lastValue,
            type,
            name: observable.debugName
          }
        }
      });
    } else if (info.listenerCount > 0 && newCount === 0) {
      this._handleChange({
        instances: { [info.instanceId]: null }
      });
      this._aliveInstances.delete(info.instanceId);
    }
    info.listenerCount = newCount;
  }
  handleObservableUpdated(observable, changeInfo) {
    if (observable instanceof Derived) {
      this._handleDerivedRecomputed(observable, changeInfo);
      return;
    }
    const info = this._getObservableInfo(observable);
    if (info) {
      if (changeInfo.didChange) {
        info.lastValue = formatValue(changeInfo.newValue, 30);
        if (info.listenerCount > 0) {
          this._handleChange({
            instances: { [info.instanceId]: { formattedValue: info.lastValue } }
          });
        }
      }
    }
  }
  handleAutorunCreated(autorun2, location2) {
    const declarationId = this._getDeclarationId("autorun", location2);
    const info = {
      declarationId,
      instanceId: this._instanceId++,
      updateCount: 0,
      changedObservables: /* @__PURE__ */ new Set()
    };
    this._instanceInfos.set(autorun2, info);
    this._aliveInstances.set(info.instanceId, autorun2);
    if (info) {
      this._handleChange({
        instances: {
          [info.instanceId]: {
            instanceId: info.instanceId,
            declarationId: info.declarationId,
            runCount: 0,
            type: "autorun",
            name: autorun2.debugName
          }
        }
      });
    }
  }
  handleAutorunDisposed(autorun2) {
    const info = this._getAutorunInfo(autorun2);
    if (!info) {
      return;
    }
    this._handleChange({
      instances: { [info.instanceId]: null }
    });
    this._instanceInfos.delete(autorun2);
    this._aliveInstances.delete(info.instanceId);
  }
  handleAutorunDependencyChanged(autorun2, observable, change) {
    const info = this._getAutorunInfo(autorun2);
    if (!info) {
      return;
    }
    info.changedObservables.add(observable);
  }
  handleAutorunStarted(autorun2) {
  }
  handleAutorunFinished(autorun2) {
    const info = this._getAutorunInfo(autorun2);
    if (!info) {
      return;
    }
    info.changedObservables.clear();
    info.updateCount++;
    this._handleChange({
      instances: { [info.instanceId]: { runCount: info.updateCount } }
    });
  }
  handleDerivedDependencyChanged(derived2, observable, change) {
    const info = this._getObservableInfo(derived2);
    if (info) {
      info.changedObservables.add(observable);
    }
  }
  _handleDerivedRecomputed(observable, changeInfo) {
    const info = this._getObservableInfo(observable);
    if (!info) {
      return;
    }
    const formattedValue = formatValue(changeInfo.newValue, 30);
    info.updateCount++;
    info.changedObservables.clear();
    info.lastValue = formattedValue;
    if (info.listenerCount > 0) {
      this._handleChange({
        instances: { [info.instanceId]: { formattedValue, recomputationCount: info.updateCount } }
      });
    }
  }
  handleDerivedCleared(observable) {
    const info = this._getObservableInfo(observable);
    if (!info) {
      return;
    }
    info.lastValue = void 0;
    info.changedObservables.clear();
    if (info.listenerCount > 0) {
      this._handleChange({
        instances: {
          [info.instanceId]: {
            formattedValue: void 0
          }
        }
      });
    }
  }
  handleBeginTransaction(transaction2) {
    this._activeTransactions.add(transaction2);
  }
  handleEndTransaction(transaction2) {
    this._activeTransactions.delete(transaction2);
  }
};

// out-build/vs/base/common/observableInternal/logging/debugGetDependencyGraph.js
function debugGetObservableGraph(obs, options2) {
  const debugNamePostProcessor = options2?.debugNamePostProcessor ?? ((str) => str);
  const info = Info.from(obs, debugNamePostProcessor);
  if (!info) {
    return "";
  }
  const alreadyListed = /* @__PURE__ */ new Set();
  if (options2.type === "observers") {
    return formatObservableInfoWithObservers(info, 0, alreadyListed, options2).trim();
  } else {
    return formatObservableInfoWithDependencies(info, 0, alreadyListed, options2).trim();
  }
}
function formatObservableInfoWithDependencies(info, indentLevel, alreadyListed, options2) {
  const indent = "		".repeat(indentLevel);
  const lines = [];
  const isAlreadyListed = alreadyListed.has(info.sourceObj);
  if (isAlreadyListed) {
    lines.push(`${indent}* ${info.type} ${info.name} (already listed)`);
    return lines.join("\n");
  }
  alreadyListed.add(info.sourceObj);
  lines.push(`${indent}* ${info.type} ${info.name}:`);
  lines.push(`${indent}  value: ${formatValue(info.value, 50)}`);
  lines.push(`${indent}  state: ${info.state}`);
  if (info.dependencies.length > 0) {
    lines.push(`${indent}  dependencies:`);
    for (const dep of info.dependencies) {
      const info2 = Info.from(dep, options2.debugNamePostProcessor ?? ((name2) => name2)) ?? Info.unknown(dep);
      lines.push(formatObservableInfoWithDependencies(info2, indentLevel + 1, alreadyListed, options2));
    }
  }
  return lines.join("\n");
}
function formatObservableInfoWithObservers(info, indentLevel, alreadyListed, options2) {
  const indent = "		".repeat(indentLevel);
  const lines = [];
  const isAlreadyListed = alreadyListed.has(info.sourceObj);
  if (isAlreadyListed) {
    lines.push(`${indent}* ${info.type} ${info.name} (already listed)`);
    return lines.join("\n");
  }
  alreadyListed.add(info.sourceObj);
  lines.push(`${indent}* ${info.type} ${info.name}:`);
  lines.push(`${indent}  value: ${formatValue(info.value, 50)}`);
  lines.push(`${indent}  state: ${info.state}`);
  if (info.observers.length > 0) {
    lines.push(`${indent}  observers:`);
    for (const observer of info.observers) {
      const info2 = Info.from(observer, options2.debugNamePostProcessor ?? ((name2) => name2)) ?? Info.unknown(observer);
      lines.push(formatObservableInfoWithObservers(info2, indentLevel + 1, alreadyListed, options2));
    }
  }
  return lines.join("\n");
}
var Info = class _Info {
  static from(obs, debugNamePostProcessor) {
    if (obs instanceof AutorunObserver) {
      const state = obs.debugGetState();
      return new _Info(obs, debugNamePostProcessor(obs.debugName), "autorun", void 0, state.stateStr, Array.from(state.dependencies), []);
    } else if (obs instanceof Derived) {
      const state = obs.debugGetState();
      return new _Info(obs, debugNamePostProcessor(obs.debugName), "derived", state.value, state.stateStr, Array.from(state.dependencies), Array.from(obs.debugGetObservers()));
    } else if (obs instanceof ObservableValue) {
      const state = obs.debugGetState();
      return new _Info(obs, debugNamePostProcessor(obs.debugName), "observableValue", state.value, "upToDate", [], Array.from(obs.debugGetObservers()));
    } else if (obs instanceof FromEventObservable) {
      const state = obs.debugGetState();
      return new _Info(obs, debugNamePostProcessor(obs.debugName), "fromEvent", state.value, state.hasValue ? "upToDate" : "initial", [], Array.from(obs.debugGetObservers()));
    }
    return void 0;
  }
  static unknown(obs) {
    return new _Info(obs, "(unknown)", "unknown", void 0, "unknown", [], []);
  }
  constructor(sourceObj, name2, type, value, state, dependencies, observers) {
    this.sourceObj = sourceObj;
    this.name = name2;
    this.type = type;
    this.value = value;
    this.state = state;
    this.dependencies = dependencies;
    this.observers = observers;
  }
};

// out-build/vs/base/common/observableInternal/index.js
_setDebugGetObservableGraph(debugGetObservableGraph);
setLogObservableFn(logObservableToConsole);
var enableLogging = false;
if (enableLogging) {
  addLogger(new ConsoleObservableLogger());
}
if (env && env["VSCODE_DEV_DEBUG_OBSERVABLES"]) {
  addLogger(DevToolsLogger.getInstance());
}

// out-build/vs/workbench/contrib/chat/common/languageModelToolsService.js
var ToolDataSource;
(function(ToolDataSource2) {
  ToolDataSource2.Internal = { type: "internal", label: "Built-In" };
  ToolDataSource2.External = { type: "external", label: "External" };
  function toKey(source) {
    switch (source.type) {
      case "extension":
        return `extension:${source.extensionId.value}`;
      case "mcp":
        return `mcp:${source.collectionId}:${source.definitionId}`;
      case "user":
        return `user:${source.file.toString()}`;
      case "internal":
        return "internal";
      case "external":
        return "external";
    }
  }
  ToolDataSource2.toKey = toKey;
  function equals3(a, b) {
    return toKey(a) === toKey(b);
  }
  ToolDataSource2.equals = equals3;
  function classify(source) {
    if (source.type === "internal") {
      return { ordinal: 1, label: localize(6453, null) };
    } else if (source.type === "mcp") {
      return { ordinal: 2, label: source.label };
    } else if (source.type === "user") {
      return { ordinal: 0, label: localize(6454, null) };
    } else {
      return { ordinal: 3, label: source.label };
    }
  }
  ToolDataSource2.classify = classify;
})(ToolDataSource || (ToolDataSource = {}));
function isToolInvocationContext(obj) {
  return typeof obj === "object" && typeof obj.sessionId === "string" && URI.isUri(obj.sessionResource);
}
var ToolInvocationPresentation;
(function(ToolInvocationPresentation2) {
  ToolInvocationPresentation2["Hidden"] = "hidden";
  ToolInvocationPresentation2["HiddenAfterComplete"] = "hiddenAfterComplete";
})(ToolInvocationPresentation || (ToolInvocationPresentation = {}));
var ToolSet = class {
  constructor(id2, referenceName, icon, source, description, legacyFullNames) {
    this.id = id2;
    this.referenceName = referenceName;
    this.icon = icon;
    this.source = source;
    this.description = description;
    this.legacyFullNames = legacyFullNames;
    this._tools = new ObservableSet();
    this._toolSets = new ObservableSet();
    this.isHomogenous = derived((r) => {
      return !Iterable.some(this._tools.observable.read(r), (tool) => !ToolDataSource.equals(tool.source, this.source)) && !Iterable.some(this._toolSets.observable.read(r), (toolSet) => !ToolDataSource.equals(toolSet.source, this.source));
    });
  }
  addTool(data2, tx) {
    this._tools.add(data2, tx);
    return toDisposable(() => {
      this._tools.delete(data2);
    });
  }
  addToolSet(toolSet, tx) {
    if (toolSet === this) {
      return Disposable.None;
    }
    this._toolSets.add(toolSet, tx);
    return toDisposable(() => {
      this._toolSets.delete(toolSet);
    });
  }
  getTools(r) {
    return Iterable.concat(this._tools.observable.read(r), ...Iterable.map(this._toolSets.observable.read(r), (toolSet) => toolSet.getTools(r)));
  }
};
var ILanguageModelToolsService = createDecorator("ILanguageModelToolsService");
var GithubCopilotToolReference;
(function(GithubCopilotToolReference2) {
  GithubCopilotToolReference2.shell = "shell";
  GithubCopilotToolReference2.edit = "edit";
  GithubCopilotToolReference2.search = "search";
  GithubCopilotToolReference2.customAgent = "custom-agent";
})(GithubCopilotToolReference || (GithubCopilotToolReference = {}));
var VSCodeToolReference;
(function(VSCodeToolReference2) {
  VSCodeToolReference2.customAgent = "agents";
  VSCodeToolReference2.shell = "shell";
  VSCodeToolReference2.runSubagent = "runSubagent";
  VSCodeToolReference2.vscode = "vscode";
  VSCodeToolReference2.launch = "launch";
})(VSCodeToolReference || (VSCodeToolReference = {}));

// out-build/vs/workbench/contrib/mcp/common/modelContextProtocol.js
var MCP;
(function(MCP2) {
  MCP2.LATEST_PROTOCOL_VERSION = "2025-06-18";
  MCP2.JSONRPC_VERSION = "2.0";
  MCP2.PARSE_ERROR = -32700;
  MCP2.INVALID_REQUEST = -32600;
  MCP2.METHOD_NOT_FOUND = -32601;
  MCP2.INVALID_PARAMS = -32602;
  MCP2.INTERNAL_ERROR = -32603;
  MCP2.URL_ELICITATION_REQUIRED = -32042;
})(MCP || (MCP = {}));

// out-build/vs/workbench/contrib/mcp/common/mcpTypes.js
function extensionPrefixedIdentifier(identifier, id2) {
  return ExtensionIdentifier.toKey(identifier) + "/" + id2;
}
var McpCollectionSortOrder;
(function(McpCollectionSortOrder2) {
  McpCollectionSortOrder2[McpCollectionSortOrder2["WorkspaceFolder"] = 0] = "WorkspaceFolder";
  McpCollectionSortOrder2[McpCollectionSortOrder2["Workspace"] = 100] = "Workspace";
  McpCollectionSortOrder2[McpCollectionSortOrder2["User"] = 200] = "User";
  McpCollectionSortOrder2[McpCollectionSortOrder2["Extension"] = 300] = "Extension";
  McpCollectionSortOrder2[McpCollectionSortOrder2["Filesystem"] = 400] = "Filesystem";
  McpCollectionSortOrder2[McpCollectionSortOrder2["RemoteBoost"] = -50] = "RemoteBoost";
})(McpCollectionSortOrder || (McpCollectionSortOrder = {}));
var McpCollectionDefinition;
(function(McpCollectionDefinition2) {
  function equals3(a, b) {
    return a.id === b.id && a.remoteAuthority === b.remoteAuthority && a.label === b.label && a.trustBehavior === b.trustBehavior;
  }
  McpCollectionDefinition2.equals = equals3;
})(McpCollectionDefinition || (McpCollectionDefinition = {}));
var McpServerStaticToolAvailability;
(function(McpServerStaticToolAvailability2) {
  McpServerStaticToolAvailability2[McpServerStaticToolAvailability2["Initial"] = 0] = "Initial";
  McpServerStaticToolAvailability2[McpServerStaticToolAvailability2["Dynamic"] = 1] = "Dynamic";
})(McpServerStaticToolAvailability || (McpServerStaticToolAvailability = {}));
var McpServerDefinition;
(function(McpServerDefinition3) {
  function toSerialized(def2) {
    return def2;
  }
  McpServerDefinition3.toSerialized = toSerialized;
  function fromSerialized(def2) {
    return {
      id: def2.id,
      label: def2.label,
      cacheNonce: def2.cacheNonce,
      staticMetadata: def2.staticMetadata,
      launch: McpServerLaunch.fromSerialized(def2.launch),
      variableReplacement: def2.variableReplacement ? McpServerDefinitionVariableReplacement.fromSerialized(def2.variableReplacement) : void 0
    };
  }
  McpServerDefinition3.fromSerialized = fromSerialized;
  function equals3(a, b) {
    return a.id === b.id && a.label === b.label && equals(a.roots, b.roots, (a2, b2) => a2.toString() === b2.toString()) && equals2(a.launch, b.launch) && equals2(a.presentation, b.presentation) && equals2(a.variableReplacement, b.variableReplacement) && equals2(a.devMode, b.devMode);
  }
  McpServerDefinition3.equals = equals3;
})(McpServerDefinition || (McpServerDefinition = {}));
var McpServerDefinitionVariableReplacement;
(function(McpServerDefinitionVariableReplacement2) {
  function toSerialized(def2) {
    return def2;
  }
  McpServerDefinitionVariableReplacement2.toSerialized = toSerialized;
  function fromSerialized(def2) {
    return {
      section: def2.section,
      folder: def2.folder ? { ...def2.folder, uri: URI.revive(def2.folder.uri) } : void 0,
      target: def2.target
    };
  }
  McpServerDefinitionVariableReplacement2.fromSerialized = fromSerialized;
})(McpServerDefinitionVariableReplacement || (McpServerDefinitionVariableReplacement = {}));
var IAutostartResult;
(function(IAutostartResult2) {
  IAutostartResult2.Empty = { working: false, starting: [], serversRequiringInteraction: [] };
})(IAutostartResult || (IAutostartResult = {}));
var LazyCollectionState;
(function(LazyCollectionState2) {
  LazyCollectionState2[LazyCollectionState2["HasUnknown"] = 0] = "HasUnknown";
  LazyCollectionState2[LazyCollectionState2["LoadingUnknown"] = 1] = "LoadingUnknown";
  LazyCollectionState2[LazyCollectionState2["AllKnown"] = 2] = "AllKnown";
})(LazyCollectionState || (LazyCollectionState = {}));
var IMcpService = createDecorator("IMcpService");
var McpServerTrust;
(function(McpServerTrust2) {
  let Kind;
  (function(Kind2) {
    Kind2[Kind2["Trusted"] = 0] = "Trusted";
    Kind2[Kind2["TrustedOnNonce"] = 1] = "TrustedOnNonce";
    Kind2[Kind2["Untrusted"] = 2] = "Untrusted";
    Kind2[Kind2["Unknown"] = 3] = "Unknown";
  })(Kind = McpServerTrust2.Kind || (McpServerTrust2.Kind = {}));
})(McpServerTrust || (McpServerTrust = {}));
var McpServerCacheState;
(function(McpServerCacheState2) {
  McpServerCacheState2[McpServerCacheState2["Unknown"] = 0] = "Unknown";
  McpServerCacheState2[McpServerCacheState2["Cached"] = 1] = "Cached";
  McpServerCacheState2[McpServerCacheState2["Outdated"] = 2] = "Outdated";
  McpServerCacheState2[McpServerCacheState2["RefreshingFromUnknown"] = 3] = "RefreshingFromUnknown";
  McpServerCacheState2[McpServerCacheState2["RefreshingFromCached"] = 4] = "RefreshingFromCached";
  McpServerCacheState2[McpServerCacheState2["Live"] = 5] = "Live";
})(McpServerCacheState || (McpServerCacheState = {}));
var McpServerTransportType;
(function(McpServerTransportType2) {
  McpServerTransportType2[McpServerTransportType2["Stdio"] = 1] = "Stdio";
  McpServerTransportType2[McpServerTransportType2["HTTP"] = 2] = "HTTP";
})(McpServerTransportType || (McpServerTransportType = {}));
var McpServerLaunch;
(function(McpServerLaunch2) {
  function toSerialized(launch) {
    return launch;
  }
  McpServerLaunch2.toSerialized = toSerialized;
  function fromSerialized(launch) {
    switch (launch.type) {
      case 2:
        return { type: launch.type, uri: URI.revive(launch.uri), headers: launch.headers, authentication: launch.authentication };
      case 1:
        return {
          type: launch.type,
          cwd: launch.cwd,
          command: launch.command,
          args: launch.args,
          env: launch.env,
          envFile: launch.envFile
        };
    }
  }
  McpServerLaunch2.fromSerialized = fromSerialized;
  async function hash2(launch) {
    const nonce = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(launch)));
    return encodeHex(VSBuffer.wrap(new Uint8Array(nonce)));
  }
  McpServerLaunch2.hash = hash2;
})(McpServerLaunch || (McpServerLaunch = {}));
var McpConnectionState;
(function(McpConnectionState2) {
  let Kind;
  (function(Kind2) {
    Kind2[Kind2["Stopped"] = 0] = "Stopped";
    Kind2[Kind2["Starting"] = 1] = "Starting";
    Kind2[Kind2["Running"] = 2] = "Running";
    Kind2[Kind2["Error"] = 3] = "Error";
  })(Kind = McpConnectionState2.Kind || (McpConnectionState2.Kind = {}));
  McpConnectionState2.toString = (s) => {
    switch (s.state) {
      case 0:
        return localize(9905, null);
      case 1:
        return localize(9906, null);
      case 2:
        return localize(9907, null);
      case 3:
        return localize(9908, null, s.message);
      default:
        assertNever(s);
    }
  };
  McpConnectionState2.toKindString = (s) => {
    switch (s) {
      case 0:
        return "stopped";
      case 1:
        return "starting";
      case 2:
        return "running";
      case 3:
        return "error";
      default:
        assertNever(s);
    }
  };
  McpConnectionState2.canBeStarted = (s) => s === 3 || s === 0;
  McpConnectionState2.isRunning = (s) => !McpConnectionState2.canBeStarted(s.state);
})(McpConnectionState || (McpConnectionState = {}));
var UserInteractionRequiredError = class _UserInteractionRequiredError extends Error {
  static {
    this.prefix = "User interaction required: ";
  }
  static is(error) {
    return error.message.startsWith(this.prefix);
  }
  constructor(reason) {
    super(`${_UserInteractionRequiredError.prefix}${reason}`);
    this.reason = reason;
  }
};
var McpServerEnablementState;
(function(McpServerEnablementState2) {
  McpServerEnablementState2[McpServerEnablementState2["Disabled"] = 0] = "Disabled";
  McpServerEnablementState2[McpServerEnablementState2["DisabledByAccess"] = 1] = "DisabledByAccess";
  McpServerEnablementState2[McpServerEnablementState2["Enabled"] = 2] = "Enabled";
})(McpServerEnablementState || (McpServerEnablementState = {}));
var McpServerInstallState;
(function(McpServerInstallState2) {
  McpServerInstallState2[McpServerInstallState2["Installing"] = 0] = "Installing";
  McpServerInstallState2[McpServerInstallState2["Installed"] = 1] = "Installed";
  McpServerInstallState2[McpServerInstallState2["Uninstalling"] = 2] = "Uninstalling";
  McpServerInstallState2[McpServerInstallState2["Uninstalled"] = 3] = "Uninstalled";
})(McpServerInstallState || (McpServerInstallState = {}));
var McpServerEditorTab;
(function(McpServerEditorTab2) {
  McpServerEditorTab2["Readme"] = "readme";
  McpServerEditorTab2["Manifest"] = "manifest";
  McpServerEditorTab2["Configuration"] = "configuration";
})(McpServerEditorTab || (McpServerEditorTab = {}));
var IMcpWorkbenchService = createDecorator("IMcpWorkbenchService");
var McpServerContainers = class McpServerContainers2 extends Disposable {
  constructor(containers, mcpWorkbenchService) {
    super();
    this.containers = containers;
    this._register(mcpWorkbenchService.onChange(this.update, this));
  }
  set mcpServer(extension) {
    this.containers.forEach((c) => c.mcpServer = extension);
  }
  update(server) {
    for (const container of this.containers) {
      if (server && container.mcpServer) {
        if (server.id === container.mcpServer.id) {
          container.mcpServer = server;
        }
      } else {
        container.update();
      }
    }
  }
};
McpServerContainers = __decorate([
  __param(1, IMcpWorkbenchService)
], McpServerContainers);
var McpServersGalleryStatusContext = new RawContextKey(
  "mcpServersGalleryStatus",
  "unavailable"
  /* McpGalleryManifestStatus.Unavailable */
);
var HasInstalledMcpServersContext = new RawContextKey("hasInstalledMcpServers", true);
var McpResourceURI;
(function(McpResourceURI2) {
  McpResourceURI2.scheme = "mcp-resource";
  const emptyAuthorityPlaceholder = "dylo78gyp";
  function fromServer(def2, resourceURI) {
    if (typeof resourceURI === "string") {
      resourceURI = URI.parse(resourceURI);
    }
    return resourceURI.with({
      scheme: McpResourceURI2.scheme,
      authority: encodeHex(VSBuffer.fromString(def2.id)),
      path: ["", resourceURI.scheme, resourceURI.authority || emptyAuthorityPlaceholder].join("/") + resourceURI.path
    });
  }
  McpResourceURI2.fromServer = fromServer;
  function toServer(uri) {
    if (typeof uri === "string") {
      uri = URI.parse(uri);
    }
    if (uri.scheme !== McpResourceURI2.scheme) {
      throw new Error(`Invalid MCP resource URI: ${uri.toString()}`);
    }
    const parts = uri.path.split("/");
    if (parts.length < 3) {
      throw new Error(`Invalid MCP resource URI: ${uri.toString()}`);
    }
    const [, serverScheme, authority, ...path] = parts;
    const url = new URL(`${serverScheme}://${authority.toLowerCase() === emptyAuthorityPlaceholder ? "" : authority}`);
    url.pathname = path.length ? "/" + path.join("/") : "";
    url.search = uri.query;
    url.hash = uri.fragment;
    return {
      definitionId: decodeHex(uri.authority).toString(),
      resourceURL: url
    };
  }
  McpResourceURI2.toServer = toServer;
})(McpResourceURI || (McpResourceURI = {}));
var McpCapability;
(function(McpCapability2) {
  McpCapability2[McpCapability2["Logging"] = 1] = "Logging";
  McpCapability2[McpCapability2["Completions"] = 2] = "Completions";
  McpCapability2[McpCapability2["Prompts"] = 4] = "Prompts";
  McpCapability2[McpCapability2["PromptsListChanged"] = 8] = "PromptsListChanged";
  McpCapability2[McpCapability2["Resources"] = 16] = "Resources";
  McpCapability2[McpCapability2["ResourcesSubscribe"] = 32] = "ResourcesSubscribe";
  McpCapability2[McpCapability2["ResourcesListChanged"] = 64] = "ResourcesListChanged";
  McpCapability2[McpCapability2["Tools"] = 128] = "Tools";
  McpCapability2[McpCapability2["ToolsListChanged"] = 256] = "ToolsListChanged";
})(McpCapability || (McpCapability = {}));
var IMcpSamplingService = createDecorator("IMcpServerSampling");
var McpToolName;
(function(McpToolName2) {
  McpToolName2["Prefix"] = "mcp_";
  McpToolName2[McpToolName2["MaxPrefixLen"] = 18] = "MaxPrefixLen";
  McpToolName2[McpToolName2["MaxLength"] = 64] = "MaxLength";
})(McpToolName || (McpToolName = {}));
var ElicitationKind;
(function(ElicitationKind2) {
  ElicitationKind2[ElicitationKind2["Form"] = 0] = "Form";
  ElicitationKind2[ElicitationKind2["URL"] = 1] = "URL";
})(ElicitationKind || (ElicitationKind = {}));
var IMcpElicitationService = createDecorator("IMcpElicitationService");

// out-build/vs/base/common/glob.js
var GLOBSTAR = "**";
var GLOB_SPLIT = "/";
var PATH_REGEX = "[/\\\\]";
var NO_PATH_REGEX = "[^/\\\\]";
var ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount, isLastPattern) {
  switch (starCount) {
    case 0:
      return "";
    case 1:
      return `${NO_PATH_REGEX}*?`;
    // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
    default:
      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ""})*?`;
  }
}
function splitGlobAware(pattern, splitChar) {
  if (!pattern) {
    return [];
  }
  const segments = [];
  let inBraces = false;
  let inBrackets = false;
  let curVal = "";
  for (const char of pattern) {
    switch (char) {
      case splitChar:
        if (!inBraces && !inBrackets) {
          segments.push(curVal);
          curVal = "";
          continue;
        }
        break;
      case "{":
        inBraces = true;
        break;
      case "}":
        inBraces = false;
        break;
      case "[":
        inBrackets = true;
        break;
      case "]":
        inBrackets = false;
        break;
    }
    curVal += char;
  }
  if (curVal) {
    segments.push(curVal);
  }
  return segments;
}
function parseRegExp(pattern) {
  if (!pattern) {
    return "";
  }
  let regEx = "";
  const segments = splitGlobAware(pattern, GLOB_SPLIT);
  if (segments.every((segment) => segment === GLOBSTAR)) {
    regEx = ".*";
  } else {
    let previousSegmentWasGlobStar = false;
    segments.forEach((segment, index) => {
      if (segment === GLOBSTAR) {
        if (previousSegmentWasGlobStar) {
          return;
        }
        regEx += starsToRegExp(2, index === segments.length - 1);
      } else {
        let inBraces = false;
        let braceVal = "";
        let inBrackets = false;
        let bracketVal = "";
        for (const char of segment) {
          if (char !== "}" && inBraces) {
            braceVal += char;
            continue;
          }
          if (inBrackets && (char !== "]" || !bracketVal)) {
            let res;
            if (char === "-") {
              res = char;
            } else if ((char === "^" || char === "!") && !bracketVal) {
              res = "^";
            } else if (char === GLOB_SPLIT) {
              res = "";
            } else {
              res = escapeRegExpCharacters(char);
            }
            bracketVal += res;
            continue;
          }
          switch (char) {
            case "{":
              inBraces = true;
              continue;
            case "[":
              inBrackets = true;
              continue;
            case "}": {
              const choices = splitGlobAware(braceVal, ",");
              const braceRegExp = `(?:${choices.map((choice) => parseRegExp(choice)).join("|")})`;
              regEx += braceRegExp;
              inBraces = false;
              braceVal = "";
              break;
            }
            case "]": {
              regEx += "[" + bracketVal + "]";
              inBrackets = false;
              bracketVal = "";
              break;
            }
            case "?":
              regEx += NO_PATH_REGEX;
              continue;
            case "*":
              regEx += starsToRegExp(1);
              continue;
            default:
              regEx += escapeRegExpCharacters(char);
          }
        }
        if (index < segments.length - 1 && // more segments to come after this
        (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...
        index + 2 < segments.length)) {
          regEx += PATH_REGEX;
        }
      }
      previousSegmentWasGlobStar = segment === GLOBSTAR;
    });
  }
  return regEx;
}
var T1 = /^\*\*\/\*\.[\w\.-]+$/;
var T2 = /^\*\*\/([\w\.-]+)\/?$/;
var T3 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/;
var T3_2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/;
var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/;
var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/;
var CACHE = new LRUCache(1e4);
var FALSE = function() {
  return false;
};
var NULL = function() {
  return null;
};
function parsePattern(arg1, options2) {
  if (!arg1) {
    return NULL;
  }
  let pattern;
  if (typeof arg1 !== "string") {
    pattern = arg1.pattern;
  } else {
    pattern = arg1;
  }
  pattern = pattern.trim();
  const ignoreCase = options2.ignoreCase ?? false;
  const internalOptions = {
    ...options2,
    equals: ignoreCase ? equalsIgnoreCase : (a, b) => a === b,
    endsWith: ignoreCase ? endsWithIgnoreCase : (str, candidate) => str.endsWith(candidate),
    // TODO: the '!isLinux' part below is to keep current behavior unchanged, but it should probably be removed
    // in favor of passing correct options from the caller.
    isEqualOrParent: (base, candidate) => isEqualOrParent(base, candidate, !isLinux || ignoreCase)
  };
  const patternKey = `${ignoreCase ? pattern.toLowerCase() : pattern}_${!!options2.trimForExclusions}_${ignoreCase}`;
  let parsedPattern = CACHE.get(patternKey);
  if (parsedPattern) {
    return wrapRelativePattern(parsedPattern, arg1, internalOptions);
  }
  let match2;
  if (T1.test(pattern)) {
    parsedPattern = trivia1(pattern.substring(4), pattern, internalOptions);
  } else if (match2 = T2.exec(trimForExclusions(pattern, internalOptions))) {
    parsedPattern = trivia2(match2[1], pattern, internalOptions);
  } else if ((options2.trimForExclusions ? T3_2 : T3).test(pattern)) {
    parsedPattern = trivia3(pattern, internalOptions);
  } else if (match2 = T4.exec(trimForExclusions(pattern, internalOptions))) {
    parsedPattern = trivia4and5(match2[1].substring(1), pattern, true, internalOptions);
  } else if (match2 = T5.exec(trimForExclusions(pattern, internalOptions))) {
    parsedPattern = trivia4and5(match2[1], pattern, false, internalOptions);
  } else {
    parsedPattern = toRegExp(pattern, internalOptions);
  }
  CACHE.set(patternKey, parsedPattern);
  return wrapRelativePattern(parsedPattern, arg1, internalOptions);
}
function wrapRelativePattern(parsedPattern, arg2, options2) {
  if (typeof arg2 === "string") {
    return parsedPattern;
  }
  const wrappedPattern = function(path, basename3) {
    if (!options2.isEqualOrParent(path, arg2.base)) {
      return null;
    }
    return parsedPattern(ltrim(path.substring(arg2.base.length), sep), basename3);
  };
  wrappedPattern.allBasenames = parsedPattern.allBasenames;
  wrappedPattern.allPaths = parsedPattern.allPaths;
  wrappedPattern.basenames = parsedPattern.basenames;
  wrappedPattern.patterns = parsedPattern.patterns;
  return wrappedPattern;
}
function trimForExclusions(pattern, options2) {
  return options2.trimForExclusions && pattern.endsWith("/**") ? pattern.substring(0, pattern.length - 2) : pattern;
}
function trivia1(base, pattern, options2) {
  return function(path, basename3) {
    return typeof path === "string" && options2.endsWith(path, base) ? pattern : null;
  };
}
function trivia2(base, pattern, options2) {
  const slashBase = `/${base}`;
  const backslashBase = `\\${base}`;
  const parsedPattern = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (basename3) {
      return options2.equals(basename3, base) ? pattern : null;
    }
    return options2.equals(path, base) || options2.endsWith(path, slashBase) || options2.endsWith(path, backslashBase) ? pattern : null;
  };
  const basenames = [base];
  parsedPattern.basenames = basenames;
  parsedPattern.patterns = [pattern];
  parsedPattern.allBasenames = basenames;
  return parsedPattern;
}
function trivia3(pattern, options2) {
  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(",").map((pattern2) => parsePattern(pattern2, options2)).filter((pattern2) => pattern2 !== NULL), pattern);
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (patternsLength === 1) {
    return parsedPatterns[0];
  }
  const parsedPattern = function(path, basename3) {
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      if (parsedPatterns[i](path, basename3)) {
        return pattern;
      }
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern2) => !!pattern2.allBasenames);
  if (withBasenames) {
    parsedPattern.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    parsedPattern.allPaths = allPaths;
  }
  return parsedPattern;
}
function trivia4and5(targetPath, pattern, matchPathEnds, options2) {
  const usingPosixSep = sep === posix.sep;
  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);
  const nativePathEnd = sep + nativePath;
  const targetPathEnd = posix.sep + targetPath;
  let parsedPattern;
  if (matchPathEnds) {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (options2.equals(path, nativePath) || options2.endsWith(path, nativePathEnd) || !usingPosixSep && (options2.equals(path, targetPath) || options2.endsWith(path, targetPathEnd))) ? pattern : null;
    };
  } else {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (options2.equals(path, nativePath) || !usingPosixSep && options2.equals(path, targetPath)) ? pattern : null;
    };
  }
  parsedPattern.allPaths = [(matchPathEnds ? "*/" : "./") + targetPath];
  return parsedPattern;
}
function toRegExp(pattern, options2) {
  try {
    const regExp = new RegExp(`^${parseRegExp(pattern)}$`, options2.ignoreCase ? "i" : void 0);
    return function(path) {
      regExp.lastIndex = 0;
      return typeof path === "string" && regExp.test(path) ? pattern : null;
    };
  } catch {
    return NULL;
  }
}
function match(arg1, path, options2) {
  if (!arg1 || typeof path !== "string") {
    return false;
  }
  return parse3(arg1, options2)(path);
}
function parse3(arg1, options2 = {}) {
  if (!arg1) {
    return FALSE;
  }
  if (typeof arg1 === "string" || isRelativePattern(arg1)) {
    const parsedPattern = parsePattern(arg1, options2);
    if (parsedPattern === NULL) {
      return FALSE;
    }
    const resultPattern = function(path, basename3) {
      return !!parsedPattern(path, basename3);
    };
    if (parsedPattern.allBasenames) {
      resultPattern.allBasenames = parsedPattern.allBasenames;
    }
    if (parsedPattern.allPaths) {
      resultPattern.allPaths = parsedPattern.allPaths;
    }
    return resultPattern;
  }
  return parsedExpression(arg1, options2);
}
function isRelativePattern(obj) {
  const rp = obj;
  if (!rp) {
    return false;
  }
  return typeof rp.base === "string" && typeof rp.pattern === "string";
}
function parsedExpression(expression, options2) {
  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map((pattern) => parseExpressionPattern(pattern, expression[pattern], options2)).filter((pattern) => pattern !== NULL));
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (!parsedPatterns.some((parsedPattern) => !!parsedPattern.requiresSiblings)) {
    if (patternsLength === 1) {
      return parsedPatterns[0];
    }
    const resultExpression2 = function(path, basename3) {
      let resultPromises = void 0;
      for (let i = 0, n = parsedPatterns.length; i < n; i++) {
        const result = parsedPatterns[i](path, basename3);
        if (typeof result === "string") {
          return result;
        }
        if (isThenable(result)) {
          if (!resultPromises) {
            resultPromises = [];
          }
          resultPromises.push(result);
        }
      }
      if (resultPromises) {
        return (async () => {
          for (const resultPromise of resultPromises) {
            const result = await resultPromise;
            if (typeof result === "string") {
              return result;
            }
          }
          return null;
        })();
      }
      return null;
    };
    const withBasenames2 = parsedPatterns.find((pattern) => !!pattern.allBasenames);
    if (withBasenames2) {
      resultExpression2.allBasenames = withBasenames2.allBasenames;
    }
    const allPaths2 = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths2.length) {
      resultExpression2.allPaths = allPaths2;
    }
    return resultExpression2;
  }
  const resultExpression = function(path, base, hasSibling) {
    let name2 = void 0;
    let resultPromises = void 0;
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      const parsedPattern = parsedPatterns[i];
      if (parsedPattern.requiresSiblings && hasSibling) {
        if (!base) {
          base = basename(path);
        }
        if (!name2) {
          name2 = base.substring(0, base.length - extname(path).length);
        }
      }
      const result = parsedPattern(path, base, name2, hasSibling);
      if (typeof result === "string") {
        return result;
      }
      if (isThenable(result)) {
        if (!resultPromises) {
          resultPromises = [];
        }
        resultPromises.push(result);
      }
    }
    if (resultPromises) {
      return (async () => {
        for (const resultPromise of resultPromises) {
          const result = await resultPromise;
          if (typeof result === "string") {
            return result;
          }
        }
        return null;
      })();
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern) => !!pattern.allBasenames);
  if (withBasenames) {
    resultExpression.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    resultExpression.allPaths = allPaths;
  }
  return resultExpression;
}
function parseExpressionPattern(pattern, value, options2) {
  if (value === false) {
    return NULL;
  }
  const parsedPattern = parsePattern(pattern, options2);
  if (parsedPattern === NULL) {
    return NULL;
  }
  if (typeof value === "boolean") {
    return parsedPattern;
  }
  if (value) {
    const when = value.when;
    if (typeof when === "string") {
      const result = (path, basename3, name2, hasSibling) => {
        if (!hasSibling || !parsedPattern(path, basename3)) {
          return null;
        }
        const clausePattern = when.replace("$(basename)", () => name2);
        const matched = hasSibling(clausePattern);
        return isThenable(matched) ? matched.then((match2) => match2 ? pattern : null) : matched ? pattern : null;
      };
      result.requiresSiblings = true;
      return result;
    }
  }
  return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
  const basenamePatterns = parsedPatterns.filter((parsedPattern) => !!parsedPattern.basenames);
  if (basenamePatterns.length < 2) {
    return parsedPatterns;
  }
  const basenames = basenamePatterns.reduce((all, current) => {
    const basenames2 = current.basenames;
    return basenames2 ? all.concat(basenames2) : all;
  }, []);
  let patterns;
  if (result) {
    patterns = [];
    for (let i = 0, n = basenames.length; i < n; i++) {
      patterns.push(result);
    }
  } else {
    patterns = basenamePatterns.reduce((all, current) => {
      const patterns2 = current.patterns;
      return patterns2 ? all.concat(patterns2) : all;
    }, []);
  }
  const aggregate = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (!basename3) {
      let i;
      for (i = path.length; i > 0; i--) {
        const ch = path.charCodeAt(i - 1);
        if (ch === 47 || ch === 92) {
          break;
        }
      }
      basename3 = path.substring(i);
    }
    const index = basenames.indexOf(basename3);
    return index !== -1 ? patterns[index] : null;
  };
  aggregate.basenames = basenames;
  aggregate.patterns = patterns;
  aggregate.allBasenames = basenames;
  const aggregatedPatterns = parsedPatterns.filter((parsedPattern) => !parsedPattern.basenames);
  aggregatedPatterns.push(aggregate);
  return aggregatedPatterns;
}

// out-build/vs/workbench/services/notebook/common/notebookDocumentService.js
var INotebookDocumentService = createDecorator("notebookDocumentService");
var _lengths = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"];
var _padRegexp = new RegExp(`^[${_lengths.join("")}]+`);
var _radix = 7;
function parse4(cell) {
  if (cell.scheme !== Schemas.vscodeNotebookCell) {
    return void 0;
  }
  const idx = cell.fragment.indexOf("s");
  if (idx < 0) {
    return void 0;
  }
  const handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ""), _radix);
  const _scheme = decodeBase64(cell.fragment.substring(idx + 1)).toString();
  if (isNaN(handle)) {
    return void 0;
  }
  return {
    handle,
    notebook: cell.with({ scheme: _scheme, fragment: null })
  };
}
function generate(notebook, handle) {
  const s = handle.toString(_radix);
  const p = s.length < _lengths.length ? _lengths[s.length - 1] : "z";
  const fragment = `${p}${s}s${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;
  return notebook.with({ scheme: Schemas.vscodeNotebookCell, fragment });
}
function parseMetadataUri(metadata) {
  if (metadata.scheme !== Schemas.vscodeNotebookMetadata) {
    return void 0;
  }
  const _scheme = decodeBase64(metadata.fragment).toString();
  return metadata.with({ scheme: _scheme, fragment: null });
}
function generateMetadataUri(notebook) {
  const fragment = `${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;
  return notebook.with({ scheme: Schemas.vscodeNotebookMetadata, fragment });
}
function extractCellOutputDetails(uri) {
  if (uri.scheme !== Schemas.vscodeNotebookCellOutput) {
    return;
  }
  const params = new URLSearchParams(uri.query);
  const openIn = params.get("openIn");
  if (!openIn) {
    return;
  }
  const outputId = params.get("outputId") ?? void 0;
  const parsedCell = parse4(uri.with({ scheme: Schemas.vscodeNotebookCell, query: null }));
  const outputIndex = params.get("outputIndex") ? parseInt(params.get("outputIndex") || "", 10) : void 0;
  const notebookUri = parsedCell ? parsedCell.notebook : uri.with({
    scheme: params.get("notebookScheme") || Schemas.file,
    fragment: null,
    query: null
  });
  const cellIndex = params.get("cellIndex") ? parseInt(params.get("cellIndex") || "", 10) : void 0;
  return {
    notebook: notebookUri,
    openIn,
    outputId,
    outputIndex,
    cellHandle: parsedCell?.handle,
    cellFragment: uri.fragment,
    cellIndex
  };
}
var NotebookDocumentWorkbenchService = class {
  constructor() {
    this._documents = new ResourceMap();
  }
  getNotebook(uri) {
    if (uri.scheme === Schemas.vscodeNotebookCell) {
      const cellUri = parse4(uri);
      if (cellUri) {
        const document2 = this._documents.get(cellUri.notebook);
        if (document2) {
          return document2;
        }
      }
    }
    if (uri.scheme === Schemas.vscodeNotebookCellOutput) {
      const parsedData = extractCellOutputDetails(uri);
      if (parsedData) {
        const document2 = this._documents.get(parsedData.notebook);
        if (document2) {
          return document2;
        }
      }
    }
    return this._documents.get(uri);
  }
  addNotebookDocument(document2) {
    this._documents.set(document2.uri, document2);
  }
  removeNotebookDocument(document2) {
    this._documents.delete(document2.uri);
  }
};
registerSingleton(
  INotebookDocumentService,
  NotebookDocumentWorkbenchService,
  1
  /* InstantiationType.Delayed */
);

// out-build/vs/workbench/contrib/notebook/common/notebookCommon.js
var CellKind;
(function(CellKind2) {
  CellKind2[CellKind2["Markup"] = 1] = "Markup";
  CellKind2[CellKind2["Code"] = 2] = "Code";
})(CellKind || (CellKind = {}));
var NOTEBOOK_DISPLAY_ORDER = [
  "application/json",
  "application/javascript",
  "text/html",
  "image/svg+xml",
  Mimes.latex,
  Mimes.markdown,
  "image/png",
  "image/jpeg",
  Mimes.text
];
var ACCESSIBLE_NOTEBOOK_DISPLAY_ORDER = [
  Mimes.latex,
  Mimes.markdown,
  "application/json",
  "text/html",
  "image/svg+xml",
  "image/png",
  "image/jpeg",
  Mimes.text
];
var NotebookRunState;
(function(NotebookRunState2) {
  NotebookRunState2[NotebookRunState2["Running"] = 1] = "Running";
  NotebookRunState2[NotebookRunState2["Idle"] = 2] = "Idle";
})(NotebookRunState || (NotebookRunState = {}));
var NotebookCellExecutionState;
(function(NotebookCellExecutionState3) {
  NotebookCellExecutionState3[NotebookCellExecutionState3["Unconfirmed"] = 1] = "Unconfirmed";
  NotebookCellExecutionState3[NotebookCellExecutionState3["Pending"] = 2] = "Pending";
  NotebookCellExecutionState3[NotebookCellExecutionState3["Executing"] = 3] = "Executing";
})(NotebookCellExecutionState || (NotebookCellExecutionState = {}));
var NotebookExecutionState;
(function(NotebookExecutionState2) {
  NotebookExecutionState2[NotebookExecutionState2["Unconfirmed"] = 1] = "Unconfirmed";
  NotebookExecutionState2[NotebookExecutionState2["Pending"] = 2] = "Pending";
  NotebookExecutionState2[NotebookExecutionState2["Executing"] = 3] = "Executing";
})(NotebookExecutionState || (NotebookExecutionState = {}));
var NotebookRendererMatch;
(function(NotebookRendererMatch2) {
  NotebookRendererMatch2[NotebookRendererMatch2["WithHardKernelDependency"] = 0] = "WithHardKernelDependency";
  NotebookRendererMatch2[NotebookRendererMatch2["WithOptionalKernelDependency"] = 1] = "WithOptionalKernelDependency";
  NotebookRendererMatch2[NotebookRendererMatch2["Pure"] = 2] = "Pure";
  NotebookRendererMatch2[NotebookRendererMatch2["Never"] = 3] = "Never";
})(NotebookRendererMatch || (NotebookRendererMatch = {}));
var RendererMessagingSpec;
(function(RendererMessagingSpec2) {
  RendererMessagingSpec2["Always"] = "always";
  RendererMessagingSpec2["Never"] = "never";
  RendererMessagingSpec2["Optional"] = "optional";
})(RendererMessagingSpec || (RendererMessagingSpec = {}));
var NotebookCellsChangeType;
(function(NotebookCellsChangeType2) {
  NotebookCellsChangeType2[NotebookCellsChangeType2["ModelChange"] = 1] = "ModelChange";
  NotebookCellsChangeType2[NotebookCellsChangeType2["Move"] = 2] = "Move";
  NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellLanguage"] = 5] = "ChangeCellLanguage";
  NotebookCellsChangeType2[NotebookCellsChangeType2["Initialize"] = 6] = "Initialize";
  NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellMetadata"] = 7] = "ChangeCellMetadata";
  NotebookCellsChangeType2[NotebookCellsChangeType2["Output"] = 8] = "Output";
  NotebookCellsChangeType2[NotebookCellsChangeType2["OutputItem"] = 9] = "OutputItem";
  NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellContent"] = 10] = "ChangeCellContent";
  NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeDocumentMetadata"] = 11] = "ChangeDocumentMetadata";
  NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellInternalMetadata"] = 12] = "ChangeCellInternalMetadata";
  NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellMime"] = 13] = "ChangeCellMime";
  NotebookCellsChangeType2[NotebookCellsChangeType2["Unknown"] = 100] = "Unknown";
})(NotebookCellsChangeType || (NotebookCellsChangeType = {}));
var SelectionStateType;
(function(SelectionStateType2) {
  SelectionStateType2[SelectionStateType2["Handle"] = 0] = "Handle";
  SelectionStateType2[SelectionStateType2["Index"] = 1] = "Index";
})(SelectionStateType || (SelectionStateType = {}));
var CellEditType;
(function(CellEditType2) {
  CellEditType2[CellEditType2["Replace"] = 1] = "Replace";
  CellEditType2[CellEditType2["Output"] = 2] = "Output";
  CellEditType2[CellEditType2["Metadata"] = 3] = "Metadata";
  CellEditType2[CellEditType2["CellLanguage"] = 4] = "CellLanguage";
  CellEditType2[CellEditType2["DocumentMetadata"] = 5] = "DocumentMetadata";
  CellEditType2[CellEditType2["Move"] = 6] = "Move";
  CellEditType2[CellEditType2["OutputItems"] = 7] = "OutputItems";
  CellEditType2[CellEditType2["PartialMetadata"] = 8] = "PartialMetadata";
  CellEditType2[CellEditType2["PartialInternalMetadata"] = 9] = "PartialInternalMetadata";
})(CellEditType || (CellEditType = {}));
var NotebookMetadataUri;
(function(NotebookMetadataUri2) {
  NotebookMetadataUri2.scheme = Schemas.vscodeNotebookMetadata;
  function generate2(notebook) {
    return generateMetadataUri(notebook);
  }
  NotebookMetadataUri2.generate = generate2;
  function parse6(metadata) {
    return parseMetadataUri(metadata);
  }
  NotebookMetadataUri2.parse = parse6;
})(NotebookMetadataUri || (NotebookMetadataUri = {}));
var CellUri;
(function(CellUri2) {
  CellUri2.scheme = Schemas.vscodeNotebookCell;
  function generate2(notebook, handle) {
    return generate(notebook, handle);
  }
  CellUri2.generate = generate2;
  function parse6(cell) {
    return parse4(cell);
  }
  CellUri2.parse = parse6;
  function generateCellOutputUriWithId(notebook, outputId) {
    return notebook.with({
      scheme: Schemas.vscodeNotebookCellOutput,
      query: new URLSearchParams({
        openIn: "editor",
        outputId: outputId ?? "",
        notebookScheme: notebook.scheme !== Schemas.file ? notebook.scheme : ""
      }).toString()
    });
  }
  CellUri2.generateCellOutputUriWithId = generateCellOutputUriWithId;
  function generateCellOutputUriWithIndex(notebook, cellUri, outputIndex) {
    return notebook.with({
      scheme: Schemas.vscodeNotebookCellOutput,
      fragment: cellUri.fragment,
      query: new URLSearchParams({
        openIn: "notebook",
        outputIndex: String(outputIndex)
      }).toString()
    });
  }
  CellUri2.generateCellOutputUriWithIndex = generateCellOutputUriWithIndex;
  function generateOutputEditorUri(notebook, cellId, cellIndex, outputId, outputIndex) {
    return notebook.with({
      scheme: Schemas.vscodeNotebookCellOutput,
      query: new URLSearchParams({
        openIn: "notebookOutputEditor",
        notebook: notebook.toString(),
        cellIndex: String(cellIndex),
        outputId,
        outputIndex: String(outputIndex)
      }).toString()
    });
  }
  CellUri2.generateOutputEditorUri = generateOutputEditorUri;
  function parseCellOutputUri(uri) {
    return extractCellOutputDetails(uri);
  }
  CellUri2.parseCellOutputUri = parseCellOutputUri;
  function generateCellPropertyUri(notebook, handle, scheme) {
    return CellUri2.generate(notebook, handle).with({ scheme });
  }
  CellUri2.generateCellPropertyUri = generateCellPropertyUri;
  function parseCellPropertyUri(uri, propertyScheme) {
    if (uri.scheme !== propertyScheme) {
      return void 0;
    }
    return CellUri2.parse(uri.with({ scheme: CellUri2.scheme }));
  }
  CellUri2.parseCellPropertyUri = parseCellPropertyUri;
})(CellUri || (CellUri = {}));
var NOTEBOOK_EDITOR_CURSOR_BOUNDARY = new RawContextKey("notebookEditorCursorAtBoundary", "none");
var NOTEBOOK_EDITOR_CURSOR_LINE_BOUNDARY = new RawContextKey("notebookEditorCursorAtLineBoundary", "none");
var NotebookEditorPriority;
(function(NotebookEditorPriority2) {
  NotebookEditorPriority2["default"] = "default";
  NotebookEditorPriority2["option"] = "option";
})(NotebookEditorPriority || (NotebookEditorPriority = {}));
var NotebookFindScopeType;
(function(NotebookFindScopeType2) {
  NotebookFindScopeType2["Cells"] = "cells";
  NotebookFindScopeType2["Text"] = "text";
  NotebookFindScopeType2["None"] = "none";
})(NotebookFindScopeType || (NotebookFindScopeType = {}));
var CellStatusbarAlignment;
(function(CellStatusbarAlignment2) {
  CellStatusbarAlignment2[CellStatusbarAlignment2["Left"] = 1] = "Left";
  CellStatusbarAlignment2[CellStatusbarAlignment2["Right"] = 2] = "Right";
})(CellStatusbarAlignment || (CellStatusbarAlignment = {}));
var NotebookWorkingCopyTypeIdentifier = class _NotebookWorkingCopyTypeIdentifier {
  static {
    this._prefix = "notebook/";
  }
  static create(notebookType, viewType) {
    return `${_NotebookWorkingCopyTypeIdentifier._prefix}${notebookType}/${viewType ?? notebookType}`;
  }
  static parse(candidate) {
    if (candidate.startsWith(_NotebookWorkingCopyTypeIdentifier._prefix)) {
      const split = candidate.substring(_NotebookWorkingCopyTypeIdentifier._prefix.length).split("/");
      if (split.length === 2) {
        return { notebookType: split[0], viewType: split[1] };
      }
    }
    return void 0;
  }
};
var textDecoder2 = new TextDecoder();
function compressOutputItemStreams(outputs) {
  const buffers = [];
  let startAppending = false;
  for (const output of outputs) {
    if (buffers.length === 0 || startAppending) {
      buffers.push(output);
      startAppending = true;
    }
  }
  let didCompression = compressStreamBuffer(buffers);
  const concatenated = VSBuffer.concat(buffers.map((buffer) => VSBuffer.wrap(buffer)));
  const data2 = formatStreamText(concatenated);
  didCompression = didCompression || data2.byteLength !== concatenated.byteLength;
  return { data: data2, didCompression };
}
var MOVE_CURSOR_1_LINE_COMMAND = `${String.fromCharCode(27)}[A`;
var MOVE_CURSOR_1_LINE_COMMAND_BYTES = MOVE_CURSOR_1_LINE_COMMAND.split("").map((c) => c.charCodeAt(0));
var LINE_FEED = 10;
function compressStreamBuffer(streams) {
  let didCompress = false;
  streams.forEach((stream, index) => {
    if (index === 0 || stream.length < MOVE_CURSOR_1_LINE_COMMAND.length) {
      return;
    }
    const previousStream = streams[index - 1];
    const command = stream.subarray(0, MOVE_CURSOR_1_LINE_COMMAND.length);
    if (command[0] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[0] && command[1] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[1] && command[2] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[2]) {
      const lastIndexOfLineFeed = previousStream.lastIndexOf(LINE_FEED);
      if (lastIndexOfLineFeed === -1) {
        return;
      }
      didCompress = true;
      streams[index - 1] = previousStream.subarray(0, lastIndexOfLineFeed);
      streams[index] = stream.subarray(MOVE_CURSOR_1_LINE_COMMAND.length);
    }
  });
  return didCompress;
}
function fixBackspace(txt) {
  let tmp = txt;
  do {
    txt = tmp;
    tmp = txt.replace(/[^\n]\x08/gm, "");
  } while (tmp.length < txt.length);
  return txt;
}
function fixCarriageReturn(txt) {
  txt = txt.replace(/\r+\n/gm, "\n");
  while (txt.search(/\r[^$]/g) > -1) {
    const base = txt.match(/^(.*)\r+/m)[1];
    let insert = txt.match(/\r+(.*)$/m)[1];
    insert = insert + base.slice(insert.length, base.length);
    txt = txt.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, insert);
  }
  return txt;
}
var BACKSPACE_CHARACTER = "\b".charCodeAt(0);
var CARRIAGE_RETURN_CHARACTER = "\r".charCodeAt(0);
function formatStreamText(buffer) {
  if (!buffer.buffer.includes(BACKSPACE_CHARACTER) && !buffer.buffer.includes(CARRIAGE_RETURN_CHARACTER)) {
    return buffer;
  }
  return VSBuffer.fromString(fixCarriageReturn(fixBackspace(textDecoder2.decode(buffer.buffer))));
}

// out-build/vs/workbench/contrib/testing/common/testId.js
var TestIdPathParts;
(function(TestIdPathParts2) {
  TestIdPathParts2["Delimiter"] = "\0";
})(TestIdPathParts || (TestIdPathParts = {}));
var TestPosition;
(function(TestPosition2) {
  TestPosition2[TestPosition2["IsSame"] = 0] = "IsSame";
  TestPosition2[TestPosition2["Disconnected"] = 1] = "Disconnected";
  TestPosition2[TestPosition2["IsChild"] = 2] = "IsChild";
  TestPosition2[TestPosition2["IsParent"] = 3] = "IsParent";
})(TestPosition || (TestPosition = {}));
var TestId = class _TestId {
  /**
   * Creates a test ID from an ext host test item.
   */
  static fromExtHostTestItem(item, rootId, parent = item.parent) {
    if (item._isRoot) {
      return new _TestId([rootId]);
    }
    const path = [item.id];
    for (let i = parent; i && i.id !== rootId; i = i.parent) {
      path.push(i.id);
    }
    path.push(rootId);
    return new _TestId(path.reverse());
  }
  /**
   * Cheaply ets whether the ID refers to the root .
   */
  static isRoot(idString) {
    return !idString.includes(
      "\0"
      /* TestIdPathParts.Delimiter */
    );
  }
  /**
   * Cheaply gets whether the ID refers to the root .
   */
  static root(idString) {
    const idx = idString.indexOf(
      "\0"
      /* TestIdPathParts.Delimiter */
    );
    return idx === -1 ? idString : idString.slice(0, idx);
  }
  /**
   * Creates a test ID from a serialized TestId instance.
   */
  static fromString(idString) {
    return new _TestId(idString.split(
      "\0"
      /* TestIdPathParts.Delimiter */
    ));
  }
  /**
   * Gets the ID resulting from adding b to the base ID.
   */
  static join(base, b) {
    return new _TestId([...base.path, b]);
  }
  /**
   * Splits a test ID into its parts.
   */
  static split(idString) {
    return idString.split(
      "\0"
      /* TestIdPathParts.Delimiter */
    );
  }
  /**
   * Gets the string ID resulting from adding b to the base ID.
   */
  static joinToString(base, b) {
    return base.toString() + "\0" + b;
  }
  /**
   * Cheaply gets the parent ID of a test identified with the string.
   */
  static parentId(idString) {
    const idx = idString.lastIndexOf(
      "\0"
      /* TestIdPathParts.Delimiter */
    );
    return idx === -1 ? void 0 : idString.slice(0, idx);
  }
  /**
   * Cheaply gets the local ID of a test identified with the string.
   */
  static localId(idString) {
    const idx = idString.lastIndexOf(
      "\0"
      /* TestIdPathParts.Delimiter */
    );
    return idx === -1 ? idString : idString.slice(idx + "\0".length);
  }
  /**
   * Gets whether maybeChild is a child of maybeParent.
   * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better
   */
  static isChild(maybeParent, maybeChild) {
    return maybeChild[maybeParent.length] === "\0" && maybeChild.startsWith(maybeParent);
  }
  /**
   * Compares the position of the two ID strings.
   * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better
   */
  static compare(a, b) {
    if (a === b) {
      return 0;
    }
    if (_TestId.isChild(a, b)) {
      return 2;
    }
    if (_TestId.isChild(b, a)) {
      return 3;
    }
    return 1;
  }
  static getLengthOfCommonPrefix(length, getId) {
    if (length === 0) {
      return 0;
    }
    let commonPrefix = 0;
    while (commonPrefix < length - 1) {
      for (let i = 1; i < length; i++) {
        const a = getId(i - 1);
        const b = getId(i);
        if (a.path[commonPrefix] !== b.path[commonPrefix]) {
          return commonPrefix;
        }
      }
      commonPrefix++;
    }
    return commonPrefix;
  }
  constructor(path, viewEnd = path.length) {
    this.path = path;
    this.viewEnd = viewEnd;
    if (path.length === 0 || viewEnd < 1) {
      throw new Error("cannot create test with empty path");
    }
  }
  /**
   * Gets the ID of the parent test.
   */
  get rootId() {
    return new _TestId(this.path, 1);
  }
  /**
   * Gets the ID of the parent test.
   */
  get parentId() {
    return this.viewEnd > 1 ? new _TestId(this.path, this.viewEnd - 1) : void 0;
  }
  /**
   * Gets the local ID of the current full test ID.
   */
  get localId() {
    return this.path[this.viewEnd - 1];
  }
  /**
   * Gets whether this ID refers to the root.
   */
  get controllerId() {
    return this.path[0];
  }
  /**
   * Gets whether this ID refers to the root.
   */
  get isRoot() {
    return this.viewEnd === 1;
  }
  /**
   * Returns an iterable that yields IDs of all parent items down to and
   * including the current item.
   */
  *idsFromRoot() {
    for (let i = 1; i <= this.viewEnd; i++) {
      yield new _TestId(this.path, i);
    }
  }
  /**
   * Returns an iterable that yields IDs of the current item up to the root
   * item.
   */
  *idsToRoot() {
    for (let i = this.viewEnd; i > 0; i--) {
      yield new _TestId(this.path, i);
    }
  }
  /**
   * Compares the other test ID with this one.
   */
  compare(other) {
    if (typeof other === "string") {
      return _TestId.compare(this.toString(), other);
    }
    for (let i = 0; i < other.viewEnd && i < this.viewEnd; i++) {
      if (other.path[i] !== this.path[i]) {
        return 1;
      }
    }
    if (other.viewEnd > this.viewEnd) {
      return 2;
    }
    if (other.viewEnd < this.viewEnd) {
      return 3;
    }
    return 0;
  }
  /**
   * Serializes the ID.
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Serializes the ID to a string.
   */
  toString() {
    if (!this.stringifed) {
      this.stringifed = this.path[0];
      for (let i = 1; i < this.viewEnd; i++) {
        this.stringifed += "\0";
        this.stringifed += this.path[i];
      }
    }
    return this.stringifed;
  }
};

// out-build/vs/workbench/contrib/testing/common/testTypes.js
var TestResultState;
(function(TestResultState3) {
  TestResultState3[TestResultState3["Unset"] = 0] = "Unset";
  TestResultState3[TestResultState3["Queued"] = 1] = "Queued";
  TestResultState3[TestResultState3["Running"] = 2] = "Running";
  TestResultState3[TestResultState3["Passed"] = 3] = "Passed";
  TestResultState3[TestResultState3["Failed"] = 4] = "Failed";
  TestResultState3[TestResultState3["Skipped"] = 5] = "Skipped";
  TestResultState3[TestResultState3["Errored"] = 6] = "Errored";
})(TestResultState || (TestResultState = {}));
var ExtTestRunProfileKind;
(function(ExtTestRunProfileKind2) {
  ExtTestRunProfileKind2[ExtTestRunProfileKind2["Run"] = 1] = "Run";
  ExtTestRunProfileKind2[ExtTestRunProfileKind2["Debug"] = 2] = "Debug";
  ExtTestRunProfileKind2[ExtTestRunProfileKind2["Coverage"] = 3] = "Coverage";
})(ExtTestRunProfileKind || (ExtTestRunProfileKind = {}));
var TestControllerCapability;
(function(TestControllerCapability2) {
  TestControllerCapability2[TestControllerCapability2["Refresh"] = 2] = "Refresh";
  TestControllerCapability2[TestControllerCapability2["CodeRelatedToTest"] = 4] = "CodeRelatedToTest";
  TestControllerCapability2[TestControllerCapability2["TestRelatedToCode"] = 8] = "TestRelatedToCode";
})(TestControllerCapability || (TestControllerCapability = {}));
var TestRunProfileBitset;
(function(TestRunProfileBitset2) {
  TestRunProfileBitset2[TestRunProfileBitset2["Run"] = 2] = "Run";
  TestRunProfileBitset2[TestRunProfileBitset2["Debug"] = 4] = "Debug";
  TestRunProfileBitset2[TestRunProfileBitset2["Coverage"] = 8] = "Coverage";
  TestRunProfileBitset2[TestRunProfileBitset2["HasNonDefaultProfile"] = 16] = "HasNonDefaultProfile";
  TestRunProfileBitset2[TestRunProfileBitset2["HasConfigurable"] = 32] = "HasConfigurable";
  TestRunProfileBitset2[TestRunProfileBitset2["SupportsContinuousRun"] = 64] = "SupportsContinuousRun";
})(TestRunProfileBitset || (TestRunProfileBitset = {}));
var testProfileBitset = {
  [
    2
    /* TestRunProfileBitset.Run */
  ]: localize(13862, null),
  [
    4
    /* TestRunProfileBitset.Debug */
  ]: localize(13863, null),
  [
    8
    /* TestRunProfileBitset.Coverage */
  ]: localize(13864, null)
};
var isStartControllerTests = (t) => "runId" in t;
var IRichLocation;
(function(IRichLocation2) {
  IRichLocation2.serialize = (location2) => ({
    range: location2.range.toJSON(),
    uri: location2.uri.toJSON()
  });
  IRichLocation2.deserialize = (uriIdentity, location2) => ({
    range: Range.lift(location2.range),
    uri: uriIdentity.asCanonicalUri(URI.revive(location2.uri))
  });
})(IRichLocation || (IRichLocation = {}));
var TestMessageType;
(function(TestMessageType2) {
  TestMessageType2[TestMessageType2["Error"] = 0] = "Error";
  TestMessageType2[TestMessageType2["Output"] = 1] = "Output";
})(TestMessageType || (TestMessageType = {}));
var ITestMessageStackFrame;
(function(ITestMessageStackFrame2) {
  ITestMessageStackFrame2.serialize = (stack) => ({
    label: stack.label,
    uri: stack.uri?.toJSON(),
    position: stack.position?.toJSON()
  });
  ITestMessageStackFrame2.deserialize = (uriIdentity, stack) => ({
    label: stack.label,
    uri: stack.uri ? uriIdentity.asCanonicalUri(URI.revive(stack.uri)) : void 0,
    position: stack.position ? Position.lift(stack.position) : void 0
  });
})(ITestMessageStackFrame || (ITestMessageStackFrame = {}));
var ITestErrorMessage;
(function(ITestErrorMessage2) {
  ITestErrorMessage2.serialize = (message) => ({
    message: message.message,
    type: 0,
    expected: message.expected,
    actual: message.actual,
    contextValue: message.contextValue,
    location: message.location && IRichLocation.serialize(message.location),
    stackTrace: message.stackTrace?.map(ITestMessageStackFrame.serialize)
  });
  ITestErrorMessage2.deserialize = (uriIdentity, message) => ({
    message: message.message,
    type: 0,
    expected: message.expected,
    actual: message.actual,
    contextValue: message.contextValue,
    location: message.location && IRichLocation.deserialize(uriIdentity, message.location),
    stackTrace: message.stackTrace && message.stackTrace.map((s) => ITestMessageStackFrame.deserialize(uriIdentity, s))
  });
})(ITestErrorMessage || (ITestErrorMessage = {}));
var ITestOutputMessage;
(function(ITestOutputMessage2) {
  ITestOutputMessage2.serialize = (message) => ({
    message: message.message,
    type: 1,
    offset: message.offset,
    length: message.length,
    location: message.location && IRichLocation.serialize(message.location)
  });
  ITestOutputMessage2.deserialize = (uriIdentity, message) => ({
    message: message.message,
    type: 1,
    offset: message.offset,
    length: message.length,
    location: message.location && IRichLocation.deserialize(uriIdentity, message.location)
  });
})(ITestOutputMessage || (ITestOutputMessage = {}));
var ITestMessage;
(function(ITestMessage2) {
  ITestMessage2.serialize = (message) => message.type === 0 ? ITestErrorMessage.serialize(message) : ITestOutputMessage.serialize(message);
  ITestMessage2.deserialize = (uriIdentity, message) => message.type === 0 ? ITestErrorMessage.deserialize(uriIdentity, message) : ITestOutputMessage.deserialize(uriIdentity, message);
  ITestMessage2.isDiffable = (message) => message.type === 0 && message.actual !== void 0 && message.expected !== void 0;
})(ITestMessage || (ITestMessage = {}));
var ITestTaskState;
(function(ITestTaskState2) {
  ITestTaskState2.serializeWithoutMessages = (state) => ({
    state: state.state,
    duration: state.duration,
    messages: []
  });
  ITestTaskState2.serialize = (state) => ({
    state: state.state,
    duration: state.duration,
    messages: state.messages.map(ITestMessage.serialize)
  });
  ITestTaskState2.deserialize = (uriIdentity, state) => ({
    state: state.state,
    duration: state.duration,
    messages: state.messages.map((m) => ITestMessage.deserialize(uriIdentity, m))
  });
})(ITestTaskState || (ITestTaskState = {}));
var testTagDelimiter = "\0";
var namespaceTestTag = (ctrlId, tagId) => ctrlId + testTagDelimiter + tagId;
var denamespaceTestTag = (namespaced) => {
  const index = namespaced.indexOf(testTagDelimiter);
  return { ctrlId: namespaced.slice(0, index), tagId: namespaced.slice(index + 1) };
};
var ITestItem;
(function(ITestItem2) {
  ITestItem2.serialize = (item) => ({
    extId: item.extId,
    label: item.label,
    tags: item.tags,
    busy: item.busy,
    children: void 0,
    uri: item.uri?.toJSON(),
    range: item.range?.toJSON() || null,
    description: item.description,
    error: item.error,
    sortText: item.sortText
  });
  ITestItem2.deserialize = (uriIdentity, serialized) => ({
    extId: serialized.extId,
    label: serialized.label,
    tags: serialized.tags,
    busy: serialized.busy,
    children: void 0,
    uri: serialized.uri ? uriIdentity.asCanonicalUri(URI.revive(serialized.uri)) : void 0,
    range: serialized.range ? Range.lift(serialized.range) : null,
    description: serialized.description,
    error: serialized.error,
    sortText: serialized.sortText
  });
})(ITestItem || (ITestItem = {}));
var TestItemExpandState;
(function(TestItemExpandState2) {
  TestItemExpandState2[TestItemExpandState2["NotExpandable"] = 0] = "NotExpandable";
  TestItemExpandState2[TestItemExpandState2["Expandable"] = 1] = "Expandable";
  TestItemExpandState2[TestItemExpandState2["BusyExpanding"] = 2] = "BusyExpanding";
  TestItemExpandState2[TestItemExpandState2["Expanded"] = 3] = "Expanded";
})(TestItemExpandState || (TestItemExpandState = {}));
var InternalTestItem;
(function(InternalTestItem2) {
  InternalTestItem2.serialize = (item) => ({
    expand: item.expand,
    item: ITestItem.serialize(item.item)
  });
  InternalTestItem2.deserialize = (uriIdentity, serialized) => ({
    // the `controllerId` is derived from the test.item.extId. It's redundant
    // in the non-serialized InternalTestItem too, but there just because it's
    // checked against in many hot paths.
    controllerId: TestId.root(serialized.item.extId),
    expand: serialized.expand,
    item: ITestItem.deserialize(uriIdentity, serialized.item)
  });
})(InternalTestItem || (InternalTestItem = {}));
var ITestItemUpdate;
(function(ITestItemUpdate2) {
  ITestItemUpdate2.serialize = (u) => {
    let item;
    if (u.item) {
      item = {};
      if (u.item.label !== void 0) {
        item.label = u.item.label;
      }
      if (u.item.tags !== void 0) {
        item.tags = u.item.tags;
      }
      if (u.item.busy !== void 0) {
        item.busy = u.item.busy;
      }
      if (u.item.uri !== void 0) {
        item.uri = u.item.uri?.toJSON();
      }
      if (u.item.range !== void 0) {
        item.range = u.item.range?.toJSON();
      }
      if (u.item.description !== void 0) {
        item.description = u.item.description;
      }
      if (u.item.error !== void 0) {
        item.error = u.item.error;
      }
      if (u.item.sortText !== void 0) {
        item.sortText = u.item.sortText;
      }
    }
    return { extId: u.extId, expand: u.expand, item };
  };
  ITestItemUpdate2.deserialize = (u) => {
    let item;
    if (u.item) {
      item = {};
      if (u.item.label !== void 0) {
        item.label = u.item.label;
      }
      if (u.item.tags !== void 0) {
        item.tags = u.item.tags;
      }
      if (u.item.busy !== void 0) {
        item.busy = u.item.busy;
      }
      if (u.item.range !== void 0) {
        item.range = u.item.range ? Range.lift(u.item.range) : null;
      }
      if (u.item.description !== void 0) {
        item.description = u.item.description;
      }
      if (u.item.error !== void 0) {
        item.error = u.item.error;
      }
      if (u.item.sortText !== void 0) {
        item.sortText = u.item.sortText;
      }
    }
    return { extId: u.extId, expand: u.expand, item };
  };
})(ITestItemUpdate || (ITestItemUpdate = {}));
var applyTestItemUpdate = (internal, patch2) => {
  if (patch2.expand !== void 0) {
    internal.expand = patch2.expand;
  }
  if (patch2.item !== void 0) {
    internal.item = internal.item ? Object.assign(internal.item, patch2.item) : patch2.item;
  }
};
var TestResultItem;
(function(TestResultItem2) {
  TestResultItem2.serializeWithoutMessages = (original) => ({
    ...InternalTestItem.serialize(original),
    ownComputedState: original.ownComputedState,
    computedState: original.computedState,
    tasks: original.tasks.map(ITestTaskState.serializeWithoutMessages)
  });
  TestResultItem2.serialize = (original) => ({
    ...InternalTestItem.serialize(original),
    ownComputedState: original.ownComputedState,
    computedState: original.computedState,
    tasks: original.tasks.map(ITestTaskState.serialize)
  });
  TestResultItem2.deserialize = (uriIdentity, serialized) => ({
    ...InternalTestItem.deserialize(uriIdentity, serialized),
    ownComputedState: serialized.ownComputedState,
    computedState: serialized.computedState,
    tasks: serialized.tasks.map((m) => ITestTaskState.deserialize(uriIdentity, m)),
    retired: true
  });
})(TestResultItem || (TestResultItem = {}));
var ICoverageCount;
(function(ICoverageCount2) {
  ICoverageCount2.empty = () => ({ covered: 0, total: 0 });
  ICoverageCount2.sum = (target, src) => {
    target.covered += src.covered;
    target.total += src.total;
  };
})(ICoverageCount || (ICoverageCount = {}));
var IFileCoverage;
(function(IFileCoverage2) {
  IFileCoverage2.serialize = (original) => ({
    id: original.id,
    statement: original.statement,
    branch: original.branch,
    declaration: original.declaration,
    testIds: original.testIds,
    uri: original.uri.toJSON()
  });
  IFileCoverage2.deserialize = (uriIdentity, serialized) => ({
    id: serialized.id,
    statement: serialized.statement,
    branch: serialized.branch,
    declaration: serialized.declaration,
    testIds: serialized.testIds,
    uri: uriIdentity.asCanonicalUri(URI.revive(serialized.uri))
  });
  IFileCoverage2.empty = (id2, uri) => ({
    id: id2,
    uri,
    statement: ICoverageCount.empty()
  });
})(IFileCoverage || (IFileCoverage = {}));
function serializeThingWithLocation(serialized) {
  return {
    ...serialized,
    location: serialized.location?.toJSON()
  };
}
function deserializeThingWithLocation(serialized) {
  serialized.location = serialized.location ? Position.isIPosition(serialized.location) ? Position.lift(serialized.location) : Range.lift(serialized.location) : void 0;
  return serialized;
}
var DetailType;
(function(DetailType2) {
  DetailType2[DetailType2["Declaration"] = 0] = "Declaration";
  DetailType2[DetailType2["Statement"] = 1] = "Statement";
  DetailType2[DetailType2["Branch"] = 2] = "Branch";
})(DetailType || (DetailType = {}));
var CoverageDetails;
(function(CoverageDetails2) {
  CoverageDetails2.serialize = (original) => original.type === 0 ? IDeclarationCoverage.serialize(original) : IStatementCoverage.serialize(original);
  CoverageDetails2.deserialize = (serialized) => serialized.type === 0 ? IDeclarationCoverage.deserialize(serialized) : IStatementCoverage.deserialize(serialized);
})(CoverageDetails || (CoverageDetails = {}));
var IBranchCoverage;
(function(IBranchCoverage2) {
  IBranchCoverage2.serialize = serializeThingWithLocation;
  IBranchCoverage2.deserialize = deserializeThingWithLocation;
})(IBranchCoverage || (IBranchCoverage = {}));
var IDeclarationCoverage;
(function(IDeclarationCoverage2) {
  IDeclarationCoverage2.serialize = serializeThingWithLocation;
  IDeclarationCoverage2.deserialize = deserializeThingWithLocation;
})(IDeclarationCoverage || (IDeclarationCoverage = {}));
var IStatementCoverage;
(function(IStatementCoverage2) {
  IStatementCoverage2.serialize = (original) => ({
    ...serializeThingWithLocation(original),
    branches: original.branches?.map(IBranchCoverage.serialize)
  });
  IStatementCoverage2.deserialize = (serialized) => ({
    ...deserializeThingWithLocation(serialized),
    branches: serialized.branches?.map(IBranchCoverage.deserialize)
  });
})(IStatementCoverage || (IStatementCoverage = {}));
var TestDiffOpType;
(function(TestDiffOpType2) {
  TestDiffOpType2[TestDiffOpType2["Add"] = 0] = "Add";
  TestDiffOpType2[TestDiffOpType2["Update"] = 1] = "Update";
  TestDiffOpType2[TestDiffOpType2["DocumentSynced"] = 2] = "DocumentSynced";
  TestDiffOpType2[TestDiffOpType2["Remove"] = 3] = "Remove";
  TestDiffOpType2[TestDiffOpType2["IncrementPendingExtHosts"] = 4] = "IncrementPendingExtHosts";
  TestDiffOpType2[TestDiffOpType2["Retire"] = 5] = "Retire";
  TestDiffOpType2[TestDiffOpType2["AddTag"] = 6] = "AddTag";
  TestDiffOpType2[TestDiffOpType2["RemoveTag"] = 7] = "RemoveTag";
})(TestDiffOpType || (TestDiffOpType = {}));
var TestsDiffOp;
(function(TestsDiffOp2) {
  TestsDiffOp2.deserialize = (uriIdentity, u) => {
    if (u.op === 0) {
      return { op: u.op, item: InternalTestItem.deserialize(uriIdentity, u.item) };
    } else if (u.op === 1) {
      return { op: u.op, item: ITestItemUpdate.deserialize(u.item) };
    } else if (u.op === 2) {
      return { op: u.op, uri: uriIdentity.asCanonicalUri(URI.revive(u.uri)), docv: u.docv };
    } else {
      return u;
    }
  };
  TestsDiffOp2.serialize = (u) => {
    if (u.op === 0) {
      return { op: u.op, item: InternalTestItem.serialize(u.item) };
    } else if (u.op === 1) {
      return { op: u.op, item: ITestItemUpdate.serialize(u.item) };
    } else {
      return u;
    }
  };
})(TestsDiffOp || (TestsDiffOp = {}));
var AbstractIncrementalTestCollection = class {
  constructor(uriIdentity) {
    this.uriIdentity = uriIdentity;
    this._tags = /* @__PURE__ */ new Map();
    this.items = /* @__PURE__ */ new Map();
    this.roots = /* @__PURE__ */ new Set();
    this.busyControllerCount = 0;
    this.pendingRootCount = 0;
    this.tags = this._tags;
  }
  /**
   * Applies the diff to the collection.
   */
  apply(diff2) {
    const changes = this.createChangeCollector();
    for (const op of diff2) {
      switch (op.op) {
        case 0:
          this.add(InternalTestItem.deserialize(this.uriIdentity, op.item), changes);
          break;
        case 1:
          this.update(ITestItemUpdate.deserialize(op.item), changes);
          break;
        case 3:
          this.remove(op.itemId, changes);
          break;
        case 5:
          this.retireTest(op.itemId);
          break;
        case 4:
          this.updatePendingRoots(op.amount);
          break;
        case 6:
          this._tags.set(op.tag.id, op.tag);
          break;
        case 7:
          this._tags.delete(op.id);
          break;
      }
    }
    changes.complete?.();
  }
  add(item, changes) {
    const parentId = TestId.parentId(item.item.extId)?.toString();
    let created;
    if (!parentId) {
      created = this.createItem(item);
      this.roots.add(created);
      this.items.set(item.item.extId, created);
    } else if (this.items.has(parentId)) {
      const parent = this.items.get(parentId);
      parent.children.add(item.item.extId);
      created = this.createItem(item, parent);
      this.items.set(item.item.extId, created);
    } else {
      console.error(`Test with unknown parent ID: ${JSON.stringify(item)}`);
      return;
    }
    changes.add?.(created);
    if (item.expand === 2) {
      this.busyControllerCount++;
    }
    return created;
  }
  update(patch2, changes) {
    const existing = this.items.get(patch2.extId);
    if (!existing) {
      return;
    }
    if (patch2.expand !== void 0) {
      if (existing.expand === 2) {
        this.busyControllerCount--;
      }
      if (patch2.expand === 2) {
        this.busyControllerCount++;
      }
    }
    applyTestItemUpdate(existing, patch2);
    changes.update?.(existing);
    return existing;
  }
  remove(itemId, changes) {
    const toRemove = this.items.get(itemId);
    if (!toRemove) {
      return;
    }
    const parentId = TestId.parentId(toRemove.item.extId)?.toString();
    if (parentId) {
      const parent = this.items.get(parentId);
      parent.children.delete(toRemove.item.extId);
    } else {
      this.roots.delete(toRemove);
    }
    const queue = [[itemId]];
    while (queue.length) {
      for (const itemId2 of queue.pop()) {
        const existing = this.items.get(itemId2);
        if (existing) {
          queue.push(existing.children);
          this.items.delete(itemId2);
          changes.remove?.(existing, existing !== toRemove);
          if (existing.expand === 2) {
            this.busyControllerCount--;
          }
        }
      }
    }
  }
  /**
   * Called when the extension signals a test result should be retired.
   */
  retireTest(testId) {
  }
  /**
   * Updates the number of test root sources who are yet to report. When
   * the total pending test roots reaches 0, the roots for all controllers
   * will exist in the collection.
   */
  updatePendingRoots(delta3) {
    this.pendingRootCount += delta3;
  }
  /**
   * Called before a diff is applied to create a new change collector.
   */
  createChangeCollector() {
    return {};
  }
};

// out-build/vs/workbench/services/aiSettingsSearch/common/aiSettingsSearch.js
var IAiSettingsSearchService = createDecorator("IAiSettingsSearchService");
var AiSettingsSearchResultKind;
(function(AiSettingsSearchResultKind2) {
  AiSettingsSearchResultKind2[AiSettingsSearchResultKind2["EMBEDDED"] = 1] = "EMBEDDED";
  AiSettingsSearchResultKind2[AiSettingsSearchResultKind2["LLM_RANKED"] = 2] = "LLM_RANKED";
  AiSettingsSearchResultKind2[AiSettingsSearchResultKind2["CANCELED"] = 3] = "CANCELED";
})(AiSettingsSearchResultKind || (AiSettingsSearchResultKind = {}));

// out-build/vs/workbench/services/editor/common/editorGroupsService.js
var IEditorGroupsService = createDecorator("editorGroupsService");
var GroupDirection;
(function(GroupDirection2) {
  GroupDirection2[GroupDirection2["UP"] = 0] = "UP";
  GroupDirection2[GroupDirection2["DOWN"] = 1] = "DOWN";
  GroupDirection2[GroupDirection2["LEFT"] = 2] = "LEFT";
  GroupDirection2[GroupDirection2["RIGHT"] = 3] = "RIGHT";
})(GroupDirection || (GroupDirection = {}));
var GroupOrientation;
(function(GroupOrientation2) {
  GroupOrientation2[GroupOrientation2["HORIZONTAL"] = 0] = "HORIZONTAL";
  GroupOrientation2[GroupOrientation2["VERTICAL"] = 1] = "VERTICAL";
})(GroupOrientation || (GroupOrientation = {}));
var GroupLocation;
(function(GroupLocation2) {
  GroupLocation2[GroupLocation2["FIRST"] = 0] = "FIRST";
  GroupLocation2[GroupLocation2["LAST"] = 1] = "LAST";
  GroupLocation2[GroupLocation2["NEXT"] = 2] = "NEXT";
  GroupLocation2[GroupLocation2["PREVIOUS"] = 3] = "PREVIOUS";
})(GroupLocation || (GroupLocation = {}));
var GroupsArrangement;
(function(GroupsArrangement2) {
  GroupsArrangement2[GroupsArrangement2["MAXIMIZE"] = 0] = "MAXIMIZE";
  GroupsArrangement2[GroupsArrangement2["EXPAND"] = 1] = "EXPAND";
  GroupsArrangement2[GroupsArrangement2["EVEN"] = 2] = "EVEN";
})(GroupsArrangement || (GroupsArrangement = {}));
var MergeGroupMode;
(function(MergeGroupMode2) {
  MergeGroupMode2[MergeGroupMode2["COPY_EDITORS"] = 0] = "COPY_EDITORS";
  MergeGroupMode2[MergeGroupMode2["MOVE_EDITORS"] = 1] = "MOVE_EDITORS";
})(MergeGroupMode || (MergeGroupMode = {}));
var GroupsOrder;
(function(GroupsOrder2) {
  GroupsOrder2[GroupsOrder2["CREATION_TIME"] = 0] = "CREATION_TIME";
  GroupsOrder2[GroupsOrder2["MOST_RECENTLY_ACTIVE"] = 1] = "MOST_RECENTLY_ACTIVE";
  GroupsOrder2[GroupsOrder2["GRID_APPEARANCE"] = 2] = "GRID_APPEARANCE";
})(GroupsOrder || (GroupsOrder = {}));
var OpenEditorContext;
(function(OpenEditorContext2) {
  OpenEditorContext2[OpenEditorContext2["NEW_EDITOR"] = 1] = "NEW_EDITOR";
  OpenEditorContext2[OpenEditorContext2["MOVE_EDITOR"] = 2] = "MOVE_EDITOR";
  OpenEditorContext2[OpenEditorContext2["COPY_EDITOR"] = 3] = "COPY_EDITOR";
})(OpenEditorContext || (OpenEditorContext = {}));

// out-build/vs/workbench/services/editor/common/editorService.js
var IEditorService = createDecorator("editorService");
var ACTIVE_GROUP = -1;
var SIDE_GROUP = -2;

// out-build/vs/base/common/policy.js
var PolicyCategory;
(function(PolicyCategory2) {
  PolicyCategory2["Extensions"] = "Extensions";
  PolicyCategory2["IntegratedTerminal"] = "IntegratedTerminal";
  PolicyCategory2["InteractiveSession"] = "InteractiveSession";
  PolicyCategory2["Telemetry"] = "Telemetry";
  PolicyCategory2["Update"] = "Update";
})(PolicyCategory || (PolicyCategory = {}));
var PolicyCategoryData = {
  [PolicyCategory.Extensions]: {
    name: {
      key: "extensionsConfigurationTitle",
      value: localize(145, null)
    }
  },
  [PolicyCategory.IntegratedTerminal]: {
    name: {
      key: "terminalIntegratedConfigurationTitle",
      value: localize(146, null)
    }
  },
  [PolicyCategory.InteractiveSession]: {
    name: {
      key: "interactiveSessionConfigurationTitle",
      value: localize(147, null)
    }
  },
  [PolicyCategory.Telemetry]: {
    name: {
      key: "telemetryConfigurationTitle",
      value: localize(148, null)
    }
  },
  [PolicyCategory.Update]: {
    name: {
      key: "updateConfigurationTitle",
      value: localize(149, null)
    }
  }
};

// out-build/vs/platform/configuration/common/configuration.js
var IConfigurationService = createDecorator("configurationService");
var ConfigurationTarget;
(function(ConfigurationTarget3) {
  ConfigurationTarget3[ConfigurationTarget3["APPLICATION"] = 1] = "APPLICATION";
  ConfigurationTarget3[ConfigurationTarget3["USER"] = 2] = "USER";
  ConfigurationTarget3[ConfigurationTarget3["USER_LOCAL"] = 3] = "USER_LOCAL";
  ConfigurationTarget3[ConfigurationTarget3["USER_REMOTE"] = 4] = "USER_REMOTE";
  ConfigurationTarget3[ConfigurationTarget3["WORKSPACE"] = 5] = "WORKSPACE";
  ConfigurationTarget3[ConfigurationTarget3["WORKSPACE_FOLDER"] = 6] = "WORKSPACE_FOLDER";
  ConfigurationTarget3[ConfigurationTarget3["DEFAULT"] = 7] = "DEFAULT";
  ConfigurationTarget3[ConfigurationTarget3["MEMORY"] = 8] = "MEMORY";
})(ConfigurationTarget || (ConfigurationTarget = {}));
function toValuesTree(properties, conflictReporter) {
  const root = /* @__PURE__ */ Object.create(null);
  for (const key in properties) {
    addToValueTree(root, key, properties[key], conflictReporter);
  }
  return root;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    const s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "undefined":
        obj = curr[s] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        if (obj === null) {
          conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is null`);
          return;
        }
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object" && curr !== null) {
    try {
      curr[last] = value;
    } catch (e) {
      conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
    }
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  if (!valueTree) {
    return;
  }
  const valueTreeRecord = valueTree;
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTreeRecord[first];
    return;
  }
  if (Object.keys(valueTreeRecord).indexOf(first) !== -1) {
    const value = valueTreeRecord[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTreeRecord[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path2) {
    let current = config2;
    for (const component of path2) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[component];
    }
    return current;
  }
  const path = settingPath.split(".");
  const result = accessSetting(config, path);
  return typeof result === "undefined" ? defaultValue : result;
}
function getLanguageTagSettingPlainKey(settingKey) {
  return settingKey.replace(/^\[/, "").replace(/]$/g, "").replace(/\]\[/g, ", ");
}

// out-build/vs/base/common/jsonSchema.js
function getCompressedContent(schema2) {
  let hasDups = false;
  const equalsByString = /* @__PURE__ */ new Map();
  const nodeToEquals = /* @__PURE__ */ new Map();
  const visitSchemas = (next) => {
    if (schema2 === next) {
      return true;
    }
    const val = JSON.stringify(next);
    if (val.length < 30) {
      return true;
    }
    const eq2 = equalsByString.get(val);
    if (!eq2) {
      const newEq = { schemas: [next] };
      equalsByString.set(val, newEq);
      nodeToEquals.set(next, newEq);
      return true;
    }
    eq2.schemas.push(next);
    nodeToEquals.set(next, eq2);
    hasDups = true;
    return false;
  };
  traverseNodes(schema2, visitSchemas);
  equalsByString.clear();
  if (!hasDups) {
    return JSON.stringify(schema2);
  }
  let defNodeName = "$defs";
  while (schema2.hasOwnProperty(defNodeName)) {
    defNodeName += "_";
  }
  const definitions = [];
  function stringify3(root) {
    return JSON.stringify(root, (_key, value) => {
      if (value !== root) {
        const eq2 = nodeToEquals.get(value);
        if (eq2 && eq2.schemas.length > 1) {
          if (!eq2.id) {
            eq2.id = `_${definitions.length}`;
            definitions.push(eq2.schemas[0]);
          }
          return { $ref: `#/${defNodeName}/${eq2.id}` };
        }
      }
      return value;
    });
  }
  const str = stringify3(schema2);
  const defStrings = [];
  for (let i = 0; i < definitions.length; i++) {
    defStrings.push(`"_${i}":${stringify3(definitions[i])}`);
  }
  if (defStrings.length) {
    return `${str.substring(0, str.length - 1)},"${defNodeName}":{${defStrings.join(",")}}}`;
  }
  return str;
}
function isObject2(thing) {
  return typeof thing === "object" && thing !== null;
}
function traverseNodes(root, visit2) {
  if (!root || typeof root !== "object") {
    return;
  }
  const collectEntries = (...entries) => {
    for (const entry of entries) {
      if (isObject2(entry)) {
        toWalk.push(entry);
      }
    }
  };
  const collectMapEntries = (...maps) => {
    for (const map of maps) {
      if (isObject2(map)) {
        for (const key in map) {
          const entry = map[key];
          if (isObject2(entry)) {
            toWalk.push(entry);
          }
        }
      }
    }
  };
  const collectArrayEntries = (...arrays) => {
    for (const array of arrays) {
      if (Array.isArray(array)) {
        for (const entry of array) {
          if (isObject2(entry)) {
            toWalk.push(entry);
          }
        }
      }
    }
  };
  const collectEntryOrArrayEntries = (items) => {
    if (Array.isArray(items)) {
      for (const entry of items) {
        if (isObject2(entry)) {
          toWalk.push(entry);
        }
      }
    } else if (isObject2(items)) {
      toWalk.push(items);
    }
  };
  const toWalk = [root];
  let next = toWalk.pop();
  while (next) {
    const visitChildern = visit2(next);
    if (visitChildern) {
      collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);
      collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);
      collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);
      collectEntryOrArrayEntries(next.items);
    }
    next = toWalk.pop();
  }
}

// out-build/vs/platform/jsonschemas/common/jsonContributionRegistry.js
var Extensions = {
  JSONContribution: "base.contributions.json"
};
function normalizeId(id2) {
  if (id2.length > 0 && id2.charAt(id2.length - 1) === "#") {
    return id2.substring(0, id2.length - 1);
  }
  return id2;
}
var JSONContributionRegistry = class extends Disposable {
  constructor() {
    super(...arguments);
    this.schemasById = {};
    this.schemaAssociations = {};
    this._onDidChangeSchema = this._register(new Emitter());
    this.onDidChangeSchema = this._onDidChangeSchema.event;
    this._onDidChangeSchemaAssociations = this._register(new Emitter());
    this.onDidChangeSchemaAssociations = this._onDidChangeSchemaAssociations.event;
  }
  registerSchema(uri, unresolvedSchemaContent, store) {
    const normalizedUri = normalizeId(uri);
    this.schemasById[normalizedUri] = unresolvedSchemaContent;
    this._onDidChangeSchema.fire(uri);
    if (store) {
      store.add(toDisposable(() => {
        delete this.schemasById[normalizedUri];
        this._onDidChangeSchema.fire(uri);
      }));
    }
  }
  registerSchemaAssociation(uri, glob) {
    const normalizedUri = normalizeId(uri);
    if (!this.schemaAssociations[normalizedUri]) {
      this.schemaAssociations[normalizedUri] = [];
    }
    if (!this.schemaAssociations[normalizedUri].includes(glob)) {
      this.schemaAssociations[normalizedUri].push(glob);
      this._onDidChangeSchemaAssociations.fire();
    }
    return toDisposable(() => {
      const associations = this.schemaAssociations[normalizedUri];
      if (associations) {
        const index = associations.indexOf(glob);
        if (index !== -1) {
          associations.splice(index, 1);
          if (associations.length === 0) {
            delete this.schemaAssociations[normalizedUri];
          }
          this._onDidChangeSchemaAssociations.fire();
        }
      }
    });
  }
  notifySchemaChanged(uri) {
    this._onDidChangeSchema.fire(uri);
  }
  getSchemaContributions() {
    return {
      schemas: this.schemasById
    };
  }
  getSchemaContent(uri) {
    const schema2 = this.schemasById[uri];
    return schema2 ? getCompressedContent(schema2) : void 0;
  }
  hasSchemaContent(uri) {
    return !!this.schemasById[uri];
  }
  getSchemaAssociations() {
    return this.schemaAssociations;
  }
};
var jsonContributionRegistry = new JSONContributionRegistry();
Registry.add(Extensions.JSONContribution, jsonContributionRegistry);

// out-build/vs/platform/product/common/product.js
var product;
var vscodeGlobal2 = globalThis.vscode;
if (typeof vscodeGlobal2 !== "undefined" && typeof vscodeGlobal2.context !== "undefined") {
  const configuration = vscodeGlobal2.context.configuration();
  if (configuration) {
    product = configuration.product;
  } else {
    throw new Error("Sandbox: unable to resolve product configuration from preload script.");
  }
} else if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {
  product = globalThis._VSCODE_PRODUCT_JSON;
  if (env["VSCODE_DEV"]) {
    Object.assign(product, {
      nameShort: `${product.nameShort} Dev`,
      nameLong: `${product.nameLong} Dev`,
      dataFolderName: `${product.dataFolderName}-dev`,
      serverDataFolderName: product.serverDataFolderName ? `${product.serverDataFolderName}-dev` : void 0
    });
  }
  if (!product.version) {
    const pkg = globalThis._VSCODE_PACKAGE_JSON;
    Object.assign(product, {
      version: pkg.version
    });
  }
} else {
  product = {
    /*BUILD->INSERT_PRODUCT_CONFIGURATION*/
  };
  if (Object.keys(product).length === 0) {
    Object.assign(product, {
      version: "1.104.0-dev",
      nameShort: "Code - OSS Dev",
      nameLong: "Code - OSS Dev",
      applicationName: "code-oss",
      dataFolderName: ".vscode-oss",
      urlProtocol: "code-oss",
      reportIssueUrl: "https://github.com/microsoft/vscode/issues/new",
      licenseName: "MIT",
      licenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
      serverLicenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt"
    });
  }
}
var product_default = product;

// out-build/vs/platform/configuration/common/configurationRegistry.js
var EditPresentationTypes;
(function(EditPresentationTypes2) {
  EditPresentationTypes2["Multiline"] = "multilineText";
  EditPresentationTypes2["Singleline"] = "singlelineText";
})(EditPresentationTypes || (EditPresentationTypes = {}));
var Extensions2 = {
  Configuration: "base.contributions.configuration"
};
var ConfigurationScope;
(function(ConfigurationScope2) {
  ConfigurationScope2[ConfigurationScope2["APPLICATION"] = 1] = "APPLICATION";
  ConfigurationScope2[ConfigurationScope2["MACHINE"] = 2] = "MACHINE";
  ConfigurationScope2[ConfigurationScope2["APPLICATION_MACHINE"] = 3] = "APPLICATION_MACHINE";
  ConfigurationScope2[ConfigurationScope2["WINDOW"] = 4] = "WINDOW";
  ConfigurationScope2[ConfigurationScope2["RESOURCE"] = 5] = "RESOURCE";
  ConfigurationScope2[ConfigurationScope2["LANGUAGE_OVERRIDABLE"] = 6] = "LANGUAGE_OVERRIDABLE";
  ConfigurationScope2[ConfigurationScope2["MACHINE_OVERRIDABLE"] = 7] = "MACHINE_OVERRIDABLE";
})(ConfigurationScope || (ConfigurationScope = {}));
var allSettings = { properties: {}, patternProperties: {} };
var applicationSettings = { properties: {}, patternProperties: {} };
var applicationMachineSettings = { properties: {}, patternProperties: {} };
var machineSettings = { properties: {}, patternProperties: {} };
var machineOverridableSettings = { properties: {}, patternProperties: {} };
var windowSettings = { properties: {}, patternProperties: {} };
var resourceSettings = { properties: {}, patternProperties: {} };
var resourceLanguageSettingsSchemaId = "vscode://schemas/settings/resourceLanguage";
var contributionRegistry = Registry.as(Extensions.JSONContribution);
var ConfigurationRegistry = class extends Disposable {
  constructor() {
    super();
    this.registeredConfigurationDefaults = [];
    this.overrideIdentifiers = /* @__PURE__ */ new Set();
    this._onDidSchemaChange = this._register(new Emitter());
    this.onDidSchemaChange = this._onDidSchemaChange.event;
    this._onDidUpdateConfiguration = this._register(new Emitter());
    this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
    this.configurationDefaultsOverrides = /* @__PURE__ */ new Map();
    this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: localize(1832, null),
      properties: {}
    };
    this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];
    this.resourceLanguageSettingsSchema = {
      properties: {},
      patternProperties: {},
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    this.configurationProperties = {};
    this.policyConfigurations = /* @__PURE__ */ new Map();
    this.excludedConfigurationProperties = {};
    contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
    this.registerOverridePropertyPatternKey();
  }
  registerConfiguration(configuration, validate = true) {
    this.registerConfigurations([configuration], validate);
    return configuration;
  }
  registerConfigurations(configurations, validate = true) {
    const properties = /* @__PURE__ */ new Set();
    this.doRegisterConfigurations(configurations, validate, properties);
    contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
    this._onDidSchemaChange.fire();
    this._onDidUpdateConfiguration.fire({ properties });
  }
  deregisterConfigurations(configurations) {
    const properties = /* @__PURE__ */ new Set();
    this.doDeregisterConfigurations(configurations, properties);
    contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
    this._onDidSchemaChange.fire();
    this._onDidUpdateConfiguration.fire({ properties });
  }
  updateConfigurations({ add, remove }) {
    const properties = /* @__PURE__ */ new Set();
    this.doDeregisterConfigurations(remove, properties);
    this.doRegisterConfigurations(add, false, properties);
    contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
    this._onDidSchemaChange.fire();
    this._onDidUpdateConfiguration.fire({ properties });
  }
  registerDefaultConfigurations(configurationDefaults) {
    const properties = /* @__PURE__ */ new Set();
    this.doRegisterDefaultConfigurations(configurationDefaults, properties);
    this._onDidSchemaChange.fire();
    this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });
  }
  doRegisterDefaultConfigurations(configurationDefaults, bucket) {
    this.registeredConfigurationDefaults.push(...configurationDefaults);
    const overrideIdentifiers = [];
    for (const { overrides, source } of configurationDefaults) {
      for (const key in overrides) {
        bucket.add(key);
        const configurationDefaultOverridesForKey = this.configurationDefaultsOverrides.get(key) ?? this.configurationDefaultsOverrides.set(key, { configurationDefaultOverrides: [] }).get(key);
        const value = overrides[key];
        configurationDefaultOverridesForKey.configurationDefaultOverrides.push({ value, source });
        if (OVERRIDE_PROPERTY_REGEX.test(key)) {
          const newDefaultOverride = this.mergeDefaultConfigurationsForOverrideIdentifier(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);
          if (!newDefaultOverride) {
            continue;
          }
          configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;
          this.updateDefaultOverrideProperty(key, newDefaultOverride, source);
          overrideIdentifiers.push(...overrideIdentifiersFromKey(key));
        } else {
          const newDefaultOverride = this.mergeDefaultConfigurationsForConfigurationProperty(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);
          if (!newDefaultOverride) {
            continue;
          }
          configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;
          const property = this.configurationProperties[key];
          if (property) {
            this.updatePropertyDefaultValue(key, property);
            this.updateSchema(key, property);
          }
        }
      }
    }
    this.doRegisterOverrideIdentifiers(overrideIdentifiers);
  }
  deregisterDefaultConfigurations(defaultConfigurations) {
    const properties = /* @__PURE__ */ new Set();
    this.doDeregisterDefaultConfigurations(defaultConfigurations, properties);
    this._onDidSchemaChange.fire();
    this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });
  }
  doDeregisterDefaultConfigurations(defaultConfigurations, bucket) {
    for (const defaultConfiguration of defaultConfigurations) {
      const index = this.registeredConfigurationDefaults.indexOf(defaultConfiguration);
      if (index !== -1) {
        this.registeredConfigurationDefaults.splice(index, 1);
      }
    }
    for (const { overrides, source } of defaultConfigurations) {
      for (const key in overrides) {
        const configurationDefaultOverridesForKey = this.configurationDefaultsOverrides.get(key);
        if (!configurationDefaultOverridesForKey) {
          continue;
        }
        const index = configurationDefaultOverridesForKey.configurationDefaultOverrides.findIndex((configurationDefaultOverride) => source ? configurationDefaultOverride.source?.id === source.id : configurationDefaultOverride.value === overrides[key]);
        if (index === -1) {
          continue;
        }
        configurationDefaultOverridesForKey.configurationDefaultOverrides.splice(index, 1);
        if (configurationDefaultOverridesForKey.configurationDefaultOverrides.length === 0) {
          this.configurationDefaultsOverrides.delete(key);
        }
        if (OVERRIDE_PROPERTY_REGEX.test(key)) {
          let configurationDefaultOverrideValue;
          for (const configurationDefaultOverride of configurationDefaultOverridesForKey.configurationDefaultOverrides) {
            configurationDefaultOverrideValue = this.mergeDefaultConfigurationsForOverrideIdentifier(key, configurationDefaultOverride.value, configurationDefaultOverride.source, configurationDefaultOverrideValue);
          }
          if (configurationDefaultOverrideValue && !isEmptyObject(configurationDefaultOverrideValue.value)) {
            configurationDefaultOverridesForKey.configurationDefaultOverrideValue = configurationDefaultOverrideValue;
            this.updateDefaultOverrideProperty(key, configurationDefaultOverrideValue, source);
          } else {
            this.configurationDefaultsOverrides.delete(key);
            delete this.configurationProperties[key];
            delete this.defaultLanguageConfigurationOverridesNode.properties[key];
          }
        } else {
          let configurationDefaultOverrideValue;
          for (const configurationDefaultOverride of configurationDefaultOverridesForKey.configurationDefaultOverrides) {
            configurationDefaultOverrideValue = this.mergeDefaultConfigurationsForConfigurationProperty(key, configurationDefaultOverride.value, configurationDefaultOverride.source, configurationDefaultOverrideValue);
          }
          configurationDefaultOverridesForKey.configurationDefaultOverrideValue = configurationDefaultOverrideValue;
          const property = this.configurationProperties[key];
          if (property) {
            this.updatePropertyDefaultValue(key, property);
            this.updateSchema(key, property);
          }
        }
        bucket.add(key);
      }
    }
    this.updateOverridePropertyPatternKey();
  }
  updateDefaultOverrideProperty(key, newDefaultOverride, source) {
    const property = {
      section: {
        id: this.defaultLanguageConfigurationOverridesNode.id,
        title: this.defaultLanguageConfigurationOverridesNode.title,
        order: this.defaultLanguageConfigurationOverridesNode.order,
        extensionInfo: this.defaultLanguageConfigurationOverridesNode.extensionInfo
      },
      type: "object",
      default: newDefaultOverride.value,
      description: localize(1833, null, getLanguageTagSettingPlainKey(key)),
      $ref: resourceLanguageSettingsSchemaId,
      defaultDefaultValue: newDefaultOverride.value,
      source,
      defaultValueSource: source
    };
    this.configurationProperties[key] = property;
    this.defaultLanguageConfigurationOverridesNode.properties[key] = property;
  }
  mergeDefaultConfigurationsForOverrideIdentifier(overrideIdentifier, configurationValueObject, valueSource, existingDefaultOverride) {
    const defaultValue = existingDefaultOverride?.value || {};
    const source = existingDefaultOverride?.source ?? /* @__PURE__ */ new Map();
    if (!(source instanceof Map)) {
      console.error("objectConfigurationSources is not a Map");
      return void 0;
    }
    for (const propertyKey of Object.keys(configurationValueObject)) {
      const propertyDefaultValue = configurationValueObject[propertyKey];
      const isObjectSetting = isObject(propertyDefaultValue) && (isUndefined(defaultValue[propertyKey]) || isObject(defaultValue[propertyKey]));
      if (isObjectSetting) {
        defaultValue[propertyKey] = { ...defaultValue[propertyKey] ?? {}, ...propertyDefaultValue };
        if (valueSource) {
          for (const objectKey in propertyDefaultValue) {
            source.set(`${propertyKey}.${objectKey}`, valueSource);
          }
        }
      } else {
        defaultValue[propertyKey] = propertyDefaultValue;
        if (valueSource) {
          source.set(propertyKey, valueSource);
        } else {
          source.delete(propertyKey);
        }
      }
    }
    return { value: defaultValue, source };
  }
  mergeDefaultConfigurationsForConfigurationProperty(propertyKey, value, valuesSource, existingDefaultOverride) {
    const property = this.configurationProperties[propertyKey];
    const existingDefaultValue = existingDefaultOverride?.value ?? property?.defaultDefaultValue;
    let source = valuesSource;
    const isObjectSetting = isObject(value) && (property !== void 0 && property.type === "object" || property === void 0 && (isUndefined(existingDefaultValue) || isObject(existingDefaultValue)));
    if (isObjectSetting) {
      source = existingDefaultOverride?.source ?? /* @__PURE__ */ new Map();
      if (!(source instanceof Map)) {
        console.error("defaultValueSource is not a Map");
        return void 0;
      }
      for (const objectKey in value) {
        if (valuesSource) {
          source.set(`${propertyKey}.${objectKey}`, valuesSource);
        }
      }
      value = { ...isObject(existingDefaultValue) ? existingDefaultValue : {}, ...value };
    }
    return { value, source };
  }
  deltaConfiguration(delta3) {
    let defaultsOverrides = false;
    const properties = /* @__PURE__ */ new Set();
    if (delta3.removedDefaults) {
      this.doDeregisterDefaultConfigurations(delta3.removedDefaults, properties);
      defaultsOverrides = true;
    }
    if (delta3.addedDefaults) {
      this.doRegisterDefaultConfigurations(delta3.addedDefaults, properties);
      defaultsOverrides = true;
    }
    if (delta3.removedConfigurations) {
      this.doDeregisterConfigurations(delta3.removedConfigurations, properties);
    }
    if (delta3.addedConfigurations) {
      this.doRegisterConfigurations(delta3.addedConfigurations, false, properties);
    }
    this._onDidSchemaChange.fire();
    this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides });
  }
  notifyConfigurationSchemaUpdated(...configurations) {
    this._onDidSchemaChange.fire();
  }
  registerOverrideIdentifiers(overrideIdentifiers) {
    this.doRegisterOverrideIdentifiers(overrideIdentifiers);
    this._onDidSchemaChange.fire();
  }
  doRegisterOverrideIdentifiers(overrideIdentifiers) {
    for (const overrideIdentifier of overrideIdentifiers) {
      this.overrideIdentifiers.add(overrideIdentifier);
    }
    this.updateOverridePropertyPatternKey();
  }
  doRegisterConfigurations(configurations, validate, bucket) {
    configurations.forEach((configuration) => {
      this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo, configuration.restrictedProperties, void 0, bucket);
      this.configurationContributors.push(configuration);
      this.registerJSONConfiguration(configuration);
    });
  }
  doDeregisterConfigurations(configurations, bucket) {
    const deregisterConfiguration = (configuration) => {
      if (configuration.properties) {
        for (const key in configuration.properties) {
          bucket.add(key);
          const property = this.configurationProperties[key];
          if (property?.policy?.name) {
            this.policyConfigurations.delete(property.policy.name);
          }
          delete this.configurationProperties[key];
          this.removeFromSchema(key, configuration.properties[key]);
        }
      }
      configuration.allOf?.forEach((node) => deregisterConfiguration(node));
    };
    for (const configuration of configurations) {
      deregisterConfiguration(configuration);
      const index = this.configurationContributors.indexOf(configuration);
      if (index !== -1) {
        this.configurationContributors.splice(index, 1);
      }
    }
  }
  validateAndRegisterProperties(configuration, validate = true, extensionInfo, restrictedProperties, scope = 4, bucket) {
    scope = isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
    const properties = configuration.properties;
    if (properties) {
      for (const key in properties) {
        const property = properties[key];
        property.section = {
          id: configuration.id,
          title: configuration.title,
          order: configuration.order,
          extensionInfo: configuration.extensionInfo
        };
        if (validate && validateProperty(key, property, extensionInfo?.id)) {
          delete properties[key];
          continue;
        }
        property.source = extensionInfo;
        property.defaultDefaultValue = properties[key].default;
        this.updatePropertyDefaultValue(key, property);
        if (OVERRIDE_PROPERTY_REGEX.test(key)) {
          property.scope = void 0;
        } else {
          property.scope = isUndefinedOrNull(property.scope) ? scope : property.scope;
          property.restricted = isUndefinedOrNull(property.restricted) ? !!restrictedProperties?.includes(key) : property.restricted;
        }
        if (property.experiment) {
          if (!property.tags?.some((tag2) => tag2.toLowerCase() === "onexp")) {
            property.tags = property.tags ?? [];
            property.tags.push("onExP");
          }
        } else if (property.tags?.some((tag2) => tag2.toLowerCase() === "onexp")) {
          console.error(`Invalid tag 'onExP' found for property '${key}'. Please use 'experiment' property instead.`);
          property.experiment = { mode: "startup" };
        }
        const excluded = properties[key].hasOwnProperty("included") && !properties[key].included;
        const policyName = properties[key].policy?.name;
        if (excluded) {
          this.excludedConfigurationProperties[key] = properties[key];
          if (policyName) {
            this.policyConfigurations.set(policyName, key);
            bucket.add(key);
          }
          delete properties[key];
        } else {
          bucket.add(key);
          if (policyName) {
            this.policyConfigurations.set(policyName, key);
          }
          this.configurationProperties[key] = properties[key];
          if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {
            properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;
          }
        }
      }
    }
    const subNodes = configuration.allOf;
    if (subNodes) {
      for (const node of subNodes) {
        this.validateAndRegisterProperties(node, validate, extensionInfo, restrictedProperties, scope, bucket);
      }
    }
  }
  // Only for tests
  getConfigurations() {
    return this.configurationContributors;
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  getPolicyConfigurations() {
    return this.policyConfigurations;
  }
  getExcludedConfigurationProperties() {
    return this.excludedConfigurationProperties;
  }
  getRegisteredDefaultConfigurations() {
    return [...this.registeredConfigurationDefaults];
  }
  getConfigurationDefaultsOverrides() {
    const configurationDefaultsOverrides = /* @__PURE__ */ new Map();
    for (const [key, value] of this.configurationDefaultsOverrides) {
      if (value.configurationDefaultOverrideValue) {
        configurationDefaultsOverrides.set(key, value.configurationDefaultOverrideValue);
      }
    }
    return configurationDefaultsOverrides;
  }
  registerJSONConfiguration(configuration) {
    const register3 = (configuration2) => {
      const properties = configuration2.properties;
      if (properties) {
        for (const key in properties) {
          this.updateSchema(key, properties[key]);
        }
      }
      const subNodes = configuration2.allOf;
      subNodes?.forEach(register3);
    };
    register3(configuration);
  }
  updateSchema(key, property) {
    allSettings.properties[key] = property;
    switch (property.scope) {
      case 1:
        applicationSettings.properties[key] = property;
        break;
      case 2:
        machineSettings.properties[key] = property;
        break;
      case 3:
        applicationMachineSettings.properties[key] = property;
        break;
      case 7:
        machineOverridableSettings.properties[key] = property;
        break;
      case 4:
        windowSettings.properties[key] = property;
        break;
      case 5:
        resourceSettings.properties[key] = property;
        break;
      case 6:
        resourceSettings.properties[key] = property;
        this.resourceLanguageSettingsSchema.properties[key] = property;
        break;
    }
  }
  removeFromSchema(key, property) {
    delete allSettings.properties[key];
    switch (property.scope) {
      case 1:
        delete applicationSettings.properties[key];
        break;
      case 2:
        delete machineSettings.properties[key];
        break;
      case 3:
        delete applicationMachineSettings.properties[key];
        break;
      case 7:
        delete machineOverridableSettings.properties[key];
        break;
      case 4:
        delete windowSettings.properties[key];
        break;
      case 5:
      case 6:
        delete resourceSettings.properties[key];
        delete this.resourceLanguageSettingsSchema.properties[key];
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const overrideIdentifier of this.overrideIdentifiers.values()) {
      const overrideIdentifierProperty = `[${overrideIdentifier}]`;
      const resourceLanguagePropertiesSchema = {
        type: "object",
        description: localize(1834, null),
        errorMessage: localize(1835, null),
        $ref: resourceLanguageSettingsSchemaId
      };
      this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);
      allSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      applicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      applicationMachineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      machineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      machineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      windowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      resourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
    }
  }
  registerOverridePropertyPatternKey() {
    const resourceLanguagePropertiesSchema = {
      type: "object",
      description: localize(1836, null),
      errorMessage: localize(1837, null),
      $ref: resourceLanguageSettingsSchemaId
    };
    allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    applicationSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    applicationMachineSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    machineSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    machineOverridableSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    windowSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    resourceSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(key, property) {
    const configurationdefaultOverride = this.configurationDefaultsOverrides.get(key)?.configurationDefaultOverrideValue;
    let defaultValue = void 0;
    let defaultSource = void 0;
    if (configurationdefaultOverride && (!property.disallowConfigurationDefault || !configurationdefaultOverride.source)) {
      defaultValue = configurationdefaultOverride.value;
      defaultSource = configurationdefaultOverride.source;
    }
    if (isUndefined(defaultValue)) {
      defaultValue = property.defaultDefaultValue;
      defaultSource = void 0;
    }
    if (isUndefined(defaultValue)) {
      defaultValue = getDefaultValue(property.type);
    }
    property.default = defaultValue;
    property.defaultValueSource = defaultSource;
  }
};
var OVERRIDE_IDENTIFIER_PATTERN = `\\[([^\\]]+)\\]`;
var OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, "g");
var OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;
var OVERRIDE_PROPERTY_REGEX = new RegExp(OVERRIDE_PROPERTY_PATTERN);
function overrideIdentifiersFromKey(key) {
  const identifiers2 = [];
  if (OVERRIDE_PROPERTY_REGEX.test(key)) {
    let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    while (matches?.length) {
      const identifier = matches[1].trim();
      if (identifier) {
        identifiers2.push(identifier);
      }
      matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    }
  }
  return distinct(identifiers2);
}
function getDefaultValue(type) {
  const t = Array.isArray(type) ? type[0] : type;
  switch (t) {
    case "boolean":
      return false;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
var configurationRegistry = new ConfigurationRegistry();
Registry.add(Extensions2.Configuration, configurationRegistry);
function validateProperty(property, schema2, extensionId) {
  if (!property.trim()) {
    return localize(1838, null);
  }
  if (OVERRIDE_PROPERTY_REGEX.test(property)) {
    return localize(1839, null, property);
  }
  if (configurationRegistry.getConfigurationProperties()[property] !== void 0 && (!extensionId || !EXTENSION_UNIFICATION_EXTENSION_IDS.has(extensionId.toLowerCase()))) {
    return localize(1840, null, property);
  }
  if (schema2.policy?.name && configurationRegistry.getPolicyConfigurations().get(schema2.policy?.name) !== void 0) {
    return localize(1841, null, property, schema2.policy?.name, configurationRegistry.getPolicyConfigurations().get(schema2.policy?.name));
  }
  return null;
}
var EXTENSION_UNIFICATION_EXTENSION_IDS = new Set(product_default.defaultChatAgent ? [product_default.defaultChatAgent.extensionId, product_default.defaultChatAgent.chatExtensionId].map((id2) => id2.toLowerCase()) : []);

// out-build/vs/platform/extensionManagement/common/extensionManagement.js
var EXTENSION_IDENTIFIER_PATTERN = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$";
var EXTENSION_IDENTIFIER_REGEX = new RegExp(EXTENSION_IDENTIFIER_PATTERN);
var ExtensionInstallSource;
(function(ExtensionInstallSource2) {
  ExtensionInstallSource2["COMMAND"] = "command";
  ExtensionInstallSource2["SETTINGS_SYNC"] = "settingsSync";
})(ExtensionInstallSource || (ExtensionInstallSource = {}));
var SortBy;
(function(SortBy2) {
  SortBy2["NoneOrRelevance"] = "NoneOrRelevance";
  SortBy2["LastUpdatedDate"] = "LastUpdatedDate";
  SortBy2["Title"] = "Title";
  SortBy2["PublisherName"] = "PublisherName";
  SortBy2["InstallCount"] = "InstallCount";
  SortBy2["PublishedDate"] = "PublishedDate";
  SortBy2["AverageRating"] = "AverageRating";
  SortBy2["WeightedRating"] = "WeightedRating";
})(SortBy || (SortBy = {}));
var SortOrder;
(function(SortOrder2) {
  SortOrder2[SortOrder2["Default"] = 0] = "Default";
  SortOrder2[SortOrder2["Ascending"] = 1] = "Ascending";
  SortOrder2[SortOrder2["Descending"] = 2] = "Descending";
})(SortOrder || (SortOrder = {}));
var FilterType;
(function(FilterType2) {
  FilterType2["Category"] = "Category";
  FilterType2["ExtensionId"] = "ExtensionId";
  FilterType2["ExtensionName"] = "ExtensionName";
  FilterType2["ExcludeWithFlags"] = "ExcludeWithFlags";
  FilterType2["Featured"] = "Featured";
  FilterType2["SearchText"] = "SearchText";
  FilterType2["Tag"] = "Tag";
  FilterType2["Target"] = "Target";
})(FilterType || (FilterType = {}));
var StatisticType;
(function(StatisticType2) {
  StatisticType2["Install"] = "install";
  StatisticType2["Uninstall"] = "uninstall";
})(StatisticType || (StatisticType = {}));
var InstallOperation;
(function(InstallOperation2) {
  InstallOperation2[InstallOperation2["None"] = 1] = "None";
  InstallOperation2[InstallOperation2["Install"] = 2] = "Install";
  InstallOperation2[InstallOperation2["Update"] = 3] = "Update";
  InstallOperation2[InstallOperation2["Migrate"] = 4] = "Migrate";
})(InstallOperation || (InstallOperation = {}));
var IExtensionGalleryService = createDecorator("extensionGalleryService");
var ExtensionGalleryErrorCode;
(function(ExtensionGalleryErrorCode2) {
  ExtensionGalleryErrorCode2["Timeout"] = "Timeout";
  ExtensionGalleryErrorCode2["Cancelled"] = "Cancelled";
  ExtensionGalleryErrorCode2["ClientError"] = "ClientError";
  ExtensionGalleryErrorCode2["ServerError"] = "ServerError";
  ExtensionGalleryErrorCode2["Failed"] = "Failed";
  ExtensionGalleryErrorCode2["DownloadFailedWriting"] = "DownloadFailedWriting";
  ExtensionGalleryErrorCode2["Offline"] = "Offline";
})(ExtensionGalleryErrorCode || (ExtensionGalleryErrorCode = {}));
var ExtensionManagementErrorCode;
(function(ExtensionManagementErrorCode2) {
  ExtensionManagementErrorCode2["NotFound"] = "NotFound";
  ExtensionManagementErrorCode2["Unsupported"] = "Unsupported";
  ExtensionManagementErrorCode2["Deprecated"] = "Deprecated";
  ExtensionManagementErrorCode2["Malicious"] = "Malicious";
  ExtensionManagementErrorCode2["Incompatible"] = "Incompatible";
  ExtensionManagementErrorCode2["IncompatibleApi"] = "IncompatibleApi";
  ExtensionManagementErrorCode2["IncompatibleTargetPlatform"] = "IncompatibleTargetPlatform";
  ExtensionManagementErrorCode2["ReleaseVersionNotFound"] = "ReleaseVersionNotFound";
  ExtensionManagementErrorCode2["Invalid"] = "Invalid";
  ExtensionManagementErrorCode2["Download"] = "Download";
  ExtensionManagementErrorCode2["DownloadSignature"] = "DownloadSignature";
  ExtensionManagementErrorCode2["DownloadFailedWriting"] = "DownloadFailedWriting";
  ExtensionManagementErrorCode2["UpdateMetadata"] = "UpdateMetadata";
  ExtensionManagementErrorCode2["Extract"] = "Extract";
  ExtensionManagementErrorCode2["Scanning"] = "Scanning";
  ExtensionManagementErrorCode2["ScanningExtension"] = "ScanningExtension";
  ExtensionManagementErrorCode2["ReadRemoved"] = "ReadRemoved";
  ExtensionManagementErrorCode2["UnsetRemoved"] = "UnsetRemoved";
  ExtensionManagementErrorCode2["Delete"] = "Delete";
  ExtensionManagementErrorCode2["Rename"] = "Rename";
  ExtensionManagementErrorCode2["IntializeDefaultProfile"] = "IntializeDefaultProfile";
  ExtensionManagementErrorCode2["AddToProfile"] = "AddToProfile";
  ExtensionManagementErrorCode2["InstalledExtensionNotFound"] = "InstalledExtensionNotFound";
  ExtensionManagementErrorCode2["PostInstall"] = "PostInstall";
  ExtensionManagementErrorCode2["CorruptZip"] = "CorruptZip";
  ExtensionManagementErrorCode2["IncompleteZip"] = "IncompleteZip";
  ExtensionManagementErrorCode2["PackageNotSigned"] = "PackageNotSigned";
  ExtensionManagementErrorCode2["SignatureVerificationInternal"] = "SignatureVerificationInternal";
  ExtensionManagementErrorCode2["SignatureVerificationFailed"] = "SignatureVerificationFailed";
  ExtensionManagementErrorCode2["NotAllowed"] = "NotAllowed";
  ExtensionManagementErrorCode2["Gallery"] = "Gallery";
  ExtensionManagementErrorCode2["Cancelled"] = "Cancelled";
  ExtensionManagementErrorCode2["Unknown"] = "Unknown";
  ExtensionManagementErrorCode2["Internal"] = "Internal";
})(ExtensionManagementErrorCode || (ExtensionManagementErrorCode = {}));
var ExtensionSignatureVerificationCode;
(function(ExtensionSignatureVerificationCode2) {
  ExtensionSignatureVerificationCode2["NotSigned"] = "NotSigned";
  ExtensionSignatureVerificationCode2["Success"] = "Success";
  ExtensionSignatureVerificationCode2["RequiredArgumentMissing"] = "RequiredArgumentMissing";
  ExtensionSignatureVerificationCode2["InvalidArgument"] = "InvalidArgument";
  ExtensionSignatureVerificationCode2["PackageIsUnreadable"] = "PackageIsUnreadable";
  ExtensionSignatureVerificationCode2["UnhandledException"] = "UnhandledException";
  ExtensionSignatureVerificationCode2["SignatureManifestIsMissing"] = "SignatureManifestIsMissing";
  ExtensionSignatureVerificationCode2["SignatureManifestIsUnreadable"] = "SignatureManifestIsUnreadable";
  ExtensionSignatureVerificationCode2["SignatureIsMissing"] = "SignatureIsMissing";
  ExtensionSignatureVerificationCode2["SignatureIsUnreadable"] = "SignatureIsUnreadable";
  ExtensionSignatureVerificationCode2["CertificateIsUnreadable"] = "CertificateIsUnreadable";
  ExtensionSignatureVerificationCode2["SignatureArchiveIsUnreadable"] = "SignatureArchiveIsUnreadable";
  ExtensionSignatureVerificationCode2["FileAlreadyExists"] = "FileAlreadyExists";
  ExtensionSignatureVerificationCode2["SignatureArchiveIsInvalidZip"] = "SignatureArchiveIsInvalidZip";
  ExtensionSignatureVerificationCode2["SignatureArchiveHasSameSignatureFile"] = "SignatureArchiveHasSameSignatureFile";
  ExtensionSignatureVerificationCode2["PackageIntegrityCheckFailed"] = "PackageIntegrityCheckFailed";
  ExtensionSignatureVerificationCode2["SignatureIsInvalid"] = "SignatureIsInvalid";
  ExtensionSignatureVerificationCode2["SignatureManifestIsInvalid"] = "SignatureManifestIsInvalid";
  ExtensionSignatureVerificationCode2["SignatureIntegrityCheckFailed"] = "SignatureIntegrityCheckFailed";
  ExtensionSignatureVerificationCode2["EntryIsMissing"] = "EntryIsMissing";
  ExtensionSignatureVerificationCode2["EntryIsTampered"] = "EntryIsTampered";
  ExtensionSignatureVerificationCode2["Untrusted"] = "Untrusted";
  ExtensionSignatureVerificationCode2["CertificateRevoked"] = "CertificateRevoked";
  ExtensionSignatureVerificationCode2["SignatureIsNotValid"] = "SignatureIsNotValid";
  ExtensionSignatureVerificationCode2["UnknownError"] = "UnknownError";
  ExtensionSignatureVerificationCode2["PackageIsInvalidZip"] = "PackageIsInvalidZip";
  ExtensionSignatureVerificationCode2["SignatureArchiveHasTooManyEntries"] = "SignatureArchiveHasTooManyEntries";
})(ExtensionSignatureVerificationCode || (ExtensionSignatureVerificationCode = {}));
var IExtensionManagementService = createDecorator("extensionManagementService");
var IGlobalExtensionEnablementService = createDecorator("IGlobalExtensionEnablementService");
var IExtensionTipsService = createDecorator("IExtensionTipsService");
var IAllowedExtensionsService = createDecorator("IAllowedExtensionsService");
var ExtensionsLocalizedLabel = localize2(1991, "Extensions");
var PreferencesLocalizedLabel = localize2(1992, "Preferences");
var AllowedExtensionsConfigKey = "extensions.allowed";
Registry.as(Extensions2.Configuration).registerConfiguration({
  id: "extensions",
  order: 30,
  title: localize(1974, null),
  type: "object",
  properties: {
    [AllowedExtensionsConfigKey]: {
      // Note: Type is set only to object because to support policies generation during build time, where single type is expected.
      type: "object",
      markdownDescription: localize(1975, null),
      default: "*",
      defaultSnippets: [{
        body: {},
        description: localize(1976, null)
      }, {
        body: {
          "*": true
        },
        description: localize(1977, null)
      }],
      scope: 1,
      policy: {
        name: "AllowedExtensions",
        category: PolicyCategory.Extensions,
        minimumVersion: "1.96",
        localization: {
          description: {
            key: "extensions.allowed.policy",
            value: localize(1978, null)
          }
        }
      },
      additionalProperties: false,
      patternProperties: {
        "([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
          anyOf: [
            {
              type: ["boolean", "string"],
              enum: [true, false, "stable"],
              description: localize(1979, null),
              enumDescriptions: [
                localize(1980, null),
                localize(1981, null),
                localize(1982, null)
              ]
            },
            {
              type: "array",
              items: {
                type: "string"
              },
              description: localize(1983, null)
            }
          ]
        },
        "([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
          type: ["boolean", "string"],
          enum: [true, false, "stable"],
          description: localize(1984, null),
          enumDescriptions: [
            localize(1985, null),
            localize(1986, null),
            localize(1987, null)
          ]
        },
        "\\*": {
          type: "boolean",
          enum: [true, false],
          description: localize(1988, null),
          enumDescriptions: [
            localize(1989, null),
            localize(1990, null)
          ]
        }
      }
    }
  }
});

// out-build/vs/platform/telemetry/common/telemetry.js
var ITelemetryService = createDecorator("telemetryService");
var ICustomEndpointTelemetryService = createDecorator("customEndpointTelemetryService");
var TelemetryLevel;
(function(TelemetryLevel2) {
  TelemetryLevel2[TelemetryLevel2["NONE"] = 0] = "NONE";
  TelemetryLevel2[TelemetryLevel2["CRASH"] = 1] = "CRASH";
  TelemetryLevel2[TelemetryLevel2["ERROR"] = 2] = "ERROR";
  TelemetryLevel2[TelemetryLevel2["USAGE"] = 3] = "USAGE";
})(TelemetryLevel || (TelemetryLevel = {}));
var TelemetryConfiguration;
(function(TelemetryConfiguration2) {
  TelemetryConfiguration2["OFF"] = "off";
  TelemetryConfiguration2["CRASH"] = "crash";
  TelemetryConfiguration2["ERROR"] = "error";
  TelemetryConfiguration2["ON"] = "all";
})(TelemetryConfiguration || (TelemetryConfiguration = {}));

// out-build/vs/platform/telemetry/common/telemetryUtils.js
var TelemetryTrustedValue = class {
  constructor(value) {
    this.value = value;
    this.isTrustedTelemetryValue = true;
  }
};
var NullTelemetryServiceShape = class {
  constructor() {
    this.telemetryLevel = 0;
    this.sessionId = "someValue.sessionId";
    this.machineId = "someValue.machineId";
    this.sqmId = "someValue.sqmId";
    this.devDeviceId = "someValue.devDeviceId";
    this.firstSessionDate = "someValue.firstSessionDate";
    this.sendErrorTelemetry = false;
  }
  publicLog() {
  }
  publicLog2() {
  }
  publicLogError() {
  }
  publicLogError2() {
  }
  setExperimentProperty() {
  }
};
var NullTelemetryService = new NullTelemetryServiceShape();
var telemetryLogId = "telemetry";
var TelemetryLogGroup = { id: telemetryLogId, name: localize(2330, null) };
var telemetryAllowedAuthorities = /* @__PURE__ */ new Set(["ssh-remote", "dev-container", "attached-container", "wsl", "tunnel", "codespaces", "amlext"]);
function cleanRemoteAuthority(remoteAuthority) {
  if (!remoteAuthority) {
    return "none";
  }
  const remoteName = getRemoteName(remoteAuthority);
  return telemetryAllowedAuthorities.has(remoteName) ? remoteName : "other";
}
function anonymizeFilePaths(stack, cleanupPatterns) {
  if (!stack || !stack.includes("/") && !stack.includes("\\")) {
    return stack;
  }
  let updatedStack = stack;
  const cleanUpIndexes = [];
  for (const regexp of cleanupPatterns) {
    while (true) {
      const result = regexp.exec(stack);
      if (!result) {
        break;
      }
      cleanUpIndexes.push([result.index, regexp.lastIndex]);
    }
  }
  const nodeModulesRegex = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/;
  const fileRegex = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
  let lastIndex = 0;
  updatedStack = "";
  while (true) {
    const result = fileRegex.exec(stack);
    if (!result) {
      break;
    }
    const overlappingRange = cleanUpIndexes.some(([start, end]) => result.index < end && start < fileRegex.lastIndex);
    if (!nodeModulesRegex.test(result[0]) && !overlappingRange) {
      updatedStack += stack.substring(lastIndex, result.index) + "<REDACTED: user-file-path>";
      lastIndex = fileRegex.lastIndex;
    }
  }
  if (lastIndex < stack.length) {
    updatedStack += stack.substr(lastIndex);
  }
  return updatedStack;
}
function removePropertiesWithPossibleUserInfo(property) {
  if (!property) {
    return property;
  }
  const userDataRegexes = [
    { label: "URL", regex: /[a-zA-Z][a-zA-Z0-9+.-]*:\/\/[^\s]*/ },
    { label: "Google API Key", regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
    { label: "JWT", regex: /eyJ[0eXAiOiJKV1Qi|hbGci|a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+/ },
    { label: "Slack Token", regex: /xox[pbar]\-[A-Za-z0-9]/ },
    { label: "GitHub Token", regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },
    { label: "Generic Secret", regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i },
    { label: "CLI Credentials", regex: /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/ },
    { label: "Microsoft Entra ID", regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/ },
    { label: "Email", regex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/ }
  ];
  for (const secretRegex of userDataRegexes) {
    if (secretRegex.regex.test(property)) {
      return `<REDACTED: ${secretRegex.label}>`;
    }
  }
  return property;
}
function cleanData(data2, cleanUpPatterns) {
  if (!data2) {
    return {};
  }
  return cloneAndChange(data2, (value) => {
    if (value instanceof TelemetryTrustedValue || Object.hasOwnProperty.call(value, "isTrustedTelemetryValue")) {
      return value.value;
    }
    if (typeof value === "string") {
      let updatedProperty = value.replaceAll("%20", " ");
      updatedProperty = anonymizeFilePaths(updatedProperty, cleanUpPatterns);
      for (const regexp of cleanUpPatterns) {
        updatedProperty = updatedProperty.replace(regexp, "");
      }
      updatedProperty = removePropertiesWithPossibleUserInfo(updatedProperty);
      return updatedProperty;
    }
    return void 0;
  });
}

// out-build/vs/platform/extensionManagement/common/extensionManagementUtil.js
function areSameExtensions(a, b) {
  if (a.uuid && b.uuid) {
    return a.uuid === b.uuid;
  }
  if (a.id === b.id) {
    return true;
  }
  return compareIgnoreCase(a.id, b.id) === 0;
}
var BetterMergeId = new ExtensionIdentifier("pprice.better-merge");

// out-build/vs/platform/extensionManagement/common/implicitActivationEvents.js
var ImplicitActivationEventsImpl = class {
  constructor() {
    this._generators = /* @__PURE__ */ new Map();
    this._cache = /* @__PURE__ */ new WeakMap();
  }
  register(extensionPointName, generator) {
    this._generators.set(extensionPointName, generator);
  }
  /**
   * This can run correctly only on the renderer process because that is the only place
   * where all extension points and all implicit activation events generators are known.
   */
  readActivationEvents(extensionDescription) {
    if (!this._cache.has(extensionDescription)) {
      this._cache.set(extensionDescription, this._readActivationEvents(extensionDescription));
    }
    return this._cache.get(extensionDescription);
  }
  /**
   * This can run correctly only on the renderer process because that is the only place
   * where all extension points and all implicit activation events generators are known.
   */
  createActivationEventsMap(extensionDescriptions) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const extensionDescription of extensionDescriptions) {
      const activationEvents = this.readActivationEvents(extensionDescription);
      if (activationEvents.length > 0) {
        result[ExtensionIdentifier.toKey(extensionDescription.identifier)] = activationEvents;
      }
    }
    return result;
  }
  _readActivationEvents(desc) {
    if (typeof desc.main === "undefined" && typeof desc.browser === "undefined") {
      return [];
    }
    const activationEvents = Array.isArray(desc.activationEvents) ? desc.activationEvents.slice(0) : [];
    for (let i = 0; i < activationEvents.length; i++) {
      if (activationEvents[i] === "onUri") {
        activationEvents[i] = `onUri:${ExtensionIdentifier.toKey(desc.identifier)}`;
      }
    }
    if (!desc.contributes) {
      return activationEvents;
    }
    for (const extPointName in desc.contributes) {
      const generator = this._generators.get(extPointName);
      if (!generator) {
        continue;
      }
      const contrib = desc.contributes[extPointName];
      const contribArr = Array.isArray(contrib) ? contrib : [contrib];
      try {
        activationEvents.push(...generator(contribArr));
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    return activationEvents;
  }
};
var ImplicitActivationEvents = new ImplicitActivationEventsImpl();

// out-build/vs/workbench/services/extensions/common/extensions.js
var nullExtensionDescription = Object.freeze({
  identifier: new ExtensionIdentifier("nullExtensionDescription"),
  name: "Null Extension Description",
  version: "0.0.0",
  publisher: "vscode",
  engines: { vscode: "" },
  extensionLocation: URI.parse("void:location"),
  isBuiltin: false,
  targetPlatform: "undefined",
  isUserBuiltin: false,
  isUnderDevelopment: false,
  preRelease: false
});
var IExtensionService = createDecorator("extensionService");
var MissingExtensionDependency = class {
  constructor(dependency) {
    this.dependency = dependency;
  }
};
var ExtensionHostStartup;
(function(ExtensionHostStartup2) {
  ExtensionHostStartup2[ExtensionHostStartup2["EagerAutoStart"] = 1] = "EagerAutoStart";
  ExtensionHostStartup2[ExtensionHostStartup2["EagerManualStart"] = 2] = "EagerManualStart";
  ExtensionHostStartup2[ExtensionHostStartup2["LazyAutoStart"] = 3] = "LazyAutoStart";
})(ExtensionHostStartup || (ExtensionHostStartup = {}));
function isProposedApiEnabled(extension, proposal) {
  if (!extension.enabledApiProposals) {
    return false;
  }
  return extension.enabledApiProposals.includes(proposal);
}
function checkProposedApiEnabled(extension, proposal) {
  if (!isProposedApiEnabled(extension, proposal)) {
    throw new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.
Its package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(", ") ?? "[]"} but NOT ${proposal}.
 The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);
  }
}
var ActivationKind;
(function(ActivationKind2) {
  ActivationKind2[ActivationKind2["Normal"] = 0] = "Normal";
  ActivationKind2[ActivationKind2["Immediate"] = 1] = "Immediate";
})(ActivationKind || (ActivationKind = {}));

// out-build/vs/workbench/contrib/testing/common/testItemCollection.js
var TestItemEventOp;
(function(TestItemEventOp2) {
  TestItemEventOp2[TestItemEventOp2["Upsert"] = 0] = "Upsert";
  TestItemEventOp2[TestItemEventOp2["SetTags"] = 1] = "SetTags";
  TestItemEventOp2[TestItemEventOp2["UpdateCanResolveChildren"] = 2] = "UpdateCanResolveChildren";
  TestItemEventOp2[TestItemEventOp2["RemoveChild"] = 3] = "RemoveChild";
  TestItemEventOp2[TestItemEventOp2["SetProp"] = 4] = "SetProp";
  TestItemEventOp2[TestItemEventOp2["Bulk"] = 5] = "Bulk";
  TestItemEventOp2[TestItemEventOp2["DocumentSynced"] = 6] = "DocumentSynced";
})(TestItemEventOp || (TestItemEventOp = {}));
var strictEqualComparator = (a, b) => a === b;
var diffableProps = {
  range: (a, b) => {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.equalsRange(b);
  },
  busy: strictEqualComparator,
  label: strictEqualComparator,
  description: strictEqualComparator,
  error: strictEqualComparator,
  sortText: strictEqualComparator,
  tags: (a, b) => {
    if (a.length !== b.length) {
      return false;
    }
    if (a.some((t1) => !b.includes(t1))) {
      return false;
    }
    return true;
  }
};
var diffableEntries = Object.entries(diffableProps);
var diffTestItems = (a, b) => {
  let output;
  for (const [key, cmp4] of diffableEntries) {
    if (!cmp4(a[key], b[key])) {
      if (output) {
        output[key] = b[key];
      } else {
        output = { [key]: b[key] };
      }
    }
  }
  return output;
};
var TestItemCollection = class extends Disposable {
  get root() {
    return this.options.root;
  }
  constructor(options2) {
    super();
    this.options = options2;
    this.debounceSendDiff = this._register(new RunOnceScheduler(() => this.flushDiff(), 200));
    this.diffOpEmitter = this._register(new Emitter());
    this.tree = /* @__PURE__ */ new Map();
    this.tags = /* @__PURE__ */ new Map();
    this.diff = [];
    this.onDidGenerateDiff = this.diffOpEmitter.event;
    this.root.canResolveChildren = true;
    this.upsertItem(this.root, void 0);
  }
  /**
   * Handler used for expanding test items.
   */
  set resolveHandler(handler) {
    this._resolveHandler = handler;
    for (const test of this.tree.values()) {
      this.updateExpandability(test);
    }
  }
  get resolveHandler() {
    return this._resolveHandler;
  }
  /**
   * Gets a diff of all changes that have been made, and clears the diff queue.
   */
  collectDiff() {
    const diff2 = this.diff;
    this.diff = [];
    return diff2;
  }
  /**
   * Pushes a new diff entry onto the collected diff list.
   */
  pushDiff(diff2) {
    switch (diff2.op) {
      case 2: {
        for (const existing of this.diff) {
          if (existing.op === 2 && existing.uri === diff2.uri) {
            existing.docv = diff2.docv;
            return;
          }
        }
        break;
      }
      case 1: {
        const last = this.diff[this.diff.length - 1];
        if (last) {
          if (last.op === 1 && last.item.extId === diff2.item.extId) {
            applyTestItemUpdate(last.item, diff2.item);
            return;
          }
          if (last.op === 0 && last.item.item.extId === diff2.item.extId) {
            applyTestItemUpdate(last.item, diff2.item);
            return;
          }
        }
        break;
      }
    }
    this.diff.push(diff2);
    if (!this.debounceSendDiff.isScheduled()) {
      this.debounceSendDiff.schedule();
    }
  }
  /**
   * Expands the test and the given number of `levels` of children. If levels
   * is < 0, then all children will be expanded. If it's 0, then only this
   * item will be expanded.
   */
  expand(testId, levels) {
    const internal = this.tree.get(testId);
    if (!internal) {
      return;
    }
    if (internal.expandLevels === void 0 || levels > internal.expandLevels) {
      internal.expandLevels = levels;
    }
    if (internal.expand === 1) {
      const r = this.resolveChildren(internal);
      return !r.isOpen() ? r.wait().then(() => this.expandChildren(internal, levels - 1)) : this.expandChildren(internal, levels - 1);
    } else if (internal.expand === 3) {
      return internal.resolveBarrier?.isOpen() === false ? internal.resolveBarrier.wait().then(() => this.expandChildren(internal, levels - 1)) : this.expandChildren(internal, levels - 1);
    }
  }
  dispose() {
    for (const item of this.tree.values()) {
      this.options.getApiFor(item.actual).listener = void 0;
    }
    this.tree.clear();
    this.diff = [];
    super.dispose();
  }
  onTestItemEvent(internal, evt) {
    switch (evt.op) {
      case 3:
        this.removeItem(TestId.joinToString(internal.fullId, evt.id));
        break;
      case 0:
        this.upsertItem(evt.item, internal);
        break;
      case 5:
        for (const op of evt.ops) {
          this.onTestItemEvent(internal, op);
        }
        break;
      case 1:
        this.diffTagRefs(evt.new, evt.old, internal.fullId.toString());
        break;
      case 2:
        this.updateExpandability(internal);
        break;
      case 4:
        this.pushDiff({
          op: 1,
          item: {
            extId: internal.fullId.toString(),
            item: evt.update
          }
        });
        break;
      case 6:
        this.documentSynced(internal.actual.uri);
        break;
      default:
        assertNever(evt);
    }
  }
  documentSynced(uri) {
    if (uri) {
      this.pushDiff({
        op: 2,
        uri,
        docv: this.options.getDocumentVersion(uri)
      });
    }
  }
  upsertItem(actual, parent) {
    const fullId = TestId.fromExtHostTestItem(actual, this.root.id, parent?.actual);
    const privateApi = this.options.getApiFor(actual);
    if (privateApi.parent && privateApi.parent !== parent?.actual) {
      this.options.getChildren(privateApi.parent).delete(actual.id);
    }
    let internal = this.tree.get(fullId.toString());
    if (!internal) {
      internal = {
        fullId,
        actual,
        expandLevels: parent?.expandLevels ? parent.expandLevels - 1 : void 0,
        expand: 0
        // updated by `connectItemAndChildren`
      };
      actual.tags.forEach(this.incrementTagRefs, this);
      this.tree.set(internal.fullId.toString(), internal);
      this.setItemParent(actual, parent);
      this.pushDiff({
        op: 0,
        item: {
          controllerId: this.options.controllerId,
          expand: internal.expand,
          item: this.options.toITestItem(actual)
        }
      });
      this.connectItemAndChildren(actual, internal, parent);
      return;
    }
    if (internal.actual === actual) {
      this.connectItem(actual, internal, parent);
      return;
    }
    if (internal.actual.uri?.toString() !== actual.uri?.toString()) {
      this.removeItem(fullId.toString());
      return this.upsertItem(actual, parent);
    }
    const oldChildren = this.options.getChildren(internal.actual);
    const oldActual = internal.actual;
    const update = diffTestItems(this.options.toITestItem(oldActual), this.options.toITestItem(actual));
    this.options.getApiFor(oldActual).listener = void 0;
    internal.actual = actual;
    internal.resolveBarrier = void 0;
    internal.expand = 0;
    if (update) {
      if (update.hasOwnProperty("tags")) {
        this.diffTagRefs(actual.tags, oldActual.tags, fullId.toString());
        delete update.tags;
      }
      this.onTestItemEvent(internal, { op: 4, update });
    }
    this.connectItemAndChildren(actual, internal, parent);
    for (const [_, child] of oldChildren) {
      if (!this.options.getChildren(actual).get(child.id)) {
        this.removeItem(TestId.joinToString(fullId, child.id));
      }
    }
    const expandLevels = internal.expandLevels;
    if (expandLevels !== void 0) {
      queueMicrotask(() => {
        if (internal.expand === 1) {
          internal.expandLevels = void 0;
          this.expand(fullId.toString(), expandLevels);
        }
      });
    }
    this.documentSynced(internal.actual.uri);
  }
  diffTagRefs(newTags, oldTags, extId) {
    const toDelete = new Set(oldTags.map((t) => t.id));
    for (const tag2 of newTags) {
      if (!toDelete.delete(tag2.id)) {
        this.incrementTagRefs(tag2);
      }
    }
    this.pushDiff({
      op: 1,
      item: { extId, item: { tags: newTags.map((v) => namespaceTestTag(this.options.controllerId, v.id)) } }
    });
    toDelete.forEach(this.decrementTagRefs, this);
  }
  incrementTagRefs(tag2) {
    const existing = this.tags.get(tag2.id);
    if (existing) {
      existing.refCount++;
    } else {
      this.tags.set(tag2.id, { refCount: 1 });
      this.pushDiff({
        op: 6,
        tag: {
          id: namespaceTestTag(this.options.controllerId, tag2.id)
        }
      });
    }
  }
  decrementTagRefs(tagId) {
    const existing = this.tags.get(tagId);
    if (existing && !--existing.refCount) {
      this.tags.delete(tagId);
      this.pushDiff({ op: 7, id: namespaceTestTag(this.options.controllerId, tagId) });
    }
  }
  setItemParent(actual, parent) {
    this.options.getApiFor(actual).parent = parent && parent.actual !== this.root ? parent.actual : void 0;
  }
  connectItem(actual, internal, parent) {
    this.setItemParent(actual, parent);
    const api = this.options.getApiFor(actual);
    api.parent = parent?.actual;
    api.listener = (evt) => this.onTestItemEvent(internal, evt);
    this.updateExpandability(internal);
  }
  connectItemAndChildren(actual, internal, parent) {
    this.connectItem(actual, internal, parent);
    for (const [_, child] of this.options.getChildren(actual)) {
      this.upsertItem(child, internal);
    }
  }
  /**
   * Updates the `expand` state of the item. Should be called whenever the
   * resolved state of the item changes. Can automatically expand the item
   * if requested by a consumer.
   */
  updateExpandability(internal) {
    let newState;
    if (!this._resolveHandler) {
      newState = 0;
    } else if (internal.resolveBarrier) {
      newState = internal.resolveBarrier.isOpen() ? 3 : 2;
    } else {
      newState = internal.actual.canResolveChildren ? 1 : 0;
    }
    if (newState === internal.expand) {
      return;
    }
    internal.expand = newState;
    this.pushDiff({ op: 1, item: { extId: internal.fullId.toString(), expand: newState } });
    if (newState === 1 && internal.expandLevels !== void 0) {
      this.resolveChildren(internal);
    }
  }
  /**
   * Expands all children of the item, "levels" deep. If levels is 0, only
   * the children will be expanded. If it's 1, the children and their children
   * will be expanded. If it's <0, it's a no-op.
   */
  expandChildren(internal, levels) {
    if (levels < 0) {
      return;
    }
    const expandRequests = [];
    for (const [_, child] of this.options.getChildren(internal.actual)) {
      const promise = this.expand(TestId.joinToString(internal.fullId, child.id), levels);
      if (isThenable(promise)) {
        expandRequests.push(promise);
      }
    }
    if (expandRequests.length) {
      return Promise.all(expandRequests).then(() => {
      });
    }
  }
  /**
   * Calls `discoverChildren` on the item, refreshing all its tests.
   */
  resolveChildren(internal) {
    if (internal.resolveBarrier) {
      return internal.resolveBarrier;
    }
    if (!this._resolveHandler) {
      const b = new Barrier();
      b.open();
      return b;
    }
    internal.expand = 2;
    this.pushExpandStateUpdate(internal);
    const barrier = internal.resolveBarrier = new Barrier();
    const applyError = (err) => {
      console.error(`Unhandled error in resolveHandler of test controller "${this.options.controllerId}"`, err);
    };
    let r;
    try {
      r = this._resolveHandler(internal.actual === this.root ? void 0 : internal.actual);
    } catch (err) {
      applyError(err);
    }
    if (isThenable(r)) {
      r.catch(applyError).then(() => {
        barrier.open();
        this.updateExpandability(internal);
      });
    } else {
      barrier.open();
      this.updateExpandability(internal);
    }
    return internal.resolveBarrier;
  }
  pushExpandStateUpdate(internal) {
    this.pushDiff({ op: 1, item: { extId: internal.fullId.toString(), expand: internal.expand } });
  }
  removeItem(childId) {
    const childItem = this.tree.get(childId);
    if (!childItem) {
      throw new Error("attempting to remove non-existent child");
    }
    this.pushDiff({ op: 3, itemId: childId });
    const queue = [childItem];
    while (queue.length) {
      const item = queue.pop();
      if (!item) {
        continue;
      }
      this.options.getApiFor(item.actual).listener = void 0;
      for (const tag2 of item.actual.tags) {
        this.decrementTagRefs(tag2.id);
      }
      this.tree.delete(item.fullId.toString());
      for (const [_, child] of this.options.getChildren(item.actual)) {
        queue.push(this.tree.get(TestId.joinToString(item.fullId, child.id)));
      }
    }
  }
  /**
   * Immediately emits any pending diffs on the collection.
   */
  flushDiff() {
    const diff2 = this.collectDiff();
    if (diff2.length) {
      this.diffOpEmitter.fire(diff2);
    }
  }
};
var DuplicateTestItemError = class extends Error {
  constructor(id2) {
    super(`Attempted to insert a duplicate test item ID ${id2}`);
  }
};
var InvalidTestItemError = class extends Error {
  constructor(id2) {
    super(`TestItem with ID "${id2}" is invalid. Make sure to create it from the createTestItem method.`);
  }
};
var MixedTestItemController = class extends Error {
  constructor(id2, ctrlA, ctrlB) {
    super(`TestItem with ID "${id2}" is from controller "${ctrlA}" and cannot be added as a child of an item from controller "${ctrlB}".`);
  }
};
var createTestItemChildren = (api, getApi, checkCtor) => {
  let mapped = /* @__PURE__ */ new Map();
  return {
    /** @inheritdoc */
    get size() {
      return mapped.size;
    },
    /** @inheritdoc */
    forEach(callback, thisArg) {
      for (const item of mapped.values()) {
        callback.call(thisArg, item, this);
      }
    },
    /** @inheritdoc */
    [Symbol.iterator]() {
      return mapped.entries();
    },
    /** @inheritdoc */
    replace(items) {
      const newMapped = /* @__PURE__ */ new Map();
      const toDelete = new Set(mapped.keys());
      const bulk = { op: 5, ops: [] };
      for (const item of items) {
        if (!(item instanceof checkCtor)) {
          throw new InvalidTestItemError(item.id);
        }
        const itemController = getApi(item).controllerId;
        if (itemController !== api.controllerId) {
          throw new MixedTestItemController(item.id, itemController, api.controllerId);
        }
        if (newMapped.has(item.id)) {
          throw new DuplicateTestItemError(item.id);
        }
        newMapped.set(item.id, item);
        toDelete.delete(item.id);
        bulk.ops.push({ op: 0, item });
      }
      for (const id2 of toDelete.keys()) {
        bulk.ops.push({ op: 3, id: id2 });
      }
      api.listener?.(bulk);
      mapped = newMapped;
    },
    /** @inheritdoc */
    add(item) {
      if (!(item instanceof checkCtor)) {
        throw new InvalidTestItemError(item.id);
      }
      mapped.set(item.id, item);
      api.listener?.({ op: 0, item });
    },
    /** @inheritdoc */
    delete(id2) {
      if (mapped.delete(id2)) {
        api.listener?.({ op: 3, id: id2 });
      }
    },
    /** @inheritdoc */
    get(itemId) {
      return mapped.get(itemId);
    },
    /** JSON serialization function. */
    toJSON() {
      return Array.from(mapped.values());
    }
  };
};

// out-build/vs/workbench/api/common/extHostTestingPrivateApi.js
var eventPrivateApis = /* @__PURE__ */ new WeakMap();
var createPrivateApiFor = (impl, controllerId) => {
  const api = { controllerId };
  eventPrivateApis.set(impl, api);
  return api;
};
var getPrivateApiFor = (impl) => {
  const api = eventPrivateApis.get(impl);
  if (!api) {
    throw new InvalidTestItemError(impl?.id || "<unknown>");
  }
  return api;
};

// out-build/vs/platform/remote/common/remoteAuthorityResolver.js
var IRemoteAuthorityResolverService = createDecorator("remoteAuthorityResolverService");
var RemoteConnectionType;
(function(RemoteConnectionType2) {
  RemoteConnectionType2[RemoteConnectionType2["WebSocket"] = 0] = "WebSocket";
  RemoteConnectionType2[RemoteConnectionType2["Managed"] = 1] = "Managed";
})(RemoteConnectionType || (RemoteConnectionType = {}));
var ManagedRemoteConnection = class {
  constructor(id2) {
    this.id = id2;
    this.type = 1;
  }
  toString() {
    return `Managed(${this.id})`;
  }
};
var WebSocketRemoteConnection = class {
  constructor(host, port) {
    this.host = host;
    this.port = port;
    this.type = 0;
  }
  toString() {
    return `WebSocket(${this.host}:${this.port})`;
  }
};
var RemoteAuthorityResolverErrorCode;
(function(RemoteAuthorityResolverErrorCode2) {
  RemoteAuthorityResolverErrorCode2["Unknown"] = "Unknown";
  RemoteAuthorityResolverErrorCode2["NotAvailable"] = "NotAvailable";
  RemoteAuthorityResolverErrorCode2["TemporarilyNotAvailable"] = "TemporarilyNotAvailable";
  RemoteAuthorityResolverErrorCode2["NoResolverFound"] = "NoResolverFound";
  RemoteAuthorityResolverErrorCode2["InvalidAuthority"] = "InvalidAuthority";
})(RemoteAuthorityResolverErrorCode || (RemoteAuthorityResolverErrorCode = {}));
function getRemoteAuthorityPrefix(remoteAuthority) {
  const plusIndex = remoteAuthority.indexOf("+");
  if (plusIndex === -1) {
    return remoteAuthority;
  }
  return remoteAuthority.substring(0, plusIndex);
}

// out-build/vs/workbench/api/common/extHostTypes/es5ClassCompat.js
function es5ClassCompat(target) {
  const interceptFunctions = {
    apply: function(...args) {
      if (args.length === 0) {
        return Reflect.construct(target, []);
      } else {
        const argsList = args.length === 1 ? [] : args[1];
        return Reflect.construct(target, argsList, args[0].constructor);
      }
    },
    call: function(...args) {
      if (args.length === 0) {
        return Reflect.construct(target, []);
      } else {
        const [thisArg, ...restArgs] = args;
        return Reflect.construct(target, restArgs, thisArg.constructor);
      }
    }
  };
  return Object.assign(target, interceptFunctions);
}

// out-build/vs/workbench/api/common/extHostTypes/markdownString.js
var MarkdownString_1;
var MarkdownString2 = MarkdownString_1 = class MarkdownString3 {
  #delegate;
  static isMarkdownString(thing) {
    if (thing instanceof MarkdownString_1) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return thing.appendCodeblock && thing.appendMarkdown && thing.appendText && thing.value !== void 0;
  }
  constructor(value, supportThemeIcons = false) {
    this.#delegate = new MarkdownString(value, { supportThemeIcons });
  }
  get value() {
    return this.#delegate.value;
  }
  set value(value) {
    this.#delegate.value = value;
  }
  get isTrusted() {
    return this.#delegate.isTrusted;
  }
  set isTrusted(value) {
    this.#delegate.isTrusted = value;
  }
  get supportThemeIcons() {
    return this.#delegate.supportThemeIcons;
  }
  set supportThemeIcons(value) {
    this.#delegate.supportThemeIcons = value;
  }
  get supportHtml() {
    return this.#delegate.supportHtml;
  }
  set supportHtml(value) {
    this.#delegate.supportHtml = value;
  }
  get supportAlertSyntax() {
    return this.#delegate.supportAlertSyntax;
  }
  set supportAlertSyntax(value) {
    this.#delegate.supportAlertSyntax = value;
  }
  get baseUri() {
    return this.#delegate.baseUri;
  }
  set baseUri(value) {
    this.#delegate.baseUri = value;
  }
  appendText(value) {
    this.#delegate.appendText(value);
    return this;
  }
  appendMarkdown(value) {
    this.#delegate.appendMarkdown(value);
    return this;
  }
  appendCodeblock(value, language2) {
    this.#delegate.appendCodeblock(language2 ?? "", value);
    return this;
  }
};
MarkdownString2 = MarkdownString_1 = __decorate([
  es5ClassCompat
], MarkdownString2);

// out-build/vs/workbench/api/common/extHostTypes/position.js
var Position_1;
var Position2 = Position_1 = class Position3 {
  static Min(...positions) {
    if (positions.length === 0) {
      throw new TypeError();
    }
    let result = positions[0];
    for (let i = 1; i < positions.length; i++) {
      const p = positions[i];
      if (p.isBefore(result)) {
        result = p;
      }
    }
    return result;
  }
  static Max(...positions) {
    if (positions.length === 0) {
      throw new TypeError();
    }
    let result = positions[0];
    for (let i = 1; i < positions.length; i++) {
      const p = positions[i];
      if (p.isAfter(result)) {
        result = p;
      }
    }
    return result;
  }
  static isPosition(other) {
    if (!other) {
      return false;
    }
    if (other instanceof Position_1) {
      return true;
    }
    const { line, character } = other;
    if (typeof line === "number" && typeof character === "number") {
      return true;
    }
    return false;
  }
  static of(obj) {
    if (obj instanceof Position_1) {
      return obj;
    } else if (this.isPosition(obj)) {
      return new Position_1(obj.line, obj.character);
    }
    throw new Error("Invalid argument, is NOT a position-like object");
  }
  get line() {
    return this._line;
  }
  get character() {
    return this._character;
  }
  constructor(line, character) {
    if (line < 0) {
      throw illegalArgument("line must be non-negative");
    }
    if (character < 0) {
      throw illegalArgument("character must be non-negative");
    }
    this._line = line;
    this._character = character;
  }
  isBefore(other) {
    if (this._line < other._line) {
      return true;
    }
    if (other._line < this._line) {
      return false;
    }
    return this._character < other._character;
  }
  isBeforeOrEqual(other) {
    if (this._line < other._line) {
      return true;
    }
    if (other._line < this._line) {
      return false;
    }
    return this._character <= other._character;
  }
  isAfter(other) {
    return !this.isBeforeOrEqual(other);
  }
  isAfterOrEqual(other) {
    return !this.isBefore(other);
  }
  isEqual(other) {
    return this._line === other._line && this._character === other._character;
  }
  compareTo(other) {
    if (this._line < other._line) {
      return -1;
    } else if (this._line > other.line) {
      return 1;
    } else {
      if (this._character < other._character) {
        return -1;
      } else if (this._character > other._character) {
        return 1;
      } else {
        return 0;
      }
    }
  }
  translate(lineDeltaOrChange, characterDelta = 0) {
    if (lineDeltaOrChange === null || characterDelta === null) {
      throw illegalArgument();
    }
    let lineDelta;
    if (typeof lineDeltaOrChange === "undefined") {
      lineDelta = 0;
    } else if (typeof lineDeltaOrChange === "number") {
      lineDelta = lineDeltaOrChange;
    } else {
      lineDelta = typeof lineDeltaOrChange.lineDelta === "number" ? lineDeltaOrChange.lineDelta : 0;
      characterDelta = typeof lineDeltaOrChange.characterDelta === "number" ? lineDeltaOrChange.characterDelta : 0;
    }
    if (lineDelta === 0 && characterDelta === 0) {
      return this;
    }
    return new Position_1(this.line + lineDelta, this.character + characterDelta);
  }
  with(lineOrChange, character = this.character) {
    if (lineOrChange === null || character === null) {
      throw illegalArgument();
    }
    let line;
    if (typeof lineOrChange === "undefined") {
      line = this.line;
    } else if (typeof lineOrChange === "number") {
      line = lineOrChange;
    } else {
      line = typeof lineOrChange.line === "number" ? lineOrChange.line : this.line;
      character = typeof lineOrChange.character === "number" ? lineOrChange.character : this.character;
    }
    if (line === this.line && character === this.character) {
      return this;
    }
    return new Position_1(line, character);
  }
  toJSON() {
    return { line: this.line, character: this.character };
  }
  [Symbol.for("debug.description")]() {
    return `(${this.line}:${this.character})`;
  }
};
Position2 = Position_1 = __decorate([
  es5ClassCompat
], Position2);

// out-build/vs/workbench/api/common/extHostTypes/range.js
var Range_1;
var Range2 = Range_1 = class Range3 {
  static isRange(thing) {
    if (thing instanceof Range_1) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return Position2.isPosition(thing.start) && Position2.isPosition(thing.end);
  }
  static of(obj) {
    if (obj instanceof Range_1) {
      return obj;
    }
    if (this.isRange(obj)) {
      return new Range_1(obj.start, obj.end);
    }
    throw new Error("Invalid argument, is NOT a range-like object");
  }
  get start() {
    return this._start;
  }
  get end() {
    return this._end;
  }
  constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
    let start;
    let end;
    if (typeof startLineOrStart === "number" && typeof startColumnOrEnd === "number" && typeof endLine === "number" && typeof endColumn === "number") {
      start = new Position2(startLineOrStart, startColumnOrEnd);
      end = new Position2(endLine, endColumn);
    } else if (Position2.isPosition(startLineOrStart) && Position2.isPosition(startColumnOrEnd)) {
      start = Position2.of(startLineOrStart);
      end = Position2.of(startColumnOrEnd);
    }
    if (!start || !end) {
      throw new Error("Invalid arguments");
    }
    if (start.isBefore(end)) {
      this._start = start;
      this._end = end;
    } else {
      this._start = end;
      this._end = start;
    }
  }
  contains(positionOrRange) {
    if (Range_1.isRange(positionOrRange)) {
      return this.contains(positionOrRange.start) && this.contains(positionOrRange.end);
    } else if (Position2.isPosition(positionOrRange)) {
      if (Position2.of(positionOrRange).isBefore(this._start)) {
        return false;
      }
      if (this._end.isBefore(positionOrRange)) {
        return false;
      }
      return true;
    }
    return false;
  }
  isEqual(other) {
    return this._start.isEqual(other._start) && this._end.isEqual(other._end);
  }
  intersection(other) {
    const start = Position2.Max(other.start, this._start);
    const end = Position2.Min(other.end, this._end);
    if (start.isAfter(end)) {
      return void 0;
    }
    return new Range_1(start, end);
  }
  union(other) {
    if (this.contains(other)) {
      return this;
    } else if (other.contains(this)) {
      return other;
    }
    const start = Position2.Min(other.start, this._start);
    const end = Position2.Max(other.end, this.end);
    return new Range_1(start, end);
  }
  get isEmpty() {
    return this._start.isEqual(this._end);
  }
  get isSingleLine() {
    return this._start.line === this._end.line;
  }
  with(startOrChange, end = this.end) {
    if (startOrChange === null || end === null) {
      throw illegalArgument();
    }
    let start;
    if (!startOrChange) {
      start = this.start;
    } else if (Position2.isPosition(startOrChange)) {
      start = startOrChange;
    } else {
      start = startOrChange.start || this.start;
      end = startOrChange.end || this.end;
    }
    if (start.isEqual(this._start) && end.isEqual(this.end)) {
      return this;
    }
    return new Range_1(start, end);
  }
  toJSON() {
    return [this.start, this.end];
  }
  [Symbol.for("debug.description")]() {
    return getDebugDescriptionOfRange(this);
  }
};
Range2 = Range_1 = __decorate([
  es5ClassCompat
], Range2);
function getDebugDescriptionOfRange(range) {
  return range.isEmpty ? `[${range.start.line}:${range.start.character})` : `[${range.start.line}:${range.start.character} -> ${range.end.line}:${range.end.character})`;
}

// out-build/vs/workbench/api/common/extHostTypes/codeActionKind.js
var CodeActionKind_1;
var CodeActionKind = class CodeActionKind2 {
  static {
    CodeActionKind_1 = this;
  }
  static {
    this.sep = ".";
  }
  constructor(value) {
    this.value = value;
  }
  append(parts) {
    return new CodeActionKind_1(this.value ? this.value + CodeActionKind_1.sep + parts : parts);
  }
  intersects(other) {
    return this.contains(other) || other.contains(this);
  }
  contains(other) {
    return this.value === other.value || other.value.startsWith(this.value + CodeActionKind_1.sep);
  }
};
CodeActionKind = CodeActionKind_1 = __decorate([
  es5ClassCompat
], CodeActionKind);
CodeActionKind.Empty = new CodeActionKind("");
CodeActionKind.QuickFix = CodeActionKind.Empty.append("quickfix");
CodeActionKind.Refactor = CodeActionKind.Empty.append("refactor");
CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append("extract");
CodeActionKind.RefactorInline = CodeActionKind.Refactor.append("inline");
CodeActionKind.RefactorMove = CodeActionKind.Refactor.append("move");
CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append("rewrite");
CodeActionKind.Source = CodeActionKind.Empty.append("source");
CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
CodeActionKind.Notebook = CodeActionKind.Empty.append("notebook");

// out-build/vs/workbench/api/common/extHostTypes/diagnostic.js
var DiagnosticTag;
(function(DiagnosticTag3) {
  DiagnosticTag3[DiagnosticTag3["Unnecessary"] = 1] = "Unnecessary";
  DiagnosticTag3[DiagnosticTag3["Deprecated"] = 2] = "Deprecated";
})(DiagnosticTag || (DiagnosticTag = {}));
var DiagnosticSeverity;
(function(DiagnosticSeverity3) {
  DiagnosticSeverity3[DiagnosticSeverity3["Hint"] = 3] = "Hint";
  DiagnosticSeverity3[DiagnosticSeverity3["Information"] = 2] = "Information";
  DiagnosticSeverity3[DiagnosticSeverity3["Warning"] = 1] = "Warning";
  DiagnosticSeverity3[DiagnosticSeverity3["Error"] = 0] = "Error";
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var DiagnosticRelatedInformation = class DiagnosticRelatedInformation2 {
  static is(thing) {
    if (!thing) {
      return false;
    }
    return typeof thing.message === "string" && thing.location && Range2.isRange(thing.location.range) && URI.isUri(thing.location.uri);
  }
  constructor(location2, message) {
    this.location = location2;
    this.message = message;
  }
  static isEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.message === b.message && a.location.range.isEqual(b.location.range) && a.location.uri.toString() === b.location.uri.toString();
  }
};
DiagnosticRelatedInformation = __decorate([
  es5ClassCompat
], DiagnosticRelatedInformation);
var Diagnostic = class Diagnostic2 {
  constructor(range, message, severity = DiagnosticSeverity.Error) {
    if (!Range2.isRange(range)) {
      throw new TypeError("range must be set");
    }
    if (!message) {
      throw new TypeError("message must be set");
    }
    this.range = range;
    this.message = message;
    this.severity = severity;
  }
  toJSON() {
    return {
      severity: DiagnosticSeverity[this.severity],
      message: this.message,
      range: this.range,
      source: this.source,
      code: this.code
    };
  }
  static isEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.message === b.message && a.severity === b.severity && a.code === b.code && a.severity === b.severity && a.source === b.source && a.range.isEqual(b.range) && equals(a.tags, b.tags) && equals(a.relatedInformation, b.relatedInformation, DiagnosticRelatedInformation.isEqual);
  }
};
Diagnostic = __decorate([
  es5ClassCompat
], Diagnostic);

// out-build/vs/workbench/api/common/extHostTypes/location.js
var Location_1;
var Location = Location_1 = class Location2 {
  static isLocation(thing) {
    if (thing instanceof Location_1) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return Range2.isRange(thing.range) && URI.isUri(thing.uri);
  }
  constructor(uri, rangeOrPosition) {
    this.uri = uri;
    if (!rangeOrPosition) {
    } else if (Range2.isRange(rangeOrPosition)) {
      this.range = Range2.of(rangeOrPosition);
    } else if (Position2.isPosition(rangeOrPosition)) {
      this.range = new Range2(rangeOrPosition, rangeOrPosition);
    } else {
      throw new Error("Illegal argument");
    }
  }
  toJSON() {
    return {
      uri: this.uri,
      range: this.range
    };
  }
};
Location = Location_1 = __decorate([
  es5ClassCompat
], Location);

// out-build/vs/workbench/api/common/extHostTypes/notebooks.js
var NotebookEdit_1;
var NotebookCellKind;
(function(NotebookCellKind3) {
  NotebookCellKind3[NotebookCellKind3["Markup"] = 1] = "Markup";
  NotebookCellKind3[NotebookCellKind3["Code"] = 2] = "Code";
})(NotebookCellKind || (NotebookCellKind = {}));
var NotebookRange = class _NotebookRange {
  static isNotebookRange(thing) {
    if (thing instanceof _NotebookRange) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.start === "number" && typeof thing.end === "number";
  }
  get start() {
    return this._start;
  }
  get end() {
    return this._end;
  }
  get isEmpty() {
    return this._start === this._end;
  }
  constructor(start, end) {
    if (start < 0) {
      throw illegalArgument("start must be positive");
    }
    if (end < 0) {
      throw illegalArgument("end must be positive");
    }
    if (start <= end) {
      this._start = start;
      this._end = end;
    } else {
      this._start = end;
      this._end = start;
    }
  }
  with(change) {
    let start = this._start;
    let end = this._end;
    if (change.start !== void 0) {
      start = change.start;
    }
    if (change.end !== void 0) {
      end = change.end;
    }
    if (start === this._start && end === this._end) {
      return this;
    }
    return new _NotebookRange(start, end);
  }
};
var NotebookCellData = class _NotebookCellData {
  static validate(data2) {
    if (typeof data2.kind !== "number") {
      throw new Error("NotebookCellData MUST have 'kind' property");
    }
    if (typeof data2.value !== "string") {
      throw new Error("NotebookCellData MUST have 'value' property");
    }
    if (typeof data2.languageId !== "string") {
      throw new Error("NotebookCellData MUST have 'languageId' property");
    }
  }
  static isNotebookCellDataArray(value) {
    return Array.isArray(value) && value.every((elem) => _NotebookCellData.isNotebookCellData(elem));
  }
  static isNotebookCellData(value) {
    return true;
  }
  constructor(kind, value, languageId, mime, outputs, metadata, executionSummary) {
    this.kind = kind;
    this.value = value;
    this.languageId = languageId;
    this.mime = mime;
    this.outputs = outputs ?? [];
    this.metadata = metadata;
    this.executionSummary = executionSummary;
    _NotebookCellData.validate(this);
  }
};
var NotebookData = class {
  constructor(cells) {
    this.cells = cells;
  }
};
var NotebookEdit = NotebookEdit_1 = class NotebookEdit2 {
  static isNotebookCellEdit(thing) {
    if (thing instanceof NotebookEdit_1) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return NotebookRange.isNotebookRange(thing) && Array.isArray(thing.newCells);
  }
  static replaceCells(range, newCells) {
    return new NotebookEdit_1(range, newCells);
  }
  static insertCells(index, newCells) {
    return new NotebookEdit_1(new NotebookRange(index, index), newCells);
  }
  static deleteCells(range) {
    return new NotebookEdit_1(range, []);
  }
  static updateCellMetadata(index, newMetadata) {
    const edit2 = new NotebookEdit_1(new NotebookRange(index, index), []);
    edit2.newCellMetadata = newMetadata;
    return edit2;
  }
  static updateNotebookMetadata(newMetadata) {
    const edit2 = new NotebookEdit_1(new NotebookRange(0, 0), []);
    edit2.newNotebookMetadata = newMetadata;
    return edit2;
  }
  constructor(range, newCells) {
    this.range = range;
    this.newCells = newCells;
  }
};
NotebookEdit = NotebookEdit_1 = __decorate([
  es5ClassCompat
], NotebookEdit);
var NotebookCellOutputItem = class _NotebookCellOutputItem {
  static isNotebookCellOutputItem(obj) {
    if (obj instanceof _NotebookCellOutputItem) {
      return true;
    }
    if (!obj) {
      return false;
    }
    return typeof obj.mime === "string" && obj.data instanceof Uint8Array;
  }
  static error(err) {
    const obj = {
      name: err.name,
      message: err.message,
      stack: err.stack
    };
    return _NotebookCellOutputItem.json(obj, "application/vnd.code.notebook.error");
  }
  static stdout(value) {
    return _NotebookCellOutputItem.text(value, "application/vnd.code.notebook.stdout");
  }
  static stderr(value) {
    return _NotebookCellOutputItem.text(value, "application/vnd.code.notebook.stderr");
  }
  static bytes(value, mime = "application/octet-stream") {
    return new _NotebookCellOutputItem(value, mime);
  }
  static #encoder = new TextEncoder();
  static text(value, mime = Mimes.text) {
    const bytes = _NotebookCellOutputItem.#encoder.encode(String(value));
    return new _NotebookCellOutputItem(bytes, mime);
  }
  static json(value, mime = "text/x-json") {
    const rawStr = JSON.stringify(value, void 0, "	");
    return _NotebookCellOutputItem.text(rawStr, mime);
  }
  constructor(data2, mime) {
    this.data = data2;
    this.mime = mime;
    const mimeNormalized = normalizeMimeType(mime, true);
    if (!mimeNormalized) {
      throw new Error(`INVALID mime type: ${mime}. Must be in the format "type/subtype[;optionalparameter]"`);
    }
    this.mime = mimeNormalized;
  }
};
var NotebookCellOutput = class _NotebookCellOutput {
  static isNotebookCellOutput(candidate) {
    if (candidate instanceof _NotebookCellOutput) {
      return true;
    }
    if (!candidate || typeof candidate !== "object") {
      return false;
    }
    return typeof candidate.id === "string" && Array.isArray(candidate.items);
  }
  static ensureUniqueMimeTypes(items, warn = false) {
    const seen = /* @__PURE__ */ new Set();
    const removeIdx = /* @__PURE__ */ new Set();
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const normalMime = normalizeMimeType(item.mime);
      if (!seen.has(normalMime) || isTextStreamMime(normalMime)) {
        seen.add(normalMime);
        continue;
      }
      removeIdx.add(i);
      if (warn) {
        console.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);
      }
    }
    if (removeIdx.size === 0) {
      return items;
    }
    return items.filter((_item, index) => !removeIdx.has(index));
  }
  constructor(items, idOrMetadata, metadata) {
    this.items = _NotebookCellOutput.ensureUniqueMimeTypes(items, true);
    if (typeof idOrMetadata === "string") {
      this.id = idOrMetadata;
      this.metadata = metadata;
    } else {
      this.id = generateUuid();
      this.metadata = idOrMetadata ?? metadata;
    }
  }
};

// out-build/vs/workbench/api/common/extHostTypes/selection.js
var Selection_1;
var Selection = Selection_1 = class Selection2 extends Range2 {
  static isSelection(thing) {
    if (thing instanceof Selection_1) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return Range2.isRange(thing) && Position2.isPosition(thing.anchor) && Position2.isPosition(thing.active) && typeof thing.isReversed === "boolean";
  }
  get anchor() {
    return this._anchor;
  }
  get active() {
    return this._active;
  }
  constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
    let anchor;
    let active;
    if (typeof anchorLineOrAnchor === "number" && typeof anchorColumnOrActive === "number" && typeof activeLine === "number" && typeof activeColumn === "number") {
      anchor = new Position2(anchorLineOrAnchor, anchorColumnOrActive);
      active = new Position2(activeLine, activeColumn);
    } else if (Position2.isPosition(anchorLineOrAnchor) && Position2.isPosition(anchorColumnOrActive)) {
      anchor = Position2.of(anchorLineOrAnchor);
      active = Position2.of(anchorColumnOrActive);
    }
    if (!anchor || !active) {
      throw new Error("Invalid arguments");
    }
    super(anchor, active);
    this._anchor = anchor;
    this._active = active;
  }
  get isReversed() {
    return this._anchor === this._end;
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end,
      active: this.active,
      anchor: this.anchor
    };
  }
  [Symbol.for("debug.description")]() {
    return getDebugDescriptionOfSelection(this);
  }
};
Selection = Selection_1 = __decorate([
  es5ClassCompat
], Selection);
function getDebugDescriptionOfSelection(selection) {
  let rangeStr = getDebugDescriptionOfRange(selection);
  if (!selection.isEmpty) {
    if (selection.active.isEqual(selection.start)) {
      rangeStr = `|${rangeStr}`;
    } else {
      rangeStr = `${rangeStr}|`;
    }
  }
  return rangeStr;
}

// out-build/vs/workbench/api/common/extHostTypes/snippetString.js
var SnippetString_1;
var SnippetString = SnippetString_1 = class SnippetString2 {
  static isSnippetString(thing) {
    if (thing instanceof SnippetString_1) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.value === "string";
  }
  static _escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  constructor(value) {
    this._tabstop = 1;
    this.value = value || "";
  }
  appendText(string) {
    this.value += SnippetString_1._escape(string);
    return this;
  }
  appendTabstop(number = this._tabstop++) {
    this.value += "$";
    this.value += number;
    return this;
  }
  appendPlaceholder(value, number = this._tabstop++) {
    if (typeof value === "function") {
      const nested = new SnippetString_1();
      nested._tabstop = this._tabstop;
      value(nested);
      this._tabstop = nested._tabstop;
      value = nested.value;
    } else {
      value = SnippetString_1._escape(value);
    }
    this.value += "${";
    this.value += number;
    this.value += ":";
    this.value += value;
    this.value += "}";
    return this;
  }
  appendChoice(values, number = this._tabstop++) {
    const value = values.map((s) => s.replaceAll(/[|\\,]/g, "\\$&")).join(",");
    this.value += "${";
    this.value += number;
    this.value += "|";
    this.value += value;
    this.value += "|}";
    return this;
  }
  appendVariable(name2, defaultValue) {
    if (typeof defaultValue === "function") {
      const nested = new SnippetString_1();
      nested._tabstop = this._tabstop;
      defaultValue(nested);
      this._tabstop = nested._tabstop;
      defaultValue = nested.value;
    } else if (typeof defaultValue === "string") {
      defaultValue = defaultValue.replace(/\$|}/g, "\\$&");
    }
    this.value += "${";
    this.value += name2;
    if (defaultValue) {
      this.value += ":";
      this.value += defaultValue;
    }
    this.value += "}";
    return this;
  }
};
SnippetString = SnippetString_1 = __decorate([
  es5ClassCompat
], SnippetString);

// out-build/vs/workbench/api/common/extHostTypes/snippetTextEdit.js
var SnippetTextEdit = class _SnippetTextEdit {
  static isSnippetTextEdit(thing) {
    if (thing instanceof _SnippetTextEdit) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return Range2.isRange(thing.range) && SnippetString.isSnippetString(thing.snippet);
  }
  static replace(range, snippet) {
    return new _SnippetTextEdit(range, snippet);
  }
  static insert(position, snippet) {
    return _SnippetTextEdit.replace(new Range2(position, position), snippet);
  }
  constructor(range, snippet) {
    this.range = range;
    this.snippet = snippet;
  }
};

// out-build/vs/workbench/api/common/extHostTypes/symbolInformation.js
var SymbolInformation_1;
var SymbolKind2;
(function(SymbolKind4) {
  SymbolKind4[SymbolKind4["File"] = 0] = "File";
  SymbolKind4[SymbolKind4["Module"] = 1] = "Module";
  SymbolKind4[SymbolKind4["Namespace"] = 2] = "Namespace";
  SymbolKind4[SymbolKind4["Package"] = 3] = "Package";
  SymbolKind4[SymbolKind4["Class"] = 4] = "Class";
  SymbolKind4[SymbolKind4["Method"] = 5] = "Method";
  SymbolKind4[SymbolKind4["Property"] = 6] = "Property";
  SymbolKind4[SymbolKind4["Field"] = 7] = "Field";
  SymbolKind4[SymbolKind4["Constructor"] = 8] = "Constructor";
  SymbolKind4[SymbolKind4["Enum"] = 9] = "Enum";
  SymbolKind4[SymbolKind4["Interface"] = 10] = "Interface";
  SymbolKind4[SymbolKind4["Function"] = 11] = "Function";
  SymbolKind4[SymbolKind4["Variable"] = 12] = "Variable";
  SymbolKind4[SymbolKind4["Constant"] = 13] = "Constant";
  SymbolKind4[SymbolKind4["String"] = 14] = "String";
  SymbolKind4[SymbolKind4["Number"] = 15] = "Number";
  SymbolKind4[SymbolKind4["Boolean"] = 16] = "Boolean";
  SymbolKind4[SymbolKind4["Array"] = 17] = "Array";
  SymbolKind4[SymbolKind4["Object"] = 18] = "Object";
  SymbolKind4[SymbolKind4["Key"] = 19] = "Key";
  SymbolKind4[SymbolKind4["Null"] = 20] = "Null";
  SymbolKind4[SymbolKind4["EnumMember"] = 21] = "EnumMember";
  SymbolKind4[SymbolKind4["Struct"] = 22] = "Struct";
  SymbolKind4[SymbolKind4["Event"] = 23] = "Event";
  SymbolKind4[SymbolKind4["Operator"] = 24] = "Operator";
  SymbolKind4[SymbolKind4["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind2 || (SymbolKind2 = {}));
var SymbolTag2;
(function(SymbolTag4) {
  SymbolTag4[SymbolTag4["Deprecated"] = 1] = "Deprecated";
})(SymbolTag2 || (SymbolTag2 = {}));
var SymbolInformation = SymbolInformation_1 = class SymbolInformation2 {
  static validate(candidate) {
    if (!candidate.name) {
      throw new Error("name must not be falsy");
    }
  }
  constructor(name2, kind, rangeOrContainer, locationOrUri, containerName) {
    this.name = name2;
    this.kind = kind;
    this.containerName = containerName;
    if (typeof rangeOrContainer === "string") {
      this.containerName = rangeOrContainer;
    }
    if (locationOrUri instanceof Location) {
      this.location = locationOrUri;
    } else if (rangeOrContainer instanceof Range2) {
      this.location = new Location(locationOrUri, rangeOrContainer);
    }
    SymbolInformation_1.validate(this);
  }
  toJSON() {
    return {
      name: this.name,
      kind: SymbolKind2[this.kind],
      location: this.location,
      containerName: this.containerName
    };
  }
};
SymbolInformation = SymbolInformation_1 = __decorate([
  es5ClassCompat
], SymbolInformation);

// out-build/vs/workbench/api/common/extHostTypes/textEdit.js
var TextEdit_1;
var EndOfLine;
(function(EndOfLine3) {
  EndOfLine3[EndOfLine3["LF"] = 1] = "LF";
  EndOfLine3[EndOfLine3["CRLF"] = 2] = "CRLF";
})(EndOfLine || (EndOfLine = {}));
var TextEdit = TextEdit_1 = class TextEdit2 {
  static isTextEdit(thing) {
    if (thing instanceof TextEdit_1) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return Range2.isRange(thing) && typeof thing.newText === "string";
  }
  static replace(range, newText) {
    return new TextEdit_1(range, newText);
  }
  static insert(position, newText) {
    return TextEdit_1.replace(new Range2(position, position), newText);
  }
  static delete(range) {
    return TextEdit_1.replace(range, "");
  }
  static setEndOfLine(eol) {
    const ret = new TextEdit_1(new Range2(new Position2(0, 0), new Position2(0, 0)), "");
    ret.newEol = eol;
    return ret;
  }
  get range() {
    return this._range;
  }
  set range(value) {
    if (value && !Range2.isRange(value)) {
      throw illegalArgument("range");
    }
    this._range = value;
  }
  get newText() {
    return this._newText || "";
  }
  set newText(value) {
    if (value && typeof value !== "string") {
      throw illegalArgument("newText");
    }
    this._newText = value;
  }
  get newEol() {
    return this._newEol;
  }
  set newEol(value) {
    if (value && typeof value !== "number") {
      throw illegalArgument("newEol");
    }
    this._newEol = value;
  }
  constructor(range, newText) {
    this._range = range;
    this._newText = newText;
  }
  toJSON() {
    return {
      range: this.range,
      newText: this.newText,
      newEol: this._newEol
    };
  }
};
TextEdit = TextEdit_1 = __decorate([
  es5ClassCompat
], TextEdit);

// out-build/vs/workbench/api/common/extHostTypes/workspaceEdit.js
var FileEditType;
(function(FileEditType2) {
  FileEditType2[FileEditType2["File"] = 1] = "File";
  FileEditType2[FileEditType2["Text"] = 2] = "Text";
  FileEditType2[FileEditType2["Cell"] = 3] = "Cell";
  FileEditType2[FileEditType2["CellReplace"] = 5] = "CellReplace";
  FileEditType2[FileEditType2["Snippet"] = 6] = "Snippet";
})(FileEditType || (FileEditType = {}));
var WorkspaceEdit = class WorkspaceEdit2 {
  constructor() {
    this._edits = [];
  }
  _allEntries() {
    return this._edits;
  }
  // --- file
  renameFile(from, to, options2, metadata) {
    this._edits.push({ _type: 1, from, to, options: options2, metadata });
  }
  createFile(uri, options2, metadata) {
    this._edits.push({ _type: 1, from: void 0, to: uri, options: options2, metadata });
  }
  deleteFile(uri, options2, metadata) {
    this._edits.push({ _type: 1, from: uri, to: void 0, options: options2, metadata });
  }
  // --- notebook
  replaceNotebookMetadata(uri, value, metadata) {
    this._edits.push({ _type: 3, metadata, uri, edit: { editType: 5, metadata: value } });
  }
  replaceNotebookCells(uri, startOrRange, cellData, metadata) {
    const start = startOrRange.start;
    const end = startOrRange.end;
    if (start !== end || cellData.length > 0) {
      this._edits.push({ _type: 5, uri, index: start, count: end - start, cells: cellData, metadata });
    }
  }
  replaceNotebookCellMetadata(uri, index, cellMetadata, metadata) {
    this._edits.push({ _type: 3, metadata, uri, edit: { editType: 3, index, metadata: cellMetadata } });
  }
  // --- text
  replace(uri, range, newText, metadata) {
    this._edits.push({ _type: 2, uri, edit: new TextEdit(range, newText), metadata });
  }
  insert(resource, position, newText, metadata) {
    this.replace(resource, new Range2(position, position), newText, metadata);
  }
  delete(resource, range, metadata) {
    this.replace(resource, range, "", metadata);
  }
  // --- text (Maplike)
  has(uri) {
    return this._edits.some((edit2) => edit2._type === 2 && edit2.uri.toString() === uri.toString());
  }
  set(uri, edits) {
    if (!edits) {
      for (let i = 0; i < this._edits.length; i++) {
        const element = this._edits[i];
        switch (element._type) {
          case 2:
          case 6:
          case 3:
          case 5:
            if (element.uri.toString() === uri.toString()) {
              this._edits[i] = void 0;
            }
            break;
        }
      }
      coalesceInPlace(this._edits);
    } else {
      for (const editOrTuple of edits) {
        if (!editOrTuple) {
          continue;
        }
        let edit2;
        let metadata;
        if (Array.isArray(editOrTuple)) {
          edit2 = editOrTuple[0];
          metadata = editOrTuple[1];
        } else {
          edit2 = editOrTuple;
        }
        if (NotebookEdit.isNotebookCellEdit(edit2)) {
          if (edit2.newCellMetadata) {
            this.replaceNotebookCellMetadata(uri, edit2.range.start, edit2.newCellMetadata, metadata);
          } else if (edit2.newNotebookMetadata) {
            this.replaceNotebookMetadata(uri, edit2.newNotebookMetadata, metadata);
          } else {
            this.replaceNotebookCells(uri, edit2.range, edit2.newCells, metadata);
          }
        } else if (SnippetTextEdit.isSnippetTextEdit(edit2)) {
          this._edits.push({ _type: 6, uri, range: edit2.range, edit: edit2.snippet, metadata, keepWhitespace: edit2.keepWhitespace });
        } else {
          this._edits.push({ _type: 2, uri, edit: edit2, metadata });
        }
      }
    }
  }
  get(uri) {
    const res = [];
    for (const candidate of this._edits) {
      if (candidate._type === 2 && candidate.uri.toString() === uri.toString()) {
        res.push(candidate.edit);
      }
    }
    return res;
  }
  entries() {
    const textEdits = new ResourceMap();
    for (const candidate of this._edits) {
      if (candidate._type === 2) {
        let textEdit = textEdits.get(candidate.uri);
        if (!textEdit) {
          textEdit = [candidate.uri, []];
          textEdits.set(candidate.uri, textEdit);
        }
        textEdit[1].push(candidate.edit);
      }
    }
    return [...textEdits.values()];
  }
  get size() {
    return this.entries().length;
  }
  toJSON() {
    return this.entries();
  }
};
WorkspaceEdit = __decorate([
  es5ClassCompat
], WorkspaceEdit);

// out-build/vs/workbench/api/common/extHostTypes.js
var Disposable_1;
var DocumentSymbol_1;
var TaskGroup_1;
var Task_1;
var TreeItem_1;
var FileSystemError_1;
var TestMessage_1;
var TerminalOutputAnchor;
(function(TerminalOutputAnchor2) {
  TerminalOutputAnchor2[TerminalOutputAnchor2["Top"] = 0] = "Top";
  TerminalOutputAnchor2[TerminalOutputAnchor2["Bottom"] = 1] = "Bottom";
})(TerminalOutputAnchor || (TerminalOutputAnchor = {}));
var TerminalQuickFixType;
(function(TerminalQuickFixType2) {
  TerminalQuickFixType2[TerminalQuickFixType2["TerminalCommand"] = 0] = "TerminalCommand";
  TerminalQuickFixType2[TerminalQuickFixType2["Opener"] = 1] = "Opener";
  TerminalQuickFixType2[TerminalQuickFixType2["Command"] = 3] = "Command";
})(TerminalQuickFixType || (TerminalQuickFixType = {}));
var Disposable2 = Disposable_1 = class Disposable3 {
  static from(...inDisposables) {
    let disposables = inDisposables;
    return new Disposable_1(function() {
      if (disposables) {
        for (const disposable of disposables) {
          if (disposable && typeof disposable.dispose === "function") {
            disposable.dispose();
          }
        }
        disposables = void 0;
      }
    });
  }
  #callOnDispose;
  constructor(callOnDispose) {
    this.#callOnDispose = callOnDispose;
  }
  dispose() {
    if (typeof this.#callOnDispose === "function") {
      this.#callOnDispose();
      this.#callOnDispose = void 0;
    }
  }
};
Disposable2 = Disposable_1 = __decorate([
  es5ClassCompat
], Disposable2);
var validateConnectionToken = (connectionToken) => {
  if (typeof connectionToken !== "string" || connectionToken.length === 0 || !/^[0-9A-Za-z_\-]+$/.test(connectionToken)) {
    throw illegalArgument("connectionToken");
  }
};
var ResolvedAuthority = class {
  static isResolvedAuthority(resolvedAuthority) {
    return resolvedAuthority && typeof resolvedAuthority === "object" && typeof resolvedAuthority.host === "string" && typeof resolvedAuthority.port === "number" && (resolvedAuthority.connectionToken === void 0 || typeof resolvedAuthority.connectionToken === "string");
  }
  constructor(host, port, connectionToken) {
    if (typeof host !== "string" || host.length === 0) {
      throw illegalArgument("host");
    }
    if (typeof port !== "number" || port === 0 || Math.round(port) !== port) {
      throw illegalArgument("port");
    }
    if (typeof connectionToken !== "undefined") {
      validateConnectionToken(connectionToken);
    }
    this.host = host;
    this.port = Math.round(port);
    this.connectionToken = connectionToken;
  }
};
var ManagedResolvedAuthority = class {
  static isManagedResolvedAuthority(resolvedAuthority) {
    return resolvedAuthority && typeof resolvedAuthority === "object" && typeof resolvedAuthority.makeConnection === "function" && (resolvedAuthority.connectionToken === void 0 || typeof resolvedAuthority.connectionToken === "string");
  }
  constructor(makeConnection, connectionToken) {
    this.makeConnection = makeConnection;
    this.connectionToken = connectionToken;
    if (typeof connectionToken !== "undefined") {
      validateConnectionToken(connectionToken);
    }
  }
};
var RemoteAuthorityResolverError = class _RemoteAuthorityResolverError extends Error {
  static NotAvailable(message, handled) {
    return new _RemoteAuthorityResolverError(message, RemoteAuthorityResolverErrorCode.NotAvailable, handled);
  }
  static TemporarilyNotAvailable(message) {
    return new _RemoteAuthorityResolverError(message, RemoteAuthorityResolverErrorCode.TemporarilyNotAvailable);
  }
  constructor(message, code = RemoteAuthorityResolverErrorCode.Unknown, detail) {
    super(message);
    this._message = message;
    this._code = code;
    this._detail = detail;
    Object.setPrototypeOf(this, _RemoteAuthorityResolverError.prototype);
  }
};
var EnvironmentVariableMutatorType;
(function(EnvironmentVariableMutatorType2) {
  EnvironmentVariableMutatorType2[EnvironmentVariableMutatorType2["Replace"] = 1] = "Replace";
  EnvironmentVariableMutatorType2[EnvironmentVariableMutatorType2["Append"] = 2] = "Append";
  EnvironmentVariableMutatorType2[EnvironmentVariableMutatorType2["Prepend"] = 3] = "Prepend";
})(EnvironmentVariableMutatorType || (EnvironmentVariableMutatorType = {}));
var Hover = class Hover2 {
  constructor(contents, range) {
    if (!contents) {
      throw new Error("Illegal argument, contents must be defined");
    }
    if (Array.isArray(contents)) {
      this.contents = contents;
    } else {
      this.contents = [contents];
    }
    this.range = range;
  }
};
Hover = __decorate([
  es5ClassCompat
], Hover);
var VerboseHover = class VerboseHover2 extends Hover {
  constructor(contents, range, canIncreaseVerbosity, canDecreaseVerbosity) {
    super(contents, range);
    this.canIncreaseVerbosity = canIncreaseVerbosity;
    this.canDecreaseVerbosity = canDecreaseVerbosity;
  }
};
VerboseHover = __decorate([
  es5ClassCompat
], VerboseHover);
var HoverVerbosityAction2;
(function(HoverVerbosityAction3) {
  HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
  HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
})(HoverVerbosityAction2 || (HoverVerbosityAction2 = {}));
var DocumentHighlightKind2;
(function(DocumentHighlightKind3) {
  DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
  DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
  DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
})(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
var DocumentHighlight = class DocumentHighlight2 {
  constructor(range, kind = DocumentHighlightKind2.Text) {
    this.range = range;
    this.kind = kind;
  }
  toJSON() {
    return {
      range: this.range,
      kind: DocumentHighlightKind2[this.kind]
    };
  }
};
DocumentHighlight = __decorate([
  es5ClassCompat
], DocumentHighlight);
var MultiDocumentHighlight = class MultiDocumentHighlight2 {
  constructor(uri, highlights) {
    this.uri = uri;
    this.highlights = highlights;
  }
  toJSON() {
    return {
      uri: this.uri,
      highlights: this.highlights.map((h) => h.toJSON())
    };
  }
};
MultiDocumentHighlight = __decorate([
  es5ClassCompat
], MultiDocumentHighlight);
var DocumentSymbol = DocumentSymbol_1 = class DocumentSymbol2 {
  static validate(candidate) {
    if (!candidate.name) {
      throw new Error("name must not be falsy");
    }
    if (!candidate.range.contains(candidate.selectionRange)) {
      throw new Error("selectionRange must be contained in fullRange");
    }
    candidate.children?.forEach(DocumentSymbol_1.validate);
  }
  constructor(name2, detail, kind, range, selectionRange) {
    this.name = name2;
    this.detail = detail;
    this.kind = kind;
    this.range = range;
    this.selectionRange = selectionRange;
    this.children = [];
    DocumentSymbol_1.validate(this);
  }
};
DocumentSymbol = DocumentSymbol_1 = __decorate([
  es5ClassCompat
], DocumentSymbol);
var CodeActionTriggerKind;
(function(CodeActionTriggerKind3) {
  CodeActionTriggerKind3[CodeActionTriggerKind3["Invoke"] = 1] = "Invoke";
  CodeActionTriggerKind3[CodeActionTriggerKind3["Automatic"] = 2] = "Automatic";
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
var CodeAction = class CodeAction2 {
  constructor(title, kind) {
    this.title = title;
    this.kind = kind;
  }
};
CodeAction = __decorate([
  es5ClassCompat
], CodeAction);
var SelectionRange = class SelectionRange2 {
  constructor(range, parent) {
    this.range = range;
    this.parent = parent;
    if (parent && !parent.range.contains(this.range)) {
      throw new Error("Invalid argument: parent must contain this range");
    }
  }
};
SelectionRange = __decorate([
  es5ClassCompat
], SelectionRange);
var CallHierarchyItem = class {
  constructor(kind, name2, detail, uri, range, selectionRange) {
    this.kind = kind;
    this.name = name2;
    this.detail = detail;
    this.uri = uri;
    this.range = range;
    this.selectionRange = selectionRange;
  }
};
var CallHierarchyIncomingCall = class {
  constructor(item, fromRanges) {
    this.fromRanges = fromRanges;
    this.from = item;
  }
};
var CallHierarchyOutgoingCall = class {
  constructor(item, fromRanges) {
    this.fromRanges = fromRanges;
    this.to = item;
  }
};
var LanguageStatusSeverity;
(function(LanguageStatusSeverity2) {
  LanguageStatusSeverity2[LanguageStatusSeverity2["Information"] = 0] = "Information";
  LanguageStatusSeverity2[LanguageStatusSeverity2["Warning"] = 1] = "Warning";
  LanguageStatusSeverity2[LanguageStatusSeverity2["Error"] = 2] = "Error";
})(LanguageStatusSeverity || (LanguageStatusSeverity = {}));
var CodeLens = class CodeLens2 {
  constructor(range, command) {
    this.range = range;
    this.command = command;
  }
  get isResolved() {
    return !!this.command;
  }
};
CodeLens = __decorate([
  es5ClassCompat
], CodeLens);
var ParameterInformation = class ParameterInformation2 {
  constructor(label, documentation) {
    this.label = label;
    this.documentation = documentation;
  }
};
ParameterInformation = __decorate([
  es5ClassCompat
], ParameterInformation);
var SignatureInformation = class SignatureInformation2 {
  constructor(label, documentation) {
    this.label = label;
    this.documentation = documentation;
    this.parameters = [];
  }
};
SignatureInformation = __decorate([
  es5ClassCompat
], SignatureInformation);
var SignatureHelp = class SignatureHelp2 {
  constructor() {
    this.activeSignature = 0;
    this.activeParameter = 0;
    this.signatures = [];
  }
};
SignatureHelp = __decorate([
  es5ClassCompat
], SignatureHelp);
var SignatureHelpTriggerKind2;
(function(SignatureHelpTriggerKind3) {
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
var InlayHintKind2;
(function(InlayHintKind4) {
  InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
  InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
})(InlayHintKind2 || (InlayHintKind2 = {}));
var InlayHintLabelPart = class InlayHintLabelPart2 {
  constructor(value) {
    this.value = value;
  }
};
InlayHintLabelPart = __decorate([
  es5ClassCompat
], InlayHintLabelPart);
var InlayHint = class InlayHint2 {
  constructor(position, label, kind) {
    this.position = position;
    this.label = label;
    this.kind = kind;
  }
};
InlayHint = __decorate([
  es5ClassCompat
], InlayHint);
var CompletionTriggerKind2;
(function(CompletionTriggerKind4) {
  CompletionTriggerKind4[CompletionTriggerKind4["Invoke"] = 0] = "Invoke";
  CompletionTriggerKind4[CompletionTriggerKind4["TriggerCharacter"] = 1] = "TriggerCharacter";
  CompletionTriggerKind4[CompletionTriggerKind4["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind2 || (CompletionTriggerKind2 = {}));
var CompletionItemKind2;
(function(CompletionItemKind4) {
  CompletionItemKind4[CompletionItemKind4["Text"] = 0] = "Text";
  CompletionItemKind4[CompletionItemKind4["Method"] = 1] = "Method";
  CompletionItemKind4[CompletionItemKind4["Function"] = 2] = "Function";
  CompletionItemKind4[CompletionItemKind4["Constructor"] = 3] = "Constructor";
  CompletionItemKind4[CompletionItemKind4["Field"] = 4] = "Field";
  CompletionItemKind4[CompletionItemKind4["Variable"] = 5] = "Variable";
  CompletionItemKind4[CompletionItemKind4["Class"] = 6] = "Class";
  CompletionItemKind4[CompletionItemKind4["Interface"] = 7] = "Interface";
  CompletionItemKind4[CompletionItemKind4["Module"] = 8] = "Module";
  CompletionItemKind4[CompletionItemKind4["Property"] = 9] = "Property";
  CompletionItemKind4[CompletionItemKind4["Unit"] = 10] = "Unit";
  CompletionItemKind4[CompletionItemKind4["Value"] = 11] = "Value";
  CompletionItemKind4[CompletionItemKind4["Enum"] = 12] = "Enum";
  CompletionItemKind4[CompletionItemKind4["Keyword"] = 13] = "Keyword";
  CompletionItemKind4[CompletionItemKind4["Snippet"] = 14] = "Snippet";
  CompletionItemKind4[CompletionItemKind4["Color"] = 15] = "Color";
  CompletionItemKind4[CompletionItemKind4["File"] = 16] = "File";
  CompletionItemKind4[CompletionItemKind4["Reference"] = 17] = "Reference";
  CompletionItemKind4[CompletionItemKind4["Folder"] = 18] = "Folder";
  CompletionItemKind4[CompletionItemKind4["EnumMember"] = 19] = "EnumMember";
  CompletionItemKind4[CompletionItemKind4["Constant"] = 20] = "Constant";
  CompletionItemKind4[CompletionItemKind4["Struct"] = 21] = "Struct";
  CompletionItemKind4[CompletionItemKind4["Event"] = 22] = "Event";
  CompletionItemKind4[CompletionItemKind4["Operator"] = 23] = "Operator";
  CompletionItemKind4[CompletionItemKind4["TypeParameter"] = 24] = "TypeParameter";
  CompletionItemKind4[CompletionItemKind4["User"] = 25] = "User";
  CompletionItemKind4[CompletionItemKind4["Issue"] = 26] = "Issue";
})(CompletionItemKind2 || (CompletionItemKind2 = {}));
var CompletionItemTag2;
(function(CompletionItemTag4) {
  CompletionItemTag4[CompletionItemTag4["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag2 || (CompletionItemTag2 = {}));
var CompletionItem = class CompletionItem2 {
  constructor(label, kind) {
    this.label = label;
    this.kind = kind;
  }
  toJSON() {
    return {
      label: this.label,
      kind: this.kind && CompletionItemKind2[this.kind],
      detail: this.detail,
      documentation: this.documentation,
      sortText: this.sortText,
      filterText: this.filterText,
      preselect: this.preselect,
      insertText: this.insertText,
      textEdit: this.textEdit
    };
  }
};
CompletionItem = __decorate([
  es5ClassCompat
], CompletionItem);
var CompletionList = class CompletionList2 {
  constructor(items = [], isIncomplete = false) {
    this.items = items;
    this.isIncomplete = isIncomplete;
  }
};
CompletionList = __decorate([
  es5ClassCompat
], CompletionList);
var InlineSuggestion = class InlineSuggestion2 {
  constructor(insertText, range, command) {
    this.insertText = insertText;
    this.range = range;
    this.command = command;
  }
};
InlineSuggestion = __decorate([
  es5ClassCompat
], InlineSuggestion);
var InlineSuggestionList = class InlineSuggestionList2 {
  constructor(items) {
    this.commands = void 0;
    this.suppressSuggestions = void 0;
    this.items = items;
  }
};
InlineSuggestionList = __decorate([
  es5ClassCompat
], InlineSuggestionList);
var PartialAcceptTriggerKind2;
(function(PartialAcceptTriggerKind4) {
  PartialAcceptTriggerKind4[PartialAcceptTriggerKind4["Unknown"] = 0] = "Unknown";
  PartialAcceptTriggerKind4[PartialAcceptTriggerKind4["Word"] = 1] = "Word";
  PartialAcceptTriggerKind4[PartialAcceptTriggerKind4["Line"] = 2] = "Line";
  PartialAcceptTriggerKind4[PartialAcceptTriggerKind4["Suggest"] = 3] = "Suggest";
})(PartialAcceptTriggerKind2 || (PartialAcceptTriggerKind2 = {}));
var InlineCompletionEndOfLifeReasonKind2;
(function(InlineCompletionEndOfLifeReasonKind3) {
  InlineCompletionEndOfLifeReasonKind3[InlineCompletionEndOfLifeReasonKind3["Accepted"] = 0] = "Accepted";
  InlineCompletionEndOfLifeReasonKind3[InlineCompletionEndOfLifeReasonKind3["Rejected"] = 1] = "Rejected";
  InlineCompletionEndOfLifeReasonKind3[InlineCompletionEndOfLifeReasonKind3["Ignored"] = 2] = "Ignored";
})(InlineCompletionEndOfLifeReasonKind2 || (InlineCompletionEndOfLifeReasonKind2 = {}));
var InlineCompletionDisplayLocationKind;
(function(InlineCompletionDisplayLocationKind2) {
  InlineCompletionDisplayLocationKind2[InlineCompletionDisplayLocationKind2["Code"] = 1] = "Code";
  InlineCompletionDisplayLocationKind2[InlineCompletionDisplayLocationKind2["Label"] = 2] = "Label";
})(InlineCompletionDisplayLocationKind || (InlineCompletionDisplayLocationKind = {}));
var ViewColumn;
(function(ViewColumn3) {
  ViewColumn3[ViewColumn3["Active"] = -1] = "Active";
  ViewColumn3[ViewColumn3["Beside"] = -2] = "Beside";
  ViewColumn3[ViewColumn3["One"] = 1] = "One";
  ViewColumn3[ViewColumn3["Two"] = 2] = "Two";
  ViewColumn3[ViewColumn3["Three"] = 3] = "Three";
  ViewColumn3[ViewColumn3["Four"] = 4] = "Four";
  ViewColumn3[ViewColumn3["Five"] = 5] = "Five";
  ViewColumn3[ViewColumn3["Six"] = 6] = "Six";
  ViewColumn3[ViewColumn3["Seven"] = 7] = "Seven";
  ViewColumn3[ViewColumn3["Eight"] = 8] = "Eight";
  ViewColumn3[ViewColumn3["Nine"] = 9] = "Nine";
})(ViewColumn || (ViewColumn = {}));
var StatusBarAlignment;
(function(StatusBarAlignment2) {
  StatusBarAlignment2[StatusBarAlignment2["Left"] = 1] = "Left";
  StatusBarAlignment2[StatusBarAlignment2["Right"] = 2] = "Right";
})(StatusBarAlignment || (StatusBarAlignment = {}));
function asStatusBarItemIdentifier(extension, id2) {
  return `${ExtensionIdentifier.toKey(extension)}.${id2}`;
}
var TextEditorLineNumbersStyle;
(function(TextEditorLineNumbersStyle3) {
  TextEditorLineNumbersStyle3[TextEditorLineNumbersStyle3["Off"] = 0] = "Off";
  TextEditorLineNumbersStyle3[TextEditorLineNumbersStyle3["On"] = 1] = "On";
  TextEditorLineNumbersStyle3[TextEditorLineNumbersStyle3["Relative"] = 2] = "Relative";
  TextEditorLineNumbersStyle3[TextEditorLineNumbersStyle3["Interval"] = 3] = "Interval";
})(TextEditorLineNumbersStyle || (TextEditorLineNumbersStyle = {}));
var TextDocumentSaveReason;
(function(TextDocumentSaveReason3) {
  TextDocumentSaveReason3[TextDocumentSaveReason3["Manual"] = 1] = "Manual";
  TextDocumentSaveReason3[TextDocumentSaveReason3["AfterDelay"] = 2] = "AfterDelay";
  TextDocumentSaveReason3[TextDocumentSaveReason3["FocusOut"] = 3] = "FocusOut";
})(TextDocumentSaveReason || (TextDocumentSaveReason = {}));
var TextEditorRevealType2;
(function(TextEditorRevealType3) {
  TextEditorRevealType3[TextEditorRevealType3["Default"] = 0] = "Default";
  TextEditorRevealType3[TextEditorRevealType3["InCenter"] = 1] = "InCenter";
  TextEditorRevealType3[TextEditorRevealType3["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
  TextEditorRevealType3[TextEditorRevealType3["AtTop"] = 3] = "AtTop";
})(TextEditorRevealType2 || (TextEditorRevealType2 = {}));
var TextEditorSelectionChangeKind;
(function(TextEditorSelectionChangeKind2) {
  TextEditorSelectionChangeKind2[TextEditorSelectionChangeKind2["Keyboard"] = 1] = "Keyboard";
  TextEditorSelectionChangeKind2[TextEditorSelectionChangeKind2["Mouse"] = 2] = "Mouse";
  TextEditorSelectionChangeKind2[TextEditorSelectionChangeKind2["Command"] = 3] = "Command";
})(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {}));
var TextEditorChangeKind;
(function(TextEditorChangeKind2) {
  TextEditorChangeKind2[TextEditorChangeKind2["Addition"] = 1] = "Addition";
  TextEditorChangeKind2[TextEditorChangeKind2["Deletion"] = 2] = "Deletion";
  TextEditorChangeKind2[TextEditorChangeKind2["Modification"] = 3] = "Modification";
})(TextEditorChangeKind || (TextEditorChangeKind = {}));
var TextDocumentChangeReason;
(function(TextDocumentChangeReason2) {
  TextDocumentChangeReason2[TextDocumentChangeReason2["Undo"] = 1] = "Undo";
  TextDocumentChangeReason2[TextDocumentChangeReason2["Redo"] = 2] = "Redo";
})(TextDocumentChangeReason || (TextDocumentChangeReason = {}));
var DecorationRangeBehavior;
(function(DecorationRangeBehavior3) {
  DecorationRangeBehavior3[DecorationRangeBehavior3["OpenOpen"] = 0] = "OpenOpen";
  DecorationRangeBehavior3[DecorationRangeBehavior3["ClosedClosed"] = 1] = "ClosedClosed";
  DecorationRangeBehavior3[DecorationRangeBehavior3["OpenClosed"] = 2] = "OpenClosed";
  DecorationRangeBehavior3[DecorationRangeBehavior3["ClosedOpen"] = 3] = "ClosedOpen";
})(DecorationRangeBehavior || (DecorationRangeBehavior = {}));
(function(TextEditorSelectionChangeKind2) {
  function fromValue(s) {
    switch (s) {
      case "keyboard":
        return TextEditorSelectionChangeKind2.Keyboard;
      case "mouse":
        return TextEditorSelectionChangeKind2.Mouse;
      case "api":
      case "code.jump":
      case "code.navigation":
        return TextEditorSelectionChangeKind2.Command;
    }
    return void 0;
  }
  TextEditorSelectionChangeKind2.fromValue = fromValue;
})(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {}));
var SyntaxTokenType;
(function(SyntaxTokenType2) {
  SyntaxTokenType2[SyntaxTokenType2["Other"] = 0] = "Other";
  SyntaxTokenType2[SyntaxTokenType2["Comment"] = 1] = "Comment";
  SyntaxTokenType2[SyntaxTokenType2["String"] = 2] = "String";
  SyntaxTokenType2[SyntaxTokenType2["RegEx"] = 3] = "RegEx";
})(SyntaxTokenType || (SyntaxTokenType = {}));
(function(SyntaxTokenType2) {
  function toString(v) {
    switch (v) {
      case SyntaxTokenType2.Other:
        return "other";
      case SyntaxTokenType2.Comment:
        return "comment";
      case SyntaxTokenType2.String:
        return "string";
      case SyntaxTokenType2.RegEx:
        return "regex";
    }
    return "other";
  }
  SyntaxTokenType2.toString = toString;
})(SyntaxTokenType || (SyntaxTokenType = {}));
var DocumentLink = class DocumentLink2 {
  constructor(range, target) {
    if (target && !URI.isUri(target)) {
      throw illegalArgument("target");
    }
    if (!Range2.isRange(range) || range.isEmpty) {
      throw illegalArgument("range");
    }
    this.range = range;
    this.target = target;
  }
};
DocumentLink = __decorate([
  es5ClassCompat
], DocumentLink);
var Color = class Color2 {
  constructor(red, green, blue, alpha) {
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
};
Color = __decorate([
  es5ClassCompat
], Color);
var ColorInformation = class ColorInformation2 {
  constructor(range, color) {
    if (color && !(color instanceof Color)) {
      throw illegalArgument("color");
    }
    if (!Range2.isRange(range) || range.isEmpty) {
      throw illegalArgument("range");
    }
    this.range = range;
    this.color = color;
  }
};
ColorInformation = __decorate([
  es5ClassCompat
], ColorInformation);
var ColorPresentation = class ColorPresentation2 {
  constructor(label) {
    if (!label || typeof label !== "string") {
      throw illegalArgument("label");
    }
    this.label = label;
  }
};
ColorPresentation = __decorate([
  es5ClassCompat
], ColorPresentation);
var ColorFormat;
(function(ColorFormat2) {
  ColorFormat2[ColorFormat2["RGB"] = 0] = "RGB";
  ColorFormat2[ColorFormat2["HEX"] = 1] = "HEX";
  ColorFormat2[ColorFormat2["HSL"] = 2] = "HSL";
})(ColorFormat || (ColorFormat = {}));
var SourceControlInputBoxValidationType;
(function(SourceControlInputBoxValidationType3) {
  SourceControlInputBoxValidationType3[SourceControlInputBoxValidationType3["Error"] = 0] = "Error";
  SourceControlInputBoxValidationType3[SourceControlInputBoxValidationType3["Warning"] = 1] = "Warning";
  SourceControlInputBoxValidationType3[SourceControlInputBoxValidationType3["Information"] = 2] = "Information";
})(SourceControlInputBoxValidationType || (SourceControlInputBoxValidationType = {}));
var TerminalExitReason;
(function(TerminalExitReason2) {
  TerminalExitReason2[TerminalExitReason2["Unknown"] = 0] = "Unknown";
  TerminalExitReason2[TerminalExitReason2["Shutdown"] = 1] = "Shutdown";
  TerminalExitReason2[TerminalExitReason2["Process"] = 2] = "Process";
  TerminalExitReason2[TerminalExitReason2["User"] = 3] = "User";
  TerminalExitReason2[TerminalExitReason2["Extension"] = 4] = "Extension";
})(TerminalExitReason || (TerminalExitReason = {}));
var TerminalShellExecutionCommandLineConfidence;
(function(TerminalShellExecutionCommandLineConfidence2) {
  TerminalShellExecutionCommandLineConfidence2[TerminalShellExecutionCommandLineConfidence2["Low"] = 0] = "Low";
  TerminalShellExecutionCommandLineConfidence2[TerminalShellExecutionCommandLineConfidence2["Medium"] = 1] = "Medium";
  TerminalShellExecutionCommandLineConfidence2[TerminalShellExecutionCommandLineConfidence2["High"] = 2] = "High";
})(TerminalShellExecutionCommandLineConfidence || (TerminalShellExecutionCommandLineConfidence = {}));
var TerminalShellType;
(function(TerminalShellType2) {
  TerminalShellType2[TerminalShellType2["Sh"] = 1] = "Sh";
  TerminalShellType2[TerminalShellType2["Bash"] = 2] = "Bash";
  TerminalShellType2[TerminalShellType2["Fish"] = 3] = "Fish";
  TerminalShellType2[TerminalShellType2["Csh"] = 4] = "Csh";
  TerminalShellType2[TerminalShellType2["Ksh"] = 5] = "Ksh";
  TerminalShellType2[TerminalShellType2["Zsh"] = 6] = "Zsh";
  TerminalShellType2[TerminalShellType2["CommandPrompt"] = 7] = "CommandPrompt";
  TerminalShellType2[TerminalShellType2["GitBash"] = 8] = "GitBash";
  TerminalShellType2[TerminalShellType2["PowerShell"] = 9] = "PowerShell";
  TerminalShellType2[TerminalShellType2["Python"] = 10] = "Python";
  TerminalShellType2[TerminalShellType2["Julia"] = 11] = "Julia";
  TerminalShellType2[TerminalShellType2["NuShell"] = 12] = "NuShell";
  TerminalShellType2[TerminalShellType2["Node"] = 13] = "Node";
})(TerminalShellType || (TerminalShellType = {}));
var TerminalLink = class {
  constructor(startIndex, length, tooltip) {
    this.startIndex = startIndex;
    this.length = length;
    this.tooltip = tooltip;
    if (typeof startIndex !== "number" || startIndex < 0) {
      throw illegalArgument("startIndex");
    }
    if (typeof length !== "number" || length < 1) {
      throw illegalArgument("length");
    }
    if (tooltip !== void 0 && typeof tooltip !== "string") {
      throw illegalArgument("tooltip");
    }
  }
};
var TerminalQuickFixOpener = class {
  constructor(uri) {
    this.uri = uri;
  }
};
var TerminalQuickFixCommand = class {
  constructor(terminalCommand) {
    this.terminalCommand = terminalCommand;
  }
};
var TerminalLocation;
(function(TerminalLocation2) {
  TerminalLocation2[TerminalLocation2["Panel"] = 1] = "Panel";
  TerminalLocation2[TerminalLocation2["Editor"] = 2] = "Editor";
})(TerminalLocation || (TerminalLocation = {}));
var TerminalProfile = class {
  constructor(options2) {
    this.options = options2;
    if (typeof options2 !== "object") {
      throw illegalArgument("options");
    }
  }
};
var TerminalCompletionItemKind;
(function(TerminalCompletionItemKind2) {
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["File"] = 0] = "File";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["Folder"] = 1] = "Folder";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["Method"] = 2] = "Method";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["Alias"] = 3] = "Alias";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["Argument"] = 4] = "Argument";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["Option"] = 5] = "Option";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["OptionValue"] = 6] = "OptionValue";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["Flag"] = 7] = "Flag";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["SymbolicLinkFile"] = 8] = "SymbolicLinkFile";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["SymbolicLinkFolder"] = 9] = "SymbolicLinkFolder";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["ScmCommit"] = 10] = "ScmCommit";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["ScmBranch"] = 11] = "ScmBranch";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["ScmTag"] = 12] = "ScmTag";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["ScmStash"] = 13] = "ScmStash";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["ScmRemote"] = 14] = "ScmRemote";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["PullRequest"] = 15] = "PullRequest";
  TerminalCompletionItemKind2[TerminalCompletionItemKind2["PullRequestDone"] = 16] = "PullRequestDone";
})(TerminalCompletionItemKind || (TerminalCompletionItemKind = {}));
var TerminalCompletionItem = class {
  constructor(label, replacementRange, kind, detail, documentation, isFile, isDirectory, isKeyword) {
    this.label = label;
    this.replacementRange = replacementRange;
    this.kind = kind;
    this.detail = detail;
    this.documentation = documentation;
    this.isFile = isFile;
    this.isDirectory = isDirectory;
    this.isKeyword = isKeyword;
  }
};
var TerminalCompletionList = class {
  /**
   * Creates a new completion list.
   *
   * @param items The completion items.
   * @param isIncomplete The list is not complete.
   */
  constructor(items, resourceOptions) {
    this.items = items ?? [];
    this.resourceOptions = resourceOptions;
  }
};
var TaskRevealKind;
(function(TaskRevealKind2) {
  TaskRevealKind2[TaskRevealKind2["Always"] = 1] = "Always";
  TaskRevealKind2[TaskRevealKind2["Silent"] = 2] = "Silent";
  TaskRevealKind2[TaskRevealKind2["Never"] = 3] = "Never";
})(TaskRevealKind || (TaskRevealKind = {}));
var TaskEventKind;
(function(TaskEventKind3) {
  TaskEventKind3["Changed"] = "changed";
  TaskEventKind3["ProcessStarted"] = "processStarted";
  TaskEventKind3["ProcessEnded"] = "processEnded";
  TaskEventKind3["Terminated"] = "terminated";
  TaskEventKind3["Start"] = "start";
  TaskEventKind3["AcquiredInput"] = "acquiredInput";
  TaskEventKind3["DependsOnStarted"] = "dependsOnStarted";
  TaskEventKind3["Active"] = "active";
  TaskEventKind3["Inactive"] = "inactive";
  TaskEventKind3["End"] = "end";
  TaskEventKind3["ProblemMatcherStarted"] = "problemMatcherStarted";
  TaskEventKind3["ProblemMatcherEnded"] = "problemMatcherEnded";
  TaskEventKind3["ProblemMatcherFoundErrors"] = "problemMatcherFoundErrors";
})(TaskEventKind || (TaskEventKind = {}));
var TaskPanelKind;
(function(TaskPanelKind2) {
  TaskPanelKind2[TaskPanelKind2["Shared"] = 1] = "Shared";
  TaskPanelKind2[TaskPanelKind2["Dedicated"] = 2] = "Dedicated";
  TaskPanelKind2[TaskPanelKind2["New"] = 3] = "New";
})(TaskPanelKind || (TaskPanelKind = {}));
var TaskGroup = class TaskGroup2 {
  static {
    TaskGroup_1 = this;
  }
  static {
    this.Clean = new TaskGroup_1("clean", "Clean");
  }
  static {
    this.Build = new TaskGroup_1("build", "Build");
  }
  static {
    this.Rebuild = new TaskGroup_1("rebuild", "Rebuild");
  }
  static {
    this.Test = new TaskGroup_1("test", "Test");
  }
  static from(value) {
    switch (value) {
      case "clean":
        return TaskGroup_1.Clean;
      case "build":
        return TaskGroup_1.Build;
      case "rebuild":
        return TaskGroup_1.Rebuild;
      case "test":
        return TaskGroup_1.Test;
      default:
        return void 0;
    }
  }
  constructor(id2, label) {
    this.label = label;
    if (typeof id2 !== "string") {
      throw illegalArgument("name");
    }
    if (typeof label !== "string") {
      throw illegalArgument("name");
    }
    this._id = id2;
  }
  get id() {
    return this._id;
  }
};
TaskGroup = TaskGroup_1 = __decorate([
  es5ClassCompat
], TaskGroup);
function computeTaskExecutionId(values) {
  let id2 = "";
  for (let i = 0; i < values.length; i++) {
    id2 += values[i].replace(/,/g, ",,") + ",";
  }
  return id2;
}
var ProcessExecution = class ProcessExecution2 {
  constructor(process2, varg1, varg2) {
    if (typeof process2 !== "string") {
      throw illegalArgument("process");
    }
    this._args = [];
    this._process = process2;
    if (varg1 !== void 0) {
      if (Array.isArray(varg1)) {
        this._args = varg1;
        this._options = varg2;
      } else {
        this._options = varg1;
      }
    }
  }
  get process() {
    return this._process;
  }
  set process(value) {
    if (typeof value !== "string") {
      throw illegalArgument("process");
    }
    this._process = value;
  }
  get args() {
    return this._args;
  }
  set args(value) {
    if (!Array.isArray(value)) {
      value = [];
    }
    this._args = value;
  }
  get options() {
    return this._options;
  }
  set options(value) {
    this._options = value;
  }
  computeId() {
    const props = [];
    props.push("process");
    if (this._process !== void 0) {
      props.push(this._process);
    }
    if (this._args && this._args.length > 0) {
      for (const arg of this._args) {
        props.push(arg);
      }
    }
    return computeTaskExecutionId(props);
  }
};
ProcessExecution = __decorate([
  es5ClassCompat
], ProcessExecution);
var ShellExecution = class ShellExecution2 {
  constructor(arg0, arg1, arg2) {
    this._args = [];
    if (Array.isArray(arg1)) {
      if (!arg0) {
        throw illegalArgument("command can't be undefined or null");
      }
      if (typeof arg0 !== "string" && typeof arg0.value !== "string") {
        throw illegalArgument("command");
      }
      this._command = arg0;
      if (arg1) {
        this._args = arg1;
      }
      this._options = arg2;
    } else {
      if (typeof arg0 !== "string") {
        throw illegalArgument("commandLine");
      }
      this._commandLine = arg0;
      this._options = arg1;
    }
  }
  get commandLine() {
    return this._commandLine;
  }
  set commandLine(value) {
    if (typeof value !== "string") {
      throw illegalArgument("commandLine");
    }
    this._commandLine = value;
  }
  get command() {
    return this._command ? this._command : "";
  }
  set command(value) {
    if (typeof value !== "string" && typeof value.value !== "string") {
      throw illegalArgument("command");
    }
    this._command = value;
  }
  get args() {
    return this._args;
  }
  set args(value) {
    this._args = value || [];
  }
  get options() {
    return this._options;
  }
  set options(value) {
    this._options = value;
  }
  computeId() {
    const props = [];
    props.push("shell");
    if (this._commandLine !== void 0) {
      props.push(this._commandLine);
    }
    if (this._command !== void 0) {
      props.push(typeof this._command === "string" ? this._command : this._command.value);
    }
    if (this._args && this._args.length > 0) {
      for (const arg of this._args) {
        props.push(typeof arg === "string" ? arg : arg.value);
      }
    }
    return computeTaskExecutionId(props);
  }
};
ShellExecution = __decorate([
  es5ClassCompat
], ShellExecution);
var ShellQuoting;
(function(ShellQuoting3) {
  ShellQuoting3[ShellQuoting3["Escape"] = 1] = "Escape";
  ShellQuoting3[ShellQuoting3["Strong"] = 2] = "Strong";
  ShellQuoting3[ShellQuoting3["Weak"] = 3] = "Weak";
})(ShellQuoting || (ShellQuoting = {}));
var TaskScope;
(function(TaskScope3) {
  TaskScope3[TaskScope3["Global"] = 1] = "Global";
  TaskScope3[TaskScope3["Workspace"] = 2] = "Workspace";
})(TaskScope || (TaskScope = {}));
var CustomExecution = class {
  constructor(callback) {
    this._callback = callback;
  }
  computeId() {
    return "customExecution" + generateUuid();
  }
  set callback(value) {
    this._callback = value;
  }
  get callback() {
    return this._callback;
  }
};
var Task = class Task2 {
  static {
    Task_1 = this;
  }
  static {
    this.ExtensionCallbackType = "customExecution";
  }
  static {
    this.ProcessType = "process";
  }
  static {
    this.ShellType = "shell";
  }
  static {
    this.EmptyType = "$empty";
  }
  constructor(definition, arg2, arg3, arg4, arg5, arg6) {
    this.__deprecated = false;
    this._definition = this.definition = definition;
    let problemMatchers;
    if (typeof arg2 === "string") {
      this._name = this.name = arg2;
      this._source = this.source = arg3;
      this.execution = arg4;
      problemMatchers = arg5;
      this.__deprecated = true;
    } else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {
      this.target = arg2;
      this._name = this.name = arg3;
      this._source = this.source = arg4;
      this.execution = arg5;
      problemMatchers = arg6;
    } else {
      this.target = arg2;
      this._name = this.name = arg3;
      this._source = this.source = arg4;
      this.execution = arg5;
      problemMatchers = arg6;
    }
    if (typeof problemMatchers === "string") {
      this._problemMatchers = [problemMatchers];
      this._hasDefinedMatchers = true;
    } else if (Array.isArray(problemMatchers)) {
      this._problemMatchers = problemMatchers;
      this._hasDefinedMatchers = true;
    } else {
      this._problemMatchers = [];
      this._hasDefinedMatchers = false;
    }
    this._isBackground = false;
    this._presentationOptions = /* @__PURE__ */ Object.create(null);
    this._runOptions = /* @__PURE__ */ Object.create(null);
  }
  get _id() {
    return this.__id;
  }
  set _id(value) {
    this.__id = value;
  }
  get _deprecated() {
    return this.__deprecated;
  }
  clear() {
    if (this.__id === void 0) {
      return;
    }
    this.__id = void 0;
    this._scope = void 0;
    this.computeDefinitionBasedOnExecution();
  }
  computeDefinitionBasedOnExecution() {
    if (this._execution instanceof ProcessExecution) {
      this._definition = {
        type: Task_1.ProcessType,
        id: this._execution.computeId()
      };
    } else if (this._execution instanceof ShellExecution) {
      this._definition = {
        type: Task_1.ShellType,
        id: this._execution.computeId()
      };
    } else if (this._execution instanceof CustomExecution) {
      this._definition = {
        type: Task_1.ExtensionCallbackType,
        id: this._execution.computeId()
      };
    } else {
      this._definition = {
        type: Task_1.EmptyType,
        id: generateUuid()
      };
    }
  }
  get definition() {
    return this._definition;
  }
  set definition(value) {
    if (value === void 0 || value === null) {
      throw illegalArgument("Kind can't be undefined or null");
    }
    this.clear();
    this._definition = value;
  }
  get scope() {
    return this._scope;
  }
  set target(value) {
    this.clear();
    this._scope = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    if (typeof value !== "string") {
      throw illegalArgument("name");
    }
    this.clear();
    this._name = value;
  }
  get execution() {
    return this._execution;
  }
  set execution(value) {
    if (value === null) {
      value = void 0;
    }
    this.clear();
    this._execution = value;
    const type = this._definition.type;
    if (Task_1.EmptyType === type || Task_1.ProcessType === type || Task_1.ShellType === type || Task_1.ExtensionCallbackType === type) {
      this.computeDefinitionBasedOnExecution();
    }
  }
  get problemMatchers() {
    return this._problemMatchers;
  }
  set problemMatchers(value) {
    if (!Array.isArray(value)) {
      this.clear();
      this._problemMatchers = [];
      this._hasDefinedMatchers = false;
      return;
    } else {
      this.clear();
      this._problemMatchers = value;
      this._hasDefinedMatchers = true;
    }
  }
  get hasDefinedMatchers() {
    return this._hasDefinedMatchers;
  }
  get isBackground() {
    return this._isBackground;
  }
  set isBackground(value) {
    if (value !== true && value !== false) {
      value = false;
    }
    this.clear();
    this._isBackground = value;
  }
  get source() {
    return this._source;
  }
  set source(value) {
    if (typeof value !== "string" || value.length === 0) {
      throw illegalArgument("source must be a string of length > 0");
    }
    this.clear();
    this._source = value;
  }
  get group() {
    return this._group;
  }
  set group(value) {
    if (value === null) {
      value = void 0;
    }
    this.clear();
    this._group = value;
  }
  get detail() {
    return this._detail;
  }
  set detail(value) {
    if (value === null) {
      value = void 0;
    }
    this._detail = value;
  }
  get presentationOptions() {
    return this._presentationOptions;
  }
  set presentationOptions(value) {
    if (value === null || value === void 0) {
      value = /* @__PURE__ */ Object.create(null);
    }
    this.clear();
    this._presentationOptions = value;
  }
  get runOptions() {
    return this._runOptions;
  }
  set runOptions(value) {
    if (value === null || value === void 0) {
      value = /* @__PURE__ */ Object.create(null);
    }
    this.clear();
    this._runOptions = value;
  }
};
Task = Task_1 = __decorate([
  es5ClassCompat
], Task);
var ProgressLocation;
(function(ProgressLocation4) {
  ProgressLocation4[ProgressLocation4["SourceControl"] = 1] = "SourceControl";
  ProgressLocation4[ProgressLocation4["Window"] = 10] = "Window";
  ProgressLocation4[ProgressLocation4["Notification"] = 15] = "Notification";
})(ProgressLocation || (ProgressLocation = {}));
var ViewBadge;
(function(ViewBadge3) {
  function isViewBadge(thing) {
    const viewBadgeThing = thing;
    if (!isNumber(viewBadgeThing.value)) {
      console.log("INVALID view badge, invalid value", viewBadgeThing.value);
      return false;
    }
    if (viewBadgeThing.tooltip && !isString(viewBadgeThing.tooltip)) {
      console.log("INVALID view badge, invalid tooltip", viewBadgeThing.tooltip);
      return false;
    }
    return true;
  }
  ViewBadge3.isViewBadge = isViewBadge;
})(ViewBadge || (ViewBadge = {}));
var TreeItem = TreeItem_1 = class TreeItem2 {
  static isTreeItem(thing, extension) {
    const treeItemThing = thing;
    if (treeItemThing.checkboxState !== void 0) {
      const checkbox = isNumber(treeItemThing.checkboxState) ? treeItemThing.checkboxState : isObject(treeItemThing.checkboxState) && isNumber(treeItemThing.checkboxState.state) ? treeItemThing.checkboxState.state : void 0;
      const tooltip = !isNumber(treeItemThing.checkboxState) && isObject(treeItemThing.checkboxState) ? treeItemThing.checkboxState.tooltip : void 0;
      if (checkbox === void 0 || checkbox !== TreeItemCheckboxState.Checked && checkbox !== TreeItemCheckboxState.Unchecked || tooltip !== void 0 && !isString(tooltip)) {
        console.log("INVALID tree item, invalid checkboxState", treeItemThing.checkboxState);
        return false;
      }
    }
    if (thing instanceof TreeItem_1) {
      return true;
    }
    if (treeItemThing.label !== void 0 && !isString(treeItemThing.label) && !treeItemThing.label?.label) {
      console.log("INVALID tree item, invalid label", treeItemThing.label);
      return false;
    }
    if (treeItemThing.id !== void 0 && !isString(treeItemThing.id)) {
      console.log("INVALID tree item, invalid id", treeItemThing.id);
      return false;
    }
    if (treeItemThing.iconPath !== void 0 && !isString(treeItemThing.iconPath) && !URI.isUri(treeItemThing.iconPath) && (!treeItemThing.iconPath || !isString(treeItemThing.iconPath.id))) {
      const asLightAndDarkThing = treeItemThing.iconPath;
      if (!asLightAndDarkThing || !isString(asLightAndDarkThing.light) && !URI.isUri(asLightAndDarkThing.light) && !isString(asLightAndDarkThing.dark) && !URI.isUri(asLightAndDarkThing.dark)) {
        console.log("INVALID tree item, invalid iconPath", treeItemThing.iconPath);
        return false;
      }
    }
    if (treeItemThing.description !== void 0 && !isString(treeItemThing.description) && typeof treeItemThing.description !== "boolean") {
      console.log("INVALID tree item, invalid description", treeItemThing.description);
      return false;
    }
    if (treeItemThing.resourceUri !== void 0 && !URI.isUri(treeItemThing.resourceUri)) {
      console.log("INVALID tree item, invalid resourceUri", treeItemThing.resourceUri);
      return false;
    }
    if (treeItemThing.tooltip !== void 0 && !isString(treeItemThing.tooltip) && !(treeItemThing.tooltip instanceof MarkdownString2)) {
      console.log("INVALID tree item, invalid tooltip", treeItemThing.tooltip);
      return false;
    }
    if (treeItemThing.command !== void 0 && !treeItemThing.command.command) {
      console.log("INVALID tree item, invalid command", treeItemThing.command);
      return false;
    }
    if (treeItemThing.collapsibleState !== void 0 && treeItemThing.collapsibleState < TreeItemCollapsibleState.None && treeItemThing.collapsibleState > TreeItemCollapsibleState.Expanded) {
      console.log("INVALID tree item, invalid collapsibleState", treeItemThing.collapsibleState);
      return false;
    }
    if (treeItemThing.contextValue !== void 0 && !isString(treeItemThing.contextValue)) {
      console.log("INVALID tree item, invalid contextValue", treeItemThing.contextValue);
      return false;
    }
    if (treeItemThing.accessibilityInformation !== void 0 && !treeItemThing.accessibilityInformation?.label) {
      console.log("INVALID tree item, invalid accessibilityInformation", treeItemThing.accessibilityInformation);
      return false;
    }
    return true;
  }
  constructor(arg1, collapsibleState = TreeItemCollapsibleState.None) {
    this.collapsibleState = collapsibleState;
    if (URI.isUri(arg1)) {
      this.resourceUri = arg1;
    } else {
      this.label = arg1;
    }
  }
};
TreeItem = TreeItem_1 = __decorate([
  es5ClassCompat
], TreeItem);
var TreeItemCollapsibleState;
(function(TreeItemCollapsibleState3) {
  TreeItemCollapsibleState3[TreeItemCollapsibleState3["None"] = 0] = "None";
  TreeItemCollapsibleState3[TreeItemCollapsibleState3["Collapsed"] = 1] = "Collapsed";
  TreeItemCollapsibleState3[TreeItemCollapsibleState3["Expanded"] = 2] = "Expanded";
})(TreeItemCollapsibleState || (TreeItemCollapsibleState = {}));
var TreeItemCheckboxState;
(function(TreeItemCheckboxState2) {
  TreeItemCheckboxState2[TreeItemCheckboxState2["Unchecked"] = 0] = "Unchecked";
  TreeItemCheckboxState2[TreeItemCheckboxState2["Checked"] = 1] = "Checked";
})(TreeItemCheckboxState || (TreeItemCheckboxState = {}));
var DataTransferItem = class DataTransferItem2 {
  async asString() {
    return typeof this.value === "string" ? this.value : JSON.stringify(this.value);
  }
  asFile() {
    return void 0;
  }
  constructor(value) {
    this.value = value;
  }
};
DataTransferItem = __decorate([
  es5ClassCompat
], DataTransferItem);
var InternalDataTransferItem = class extends DataTransferItem {
};
var InternalFileDataTransferItem = class extends InternalDataTransferItem {
  #file;
  constructor(file) {
    super("");
    this.#file = file;
  }
  asFile() {
    return this.#file;
  }
};
var DataTransferFile = class {
  constructor(name2, uri, itemId, getData) {
    this.name = name2;
    this.uri = uri;
    this._itemId = itemId;
    this._getData = getData;
  }
  data() {
    return this._getData();
  }
};
var DataTransfer = class DataTransfer2 {
  #items = /* @__PURE__ */ new Map();
  constructor(init) {
    for (const [mime, item] of init ?? []) {
      const existing = this.#items.get(this.#normalizeMime(mime));
      if (existing) {
        existing.push(item);
      } else {
        this.#items.set(this.#normalizeMime(mime), [item]);
      }
    }
  }
  get(mimeType) {
    return this.#items.get(this.#normalizeMime(mimeType))?.[0];
  }
  set(mimeType, value) {
    this.#items.set(this.#normalizeMime(mimeType), [value]);
  }
  forEach(callbackfn, thisArg) {
    for (const [mime, items] of this.#items) {
      for (const item of items) {
        callbackfn.call(thisArg, item, mime, this);
      }
    }
  }
  *[Symbol.iterator]() {
    for (const [mime, items] of this.#items) {
      for (const item of items) {
        yield [mime, item];
      }
    }
  }
  #normalizeMime(mimeType) {
    return mimeType.toLowerCase();
  }
};
DataTransfer = __decorate([
  es5ClassCompat
], DataTransfer);
var DocumentDropEdit = class DocumentDropEdit2 {
  constructor(insertText, title, kind) {
    this.insertText = insertText;
    this.title = title;
    this.kind = kind;
  }
};
DocumentDropEdit = __decorate([
  es5ClassCompat
], DocumentDropEdit);
var DocumentPasteTriggerKind2;
(function(DocumentPasteTriggerKind3) {
  DocumentPasteTriggerKind3[DocumentPasteTriggerKind3["Automatic"] = 0] = "Automatic";
  DocumentPasteTriggerKind3[DocumentPasteTriggerKind3["PasteAs"] = 1] = "PasteAs";
})(DocumentPasteTriggerKind2 || (DocumentPasteTriggerKind2 = {}));
var DocumentDropOrPasteEditKind = class _DocumentDropOrPasteEditKind {
  static {
    this.sep = ".";
  }
  constructor(value) {
    this.value = value;
  }
  append(...parts) {
    return new _DocumentDropOrPasteEditKind((this.value ? [this.value, ...parts] : parts).join(_DocumentDropOrPasteEditKind.sep));
  }
  intersects(other) {
    return this.contains(other) || other.contains(this);
  }
  contains(other) {
    return this.value === other.value || other.value.startsWith(this.value + _DocumentDropOrPasteEditKind.sep);
  }
};
DocumentDropOrPasteEditKind.Empty = new DocumentDropOrPasteEditKind("");
DocumentDropOrPasteEditKind.Text = new DocumentDropOrPasteEditKind("text");
DocumentDropOrPasteEditKind.TextUpdateImports = DocumentDropOrPasteEditKind.Text.append("updateImports");
var DocumentPasteEdit = class {
  constructor(insertText, title, kind) {
    this.title = title;
    this.insertText = insertText;
    this.kind = kind;
  }
};
var ThemeIcon2 = class ThemeIcon3 {
  constructor(id2, color) {
    this.id = id2;
    this.color = color;
  }
  static isThemeIcon(thing) {
    if (typeof thing.id !== "string") {
      console.log("INVALID ThemeIcon, invalid id", thing.id);
      return false;
    }
    return true;
  }
};
ThemeIcon2 = __decorate([
  es5ClassCompat
], ThemeIcon2);
ThemeIcon2.File = new ThemeIcon2("file");
ThemeIcon2.Folder = new ThemeIcon2("folder");
var ThemeColor2 = class ThemeColor3 {
  constructor(id2) {
    this.id = id2;
  }
};
ThemeColor2 = __decorate([
  es5ClassCompat
], ThemeColor2);
var ConfigurationTarget2;
(function(ConfigurationTarget3) {
  ConfigurationTarget3[ConfigurationTarget3["Global"] = 1] = "Global";
  ConfigurationTarget3[ConfigurationTarget3["Workspace"] = 2] = "Workspace";
  ConfigurationTarget3[ConfigurationTarget3["WorkspaceFolder"] = 3] = "WorkspaceFolder";
})(ConfigurationTarget2 || (ConfigurationTarget2 = {}));
var RelativePattern = class RelativePattern2 {
  get base() {
    return this._base;
  }
  set base(base) {
    this._base = base;
    this._baseUri = URI.file(base);
  }
  get baseUri() {
    return this._baseUri;
  }
  set baseUri(baseUri) {
    this._baseUri = baseUri;
    this._base = baseUri.fsPath;
  }
  constructor(base, pattern) {
    if (typeof base !== "string") {
      if (!base || !URI.isUri(base) && !URI.isUri(base.uri)) {
        throw illegalArgument("base");
      }
    }
    if (typeof pattern !== "string") {
      throw illegalArgument("pattern");
    }
    if (typeof base === "string") {
      this.baseUri = URI.file(base);
    } else if (URI.isUri(base)) {
      this.baseUri = base;
    } else {
      this.baseUri = base.uri;
    }
    this.pattern = pattern;
  }
  toJSON() {
    return {
      pattern: this.pattern,
      base: this.base,
      baseUri: this.baseUri.toJSON()
    };
  }
};
RelativePattern = __decorate([
  es5ClassCompat
], RelativePattern);
var breakpointIds = /* @__PURE__ */ new WeakMap();
function setBreakpointId(bp, id2) {
  breakpointIds.set(bp, id2);
}
var Breakpoint = class Breakpoint2 {
  constructor(enabled, condition, hitCondition, logMessage, mode) {
    this.enabled = typeof enabled === "boolean" ? enabled : true;
    if (typeof condition === "string") {
      this.condition = condition;
    }
    if (typeof hitCondition === "string") {
      this.hitCondition = hitCondition;
    }
    if (typeof logMessage === "string") {
      this.logMessage = logMessage;
    }
    if (typeof mode === "string") {
      this.mode = mode;
    }
  }
  get id() {
    if (!this._id) {
      this._id = breakpointIds.get(this) ?? generateUuid();
    }
    return this._id;
  }
};
Breakpoint = __decorate([
  es5ClassCompat
], Breakpoint);
var SourceBreakpoint = class SourceBreakpoint2 extends Breakpoint {
  constructor(location2, enabled, condition, hitCondition, logMessage, mode) {
    super(enabled, condition, hitCondition, logMessage, mode);
    if (location2 === null) {
      throw illegalArgument("location");
    }
    this.location = location2;
  }
};
SourceBreakpoint = __decorate([
  es5ClassCompat
], SourceBreakpoint);
var FunctionBreakpoint = class FunctionBreakpoint2 extends Breakpoint {
  constructor(functionName, enabled, condition, hitCondition, logMessage, mode) {
    super(enabled, condition, hitCondition, logMessage, mode);
    this.functionName = functionName;
  }
};
FunctionBreakpoint = __decorate([
  es5ClassCompat
], FunctionBreakpoint);
var DataBreakpoint = class DataBreakpoint2 extends Breakpoint {
  constructor(label, dataId, canPersist, enabled, condition, hitCondition, logMessage, mode) {
    super(enabled, condition, hitCondition, logMessage, mode);
    if (!dataId) {
      throw illegalArgument("dataId");
    }
    this.label = label;
    this.dataId = dataId;
    this.canPersist = canPersist;
  }
};
DataBreakpoint = __decorate([
  es5ClassCompat
], DataBreakpoint);
var DebugAdapterExecutable = class DebugAdapterExecutable2 {
  constructor(command, args, options2) {
    this.command = command;
    this.args = args || [];
    this.options = options2;
  }
};
DebugAdapterExecutable = __decorate([
  es5ClassCompat
], DebugAdapterExecutable);
var DebugAdapterServer = class DebugAdapterServer2 {
  constructor(port, host) {
    this.port = port;
    this.host = host;
  }
};
DebugAdapterServer = __decorate([
  es5ClassCompat
], DebugAdapterServer);
var DebugAdapterNamedPipeServer = class DebugAdapterNamedPipeServer2 {
  constructor(path) {
    this.path = path;
  }
};
DebugAdapterNamedPipeServer = __decorate([
  es5ClassCompat
], DebugAdapterNamedPipeServer);
var DebugAdapterInlineImplementation = class DebugAdapterInlineImplementation2 {
  constructor(impl) {
    this.implementation = impl;
  }
};
DebugAdapterInlineImplementation = __decorate([
  es5ClassCompat
], DebugAdapterInlineImplementation);
var DebugStackFrame = class {
  constructor(session, threadId, frameId) {
    this.session = session;
    this.threadId = threadId;
    this.frameId = frameId;
  }
};
var DebugThread = class {
  constructor(session, threadId) {
    this.session = session;
    this.threadId = threadId;
  }
};
var EvaluatableExpression = class EvaluatableExpression2 {
  constructor(range, expression) {
    this.range = range;
    this.expression = expression;
  }
};
EvaluatableExpression = __decorate([
  es5ClassCompat
], EvaluatableExpression);
var InlineCompletionTriggerKind2;
(function(InlineCompletionTriggerKind3) {
  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Invoke"] = 0] = "Invoke";
  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 1] = "Automatic";
})(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
var InlineCompletionsDisposeReasonKind;
(function(InlineCompletionsDisposeReasonKind2) {
  InlineCompletionsDisposeReasonKind2[InlineCompletionsDisposeReasonKind2["Other"] = 0] = "Other";
  InlineCompletionsDisposeReasonKind2[InlineCompletionsDisposeReasonKind2["Empty"] = 1] = "Empty";
  InlineCompletionsDisposeReasonKind2[InlineCompletionsDisposeReasonKind2["TokenCancellation"] = 2] = "TokenCancellation";
  InlineCompletionsDisposeReasonKind2[InlineCompletionsDisposeReasonKind2["LostRace"] = 3] = "LostRace";
  InlineCompletionsDisposeReasonKind2[InlineCompletionsDisposeReasonKind2["NotTaken"] = 4] = "NotTaken";
})(InlineCompletionsDisposeReasonKind || (InlineCompletionsDisposeReasonKind = {}));
var InlineValueText = class InlineValueText2 {
  constructor(range, text) {
    this.range = range;
    this.text = text;
  }
};
InlineValueText = __decorate([
  es5ClassCompat
], InlineValueText);
var InlineValueVariableLookup = class InlineValueVariableLookup2 {
  constructor(range, variableName, caseSensitiveLookup = true) {
    this.range = range;
    this.variableName = variableName;
    this.caseSensitiveLookup = caseSensitiveLookup;
  }
};
InlineValueVariableLookup = __decorate([
  es5ClassCompat
], InlineValueVariableLookup);
var InlineValueEvaluatableExpression = class InlineValueEvaluatableExpression2 {
  constructor(range, expression) {
    this.range = range;
    this.expression = expression;
  }
};
InlineValueEvaluatableExpression = __decorate([
  es5ClassCompat
], InlineValueEvaluatableExpression);
var InlineValueContext = class InlineValueContext2 {
  constructor(frameId, range) {
    this.frameId = frameId;
    this.stoppedLocation = range;
  }
};
InlineValueContext = __decorate([
  es5ClassCompat
], InlineValueContext);
var NewSymbolNameTag2;
(function(NewSymbolNameTag3) {
  NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
})(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));
var NewSymbolNameTriggerKind2;
(function(NewSymbolNameTriggerKind3) {
  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
})(NewSymbolNameTriggerKind2 || (NewSymbolNameTriggerKind2 = {}));
var NewSymbolName = class {
  constructor(newSymbolName, tags) {
    this.newSymbolName = newSymbolName;
    this.tags = tags;
  }
};
var FileChangeType2;
(function(FileChangeType3) {
  FileChangeType3[FileChangeType3["Changed"] = 1] = "Changed";
  FileChangeType3[FileChangeType3["Created"] = 2] = "Created";
  FileChangeType3[FileChangeType3["Deleted"] = 3] = "Deleted";
})(FileChangeType2 || (FileChangeType2 = {}));
var FileSystemError = FileSystemError_1 = class FileSystemError2 extends Error {
  static FileExists(messageOrUri) {
    return new FileSystemError_1(messageOrUri, FileSystemProviderErrorCode.FileExists, FileSystemError_1.FileExists);
  }
  static FileNotFound(messageOrUri) {
    return new FileSystemError_1(messageOrUri, FileSystemProviderErrorCode.FileNotFound, FileSystemError_1.FileNotFound);
  }
  static FileNotADirectory(messageOrUri) {
    return new FileSystemError_1(messageOrUri, FileSystemProviderErrorCode.FileNotADirectory, FileSystemError_1.FileNotADirectory);
  }
  static FileIsADirectory(messageOrUri) {
    return new FileSystemError_1(messageOrUri, FileSystemProviderErrorCode.FileIsADirectory, FileSystemError_1.FileIsADirectory);
  }
  static NoPermissions(messageOrUri) {
    return new FileSystemError_1(messageOrUri, FileSystemProviderErrorCode.NoPermissions, FileSystemError_1.NoPermissions);
  }
  static Unavailable(messageOrUri) {
    return new FileSystemError_1(messageOrUri, FileSystemProviderErrorCode.Unavailable, FileSystemError_1.Unavailable);
  }
  constructor(uriOrMessage, code = FileSystemProviderErrorCode.Unknown, terminator) {
    super(URI.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage);
    this.code = terminator?.name ?? "Unknown";
    markAsFileSystemProviderError(this, code);
    Object.setPrototypeOf(this, FileSystemError_1.prototype);
    if (typeof Error.captureStackTrace === "function" && typeof terminator === "function") {
      Error.captureStackTrace(this, terminator);
    }
  }
};
FileSystemError = FileSystemError_1 = __decorate([
  es5ClassCompat
], FileSystemError);
var FoldingRange = class FoldingRange2 {
  constructor(start, end, kind) {
    this.start = start;
    this.end = end;
    this.kind = kind;
  }
};
FoldingRange = __decorate([
  es5ClassCompat
], FoldingRange);
var FoldingRangeKind2;
(function(FoldingRangeKind4) {
  FoldingRangeKind4[FoldingRangeKind4["Comment"] = 1] = "Comment";
  FoldingRangeKind4[FoldingRangeKind4["Imports"] = 2] = "Imports";
  FoldingRangeKind4[FoldingRangeKind4["Region"] = 3] = "Region";
})(FoldingRangeKind2 || (FoldingRangeKind2 = {}));
var CommentThreadCollapsibleState2;
(function(CommentThreadCollapsibleState3) {
  CommentThreadCollapsibleState3[CommentThreadCollapsibleState3["Collapsed"] = 0] = "Collapsed";
  CommentThreadCollapsibleState3[CommentThreadCollapsibleState3["Expanded"] = 1] = "Expanded";
})(CommentThreadCollapsibleState2 || (CommentThreadCollapsibleState2 = {}));
var CommentMode2;
(function(CommentMode3) {
  CommentMode3[CommentMode3["Editing"] = 0] = "Editing";
  CommentMode3[CommentMode3["Preview"] = 1] = "Preview";
})(CommentMode2 || (CommentMode2 = {}));
var CommentState2;
(function(CommentState3) {
  CommentState3[CommentState3["Published"] = 0] = "Published";
  CommentState3[CommentState3["Draft"] = 1] = "Draft";
})(CommentState2 || (CommentState2 = {}));
var CommentThreadState2;
(function(CommentThreadState3) {
  CommentThreadState3[CommentThreadState3["Unresolved"] = 0] = "Unresolved";
  CommentThreadState3[CommentThreadState3["Resolved"] = 1] = "Resolved";
})(CommentThreadState2 || (CommentThreadState2 = {}));
var CommentThreadApplicability2;
(function(CommentThreadApplicability3) {
  CommentThreadApplicability3[CommentThreadApplicability3["Current"] = 0] = "Current";
  CommentThreadApplicability3[CommentThreadApplicability3["Outdated"] = 1] = "Outdated";
})(CommentThreadApplicability2 || (CommentThreadApplicability2 = {}));
var CommentThreadFocus;
(function(CommentThreadFocus2) {
  CommentThreadFocus2[CommentThreadFocus2["Reply"] = 1] = "Reply";
  CommentThreadFocus2[CommentThreadFocus2["Comment"] = 2] = "Comment";
})(CommentThreadFocus || (CommentThreadFocus = {}));
var SemanticTokensLegend = class {
  constructor(tokenTypes, tokenModifiers = []) {
    this.tokenTypes = tokenTypes;
    this.tokenModifiers = tokenModifiers;
  }
};
function isStrArrayOrUndefined(arg) {
  return typeof arg === "undefined" || isStringArray(arg);
}
var SemanticTokensBuilder = class _SemanticTokensBuilder {
  constructor(legend) {
    this._prevLine = 0;
    this._prevChar = 0;
    this._dataIsSortedAndDeltaEncoded = true;
    this._data = [];
    this._dataLen = 0;
    this._tokenTypeStrToInt = /* @__PURE__ */ new Map();
    this._tokenModifierStrToInt = /* @__PURE__ */ new Map();
    this._hasLegend = false;
    if (legend) {
      this._hasLegend = true;
      for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
        this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
      }
      for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
        this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
      }
    }
  }
  push(arg0, arg1, arg2, arg3, arg4) {
    if (typeof arg0 === "number" && typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && (typeof arg4 === "number" || typeof arg4 === "undefined")) {
      if (typeof arg4 === "undefined") {
        arg4 = 0;
      }
      return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
    }
    if (Range2.isRange(arg0) && typeof arg1 === "string" && isStrArrayOrUndefined(arg2)) {
      return this._push(arg0, arg1, arg2);
    }
    throw illegalArgument();
  }
  _push(range, tokenType, tokenModifiers) {
    if (!this._hasLegend) {
      throw new Error("Legend must be provided in constructor");
    }
    if (range.start.line !== range.end.line) {
      throw new Error("`range` cannot span multiple lines");
    }
    if (!this._tokenTypeStrToInt.has(tokenType)) {
      throw new Error("`tokenType` is not in the provided legend");
    }
    const line = range.start.line;
    const char = range.start.character;
    const length = range.end.character - range.start.character;
    const nTokenType = this._tokenTypeStrToInt.get(tokenType);
    let nTokenModifiers = 0;
    if (tokenModifiers) {
      for (const tokenModifier of tokenModifiers) {
        if (!this._tokenModifierStrToInt.has(tokenModifier)) {
          throw new Error("`tokenModifier` is not in the provided legend");
        }
        const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
        nTokenModifiers |= 1 << nTokenModifier >>> 0;
      }
    }
    this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
  }
  _pushEncoded(line, char, length, tokenType, tokenModifiers) {
    if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || line === this._prevLine && char < this._prevChar)) {
      this._dataIsSortedAndDeltaEncoded = false;
      const tokenCount = this._data.length / 5 | 0;
      let prevLine = 0;
      let prevChar = 0;
      for (let i = 0; i < tokenCount; i++) {
        let line2 = this._data[5 * i];
        let char2 = this._data[5 * i + 1];
        if (line2 === 0) {
          line2 = prevLine;
          char2 += prevChar;
        } else {
          line2 += prevLine;
        }
        this._data[5 * i] = line2;
        this._data[5 * i + 1] = char2;
        prevLine = line2;
        prevChar = char2;
      }
    }
    let pushLine = line;
    let pushChar = char;
    if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
      pushLine -= this._prevLine;
      if (pushLine === 0) {
        pushChar -= this._prevChar;
      }
    }
    this._data[this._dataLen++] = pushLine;
    this._data[this._dataLen++] = pushChar;
    this._data[this._dataLen++] = length;
    this._data[this._dataLen++] = tokenType;
    this._data[this._dataLen++] = tokenModifiers;
    this._prevLine = line;
    this._prevChar = char;
  }
  static _sortAndDeltaEncode(data2) {
    const pos = [];
    const tokenCount = data2.length / 5 | 0;
    for (let i = 0; i < tokenCount; i++) {
      pos[i] = i;
    }
    pos.sort((a, b) => {
      const aLine = data2[5 * a];
      const bLine = data2[5 * b];
      if (aLine === bLine) {
        const aChar = data2[5 * a + 1];
        const bChar = data2[5 * b + 1];
        return aChar - bChar;
      }
      return aLine - bLine;
    });
    const result = new Uint32Array(data2.length);
    let prevLine = 0;
    let prevChar = 0;
    for (let i = 0; i < tokenCount; i++) {
      const srcOffset = 5 * pos[i];
      const line = data2[srcOffset + 0];
      const char = data2[srcOffset + 1];
      const length = data2[srcOffset + 2];
      const tokenType = data2[srcOffset + 3];
      const tokenModifiers = data2[srcOffset + 4];
      const pushLine = line - prevLine;
      const pushChar = pushLine === 0 ? char - prevChar : char;
      const dstOffset = 5 * i;
      result[dstOffset + 0] = pushLine;
      result[dstOffset + 1] = pushChar;
      result[dstOffset + 2] = length;
      result[dstOffset + 3] = tokenType;
      result[dstOffset + 4] = tokenModifiers;
      prevLine = line;
      prevChar = char;
    }
    return result;
  }
  build(resultId) {
    if (!this._dataIsSortedAndDeltaEncoded) {
      return new SemanticTokens(_SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId);
    }
    return new SemanticTokens(new Uint32Array(this._data), resultId);
  }
};
var SemanticTokens = class {
  constructor(data2, resultId) {
    this.resultId = resultId;
    this.data = data2;
  }
};
var SemanticTokensEdit = class {
  constructor(start, deleteCount, data2) {
    this.start = start;
    this.deleteCount = deleteCount;
    this.data = data2;
  }
};
var SemanticTokensEdits = class {
  constructor(edits, resultId) {
    this.resultId = resultId;
    this.edits = edits;
  }
};
var DebugConsoleMode;
(function(DebugConsoleMode2) {
  DebugConsoleMode2[DebugConsoleMode2["Separate"] = 0] = "Separate";
  DebugConsoleMode2[DebugConsoleMode2["MergeWithParent"] = 1] = "MergeWithParent";
})(DebugConsoleMode || (DebugConsoleMode = {}));
var DebugVisualization = class {
  constructor(name2) {
    this.name = name2;
  }
};
var QuickInputButtonLocation;
(function(QuickInputButtonLocation2) {
  QuickInputButtonLocation2[QuickInputButtonLocation2["Title"] = 1] = "Title";
  QuickInputButtonLocation2[QuickInputButtonLocation2["Inline"] = 2] = "Inline";
  QuickInputButtonLocation2[QuickInputButtonLocation2["Input"] = 3] = "Input";
})(QuickInputButtonLocation || (QuickInputButtonLocation = {}));
var QuickInputButtons = class QuickInputButtons2 {
  static {
    this.Back = { iconPath: new ThemeIcon2("arrow-left") };
  }
  constructor() {
  }
};
QuickInputButtons = __decorate([
  es5ClassCompat
], QuickInputButtons);
var QuickPickItemKind;
(function(QuickPickItemKind2) {
  QuickPickItemKind2[QuickPickItemKind2["Separator"] = -1] = "Separator";
  QuickPickItemKind2[QuickPickItemKind2["Default"] = 0] = "Default";
})(QuickPickItemKind || (QuickPickItemKind = {}));
var InputBoxValidationSeverity;
(function(InputBoxValidationSeverity2) {
  InputBoxValidationSeverity2[InputBoxValidationSeverity2["Info"] = 1] = "Info";
  InputBoxValidationSeverity2[InputBoxValidationSeverity2["Warning"] = 2] = "Warning";
  InputBoxValidationSeverity2[InputBoxValidationSeverity2["Error"] = 3] = "Error";
})(InputBoxValidationSeverity || (InputBoxValidationSeverity = {}));
var ExtensionKind;
(function(ExtensionKind2) {
  ExtensionKind2[ExtensionKind2["UI"] = 1] = "UI";
  ExtensionKind2[ExtensionKind2["Workspace"] = 2] = "Workspace";
})(ExtensionKind || (ExtensionKind = {}));
var FileDecoration = class {
  static validate(d) {
    if (typeof d.badge === "string") {
      let len = nextCharLength(d.badge, 0);
      if (len < d.badge.length) {
        len += nextCharLength(d.badge, len);
      }
      if (d.badge.length > len) {
        throw new Error(`The 'badge'-property must be undefined or a short character`);
      }
    } else if (d.badge) {
      if (!ThemeIcon2.isThemeIcon(d.badge)) {
        throw new Error(`The 'badge'-property is not a valid ThemeIcon`);
      }
    }
    if (!d.color && !d.badge && !d.tooltip) {
      throw new Error(`The decoration is empty`);
    }
    return true;
  }
  constructor(badge, tooltip, color) {
    this.badge = badge;
    this.tooltip = tooltip;
    this.color = color;
  }
};
var ColorTheme = class ColorTheme2 {
  constructor(kind) {
    this.kind = kind;
  }
};
ColorTheme = __decorate([
  es5ClassCompat
], ColorTheme);
var ColorThemeKind;
(function(ColorThemeKind2) {
  ColorThemeKind2[ColorThemeKind2["Light"] = 1] = "Light";
  ColorThemeKind2[ColorThemeKind2["Dark"] = 2] = "Dark";
  ColorThemeKind2[ColorThemeKind2["HighContrast"] = 3] = "HighContrast";
  ColorThemeKind2[ColorThemeKind2["HighContrastLight"] = 4] = "HighContrastLight";
})(ColorThemeKind || (ColorThemeKind = {}));
var CellErrorStackFrame = class {
  /**
   * @param label The name of the stack frame
   * @param file The file URI of the stack frame
   * @param position The position of the stack frame within the file
   */
  constructor(label, uri, position) {
    this.label = label;
    this.uri = uri;
    this.position = position;
  }
};
var NotebookCellExecutionState2;
(function(NotebookCellExecutionState3) {
  NotebookCellExecutionState3[NotebookCellExecutionState3["Idle"] = 1] = "Idle";
  NotebookCellExecutionState3[NotebookCellExecutionState3["Pending"] = 2] = "Pending";
  NotebookCellExecutionState3[NotebookCellExecutionState3["Executing"] = 3] = "Executing";
})(NotebookCellExecutionState2 || (NotebookCellExecutionState2 = {}));
var NotebookCellStatusBarAlignment;
(function(NotebookCellStatusBarAlignment2) {
  NotebookCellStatusBarAlignment2[NotebookCellStatusBarAlignment2["Left"] = 1] = "Left";
  NotebookCellStatusBarAlignment2[NotebookCellStatusBarAlignment2["Right"] = 2] = "Right";
})(NotebookCellStatusBarAlignment || (NotebookCellStatusBarAlignment = {}));
var NotebookEditorRevealType2;
(function(NotebookEditorRevealType3) {
  NotebookEditorRevealType3[NotebookEditorRevealType3["Default"] = 0] = "Default";
  NotebookEditorRevealType3[NotebookEditorRevealType3["InCenter"] = 1] = "InCenter";
  NotebookEditorRevealType3[NotebookEditorRevealType3["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
  NotebookEditorRevealType3[NotebookEditorRevealType3["AtTop"] = 3] = "AtTop";
})(NotebookEditorRevealType2 || (NotebookEditorRevealType2 = {}));
var NotebookCellStatusBarItem = class {
  constructor(text, alignment) {
    this.text = text;
    this.alignment = alignment;
  }
};
var NotebookControllerAffinity;
(function(NotebookControllerAffinity3) {
  NotebookControllerAffinity3[NotebookControllerAffinity3["Default"] = 1] = "Default";
  NotebookControllerAffinity3[NotebookControllerAffinity3["Preferred"] = 2] = "Preferred";
})(NotebookControllerAffinity || (NotebookControllerAffinity = {}));
var NotebookControllerAffinity2;
(function(NotebookControllerAffinity22) {
  NotebookControllerAffinity22[NotebookControllerAffinity22["Default"] = 1] = "Default";
  NotebookControllerAffinity22[NotebookControllerAffinity22["Preferred"] = 2] = "Preferred";
  NotebookControllerAffinity22[NotebookControllerAffinity22["Hidden"] = -1] = "Hidden";
})(NotebookControllerAffinity2 || (NotebookControllerAffinity2 = {}));
var NotebookRendererScript = class {
  constructor(uri, provides = []) {
    this.uri = uri;
    this.provides = asArray(provides);
  }
};
var NotebookKernelSourceAction = class {
  constructor(label) {
    this.label = label;
  }
};
var NotebookVariablesRequestKind;
(function(NotebookVariablesRequestKind2) {
  NotebookVariablesRequestKind2[NotebookVariablesRequestKind2["Named"] = 1] = "Named";
  NotebookVariablesRequestKind2[NotebookVariablesRequestKind2["Indexed"] = 2] = "Indexed";
})(NotebookVariablesRequestKind || (NotebookVariablesRequestKind = {}));
var TimelineItem = class TimelineItem2 {
  constructor(label, timestamp) {
    this.label = label;
    this.timestamp = timestamp;
  }
};
TimelineItem = __decorate([
  es5ClassCompat
], TimelineItem);
var ExtensionMode;
(function(ExtensionMode2) {
  ExtensionMode2[ExtensionMode2["Production"] = 1] = "Production";
  ExtensionMode2[ExtensionMode2["Development"] = 2] = "Development";
  ExtensionMode2[ExtensionMode2["Test"] = 3] = "Test";
})(ExtensionMode || (ExtensionMode = {}));
var ExtensionRuntime;
(function(ExtensionRuntime2) {
  ExtensionRuntime2[ExtensionRuntime2["Node"] = 1] = "Node";
  ExtensionRuntime2[ExtensionRuntime2["Webworker"] = 2] = "Webworker";
})(ExtensionRuntime || (ExtensionRuntime = {}));
var StandardTokenType;
(function(StandardTokenType2) {
  StandardTokenType2[StandardTokenType2["Other"] = 0] = "Other";
  StandardTokenType2[StandardTokenType2["Comment"] = 1] = "Comment";
  StandardTokenType2[StandardTokenType2["String"] = 2] = "String";
  StandardTokenType2[StandardTokenType2["RegEx"] = 3] = "RegEx";
})(StandardTokenType || (StandardTokenType = {}));
var LinkedEditingRanges = class {
  constructor(ranges, wordPattern) {
    this.ranges = ranges;
    this.wordPattern = wordPattern;
  }
};
var PortAttributes = class {
  constructor(autoForwardAction) {
    this._autoForwardAction = autoForwardAction;
  }
  get autoForwardAction() {
    return this._autoForwardAction;
  }
};
var TestResultState2;
(function(TestResultState3) {
  TestResultState3[TestResultState3["Queued"] = 1] = "Queued";
  TestResultState3[TestResultState3["Running"] = 2] = "Running";
  TestResultState3[TestResultState3["Passed"] = 3] = "Passed";
  TestResultState3[TestResultState3["Failed"] = 4] = "Failed";
  TestResultState3[TestResultState3["Skipped"] = 5] = "Skipped";
  TestResultState3[TestResultState3["Errored"] = 6] = "Errored";
})(TestResultState2 || (TestResultState2 = {}));
var TestRunProfileKind;
(function(TestRunProfileKind3) {
  TestRunProfileKind3[TestRunProfileKind3["Run"] = 1] = "Run";
  TestRunProfileKind3[TestRunProfileKind3["Debug"] = 2] = "Debug";
  TestRunProfileKind3[TestRunProfileKind3["Coverage"] = 3] = "Coverage";
})(TestRunProfileKind || (TestRunProfileKind = {}));
var TestRunProfileBase = class {
  constructor(controllerId, profileId, kind) {
    this.controllerId = controllerId;
    this.profileId = profileId;
    this.kind = kind;
  }
};
var TestRunRequest = class TestRunRequest2 {
  constructor(include = void 0, exclude = void 0, profile = void 0, continuous = false, preserveFocus = true) {
    this.include = include;
    this.exclude = exclude;
    this.profile = profile;
    this.continuous = continuous;
    this.preserveFocus = preserveFocus;
  }
};
TestRunRequest = __decorate([
  es5ClassCompat
], TestRunRequest);
var TestMessage = TestMessage_1 = class TestMessage2 {
  static diff(message, expected, actual) {
    const msg = new TestMessage_1(message);
    msg.expectedOutput = expected;
    msg.actualOutput = actual;
    return msg;
  }
  constructor(message) {
    this.message = message;
  }
};
TestMessage = TestMessage_1 = __decorate([
  es5ClassCompat
], TestMessage);
var TestTag = class TestTag2 {
  constructor(id2) {
    this.id = id2;
  }
};
TestTag = __decorate([
  es5ClassCompat
], TestTag);
var TestMessageStackFrame = class {
  /**
   * @param label The name of the stack frame
   * @param file The file URI of the stack frame
   * @param position The position of the stack frame within the file
   */
  constructor(label, uri, position) {
    this.label = label;
    this.uri = uri;
    this.position = position;
  }
};
var TestCoverageCount = class {
  constructor(covered, total) {
    this.covered = covered;
    this.total = total;
    validateTestCoverageCount(this);
  }
};
function validateTestCoverageCount(cc) {
  if (!cc) {
    return;
  }
  if (cc.covered > cc.total) {
    throw new Error(`The total number of covered items (${cc.covered}) cannot be greater than the total (${cc.total})`);
  }
  if (cc.total < 0) {
    throw new Error(`The number of covered items (${cc.total}) cannot be negative`);
  }
}
var FileCoverage = class _FileCoverage {
  static fromDetails(uri, details) {
    const statements = new TestCoverageCount(0, 0);
    const branches = new TestCoverageCount(0, 0);
    const decl = new TestCoverageCount(0, 0);
    for (const detail of details) {
      if ("branches" in detail) {
        statements.total += 1;
        statements.covered += detail.executed ? 1 : 0;
        for (const branch of detail.branches) {
          branches.total += 1;
          branches.covered += branch.executed ? 1 : 0;
        }
      } else {
        decl.total += 1;
        decl.covered += detail.executed ? 1 : 0;
      }
    }
    const coverage = new _FileCoverage(uri, statements, branches.total > 0 ? branches : void 0, decl.total > 0 ? decl : void 0);
    coverage.detailedCoverage = details;
    return coverage;
  }
  constructor(uri, statementCoverage, branchCoverage, declarationCoverage, includesTests = []) {
    this.uri = uri;
    this.statementCoverage = statementCoverage;
    this.branchCoverage = branchCoverage;
    this.declarationCoverage = declarationCoverage;
    this.includesTests = includesTests;
  }
};
var StatementCoverage = class {
  // back compat until finalization:
  get executionCount() {
    return +this.executed;
  }
  set executionCount(n) {
    this.executed = n;
  }
  constructor(executed, location2, branches = []) {
    this.executed = executed;
    this.location = location2;
    this.branches = branches;
  }
};
var BranchCoverage = class {
  // back compat until finalization:
  get executionCount() {
    return +this.executed;
  }
  set executionCount(n) {
    this.executed = n;
  }
  constructor(executed, location2, label) {
    this.executed = executed;
    this.location = location2;
    this.label = label;
  }
};
var DeclarationCoverage = class {
  // back compat until finalization:
  get executionCount() {
    return +this.executed;
  }
  set executionCount(n) {
    this.executed = n;
  }
  constructor(name2, executed, location2) {
    this.name = name2;
    this.executed = executed;
    this.location = location2;
  }
};
var ExternalUriOpenerPriority2;
(function(ExternalUriOpenerPriority3) {
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["None"] = 0] = "None";
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Option"] = 1] = "Option";
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Default"] = 2] = "Default";
  ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Preferred"] = 3] = "Preferred";
})(ExternalUriOpenerPriority2 || (ExternalUriOpenerPriority2 = {}));
var WorkspaceTrustState;
(function(WorkspaceTrustState2) {
  WorkspaceTrustState2[WorkspaceTrustState2["Untrusted"] = 0] = "Untrusted";
  WorkspaceTrustState2[WorkspaceTrustState2["Trusted"] = 1] = "Trusted";
  WorkspaceTrustState2[WorkspaceTrustState2["Unspecified"] = 2] = "Unspecified";
})(WorkspaceTrustState || (WorkspaceTrustState = {}));
var PortAutoForwardAction;
(function(PortAutoForwardAction2) {
  PortAutoForwardAction2[PortAutoForwardAction2["Notify"] = 1] = "Notify";
  PortAutoForwardAction2[PortAutoForwardAction2["OpenBrowser"] = 2] = "OpenBrowser";
  PortAutoForwardAction2[PortAutoForwardAction2["OpenPreview"] = 3] = "OpenPreview";
  PortAutoForwardAction2[PortAutoForwardAction2["Silent"] = 4] = "Silent";
  PortAutoForwardAction2[PortAutoForwardAction2["Ignore"] = 5] = "Ignore";
  PortAutoForwardAction2[PortAutoForwardAction2["OpenBrowserOnce"] = 6] = "OpenBrowserOnce";
})(PortAutoForwardAction || (PortAutoForwardAction = {}));
var TypeHierarchyItem = class {
  constructor(kind, name2, detail, uri, range, selectionRange) {
    this.kind = kind;
    this.name = name2;
    this.detail = detail;
    this.uri = uri;
    this.range = range;
    this.selectionRange = selectionRange;
  }
};
var TextTabInput = class {
  constructor(uri) {
    this.uri = uri;
  }
};
var TextDiffTabInput = class {
  constructor(original, modified) {
    this.original = original;
    this.modified = modified;
  }
};
var TextMergeTabInput = class {
  constructor(base, input1, input2, result) {
    this.base = base;
    this.input1 = input1;
    this.input2 = input2;
    this.result = result;
  }
};
var CustomEditorTabInput = class {
  constructor(uri, viewType) {
    this.uri = uri;
    this.viewType = viewType;
  }
};
var WebviewEditorTabInput = class {
  constructor(viewType) {
    this.viewType = viewType;
  }
};
var NotebookEditorTabInput = class {
  constructor(uri, notebookType) {
    this.uri = uri;
    this.notebookType = notebookType;
  }
};
var NotebookDiffEditorTabInput = class {
  constructor(original, modified, notebookType) {
    this.original = original;
    this.modified = modified;
    this.notebookType = notebookType;
  }
};
var TerminalEditorTabInput = class {
  constructor() {
  }
};
var InteractiveWindowInput = class {
  constructor(uri, inputBoxUri) {
    this.uri = uri;
    this.inputBoxUri = inputBoxUri;
  }
};
var ChatEditorTabInput = class {
  constructor() {
  }
};
var TextMultiDiffTabInput = class {
  constructor(textDiffs) {
    this.textDiffs = textDiffs;
  }
};
var InteractiveSessionVoteDirection;
(function(InteractiveSessionVoteDirection2) {
  InteractiveSessionVoteDirection2[InteractiveSessionVoteDirection2["Down"] = 0] = "Down";
  InteractiveSessionVoteDirection2[InteractiveSessionVoteDirection2["Up"] = 1] = "Up";
})(InteractiveSessionVoteDirection || (InteractiveSessionVoteDirection = {}));
var ChatCopyKind;
(function(ChatCopyKind3) {
  ChatCopyKind3[ChatCopyKind3["Action"] = 1] = "Action";
  ChatCopyKind3[ChatCopyKind3["Toolbar"] = 2] = "Toolbar";
})(ChatCopyKind || (ChatCopyKind = {}));
var ChatVariableLevel;
(function(ChatVariableLevel2) {
  ChatVariableLevel2[ChatVariableLevel2["Short"] = 1] = "Short";
  ChatVariableLevel2[ChatVariableLevel2["Medium"] = 2] = "Medium";
  ChatVariableLevel2[ChatVariableLevel2["Full"] = 3] = "Full";
})(ChatVariableLevel || (ChatVariableLevel = {}));
var ChatCompletionItem = class {
  constructor(id2, label, values) {
    this.id = id2;
    this.label = label;
    this.values = values;
  }
};
var ChatEditingSessionActionOutcome;
(function(ChatEditingSessionActionOutcome2) {
  ChatEditingSessionActionOutcome2[ChatEditingSessionActionOutcome2["Accepted"] = 1] = "Accepted";
  ChatEditingSessionActionOutcome2[ChatEditingSessionActionOutcome2["Rejected"] = 2] = "Rejected";
  ChatEditingSessionActionOutcome2[ChatEditingSessionActionOutcome2["Saved"] = 3] = "Saved";
})(ChatEditingSessionActionOutcome || (ChatEditingSessionActionOutcome = {}));
var ChatRequestEditedFileEventKind;
(function(ChatRequestEditedFileEventKind2) {
  ChatRequestEditedFileEventKind2[ChatRequestEditedFileEventKind2["Keep"] = 1] = "Keep";
  ChatRequestEditedFileEventKind2[ChatRequestEditedFileEventKind2["Undo"] = 2] = "Undo";
  ChatRequestEditedFileEventKind2[ChatRequestEditedFileEventKind2["UserModification"] = 3] = "UserModification";
})(ChatRequestEditedFileEventKind || (ChatRequestEditedFileEventKind = {}));
var InteractiveEditorResponseFeedbackKind;
(function(InteractiveEditorResponseFeedbackKind2) {
  InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Unhelpful"] = 0] = "Unhelpful";
  InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Helpful"] = 1] = "Helpful";
  InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Undone"] = 2] = "Undone";
  InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Accepted"] = 3] = "Accepted";
  InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Bug"] = 4] = "Bug";
})(InteractiveEditorResponseFeedbackKind || (InteractiveEditorResponseFeedbackKind = {}));
var ChatResultFeedbackKind;
(function(ChatResultFeedbackKind2) {
  ChatResultFeedbackKind2[ChatResultFeedbackKind2["Unhelpful"] = 0] = "Unhelpful";
  ChatResultFeedbackKind2[ChatResultFeedbackKind2["Helpful"] = 1] = "Helpful";
})(ChatResultFeedbackKind || (ChatResultFeedbackKind = {}));
var ChatResponseMarkdownPart = class {
  constructor(value) {
    if (typeof value !== "string" && value.isTrusted === true) {
      throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.");
    }
    this.value = typeof value === "string" ? new MarkdownString2(value) : value;
  }
};
var ChatResponseMarkdownWithVulnerabilitiesPart = class {
  constructor(value, vulnerabilities) {
    if (typeof value !== "string" && value.isTrusted === true) {
      throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.");
    }
    this.value = typeof value === "string" ? new MarkdownString2(value) : value;
    this.vulnerabilities = vulnerabilities;
  }
};
var ChatResponseConfirmationPart = class {
  constructor(title, message, data2, buttons) {
    this.title = title;
    this.message = message;
    this.data = data2;
    this.buttons = buttons;
  }
};
var ChatResponseFileTreePart = class {
  constructor(value, baseUri) {
    this.value = value;
    this.baseUri = baseUri;
  }
};
var ChatResponseMultiDiffPart = class {
  constructor(value, title, readOnly) {
    this.value = value;
    this.title = title;
    this.readOnly = readOnly;
  }
};
var ChatResponseExternalEditPart = class {
  constructor(uris, callback) {
    this.uris = uris;
    this.callback = callback;
    this.applied = new Promise((resolve2) => {
      this.didGetApplied = resolve2;
    });
  }
};
var ChatResponseAnchorPart = class {
  constructor(value, title) {
    this.value = value;
    this.value2 = value;
    this.title = title;
  }
};
var ChatResponseProgressPart = class {
  constructor(value) {
    this.value = value;
  }
};
var ChatResponseProgressPart2 = class {
  constructor(value, task) {
    this.value = value;
    this.task = task;
  }
};
var ChatResponseThinkingProgressPart = class {
  constructor(value, id2, metadata) {
    this.value = value;
    this.id = id2;
    this.metadata = metadata;
  }
};
var ChatResponseWarningPart = class {
  constructor(value) {
    if (typeof value !== "string" && value.isTrusted === true) {
      throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.");
    }
    this.value = typeof value === "string" ? new MarkdownString2(value) : value;
  }
};
var ChatResponseCommandButtonPart = class {
  constructor(value) {
    this.value = value;
  }
};
var ChatResponseReferencePart = class {
  constructor(value, iconPath, options2) {
    this.value = value;
    this.iconPath = iconPath;
    this.options = options2;
  }
};
var ChatResponseCodeblockUriPart = class {
  constructor(value, isEdit) {
    this.value = value;
    this.isEdit = isEdit;
  }
};
var ChatResponseCodeCitationPart = class {
  constructor(value, license, snippet) {
    this.value = value;
    this.license = license;
    this.snippet = snippet;
  }
};
var ChatResponseMovePart = class {
  constructor(uri, range) {
    this.uri = uri;
    this.range = range;
  }
};
var ChatResponseExtensionsPart = class {
  constructor(extensions) {
    this.extensions = extensions;
  }
};
var ChatResponsePullRequestPart = class {
  constructor(uri, title, description, author, linkTag) {
    this.uri = uri;
    this.title = title;
    this.description = description;
    this.author = author;
    this.linkTag = linkTag;
  }
  toJSON() {
    return {
      $mid: 26,
      uri: this.uri,
      title: this.title,
      description: this.description,
      author: this.author
    };
  }
};
var ChatResponseTextEditPart = class {
  constructor(uri, editsOrDone) {
    this.uri = uri;
    if (editsOrDone === true) {
      this.isDone = true;
      this.edits = [];
    } else {
      this.edits = Array.isArray(editsOrDone) ? editsOrDone : [editsOrDone];
    }
  }
};
var ChatResponseNotebookEditPart = class {
  constructor(uri, editsOrDone) {
    this.uri = uri;
    if (editsOrDone === true) {
      this.isDone = true;
      this.edits = [];
    } else {
      this.edits = Array.isArray(editsOrDone) ? editsOrDone : [editsOrDone];
    }
  }
};
var ChatPrepareToolInvocationPart = class {
  /**
   * @param toolName The name of the tool being prepared for invocation.
   */
  constructor(toolName) {
    this.toolName = toolName;
  }
};
var ChatToolInvocationPart = class {
  constructor(toolName, toolCallId, isError) {
    this.toolName = toolName;
    this.toolCallId = toolCallId;
    this.isError = isError;
  }
};
var ChatRequestTurn = class {
  constructor(prompt, command, references, participant, toolReferences, editedFileEvents) {
    this.prompt = prompt;
    this.command = command;
    this.references = references;
    this.participant = participant;
    this.toolReferences = toolReferences;
    this.editedFileEvents = editedFileEvents;
  }
};
var ChatResponseTurn = class {
  constructor(response, result, participant, command) {
    this.response = response;
    this.result = result;
    this.participant = participant;
    this.command = command;
  }
};
var ChatResponseTurn2 = class {
  constructor(response, result, participant, command) {
    this.response = response;
    this.result = result;
    this.participant = participant;
    this.command = command;
  }
};
var ChatLocation;
(function(ChatLocation3) {
  ChatLocation3[ChatLocation3["Panel"] = 1] = "Panel";
  ChatLocation3[ChatLocation3["Terminal"] = 2] = "Terminal";
  ChatLocation3[ChatLocation3["Notebook"] = 3] = "Notebook";
  ChatLocation3[ChatLocation3["Editor"] = 4] = "Editor";
})(ChatLocation || (ChatLocation = {}));
var ChatSessionStatus2;
(function(ChatSessionStatus3) {
  ChatSessionStatus3[ChatSessionStatus3["Failed"] = 0] = "Failed";
  ChatSessionStatus3[ChatSessionStatus3["Completed"] = 1] = "Completed";
  ChatSessionStatus3[ChatSessionStatus3["InProgress"] = 2] = "InProgress";
})(ChatSessionStatus2 || (ChatSessionStatus2 = {}));
var ChatResponseReferencePartStatusKind;
(function(ChatResponseReferencePartStatusKind3) {
  ChatResponseReferencePartStatusKind3[ChatResponseReferencePartStatusKind3["Complete"] = 1] = "Complete";
  ChatResponseReferencePartStatusKind3[ChatResponseReferencePartStatusKind3["Partial"] = 2] = "Partial";
  ChatResponseReferencePartStatusKind3[ChatResponseReferencePartStatusKind3["Omitted"] = 3] = "Omitted";
})(ChatResponseReferencePartStatusKind || (ChatResponseReferencePartStatusKind = {}));
var ChatResponseClearToPreviousToolInvocationReason;
(function(ChatResponseClearToPreviousToolInvocationReason3) {
  ChatResponseClearToPreviousToolInvocationReason3[ChatResponseClearToPreviousToolInvocationReason3["NoReason"] = 0] = "NoReason";
  ChatResponseClearToPreviousToolInvocationReason3[ChatResponseClearToPreviousToolInvocationReason3["FilteredContentRetry"] = 1] = "FilteredContentRetry";
  ChatResponseClearToPreviousToolInvocationReason3[ChatResponseClearToPreviousToolInvocationReason3["CopyrightContentRetry"] = 2] = "CopyrightContentRetry";
})(ChatResponseClearToPreviousToolInvocationReason || (ChatResponseClearToPreviousToolInvocationReason = {}));
var ChatRequestEditorData = class {
  constructor(document2, selection, wholeRange) {
    this.document = document2;
    this.selection = selection;
    this.wholeRange = wholeRange;
  }
};
var ChatRequestNotebookData = class {
  constructor(cell) {
    this.cell = cell;
  }
};
var ChatReferenceBinaryData = class {
  constructor(mimeType, data2, reference) {
    this.mimeType = mimeType;
    this.data = data2;
    this.reference = reference;
  }
};
var ChatReferenceDiagnostic = class {
  constructor(diagnostics) {
    this.diagnostics = diagnostics;
  }
};
var LanguageModelChatMessageRole;
(function(LanguageModelChatMessageRole3) {
  LanguageModelChatMessageRole3[LanguageModelChatMessageRole3["User"] = 1] = "User";
  LanguageModelChatMessageRole3[LanguageModelChatMessageRole3["Assistant"] = 2] = "Assistant";
  LanguageModelChatMessageRole3[LanguageModelChatMessageRole3["System"] = 3] = "System";
})(LanguageModelChatMessageRole || (LanguageModelChatMessageRole = {}));
var LanguageModelToolResultPart = class {
  constructor(callId, content, isError) {
    this.callId = callId;
    this.content = content;
    this.isError = isError ?? false;
  }
};
var ChatErrorLevel;
(function(ChatErrorLevel3) {
  ChatErrorLevel3[ChatErrorLevel3["Info"] = 0] = "Info";
  ChatErrorLevel3[ChatErrorLevel3["Warning"] = 1] = "Warning";
  ChatErrorLevel3[ChatErrorLevel3["Error"] = 2] = "Error";
})(ChatErrorLevel || (ChatErrorLevel = {}));
var LanguageModelChatMessage = class _LanguageModelChatMessage {
  static User(content, name2) {
    return new _LanguageModelChatMessage(LanguageModelChatMessageRole.User, content, name2);
  }
  static Assistant(content, name2) {
    return new _LanguageModelChatMessage(LanguageModelChatMessageRole.Assistant, content, name2);
  }
  set content(value) {
    if (typeof value === "string") {
      this._content = [new LanguageModelTextPart(value)];
    } else {
      this._content = value;
    }
  }
  get content() {
    return this._content;
  }
  constructor(role, content, name2) {
    this._content = [];
    this.role = role;
    this.content = content;
    this.name = name2;
  }
};
var LanguageModelChatMessage2 = class _LanguageModelChatMessage2 {
  static User(content, name2) {
    return new _LanguageModelChatMessage2(LanguageModelChatMessageRole.User, content, name2);
  }
  static Assistant(content, name2) {
    return new _LanguageModelChatMessage2(LanguageModelChatMessageRole.Assistant, content, name2);
  }
  set content(value) {
    if (typeof value === "string") {
      this._content = [new LanguageModelTextPart(value)];
    } else {
      this._content = value;
    }
  }
  get content() {
    return this._content;
  }
  // Temp to avoid breaking changes
  set content2(value) {
    if (value) {
      this.content = value.map((part) => {
        if (typeof part === "string") {
          return new LanguageModelTextPart(part);
        }
        return part;
      });
    }
  }
  get content2() {
    return this.content.map((part) => {
      if (part instanceof LanguageModelTextPart) {
        return part.value;
      }
      return part;
    });
  }
  constructor(role, content, name2) {
    this._content = [];
    this.role = role;
    this.content = content;
    this.name = name2;
  }
};
var LanguageModelToolCallPart = class {
  constructor(callId, name2, input) {
    this.callId = callId;
    this.name = name2;
    this.input = input;
  }
};
var LanguageModelPartAudience;
(function(LanguageModelPartAudience3) {
  LanguageModelPartAudience3[LanguageModelPartAudience3["Assistant"] = 0] = "Assistant";
  LanguageModelPartAudience3[LanguageModelPartAudience3["User"] = 1] = "User";
  LanguageModelPartAudience3[LanguageModelPartAudience3["Extension"] = 2] = "Extension";
})(LanguageModelPartAudience || (LanguageModelPartAudience = {}));
var LanguageModelTextPart = class {
  constructor(value, audience) {
    this.value = value;
    audience = audience;
  }
  toJSON() {
    return {
      $mid: 21,
      value: this.value,
      audience: this.audience
    };
  }
};
var LanguageModelDataPart = class _LanguageModelDataPart {
  constructor(data2, mimeType, audience) {
    this.mimeType = mimeType;
    this.data = data2;
    this.audience = audience;
  }
  static image(data2, mimeType) {
    return new _LanguageModelDataPart(data2, mimeType);
  }
  static json(value, mime = "text/x-json") {
    const rawStr = JSON.stringify(value, void 0, "	");
    return new _LanguageModelDataPart(VSBuffer.fromString(rawStr).buffer, mime);
  }
  static text(value, mime = Mimes.text) {
    return new _LanguageModelDataPart(VSBuffer.fromString(value).buffer, mime);
  }
  toJSON() {
    return {
      $mid: 24,
      mimeType: this.mimeType,
      data: this.data,
      audience: this.audience
    };
  }
};
var ChatImageMimeType;
(function(ChatImageMimeType3) {
  ChatImageMimeType3["PNG"] = "image/png";
  ChatImageMimeType3["JPEG"] = "image/jpeg";
  ChatImageMimeType3["GIF"] = "image/gif";
  ChatImageMimeType3["WEBP"] = "image/webp";
  ChatImageMimeType3["BMP"] = "image/bmp";
})(ChatImageMimeType || (ChatImageMimeType = {}));
var LanguageModelThinkingPart = class {
  constructor(value, id2, metadata) {
    this.value = value;
    this.id = id2;
    this.metadata = metadata;
  }
  toJSON() {
    return {
      $mid: 22,
      value: this.value,
      id: this.id,
      metadata: this.metadata
    };
  }
};
var LanguageModelPromptTsxPart = class {
  constructor(value) {
    this.value = value;
  }
  toJSON() {
    return {
      $mid: 23,
      value: this.value
    };
  }
};
var LanguageModelError = class _LanguageModelError extends Error {
  static #name = "LanguageModelError";
  static NotFound(message) {
    return new _LanguageModelError(message, _LanguageModelError.NotFound.name);
  }
  static NoPermissions(message) {
    return new _LanguageModelError(message, _LanguageModelError.NoPermissions.name);
  }
  static Blocked(message) {
    return new _LanguageModelError(message, _LanguageModelError.Blocked.name);
  }
  static tryDeserialize(data2) {
    if (data2.name !== _LanguageModelError.#name) {
      return void 0;
    }
    return new _LanguageModelError(data2.message, data2.code, data2.cause);
  }
  constructor(message, code, cause) {
    super(message, { cause });
    this.name = _LanguageModelError.#name;
    this.code = code ?? "";
  }
};
var LanguageModelToolResult = class {
  constructor(content) {
    this.content = content;
  }
  toJSON() {
    return {
      $mid: 20,
      content: this.content
    };
  }
};
var LanguageModelToolResult2 = class {
  constructor(content) {
    this.content = content;
  }
  toJSON() {
    return {
      $mid: 20,
      content: this.content
    };
  }
};
var ExtendedLanguageModelToolResult = class extends LanguageModelToolResult {
};
var LanguageModelChatToolMode;
(function(LanguageModelChatToolMode2) {
  LanguageModelChatToolMode2[LanguageModelChatToolMode2["Auto"] = 1] = "Auto";
  LanguageModelChatToolMode2[LanguageModelChatToolMode2["Required"] = 2] = "Required";
})(LanguageModelChatToolMode || (LanguageModelChatToolMode = {}));
var LanguageModelToolExtensionSource = class {
  constructor(id2, label) {
    this.id = id2;
    this.label = label;
  }
};
var LanguageModelToolMCPSource = class {
  constructor(label, name2, instructions) {
    this.label = label;
    this.name = name2;
    this.instructions = instructions;
  }
};
var RelatedInformationType;
(function(RelatedInformationType2) {
  RelatedInformationType2[RelatedInformationType2["SymbolInformation"] = 1] = "SymbolInformation";
  RelatedInformationType2[RelatedInformationType2["CommandInformation"] = 2] = "CommandInformation";
  RelatedInformationType2[RelatedInformationType2["SearchInformation"] = 3] = "SearchInformation";
  RelatedInformationType2[RelatedInformationType2["SettingInformation"] = 4] = "SettingInformation";
})(RelatedInformationType || (RelatedInformationType = {}));
var SettingsSearchResultKind;
(function(SettingsSearchResultKind2) {
  SettingsSearchResultKind2[SettingsSearchResultKind2["EMBEDDED"] = 1] = "EMBEDDED";
  SettingsSearchResultKind2[SettingsSearchResultKind2["LLM_RANKED"] = 2] = "LLM_RANKED";
  SettingsSearchResultKind2[SettingsSearchResultKind2["CANCELED"] = 3] = "CANCELED";
})(SettingsSearchResultKind || (SettingsSearchResultKind = {}));
var SpeechToTextStatus;
(function(SpeechToTextStatus2) {
  SpeechToTextStatus2[SpeechToTextStatus2["Started"] = 1] = "Started";
  SpeechToTextStatus2[SpeechToTextStatus2["Recognizing"] = 2] = "Recognizing";
  SpeechToTextStatus2[SpeechToTextStatus2["Recognized"] = 3] = "Recognized";
  SpeechToTextStatus2[SpeechToTextStatus2["Stopped"] = 4] = "Stopped";
  SpeechToTextStatus2[SpeechToTextStatus2["Error"] = 5] = "Error";
})(SpeechToTextStatus || (SpeechToTextStatus = {}));
var TextToSpeechStatus;
(function(TextToSpeechStatus2) {
  TextToSpeechStatus2[TextToSpeechStatus2["Started"] = 1] = "Started";
  TextToSpeechStatus2[TextToSpeechStatus2["Stopped"] = 2] = "Stopped";
  TextToSpeechStatus2[TextToSpeechStatus2["Error"] = 3] = "Error";
})(TextToSpeechStatus || (TextToSpeechStatus = {}));
var KeywordRecognitionStatus;
(function(KeywordRecognitionStatus2) {
  KeywordRecognitionStatus2[KeywordRecognitionStatus2["Recognized"] = 1] = "Recognized";
  KeywordRecognitionStatus2[KeywordRecognitionStatus2["Stopped"] = 2] = "Stopped";
})(KeywordRecognitionStatus || (KeywordRecognitionStatus = {}));
var McpToolAvailability;
(function(McpToolAvailability2) {
  McpToolAvailability2[McpToolAvailability2["Initial"] = 0] = "Initial";
  McpToolAvailability2[McpToolAvailability2["Dynamic"] = 1] = "Dynamic";
})(McpToolAvailability || (McpToolAvailability = {}));
var McpStdioServerDefinition = class {
  constructor(label, command, args, env2 = {}, version, metadata) {
    this.label = label;
    this.command = command;
    this.args = args;
    this.env = env2;
    this.version = version;
    this.metadata = metadata;
  }
};
var McpHttpServerDefinition = class {
  constructor(label, uri, headers = {}, version, metadata, authentication) {
    this.label = label;
    this.uri = uri;
    this.headers = headers;
    this.version = version;
    this.metadata = metadata;
    this.authentication = authentication;
  }
};

// out-build/vs/workbench/api/common/extHostTypeConverters.js
var Selection3;
(function(Selection5) {
  function to(selection) {
    const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
    const start = new Position2(selectionStartLineNumber - 1, selectionStartColumn - 1);
    const end = new Position2(positionLineNumber - 1, positionColumn - 1);
    return new Selection(start, end);
  }
  Selection5.to = to;
  function from(selection) {
    const { anchor, active } = selection;
    return {
      selectionStartLineNumber: anchor.line + 1,
      selectionStartColumn: anchor.character + 1,
      positionLineNumber: active.line + 1,
      positionColumn: active.character + 1
    };
  }
  Selection5.from = from;
})(Selection3 || (Selection3 = {}));
var Range4;
(function(Range6) {
  function from(range) {
    if (!range) {
      return void 0;
    }
    const { start, end } = range;
    return {
      startLineNumber: start.line + 1,
      startColumn: start.character + 1,
      endLineNumber: end.line + 1,
      endColumn: end.character + 1
    };
  }
  Range6.from = from;
  function to(range) {
    if (!range) {
      return void 0;
    }
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    return new Range2(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
  }
  Range6.to = to;
})(Range4 || (Range4 = {}));
var Location3;
(function(Location4) {
  function from(location2) {
    return {
      uri: location2.uri,
      range: Range4.from(location2.range)
    };
  }
  Location4.from = from;
  function to(location2) {
    return new Location(URI.revive(location2.uri), Range4.to(location2.range));
  }
  Location4.to = to;
})(Location3 || (Location3 = {}));
var TokenType2;
(function(TokenType3) {
  function to(type) {
    switch (type) {
      case 1:
        return StandardTokenType.Comment;
      case 0:
        return StandardTokenType.Other;
      case 3:
        return StandardTokenType.RegEx;
      case 2:
        return StandardTokenType.String;
    }
  }
  TokenType3.to = to;
})(TokenType2 || (TokenType2 = {}));
var Position4;
(function(Position5) {
  function to(position) {
    return new Position2(position.lineNumber - 1, position.column - 1);
  }
  Position5.to = to;
  function from(position) {
    return { lineNumber: position.line + 1, column: position.character + 1 };
  }
  Position5.from = from;
})(Position4 || (Position4 = {}));
var DocumentSelector;
(function(DocumentSelector2) {
  function from(value, uriTransformer, extension) {
    return coalesce(asArray(value).map((sel) => _doTransformDocumentSelector(sel, uriTransformer, extension)));
  }
  DocumentSelector2.from = from;
  function _doTransformDocumentSelector(selector, uriTransformer, extension) {
    if (typeof selector === "string") {
      return {
        $serialized: true,
        language: selector,
        isBuiltin: extension?.isBuiltin
      };
    }
    if (selector) {
      return {
        $serialized: true,
        language: selector.language,
        scheme: _transformScheme(selector.scheme, uriTransformer),
        pattern: GlobPattern.from(selector.pattern) ?? void 0,
        exclusive: selector.exclusive,
        notebookType: selector.notebookType,
        isBuiltin: extension?.isBuiltin
      };
    }
    return void 0;
  }
  function _transformScheme(scheme, uriTransformer) {
    if (uriTransformer && typeof scheme === "string") {
      return uriTransformer.transformOutgoingScheme(scheme);
    }
    return scheme;
  }
})(DocumentSelector || (DocumentSelector = {}));
var DiagnosticTag2;
(function(DiagnosticTag3) {
  function from(value) {
    switch (value) {
      case DiagnosticTag.Unnecessary:
        return 1;
      case DiagnosticTag.Deprecated:
        return 2;
    }
    return void 0;
  }
  DiagnosticTag3.from = from;
  function to(value) {
    switch (value) {
      case 1:
        return DiagnosticTag.Unnecessary;
      case 2:
        return DiagnosticTag.Deprecated;
      default:
        return void 0;
    }
  }
  DiagnosticTag3.to = to;
})(DiagnosticTag2 || (DiagnosticTag2 = {}));
var Diagnostic3;
(function(Diagnostic4) {
  function from(value) {
    let code;
    if (value.code) {
      if (isString(value.code) || isNumber(value.code)) {
        code = String(value.code);
      } else {
        code = {
          value: String(value.code.value),
          target: value.code.target
        };
      }
    }
    return {
      ...Range4.from(value.range),
      message: value.message,
      source: value.source,
      code,
      severity: DiagnosticSeverity2.from(value.severity),
      relatedInformation: value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation3.from),
      tags: Array.isArray(value.tags) ? coalesce(value.tags.map(DiagnosticTag2.from)) : void 0
    };
  }
  Diagnostic4.from = from;
  function to(value) {
    const res = new Diagnostic(Range4.to(value), value.message, DiagnosticSeverity2.to(value.severity));
    res.source = value.source;
    res.code = isString(value.code) ? value.code : value.code?.value;
    res.relatedInformation = value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation3.to);
    res.tags = value.tags && coalesce(value.tags.map(DiagnosticTag2.to));
    return res;
  }
  Diagnostic4.to = to;
})(Diagnostic3 || (Diagnostic3 = {}));
var DiagnosticRelatedInformation3;
(function(DiagnosticRelatedInformation4) {
  function from(value) {
    return {
      ...Range4.from(value.location.range),
      message: value.message,
      resource: value.location.uri
    };
  }
  DiagnosticRelatedInformation4.from = from;
  function to(value) {
    return new DiagnosticRelatedInformation(new Location(value.resource, Range4.to(value)), value.message);
  }
  DiagnosticRelatedInformation4.to = to;
})(DiagnosticRelatedInformation3 || (DiagnosticRelatedInformation3 = {}));
var DiagnosticSeverity2;
(function(DiagnosticSeverity3) {
  function from(value) {
    switch (value) {
      case DiagnosticSeverity.Error:
        return MarkerSeverity.Error;
      case DiagnosticSeverity.Warning:
        return MarkerSeverity.Warning;
      case DiagnosticSeverity.Information:
        return MarkerSeverity.Info;
      case DiagnosticSeverity.Hint:
        return MarkerSeverity.Hint;
    }
    return MarkerSeverity.Error;
  }
  DiagnosticSeverity3.from = from;
  function to(value) {
    switch (value) {
      case MarkerSeverity.Info:
        return DiagnosticSeverity.Information;
      case MarkerSeverity.Warning:
        return DiagnosticSeverity.Warning;
      case MarkerSeverity.Error:
        return DiagnosticSeverity.Error;
      case MarkerSeverity.Hint:
        return DiagnosticSeverity.Hint;
      default:
        return DiagnosticSeverity.Error;
    }
  }
  DiagnosticSeverity3.to = to;
})(DiagnosticSeverity2 || (DiagnosticSeverity2 = {}));
var ViewColumn2;
(function(ViewColumn3) {
  function from(column) {
    if (typeof column === "number" && column >= ViewColumn.One) {
      return column - 1;
    }
    if (column === ViewColumn.Beside) {
      return SIDE_GROUP;
    }
    return ACTIVE_GROUP;
  }
  ViewColumn3.from = from;
  function to(position) {
    if (typeof position === "number" && position >= 0) {
      return position + 1;
    }
    throw new Error(`invalid 'EditorGroupColumn'`);
  }
  ViewColumn3.to = to;
})(ViewColumn2 || (ViewColumn2 = {}));
function isDecorationOptions(something) {
  return typeof something.range !== "undefined";
}
function isDecorationOptionsArr(something) {
  if (something.length === 0) {
    return true;
  }
  return isDecorationOptions(something[0]) ? true : false;
}
var MarkdownString4;
(function(MarkdownString5) {
  function fromMany(markup) {
    return markup.map(MarkdownString5.from);
  }
  MarkdownString5.fromMany = fromMany;
  function isCodeblock(thing) {
    return thing && typeof thing === "object" && typeof thing.language === "string" && typeof thing.value === "string";
  }
  function from(markup) {
    let res;
    if (isCodeblock(markup)) {
      const { language: language2, value } = markup;
      res = { value: "```" + language2 + "\n" + value + "\n```\n" };
    } else if (MarkdownString2.isMarkdownString(markup)) {
      res = { value: markup.value, isTrusted: markup.isTrusted, supportThemeIcons: markup.supportThemeIcons, supportHtml: markup.supportHtml, supportAlertSyntax: markup.supportAlertSyntax, baseUri: markup.baseUri };
    } else if (typeof markup === "string") {
      res = { value: markup };
    } else {
      res = { value: "" };
    }
    const resUris = /* @__PURE__ */ Object.create(null);
    res.uris = resUris;
    const collectUri = ({ href }) => {
      try {
        let uri = URI.parse(href, true);
        uri = uri.with({ query: _uriMassage(uri.query, resUris) });
        resUris[href] = uri;
      } catch (e) {
      }
      return "";
    };
    marked.walkTokens(marked.lexer(res.value), (token) => {
      if (token.type === "link") {
        collectUri({ href: token.href });
      } else if (token.type === "image") {
        if (typeof token.href === "string") {
          collectUri(parseHrefAndDimensions(token.href));
        }
      }
    });
    return res;
  }
  MarkdownString5.from = from;
  function _uriMassage(part, bucket) {
    if (!part) {
      return part;
    }
    let data2;
    try {
      data2 = parse2(part);
    } catch (e) {
    }
    if (!data2) {
      return part;
    }
    let changed = false;
    data2 = cloneAndChange(data2, (value) => {
      if (URI.isUri(value)) {
        const key = `__uri_${Math.random().toString(16).slice(2, 8)}`;
        bucket[key] = value;
        changed = true;
        return key;
      } else {
        return void 0;
      }
    });
    if (!changed) {
      return part;
    }
    return JSON.stringify(data2);
  }
  function to(value) {
    const result = new MarkdownString2(value.value, value.supportThemeIcons);
    result.isTrusted = value.isTrusted;
    result.supportHtml = value.supportHtml;
    result.supportAlertSyntax = value.supportAlertSyntax;
    result.baseUri = value.baseUri ? URI.from(value.baseUri) : void 0;
    return result;
  }
  MarkdownString5.to = to;
  function fromStrict(value) {
    if (!value) {
      return void 0;
    }
    return typeof value === "string" ? value : MarkdownString5.from(value);
  }
  MarkdownString5.fromStrict = fromStrict;
})(MarkdownString4 || (MarkdownString4 = {}));
function fromRangeOrRangeWithMessage(ranges) {
  if (isDecorationOptionsArr(ranges)) {
    return ranges.map((r) => {
      return {
        range: Range4.from(r.range),
        hoverMessage: Array.isArray(r.hoverMessage) ? MarkdownString4.fromMany(r.hoverMessage) : r.hoverMessage ? MarkdownString4.from(r.hoverMessage) : void 0,
        // eslint-disable-next-line local/code-no-any-casts
        renderOptions: (
          /* URI vs Uri */
          r.renderOptions
        )
      };
    });
  } else {
    return ranges.map((r) => {
      return {
        range: Range4.from(r)
      };
    });
  }
}
function pathOrURIToURI(value) {
  if (typeof value === "undefined") {
    return value;
  }
  if (typeof value === "string") {
    return URI.file(value);
  } else {
    return value;
  }
}
var ThemableDecorationAttachmentRenderOptions;
(function(ThemableDecorationAttachmentRenderOptions2) {
  function from(options2) {
    if (typeof options2 === "undefined") {
      return options2;
    }
    return {
      contentText: options2.contentText,
      contentIconPath: options2.contentIconPath ? pathOrURIToURI(options2.contentIconPath) : void 0,
      border: options2.border,
      borderColor: options2.borderColor,
      fontStyle: options2.fontStyle,
      fontWeight: options2.fontWeight,
      textDecoration: options2.textDecoration,
      color: options2.color,
      backgroundColor: options2.backgroundColor,
      margin: options2.margin,
      width: options2.width,
      height: options2.height
    };
  }
  ThemableDecorationAttachmentRenderOptions2.from = from;
})(ThemableDecorationAttachmentRenderOptions || (ThemableDecorationAttachmentRenderOptions = {}));
var ThemableDecorationRenderOptions;
(function(ThemableDecorationRenderOptions2) {
  function from(options2) {
    if (typeof options2 === "undefined") {
      return options2;
    }
    return {
      backgroundColor: options2.backgroundColor,
      outline: options2.outline,
      outlineColor: options2.outlineColor,
      outlineStyle: options2.outlineStyle,
      outlineWidth: options2.outlineWidth,
      border: options2.border,
      borderColor: options2.borderColor,
      borderRadius: options2.borderRadius,
      borderSpacing: options2.borderSpacing,
      borderStyle: options2.borderStyle,
      borderWidth: options2.borderWidth,
      fontStyle: options2.fontStyle,
      fontWeight: options2.fontWeight,
      textDecoration: options2.textDecoration,
      cursor: options2.cursor,
      color: options2.color,
      opacity: options2.opacity,
      letterSpacing: options2.letterSpacing,
      gutterIconPath: options2.gutterIconPath ? pathOrURIToURI(options2.gutterIconPath) : void 0,
      gutterIconSize: options2.gutterIconSize,
      overviewRulerColor: options2.overviewRulerColor,
      before: options2.before ? ThemableDecorationAttachmentRenderOptions.from(options2.before) : void 0,
      after: options2.after ? ThemableDecorationAttachmentRenderOptions.from(options2.after) : void 0
    };
  }
  ThemableDecorationRenderOptions2.from = from;
})(ThemableDecorationRenderOptions || (ThemableDecorationRenderOptions = {}));
var DecorationRangeBehavior2;
(function(DecorationRangeBehavior3) {
  function from(value) {
    if (typeof value === "undefined") {
      return value;
    }
    switch (value) {
      case DecorationRangeBehavior.OpenOpen:
        return 0;
      case DecorationRangeBehavior.ClosedClosed:
        return 1;
      case DecorationRangeBehavior.OpenClosed:
        return 2;
      case DecorationRangeBehavior.ClosedOpen:
        return 3;
    }
  }
  DecorationRangeBehavior3.from = from;
})(DecorationRangeBehavior2 || (DecorationRangeBehavior2 = {}));
var DecorationRenderOptions;
(function(DecorationRenderOptions2) {
  function from(options2) {
    return {
      isWholeLine: options2.isWholeLine,
      rangeBehavior: options2.rangeBehavior ? DecorationRangeBehavior2.from(options2.rangeBehavior) : void 0,
      overviewRulerLane: options2.overviewRulerLane,
      light: options2.light ? ThemableDecorationRenderOptions.from(options2.light) : void 0,
      dark: options2.dark ? ThemableDecorationRenderOptions.from(options2.dark) : void 0,
      backgroundColor: options2.backgroundColor,
      outline: options2.outline,
      outlineColor: options2.outlineColor,
      outlineStyle: options2.outlineStyle,
      outlineWidth: options2.outlineWidth,
      border: options2.border,
      borderColor: options2.borderColor,
      borderRadius: options2.borderRadius,
      borderSpacing: options2.borderSpacing,
      borderStyle: options2.borderStyle,
      borderWidth: options2.borderWidth,
      fontStyle: options2.fontStyle,
      fontWeight: options2.fontWeight,
      textDecoration: options2.textDecoration,
      cursor: options2.cursor,
      color: options2.color,
      opacity: options2.opacity,
      letterSpacing: options2.letterSpacing,
      gutterIconPath: options2.gutterIconPath ? pathOrURIToURI(options2.gutterIconPath) : void 0,
      gutterIconSize: options2.gutterIconSize,
      overviewRulerColor: options2.overviewRulerColor,
      before: options2.before ? ThemableDecorationAttachmentRenderOptions.from(options2.before) : void 0,
      after: options2.after ? ThemableDecorationAttachmentRenderOptions.from(options2.after) : void 0
    };
  }
  DecorationRenderOptions2.from = from;
})(DecorationRenderOptions || (DecorationRenderOptions = {}));
var TextEdit3;
(function(TextEdit4) {
  function from(edit2) {
    return {
      text: edit2.newText,
      eol: edit2.newEol && EndOfLine2.from(edit2.newEol),
      range: Range4.from(edit2.range)
    };
  }
  TextEdit4.from = from;
  function to(edit2) {
    const result = new TextEdit(Range4.to(edit2.range), edit2.text);
    result.newEol = typeof edit2.eol === "undefined" ? void 0 : EndOfLine2.to(edit2.eol);
    return result;
  }
  TextEdit4.to = to;
})(TextEdit3 || (TextEdit3 = {}));
var WorkspaceEdit3;
(function(WorkspaceEdit4) {
  function from(value, versionInfo) {
    const result = {
      edits: []
    };
    if (value instanceof WorkspaceEdit) {
      const toCreate = new ResourceSet();
      for (const entry of value._allEntries()) {
        if (entry._type === 1 && URI.isUri(entry.to) && entry.from === void 0) {
          toCreate.add(entry.to);
        }
      }
      for (const entry of value._allEntries()) {
        if (entry._type === 1) {
          let contents;
          if (entry.options?.contents) {
            if (ArrayBuffer.isView(entry.options.contents)) {
              contents = { type: "base64", value: encodeBase64(VSBuffer.wrap(entry.options.contents)) };
            } else {
              contents = { type: "dataTransferItem", id: entry.options.contents._itemId };
            }
          }
          result.edits.push({
            oldResource: entry.from,
            newResource: entry.to,
            options: { ...entry.options, contents },
            metadata: entry.metadata
          });
        } else if (entry._type === 2) {
          result.edits.push({
            resource: entry.uri,
            textEdit: TextEdit3.from(entry.edit),
            versionId: !toCreate.has(entry.uri) ? versionInfo?.getTextDocumentVersion(entry.uri) : void 0,
            metadata: entry.metadata
          });
        } else if (entry._type === 6) {
          result.edits.push({
            resource: entry.uri,
            textEdit: {
              range: Range4.from(entry.range),
              text: entry.edit.value,
              insertAsSnippet: true,
              keepWhitespace: entry.keepWhitespace
            },
            versionId: !toCreate.has(entry.uri) ? versionInfo?.getTextDocumentVersion(entry.uri) : void 0,
            metadata: entry.metadata
          });
        } else if (entry._type === 3) {
          result.edits.push({
            metadata: entry.metadata,
            resource: entry.uri,
            cellEdit: entry.edit,
            notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri)
          });
        } else if (entry._type === 5) {
          result.edits.push({
            metadata: entry.metadata,
            resource: entry.uri,
            notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri),
            cellEdit: {
              editType: 1,
              index: entry.index,
              count: entry.count,
              cells: entry.cells.map(NotebookCellData2.from)
            }
          });
        }
      }
    }
    return result;
  }
  WorkspaceEdit4.from = from;
  function to(value) {
    const result = new WorkspaceEdit();
    const edits = new ResourceMap();
    for (const edit2 of value.edits) {
      if (edit2.textEdit) {
        const item = edit2;
        const uri = URI.revive(item.resource);
        const range = Range4.to(item.textEdit.range);
        const text = item.textEdit.text;
        const isSnippet = item.textEdit.insertAsSnippet;
        let editOrSnippetTest;
        if (isSnippet) {
          editOrSnippetTest = SnippetTextEdit.replace(range, new SnippetString(text));
        } else {
          editOrSnippetTest = TextEdit.replace(range, text);
        }
        const array = edits.get(uri);
        if (!array) {
          edits.set(uri, [editOrSnippetTest]);
        } else {
          array.push(editOrSnippetTest);
        }
      } else {
        result.renameFile(URI.revive(edit2.oldResource), URI.revive(edit2.newResource), edit2.options);
      }
    }
    for (const [uri, array] of edits) {
      result.set(uri, array);
    }
    return result;
  }
  WorkspaceEdit4.to = to;
})(WorkspaceEdit3 || (WorkspaceEdit3 = {}));
var SymbolKind3;
(function(SymbolKind4) {
  const _fromMapping = /* @__PURE__ */ Object.create(null);
  _fromMapping[SymbolKind2.File] = 0;
  _fromMapping[SymbolKind2.Module] = 1;
  _fromMapping[SymbolKind2.Namespace] = 2;
  _fromMapping[SymbolKind2.Package] = 3;
  _fromMapping[SymbolKind2.Class] = 4;
  _fromMapping[SymbolKind2.Method] = 5;
  _fromMapping[SymbolKind2.Property] = 6;
  _fromMapping[SymbolKind2.Field] = 7;
  _fromMapping[SymbolKind2.Constructor] = 8;
  _fromMapping[SymbolKind2.Enum] = 9;
  _fromMapping[SymbolKind2.Interface] = 10;
  _fromMapping[SymbolKind2.Function] = 11;
  _fromMapping[SymbolKind2.Variable] = 12;
  _fromMapping[SymbolKind2.Constant] = 13;
  _fromMapping[SymbolKind2.String] = 14;
  _fromMapping[SymbolKind2.Number] = 15;
  _fromMapping[SymbolKind2.Boolean] = 16;
  _fromMapping[SymbolKind2.Array] = 17;
  _fromMapping[SymbolKind2.Object] = 18;
  _fromMapping[SymbolKind2.Key] = 19;
  _fromMapping[SymbolKind2.Null] = 20;
  _fromMapping[SymbolKind2.EnumMember] = 21;
  _fromMapping[SymbolKind2.Struct] = 22;
  _fromMapping[SymbolKind2.Event] = 23;
  _fromMapping[SymbolKind2.Operator] = 24;
  _fromMapping[SymbolKind2.TypeParameter] = 25;
  function from(kind) {
    return typeof _fromMapping[kind] === "number" ? _fromMapping[kind] : 6;
  }
  SymbolKind4.from = from;
  function to(kind) {
    for (const k in _fromMapping) {
      if (_fromMapping[k] === kind) {
        return Number(k);
      }
    }
    return SymbolKind2.Property;
  }
  SymbolKind4.to = to;
})(SymbolKind3 || (SymbolKind3 = {}));
var SymbolTag3;
(function(SymbolTag4) {
  function from(kind) {
    switch (kind) {
      case SymbolTag2.Deprecated:
        return 1;
    }
  }
  SymbolTag4.from = from;
  function to(kind) {
    switch (kind) {
      case 1:
        return SymbolTag2.Deprecated;
    }
  }
  SymbolTag4.to = to;
})(SymbolTag3 || (SymbolTag3 = {}));
var WorkspaceSymbol;
(function(WorkspaceSymbol2) {
  function from(info) {
    return {
      name: info.name,
      kind: SymbolKind3.from(info.kind),
      tags: info.tags && info.tags.map(SymbolTag3.from),
      containerName: info.containerName,
      location: location.from(info.location)
    };
  }
  WorkspaceSymbol2.from = from;
  function to(info) {
    const result = new SymbolInformation(info.name, SymbolKind3.to(info.kind), info.containerName, location.to(info.location));
    result.tags = info.tags && info.tags.map(SymbolTag3.to);
    return result;
  }
  WorkspaceSymbol2.to = to;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol3;
(function(DocumentSymbol4) {
  function from(info) {
    const result = {
      name: info.name || "!!MISSING: name!!",
      detail: info.detail,
      range: Range4.from(info.range),
      selectionRange: Range4.from(info.selectionRange),
      kind: SymbolKind3.from(info.kind),
      tags: info.tags?.map(SymbolTag3.from) ?? []
    };
    if (info.children) {
      result.children = info.children.map(from);
    }
    return result;
  }
  DocumentSymbol4.from = from;
  function to(info) {
    const result = new DocumentSymbol(info.name, info.detail, SymbolKind3.to(info.kind), Range4.to(info.range), Range4.to(info.selectionRange));
    if (isNonEmptyArray(info.tags)) {
      result.tags = info.tags.map(SymbolTag3.to);
    }
    if (info.children) {
      result.children = info.children.map(to);
    }
    return result;
  }
  DocumentSymbol4.to = to;
})(DocumentSymbol3 || (DocumentSymbol3 = {}));
var CallHierarchyItem2;
(function(CallHierarchyItem3) {
  function to(item) {
    const result = new CallHierarchyItem(SymbolKind3.to(item.kind), item.name, item.detail || "", URI.revive(item.uri), Range4.to(item.range), Range4.to(item.selectionRange));
    result._sessionId = item._sessionId;
    result._itemId = item._itemId;
    return result;
  }
  CallHierarchyItem3.to = to;
  function from(item, sessionId, itemId) {
    sessionId = sessionId ?? item._sessionId;
    itemId = itemId ?? item._itemId;
    if (sessionId === void 0 || itemId === void 0) {
      throw new Error("invalid item");
    }
    return {
      _sessionId: sessionId,
      _itemId: itemId,
      name: item.name,
      detail: item.detail,
      kind: SymbolKind3.from(item.kind),
      uri: item.uri,
      range: Range4.from(item.range),
      selectionRange: Range4.from(item.selectionRange),
      tags: item.tags?.map(SymbolTag3.from)
    };
  }
  CallHierarchyItem3.from = from;
})(CallHierarchyItem2 || (CallHierarchyItem2 = {}));
var CallHierarchyIncomingCall2;
(function(CallHierarchyIncomingCall3) {
  function to(item) {
    return new CallHierarchyIncomingCall(CallHierarchyItem2.to(item.from), item.fromRanges.map((r) => Range4.to(r)));
  }
  CallHierarchyIncomingCall3.to = to;
})(CallHierarchyIncomingCall2 || (CallHierarchyIncomingCall2 = {}));
var CallHierarchyOutgoingCall2;
(function(CallHierarchyOutgoingCall3) {
  function to(item) {
    return new CallHierarchyOutgoingCall(CallHierarchyItem2.to(item.to), item.fromRanges.map((r) => Range4.to(r)));
  }
  CallHierarchyOutgoingCall3.to = to;
})(CallHierarchyOutgoingCall2 || (CallHierarchyOutgoingCall2 = {}));
var location;
(function(location2) {
  function from(value) {
    return {
      range: value.range && Range4.from(value.range),
      uri: value.uri
    };
  }
  location2.from = from;
  function to(value) {
    return new Location(URI.revive(value.uri), Range4.to(value.range));
  }
  location2.to = to;
})(location || (location = {}));
var DefinitionLink;
(function(DefinitionLink2) {
  function from(value) {
    const definitionLink = value;
    const location2 = value;
    return {
      originSelectionRange: definitionLink.originSelectionRange ? Range4.from(definitionLink.originSelectionRange) : void 0,
      uri: definitionLink.targetUri ? definitionLink.targetUri : location2.uri,
      range: Range4.from(definitionLink.targetRange ? definitionLink.targetRange : location2.range),
      targetSelectionRange: definitionLink.targetSelectionRange ? Range4.from(definitionLink.targetSelectionRange) : void 0
    };
  }
  DefinitionLink2.from = from;
  function to(value) {
    return {
      targetUri: URI.revive(value.uri),
      targetRange: Range4.to(value.range),
      targetSelectionRange: value.targetSelectionRange ? Range4.to(value.targetSelectionRange) : void 0,
      originSelectionRange: value.originSelectionRange ? Range4.to(value.originSelectionRange) : void 0
    };
  }
  DefinitionLink2.to = to;
})(DefinitionLink || (DefinitionLink = {}));
var Hover3;
(function(Hover4) {
  function from(hover) {
    const convertedHover = {
      range: Range4.from(hover.range),
      contents: MarkdownString4.fromMany(hover.contents),
      canIncreaseVerbosity: hover.canIncreaseVerbosity,
      canDecreaseVerbosity: hover.canDecreaseVerbosity
    };
    return convertedHover;
  }
  Hover4.from = from;
  function to(info) {
    const contents = info.contents.map(MarkdownString4.to);
    const range = Range4.to(info.range);
    const canIncreaseVerbosity = info.canIncreaseVerbosity;
    const canDecreaseVerbosity = info.canDecreaseVerbosity;
    return new VerboseHover(contents, range, canIncreaseVerbosity, canDecreaseVerbosity);
  }
  Hover4.to = to;
})(Hover3 || (Hover3 = {}));
var EvaluatableExpression3;
(function(EvaluatableExpression4) {
  function from(expression) {
    return {
      range: Range4.from(expression.range),
      expression: expression.expression
    };
  }
  EvaluatableExpression4.from = from;
  function to(info) {
    return new EvaluatableExpression(Range4.to(info.range), info.expression);
  }
  EvaluatableExpression4.to = to;
})(EvaluatableExpression3 || (EvaluatableExpression3 = {}));
var InlineValue;
(function(InlineValue2) {
  function from(inlineValue) {
    if (inlineValue instanceof InlineValueText) {
      return {
        type: "text",
        range: Range4.from(inlineValue.range),
        text: inlineValue.text
      };
    } else if (inlineValue instanceof InlineValueVariableLookup) {
      return {
        type: "variable",
        range: Range4.from(inlineValue.range),
        variableName: inlineValue.variableName,
        caseSensitiveLookup: inlineValue.caseSensitiveLookup
      };
    } else if (inlineValue instanceof InlineValueEvaluatableExpression) {
      return {
        type: "expression",
        range: Range4.from(inlineValue.range),
        expression: inlineValue.expression
      };
    } else {
      throw new Error(`Unknown 'InlineValue' type`);
    }
  }
  InlineValue2.from = from;
  function to(inlineValue) {
    switch (inlineValue.type) {
      case "text":
        return {
          range: Range4.to(inlineValue.range),
          text: inlineValue.text
        };
      case "variable":
        return {
          range: Range4.to(inlineValue.range),
          variableName: inlineValue.variableName,
          caseSensitiveLookup: inlineValue.caseSensitiveLookup
        };
      case "expression":
        return {
          range: Range4.to(inlineValue.range),
          expression: inlineValue.expression
        };
    }
  }
  InlineValue2.to = to;
})(InlineValue || (InlineValue = {}));
var InlineValueContext3;
(function(InlineValueContext4) {
  function from(inlineValueContext) {
    return {
      frameId: inlineValueContext.frameId,
      stoppedLocation: Range4.from(inlineValueContext.stoppedLocation)
    };
  }
  InlineValueContext4.from = from;
  function to(inlineValueContext) {
    return new InlineValueContext(inlineValueContext.frameId, Range4.to(inlineValueContext.stoppedLocation));
  }
  InlineValueContext4.to = to;
})(InlineValueContext3 || (InlineValueContext3 = {}));
var DocumentHighlight3;
(function(DocumentHighlight4) {
  function from(documentHighlight) {
    return {
      range: Range4.from(documentHighlight.range),
      kind: documentHighlight.kind
    };
  }
  DocumentHighlight4.from = from;
  function to(occurrence) {
    return new DocumentHighlight(Range4.to(occurrence.range), occurrence.kind);
  }
  DocumentHighlight4.to = to;
})(DocumentHighlight3 || (DocumentHighlight3 = {}));
var MultiDocumentHighlight3;
(function(MultiDocumentHighlight4) {
  function from(multiDocumentHighlight) {
    return {
      uri: multiDocumentHighlight.uri,
      highlights: multiDocumentHighlight.highlights.map(DocumentHighlight3.from)
    };
  }
  MultiDocumentHighlight4.from = from;
  function to(multiDocumentHighlight) {
    return new MultiDocumentHighlight(URI.revive(multiDocumentHighlight.uri), multiDocumentHighlight.highlights.map(DocumentHighlight3.to));
  }
  MultiDocumentHighlight4.to = to;
})(MultiDocumentHighlight3 || (MultiDocumentHighlight3 = {}));
var CompletionTriggerKind3;
(function(CompletionTriggerKind4) {
  function to(kind) {
    switch (kind) {
      case 1:
        return CompletionTriggerKind2.TriggerCharacter;
      case 2:
        return CompletionTriggerKind2.TriggerForIncompleteCompletions;
      case 0:
      default:
        return CompletionTriggerKind2.Invoke;
    }
  }
  CompletionTriggerKind4.to = to;
})(CompletionTriggerKind3 || (CompletionTriggerKind3 = {}));
var CompletionContext;
(function(CompletionContext2) {
  function to(context) {
    return {
      triggerKind: CompletionTriggerKind3.to(context.triggerKind),
      triggerCharacter: context.triggerCharacter
    };
  }
  CompletionContext2.to = to;
})(CompletionContext || (CompletionContext = {}));
var CompletionItemTag3;
(function(CompletionItemTag4) {
  function from(kind) {
    switch (kind) {
      case CompletionItemTag2.Deprecated:
        return 1;
    }
  }
  CompletionItemTag4.from = from;
  function to(kind) {
    switch (kind) {
      case 1:
        return CompletionItemTag2.Deprecated;
    }
  }
  CompletionItemTag4.to = to;
})(CompletionItemTag3 || (CompletionItemTag3 = {}));
var CompletionCommand;
(function(CompletionCommand2) {
  function from(c, converter, disposables) {
    if ("icon" in c && "command" in c) {
      return {
        command: converter.toInternal(c.command, disposables),
        icon: IconPath.fromThemeIcon(c.icon)
      };
    }
    return { command: converter.toInternal(c, disposables) };
  }
  CompletionCommand2.from = from;
})(CompletionCommand || (CompletionCommand = {}));
var CompletionItemKind3;
(function(CompletionItemKind4) {
  const _from = /* @__PURE__ */ new Map([
    [
      CompletionItemKind2.Method,
      0
      /* languages.CompletionItemKind.Method */
    ],
    [
      CompletionItemKind2.Function,
      1
      /* languages.CompletionItemKind.Function */
    ],
    [
      CompletionItemKind2.Constructor,
      2
      /* languages.CompletionItemKind.Constructor */
    ],
    [
      CompletionItemKind2.Field,
      3
      /* languages.CompletionItemKind.Field */
    ],
    [
      CompletionItemKind2.Variable,
      4
      /* languages.CompletionItemKind.Variable */
    ],
    [
      CompletionItemKind2.Class,
      5
      /* languages.CompletionItemKind.Class */
    ],
    [
      CompletionItemKind2.Interface,
      7
      /* languages.CompletionItemKind.Interface */
    ],
    [
      CompletionItemKind2.Struct,
      6
      /* languages.CompletionItemKind.Struct */
    ],
    [
      CompletionItemKind2.Module,
      8
      /* languages.CompletionItemKind.Module */
    ],
    [
      CompletionItemKind2.Property,
      9
      /* languages.CompletionItemKind.Property */
    ],
    [
      CompletionItemKind2.Unit,
      12
      /* languages.CompletionItemKind.Unit */
    ],
    [
      CompletionItemKind2.Value,
      13
      /* languages.CompletionItemKind.Value */
    ],
    [
      CompletionItemKind2.Constant,
      14
      /* languages.CompletionItemKind.Constant */
    ],
    [
      CompletionItemKind2.Enum,
      15
      /* languages.CompletionItemKind.Enum */
    ],
    [
      CompletionItemKind2.EnumMember,
      16
      /* languages.CompletionItemKind.EnumMember */
    ],
    [
      CompletionItemKind2.Keyword,
      17
      /* languages.CompletionItemKind.Keyword */
    ],
    [
      CompletionItemKind2.Snippet,
      28
      /* languages.CompletionItemKind.Snippet */
    ],
    [
      CompletionItemKind2.Text,
      18
      /* languages.CompletionItemKind.Text */
    ],
    [
      CompletionItemKind2.Color,
      19
      /* languages.CompletionItemKind.Color */
    ],
    [
      CompletionItemKind2.File,
      20
      /* languages.CompletionItemKind.File */
    ],
    [
      CompletionItemKind2.Reference,
      21
      /* languages.CompletionItemKind.Reference */
    ],
    [
      CompletionItemKind2.Folder,
      23
      /* languages.CompletionItemKind.Folder */
    ],
    [
      CompletionItemKind2.Event,
      10
      /* languages.CompletionItemKind.Event */
    ],
    [
      CompletionItemKind2.Operator,
      11
      /* languages.CompletionItemKind.Operator */
    ],
    [
      CompletionItemKind2.TypeParameter,
      24
      /* languages.CompletionItemKind.TypeParameter */
    ],
    [
      CompletionItemKind2.Issue,
      26
      /* languages.CompletionItemKind.Issue */
    ],
    [
      CompletionItemKind2.User,
      25
      /* languages.CompletionItemKind.User */
    ]
  ]);
  function from(kind) {
    return _from.get(kind) ?? 9;
  }
  CompletionItemKind4.from = from;
  const _to = /* @__PURE__ */ new Map([
    [0, CompletionItemKind2.Method],
    [1, CompletionItemKind2.Function],
    [2, CompletionItemKind2.Constructor],
    [3, CompletionItemKind2.Field],
    [4, CompletionItemKind2.Variable],
    [5, CompletionItemKind2.Class],
    [7, CompletionItemKind2.Interface],
    [6, CompletionItemKind2.Struct],
    [8, CompletionItemKind2.Module],
    [9, CompletionItemKind2.Property],
    [12, CompletionItemKind2.Unit],
    [13, CompletionItemKind2.Value],
    [14, CompletionItemKind2.Constant],
    [15, CompletionItemKind2.Enum],
    [16, CompletionItemKind2.EnumMember],
    [17, CompletionItemKind2.Keyword],
    [28, CompletionItemKind2.Snippet],
    [18, CompletionItemKind2.Text],
    [19, CompletionItemKind2.Color],
    [20, CompletionItemKind2.File],
    [21, CompletionItemKind2.Reference],
    [23, CompletionItemKind2.Folder],
    [10, CompletionItemKind2.Event],
    [11, CompletionItemKind2.Operator],
    [24, CompletionItemKind2.TypeParameter],
    [25, CompletionItemKind2.User],
    [26, CompletionItemKind2.Issue]
  ]);
  function to(kind) {
    return _to.get(kind) ?? CompletionItemKind2.Property;
  }
  CompletionItemKind4.to = to;
})(CompletionItemKind3 || (CompletionItemKind3 = {}));
var CompletionItem3;
(function(CompletionItem4) {
  function to(suggestion, converter) {
    const result = new CompletionItem(suggestion.label);
    result.insertText = suggestion.insertText;
    result.kind = CompletionItemKind3.to(suggestion.kind);
    result.tags = suggestion.tags?.map(CompletionItemTag3.to);
    result.detail = suggestion.detail;
    result.documentation = isMarkdownString(suggestion.documentation) ? MarkdownString4.to(suggestion.documentation) : suggestion.documentation;
    result.sortText = suggestion.sortText;
    result.filterText = suggestion.filterText;
    result.preselect = suggestion.preselect;
    result.commitCharacters = suggestion.commitCharacters;
    if (Range.isIRange(suggestion.range)) {
      result.range = Range4.to(suggestion.range);
    } else if (typeof suggestion.range === "object") {
      result.range = { inserting: Range4.to(suggestion.range.insert), replacing: Range4.to(suggestion.range.replace) };
    }
    result.keepWhitespace = typeof suggestion.insertTextRules === "undefined" ? false : Boolean(
      suggestion.insertTextRules & 1
      /* languages.CompletionItemInsertTextRule.KeepWhitespace */
    );
    if (typeof suggestion.insertTextRules !== "undefined" && suggestion.insertTextRules & 4) {
      result.insertText = new SnippetString(suggestion.insertText);
    } else {
      result.insertText = suggestion.insertText;
      result.textEdit = result.range instanceof Range2 ? new TextEdit(result.range, result.insertText) : void 0;
    }
    if (suggestion.additionalTextEdits && suggestion.additionalTextEdits.length > 0) {
      result.additionalTextEdits = suggestion.additionalTextEdits.map((e) => TextEdit3.to(e));
    }
    result.command = converter && suggestion.command ? converter.fromInternal(suggestion.command) : void 0;
    return result;
  }
  CompletionItem4.to = to;
})(CompletionItem3 || (CompletionItem3 = {}));
var ParameterInformation3;
(function(ParameterInformation4) {
  function from(info) {
    if (typeof info.label !== "string" && !Array.isArray(info.label)) {
      throw new TypeError("Invalid label");
    }
    return {
      label: info.label,
      documentation: MarkdownString4.fromStrict(info.documentation)
    };
  }
  ParameterInformation4.from = from;
  function to(info) {
    return {
      label: info.label,
      documentation: isMarkdownString(info.documentation) ? MarkdownString4.to(info.documentation) : info.documentation
    };
  }
  ParameterInformation4.to = to;
})(ParameterInformation3 || (ParameterInformation3 = {}));
var SignatureInformation3;
(function(SignatureInformation4) {
  function from(info) {
    return {
      label: info.label,
      documentation: MarkdownString4.fromStrict(info.documentation),
      parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation3.from) : [],
      activeParameter: info.activeParameter
    };
  }
  SignatureInformation4.from = from;
  function to(info) {
    return {
      label: info.label,
      documentation: isMarkdownString(info.documentation) ? MarkdownString4.to(info.documentation) : info.documentation,
      parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation3.to) : [],
      activeParameter: info.activeParameter
    };
  }
  SignatureInformation4.to = to;
})(SignatureInformation3 || (SignatureInformation3 = {}));
var SignatureHelp3;
(function(SignatureHelp4) {
  function from(help) {
    return {
      activeSignature: help.activeSignature,
      activeParameter: help.activeParameter,
      signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation3.from) : []
    };
  }
  SignatureHelp4.from = from;
  function to(help) {
    return {
      activeSignature: help.activeSignature,
      activeParameter: help.activeParameter,
      signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation3.to) : []
    };
  }
  SignatureHelp4.to = to;
})(SignatureHelp3 || (SignatureHelp3 = {}));
var InlayHint3;
(function(InlayHint4) {
  function to(converter, hint) {
    const res = new InlayHint(Position4.to(hint.position), typeof hint.label === "string" ? hint.label : hint.label.map(InlayHintLabelPart3.to.bind(void 0, converter)), hint.kind && InlayHintKind3.to(hint.kind));
    res.textEdits = hint.textEdits && hint.textEdits.map(TextEdit3.to);
    res.tooltip = isMarkdownString(hint.tooltip) ? MarkdownString4.to(hint.tooltip) : hint.tooltip;
    res.paddingLeft = hint.paddingLeft;
    res.paddingRight = hint.paddingRight;
    return res;
  }
  InlayHint4.to = to;
})(InlayHint3 || (InlayHint3 = {}));
var InlayHintLabelPart3;
(function(InlayHintLabelPart4) {
  function to(converter, part) {
    const result = new InlayHintLabelPart(part.label);
    result.tooltip = isMarkdownString(part.tooltip) ? MarkdownString4.to(part.tooltip) : part.tooltip;
    if (Command.is(part.command)) {
      result.command = converter.fromInternal(part.command);
    }
    if (part.location) {
      result.location = location.to(part.location);
    }
    return result;
  }
  InlayHintLabelPart4.to = to;
})(InlayHintLabelPart3 || (InlayHintLabelPart3 = {}));
var InlayHintKind3;
(function(InlayHintKind4) {
  function from(kind) {
    return kind;
  }
  InlayHintKind4.from = from;
  function to(kind) {
    return kind;
  }
  InlayHintKind4.to = to;
})(InlayHintKind3 || (InlayHintKind3 = {}));
var DocumentLink3;
(function(DocumentLink4) {
  function from(link2) {
    return {
      range: Range4.from(link2.range),
      url: link2.target,
      tooltip: link2.tooltip
    };
  }
  DocumentLink4.from = from;
  function to(link2) {
    let target = void 0;
    if (link2.url) {
      try {
        target = typeof link2.url === "string" ? URI.parse(link2.url, true) : URI.revive(link2.url);
      } catch (err) {
      }
    }
    const result = new DocumentLink(Range4.to(link2.range), target);
    result.tooltip = link2.tooltip;
    return result;
  }
  DocumentLink4.to = to;
})(DocumentLink3 || (DocumentLink3 = {}));
var ColorPresentation3;
(function(ColorPresentation4) {
  function to(colorPresentation) {
    const cp = new ColorPresentation(colorPresentation.label);
    if (colorPresentation.textEdit) {
      cp.textEdit = TextEdit3.to(colorPresentation.textEdit);
    }
    if (colorPresentation.additionalTextEdits) {
      cp.additionalTextEdits = colorPresentation.additionalTextEdits.map((value) => TextEdit3.to(value));
    }
    return cp;
  }
  ColorPresentation4.to = to;
  function from(colorPresentation) {
    return {
      label: colorPresentation.label,
      textEdit: colorPresentation.textEdit ? TextEdit3.from(colorPresentation.textEdit) : void 0,
      additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map((value) => TextEdit3.from(value)) : void 0
    };
  }
  ColorPresentation4.from = from;
})(ColorPresentation3 || (ColorPresentation3 = {}));
var Color3;
(function(Color4) {
  function to(c) {
    return new Color(c[0], c[1], c[2], c[3]);
  }
  Color4.to = to;
  function from(color) {
    return [color.red, color.green, color.blue, color.alpha];
  }
  Color4.from = from;
})(Color3 || (Color3 = {}));
var SelectionRange3;
(function(SelectionRange4) {
  function from(obj) {
    return { range: Range4.from(obj.range) };
  }
  SelectionRange4.from = from;
  function to(obj) {
    return new SelectionRange(Range4.to(obj.range));
  }
  SelectionRange4.to = to;
})(SelectionRange3 || (SelectionRange3 = {}));
var TextDocumentSaveReason2;
(function(TextDocumentSaveReason3) {
  function to(reason) {
    switch (reason) {
      case 2:
        return TextDocumentSaveReason.AfterDelay;
      case 1:
        return TextDocumentSaveReason.Manual;
      case 3:
      case 4:
        return TextDocumentSaveReason.FocusOut;
    }
  }
  TextDocumentSaveReason3.to = to;
})(TextDocumentSaveReason2 || (TextDocumentSaveReason2 = {}));
var TextEditorLineNumbersStyle2;
(function(TextEditorLineNumbersStyle3) {
  function from(style) {
    switch (style) {
      case TextEditorLineNumbersStyle.Off:
        return 0;
      case TextEditorLineNumbersStyle.Relative:
        return 2;
      case TextEditorLineNumbersStyle.Interval:
        return 3;
      case TextEditorLineNumbersStyle.On:
      default:
        return 1;
    }
  }
  TextEditorLineNumbersStyle3.from = from;
  function to(style) {
    switch (style) {
      case 0:
        return TextEditorLineNumbersStyle.Off;
      case 2:
        return TextEditorLineNumbersStyle.Relative;
      case 3:
        return TextEditorLineNumbersStyle.Interval;
      case 1:
      default:
        return TextEditorLineNumbersStyle.On;
    }
  }
  TextEditorLineNumbersStyle3.to = to;
})(TextEditorLineNumbersStyle2 || (TextEditorLineNumbersStyle2 = {}));
var EndOfLine2;
(function(EndOfLine3) {
  function from(eol) {
    if (eol === EndOfLine.CRLF) {
      return 1;
    } else if (eol === EndOfLine.LF) {
      return 0;
    }
    return void 0;
  }
  EndOfLine3.from = from;
  function to(eol) {
    if (eol === 1) {
      return EndOfLine.CRLF;
    } else if (eol === 0) {
      return EndOfLine.LF;
    }
    return void 0;
  }
  EndOfLine3.to = to;
})(EndOfLine2 || (EndOfLine2 = {}));
var ProgressLocation2;
(function(ProgressLocation4) {
  function from(loc) {
    if (typeof loc === "object") {
      return loc.viewId;
    }
    switch (loc) {
      case ProgressLocation.SourceControl:
        return 3;
      case ProgressLocation.Window:
        return 10;
      case ProgressLocation.Notification:
        return 15;
    }
    throw new Error(`Unknown 'ProgressLocation'`);
  }
  ProgressLocation4.from = from;
})(ProgressLocation2 || (ProgressLocation2 = {}));
var FoldingRange3;
(function(FoldingRange4) {
  function from(r) {
    const range = { start: r.start + 1, end: r.end + 1 };
    if (r.kind) {
      range.kind = FoldingRangeKind3.from(r.kind);
    }
    return range;
  }
  FoldingRange4.from = from;
  function to(r) {
    const range = { start: r.start - 1, end: r.end - 1 };
    if (r.kind) {
      range.kind = FoldingRangeKind3.to(r.kind);
    }
    return range;
  }
  FoldingRange4.to = to;
})(FoldingRange3 || (FoldingRange3 = {}));
var FoldingRangeKind3;
(function(FoldingRangeKind4) {
  function from(kind) {
    if (kind) {
      switch (kind) {
        case FoldingRangeKind2.Comment:
          return FoldingRangeKind.Comment;
        case FoldingRangeKind2.Imports:
          return FoldingRangeKind.Imports;
        case FoldingRangeKind2.Region:
          return FoldingRangeKind.Region;
      }
    }
    return void 0;
  }
  FoldingRangeKind4.from = from;
  function to(kind) {
    if (kind) {
      switch (kind.value) {
        case FoldingRangeKind.Comment.value:
          return FoldingRangeKind2.Comment;
        case FoldingRangeKind.Imports.value:
          return FoldingRangeKind2.Imports;
        case FoldingRangeKind.Region.value:
          return FoldingRangeKind2.Region;
      }
    }
    return void 0;
  }
  FoldingRangeKind4.to = to;
})(FoldingRangeKind3 || (FoldingRangeKind3 = {}));
var TextEditorOpenOptions;
(function(TextEditorOpenOptions2) {
  function from(options2) {
    if (options2) {
      return {
        pinned: typeof options2.preview === "boolean" ? !options2.preview : void 0,
        inactive: options2.background,
        preserveFocus: options2.preserveFocus,
        selection: typeof options2.selection === "object" ? Range4.from(options2.selection) : void 0,
        override: typeof options2.override === "boolean" ? DEFAULT_EDITOR_ASSOCIATION.id : void 0
      };
    }
    return void 0;
  }
  TextEditorOpenOptions2.from = from;
})(TextEditorOpenOptions || (TextEditorOpenOptions = {}));
var GlobPattern;
(function(GlobPattern2) {
  function from(pattern) {
    if (pattern instanceof RelativePattern) {
      return pattern.toJSON();
    }
    if (typeof pattern === "string") {
      return pattern;
    }
    if (isRelativePatternShape(pattern) || isLegacyRelativePatternShape(pattern)) {
      return new RelativePattern(pattern.baseUri ?? pattern.base, pattern.pattern).toJSON();
    }
    return pattern;
  }
  GlobPattern2.from = from;
  function isRelativePatternShape(obj) {
    const rp = obj;
    if (!rp) {
      return false;
    }
    return URI.isUri(rp.baseUri) && typeof rp.pattern === "string";
  }
  function isLegacyRelativePatternShape(obj) {
    const rp = obj;
    if (!rp) {
      return false;
    }
    return typeof rp.base === "string" && typeof rp.pattern === "string";
  }
  function to(pattern) {
    if (typeof pattern === "string") {
      return pattern;
    }
    return new RelativePattern(URI.revive(pattern.baseUri), pattern.pattern);
  }
  GlobPattern2.to = to;
})(GlobPattern || (GlobPattern = {}));
var LanguageSelector;
(function(LanguageSelector2) {
  function from(selector) {
    if (!selector) {
      return void 0;
    } else if (Array.isArray(selector)) {
      return selector.map(from);
    } else if (typeof selector === "string") {
      return selector;
    } else {
      const filter2 = selector;
      return {
        language: filter2.language,
        scheme: filter2.scheme,
        pattern: GlobPattern.from(filter2.pattern) ?? void 0,
        exclusive: filter2.exclusive,
        notebookType: filter2.notebookType
      };
    }
  }
  LanguageSelector2.from = from;
})(LanguageSelector || (LanguageSelector = {}));
var NotebookRange2;
(function(NotebookRange3) {
  function from(range) {
    return { start: range.start, end: range.end };
  }
  NotebookRange3.from = from;
  function to(range) {
    return new NotebookRange(range.start, range.end);
  }
  NotebookRange3.to = to;
})(NotebookRange2 || (NotebookRange2 = {}));
var NotebookCellExecutionSummary;
(function(NotebookCellExecutionSummary2) {
  function to(data2) {
    return {
      timing: typeof data2.runStartTime === "number" && typeof data2.runEndTime === "number" ? { startTime: data2.runStartTime, endTime: data2.runEndTime } : void 0,
      executionOrder: data2.executionOrder,
      success: data2.lastRunSuccess
    };
  }
  NotebookCellExecutionSummary2.to = to;
  function from(data2) {
    return {
      lastRunSuccess: data2.success,
      runStartTime: data2.timing?.startTime,
      runEndTime: data2.timing?.endTime,
      executionOrder: data2.executionOrder
    };
  }
  NotebookCellExecutionSummary2.from = from;
})(NotebookCellExecutionSummary || (NotebookCellExecutionSummary = {}));
var NotebookCellKind2;
(function(NotebookCellKind3) {
  function from(data2) {
    switch (data2) {
      case NotebookCellKind.Markup:
        return CellKind.Markup;
      case NotebookCellKind.Code:
      default:
        return CellKind.Code;
    }
  }
  NotebookCellKind3.from = from;
  function to(data2) {
    switch (data2) {
      case CellKind.Markup:
        return NotebookCellKind.Markup;
      case CellKind.Code:
      default:
        return NotebookCellKind.Code;
    }
  }
  NotebookCellKind3.to = to;
})(NotebookCellKind2 || (NotebookCellKind2 = {}));
var NotebookData2;
(function(NotebookData3) {
  function from(data2) {
    const res = {
      metadata: data2.metadata ?? /* @__PURE__ */ Object.create(null),
      cells: []
    };
    for (const cell of data2.cells) {
      NotebookCellData.validate(cell);
      res.cells.push(NotebookCellData2.from(cell));
    }
    return res;
  }
  NotebookData3.from = from;
  function to(data2) {
    const res = new NotebookData(data2.cells.map(NotebookCellData2.to));
    if (!isEmptyObject(data2.metadata)) {
      res.metadata = data2.metadata;
    }
    return res;
  }
  NotebookData3.to = to;
})(NotebookData2 || (NotebookData2 = {}));
var NotebookCellData2;
(function(NotebookCellData3) {
  function from(data2) {
    return {
      cellKind: NotebookCellKind2.from(data2.kind),
      language: data2.languageId,
      mime: data2.mime,
      source: data2.value,
      metadata: data2.metadata,
      internalMetadata: NotebookCellExecutionSummary.from(data2.executionSummary ?? {}),
      outputs: data2.outputs ? data2.outputs.map(NotebookCellOutput2.from) : []
    };
  }
  NotebookCellData3.from = from;
  function to(data2) {
    return new NotebookCellData(NotebookCellKind2.to(data2.cellKind), data2.source, data2.language, data2.mime, data2.outputs ? data2.outputs.map(NotebookCellOutput2.to) : void 0, data2.metadata, data2.internalMetadata ? NotebookCellExecutionSummary.to(data2.internalMetadata) : void 0);
  }
  NotebookCellData3.to = to;
})(NotebookCellData2 || (NotebookCellData2 = {}));
var NotebookCellOutputItem2;
(function(NotebookCellOutputItem3) {
  function from(item) {
    return {
      mime: item.mime,
      valueBytes: VSBuffer.wrap(item.data)
    };
  }
  NotebookCellOutputItem3.from = from;
  function to(item) {
    return new NotebookCellOutputItem(item.valueBytes.buffer, item.mime);
  }
  NotebookCellOutputItem3.to = to;
})(NotebookCellOutputItem2 || (NotebookCellOutputItem2 = {}));
var NotebookCellOutput2;
(function(NotebookCellOutput3) {
  function from(output) {
    return {
      outputId: output.id,
      items: output.items.map(NotebookCellOutputItem2.from),
      metadata: output.metadata
    };
  }
  NotebookCellOutput3.from = from;
  function to(output) {
    const items = output.items.map(NotebookCellOutputItem2.to);
    return new NotebookCellOutput(items, output.outputId, output.metadata);
  }
  NotebookCellOutput3.to = to;
})(NotebookCellOutput2 || (NotebookCellOutput2 = {}));
var NotebookExclusiveDocumentPattern;
(function(NotebookExclusiveDocumentPattern2) {
  function from(pattern) {
    if (isExclusivePattern(pattern)) {
      return {
        include: GlobPattern.from(pattern.include) ?? void 0,
        exclude: GlobPattern.from(pattern.exclude) ?? void 0
      };
    }
    return GlobPattern.from(pattern) ?? void 0;
  }
  NotebookExclusiveDocumentPattern2.from = from;
  function to(pattern) {
    if (isExclusivePattern(pattern)) {
      return {
        include: GlobPattern.to(pattern.include),
        exclude: GlobPattern.to(pattern.exclude)
      };
    }
    return GlobPattern.to(pattern);
  }
  NotebookExclusiveDocumentPattern2.to = to;
  function isExclusivePattern(obj) {
    const ep = obj;
    if (!ep) {
      return false;
    }
    return !isUndefinedOrNull(ep.include) && !isUndefinedOrNull(ep.exclude);
  }
})(NotebookExclusiveDocumentPattern || (NotebookExclusiveDocumentPattern = {}));
var NotebookStatusBarItem;
(function(NotebookStatusBarItem2) {
  function from(item, commandsConverter, disposables) {
    const command = typeof item.command === "string" ? { title: "", command: item.command } : item.command;
    return {
      alignment: item.alignment === NotebookCellStatusBarAlignment.Left ? 1 : 2,
      command: commandsConverter.toInternal(command, disposables),
      // TODO@roblou
      text: item.text,
      tooltip: item.tooltip,
      accessibilityInformation: item.accessibilityInformation,
      priority: item.priority
    };
  }
  NotebookStatusBarItem2.from = from;
})(NotebookStatusBarItem || (NotebookStatusBarItem = {}));
var NotebookKernelSourceAction2;
(function(NotebookKernelSourceAction3) {
  function from(item, commandsConverter, disposables) {
    const command = typeof item.command === "string" ? { title: "", command: item.command } : item.command;
    return {
      command: commandsConverter.toInternal(command, disposables),
      label: item.label,
      description: item.description,
      detail: item.detail,
      documentation: item.documentation
    };
  }
  NotebookKernelSourceAction3.from = from;
})(NotebookKernelSourceAction2 || (NotebookKernelSourceAction2 = {}));
var NotebookDocumentContentOptions;
(function(NotebookDocumentContentOptions2) {
  function from(options2) {
    return {
      transientOutputs: options2?.transientOutputs ?? false,
      transientCellMetadata: options2?.transientCellMetadata ?? {},
      transientDocumentMetadata: options2?.transientDocumentMetadata ?? {},
      cellContentMetadata: options2?.cellContentMetadata ?? {}
    };
  }
  NotebookDocumentContentOptions2.from = from;
})(NotebookDocumentContentOptions || (NotebookDocumentContentOptions = {}));
var NotebookRendererScript2;
(function(NotebookRendererScript3) {
  function from(preload) {
    return {
      uri: preload.uri,
      provides: preload.provides
    };
  }
  NotebookRendererScript3.from = from;
  function to(preload) {
    return new NotebookRendererScript(URI.revive(preload.uri), preload.provides);
  }
  NotebookRendererScript3.to = to;
})(NotebookRendererScript2 || (NotebookRendererScript2 = {}));
var TestMessage3;
(function(TestMessage4) {
  function from(message) {
    return {
      message: MarkdownString4.fromStrict(message.message) || "",
      type: 0,
      expected: message.expectedOutput,
      actual: message.actualOutput,
      contextValue: message.contextValue,
      location: message.location && { range: Range4.from(message.location.range), uri: message.location.uri },
      stackTrace: message.stackTrace?.map((s) => ({
        label: s.label,
        position: s.position && Position4.from(s.position),
        uri: s.uri && URI.revive(s.uri).toJSON()
      }))
    };
  }
  TestMessage4.from = from;
  function to(item) {
    const message = new TestMessage(typeof item.message === "string" ? item.message : MarkdownString4.to(item.message));
    message.actualOutput = item.actual;
    message.expectedOutput = item.expected;
    message.contextValue = item.contextValue;
    message.location = item.location ? location.to(item.location) : void 0;
    return message;
  }
  TestMessage4.to = to;
})(TestMessage3 || (TestMessage3 = {}));
var TestTag3;
(function(TestTag4) {
  TestTag4.namespace = namespaceTestTag;
  TestTag4.denamespace = denamespaceTestTag;
})(TestTag3 || (TestTag3 = {}));
var TestRunProfile;
(function(TestRunProfile2) {
  function from(item) {
    return {
      controllerId: item.controllerId,
      profileId: item.profileId,
      group: TestRunProfileKind2.from(item.kind)
    };
  }
  TestRunProfile2.from = from;
})(TestRunProfile || (TestRunProfile = {}));
var TestRunProfileKind2;
(function(TestRunProfileKind3) {
  const profileGroupToBitset = {
    [TestRunProfileKind.Coverage]: 8,
    [TestRunProfileKind.Debug]: 4,
    [TestRunProfileKind.Run]: 2
  };
  function from(kind) {
    return profileGroupToBitset.hasOwnProperty(kind) ? profileGroupToBitset[kind] : 2;
  }
  TestRunProfileKind3.from = from;
})(TestRunProfileKind2 || (TestRunProfileKind2 = {}));
var TestItem;
(function(TestItem2) {
  function from(item) {
    const ctrlId = getPrivateApiFor(item).controllerId;
    return {
      extId: TestId.fromExtHostTestItem(item, ctrlId).toString(),
      label: item.label,
      uri: URI.revive(item.uri),
      busy: item.busy,
      tags: item.tags.map((t) => TestTag3.namespace(ctrlId, t.id)),
      range: Range.lift(Range4.from(item.range)),
      description: item.description || null,
      sortText: item.sortText || null,
      error: item.error ? MarkdownString4.fromStrict(item.error) || null : null
    };
  }
  TestItem2.from = from;
  function toPlain(item) {
    return {
      parent: void 0,
      error: void 0,
      id: TestId.fromString(item.extId).localId,
      label: item.label,
      uri: URI.revive(item.uri),
      tags: (item.tags || []).map((t) => {
        const { tagId } = TestTag3.denamespace(t);
        return new TestTag(tagId);
      }),
      children: {
        add: () => {
        },
        delete: () => {
        },
        forEach: () => {
        },
        *[Symbol.iterator]() {
        },
        get: () => void 0,
        replace: () => {
        },
        size: 0
      },
      range: Range4.to(item.range || void 0),
      canResolveChildren: false,
      busy: item.busy,
      description: item.description || void 0,
      sortText: item.sortText || void 0
    };
  }
  TestItem2.toPlain = toPlain;
})(TestItem || (TestItem = {}));
(function(TestTag4) {
  function from(tag2) {
    return { id: tag2.id };
  }
  TestTag4.from = from;
  function to(tag2) {
    return new TestTag(tag2.id);
  }
  TestTag4.to = to;
})(TestTag3 || (TestTag3 = {}));
var TestResults;
(function(TestResults2) {
  const convertTestResultItem = (node, parent) => {
    const item = node.value;
    if (!item) {
      return void 0;
    }
    const snapshot = {
      ...TestItem.toPlain(item.item),
      parent,
      taskStates: item.tasks.map((t) => ({
        state: t.state,
        duration: t.duration,
        messages: t.messages.filter(
          (m) => m.type === 0
          /* TestMessageType.Error */
        ).map(TestMessage3.to)
      })),
      children: []
    };
    if (node.children) {
      for (const child of node.children.values()) {
        const c = convertTestResultItem(child, snapshot);
        if (c) {
          snapshot.children.push(c);
        }
      }
    }
    return snapshot;
  };
  function to(serialized) {
    const tree = new WellDefinedPrefixTree();
    for (const item of serialized.items) {
      tree.insert(TestId.fromString(item.item.extId).path, item);
    }
    const queue = [tree.nodes];
    const roots = [];
    while (queue.length) {
      for (const node of queue.pop()) {
        if (node.value) {
          roots.push(node);
        } else if (node.children) {
          queue.push(node.children.values());
        }
      }
    }
    return {
      completedAt: serialized.completedAt,
      results: roots.map((r) => convertTestResultItem(r)).filter(isDefined)
    };
  }
  TestResults2.to = to;
})(TestResults || (TestResults = {}));
var TestCoverage;
(function(TestCoverage2) {
  function fromCoverageCount(count2) {
    return { covered: count2.covered, total: count2.total };
  }
  function fromLocation(location2) {
    return "line" in location2 ? Position4.from(location2) : Range4.from(location2);
  }
  function toLocation(location2) {
    if (!location2) {
      return void 0;
    }
    return "endLineNumber" in location2 ? Range4.to(location2) : Position4.to(location2);
  }
  function to(serialized) {
    if (serialized.type === 1) {
      const branches = [];
      if (serialized.branches) {
        for (const branch of serialized.branches) {
          branches.push({
            executed: branch.count,
            location: toLocation(branch.location),
            label: branch.label
          });
        }
      }
      return new StatementCoverage(serialized.count, toLocation(serialized.location), serialized.branches?.map((b) => new BranchCoverage(b.count, toLocation(b.location), b.label)));
    } else {
      return new DeclarationCoverage(serialized.name, serialized.count, toLocation(serialized.location));
    }
  }
  TestCoverage2.to = to;
  function fromDetails(coverage) {
    if (typeof coverage.executed === "number" && coverage.executed < 0) {
      throw new Error(`Invalid coverage count ${coverage.executed}`);
    }
    if ("branches" in coverage) {
      return {
        count: coverage.executed,
        location: fromLocation(coverage.location),
        type: 1,
        branches: coverage.branches.length ? coverage.branches.map((b) => ({ count: b.executed, location: b.location && fromLocation(b.location), label: b.label })) : void 0
      };
    } else {
      return {
        type: 0,
        name: coverage.name,
        count: coverage.executed,
        location: fromLocation(coverage.location)
      };
    }
  }
  TestCoverage2.fromDetails = fromDetails;
  function fromFile(controllerId, id2, coverage) {
    validateTestCoverageCount(coverage.statementCoverage);
    validateTestCoverageCount(coverage.branchCoverage);
    validateTestCoverageCount(coverage.declarationCoverage);
    return {
      id: id2,
      uri: coverage.uri,
      statement: fromCoverageCount(coverage.statementCoverage),
      branch: coverage.branchCoverage && fromCoverageCount(coverage.branchCoverage),
      declaration: coverage.declarationCoverage && fromCoverageCount(coverage.declarationCoverage),
      testIds: coverage instanceof FileCoverage && coverage.includesTests.length ? coverage.includesTests.map((t) => TestId.fromExtHostTestItem(t, controllerId).toString()) : void 0
    };
  }
  TestCoverage2.fromFile = fromFile;
})(TestCoverage || (TestCoverage = {}));
var CodeActionTriggerKind2;
(function(CodeActionTriggerKind3) {
  function to(value) {
    switch (value) {
      case 1:
        return CodeActionTriggerKind.Invoke;
      case 2:
        return CodeActionTriggerKind.Automatic;
    }
  }
  CodeActionTriggerKind3.to = to;
})(CodeActionTriggerKind2 || (CodeActionTriggerKind2 = {}));
var TypeHierarchyItem2;
(function(TypeHierarchyItem3) {
  function to(item) {
    const result = new TypeHierarchyItem(SymbolKind3.to(item.kind), item.name, item.detail || "", URI.revive(item.uri), Range4.to(item.range), Range4.to(item.selectionRange));
    result._sessionId = item._sessionId;
    result._itemId = item._itemId;
    return result;
  }
  TypeHierarchyItem3.to = to;
  function from(item, sessionId, itemId) {
    sessionId = sessionId ?? item._sessionId;
    itemId = itemId ?? item._itemId;
    if (sessionId === void 0 || itemId === void 0) {
      throw new Error("invalid item");
    }
    return {
      _sessionId: sessionId,
      _itemId: itemId,
      kind: SymbolKind3.from(item.kind),
      name: item.name,
      detail: item.detail ?? "",
      uri: item.uri,
      range: Range4.from(item.range),
      selectionRange: Range4.from(item.selectionRange),
      tags: item.tags?.map(SymbolTag3.from)
    };
  }
  TypeHierarchyItem3.from = from;
})(TypeHierarchyItem2 || (TypeHierarchyItem2 = {}));
var ViewBadge2;
(function(ViewBadge3) {
  function from(badge) {
    if (!badge) {
      return void 0;
    }
    return {
      value: badge.value,
      tooltip: badge.tooltip
    };
  }
  ViewBadge3.from = from;
})(ViewBadge2 || (ViewBadge2 = {}));
var DataTransferItem3;
(function(DataTransferItem4) {
  function to(mime, item, resolveFileData) {
    const file = item.fileData;
    if (file) {
      return new InternalFileDataTransferItem(new DataTransferFile(file.name, URI.revive(file.uri), file.id, createSingleCallFunction(() => resolveFileData(file.id))));
    }
    if (mime === Mimes.uriList && item.uriListData) {
      return new InternalDataTransferItem(reviveUriList(item.uriListData));
    }
    return new InternalDataTransferItem(item.asString);
  }
  DataTransferItem4.to = to;
  async function from(mime, item, id2 = generateUuid()) {
    const stringValue = await item.asString();
    if (mime === Mimes.uriList) {
      return {
        id: id2,
        asString: stringValue,
        fileData: void 0,
        uriListData: serializeUriList(stringValue)
      };
    }
    const fileValue = item.asFile();
    return {
      id: id2,
      asString: stringValue,
      fileData: fileValue ? {
        name: fileValue.name,
        uri: fileValue.uri,
        id: fileValue._itemId ?? fileValue.id
      } : void 0
    };
  }
  DataTransferItem4.from = from;
  function serializeUriList(stringValue) {
    return UriList.split(stringValue).map((part) => {
      if (part.startsWith("#")) {
        return part;
      }
      try {
        return URI.parse(part);
      } catch {
      }
      return part;
    });
  }
  function reviveUriList(parts) {
    return UriList.create(parts.map((part) => {
      return typeof part === "string" ? part : URI.revive(part);
    }));
  }
})(DataTransferItem3 || (DataTransferItem3 = {}));
var DataTransfer3;
(function(DataTransfer4) {
  function toDataTransfer(value, resolveFileData) {
    const init = value.items.map(([type, item]) => {
      return [type, DataTransferItem3.to(type, item, resolveFileData)];
    });
    return new DataTransfer(init);
  }
  DataTransfer4.toDataTransfer = toDataTransfer;
  async function from(dataTransfer) {
    const items = await Promise.all(Array.from(dataTransfer, async ([mime, value]) => {
      return [mime, await DataTransferItem3.from(mime, value)];
    }));
    return { items };
  }
  DataTransfer4.from = from;
  async function fromList(dataTransfer) {
    const items = await Promise.all(Array.from(dataTransfer, async ([mime, value]) => {
      return [mime, await DataTransferItem3.from(mime, value, value.id)];
    }));
    return { items };
  }
  DataTransfer4.fromList = fromList;
})(DataTransfer3 || (DataTransfer3 = {}));
var ChatFollowup;
(function(ChatFollowup2) {
  function from(followup, request) {
    return {
      kind: "reply",
      agentId: followup.participant ?? request?.agentId ?? "",
      subCommand: followup.command ?? request?.command,
      message: followup.prompt,
      title: followup.label
    };
  }
  ChatFollowup2.from = from;
  function to(followup) {
    return {
      prompt: followup.message,
      label: followup.title,
      participant: followup.agentId,
      command: followup.subCommand
    };
  }
  ChatFollowup2.to = to;
})(ChatFollowup || (ChatFollowup = {}));
var LanguageModelChatMessageRole2;
(function(LanguageModelChatMessageRole3) {
  function to(role) {
    switch (role) {
      case 0:
        return LanguageModelChatMessageRole.System;
      case 1:
        return LanguageModelChatMessageRole.User;
      case 2:
        return LanguageModelChatMessageRole.Assistant;
    }
  }
  LanguageModelChatMessageRole3.to = to;
  function from(role) {
    switch (role) {
      case LanguageModelChatMessageRole.System:
        return 0;
      case LanguageModelChatMessageRole.User:
        return 1;
      case LanguageModelChatMessageRole.Assistant:
        return 2;
    }
    return 1;
  }
  LanguageModelChatMessageRole3.from = from;
})(LanguageModelChatMessageRole2 || (LanguageModelChatMessageRole2 = {}));
var LanguageModelChatMessage3;
(function(LanguageModelChatMessage4) {
  function to(message) {
    const content = message.content.map((c) => {
      if (c.type === "text") {
        return new LanguageModelTextPart(c.value, c.audience);
      } else if (c.type === "tool_result") {
        const content2 = coalesce(c.value.map((part) => {
          if (part.type === "text") {
            return new LanguageModelTextPart(part.value, part.audience);
          } else if (part.type === "data") {
            return new LanguageModelDataPart(part.data.buffer, part.mimeType);
          } else if (part.type === "prompt_tsx") {
            return new LanguageModelPromptTsxPart(part.value);
          } else {
            return void 0;
          }
        }));
        return new LanguageModelToolResultPart(c.toolCallId, content2, c.isError);
      } else if (c.type === "image_url") {
        return new LanguageModelDataPart(c.value.data.buffer, c.value.mimeType);
      } else if (c.type === "data") {
        return new LanguageModelDataPart(c.data.buffer, c.mimeType);
      } else if (c.type === "tool_use") {
        return new LanguageModelToolCallPart(c.toolCallId, c.name, c.parameters);
      }
      return void 0;
    }).filter((c) => c !== void 0);
    const role = LanguageModelChatMessageRole2.to(message.role);
    const result = new LanguageModelChatMessage(role, content, message.name);
    return result;
  }
  LanguageModelChatMessage4.to = to;
  function from(message) {
    const role = LanguageModelChatMessageRole2.from(message.role);
    const name2 = message.name;
    let messageContent = message.content;
    if (typeof messageContent === "string") {
      messageContent = [new LanguageModelTextPart(messageContent)];
    }
    const content = messageContent.map((c) => {
      if (c instanceof LanguageModelToolResultPart) {
        return {
          type: "tool_result",
          toolCallId: c.callId,
          value: coalesce(c.content.map((part) => {
            if (part instanceof LanguageModelTextPart) {
              return {
                type: "text",
                value: part.value,
                audience: part.audience
              };
            } else if (part instanceof LanguageModelPromptTsxPart) {
              return {
                type: "prompt_tsx",
                value: part.value
              };
            } else if (part instanceof LanguageModelDataPart) {
              return {
                type: "data",
                mimeType: part.mimeType,
                data: VSBuffer.wrap(part.data),
                audience: part.audience
              };
            } else {
              return void 0;
            }
          })),
          isError: c.isError
        };
      } else if (c instanceof LanguageModelDataPart) {
        if (isImageDataPart(c)) {
          const value = {
            mimeType: c.mimeType,
            data: VSBuffer.wrap(c.data)
          };
          return {
            type: "image_url",
            value
          };
        } else {
          return {
            type: "data",
            mimeType: c.mimeType,
            data: VSBuffer.wrap(c.data),
            audience: c.audience
          };
        }
      } else if (c instanceof LanguageModelToolCallPart) {
        return {
          type: "tool_use",
          toolCallId: c.callId,
          name: c.name,
          parameters: c.input
        };
      } else if (c instanceof LanguageModelTextPart) {
        return {
          type: "text",
          value: c.value
        };
      } else {
        if (typeof c !== "string") {
          throw new Error("Unexpected chat message content type");
        }
        return {
          type: "text",
          value: c
        };
      }
    });
    return {
      role,
      name: name2,
      content
    };
  }
  LanguageModelChatMessage4.from = from;
})(LanguageModelChatMessage3 || (LanguageModelChatMessage3 = {}));
var LanguageModelChatMessage22;
(function(LanguageModelChatMessage23) {
  function to(message) {
    const content = message.content.map((c) => {
      if (c.type === "text") {
        return new LanguageModelTextPart(c.value, c.audience);
      } else if (c.type === "tool_result") {
        const content2 = c.value.map((part) => {
          if (part.type === "text") {
            return new LanguageModelTextPart(part.value, part.audience);
          } else if (part.type === "data") {
            return new LanguageModelDataPart(part.data.buffer, part.mimeType);
          } else {
            return new LanguageModelPromptTsxPart(part.value);
          }
        });
        return new LanguageModelToolResultPart(c.toolCallId, content2, c.isError);
      } else if (c.type === "image_url") {
        return new LanguageModelDataPart(c.value.data.buffer, c.value.mimeType);
      } else if (c.type === "data") {
        return new LanguageModelDataPart(c.data.buffer, c.mimeType);
      } else if (c.type === "thinking") {
        return new LanguageModelThinkingPart(c.value, c.id, c.metadata);
      } else {
        return new LanguageModelToolCallPart(c.toolCallId, c.name, c.parameters);
      }
    });
    const role = LanguageModelChatMessageRole2.to(message.role);
    const result = new LanguageModelChatMessage2(role, content, message.name);
    return result;
  }
  LanguageModelChatMessage23.to = to;
  function from(message) {
    const role = LanguageModelChatMessageRole2.from(message.role);
    const name2 = message.name;
    let messageContent = message.content;
    if (typeof messageContent === "string") {
      messageContent = [new LanguageModelTextPart(messageContent)];
    }
    const content = messageContent.map((c) => {
      if (c instanceof LanguageModelToolResultPart) {
        return {
          type: "tool_result",
          toolCallId: c.callId,
          value: coalesce(c.content.map((part) => {
            if (part instanceof LanguageModelTextPart) {
              return {
                type: "text",
                value: part.value,
                audience: part.audience
              };
            } else if (part instanceof LanguageModelPromptTsxPart) {
              return {
                type: "prompt_tsx",
                value: part.value
              };
            } else if (part instanceof LanguageModelDataPart) {
              return {
                type: "data",
                mimeType: part.mimeType,
                data: VSBuffer.wrap(part.data),
                audience: part.audience
              };
            } else {
              return void 0;
            }
          })),
          isError: c.isError
        };
      } else if (c instanceof LanguageModelDataPart) {
        if (isImageDataPart(c)) {
          const value = {
            mimeType: c.mimeType,
            data: VSBuffer.wrap(c.data)
          };
          return {
            type: "image_url",
            value
          };
        } else {
          return {
            type: "data",
            mimeType: c.mimeType,
            data: VSBuffer.wrap(c.data),
            audience: c.audience
          };
        }
      } else if (c instanceof LanguageModelToolCallPart) {
        return {
          type: "tool_use",
          toolCallId: c.callId,
          name: c.name,
          parameters: c.input
        };
      } else if (c instanceof LanguageModelTextPart) {
        return {
          type: "text",
          value: c.value
        };
      } else if (c instanceof LanguageModelThinkingPart) {
        return {
          type: "thinking",
          value: c.value,
          id: c.id,
          metadata: c.metadata
        };
      } else {
        if (typeof c !== "string") {
          throw new Error("Unexpected chat message content type llm 2");
        }
        return {
          type: "text",
          value: c
        };
      }
    });
    return {
      role,
      name: name2,
      content
    };
  }
  LanguageModelChatMessage23.from = from;
})(LanguageModelChatMessage22 || (LanguageModelChatMessage22 = {}));
function isImageDataPart(part) {
  const mime = typeof part.mimeType === "string" ? part.mimeType.toLowerCase() : "";
  switch (mime) {
    case "image/png":
    case "image/jpeg":
    case "image/jpg":
    case "image/gif":
    case "image/webp":
    case "image/bmp":
      return true;
    default:
      return false;
  }
}
var ChatResponseMarkdownPart2;
(function(ChatResponseMarkdownPart3) {
  function from(part) {
    return {
      kind: "markdownContent",
      content: MarkdownString4.from(part.value)
    };
  }
  ChatResponseMarkdownPart3.from = from;
  function to(part) {
    return new ChatResponseMarkdownPart(MarkdownString4.to(part.content));
  }
  ChatResponseMarkdownPart3.to = to;
})(ChatResponseMarkdownPart2 || (ChatResponseMarkdownPart2 = {}));
var ChatResponseCodeblockUriPart2;
(function(ChatResponseCodeblockUriPart3) {
  function from(part) {
    return {
      kind: "codeblockUri",
      uri: part.value,
      isEdit: part.isEdit
    };
  }
  ChatResponseCodeblockUriPart3.from = from;
  function to(part) {
    return new ChatResponseCodeblockUriPart(URI.revive(part.uri), part.isEdit);
  }
  ChatResponseCodeblockUriPart3.to = to;
})(ChatResponseCodeblockUriPart2 || (ChatResponseCodeblockUriPart2 = {}));
var ChatResponseMarkdownWithVulnerabilitiesPart2;
(function(ChatResponseMarkdownWithVulnerabilitiesPart3) {
  function from(part) {
    return {
      kind: "markdownVuln",
      content: MarkdownString4.from(part.value),
      vulnerabilities: part.vulnerabilities
    };
  }
  ChatResponseMarkdownWithVulnerabilitiesPart3.from = from;
  function to(part) {
    return new ChatResponseMarkdownWithVulnerabilitiesPart(MarkdownString4.to(part.content), part.vulnerabilities);
  }
  ChatResponseMarkdownWithVulnerabilitiesPart3.to = to;
})(ChatResponseMarkdownWithVulnerabilitiesPart2 || (ChatResponseMarkdownWithVulnerabilitiesPart2 = {}));
var ChatResponseConfirmationPart2;
(function(ChatResponseConfirmationPart3) {
  function from(part) {
    return {
      kind: "confirmation",
      title: part.title,
      message: MarkdownString4.from(part.message),
      data: part.data,
      buttons: part.buttons
    };
  }
  ChatResponseConfirmationPart3.from = from;
})(ChatResponseConfirmationPart2 || (ChatResponseConfirmationPart2 = {}));
var ChatResponseFilesPart;
(function(ChatResponseFilesPart2) {
  function from(part) {
    const { value, baseUri } = part;
    function convert(items, baseUri2) {
      return items.map((item) => {
        const myUri = URI.joinPath(baseUri2, item.name);
        return {
          label: item.name,
          uri: myUri,
          children: item.children && convert(item.children, myUri)
        };
      });
    }
    return {
      kind: "treeData",
      treeData: {
        label: basename2(baseUri),
        uri: baseUri,
        children: convert(value, baseUri)
      }
    };
  }
  ChatResponseFilesPart2.from = from;
  function to(part) {
    const treeData = revive(part.treeData);
    function convert(items2) {
      return items2.map((item) => {
        return {
          name: item.label,
          children: item.children && convert(item.children)
        };
      });
    }
    const baseUri = treeData.uri;
    const items = treeData.children ? convert(treeData.children) : [];
    return new ChatResponseFileTreePart(items, baseUri);
  }
  ChatResponseFilesPart2.to = to;
})(ChatResponseFilesPart || (ChatResponseFilesPart = {}));
var ChatResponseMultiDiffPart2;
(function(ChatResponseMultiDiffPart3) {
  function from(part) {
    return {
      kind: "multiDiffData",
      multiDiffData: {
        title: part.title,
        resources: part.value.map((entry) => ({
          originalUri: entry.originalUri,
          modifiedUri: entry.modifiedUri,
          goToFileUri: entry.goToFileUri,
          added: entry.added,
          removed: entry.removed
        }))
      },
      readOnly: part.readOnly
    };
  }
  ChatResponseMultiDiffPart3.from = from;
  function to(part) {
    const resources = part.multiDiffData.resources.map((resource) => ({
      originalUri: resource.originalUri ? URI.revive(resource.originalUri) : void 0,
      modifiedUri: resource.modifiedUri ? URI.revive(resource.modifiedUri) : void 0,
      goToFileUri: resource.goToFileUri ? URI.revive(resource.goToFileUri) : void 0,
      added: resource.added,
      removed: resource.removed
    }));
    return new ChatResponseMultiDiffPart(resources, part.multiDiffData.title, part.readOnly);
  }
  ChatResponseMultiDiffPart3.to = to;
})(ChatResponseMultiDiffPart2 || (ChatResponseMultiDiffPart2 = {}));
var ChatResponseAnchorPart2;
(function(ChatResponseAnchorPart3) {
  function from(part) {
    const isUri3 = (thing) => URI.isUri(thing);
    const isSymbolInformation = (thing) => "name" in thing;
    return {
      kind: "inlineReference",
      name: part.title,
      inlineReference: isUri3(part.value) ? part.value : isSymbolInformation(part.value) ? WorkspaceSymbol.from(part.value) : Location3.from(part.value)
    };
  }
  ChatResponseAnchorPart3.from = from;
  function to(part) {
    const value = revive(part);
    return new ChatResponseAnchorPart(URI.isUri(value.inlineReference) ? value.inlineReference : "location" in value.inlineReference ? WorkspaceSymbol.to(value.inlineReference) : Location3.to(value.inlineReference), part.name);
  }
  ChatResponseAnchorPart3.to = to;
})(ChatResponseAnchorPart2 || (ChatResponseAnchorPart2 = {}));
var ChatResponseProgressPart3;
(function(ChatResponseProgressPart4) {
  function from(part) {
    return {
      kind: "progressMessage",
      content: MarkdownString4.from(part.value)
    };
  }
  ChatResponseProgressPart4.from = from;
  function to(part) {
    return new ChatResponseProgressPart(part.content.value);
  }
  ChatResponseProgressPart4.to = to;
})(ChatResponseProgressPart3 || (ChatResponseProgressPart3 = {}));
var ChatResponseThinkingProgressPart2;
(function(ChatResponseThinkingProgressPart3) {
  function from(part) {
    return {
      kind: "thinking",
      value: part.value,
      id: part.id,
      metadata: part.metadata
    };
  }
  ChatResponseThinkingProgressPart3.from = from;
  function to(part) {
    return new ChatResponseThinkingProgressPart(part.value ?? "", part.id, part.metadata);
  }
  ChatResponseThinkingProgressPart3.to = to;
})(ChatResponseThinkingProgressPart2 || (ChatResponseThinkingProgressPart2 = {}));
var ChatResponseWarningPart2;
(function(ChatResponseWarningPart3) {
  function from(part) {
    return {
      kind: "warning",
      content: MarkdownString4.from(part.value)
    };
  }
  ChatResponseWarningPart3.from = from;
  function to(part) {
    return new ChatResponseWarningPart(part.content.value);
  }
  ChatResponseWarningPart3.to = to;
})(ChatResponseWarningPart2 || (ChatResponseWarningPart2 = {}));
var ChatResponseExtensionsPart2;
(function(ChatResponseExtensionsPart3) {
  function from(part) {
    return {
      kind: "extensions",
      extensions: part.extensions
    };
  }
  ChatResponseExtensionsPart3.from = from;
})(ChatResponseExtensionsPart2 || (ChatResponseExtensionsPart2 = {}));
var ChatResponsePullRequestPart2;
(function(ChatResponsePullRequestPart3) {
  function from(part) {
    return {
      kind: "pullRequest",
      author: part.author,
      title: part.title,
      description: part.description,
      uri: part.uri,
      linkTag: part.linkTag
    };
  }
  ChatResponsePullRequestPart3.from = from;
})(ChatResponsePullRequestPart2 || (ChatResponsePullRequestPart2 = {}));
var ChatResponseMovePart2;
(function(ChatResponseMovePart3) {
  function from(part) {
    return {
      kind: "move",
      uri: part.uri,
      range: Range4.from(part.range)
    };
  }
  ChatResponseMovePart3.from = from;
  function to(part) {
    return new ChatResponseMovePart(URI.revive(part.uri), Range4.to(part.range));
  }
  ChatResponseMovePart3.to = to;
})(ChatResponseMovePart2 || (ChatResponseMovePart2 = {}));
var ChatPrepareToolInvocationPart2;
(function(ChatPrepareToolInvocationPart3) {
  function from(part) {
    return {
      kind: "prepareToolInvocation",
      toolName: part.toolName
    };
  }
  ChatPrepareToolInvocationPart3.from = from;
  function to(part) {
    return new ChatPrepareToolInvocationPart(part.toolName);
  }
  ChatPrepareToolInvocationPart3.to = to;
})(ChatPrepareToolInvocationPart2 || (ChatPrepareToolInvocationPart2 = {}));
var ChatToolInvocationPart2;
(function(ChatToolInvocationPart3) {
  function from(part) {
    return {
      kind: "toolInvocationSerialized",
      toolCallId: part.toolCallId,
      toolId: part.toolName,
      invocationMessage: part.invocationMessage ? MarkdownString4.from(part.invocationMessage) : part.toolName,
      originMessage: part.originMessage ? MarkdownString4.from(part.originMessage) : void 0,
      pastTenseMessage: part.pastTenseMessage ? MarkdownString4.from(part.pastTenseMessage) : void 0,
      isConfirmed: part.isConfirmed,
      isComplete: part.isComplete ?? true,
      source: ToolDataSource.External,
      // isError: part.isError ?? false,
      toolSpecificData: part.toolSpecificData ? convertToolSpecificData(part.toolSpecificData) : void 0,
      presentation: void 0,
      fromSubAgent: part.fromSubAgent
    };
  }
  ChatToolInvocationPart3.from = from;
  function convertToolSpecificData(data2) {
    if ("command" in data2 && "language" in data2) {
      return {
        kind: "terminal",
        command: data2.command,
        language: data2.language
      };
    } else if ("commandLine" in data2 && "language" in data2) {
      return {
        kind: "terminal",
        commandLine: data2.commandLine,
        language: data2.language
      };
    }
    return data2;
  }
  function to(part) {
    const toolInvocation = new ChatToolInvocationPart(part.toolId || part.toolName, part.toolCallId, part.isError);
    if (part.invocationMessage) {
      toolInvocation.invocationMessage = part.invocationMessage;
    }
    if (part.originMessage) {
      toolInvocation.originMessage = part.originMessage;
    }
    if (part.pastTenseMessage) {
      toolInvocation.pastTenseMessage = part.pastTenseMessage;
    }
    if (part.isConfirmed !== void 0) {
      toolInvocation.isConfirmed = part.isConfirmed;
    }
    if (part.isComplete !== void 0) {
      toolInvocation.isComplete = part.isComplete;
    }
    if (part.toolSpecificData) {
      toolInvocation.toolSpecificData = convertFromInternalToolSpecificData(part.toolSpecificData);
    }
    toolInvocation.fromSubAgent = part.fromSubAgent;
    return toolInvocation;
  }
  ChatToolInvocationPart3.to = to;
  function convertFromInternalToolSpecificData(data2) {
    if (data2.kind === "terminal") {
      return {
        command: data2.command,
        language: data2.language
      };
    } else if (data2.kind === "terminal2") {
      return {
        commandLine: data2.commandLine,
        language: data2.language
      };
    }
    return data2;
  }
})(ChatToolInvocationPart2 || (ChatToolInvocationPart2 = {}));
var ChatTask;
(function(ChatTask2) {
  function from(part) {
    return {
      kind: "progressTask",
      content: MarkdownString4.from(part.value)
    };
  }
  ChatTask2.from = from;
})(ChatTask || (ChatTask = {}));
var ChatTaskResult;
(function(ChatTaskResult2) {
  function from(part) {
    return {
      kind: "progressTaskResult",
      content: typeof part === "string" ? MarkdownString4.from(part) : void 0
    };
  }
  ChatTaskResult2.from = from;
})(ChatTaskResult || (ChatTaskResult = {}));
var ChatResponseCommandButtonPart2;
(function(ChatResponseCommandButtonPart3) {
  function from(part, commandsConverter, commandDisposables) {
    const command = commandsConverter.toInternal(part.value, commandDisposables) ?? { command: part.value.command, title: part.value.title };
    return {
      kind: "command",
      command
    };
  }
  ChatResponseCommandButtonPart3.from = from;
  function to(part, commandsConverter) {
    return new ChatResponseCommandButtonPart(commandsConverter.fromInternal(part.command) ?? { command: part.command.id, title: part.command.title });
  }
  ChatResponseCommandButtonPart3.to = to;
})(ChatResponseCommandButtonPart2 || (ChatResponseCommandButtonPart2 = {}));
var ChatResponseTextEditPart2;
(function(ChatResponseTextEditPart3) {
  function from(part) {
    return {
      kind: "textEdit",
      uri: part.uri,
      edits: part.edits.map((e) => TextEdit3.from(e)),
      done: part.isDone
    };
  }
  ChatResponseTextEditPart3.from = from;
  function to(part) {
    const result = new ChatResponseTextEditPart(URI.revive(part.uri), part.edits.map((e) => TextEdit3.to(e)));
    result.isDone = part.done;
    return result;
  }
  ChatResponseTextEditPart3.to = to;
})(ChatResponseTextEditPart2 || (ChatResponseTextEditPart2 = {}));
var NotebookEdit3;
(function(NotebookEdit4) {
  function from(edit2) {
    if (edit2.newCellMetadata) {
      return {
        editType: 3,
        index: edit2.range.start,
        metadata: edit2.newCellMetadata
      };
    } else if (edit2.newNotebookMetadata) {
      return {
        editType: 5,
        metadata: edit2.newNotebookMetadata
      };
    } else {
      return {
        editType: 1,
        index: edit2.range.start,
        count: edit2.range.end - edit2.range.start,
        cells: edit2.newCells.map(NotebookCellData2.from)
      };
    }
  }
  NotebookEdit4.from = from;
})(NotebookEdit3 || (NotebookEdit3 = {}));
var ChatResponseNotebookEditPart2;
(function(ChatResponseNotebookEditPart3) {
  function from(part) {
    return {
      kind: "notebookEdit",
      uri: part.uri,
      edits: part.edits.map(NotebookEdit3.from),
      done: part.isDone
    };
  }
  ChatResponseNotebookEditPart3.from = from;
})(ChatResponseNotebookEditPart2 || (ChatResponseNotebookEditPart2 = {}));
var ChatResponseReferencePart2;
(function(ChatResponseReferencePart3) {
  function from(part) {
    const iconPath = ThemeIcon.isThemeIcon(part.iconPath) ? part.iconPath : URI.isUri(part.iconPath) ? { light: URI.revive(part.iconPath) } : part.iconPath && "light" in part.iconPath && "dark" in part.iconPath && URI.isUri(part.iconPath.light) && URI.isUri(part.iconPath.dark) ? { light: URI.revive(part.iconPath.light), dark: URI.revive(part.iconPath.dark) } : void 0;
    if (typeof part.value === "object" && "variableName" in part.value) {
      return {
        kind: "reference",
        reference: {
          variableName: part.value.variableName,
          value: URI.isUri(part.value.value) || !part.value.value ? part.value.value : Location3.from(part.value.value)
        },
        iconPath,
        options: part.options
      };
    }
    return {
      kind: "reference",
      reference: URI.isUri(part.value) || typeof part.value === "string" ? part.value : Location3.from(part.value),
      iconPath,
      options: part.options
    };
  }
  ChatResponseReferencePart3.from = from;
  function to(part) {
    const value = revive(part);
    const mapValue = (value2) => URI.isUri(value2) ? value2 : Location3.to(value2);
    return new ChatResponseReferencePart(typeof value.reference === "string" ? value.reference : "variableName" in value.reference ? {
      variableName: value.reference.variableName,
      value: value.reference.value && mapValue(value.reference.value)
    } : mapValue(value.reference));
  }
  ChatResponseReferencePart3.to = to;
})(ChatResponseReferencePart2 || (ChatResponseReferencePart2 = {}));
var ChatResponseCodeCitationPart2;
(function(ChatResponseCodeCitationPart3) {
  function from(part) {
    return {
      kind: "codeCitation",
      value: part.value,
      license: part.license,
      snippet: part.snippet
    };
  }
  ChatResponseCodeCitationPart3.from = from;
})(ChatResponseCodeCitationPart2 || (ChatResponseCodeCitationPart2 = {}));
var ChatResponsePart;
(function(ChatResponsePart2) {
  function from(part, commandsConverter, commandDisposables) {
    if (part instanceof ChatResponseMarkdownPart) {
      return ChatResponseMarkdownPart2.from(part);
    } else if (part instanceof ChatResponseAnchorPart) {
      return ChatResponseAnchorPart2.from(part);
    } else if (part instanceof ChatResponseReferencePart) {
      return ChatResponseReferencePart2.from(part);
    } else if (part instanceof ChatResponseProgressPart) {
      return ChatResponseProgressPart3.from(part);
    } else if (part instanceof ChatResponseThinkingProgressPart) {
      return ChatResponseThinkingProgressPart2.from(part);
    } else if (part instanceof ChatResponseFileTreePart) {
      return ChatResponseFilesPart.from(part);
    } else if (part instanceof ChatResponseMultiDiffPart) {
      return ChatResponseMultiDiffPart2.from(part);
    } else if (part instanceof ChatResponseCommandButtonPart) {
      return ChatResponseCommandButtonPart2.from(part, commandsConverter, commandDisposables);
    } else if (part instanceof ChatResponseTextEditPart) {
      return ChatResponseTextEditPart2.from(part);
    } else if (part instanceof ChatResponseNotebookEditPart) {
      return ChatResponseNotebookEditPart2.from(part);
    } else if (part instanceof ChatResponseMarkdownWithVulnerabilitiesPart) {
      return ChatResponseMarkdownWithVulnerabilitiesPart2.from(part);
    } else if (part instanceof ChatResponseCodeblockUriPart) {
      return ChatResponseCodeblockUriPart2.from(part);
    } else if (part instanceof ChatResponseWarningPart) {
      return ChatResponseWarningPart2.from(part);
    } else if (part instanceof ChatResponseConfirmationPart) {
      return ChatResponseConfirmationPart2.from(part);
    } else if (part instanceof ChatResponseCodeCitationPart) {
      return ChatResponseCodeCitationPart2.from(part);
    } else if (part instanceof ChatResponseMovePart) {
      return ChatResponseMovePart2.from(part);
    } else if (part instanceof ChatResponseExtensionsPart) {
      return ChatResponseExtensionsPart2.from(part);
    } else if (part instanceof ChatPrepareToolInvocationPart) {
      return ChatPrepareToolInvocationPart2.from(part);
    } else if (part instanceof ChatResponsePullRequestPart) {
      return ChatResponsePullRequestPart2.from(part);
    } else if (part instanceof ChatToolInvocationPart) {
      return ChatToolInvocationPart2.from(part);
    }
    return {
      kind: "markdownContent",
      content: MarkdownString4.from("")
    };
  }
  ChatResponsePart2.from = from;
  function to(part, commandsConverter) {
    switch (part.kind) {
      case "reference":
        return ChatResponseReferencePart2.to(part);
      case "markdownContent":
      case "inlineReference":
      case "progressMessage":
      case "treeData":
      case "command":
        return toContent(part, commandsConverter);
    }
    return void 0;
  }
  ChatResponsePart2.to = to;
  function toContent(part, commandsConverter) {
    switch (part.kind) {
      case "markdownContent":
        return ChatResponseMarkdownPart2.to(part);
      case "inlineReference":
        return ChatResponseAnchorPart2.to(part);
      case "progressMessage":
        return void 0;
      case "treeData":
        return ChatResponseFilesPart.to(part);
      case "command":
        return ChatResponseCommandButtonPart2.to(part, commandsConverter);
    }
    return void 0;
  }
  ChatResponsePart2.toContent = toContent;
})(ChatResponsePart || (ChatResponsePart = {}));
var ChatAgentRequest;
(function(ChatAgentRequest2) {
  function to(request, location2, model, diagnostics, tools, extension, logService) {
    const toolReferences = [];
    const variableReferences = [];
    for (const v of request.variables.variables) {
      if (v.kind === "tool") {
        toolReferences.push(v);
      } else if (v.kind === "toolset") {
        toolReferences.push(...v.value);
      } else {
        variableReferences.push(v);
      }
    }
    const requestWithAllProps = {
      id: request.requestId,
      prompt: request.message,
      command: request.command,
      attempt: request.attempt ?? 0,
      enableCommandDetection: request.enableCommandDetection ?? true,
      isParticipantDetected: request.isParticipantDetected ?? false,
      sessionId: request.sessionId,
      references: variableReferences.map((v) => ChatPromptReference.to(v, diagnostics, logService)).filter(isDefined),
      toolReferences: toolReferences.map(ChatLanguageModelToolReference.to),
      location: ChatLocation2.to(request.location),
      acceptedConfirmationData: request.acceptedConfirmationData,
      rejectedConfirmationData: request.rejectedConfirmationData,
      location2,
      toolInvocationToken: Object.freeze({ sessionId: request.sessionId, sessionResource: request.sessionResource }),
      tools,
      model,
      editedFileEvents: request.editedFileEvents,
      modeInstructions: request.modeInstructions?.content,
      modeInstructions2: ChatRequestModeInstructions.to(request.modeInstructions),
      isSubagent: request.isSubagent
    };
    if (!isProposedApiEnabled(extension, "chatParticipantPrivate")) {
      delete requestWithAllProps.id;
      delete requestWithAllProps.attempt;
      delete requestWithAllProps.enableCommandDetection;
      delete requestWithAllProps.isParticipantDetected;
      delete requestWithAllProps.location;
      delete requestWithAllProps.location2;
      delete requestWithAllProps.editedFileEvents;
      delete requestWithAllProps.sessionId;
      delete requestWithAllProps.isSubagent;
    }
    if (!isProposedApiEnabled(extension, "chatParticipantAdditions")) {
      delete requestWithAllProps.acceptedConfirmationData;
      delete requestWithAllProps.rejectedConfirmationData;
      delete requestWithAllProps.tools;
    }
    return requestWithAllProps;
  }
  ChatAgentRequest2.to = to;
})(ChatAgentRequest || (ChatAgentRequest = {}));
var ChatRequestDraft;
(function(ChatRequestDraft2) {
  function to(request) {
    return {
      prompt: request.prompt,
      files: request.files.map((uri) => URI.revive(uri))
    };
  }
  ChatRequestDraft2.to = to;
})(ChatRequestDraft || (ChatRequestDraft = {}));
var ChatLocation2;
(function(ChatLocation3) {
  function to(loc) {
    switch (loc) {
      case ChatAgentLocation.Notebook:
        return ChatLocation.Notebook;
      case ChatAgentLocation.Terminal:
        return ChatLocation.Terminal;
      case ChatAgentLocation.Chat:
        return ChatLocation.Panel;
      case ChatAgentLocation.EditorInline:
        return ChatLocation.Editor;
    }
  }
  ChatLocation3.to = to;
  function from(loc) {
    switch (loc) {
      case ChatLocation.Notebook:
        return ChatAgentLocation.Notebook;
      case ChatLocation.Terminal:
        return ChatAgentLocation.Terminal;
      case ChatLocation.Panel:
        return ChatAgentLocation.Chat;
      case ChatLocation.Editor:
        return ChatAgentLocation.EditorInline;
    }
  }
  ChatLocation3.from = from;
})(ChatLocation2 || (ChatLocation2 = {}));
var ChatPromptReference;
(function(ChatPromptReference2) {
  function to(variable, diagnostics, logService) {
    let value = variable.value;
    if (!value) {
      let varStr;
      try {
        varStr = JSON.stringify(variable);
      } catch {
        varStr = `kind=${variable.kind}, id=${variable.id}, name=${variable.name}`;
      }
      logService.error(`[ChatPromptReference] Ignoring invalid reference in variable: ${varStr}`);
      return void 0;
    }
    if (isUriComponents(value)) {
      value = URI.revive(value);
    } else if (value && typeof value === "object" && "uri" in value && "range" in value && isUriComponents(value.uri)) {
      value = Location3.to(revive(value));
    } else if (isImageVariableEntry(variable)) {
      const ref = variable.references?.[0]?.reference;
      value = new ChatReferenceBinaryData(variable.mimeType ?? "image/png", () => Promise.resolve(new Uint8Array(Object.values(variable.value))), ref && URI.isUri(ref) ? ref : void 0);
    } else if (variable.kind === "diagnostic") {
      const filterSeverity = variable.filterSeverity && DiagnosticSeverity2.to(variable.filterSeverity);
      const filterUri = variable.filterUri && URI.revive(variable.filterUri).toString();
      value = new ChatReferenceDiagnostic(diagnostics.map(([uri, d]) => {
        if (variable.filterUri && uri.toString() !== filterUri) {
          return [uri, []];
        }
        return [uri, d.filter((d2) => {
          if (filterSeverity && d2.severity > filterSeverity) {
            return false;
          }
          if (variable.filterRange && !Range.areIntersectingOrTouching(variable.filterRange, Range4.from(d2.range))) {
            return false;
          }
          return true;
        })];
      }).filter(([, d]) => d.length > 0));
    }
    let toolReferences;
    if (isPromptFileVariableEntry(variable) || isPromptTextVariableEntry(variable)) {
      if (variable.toolReferences) {
        toolReferences = ChatLanguageModelToolReferences.to(variable.toolReferences);
      }
    }
    return {
      id: variable.id,
      name: variable.name,
      range: variable.range && [variable.range.start, variable.range.endExclusive],
      toolReferences,
      value,
      modelDescription: variable.modelDescription
    };
  }
  ChatPromptReference2.to = to;
})(ChatPromptReference || (ChatPromptReference = {}));
var ChatLanguageModelToolReference;
(function(ChatLanguageModelToolReference2) {
  function to(variable) {
    const value = variable.value;
    if (value) {
      throw new Error("Invalid tool reference");
    }
    return {
      name: variable.id,
      range: variable.range && [variable.range.start, variable.range.endExclusive]
    };
  }
  ChatLanguageModelToolReference2.to = to;
})(ChatLanguageModelToolReference || (ChatLanguageModelToolReference = {}));
var ChatLanguageModelToolReferences;
(function(ChatLanguageModelToolReferences2) {
  function to(variables) {
    const toolReferences = [];
    for (const v of variables) {
      if (v.kind === "tool") {
        toolReferences.push(ChatLanguageModelToolReference.to(v));
      } else if (v.kind === "toolset") {
        toolReferences.push(...v.value.map(ChatLanguageModelToolReference.to));
      } else {
        throw new Error("Invalid tool reference in prompt variables");
      }
    }
    return toolReferences;
  }
  ChatLanguageModelToolReferences2.to = to;
})(ChatLanguageModelToolReferences || (ChatLanguageModelToolReferences = {}));
var ChatRequestModeInstructions;
(function(ChatRequestModeInstructions2) {
  function to(mode) {
    if (mode) {
      return {
        name: mode.name,
        content: mode.content,
        toolReferences: ChatLanguageModelToolReferences.to(mode.toolReferences),
        metadata: mode.metadata
      };
    }
    return void 0;
  }
  ChatRequestModeInstructions2.to = to;
})(ChatRequestModeInstructions || (ChatRequestModeInstructions = {}));
var ChatAgentCompletionItem;
(function(ChatAgentCompletionItem2) {
  function from(item, commandsConverter, disposables) {
    return {
      id: item.id,
      label: item.label,
      fullName: item.fullName,
      icon: item.icon?.id,
      value: item.values[0].value,
      insertText: item.insertText,
      detail: item.detail,
      documentation: item.documentation,
      command: commandsConverter.toInternal(item.command, disposables)
    };
  }
  ChatAgentCompletionItem2.from = from;
})(ChatAgentCompletionItem || (ChatAgentCompletionItem = {}));
var ChatAgentResult;
(function(ChatAgentResult2) {
  function to(result) {
    return {
      errorDetails: result.errorDetails,
      metadata: reviveMetadata(result.metadata),
      nextQuestion: result.nextQuestion,
      details: result.details
    };
  }
  ChatAgentResult2.to = to;
  function from(result) {
    return {
      errorDetails: result.errorDetails,
      metadata: result.metadata,
      nextQuestion: result.nextQuestion,
      details: result.details
    };
  }
  ChatAgentResult2.from = from;
  function reviveMetadata(metadata) {
    return cloneAndChange(metadata, (value) => {
      if (value.$mid === 20) {
        return new LanguageModelToolResult(cloneAndChange(value.content, reviveMetadata));
      } else if (value.$mid === 21) {
        return new LanguageModelTextPart(value.value);
      } else if (value.$mid === 22) {
        return new LanguageModelThinkingPart(value.value, value.id, value.metadata);
      } else if (value.$mid === 23) {
        return new LanguageModelPromptTsxPart(value.value);
      }
      return void 0;
    });
  }
})(ChatAgentResult || (ChatAgentResult = {}));
var ChatAgentUserActionEvent;
(function(ChatAgentUserActionEvent2) {
  function to(result, event, commandsConverter) {
    if (event.action.kind === "vote") {
      return;
    }
    const ehResult = ChatAgentResult.to(result);
    if (event.action.kind === "command") {
      const command = event.action.commandButton.command;
      const commandButton = {
        command: commandsConverter.fromInternal(command) ?? { command: command.id, title: command.title }
      };
      const commandAction = { kind: "command", commandButton };
      return { action: commandAction, result: ehResult };
    } else if (event.action.kind === "followUp") {
      const followupAction = { kind: "followUp", followup: ChatFollowup.to(event.action.followup) };
      return { action: followupAction, result: ehResult };
    } else if (event.action.kind === "inlineChat") {
      return { action: { kind: "editor", accepted: event.action.action === "accepted" }, result: ehResult };
    } else if (event.action.kind === "chatEditingSessionAction") {
      const outcomes = /* @__PURE__ */ new Map([
        ["accepted", ChatEditingSessionActionOutcome.Accepted],
        ["rejected", ChatEditingSessionActionOutcome.Rejected],
        ["saved", ChatEditingSessionActionOutcome.Saved]
      ]);
      return {
        action: {
          kind: "chatEditingSessionAction",
          outcome: outcomes.get(event.action.outcome) ?? ChatEditingSessionActionOutcome.Rejected,
          uri: URI.revive(event.action.uri),
          hasRemainingEdits: event.action.hasRemainingEdits
        },
        result: ehResult
      };
    } else if (event.action.kind === "chatEditingHunkAction") {
      const outcomes = /* @__PURE__ */ new Map([
        ["accepted", ChatEditingSessionActionOutcome.Accepted],
        ["rejected", ChatEditingSessionActionOutcome.Rejected]
      ]);
      return {
        action: {
          kind: "chatEditingHunkAction",
          outcome: outcomes.get(event.action.outcome) ?? ChatEditingSessionActionOutcome.Rejected,
          uri: URI.revive(event.action.uri),
          hasRemainingEdits: event.action.hasRemainingEdits,
          lineCount: event.action.lineCount,
          linesAdded: event.action.linesAdded,
          linesRemoved: event.action.linesRemoved
        },
        result: ehResult
      };
    } else {
      return { action: event.action, result: ehResult };
    }
  }
  ChatAgentUserActionEvent2.to = to;
})(ChatAgentUserActionEvent || (ChatAgentUserActionEvent = {}));
var TerminalQuickFix;
(function(TerminalQuickFix2) {
  function from(quickFix, converter, disposables) {
    if ("terminalCommand" in quickFix) {
      return { terminalCommand: quickFix.terminalCommand, shouldExecute: quickFix.shouldExecute };
    }
    if ("uri" in quickFix) {
      return { uri: quickFix.uri };
    }
    return converter.toInternal(quickFix, disposables);
  }
  TerminalQuickFix2.from = from;
})(TerminalQuickFix || (TerminalQuickFix = {}));
var TerminalCompletionItemDto;
(function(TerminalCompletionItemDto2) {
  function from(item) {
    return {
      ...item,
      documentation: MarkdownString4.fromStrict(item.documentation)
    };
  }
  TerminalCompletionItemDto2.from = from;
})(TerminalCompletionItemDto || (TerminalCompletionItemDto = {}));
var TerminalCompletionList2;
(function(TerminalCompletionList3) {
  function from(completions, pathSeparator) {
    if (Array.isArray(completions)) {
      return {
        items: completions.map((i) => TerminalCompletionItemDto.from(i))
      };
    }
    return {
      items: completions.items.map((i) => TerminalCompletionItemDto.from(i)),
      resourceOptions: completions.resourceOptions ? TerminalCompletionResourceOptions.from(completions.resourceOptions, pathSeparator) : void 0
    };
  }
  TerminalCompletionList3.from = from;
})(TerminalCompletionList2 || (TerminalCompletionList2 = {}));
var TerminalCompletionResourceOptions;
(function(TerminalCompletionResourceOptions2) {
  function from(resourceOptions, pathSeparator) {
    return {
      ...resourceOptions,
      pathSeparator,
      cwd: resourceOptions.cwd,
      globPattern: GlobPattern.from(resourceOptions.globPattern) ?? void 0
    };
  }
  TerminalCompletionResourceOptions2.from = from;
})(TerminalCompletionResourceOptions || (TerminalCompletionResourceOptions = {}));
var PartialAcceptInfo;
(function(PartialAcceptInfo2) {
  function to(info) {
    return {
      kind: PartialAcceptTriggerKind3.to(info.kind),
      acceptedLength: info.acceptedLength
    };
  }
  PartialAcceptInfo2.to = to;
})(PartialAcceptInfo || (PartialAcceptInfo = {}));
var PartialAcceptTriggerKind3;
(function(PartialAcceptTriggerKind4) {
  function to(kind) {
    switch (kind) {
      case 0:
        return PartialAcceptTriggerKind2.Word;
      case 1:
        return PartialAcceptTriggerKind2.Line;
      case 2:
        return PartialAcceptTriggerKind2.Suggest;
      default:
        return PartialAcceptTriggerKind2.Unknown;
    }
  }
  PartialAcceptTriggerKind4.to = to;
})(PartialAcceptTriggerKind3 || (PartialAcceptTriggerKind3 = {}));
var InlineCompletionEndOfLifeReason;
(function(InlineCompletionEndOfLifeReason2) {
  function to(reason, convertFn) {
    if (reason.kind === InlineCompletionEndOfLifeReasonKind.Ignored) {
      const supersededBy = reason.supersededBy ? convertFn(reason.supersededBy) : void 0;
      return {
        kind: InlineCompletionEndOfLifeReasonKind2.Ignored,
        supersededBy,
        userTypingDisagreed: reason.userTypingDisagreed
      };
    } else if (reason.kind === InlineCompletionEndOfLifeReasonKind.Accepted) {
      return {
        kind: InlineCompletionEndOfLifeReasonKind2.Accepted
      };
    }
    return {
      kind: InlineCompletionEndOfLifeReasonKind2.Rejected
    };
  }
  InlineCompletionEndOfLifeReason2.to = to;
})(InlineCompletionEndOfLifeReason || (InlineCompletionEndOfLifeReason = {}));
var InlineCompletionHintStyle2;
(function(InlineCompletionHintStyle3) {
  function from(value) {
    if (value === InlineCompletionDisplayLocationKind.Label) {
      return InlineCompletionHintStyle.Label;
    } else {
      return InlineCompletionHintStyle.Code;
    }
  }
  InlineCompletionHintStyle3.from = from;
  function to(kind) {
    switch (kind) {
      case InlineCompletionHintStyle.Label:
        return InlineCompletionDisplayLocationKind.Label;
      default:
        return InlineCompletionDisplayLocationKind.Code;
    }
  }
  InlineCompletionHintStyle3.to = to;
})(InlineCompletionHintStyle2 || (InlineCompletionHintStyle2 = {}));
var DebugTreeItem;
(function(DebugTreeItem2) {
  function from(item, id2) {
    return {
      id: id2,
      label: item.label,
      description: item.description,
      canEdit: item.canEdit,
      collapsibleState: item.collapsibleState || 0,
      contextValue: item.contextValue
    };
  }
  DebugTreeItem2.from = from;
})(DebugTreeItem || (DebugTreeItem = {}));
var LanguageModelToolSource;
(function(LanguageModelToolSource2) {
  function to(source) {
    if (source.type === "mcp") {
      return new LanguageModelToolMCPSource(source.label, source.serverLabel || source.label, source.instructions);
    } else if (source.type === "extension") {
      return new LanguageModelToolExtensionSource(source.extensionId.value, source.label);
    } else {
      return void 0;
    }
  }
  LanguageModelToolSource2.to = to;
})(LanguageModelToolSource || (LanguageModelToolSource = {}));
var LanguageModelToolResult3;
(function(LanguageModelToolResult4) {
  function to(result) {
    return new LanguageModelToolResult(result.content.map((item) => {
      if (item.kind === "text") {
        return new LanguageModelTextPart(item.value, item.audience);
      } else if (item.kind === "data") {
        return new LanguageModelDataPart(item.value.data.buffer, item.value.mimeType, item.audience);
      } else {
        return new LanguageModelPromptTsxPart(item.value);
      }
    }));
  }
  LanguageModelToolResult4.to = to;
  function from(result, extension) {
    if (result.toolResultMessage) {
      checkProposedApiEnabled(extension, "chatParticipantPrivate");
    }
    const checkAudienceApi = (item) => {
      if (item.audience) {
        checkProposedApiEnabled(extension, "languageModelToolResultAudience");
      }
    };
    let hasBuffers = false;
    const dto = {
      content: result.content.map((item) => {
        if (item instanceof LanguageModelTextPart) {
          checkAudienceApi(item);
          return {
            kind: "text",
            value: item.value,
            audience: item.audience
          };
        } else if (item instanceof LanguageModelPromptTsxPart) {
          return {
            kind: "promptTsx",
            value: item.value
          };
        } else if (item instanceof LanguageModelDataPart) {
          checkAudienceApi(item);
          hasBuffers = true;
          return {
            kind: "data",
            value: {
              mimeType: item.mimeType,
              data: VSBuffer.wrap(item.data)
            },
            audience: item.audience
          };
        } else {
          throw new Error("Unknown LanguageModelToolResult part type");
        }
      }),
      toolResultMessage: MarkdownString4.fromStrict(result.toolResultMessage),
      toolResultDetails: result.toolResultDetails?.map((detail) => URI.isUri(detail) ? detail : Location3.from(detail))
    };
    return hasBuffers ? new SerializableObjectWithBuffers(dto) : dto;
  }
  LanguageModelToolResult4.from = from;
})(LanguageModelToolResult3 || (LanguageModelToolResult3 = {}));
var LanguageModelToolResult22;
(function(LanguageModelToolResult23) {
  function to(result) {
    const toolResult = new LanguageModelToolResult2(result.content.map((item) => {
      if (item.kind === "text") {
        return new LanguageModelTextPart(item.value, item.audience);
      } else if (item.kind === "data") {
        return new LanguageModelDataPart(item.value.data.buffer, item.value.mimeType, item.audience);
      } else {
        return new LanguageModelPromptTsxPart(item.value);
      }
    }));
    if (result.toolMetadata) {
      toolResult.toolMetadata = result.toolMetadata;
    }
    return toolResult;
  }
  LanguageModelToolResult23.to = to;
  function from(result, extension) {
    if (result.toolResultMessage) {
      checkProposedApiEnabled(extension, "chatParticipantPrivate");
    }
    const checkAudienceApi = (item) => {
      if (item.audience) {
        checkProposedApiEnabled(extension, "languageModelToolResultAudience");
      }
    };
    let hasBuffers = false;
    let detailsDto = void 0;
    if (Array.isArray(result.toolResultDetails)) {
      detailsDto = result.toolResultDetails?.map((detail) => {
        return URI.isUri(detail) ? detail : Location3.from(detail);
      });
    } else {
      if (result.toolResultDetails2) {
        detailsDto = {
          output: {
            type: "data",
            mimeType: result.toolResultDetails2.mime,
            value: VSBuffer.wrap(result.toolResultDetails2.value)
          }
        };
        hasBuffers = true;
      }
    }
    const dto = {
      content: result.content.map((item) => {
        if (item instanceof LanguageModelTextPart) {
          checkAudienceApi(item);
          return {
            kind: "text",
            value: item.value,
            audience: item.audience
          };
        } else if (item instanceof LanguageModelPromptTsxPart) {
          return {
            kind: "promptTsx",
            value: item.value
          };
        } else if (item instanceof LanguageModelDataPart) {
          checkAudienceApi(item);
          hasBuffers = true;
          return {
            kind: "data",
            value: {
              mimeType: item.mimeType,
              data: VSBuffer.wrap(item.data)
            },
            audience: item.audience
          };
        } else {
          throw new Error("Unknown LanguageModelToolResult part type");
        }
      }),
      toolResultMessage: MarkdownString4.fromStrict(result.toolResultMessage),
      toolResultDetails: detailsDto,
      toolMetadata: result.toolMetadata
    };
    return hasBuffers ? new SerializableObjectWithBuffers(dto) : dto;
  }
  LanguageModelToolResult23.from = from;
})(LanguageModelToolResult22 || (LanguageModelToolResult22 = {}));
var IconPath;
(function(IconPath2) {
  function fromThemeIcon(iconPath) {
    return iconPath;
  }
  IconPath2.fromThemeIcon = fromThemeIcon;
  function from(value) {
    if (!value) {
      return void 0;
    } else if (ThemeIcon.isThemeIcon(value)) {
      return value;
    } else if (URI.isUri(value)) {
      return value;
    } else if (typeof value === "string") {
      return URI.file(value);
    } else if (typeof value === "object" && value !== null && "dark" in value) {
      const dark = typeof value.dark === "string" ? URI.file(value.dark) : value.dark;
      const light = typeof value.light === "string" ? URI.file(value.light) : value.light;
      return !dark ? void 0 : { dark, light: light ?? dark };
    } else {
      return void 0;
    }
  }
  IconPath2.from = from;
  function to(value) {
    if (!value) {
      return void 0;
    } else if (ThemeIcon.isThemeIcon(value)) {
      return value;
    } else if (isUriComponents(value)) {
      return URI.revive(value);
    } else {
      const icon = value;
      return {
        light: URI.revive(icon.light),
        dark: URI.revive(icon.dark)
      };
    }
  }
  IconPath2.to = to;
})(IconPath || (IconPath = {}));
var AiSettingsSearch;
(function(AiSettingsSearch2) {
  function fromSettingsSearchResult(result) {
    return {
      query: result.query,
      kind: fromSettingsSearchResultKind(result.kind),
      settings: result.settings
    };
  }
  AiSettingsSearch2.fromSettingsSearchResult = fromSettingsSearchResult;
  function fromSettingsSearchResultKind(kind) {
    switch (kind) {
      case AiSettingsSearchResultKind.EMBEDDED:
        return AiSettingsSearchResultKind.EMBEDDED;
      case AiSettingsSearchResultKind.LLM_RANKED:
        return AiSettingsSearchResultKind.LLM_RANKED;
      case AiSettingsSearchResultKind.CANCELED:
        return AiSettingsSearchResultKind.CANCELED;
      default:
        throw new Error("Unknown AiSettingsSearchResultKind");
    }
  }
})(AiSettingsSearch || (AiSettingsSearch = {}));
var McpServerDefinition2;
(function(McpServerDefinition3) {
  function isHttpConfig(candidate) {
    return !!candidate.uri;
  }
  function from(item) {
    return McpServerLaunch.toSerialized(isHttpConfig(item) ? {
      type: 2,
      uri: item.uri,
      headers: Object.entries(item.headers),
      authentication: item.authentication ? {
        providerId: item.authentication.providerId,
        scopes: item.authentication.scopes
      } : void 0
    } : {
      type: 1,
      cwd: item.cwd?.fsPath,
      args: item.args,
      command: item.command,
      env: item.env,
      envFile: void 0
    });
  }
  McpServerDefinition3.from = from;
})(McpServerDefinition2 || (McpServerDefinition2 = {}));
var SourceControlInputBoxValidationType2;
(function(SourceControlInputBoxValidationType3) {
  function from(type) {
    switch (type) {
      case SourceControlInputBoxValidationType.Error:
        return 0;
      case SourceControlInputBoxValidationType.Warning:
        return 1;
      case SourceControlInputBoxValidationType.Information:
        return 2;
      default:
        throw new Error("Unknown SourceControlInputBoxValidationType");
    }
  }
  SourceControlInputBoxValidationType3.from = from;
})(SourceControlInputBoxValidationType2 || (SourceControlInputBoxValidationType2 = {}));

// out-build/vs/workbench/services/search/common/searchExtTypes.js
var TextSearchMatch2 = class {
  /**
   * @param uri The uri for the matching document.
   * @param ranges The ranges associated with this match.
   * @param previewText The text that is used to preview the match. The highlighted range in `previewText` is specified in `ranges`.
   */
  constructor(uri, ranges, previewText) {
    this.uri = uri;
    this.ranges = ranges;
    this.previewText = previewText;
  }
};
var TextSearchContext2 = class {
  /**
   * @param uri The uri for the matching document.
   * @param text The line of context text.
   * @param lineNumber The line number of this line of context.
   */
  constructor(uri, text, lineNumber) {
    this.uri = uri;
    this.text = text;
    this.lineNumber = lineNumber;
  }
};
var AISearchKeyword = class {
  /**
   * @param keyword The keyword associated with the search.
   */
  constructor(keyword) {
    this.keyword = keyword;
  }
};
var ExcludeSettingOptions;
(function(ExcludeSettingOptions2) {
  ExcludeSettingOptions2[ExcludeSettingOptions2["None"] = 1] = "None";
  ExcludeSettingOptions2[ExcludeSettingOptions2["FilesExclude"] = 2] = "FilesExclude";
  ExcludeSettingOptions2[ExcludeSettingOptions2["SearchAndFilesExclude"] = 3] = "SearchAndFilesExclude";
})(ExcludeSettingOptions || (ExcludeSettingOptions = {}));
var TextSearchCompleteMessageType;
(function(TextSearchCompleteMessageType2) {
  TextSearchCompleteMessageType2[TextSearchCompleteMessageType2["Information"] = 1] = "Information";
  TextSearchCompleteMessageType2[TextSearchCompleteMessageType2["Warning"] = 2] = "Warning";
})(TextSearchCompleteMessageType || (TextSearchCompleteMessageType = {}));

// out-build/vs/workbench/services/search/common/search.js
var DEFAULT_MAX_SEARCH_RESULTS = 2e4;
var SEARCH_ELIDED_PREFIX = "\u27EA ";
var SEARCH_ELIDED_SUFFIX = " characters skipped \u27EB";
var SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;
var ISearchService = createDecorator("searchService");
var SearchProviderType;
(function(SearchProviderType2) {
  SearchProviderType2[SearchProviderType2["file"] = 0] = "file";
  SearchProviderType2[SearchProviderType2["text"] = 1] = "text";
  SearchProviderType2[SearchProviderType2["aiText"] = 2] = "aiText";
})(SearchProviderType || (SearchProviderType = {}));
var QueryType;
(function(QueryType2) {
  QueryType2[QueryType2["File"] = 1] = "File";
  QueryType2[QueryType2["Text"] = 2] = "Text";
  QueryType2[QueryType2["aiText"] = 3] = "aiText";
})(QueryType || (QueryType = {}));
function resultIsMatch(result) {
  return !!result.rangeLocations && !!result.previewText;
}
var SearchCompletionExitCode;
(function(SearchCompletionExitCode2) {
  SearchCompletionExitCode2[SearchCompletionExitCode2["Normal"] = 0] = "Normal";
  SearchCompletionExitCode2[SearchCompletionExitCode2["NewSearchStarted"] = 1] = "NewSearchStarted";
})(SearchCompletionExitCode || (SearchCompletionExitCode = {}));
var TextSearchMatch = class {
  constructor(text, ranges, previewOptions, webviewIndex) {
    this.rangeLocations = [];
    this.webviewIndex = webviewIndex;
    const rangesArr = Array.isArray(ranges) ? ranges : [ranges];
    if (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(rangesArr)) {
      text = getNLines(text, previewOptions.matchLines);
      let result = "";
      let shift = 0;
      let lastEnd = 0;
      const leadingChars = Math.floor(previewOptions.charsPerLine / 5);
      for (const range of rangesArr) {
        const previewStart = Math.max(range.startColumn - leadingChars, 0);
        const previewEnd = range.startColumn + previewOptions.charsPerLine;
        if (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {
          const elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;
          result += elision + text.slice(previewStart, previewEnd);
          shift += previewStart - (lastEnd + elision.length);
        } else {
          result += text.slice(lastEnd, previewEnd);
        }
        lastEnd = previewEnd;
        this.rangeLocations.push({
          source: range,
          preview: new OneLineRange(0, range.startColumn - shift, range.endColumn - shift)
        });
      }
      this.previewText = result;
    } else {
      const firstMatchLine = Array.isArray(ranges) ? ranges[0].startLineNumber : ranges.startLineNumber;
      const rangeLocs = mapArrayOrNot(ranges, (r) => ({
        preview: new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn),
        source: r
      }));
      this.rangeLocations = Array.isArray(rangeLocs) ? rangeLocs : [rangeLocs];
      this.previewText = text;
    }
  }
};
function isSingleLineRangeList(ranges) {
  const line = ranges[0].startLineNumber;
  for (const r of ranges) {
    if (r.startLineNumber !== line || r.endLineNumber !== line) {
      return false;
    }
  }
  return true;
}
var SearchRange = class {
  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
    this.startLineNumber = startLineNumber;
    this.startColumn = startColumn;
    this.endLineNumber = endLineNumber;
    this.endColumn = endColumn;
  }
};
var OneLineRange = class extends SearchRange {
  constructor(lineNumber, startColumn, endColumn) {
    super(lineNumber, startColumn, lineNumber, endColumn);
  }
};
var ViewMode;
(function(ViewMode2) {
  ViewMode2["List"] = "list";
  ViewMode2["Tree"] = "tree";
})(ViewMode || (ViewMode = {}));
var SearchSortOrder;
(function(SearchSortOrder2) {
  SearchSortOrder2["Default"] = "default";
  SearchSortOrder2["FileNames"] = "fileNames";
  SearchSortOrder2["Type"] = "type";
  SearchSortOrder2["Modified"] = "modified";
  SearchSortOrder2["CountDescending"] = "countDescending";
  SearchSortOrder2["CountAscending"] = "countAscending";
})(SearchSortOrder || (SearchSortOrder = {}));
var SemanticSearchBehavior;
(function(SemanticSearchBehavior2) {
  SemanticSearchBehavior2["Auto"] = "auto";
  SemanticSearchBehavior2["Manual"] = "manual";
  SemanticSearchBehavior2["RunOnEmpty"] = "runOnEmpty";
})(SemanticSearchBehavior || (SemanticSearchBehavior = {}));
function getExcludes(configuration, includeSearchExcludes = true) {
  const fileExcludes = configuration && configuration.files && configuration.files.exclude;
  const searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;
  if (!fileExcludes && !searchExcludes) {
    return void 0;
  }
  if (!fileExcludes || !searchExcludes) {
    return fileExcludes || searchExcludes || void 0;
  }
  let allExcludes = /* @__PURE__ */ Object.create(null);
  allExcludes = mixin(allExcludes, deepClone(fileExcludes));
  allExcludes = mixin(allExcludes, deepClone(searchExcludes), true);
  return allExcludes;
}
function pathIncludedInQuery(queryProps, fsPath) {
  if (queryProps.excludePattern && match(queryProps.excludePattern, fsPath)) {
    return false;
  }
  if (queryProps.includePattern || queryProps.usingSearchPaths) {
    if (queryProps.includePattern && match(queryProps.includePattern, fsPath)) {
      return true;
    }
    if (queryProps.usingSearchPaths) {
      return !!queryProps.folderQueries && queryProps.folderQueries.some((fq) => {
        const searchPath = fq.folder.fsPath;
        if (isEqualOrParent(fsPath, searchPath)) {
          const relPath = relative(searchPath, fsPath);
          return !fq.includePattern || !!match(fq.includePattern, relPath);
        } else {
          return false;
        }
      });
    }
    return false;
  }
  return true;
}
var SearchErrorCode;
(function(SearchErrorCode2) {
  SearchErrorCode2[SearchErrorCode2["unknownEncoding"] = 1] = "unknownEncoding";
  SearchErrorCode2[SearchErrorCode2["regexParseError"] = 2] = "regexParseError";
  SearchErrorCode2[SearchErrorCode2["globParseError"] = 3] = "globParseError";
  SearchErrorCode2[SearchErrorCode2["invalidLiteral"] = 4] = "invalidLiteral";
  SearchErrorCode2[SearchErrorCode2["rgProcessError"] = 5] = "rgProcessError";
  SearchErrorCode2[SearchErrorCode2["other"] = 6] = "other";
  SearchErrorCode2[SearchErrorCode2["canceled"] = 7] = "canceled";
})(SearchErrorCode || (SearchErrorCode = {}));
function resolvePatternsForProvider(globalPattern, folderPattern) {
  const merged = {
    ...globalPattern || {},
    ...folderPattern || {}
  };
  return Object.keys(merged).filter((key) => {
    const value = merged[key];
    return typeof value === "boolean" && value;
  });
}
var QueryGlobTester = class {
  constructor(config, folderQuery) {
    this._parsedIncludeExpression = null;
    this._excludeExpression = folderQuery.excludePattern?.map((excludePattern) => {
      return {
        ...config.excludePattern || {},
        ...excludePattern.pattern || {}
      };
    }) ?? [];
    if (this._excludeExpression.length === 0) {
      this._excludeExpression = [config.excludePattern || {}];
    }
    this._parsedExcludeExpression = this._excludeExpression.map((e) => parse3(e));
    let includeExpression = config.includePattern;
    if (folderQuery.includePattern) {
      if (includeExpression) {
        includeExpression = {
          ...includeExpression,
          ...folderQuery.includePattern
        };
      } else {
        includeExpression = folderQuery.includePattern;
      }
    }
    if (includeExpression) {
      this._parsedIncludeExpression = parse3(includeExpression);
    }
  }
  _evalParsedExcludeExpression(testPath, basename3, hasSibling) {
    let result = null;
    for (const folderExclude of this._parsedExcludeExpression) {
      const evaluation = folderExclude(testPath, basename3, hasSibling);
      if (typeof evaluation === "string") {
        result = evaluation;
        break;
      }
    }
    return result;
  }
  matchesExcludesSync(testPath, basename3, hasSibling) {
    if (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename3, hasSibling)) {
      return true;
    }
    return false;
  }
  /**
   * Guaranteed sync - siblingsFn should not return a promise.
   */
  includedInQuerySync(testPath, basename3, hasSibling) {
    if (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename3, hasSibling)) {
      return false;
    }
    if (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename3, hasSibling)) {
      return false;
    }
    return true;
  }
  /**
   * Evaluating the exclude expression is only async if it includes sibling clauses. As an optimization, avoid doing anything with Promises
   * unless the expression is async.
   */
  includedInQuery(testPath, basename3, hasSibling) {
    const isIncluded = () => {
      return this._parsedIncludeExpression ? !!this._parsedIncludeExpression(testPath, basename3, hasSibling) : true;
    };
    return Promise.all(this._parsedExcludeExpression.map((e) => {
      const excluded = e(testPath, basename3, hasSibling);
      if (isThenable(excluded)) {
        return excluded.then((excluded2) => {
          if (excluded2) {
            return false;
          }
          return isIncluded();
        });
      }
      return isIncluded();
    })).then((e) => e.some((e2) => !!e2));
  }
  hasSiblingExcludeClauses() {
    return this._excludeExpression.reduce((prev, curr) => hasSiblingClauses(curr) || prev, false);
  }
};
function hasSiblingClauses(pattern) {
  for (const key in pattern) {
    if (typeof pattern[key] !== "boolean") {
      return true;
    }
  }
  return false;
}
function hasSiblingPromiseFn(siblingsFn) {
  if (!siblingsFn) {
    return void 0;
  }
  let siblings;
  return (name2) => {
    if (!siblings) {
      siblings = (siblingsFn() || Promise.resolve([])).then((list2) => list2 ? listToMap(list2) : {});
    }
    return siblings.then((map) => !!map[name2]);
  };
}
function hasSiblingFn(siblingsFn) {
  if (!siblingsFn) {
    return void 0;
  }
  let siblings;
  return (name2) => {
    if (!siblings) {
      const list2 = siblingsFn();
      siblings = list2 ? listToMap(list2) : {};
    }
    return !!siblings[name2];
  };
}
function listToMap(list2) {
  const map = {};
  for (const key of list2) {
    map[key] = true;
  }
  return map;
}
function excludeToGlobPattern(excludesForFolder) {
  return excludesForFolder.flatMap((exclude) => exclude.patterns.map((pattern) => {
    return exclude.baseUri ? {
      baseUri: exclude.baseUri,
      pattern
    } : pattern;
  }));
}
var DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS = {
  matchLines: 100,
  charsPerLine: 1e4
};

// out-build/vs/amdX.js
var canASAR = false;
var DefineCall = class {
  constructor(id2, dependencies, callback) {
    this.id = id2;
    this.dependencies = dependencies;
    this.callback = callback;
  }
};
var AMDModuleImporterState;
(function(AMDModuleImporterState2) {
  AMDModuleImporterState2[AMDModuleImporterState2["Uninitialized"] = 1] = "Uninitialized";
  AMDModuleImporterState2[AMDModuleImporterState2["InitializedInternal"] = 2] = "InitializedInternal";
  AMDModuleImporterState2[AMDModuleImporterState2["InitializedExternal"] = 3] = "InitializedExternal";
})(AMDModuleImporterState || (AMDModuleImporterState = {}));
var AMDModuleImporter = class _AMDModuleImporter {
  static {
    this.INSTANCE = new _AMDModuleImporter();
  }
  constructor() {
    this._isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
    this._isRenderer = typeof document === "object";
    this._defineCalls = [];
    this._state = AMDModuleImporterState.Uninitialized;
  }
  _initialize() {
    if (this._state === AMDModuleImporterState.Uninitialized) {
      if (globalThis.define) {
        this._state = AMDModuleImporterState.InitializedExternal;
        return;
      }
    } else {
      return;
    }
    this._state = AMDModuleImporterState.InitializedInternal;
    globalThis.define = (id2, dependencies, callback) => {
      if (typeof id2 !== "string") {
        callback = dependencies;
        dependencies = id2;
        id2 = null;
      }
      if (typeof dependencies !== "object" || !Array.isArray(dependencies)) {
        callback = dependencies;
        dependencies = null;
      }
      this._defineCalls.push(new DefineCall(id2, dependencies, callback));
    };
    globalThis.define.amd = true;
    if (this._isRenderer) {
      this._amdPolicy = globalThis._VSCODE_WEB_PACKAGE_TTP ?? window.trustedTypes?.createPolicy("amdLoader", {
        createScriptURL(value) {
          if (value.startsWith(window.location.origin)) {
            return value;
          }
          if (value.startsWith(`${Schemas.vscodeFileResource}://${VSCODE_AUTHORITY}`)) {
            return value;
          }
          throw new Error(`[trusted_script_src] Invalid script url: ${value}`);
        }
      });
    } else if (this._isWebWorker) {
      this._amdPolicy = globalThis._VSCODE_WEB_PACKAGE_TTP ?? globalThis.trustedTypes?.createPolicy("amdLoader", {
        createScriptURL(value) {
          return value;
        }
      });
    }
  }
  async load(scriptSrc) {
    this._initialize();
    if (this._state === AMDModuleImporterState.InitializedExternal) {
      return new Promise((resolve2) => {
        const tmpModuleId = generateUuid();
        globalThis.define(tmpModuleId, [scriptSrc], function(moduleResult) {
          resolve2(moduleResult);
        });
      });
    }
    const defineCall = await (this._isWebWorker ? this._workerLoadScript(scriptSrc) : this._isRenderer ? this._rendererLoadScript(scriptSrc) : this._nodeJSLoadScript(scriptSrc));
    if (!defineCall) {
      console.warn(`Did not receive a define call from script ${scriptSrc}`);
      return void 0;
    }
    const exports2 = {};
    const dependencyObjs = [];
    const dependencyModules = [];
    if (Array.isArray(defineCall.dependencies)) {
      for (const mod of defineCall.dependencies) {
        if (mod === "exports") {
          dependencyObjs.push(exports2);
        } else {
          dependencyModules.push(mod);
        }
      }
    }
    if (dependencyModules.length > 0) {
      throw new Error(`Cannot resolve dependencies for script ${scriptSrc}. The dependencies are: ${dependencyModules.join(", ")}`);
    }
    if (typeof defineCall.callback === "function") {
      return defineCall.callback(...dependencyObjs) ?? exports2;
    } else {
      return defineCall.callback;
    }
  }
  _rendererLoadScript(scriptSrc) {
    return new Promise((resolve2, reject) => {
      const scriptElement = document.createElement("script");
      scriptElement.setAttribute("async", "async");
      scriptElement.setAttribute("type", "text/javascript");
      const unbind = () => {
        scriptElement.removeEventListener("load", loadEventListener);
        scriptElement.removeEventListener("error", errorEventListener);
      };
      const loadEventListener = (e) => {
        unbind();
        resolve2(this._defineCalls.pop());
      };
      const errorEventListener = (e) => {
        unbind();
        reject(e);
      };
      scriptElement.addEventListener("load", loadEventListener);
      scriptElement.addEventListener("error", errorEventListener);
      if (this._amdPolicy) {
        scriptSrc = this._amdPolicy.createScriptURL(scriptSrc);
      }
      scriptElement.setAttribute("src", scriptSrc);
      window.document.getElementsByTagName("head")[0].appendChild(scriptElement);
    });
  }
  async _workerLoadScript(scriptSrc) {
    if (this._amdPolicy) {
      scriptSrc = this._amdPolicy.createScriptURL(scriptSrc);
    }
    await import(scriptSrc);
    return this._defineCalls.pop();
  }
  async _nodeJSLoadScript(scriptSrc) {
    try {
      const fs = (await import(`${"fs"}`)).default;
      const vm = (await import(`${"vm"}`)).default;
      const module2 = (await import(`${"module"}`)).default;
      const filePath = URI.parse(scriptSrc).fsPath;
      const content = fs.readFileSync(filePath).toString();
      const scriptSource = module2.wrap(content.replace(/^#!.*/, ""));
      const script = new vm.Script(scriptSource);
      const compileWrapper = script.runInThisContext();
      compileWrapper.apply();
      return this._defineCalls.pop();
    } catch (error) {
      throw error;
    }
  }
};
var cache = /* @__PURE__ */ new Map();
async function importAMDNodeModule(nodeModuleName, pathInsideNodeModule, isBuilt) {
  if (isBuilt === void 0) {
    const product2 = globalThis._VSCODE_PRODUCT_JSON;
    isBuilt = Boolean((product2 ?? globalThis.vscode?.context?.configuration()?.product)?.commit);
  }
  const nodeModulePath = pathInsideNodeModule ? `${nodeModuleName}/${pathInsideNodeModule}` : nodeModuleName;
  if (cache.has(nodeModulePath)) {
    return cache.get(nodeModulePath);
  }
  let scriptSrc;
  if (/^\w[\w\d+.-]*:\/\//.test(nodeModulePath)) {
    scriptSrc = nodeModulePath;
  } else {
    const useASAR = canASAR && isBuilt && !isWeb;
    const actualNodeModulesPath = useASAR ? nodeModulesAsarPath : nodeModulesPath;
    const resourcePath = `${actualNodeModulesPath}/${nodeModulePath}`;
    scriptSrc = FileAccess.asBrowserUri(resourcePath).toString(true);
  }
  const result = AMDModuleImporter.INSTANCE.load(scriptSrc);
  cache.set(nodeModulePath, result);
  return result;
}

// out-build/vs/workbench/services/textfile/common/encoding.js
var UTF8 = "utf8";
var UTF8_with_bom = "utf8bom";
var UTF16be = "utf16be";
var UTF16le = "utf16le";
var UTF16be_BOM = [254, 255];
var UTF16le_BOM = [255, 254];
var UTF8_BOM = [239, 187, 191];
var ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512;
var NO_ENCODING_GUESS_MIN_BYTES = 512;
var AUTO_ENCODING_GUESS_MIN_BYTES = 512 * 8;
var AUTO_ENCODING_GUESS_MAX_BYTES = 512 * 128;
var DecodeStreamErrorKind;
(function(DecodeStreamErrorKind2) {
  DecodeStreamErrorKind2[DecodeStreamErrorKind2["STREAM_IS_BINARY"] = 1] = "STREAM_IS_BINARY";
})(DecodeStreamErrorKind || (DecodeStreamErrorKind = {}));
var DecodeStreamError = class extends Error {
  constructor(message, decodeStreamErrorKind) {
    super(message);
    this.decodeStreamErrorKind = decodeStreamErrorKind;
  }
};
var DecoderStream = class _DecoderStream {
  /**
   * This stream will only load iconv-lite lazily if the encoding
   * is not UTF-8. This ensures that for most common cases we do
   * not pay the price of loading the module from disk.
   *
   * We still need to be careful when converting UTF-8 to a string
   * though because we read the file in chunks of Buffer and thus
   * need to decode it via TextDecoder helper that is available
   * in browser and node.js environments.
   */
  static async create(encoding) {
    let decoder = void 0;
    if (encoding !== UTF8) {
      const iconv = await importAMDNodeModule("@vscode/iconv-lite-umd", "lib/iconv-lite-umd.js");
      decoder = iconv.getDecoder(toNodeEncoding(encoding));
    } else {
      const utf8TextDecoder = new TextDecoder();
      decoder = {
        write(buffer) {
          return utf8TextDecoder.decode(buffer, {
            // Signal to TextDecoder that potentially more data is coming
            // and that we are calling `decode` in the end to consume any
            // remainders
            stream: true
          });
        },
        end() {
          return utf8TextDecoder.decode();
        }
      };
    }
    return new _DecoderStream(decoder);
  }
  constructor(iconvLiteDecoder) {
    this.iconvLiteDecoder = iconvLiteDecoder;
  }
  write(buffer) {
    return this.iconvLiteDecoder.write(buffer);
  }
  end() {
    return this.iconvLiteDecoder.end();
  }
};
function toDecodeStream(source, options2) {
  const minBytesRequiredForDetection = options2.minBytesRequiredForDetection ?? (options2.guessEncoding ? AUTO_ENCODING_GUESS_MIN_BYTES : NO_ENCODING_GUESS_MIN_BYTES);
  return new Promise((resolve2, reject) => {
    const target = newWriteableStream((strings) => strings.join(""));
    const bufferedChunks = [];
    let bytesBuffered = 0;
    let decoder = void 0;
    const cts = new CancellationTokenSource();
    const createDecoder = async () => {
      try {
        const detected = await detectEncodingFromBuffer({
          buffer: VSBuffer.concat(bufferedChunks),
          bytesRead: bytesBuffered
        }, options2.guessEncoding, options2.candidateGuessEncodings);
        if (detected.seemsBinary && options2.acceptTextOnly) {
          throw new DecodeStreamError(
            "Stream is binary but only text is accepted for decoding",
            1
            /* DecodeStreamErrorKind.STREAM_IS_BINARY */
          );
        }
        detected.encoding = await options2.overwriteEncoding(detected.encoding);
        decoder = await DecoderStream.create(detected.encoding);
        const decoded = decoder.write(VSBuffer.concat(bufferedChunks).buffer);
        target.write(decoded);
        bufferedChunks.length = 0;
        bytesBuffered = 0;
        resolve2({
          stream: target,
          detected
        });
      } catch (error) {
        cts.cancel();
        target.destroy();
        reject(error);
      }
    };
    listenStream(source, {
      onData: async (chunk) => {
        if (decoder) {
          target.write(decoder.write(chunk.buffer));
        } else {
          bufferedChunks.push(chunk);
          bytesBuffered += chunk.byteLength;
          if (bytesBuffered >= minBytesRequiredForDetection) {
            source.pause();
            await createDecoder();
            setTimeout(() => source.resume());
          }
        }
      },
      onError: (error) => target.error(error),
      // simply forward to target
      onEnd: async () => {
        if (!decoder) {
          await createDecoder();
        }
        target.end(decoder?.end());
      }
    }, cts.token);
  });
}
async function toEncodeReadable(readable, encoding, options2) {
  const iconv = await importAMDNodeModule("@vscode/iconv-lite-umd", "lib/iconv-lite-umd.js");
  const encoder = iconv.getEncoder(toNodeEncoding(encoding), options2);
  let bytesWritten = false;
  let done = false;
  return {
    read() {
      if (done) {
        return null;
      }
      const chunk = readable.read();
      if (typeof chunk !== "string") {
        done = true;
        if (!bytesWritten && options2?.addBOM) {
          switch (encoding) {
            case UTF8:
            case UTF8_with_bom:
              return VSBuffer.wrap(Uint8Array.from(UTF8_BOM));
            case UTF16be:
              return VSBuffer.wrap(Uint8Array.from(UTF16be_BOM));
            case UTF16le:
              return VSBuffer.wrap(Uint8Array.from(UTF16le_BOM));
          }
        }
        const leftovers = encoder.end();
        if (leftovers && leftovers.length > 0) {
          bytesWritten = true;
          return VSBuffer.wrap(leftovers);
        }
        return null;
      }
      bytesWritten = true;
      return VSBuffer.wrap(encoder.write(chunk));
    }
  };
}
function toNodeEncoding(enc) {
  if (enc === UTF8_with_bom || enc === null) {
    return UTF8;
  }
  return enc;
}
function detectEncodingByBOMFromBuffer(buffer, bytesRead) {
  if (!buffer || bytesRead < UTF16be_BOM.length) {
    return null;
  }
  const b0 = buffer.readUInt8(0);
  const b1 = buffer.readUInt8(1);
  if (b0 === UTF16be_BOM[0] && b1 === UTF16be_BOM[1]) {
    return UTF16be;
  }
  if (b0 === UTF16le_BOM[0] && b1 === UTF16le_BOM[1]) {
    return UTF16le;
  }
  if (bytesRead < UTF8_BOM.length) {
    return null;
  }
  const b2 = buffer.readUInt8(2);
  if (b0 === UTF8_BOM[0] && b1 === UTF8_BOM[1] && b2 === UTF8_BOM[2]) {
    return UTF8_with_bom;
  }
  return null;
}
var IGNORE_ENCODINGS = ["ascii", "utf-16", "utf-32"];
async function guessEncodingByBuffer(buffer, candidateGuessEncodings) {
  const jschardet = await importAMDNodeModule("jschardet", "dist/jschardet.min.js");
  const limitedBuffer = buffer.slice(0, AUTO_ENCODING_GUESS_MAX_BYTES);
  const binaryString = encodeLatin1(limitedBuffer.buffer);
  if (candidateGuessEncodings) {
    candidateGuessEncodings = coalesce(candidateGuessEncodings.map((e) => toJschardetEncoding(e)));
    if (candidateGuessEncodings.length === 0) {
      candidateGuessEncodings = void 0;
    }
  }
  let guessed;
  try {
    guessed = jschardet.detect(binaryString, candidateGuessEncodings ? { detectEncodings: candidateGuessEncodings } : void 0);
  } catch (error) {
    return null;
  }
  if (!guessed?.encoding) {
    return null;
  }
  const enc = guessed.encoding.toLowerCase();
  if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {
    return null;
  }
  return toIconvLiteEncoding(guessed.encoding);
}
var JSCHARDET_TO_ICONV_ENCODINGS = {
  "ibm866": "cp866",
  "big5": "cp950"
};
function normalizeEncoding(encodingName) {
  return encodingName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
}
function toIconvLiteEncoding(encodingName) {
  const normalizedEncodingName = normalizeEncoding(encodingName);
  const mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];
  return mapped || normalizedEncodingName;
}
function toJschardetEncoding(encodingName) {
  const normalizedEncodingName = normalizeEncoding(encodingName);
  const mapped = GUESSABLE_ENCODINGS[normalizedEncodingName];
  return mapped ? mapped.guessableName : void 0;
}
function encodeLatin1(buffer) {
  let result = "";
  for (let i = 0; i < buffer.length; i++) {
    result += String.fromCharCode(buffer[i]);
  }
  return result;
}
function detectEncodingFromBuffer({ buffer, bytesRead }, autoGuessEncoding, candidateGuessEncodings) {
  let encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);
  let seemsBinary = false;
  if (encoding !== UTF16be && encoding !== UTF16le && buffer) {
    let couldBeUTF16LE = true;
    let couldBeUTF16BE = true;
    let containsZeroByte = false;
    for (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {
      const isEndian = i % 2 === 1;
      const isZeroByte = buffer.readUInt8(i) === 0;
      if (isZeroByte) {
        containsZeroByte = true;
      }
      if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {
        couldBeUTF16LE = false;
      }
      if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {
        couldBeUTF16BE = false;
      }
      if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {
        break;
      }
    }
    if (containsZeroByte) {
      if (couldBeUTF16LE) {
        encoding = UTF16le;
      } else if (couldBeUTF16BE) {
        encoding = UTF16be;
      } else {
        seemsBinary = true;
      }
    }
  }
  if (autoGuessEncoding && !seemsBinary && !encoding && buffer) {
    return guessEncodingByBuffer(buffer.slice(0, bytesRead), candidateGuessEncodings).then((guessedEncoding) => {
      return {
        seemsBinary: false,
        encoding: guessedEncoding
      };
    });
  }
  return { seemsBinary, encoding };
}
var SUPPORTED_ENCODINGS = {
  utf8: {
    labelLong: "UTF-8",
    labelShort: "UTF-8",
    order: 1,
    alias: "utf8bom",
    guessableName: "UTF-8"
  },
  utf8bom: {
    labelLong: "UTF-8 with BOM",
    labelShort: "UTF-8 with BOM",
    encodeOnly: true,
    order: 2,
    alias: "utf8"
  },
  utf16le: {
    labelLong: "UTF-16 LE",
    labelShort: "UTF-16 LE",
    order: 3,
    guessableName: "UTF-16LE"
  },
  utf16be: {
    labelLong: "UTF-16 BE",
    labelShort: "UTF-16 BE",
    order: 4,
    guessableName: "UTF-16BE"
  },
  windows1252: {
    labelLong: "Western (Windows 1252)",
    labelShort: "Windows 1252",
    order: 5,
    guessableName: "windows-1252"
  },
  iso88591: {
    labelLong: "Western (ISO 8859-1)",
    labelShort: "ISO 8859-1",
    order: 6
  },
  iso88593: {
    labelLong: "Western (ISO 8859-3)",
    labelShort: "ISO 8859-3",
    order: 7
  },
  iso885915: {
    labelLong: "Western (ISO 8859-15)",
    labelShort: "ISO 8859-15",
    order: 8
  },
  macroman: {
    labelLong: "Western (Mac Roman)",
    labelShort: "Mac Roman",
    order: 9
  },
  cp437: {
    labelLong: "DOS (CP 437)",
    labelShort: "CP437",
    order: 10
  },
  windows1256: {
    labelLong: "Arabic (Windows 1256)",
    labelShort: "Windows 1256",
    order: 11
  },
  iso88596: {
    labelLong: "Arabic (ISO 8859-6)",
    labelShort: "ISO 8859-6",
    order: 12
  },
  windows1257: {
    labelLong: "Baltic (Windows 1257)",
    labelShort: "Windows 1257",
    order: 13
  },
  iso88594: {
    labelLong: "Baltic (ISO 8859-4)",
    labelShort: "ISO 8859-4",
    order: 14
  },
  iso885914: {
    labelLong: "Celtic (ISO 8859-14)",
    labelShort: "ISO 8859-14",
    order: 15
  },
  windows1250: {
    labelLong: "Central European (Windows 1250)",
    labelShort: "Windows 1250",
    order: 16,
    guessableName: "windows-1250"
  },
  iso88592: {
    labelLong: "Central European (ISO 8859-2)",
    labelShort: "ISO 8859-2",
    order: 17,
    guessableName: "ISO-8859-2"
  },
  cp852: {
    labelLong: "Central European (CP 852)",
    labelShort: "CP 852",
    order: 18
  },
  windows1251: {
    labelLong: "Cyrillic (Windows 1251)",
    labelShort: "Windows 1251",
    order: 19,
    guessableName: "windows-1251"
  },
  cp866: {
    labelLong: "Cyrillic (CP 866)",
    labelShort: "CP 866",
    order: 20,
    guessableName: "IBM866"
  },
  cp1125: {
    labelLong: "Cyrillic (CP 1125)",
    labelShort: "CP 1125",
    order: 21,
    guessableName: "IBM1125"
  },
  iso88595: {
    labelLong: "Cyrillic (ISO 8859-5)",
    labelShort: "ISO 8859-5",
    order: 22,
    guessableName: "ISO-8859-5"
  },
  koi8r: {
    labelLong: "Cyrillic (KOI8-R)",
    labelShort: "KOI8-R",
    order: 23,
    guessableName: "KOI8-R"
  },
  koi8u: {
    labelLong: "Cyrillic (KOI8-U)",
    labelShort: "KOI8-U",
    order: 24
  },
  iso885913: {
    labelLong: "Estonian (ISO 8859-13)",
    labelShort: "ISO 8859-13",
    order: 25
  },
  windows1253: {
    labelLong: "Greek (Windows 1253)",
    labelShort: "Windows 1253",
    order: 26,
    guessableName: "windows-1253"
  },
  iso88597: {
    labelLong: "Greek (ISO 8859-7)",
    labelShort: "ISO 8859-7",
    order: 27,
    guessableName: "ISO-8859-7"
  },
  windows1255: {
    labelLong: "Hebrew (Windows 1255)",
    labelShort: "Windows 1255",
    order: 28,
    guessableName: "windows-1255"
  },
  iso88598: {
    labelLong: "Hebrew (ISO 8859-8)",
    labelShort: "ISO 8859-8",
    order: 29,
    guessableName: "ISO-8859-8"
  },
  iso885910: {
    labelLong: "Nordic (ISO 8859-10)",
    labelShort: "ISO 8859-10",
    order: 30
  },
  iso885916: {
    labelLong: "Romanian (ISO 8859-16)",
    labelShort: "ISO 8859-16",
    order: 31
  },
  windows1254: {
    labelLong: "Turkish (Windows 1254)",
    labelShort: "Windows 1254",
    order: 32
  },
  iso88599: {
    labelLong: "Turkish (ISO 8859-9)",
    labelShort: "ISO 8859-9",
    order: 33
  },
  windows1258: {
    labelLong: "Vietnamese (Windows 1258)",
    labelShort: "Windows 1258",
    order: 34
  },
  gbk: {
    labelLong: "Simplified Chinese (GBK)",
    labelShort: "GBK",
    order: 35
  },
  gb18030: {
    labelLong: "Simplified Chinese (GB18030)",
    labelShort: "GB18030",
    order: 36
  },
  cp950: {
    labelLong: "Traditional Chinese (Big5)",
    labelShort: "Big5",
    order: 37,
    guessableName: "Big5"
  },
  big5hkscs: {
    labelLong: "Traditional Chinese (Big5-HKSCS)",
    labelShort: "Big5-HKSCS",
    order: 38
  },
  shiftjis: {
    labelLong: "Japanese (Shift JIS)",
    labelShort: "Shift JIS",
    order: 39,
    guessableName: "SHIFT_JIS"
  },
  eucjp: {
    labelLong: "Japanese (EUC-JP)",
    labelShort: "EUC-JP",
    order: 40,
    guessableName: "EUC-JP"
  },
  euckr: {
    labelLong: "Korean (EUC-KR)",
    labelShort: "EUC-KR",
    order: 41,
    guessableName: "EUC-KR"
  },
  windows874: {
    labelLong: "Thai (Windows 874)",
    labelShort: "Windows 874",
    order: 42
  },
  iso885911: {
    labelLong: "Latin/Thai (ISO 8859-11)",
    labelShort: "ISO 8859-11",
    order: 43
  },
  koi8ru: {
    labelLong: "Cyrillic (KOI8-RU)",
    labelShort: "KOI8-RU",
    order: 44
  },
  koi8t: {
    labelLong: "Tajik (KOI8-T)",
    labelShort: "KOI8-T",
    order: 45
  },
  gb2312: {
    labelLong: "Simplified Chinese (GB 2312)",
    labelShort: "GB 2312",
    order: 46,
    guessableName: "GB2312"
  },
  cp865: {
    labelLong: "Nordic DOS (CP 865)",
    labelShort: "CP 865",
    order: 47
  },
  cp850: {
    labelLong: "Western European DOS (CP 850)",
    labelShort: "CP 850",
    order: 48
  }
};
var GUESSABLE_ENCODINGS = (() => {
  const guessableEncodings = {};
  for (const encoding in SUPPORTED_ENCODINGS) {
    if (SUPPORTED_ENCODINGS[encoding].guessableName) {
      guessableEncodings[encoding] = SUPPORTED_ENCODINGS[encoding];
    }
  }
  return guessableEncodings;
})();

// out-build/vs/workbench/services/textfile/common/textfiles.js
var ITextFileService = createDecorator("textFileService");
var TextFileOperationResult;
(function(TextFileOperationResult2) {
  TextFileOperationResult2[TextFileOperationResult2["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
})(TextFileOperationResult || (TextFileOperationResult = {}));
var TextFileEditorModelState;
(function(TextFileEditorModelState2) {
  TextFileEditorModelState2[TextFileEditorModelState2["SAVED"] = 0] = "SAVED";
  TextFileEditorModelState2[TextFileEditorModelState2["DIRTY"] = 1] = "DIRTY";
  TextFileEditorModelState2[TextFileEditorModelState2["PENDING_SAVE"] = 2] = "PENDING_SAVE";
  TextFileEditorModelState2[TextFileEditorModelState2["CONFLICT"] = 3] = "CONFLICT";
  TextFileEditorModelState2[TextFileEditorModelState2["ORPHAN"] = 4] = "ORPHAN";
  TextFileEditorModelState2[TextFileEditorModelState2["ERROR"] = 5] = "ERROR";
})(TextFileEditorModelState || (TextFileEditorModelState = {}));
var TextFileResolveReason;
(function(TextFileResolveReason2) {
  TextFileResolveReason2[TextFileResolveReason2["EDITOR"] = 1] = "EDITOR";
  TextFileResolveReason2[TextFileResolveReason2["REFERENCE"] = 2] = "REFERENCE";
  TextFileResolveReason2[TextFileResolveReason2["OTHER"] = 3] = "OTHER";
})(TextFileResolveReason || (TextFileResolveReason = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["Encode"] = 0] = "Encode";
  EncodingMode2[EncodingMode2["Decode"] = 1] = "Decode";
})(EncodingMode || (EncodingMode = {}));
function stringToSnapshot(value) {
  let done = false;
  return {
    read() {
      if (!done) {
        done = true;
        return value;
      }
      return null;
    }
  };
}

// out-build/vs/workbench/api/common/extHostWorkspace.js
function isFolderEqual(folderA, folderB, extHostFileSystemInfo) {
  return new ExtUri((uri) => ignorePathCasing(uri, extHostFileSystemInfo)).isEqual(folderA, folderB);
}
function compareWorkspaceFolderByUri(a, b, extHostFileSystemInfo) {
  return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? 0 : compare(a.uri.toString(), b.uri.toString());
}
function compareWorkspaceFolderByUriAndNameAndIndex(a, b, extHostFileSystemInfo) {
  if (a.index !== b.index) {
    return a.index < b.index ? -1 : 1;
  }
  return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? compare(a.name, b.name) : compare(a.uri.toString(), b.uri.toString());
}
function delta2(oldFolders, newFolders, compare4, extHostFileSystemInfo) {
  const oldSortedFolders = oldFolders.slice(0).sort((a, b) => compare4(a, b, extHostFileSystemInfo));
  const newSortedFolders = newFolders.slice(0).sort((a, b) => compare4(a, b, extHostFileSystemInfo));
  return delta(oldSortedFolders, newSortedFolders, (a, b) => compare4(a, b, extHostFileSystemInfo));
}
function ignorePathCasing(uri, extHostFileSystemInfo) {
  const capabilities = extHostFileSystemInfo.getCapabilities(uri.scheme);
  return !(capabilities && capabilities & 1024);
}
var ExtHostWorkspaceImpl = class _ExtHostWorkspaceImpl extends Workspace {
  static toExtHostWorkspace(data2, previousConfirmedWorkspace, previousUnconfirmedWorkspace, extHostFileSystemInfo) {
    if (!data2) {
      return { workspace: null, added: [], removed: [] };
    }
    const { id: id2, name: name2, folders, configuration, transient, isUntitled } = data2;
    const newWorkspaceFolders = [];
    const oldWorkspace = previousConfirmedWorkspace;
    if (previousConfirmedWorkspace) {
      folders.forEach((folderData, index) => {
        const folderUri = URI.revive(folderData.uri);
        const existingFolder = _ExtHostWorkspaceImpl._findFolder(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri, extHostFileSystemInfo);
        if (existingFolder) {
          existingFolder.name = folderData.name;
          existingFolder.index = folderData.index;
          newWorkspaceFolders.push(existingFolder);
        } else {
          newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index });
        }
      });
    } else {
      newWorkspaceFolders.push(...folders.map(({ uri, name: name3, index }) => ({ uri: URI.revive(uri), name: name3, index })));
    }
    newWorkspaceFolders.sort((f1, f2) => f1.index < f2.index ? -1 : 1);
    const workspace = new _ExtHostWorkspaceImpl(id2, name2, newWorkspaceFolders, !!transient, configuration ? URI.revive(configuration) : null, !!isUntitled, (uri) => ignorePathCasing(uri, extHostFileSystemInfo));
    const { added, removed } = delta2(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri, extHostFileSystemInfo);
    return { workspace, added, removed };
  }
  static _findFolder(workspace, folderUriToFind, extHostFileSystemInfo) {
    for (let i = 0; i < workspace.folders.length; i++) {
      const folder = workspace.workspaceFolders[i];
      if (isFolderEqual(folder.uri, folderUriToFind, extHostFileSystemInfo)) {
        return folder;
      }
    }
    return void 0;
  }
  constructor(id2, _name, folders, transient, configuration, _isUntitled, ignorePathCasing2) {
    super(id2, folders.map((f) => new WorkspaceFolder(f)), transient, configuration, ignorePathCasing2);
    this._name = _name;
    this._isUntitled = _isUntitled;
    this._workspaceFolders = [];
    this._structure = TernarySearchTree.forUris(ignorePathCasing2, () => true);
    folders.forEach((folder) => {
      this._workspaceFolders.push(folder);
      this._structure.set(folder.uri, folder);
    });
  }
  get name() {
    return this._name;
  }
  get isUntitled() {
    return this._isUntitled;
  }
  get workspaceFolders() {
    return this._workspaceFolders.slice(0);
  }
  getWorkspaceFolder(uri, resolveParent) {
    if (resolveParent && this._structure.get(uri)) {
      uri = dirname2(uri);
    }
    return this._structure.findSubstr(uri);
  }
  resolveWorkspaceFolder(uri) {
    return this._structure.get(uri);
  }
};
var ExtHostWorkspace = class ExtHostWorkspace2 {
  constructor(extHostRpc, initData, extHostFileSystemInfo, logService, uriTransformerService) {
    this._onDidChangeWorkspace = new Emitter();
    this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;
    this._onDidGrantWorkspaceTrust = new Emitter();
    this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event;
    this._activeSearchCallbacks = [];
    this._trusted = false;
    this._editSessionIdentityProviders = /* @__PURE__ */ new Map();
    this._providerHandlePool = 0;
    this._onWillCreateEditSessionIdentityEvent = new AsyncEmitter();
    this._canonicalUriProviders = /* @__PURE__ */ new Map();
    this._logService = logService;
    this._extHostFileSystemInfo = extHostFileSystemInfo;
    this._uriTransformerService = uriTransformerService;
    this._requestIdProvider = new Counter();
    this._barrier = new Barrier();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadWorkspace);
    this._messageService = extHostRpc.getProxy(MainContext.MainThreadMessageService);
    const data2 = initData.workspace;
    this._confirmedWorkspace = data2 ? new ExtHostWorkspaceImpl(data2.id, data2.name, [], !!data2.transient, data2.configuration ? URI.revive(data2.configuration) : null, !!data2.isUntitled, (uri) => ignorePathCasing(uri, extHostFileSystemInfo)) : void 0;
  }
  $initializeWorkspace(data2, trusted) {
    this._trusted = trusted;
    this.$acceptWorkspaceData(data2);
    this._barrier.open();
  }
  waitForInitializeCall() {
    return this._barrier.wait();
  }
  // --- workspace ---
  get workspace() {
    return this._actualWorkspace;
  }
  get name() {
    return this._actualWorkspace ? this._actualWorkspace.name : void 0;
  }
  get workspaceFile() {
    if (this._actualWorkspace) {
      if (this._actualWorkspace.configuration) {
        if (this._actualWorkspace.isUntitled) {
          return URI.from({ scheme: Schemas.untitled, path: basename2(dirname2(this._actualWorkspace.configuration)) });
        }
        return this._actualWorkspace.configuration;
      }
    }
    return void 0;
  }
  get _actualWorkspace() {
    return this._unconfirmedWorkspace || this._confirmedWorkspace;
  }
  getWorkspaceFolders() {
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.workspaceFolders.slice(0);
  }
  async getWorkspaceFolders2() {
    await this._barrier.wait();
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.workspaceFolders.slice(0);
  }
  updateWorkspaceFolders(extension, index, deleteCount, ...workspaceFoldersToAdd) {
    const validatedDistinctWorkspaceFoldersToAdd = [];
    if (Array.isArray(workspaceFoldersToAdd)) {
      workspaceFoldersToAdd.forEach((folderToAdd) => {
        if (URI.isUri(folderToAdd.uri) && !validatedDistinctWorkspaceFoldersToAdd.some((f) => isFolderEqual(f.uri, folderToAdd.uri, this._extHostFileSystemInfo))) {
          validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || basenameOrAuthority(folderToAdd.uri) });
        }
      });
    }
    if (!!this._unconfirmedWorkspace) {
      return false;
    }
    if ([index, deleteCount].some((i) => typeof i !== "number" || i < 0)) {
      return false;
    }
    if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {
      return false;
    }
    const currentWorkspaceFolders = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];
    if (index + deleteCount > currentWorkspaceFolders.length) {
      return false;
    }
    const newWorkspaceFolders = currentWorkspaceFolders.slice(0);
    newWorkspaceFolders.splice(index, deleteCount, ...validatedDistinctWorkspaceFoldersToAdd.map((f) => ({
      uri: f.uri,
      name: f.name || basenameOrAuthority(f.uri),
      index: void 0
      /* fixed later */
    })));
    for (let i = 0; i < newWorkspaceFolders.length; i++) {
      const folder = newWorkspaceFolders[i];
      if (newWorkspaceFolders.some((otherFolder, index2) => index2 !== i && isFolderEqual(folder.uri, otherFolder.uri, this._extHostFileSystemInfo))) {
        return false;
      }
    }
    newWorkspaceFolders.forEach((f, index2) => f.index = index2);
    const { added, removed } = delta2(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex, this._extHostFileSystemInfo);
    if (added.length === 0 && removed.length === 0) {
      return false;
    }
    if (this._proxy) {
      const extName = extension.displayName || extension.name;
      this._proxy.$updateWorkspaceFolders(extName, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(void 0, (error) => {
        this._unconfirmedWorkspace = void 0;
        const options2 = { source: { identifier: extension.identifier, label: extension.displayName || extension.name } };
        this._messageService.$showMessage(Severity2.Error, localize(3027, null, extName, error.toString()), options2, []);
      });
    }
    this.trySetWorkspaceFolders(newWorkspaceFolders);
    return true;
  }
  getWorkspaceFolder(uri, resolveParent) {
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
  }
  async getWorkspaceFolder2(uri, resolveParent) {
    await this._barrier.wait();
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
  }
  async resolveWorkspaceFolder(uri) {
    await this._barrier.wait();
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.resolveWorkspaceFolder(uri);
  }
  getPath() {
    if (!this._actualWorkspace) {
      return void 0;
    }
    const { folders } = this._actualWorkspace;
    if (folders.length === 0) {
      return void 0;
    }
    return folders[0].uri.fsPath;
  }
  getRelativePath(pathOrUri, includeWorkspace) {
    let resource;
    let path = "";
    if (typeof pathOrUri === "string") {
      resource = URI.file(pathOrUri);
      path = pathOrUri;
    } else if (typeof pathOrUri !== "undefined") {
      resource = pathOrUri;
      path = pathOrUri.fsPath;
    }
    if (!resource) {
      return path;
    }
    const folder = this.getWorkspaceFolder(resource, true);
    if (!folder) {
      return path;
    }
    if (typeof includeWorkspace === "undefined" && this._actualWorkspace) {
      includeWorkspace = this._actualWorkspace.folders.length > 1;
    }
    let result = relativePath(folder.uri, resource);
    if (includeWorkspace && folder.name) {
      result = `${folder.name}/${result}`;
    }
    return result;
  }
  trySetWorkspaceFolders(folders) {
    if (this._actualWorkspace) {
      this._unconfirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace({
        id: this._actualWorkspace.id,
        name: this._actualWorkspace.name,
        configuration: this._actualWorkspace.configuration,
        folders,
        isUntitled: this._actualWorkspace.isUntitled
      }, this._actualWorkspace, void 0, this._extHostFileSystemInfo).workspace || void 0;
    }
  }
  $acceptWorkspaceData(data2) {
    const { workspace, added, removed } = ExtHostWorkspaceImpl.toExtHostWorkspace(data2, this._confirmedWorkspace, this._unconfirmedWorkspace, this._extHostFileSystemInfo);
    this._confirmedWorkspace = workspace || void 0;
    this._unconfirmedWorkspace = void 0;
    this._onDidChangeWorkspace.fire(Object.freeze({
      added,
      removed
    }));
  }
  // --- search ---
  /**
   * Note, null/undefined have different and important meanings for "exclude"
   */
  findFiles(include, exclude, maxResults, extensionId, token = CancellationToken.None) {
    this._logService.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles`);
    let excludeString = "";
    let useFileExcludes = true;
    if (exclude === null) {
      useFileExcludes = false;
    } else if (exclude !== void 0) {
      if (typeof exclude === "string") {
        excludeString = exclude;
      } else {
        excludeString = exclude.pattern;
      }
    }
    return this._findFilesImpl({ type: "include", value: include }, {
      exclude: [excludeString],
      maxResults,
      useExcludeSettings: useFileExcludes ? ExcludeSettingOptions.FilesExclude : ExcludeSettingOptions.None,
      useIgnoreFiles: {
        local: false
      }
    }, token);
  }
  findFiles2(filePatterns, options2 = {}, extensionId, token = CancellationToken.None) {
    this._logService.trace(`extHostWorkspace#findFiles2New: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles2New`);
    return this._findFilesImpl({ type: "filePatterns", value: filePatterns }, options2, token);
  }
  async _findFilesImpl(query, options2, token) {
    if (token.isCancellationRequested) {
      return Promise.resolve([]);
    }
    const filePatternsToUse = query.type === "include" ? [query.value] : query.value ?? [];
    if (!Array.isArray(filePatternsToUse)) {
      console.error("Invalid file pattern provided", filePatternsToUse);
      throw new Error(`Invalid file pattern provided ${JSON.stringify(filePatternsToUse)}`);
    }
    const queryOptions = filePatternsToUse.map((filePattern) => {
      const excludePatterns = globsToISearchPatternBuilder(options2.exclude);
      const fileQueries = {
        ignoreSymlinks: typeof options2.followSymlinks === "boolean" ? !options2.followSymlinks : void 0,
        disregardIgnoreFiles: typeof options2.useIgnoreFiles?.local === "boolean" ? !options2.useIgnoreFiles.local : void 0,
        disregardGlobalIgnoreFiles: typeof options2.useIgnoreFiles?.global === "boolean" ? !options2.useIgnoreFiles.global : void 0,
        disregardParentIgnoreFiles: typeof options2.useIgnoreFiles?.parent === "boolean" ? !options2.useIgnoreFiles.parent : void 0,
        disregardExcludeSettings: options2.useExcludeSettings !== void 0 && options2.useExcludeSettings === ExcludeSettingOptions.None,
        disregardSearchExcludeSettings: options2.useExcludeSettings !== void 0 && options2.useExcludeSettings !== ExcludeSettingOptions.SearchAndFilesExclude,
        maxResults: options2.maxResults,
        excludePattern: excludePatterns.length > 0 ? excludePatterns : void 0,
        _reason: "startFileSearch",
        shouldGlobSearch: query.type === "include" ? void 0 : true
      };
      const parseInclude = parseSearchExcludeInclude(GlobPattern.from(filePattern));
      const folderToUse = parseInclude?.folder;
      if (query.type === "include") {
        fileQueries.includePattern = parseInclude?.pattern;
      } else {
        fileQueries.filePattern = parseInclude?.pattern;
      }
      return {
        folder: folderToUse,
        options: fileQueries
      };
    });
    return this._findFilesBase(queryOptions, token);
  }
  async _findFilesBase(queryOptions, token) {
    const result = await Promise.all(queryOptions?.map((option) => this._proxy.$startFileSearch(option.folder ?? null, option.options, token).then((data2) => Array.isArray(data2) ? data2.map((d) => URI.revive(d)) : [])) ?? []);
    const flatResult = result.flat();
    const extUri2 = new ExtUri((uri) => ignorePathCasing(uri, this._extHostFileSystemInfo));
    const uriMap = /* @__PURE__ */ new Map();
    for (const uri of flatResult) {
      const key = extUri2.getComparisonKey(uri);
      if (!uriMap.has(key)) {
        uriMap.set(key, uri);
      }
    }
    return Array.from(uriMap.values());
  }
  findTextInFiles2(query, options2, extensionId, token = CancellationToken.None) {
    this._logService.trace(`extHostWorkspace#findTextInFiles2: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFiles2`);
    const getOptions = (include) => {
      if (!options2) {
        return {
          folder: void 0,
          options: {}
        };
      }
      const parsedInclude = include ? parseSearchExcludeInclude(GlobPattern.from(include)) : void 0;
      const excludePatterns = options2.exclude ? globsToISearchPatternBuilder(options2.exclude) : void 0;
      return {
        options: {
          ignoreSymlinks: typeof options2.followSymlinks === "boolean" ? !options2.followSymlinks : void 0,
          disregardIgnoreFiles: typeof options2.useIgnoreFiles?.local === "boolean" ? !options2.useIgnoreFiles?.local : void 0,
          disregardGlobalIgnoreFiles: typeof options2.useIgnoreFiles?.global === "boolean" ? !options2.useIgnoreFiles?.global : void 0,
          disregardParentIgnoreFiles: typeof options2.useIgnoreFiles?.parent === "boolean" ? !options2.useIgnoreFiles?.parent : void 0,
          disregardExcludeSettings: options2.useExcludeSettings !== void 0 && options2.useExcludeSettings === ExcludeSettingOptions.None,
          disregardSearchExcludeSettings: options2.useExcludeSettings !== void 0 && options2.useExcludeSettings !== ExcludeSettingOptions.SearchAndFilesExclude,
          fileEncoding: options2.encoding,
          maxResults: options2.maxResults,
          previewOptions: options2.previewOptions ? {
            matchLines: options2.previewOptions?.numMatchLines ?? 100,
            charsPerLine: options2.previewOptions?.charsPerLine ?? 1e4
          } : void 0,
          surroundingContext: options2.surroundingContext,
          includePattern: parsedInclude?.pattern,
          excludePattern: excludePatterns
        },
        folder: parsedInclude?.folder
      };
    };
    const queryOptionsRaw = options2?.include?.map((include) => getOptions(include)) ?? [getOptions(void 0)];
    const queryOptions = queryOptionsRaw.filter((queryOps) => !!queryOps);
    const disposables = new DisposableStore();
    const progressEmitter = disposables.add(new Emitter());
    const complete = this.findTextInFilesBase(query, queryOptions, (result, uri) => progressEmitter.fire({ result, uri }), token);
    const asyncIterable = new AsyncIterableProducer(async (emitter) => {
      disposables.add(progressEmitter.event((e) => {
        const result = e.result;
        const uri = e.uri;
        if (resultIsMatch(result)) {
          emitter.emitOne(new TextSearchMatch2(uri, result.rangeLocations.map((range) => ({
            previewRange: new Range2(range.preview.startLineNumber, range.preview.startColumn, range.preview.endLineNumber, range.preview.endColumn),
            sourceRange: new Range2(range.source.startLineNumber, range.source.startColumn, range.source.endLineNumber, range.source.endColumn)
          })), result.previewText));
        } else {
          emitter.emitOne(new TextSearchContext2(uri, result.text, result.lineNumber));
        }
      }));
      await complete;
    });
    return {
      results: asyncIterable,
      complete: complete.then((e) => {
        disposables.dispose();
        return {
          limitHit: e?.limitHit ?? false
        };
      })
    };
  }
  async findTextInFilesBase(query, queryOptions, callback, token = CancellationToken.None) {
    const requestId = this._requestIdProvider.getNext();
    let isCanceled = false;
    token.onCancellationRequested((_) => {
      isCanceled = true;
    });
    this._activeSearchCallbacks[requestId] = (p) => {
      if (isCanceled) {
        return;
      }
      const uri = URI.revive(p.resource);
      p.results.forEach((rawResult) => {
        const result = revive(rawResult);
        callback(result, uri);
      });
    };
    if (token.isCancellationRequested) {
      return {};
    }
    try {
      const result = await Promise.all(queryOptions?.map((option) => this._proxy.$startTextSearch(query, option.folder ?? null, option.options, requestId, token) || {}) ?? []);
      delete this._activeSearchCallbacks[requestId];
      return result.reduce((acc, val) => {
        return {
          limitHit: acc?.limitHit || (val?.limitHit ?? false),
          message: [acc?.message ?? [], val?.message ?? []].flat()
        };
      }, {}) ?? { limitHit: false };
    } catch (err) {
      delete this._activeSearchCallbacks[requestId];
      throw err;
    }
  }
  async findTextInFiles(query, options2, callback, extensionId, token = CancellationToken.None) {
    this._logService.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFiles`);
    const previewOptions = typeof options2.previewOptions === "undefined" ? {
      matchLines: 100,
      charsPerLine: 1e4
    } : options2.previewOptions;
    const parsedInclude = parseSearchExcludeInclude(GlobPattern.from(options2.include));
    const excludePattern = typeof options2.exclude === "string" ? options2.exclude : options2.exclude ? options2.exclude.pattern : void 0;
    const queryOptions = {
      ignoreSymlinks: typeof options2.followSymlinks === "boolean" ? !options2.followSymlinks : void 0,
      disregardIgnoreFiles: typeof options2.useIgnoreFiles === "boolean" ? !options2.useIgnoreFiles : void 0,
      disregardGlobalIgnoreFiles: typeof options2.useGlobalIgnoreFiles === "boolean" ? !options2.useGlobalIgnoreFiles : void 0,
      disregardParentIgnoreFiles: typeof options2.useParentIgnoreFiles === "boolean" ? !options2.useParentIgnoreFiles : void 0,
      disregardExcludeSettings: typeof options2.useDefaultExcludes === "boolean" ? !options2.useDefaultExcludes : true,
      disregardSearchExcludeSettings: typeof options2.useSearchExclude === "boolean" ? !options2.useSearchExclude : true,
      fileEncoding: options2.encoding,
      maxResults: options2.maxResults,
      previewOptions,
      surroundingContext: options2.afterContext,
      // TODO: remove ability to have before/after context separately
      includePattern: parsedInclude?.pattern,
      excludePattern: excludePattern ? [{ pattern: excludePattern }] : void 0
    };
    const progress = (result, uri) => {
      if (resultIsMatch(result)) {
        callback({
          uri,
          preview: {
            text: result.previewText,
            matches: mapArrayOrNot(result.rangeLocations, (m) => new Range2(m.preview.startLineNumber, m.preview.startColumn, m.preview.endLineNumber, m.preview.endColumn))
          },
          ranges: mapArrayOrNot(result.rangeLocations, (r) => new Range2(r.source.startLineNumber, r.source.startColumn, r.source.endLineNumber, r.source.endColumn))
        });
      } else {
        callback({
          uri,
          text: result.text,
          lineNumber: result.lineNumber
        });
      }
    };
    return this.findTextInFilesBase(query, [{ options: queryOptions, folder: parsedInclude?.folder }], progress, token);
  }
  $handleTextSearchResult(result, requestId) {
    this._activeSearchCallbacks[requestId]?.(result);
  }
  async save(uri) {
    const result = await this._proxy.$save(uri, { saveAs: false });
    return URI.revive(result);
  }
  async saveAs(uri) {
    const result = await this._proxy.$save(uri, { saveAs: true });
    return URI.revive(result);
  }
  saveAll(includeUntitled) {
    return this._proxy.$saveAll(includeUntitled);
  }
  resolveProxy(url) {
    return this._proxy.$resolveProxy(url);
  }
  lookupAuthorization(authInfo) {
    return this._proxy.$lookupAuthorization(authInfo);
  }
  lookupKerberosAuthorization(url) {
    return this._proxy.$lookupKerberosAuthorization(url);
  }
  loadCertificates() {
    return this._proxy.$loadCertificates();
  }
  // --- trust ---
  get trusted() {
    return this._trusted;
  }
  requestWorkspaceTrust(options2) {
    return this._proxy.$requestWorkspaceTrust(options2);
  }
  $onDidGrantWorkspaceTrust() {
    if (!this._trusted) {
      this._trusted = true;
      this._onDidGrantWorkspaceTrust.fire();
    }
  }
  // called by ext host
  registerEditSessionIdentityProvider(scheme, provider) {
    if (this._editSessionIdentityProviders.has(scheme)) {
      throw new Error(`A provider has already been registered for scheme ${scheme}`);
    }
    this._editSessionIdentityProviders.set(scheme, provider);
    const outgoingScheme = this._uriTransformerService.transformOutgoingScheme(scheme);
    const handle = this._providerHandlePool++;
    this._proxy.$registerEditSessionIdentityProvider(handle, outgoingScheme);
    return toDisposable(() => {
      this._editSessionIdentityProviders.delete(scheme);
      this._proxy.$unregisterEditSessionIdentityProvider(handle);
    });
  }
  // called by main thread
  async $getEditSessionIdentifier(workspaceFolder, cancellationToken) {
    this._logService.info("Getting edit session identifier for workspaceFolder", workspaceFolder);
    const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
    if (!folder) {
      this._logService.warn("Unable to resolve workspace folder");
      return void 0;
    }
    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", folder);
    const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);
    this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
    if (!provider) {
      return void 0;
    }
    const result = await provider.provideEditSessionIdentity(folder, cancellationToken);
    this._logService.info("Provider returned edit session identifier: ", result);
    if (!result) {
      return void 0;
    }
    return result;
  }
  async $provideEditSessionIdentityMatch(workspaceFolder, identity1, identity2, cancellationToken) {
    this._logService.info("Getting edit session identifier for workspaceFolder", workspaceFolder);
    const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
    if (!folder) {
      this._logService.warn("Unable to resolve workspace folder");
      return void 0;
    }
    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", folder);
    const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);
    this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
    if (!provider) {
      return void 0;
    }
    const result = await provider.provideEditSessionIdentityMatch?.(identity1, identity2, cancellationToken);
    this._logService.info("Provider returned edit session identifier match result: ", result);
    if (!result) {
      return void 0;
    }
    return result;
  }
  getOnWillCreateEditSessionIdentityEvent(extension) {
    return (listener, thisArg, disposables) => {
      const wrappedListener = function wrapped(e) {
        listener.call(thisArg, e);
      };
      wrappedListener.extension = extension;
      return this._onWillCreateEditSessionIdentityEvent.event(wrappedListener, void 0, disposables);
    };
  }
  // main thread calls this to trigger participants
  async $onWillCreateEditSessionIdentity(workspaceFolder, token, timeout2) {
    const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
    if (folder === void 0) {
      throw new Error("Unable to resolve workspace folder");
    }
    await this._onWillCreateEditSessionIdentityEvent.fireAsync({ workspaceFolder: folder }, token, async (thenable, listener) => {
      const now = Date.now();
      await Promise.resolve(thenable);
      if (Date.now() - now > timeout2) {
        this._logService.warn("SLOW edit session create-participant", listener.extension.identifier);
      }
    });
    if (token.isCancellationRequested) {
      return void 0;
    }
  }
  // called by ext host
  registerCanonicalUriProvider(scheme, provider) {
    if (this._canonicalUriProviders.has(scheme)) {
      throw new Error(`A provider has already been registered for scheme ${scheme}`);
    }
    this._canonicalUriProviders.set(scheme, provider);
    const outgoingScheme = this._uriTransformerService.transformOutgoingScheme(scheme);
    const handle = this._providerHandlePool++;
    this._proxy.$registerCanonicalUriProvider(handle, outgoingScheme);
    return toDisposable(() => {
      this._canonicalUriProviders.delete(scheme);
      this._proxy.$unregisterCanonicalUriProvider(handle);
    });
  }
  async provideCanonicalUri(uri, options2, cancellationToken) {
    const provider = this._canonicalUriProviders.get(uri.scheme);
    if (!provider) {
      return void 0;
    }
    const result = await provider.provideCanonicalUri?.(URI.revive(uri), options2, cancellationToken);
    if (!result) {
      return void 0;
    }
    return result;
  }
  // called by main thread
  async $provideCanonicalUri(uri, targetScheme, cancellationToken) {
    return this.provideCanonicalUri(URI.revive(uri), { targetScheme }, cancellationToken);
  }
  // --- encodings ---
  async decode(content, args) {
    const [uri, opts] = this.toEncodeDecodeParameters(args);
    const options2 = await this._proxy.$resolveDecoding(uri, opts);
    const stream = (await toDecodeStream(bufferToStream(VSBuffer.wrap(content)), {
      ...options2,
      acceptTextOnly: true,
      overwriteEncoding: (detectedEncoding) => {
        if (detectedEncoding === null || detectedEncoding === options2.preferredEncoding) {
          return Promise.resolve(options2.preferredEncoding);
        }
        return this._proxy.$validateDetectedEncoding(uri, detectedEncoding, opts);
      }
    })).stream;
    return consumeStream(stream, (chunks) => chunks.join(""));
  }
  async encode(content, args) {
    const [uri, options2] = this.toEncodeDecodeParameters(args);
    const { encoding, addBOM } = await this._proxy.$resolveEncoding(uri, options2);
    if (encoding === UTF8 && !addBOM) {
      return VSBuffer.fromString(content).buffer;
    }
    const res = await toEncodeReadable(stringToSnapshot(content), encoding, { addBOM });
    return readableToBuffer(res).buffer;
  }
  toEncodeDecodeParameters(opts) {
    const uri = isUriComponents(opts?.uri) ? opts.uri : void 0;
    const encoding = typeof opts?.encoding === "string" ? opts.encoding : void 0;
    return [uri, encoding ? { encoding } : void 0];
  }
};
ExtHostWorkspace = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostFileSystemInfo),
  __param(3, ILogService),
  __param(4, IURITransformerService)
], ExtHostWorkspace);
var IExtHostWorkspace = createDecorator("IExtHostWorkspace");
function parseSearchExcludeInclude(include) {
  let pattern;
  let includeFolder;
  if (include) {
    if (typeof include === "string") {
      pattern = include;
    } else {
      pattern = include.pattern;
      includeFolder = URI.revive(include.baseUri);
    }
    return {
      pattern,
      folder: includeFolder
    };
  }
  return void 0;
}
function globsToISearchPatternBuilder(excludes) {
  return (excludes?.map((exclude) => {
    if (typeof exclude === "string") {
      if (exclude === "") {
        return void 0;
      }
      return {
        pattern: exclude,
        uri: void 0
      };
    } else {
      const parsedExclude = parseSearchExcludeInclude(exclude);
      if (!parsedExclude) {
        return void 0;
      }
      return {
        pattern: parsedExclude.pattern,
        uri: parsedExclude.folder
      };
    }
  }) ?? []).filter((e) => !!e);
}

// out-build/vs/base/common/json.js
var ScanError;
(function(ScanError2) {
  ScanError2[ScanError2["None"] = 0] = "None";
  ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
  ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
  ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
  ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
  ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
  ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
(function(SyntaxKind2) {
  SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
  SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
  SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
  SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
  SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
  SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
  SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
  SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
  SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
  SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
  SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
  SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
  SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
  SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
  SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
  SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
  SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
var ParseErrorCode;
(function(ParseErrorCode2) {
  ParseErrorCode2[ParseErrorCode2["InvalidSymbol"] = 1] = "InvalidSymbol";
  ParseErrorCode2[ParseErrorCode2["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
  ParseErrorCode2[ParseErrorCode2["PropertyNameExpected"] = 3] = "PropertyNameExpected";
  ParseErrorCode2[ParseErrorCode2["ValueExpected"] = 4] = "ValueExpected";
  ParseErrorCode2[ParseErrorCode2["ColonExpected"] = 5] = "ColonExpected";
  ParseErrorCode2[ParseErrorCode2["CommaExpected"] = 6] = "CommaExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBraceExpected"] = 7] = "CloseBraceExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBracketExpected"] = 8] = "CloseBracketExpected";
  ParseErrorCode2[ParseErrorCode2["EndOfFileExpected"] = 9] = "EndOfFileExpected";
  ParseErrorCode2[ParseErrorCode2["InvalidCommentToken"] = 10] = "InvalidCommentToken";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
  ParseErrorCode2[ParseErrorCode2["InvalidUnicode"] = 14] = "InvalidUnicode";
  ParseErrorCode2[ParseErrorCode2["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
  ParseErrorCode2[ParseErrorCode2["InvalidCharacter"] = 16] = "InvalidCharacter";
})(ParseErrorCode || (ParseErrorCode = {}));
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: true
  };
})(ParseOptions || (ParseOptions = {}));
function createScanner(text, ignoreTrivia = false) {
  let pos = 0;
  const len = text.length;
  let value = "";
  let tokenOffset = 0;
  let token = 16;
  let scanError = 0;
  function scanHexDigits(count2) {
    let digits = 0;
    let hexValue = 0;
    while (digits < count2) {
      const ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        hexValue = hexValue * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        hexValue = hexValue * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        hexValue = hexValue * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count2) {
      hexValue = -1;
    }
    return hexValue;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    const start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    let end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    let result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      const ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        const ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117: {
            const ch3 = scanHexDigits(4);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          }
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    let code = text.charCodeAt(pos);
    if (isWhitespace2(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhitespace2(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      return token = 14;
    }
    switch (code) {
      // tokens: []{}:,
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      // strings
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      // comments
      case 47: {
        const start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          const safeLength = len - 1;
          let commentClosed = false;
          while (pos < safeLength) {
            const ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      }
      // numbers
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      // found a minus, followed by a number so
      // we fall through to proceed with scanning
      // numbers
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      // literals and unknown symbols
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhitespace2(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    let result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: () => pos,
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: () => token,
    getTokenValue: () => value,
    getTokenOffset: () => tokenOffset,
    getTokenLength: () => pos - tokenOffset,
    getTokenError: () => scanError
  };
}
function isWhitespace2(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["nullCharacter"] = 0] = "nullCharacter";
  CharacterCodes2[CharacterCodes2["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
  CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
  CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
  CharacterCodes2[CharacterCodes2["lineSeparator"] = 8232] = "lineSeparator";
  CharacterCodes2[CharacterCodes2["paragraphSeparator"] = 8233] = "paragraphSeparator";
  CharacterCodes2[CharacterCodes2["nextLine"] = 133] = "nextLine";
  CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
  CharacterCodes2[CharacterCodes2["nonBreakingSpace"] = 160] = "nonBreakingSpace";
  CharacterCodes2[CharacterCodes2["enQuad"] = 8192] = "enQuad";
  CharacterCodes2[CharacterCodes2["emQuad"] = 8193] = "emQuad";
  CharacterCodes2[CharacterCodes2["enSpace"] = 8194] = "enSpace";
  CharacterCodes2[CharacterCodes2["emSpace"] = 8195] = "emSpace";
  CharacterCodes2[CharacterCodes2["threePerEmSpace"] = 8196] = "threePerEmSpace";
  CharacterCodes2[CharacterCodes2["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
  CharacterCodes2[CharacterCodes2["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
  CharacterCodes2[CharacterCodes2["figureSpace"] = 8199] = "figureSpace";
  CharacterCodes2[CharacterCodes2["punctuationSpace"] = 8200] = "punctuationSpace";
  CharacterCodes2[CharacterCodes2["thinSpace"] = 8201] = "thinSpace";
  CharacterCodes2[CharacterCodes2["hairSpace"] = 8202] = "hairSpace";
  CharacterCodes2[CharacterCodes2["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
  CharacterCodes2[CharacterCodes2["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
  CharacterCodes2[CharacterCodes2["ideographicSpace"] = 12288] = "ideographicSpace";
  CharacterCodes2[CharacterCodes2["mathematicalSpace"] = 8287] = "mathematicalSpace";
  CharacterCodes2[CharacterCodes2["ogham"] = 5760] = "ogham";
  CharacterCodes2[CharacterCodes2["_"] = 95] = "_";
  CharacterCodes2[CharacterCodes2["$"] = 36] = "$";
  CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
  CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
  CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
  CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
  CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
  CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
  CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
  CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
  CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
  CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
  CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
  CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
  CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
  CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
  CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
  CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
  CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
  CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
  CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
  CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
  CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
  CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
  CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
  CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
  CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
  CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
  CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
  CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
  CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
  CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
  CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
  CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
  CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
  CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
  CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
  CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
  CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
  CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
  CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
  CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
  CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
  CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
  CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
  CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
  CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
  CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
  CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
  CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
  CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
  CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
  CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
  CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
  CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
  CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
  CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
  CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
  CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
  CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
  CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
  CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
  CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
  CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
  CharacterCodes2[CharacterCodes2["ampersand"] = 38] = "ampersand";
  CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
  CharacterCodes2[CharacterCodes2["at"] = 64] = "at";
  CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
  CharacterCodes2[CharacterCodes2["bar"] = 124] = "bar";
  CharacterCodes2[CharacterCodes2["caret"] = 94] = "caret";
  CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
  CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
  CharacterCodes2[CharacterCodes2["closeParen"] = 41] = "closeParen";
  CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
  CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
  CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
  CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
  CharacterCodes2[CharacterCodes2["equals"] = 61] = "equals";
  CharacterCodes2[CharacterCodes2["exclamation"] = 33] = "exclamation";
  CharacterCodes2[CharacterCodes2["greaterThan"] = 62] = "greaterThan";
  CharacterCodes2[CharacterCodes2["lessThan"] = 60] = "lessThan";
  CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
  CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
  CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
  CharacterCodes2[CharacterCodes2["openParen"] = 40] = "openParen";
  CharacterCodes2[CharacterCodes2["percent"] = 37] = "percent";
  CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
  CharacterCodes2[CharacterCodes2["question"] = 63] = "question";
  CharacterCodes2[CharacterCodes2["semicolon"] = 59] = "semicolon";
  CharacterCodes2[CharacterCodes2["singleQuote"] = 39] = "singleQuote";
  CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
  CharacterCodes2[CharacterCodes2["tilde"] = 126] = "tilde";
  CharacterCodes2[CharacterCodes2["backspace"] = 8] = "backspace";
  CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
  CharacterCodes2[CharacterCodes2["byteOrderMark"] = 65279] = "byteOrderMark";
  CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
  CharacterCodes2[CharacterCodes2["verticalTab"] = 11] = "verticalTab";
})(CharacterCodes || (CharacterCodes = {}));
function visit(text, visitor, options2 = ParseOptions.DEFAULT) {
  const _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
  }
  const onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  const disallowComments = options2 && options2.disallowComments;
  const allowTrailingComma = options2 && options2.allowTrailingComma;
  function scanNext() {
    while (true) {
      const token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(
            14
            /* ParseErrorCode.InvalidUnicode */
          );
          break;
        case 5:
          handleError(
            15
            /* ParseErrorCode.InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError(
            13
            /* ParseErrorCode.UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError(
              11
              /* ParseErrorCode.UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError(
            12
            /* ParseErrorCode.UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError(
            16
            /* ParseErrorCode.InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(
              10
              /* ParseErrorCode.InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(
            1
            /* ParseErrorCode.InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter = [], skipUntil = []) {
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    const value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11: {
        let value = 0;
        try {
          value = JSON.parse(_scanner.getTokenValue());
          if (typeof value !== "number") {
            handleError(
              2
              /* ParseErrorCode.InvalidNumberFormat */
            );
            value = 0;
          }
        } catch (e) {
          handleError(
            2
            /* ParseErrorCode.InvalidNumberFormat */
          );
        }
        onLiteralValue(value);
        break;
      }
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
    } else {
      handleError(5, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [
        2
        /* SyntaxKind.CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseValue()) {
        handleError(4, [], [
          4,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError(8, [
        4
        /* SyntaxKind.CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options2.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}

// out-build/vs/platform/configuration/common/configurationModels.js
function freeze(data2) {
  return Object.isFrozen(data2) ? data2 : deepFreeze(data2);
}
var ConfigurationModel = class _ConfigurationModel {
  static createEmptyModel(logService) {
    return new _ConfigurationModel({}, [], [], void 0, logService);
  }
  constructor(_contents, _keys, _overrides, _raw, logService) {
    this._contents = _contents;
    this._keys = _keys;
    this._overrides = _overrides;
    this._raw = _raw;
    this.logService = logService;
    this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    if (!this._rawConfiguration) {
      if (this._raw) {
        const rawConfigurationModels = (Array.isArray(this._raw) ? this._raw : [this._raw]).map((raw) => {
          if (raw instanceof _ConfigurationModel) {
            return raw;
          }
          const parser2 = new ConfigurationModelParser("", this.logService);
          parser2.parseRaw(raw);
          return parser2.configurationModel;
        });
        this._rawConfiguration = rawConfigurationModels.reduce((previous, current) => current === previous ? current : previous.merge(current), rawConfigurationModels[0]);
      } else {
        this._rawConfiguration = this;
      }
    }
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  get raw() {
    if (!this._raw) {
      return void 0;
    }
    if (Array.isArray(this._raw) && this._raw.every((raw) => raw instanceof _ConfigurationModel)) {
      return void 0;
    }
    return this._raw;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(section) {
    return section ? getConfigurationValue(this.contents, section) : this.contents;
  }
  inspect(section, overrideIdentifier) {
    const that = this;
    return {
      get value() {
        return freeze(that.rawConfiguration.getValue(section));
      },
      get override() {
        return overrideIdentifier ? freeze(that.rawConfiguration.getOverrideValue(section, overrideIdentifier)) : void 0;
      },
      get merged() {
        return freeze(overrideIdentifier ? that.rawConfiguration.override(overrideIdentifier).getValue(section) : that.rawConfiguration.getValue(section));
      },
      get overrides() {
        const overrides = [];
        for (const { contents, identifiers: identifiers2, keys } of that.rawConfiguration.overrides) {
          const value = new _ConfigurationModel(contents, keys, [], void 0, that.logService).getValue(section);
          if (value !== void 0) {
            overrides.push({ identifiers: identifiers2, value });
          }
        }
        return overrides.length ? freeze(overrides) : void 0;
      }
    };
  }
  getOverrideValue(section, overrideIdentifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(overrideIdentifier);
    return overrideContents ? section ? getConfigurationValue(overrideContents, section) : overrideContents : void 0;
  }
  getKeysForOverrideIdentifier(identifier) {
    const keys = [];
    for (const override of this.overrides) {
      if (override.identifiers.includes(identifier)) {
        keys.push(...override.keys);
      }
    }
    return distinct(keys);
  }
  getAllOverrideIdentifiers() {
    const result = [];
    for (const override of this.overrides) {
      result.push(...override.identifiers);
    }
    return distinct(result);
  }
  override(identifier) {
    let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
    if (!overrideConfigurationModel) {
      overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);
      this.overrideConfigurations.set(identifier, overrideConfigurationModel);
    }
    return overrideConfigurationModel;
  }
  merge(...others) {
    const contents = deepClone(this.contents);
    const overrides = deepClone(this.overrides);
    const keys = [...this.keys];
    const raws = this._raw ? Array.isArray(this._raw) ? [...this._raw] : [this._raw] : [this];
    for (const other of others) {
      raws.push(...other._raw ? Array.isArray(other._raw) ? other._raw : [other._raw] : [other]);
      if (other.isEmpty()) {
        continue;
      }
      this.mergeContents(contents, other.contents);
      for (const otherOverride of other.overrides) {
        const [override] = overrides.filter((o) => equals(o.identifiers, otherOverride.identifiers));
        if (override) {
          this.mergeContents(override.contents, otherOverride.contents);
          override.keys.push(...otherOverride.keys);
          override.keys = distinct(override.keys);
        } else {
          overrides.push(deepClone(otherOverride));
        }
      }
      for (const key of other.keys) {
        if (keys.indexOf(key) === -1) {
          keys.push(key);
        }
      }
    }
    return new _ConfigurationModel(contents, keys, overrides, !raws.length || raws.every((raw) => raw instanceof _ConfigurationModel) ? void 0 : raws, this.logService);
  }
  createOverrideConfigurationModel(identifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(identifier);
    if (!overrideContents || typeof overrideContents !== "object" || !Object.keys(overrideContents).length) {
      return this;
    }
    const contents = {};
    for (const key of distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
      let contentsForKey = this.contents[key];
      const overrideContentsForKey = overrideContents[key];
      if (overrideContentsForKey) {
        if (typeof contentsForKey === "object" && typeof overrideContentsForKey === "object") {
          contentsForKey = deepClone(contentsForKey);
          this.mergeContents(contentsForKey, overrideContentsForKey);
        } else {
          contentsForKey = overrideContentsForKey;
        }
      }
      contents[key] = contentsForKey;
    }
    return new _ConfigurationModel(contents, this.keys, this.overrides, void 0, this.logService);
  }
  mergeContents(source, target) {
    for (const key of Object.keys(target)) {
      if (key in source) {
        if (isObject(source[key]) && isObject(target[key])) {
          this.mergeContents(source[key], target[key]);
          continue;
        }
      }
      source[key] = deepClone(target[key]);
    }
  }
  getContentsForOverrideIdentifer(identifier) {
    let contentsForIdentifierOnly = null;
    let contents = null;
    const mergeContents = (contentsToMerge) => {
      if (contentsToMerge) {
        if (contents) {
          this.mergeContents(contents, contentsToMerge);
        } else {
          contents = deepClone(contentsToMerge);
        }
      }
    };
    for (const override of this.overrides) {
      if (override.identifiers.length === 1 && override.identifiers[0] === identifier) {
        contentsForIdentifierOnly = override.contents;
      } else if (override.identifiers.includes(identifier)) {
        mergeContents(override.contents);
      }
    }
    mergeContents(contentsForIdentifierOnly);
    return contents;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  // Update methods
  addValue(key, value) {
    this.updateValue(key, value, true);
  }
  setValue(key, value) {
    this.updateValue(key, value, false);
  }
  removeValue(key) {
    const index = this.keys.indexOf(key);
    if (index === -1) {
      return;
    }
    this.keys.splice(index, 1);
    removeFromValueTree(this.contents, key);
    if (OVERRIDE_PROPERTY_REGEX.test(key)) {
      this.overrides.splice(this.overrides.findIndex((o) => equals(o.identifiers, overrideIdentifiersFromKey(key))), 1);
    }
  }
  updateValue(key, value, add) {
    addToValueTree(this.contents, key, value, (e) => this.logService.error(e));
    add = add || this.keys.indexOf(key) === -1;
    if (add) {
      this.keys.push(key);
    }
    if (OVERRIDE_PROPERTY_REGEX.test(key)) {
      const overrideContents = this.contents[key];
      const identifiers2 = overrideIdentifiersFromKey(key);
      const override = {
        identifiers: identifiers2,
        keys: Object.keys(overrideContents),
        contents: toValuesTree(overrideContents, (message) => this.logService.error(message))
      };
      const index = this.overrides.findIndex((o) => equals(o.identifiers, identifiers2));
      if (index !== -1) {
        this.overrides[index] = override;
      } else {
        this.overrides.push(override);
      }
    }
  }
};
var ConfigurationModelParser = class {
  constructor(_name, logService) {
    this._name = _name;
    this.logService = logService;
    this._raw = null;
    this._configurationModel = null;
    this._restrictedConfigurations = [];
    this._parseErrors = [];
  }
  get configurationModel() {
    return this._configurationModel || ConfigurationModel.createEmptyModel(this.logService);
  }
  get restrictedConfigurations() {
    return this._restrictedConfigurations;
  }
  get errors() {
    return this._parseErrors;
  }
  parse(content, options2) {
    if (!isUndefinedOrNull(content)) {
      const raw = this.doParseContent(content);
      this.parseRaw(raw, options2);
    }
  }
  reparse(options2) {
    if (this._raw) {
      this.parseRaw(this._raw, options2);
    }
  }
  parseRaw(raw, options2) {
    this._raw = raw;
    const { contents, keys, overrides, restricted, hasExcludedProperties } = this.doParseRaw(raw, options2);
    this._configurationModel = new ConfigurationModel(contents, keys, overrides, hasExcludedProperties ? [raw] : void 0, this.logService);
    this._restrictedConfigurations = restricted || [];
  }
  doParseContent(content) {
    let raw = {};
    let currentProperty = null;
    let currentParent = [];
    const previousParents = [];
    const parseErrors = [];
    function onValue(value) {
      if (Array.isArray(currentParent)) {
        currentParent.push(value);
      } else if (currentProperty !== null) {
        currentParent[currentProperty] = value;
      }
    }
    const visitor = {
      onObjectBegin: () => {
        const object = {};
        onValue(object);
        previousParents.push(currentParent);
        currentParent = object;
        currentProperty = null;
      },
      onObjectProperty: (name2) => {
        currentProperty = name2;
      },
      onObjectEnd: () => {
        currentParent = previousParents.pop();
      },
      onArrayBegin: () => {
        const array = [];
        onValue(array);
        previousParents.push(currentParent);
        currentParent = array;
        currentProperty = null;
      },
      onArrayEnd: () => {
        currentParent = previousParents.pop();
      },
      onLiteralValue: onValue,
      onError: (error, offset, length) => {
        parseErrors.push({ error, offset, length });
      }
    };
    if (content) {
      try {
        visit(content, visitor);
        raw = currentParent[0] || {};
      } catch (e) {
        this.logService.error(`Error while parsing settings file ${this._name}: ${e}`);
        this._parseErrors = [e];
      }
    }
    return raw;
  }
  doParseRaw(raw, options2) {
    const registry = Registry.as(Extensions2.Configuration);
    const configurationProperties = registry.getConfigurationProperties();
    const excludedConfigurationProperties = registry.getExcludedConfigurationProperties();
    const filtered = this.filter(raw, configurationProperties, excludedConfigurationProperties, true, options2);
    raw = filtered.raw;
    const contents = toValuesTree(raw, (message) => this.logService.error(`Conflict in settings file ${this._name}: ${message}`));
    const keys = Object.keys(raw);
    const overrides = this.toOverrides(raw, (message) => this.logService.error(`Conflict in settings file ${this._name}: ${message}`));
    return { contents, keys, overrides, restricted: filtered.restricted, hasExcludedProperties: filtered.hasExcludedProperties };
  }
  filter(properties, configurationProperties, excludedConfigurationProperties, filterOverriddenProperties, options2) {
    let hasExcludedProperties = false;
    if (!options2?.scopes && !options2?.skipRestricted && !options2?.skipUnregistered && !options2?.exclude?.length) {
      return { raw: properties, restricted: [], hasExcludedProperties };
    }
    const raw = {};
    const restricted = [];
    for (const key in properties) {
      if (OVERRIDE_PROPERTY_REGEX.test(key) && filterOverriddenProperties) {
        const result = this.filter(properties[key], configurationProperties, excludedConfigurationProperties, false, options2);
        raw[key] = result.raw;
        hasExcludedProperties = hasExcludedProperties || result.hasExcludedProperties;
        restricted.push(...result.restricted);
      } else {
        const propertySchema = configurationProperties[key];
        if (propertySchema?.restricted) {
          restricted.push(key);
        }
        if (this.shouldInclude(key, propertySchema, excludedConfigurationProperties, options2)) {
          raw[key] = properties[key];
        } else {
          hasExcludedProperties = true;
        }
      }
    }
    return { raw, restricted, hasExcludedProperties };
  }
  shouldInclude(key, propertySchema, excludedConfigurationProperties, options2) {
    if (options2.exclude?.includes(key)) {
      return false;
    }
    if (options2.include?.includes(key)) {
      return true;
    }
    if (options2.skipRestricted && propertySchema?.restricted) {
      return false;
    }
    if (options2.skipUnregistered && !propertySchema) {
      return false;
    }
    const schema2 = propertySchema ?? excludedConfigurationProperties[key];
    const scope = schema2 ? typeof schema2.scope !== "undefined" ? schema2.scope : 4 : void 0;
    if (scope === void 0 || options2.scopes === void 0) {
      return true;
    }
    return options2.scopes.includes(scope);
  }
  toOverrides(raw, conflictReporter) {
    const overrides = [];
    for (const key of Object.keys(raw)) {
      if (OVERRIDE_PROPERTY_REGEX.test(key)) {
        const overrideRaw = {};
        const rawKey = raw[key];
        for (const keyInOverrideRaw in rawKey) {
          overrideRaw[keyInOverrideRaw] = rawKey[keyInOverrideRaw];
        }
        overrides.push({
          identifiers: overrideIdentifiersFromKey(key),
          keys: Object.keys(overrideRaw),
          contents: toValuesTree(overrideRaw, conflictReporter)
        });
      }
    }
    return overrides;
  }
};
var ConfigurationInspectValue = class {
  constructor(key, overrides, _value, overrideIdentifiers, defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, localUserConfiguration, remoteUserConfiguration, workspaceConfiguration, folderConfigurationModel, memoryConfigurationModel) {
    this.key = key;
    this.overrides = overrides;
    this._value = _value;
    this.overrideIdentifiers = overrideIdentifiers;
    this.defaultConfiguration = defaultConfiguration;
    this.policyConfiguration = policyConfiguration;
    this.applicationConfiguration = applicationConfiguration;
    this.userConfiguration = userConfiguration;
    this.localUserConfiguration = localUserConfiguration;
    this.remoteUserConfiguration = remoteUserConfiguration;
    this.workspaceConfiguration = workspaceConfiguration;
    this.folderConfigurationModel = folderConfigurationModel;
    this.memoryConfigurationModel = memoryConfigurationModel;
  }
  get value() {
    return freeze(this._value);
  }
  toInspectValue(inspectValue) {
    return inspectValue?.value !== void 0 || inspectValue?.override !== void 0 || inspectValue?.overrides !== void 0 ? inspectValue : void 0;
  }
  get defaultInspectValue() {
    if (!this._defaultInspectValue) {
      this._defaultInspectValue = this.defaultConfiguration.inspect(this.key, this.overrides.overrideIdentifier);
    }
    return this._defaultInspectValue;
  }
  get defaultValue() {
    return this.defaultInspectValue.merged;
  }
  get default() {
    return this.toInspectValue(this.defaultInspectValue);
  }
  get policyInspectValue() {
    if (this._policyInspectValue === void 0) {
      this._policyInspectValue = this.policyConfiguration ? this.policyConfiguration.inspect(this.key) : null;
    }
    return this._policyInspectValue;
  }
  get policyValue() {
    return this.policyInspectValue?.merged;
  }
  get policy() {
    return this.policyInspectValue?.value !== void 0 ? { value: this.policyInspectValue.value } : void 0;
  }
  get applicationInspectValue() {
    if (this._applicationInspectValue === void 0) {
      this._applicationInspectValue = this.applicationConfiguration ? this.applicationConfiguration.inspect(this.key) : null;
    }
    return this._applicationInspectValue;
  }
  get applicationValue() {
    return this.applicationInspectValue?.merged;
  }
  get application() {
    return this.toInspectValue(this.applicationInspectValue);
  }
  get userInspectValue() {
    if (!this._userInspectValue) {
      this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier);
    }
    return this._userInspectValue;
  }
  get userValue() {
    return this.userInspectValue.merged;
  }
  get user() {
    return this.toInspectValue(this.userInspectValue);
  }
  get userLocalInspectValue() {
    if (!this._userLocalInspectValue) {
      this._userLocalInspectValue = this.localUserConfiguration.inspect(this.key, this.overrides.overrideIdentifier);
    }
    return this._userLocalInspectValue;
  }
  get userLocalValue() {
    return this.userLocalInspectValue.merged;
  }
  get userLocal() {
    return this.toInspectValue(this.userLocalInspectValue);
  }
  get userRemoteInspectValue() {
    if (!this._userRemoteInspectValue) {
      this._userRemoteInspectValue = this.remoteUserConfiguration.inspect(this.key, this.overrides.overrideIdentifier);
    }
    return this._userRemoteInspectValue;
  }
  get userRemoteValue() {
    return this.userRemoteInspectValue.merged;
  }
  get userRemote() {
    return this.toInspectValue(this.userRemoteInspectValue);
  }
  get workspaceInspectValue() {
    if (this._workspaceInspectValue === void 0) {
      this._workspaceInspectValue = this.workspaceConfiguration ? this.workspaceConfiguration.inspect(this.key, this.overrides.overrideIdentifier) : null;
    }
    return this._workspaceInspectValue;
  }
  get workspaceValue() {
    return this.workspaceInspectValue?.merged;
  }
  get workspace() {
    return this.toInspectValue(this.workspaceInspectValue);
  }
  get workspaceFolderInspectValue() {
    if (this._workspaceFolderInspectValue === void 0) {
      this._workspaceFolderInspectValue = this.folderConfigurationModel ? this.folderConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier) : null;
    }
    return this._workspaceFolderInspectValue;
  }
  get workspaceFolderValue() {
    return this.workspaceFolderInspectValue?.merged;
  }
  get workspaceFolder() {
    return this.toInspectValue(this.workspaceFolderInspectValue);
  }
  get memoryInspectValue() {
    if (this._memoryInspectValue === void 0) {
      this._memoryInspectValue = this.memoryConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier);
    }
    return this._memoryInspectValue;
  }
  get memoryValue() {
    return this.memoryInspectValue.merged;
  }
  get memory() {
    return this.toInspectValue(this.memoryInspectValue);
  }
};
var Configuration = class _Configuration {
  constructor(_defaultConfiguration, _policyConfiguration, _applicationConfiguration, _localUserConfiguration, _remoteUserConfiguration, _workspaceConfiguration, _folderConfigurations, _memoryConfiguration, _memoryConfigurationByResource, logService) {
    this._defaultConfiguration = _defaultConfiguration;
    this._policyConfiguration = _policyConfiguration;
    this._applicationConfiguration = _applicationConfiguration;
    this._localUserConfiguration = _localUserConfiguration;
    this._remoteUserConfiguration = _remoteUserConfiguration;
    this._workspaceConfiguration = _workspaceConfiguration;
    this._folderConfigurations = _folderConfigurations;
    this._memoryConfiguration = _memoryConfiguration;
    this._memoryConfigurationByResource = _memoryConfigurationByResource;
    this.logService = logService;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations = new ResourceMap();
    this._userConfiguration = null;
  }
  getValue(section, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(section, overrides, workspace);
    return consolidateConfigurationModel.getValue(section);
  }
  updateValue(key, value, overrides = {}) {
    let memoryConfiguration;
    if (overrides.resource) {
      memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
      if (!memoryConfiguration) {
        memoryConfiguration = ConfigurationModel.createEmptyModel(this.logService);
        this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
      }
    } else {
      memoryConfiguration = this._memoryConfiguration;
    }
    if (value === void 0) {
      memoryConfiguration.removeValue(key);
    } else {
      memoryConfiguration.setValue(key, value);
    }
    if (!overrides.resource) {
      this._workspaceConsolidatedConfiguration = null;
    }
  }
  inspect(key, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(key, overrides, workspace);
    const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);
    const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
    const overrideIdentifiers = /* @__PURE__ */ new Set();
    for (const override of consolidateConfigurationModel.overrides) {
      for (const overrideIdentifier of override.identifiers) {
        if (consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== void 0) {
          overrideIdentifiers.add(overrideIdentifier);
        }
      }
    }
    return new ConfigurationInspectValue(key, overrides, consolidateConfigurationModel.getValue(key), overrideIdentifiers.size ? [...overrideIdentifiers] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, workspace ? this._workspaceConfiguration : void 0, folderConfigurationModel ? folderConfigurationModel : void 0, memoryConfigurationModel);
  }
  keys(workspace) {
    const folderConfigurationModel = this.getFolderConfigurationModelForResource(void 0, workspace);
    return {
      default: this._defaultConfiguration.keys.slice(0),
      policy: this._policyConfiguration.keys.slice(0),
      user: this.userConfiguration.keys.slice(0),
      workspace: this._workspaceConfiguration.keys.slice(0),
      workspaceFolder: folderConfigurationModel ? folderConfigurationModel.keys.slice(0) : []
    };
  }
  updateDefaultConfiguration(defaultConfiguration) {
    this._defaultConfiguration = defaultConfiguration;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations.clear();
  }
  updatePolicyConfiguration(policyConfiguration) {
    this._policyConfiguration = policyConfiguration;
  }
  updateApplicationConfiguration(applicationConfiguration) {
    this._applicationConfiguration = applicationConfiguration;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations.clear();
  }
  updateLocalUserConfiguration(localUserConfiguration) {
    this._localUserConfiguration = localUserConfiguration;
    this._userConfiguration = null;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations.clear();
  }
  updateRemoteUserConfiguration(remoteUserConfiguration) {
    this._remoteUserConfiguration = remoteUserConfiguration;
    this._userConfiguration = null;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations.clear();
  }
  updateWorkspaceConfiguration(workspaceConfiguration) {
    this._workspaceConfiguration = workspaceConfiguration;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations.clear();
  }
  updateFolderConfiguration(resource, configuration) {
    this._folderConfigurations.set(resource, configuration);
    this._foldersConsolidatedConfigurations.delete(resource);
  }
  deleteFolderConfiguration(resource) {
    this.folderConfigurations.delete(resource);
    this._foldersConsolidatedConfigurations.delete(resource);
  }
  compareAndUpdateDefaultConfiguration(defaults, keys) {
    const overrides = [];
    if (!keys) {
      const { added, updated, removed } = compare2(this._defaultConfiguration, defaults);
      keys = [...added, ...updated, ...removed];
    }
    for (const key of keys) {
      for (const overrideIdentifier of overrideIdentifiersFromKey(key)) {
        const fromKeys = this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier);
        const toKeys = defaults.getKeysForOverrideIdentifier(overrideIdentifier);
        const keys2 = [
          ...toKeys.filter((key2) => fromKeys.indexOf(key2) === -1),
          ...fromKeys.filter((key2) => toKeys.indexOf(key2) === -1),
          ...fromKeys.filter((key2) => !equals2(this._defaultConfiguration.override(overrideIdentifier).getValue(key2), defaults.override(overrideIdentifier).getValue(key2)))
        ];
        overrides.push([overrideIdentifier, keys2]);
      }
    }
    this.updateDefaultConfiguration(defaults);
    return { keys, overrides };
  }
  compareAndUpdatePolicyConfiguration(policyConfiguration) {
    const { added, updated, removed } = compare2(this._policyConfiguration, policyConfiguration);
    const keys = [...added, ...updated, ...removed];
    if (keys.length) {
      this.updatePolicyConfiguration(policyConfiguration);
    }
    return { keys, overrides: [] };
  }
  compareAndUpdateApplicationConfiguration(application) {
    const { added, updated, removed, overrides } = compare2(this.applicationConfiguration, application);
    const keys = [...added, ...updated, ...removed];
    if (keys.length) {
      this.updateApplicationConfiguration(application);
    }
    return { keys, overrides };
  }
  compareAndUpdateLocalUserConfiguration(user) {
    const { added, updated, removed, overrides } = compare2(this.localUserConfiguration, user);
    const keys = [...added, ...updated, ...removed];
    if (keys.length) {
      this.updateLocalUserConfiguration(user);
    }
    return { keys, overrides };
  }
  compareAndUpdateRemoteUserConfiguration(user) {
    const { added, updated, removed, overrides } = compare2(this.remoteUserConfiguration, user);
    const keys = [...added, ...updated, ...removed];
    if (keys.length) {
      this.updateRemoteUserConfiguration(user);
    }
    return { keys, overrides };
  }
  compareAndUpdateWorkspaceConfiguration(workspaceConfiguration) {
    const { added, updated, removed, overrides } = compare2(this.workspaceConfiguration, workspaceConfiguration);
    const keys = [...added, ...updated, ...removed];
    if (keys.length) {
      this.updateWorkspaceConfiguration(workspaceConfiguration);
    }
    return { keys, overrides };
  }
  compareAndUpdateFolderConfiguration(resource, folderConfiguration) {
    const currentFolderConfiguration = this.folderConfigurations.get(resource);
    const { added, updated, removed, overrides } = compare2(currentFolderConfiguration, folderConfiguration);
    const keys = [...added, ...updated, ...removed];
    if (keys.length || !currentFolderConfiguration) {
      this.updateFolderConfiguration(resource, folderConfiguration);
    }
    return { keys, overrides };
  }
  compareAndDeleteFolderConfiguration(folder) {
    const folderConfig = this.folderConfigurations.get(folder);
    if (!folderConfig) {
      throw new Error("Unknown folder");
    }
    this.deleteFolderConfiguration(folder);
    const { added, updated, removed, overrides } = compare2(folderConfig, void 0);
    return { keys: [...added, ...updated, ...removed], overrides };
  }
  get defaults() {
    return this._defaultConfiguration;
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    if (!this._userConfiguration) {
      if (this._remoteUserConfiguration.isEmpty()) {
        this._userConfiguration = this._localUserConfiguration;
      } else {
        const merged = this._localUserConfiguration.merge(this._remoteUserConfiguration);
        this._userConfiguration = new ConfigurationModel(merged.contents, merged.keys, merged.overrides, void 0, this.logService);
      }
    }
    return this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  get workspaceConfiguration() {
    return this._workspaceConfiguration;
  }
  get folderConfigurations() {
    return this._folderConfigurations;
  }
  getConsolidatedConfigurationModel(section, overrides, workspace) {
    let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
    if (overrides.overrideIdentifier) {
      configurationModel = configurationModel.override(overrides.overrideIdentifier);
    }
    if (!this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(section) !== void 0) {
      configurationModel = configurationModel.merge();
      for (const key of this._policyConfiguration.keys) {
        configurationModel.setValue(key, this._policyConfiguration.getValue(key));
      }
    }
    return configurationModel;
  }
  getConsolidatedConfigurationModelForResource({ resource }, workspace) {
    let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
      }
      const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
      if (memoryConfigurationForResource) {
        consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
      }
    }
    return consolidateConfiguration;
  }
  getWorkspaceConsolidatedConfiguration() {
    if (!this._workspaceConsolidatedConfiguration) {
      this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
    }
    return this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(folder) {
    let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
    if (!folderConsolidatedConfiguration) {
      const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
      const folderConfiguration = this._folderConfigurations.get(folder);
      if (folderConfiguration) {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
        this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
      } else {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
      }
    }
    return folderConsolidatedConfiguration;
  }
  getFolderConfigurationModelForResource(resource, workspace) {
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        return this._folderConfigurations.get(root.uri);
      }
    }
    return void 0;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys,
        raw: Array.isArray(this.applicationConfiguration.raw) ? void 0 : this.applicationConfiguration.raw
      },
      userLocal: {
        contents: this.localUserConfiguration.contents,
        overrides: this.localUserConfiguration.overrides,
        keys: this.localUserConfiguration.keys,
        raw: Array.isArray(this.localUserConfiguration.raw) ? void 0 : this.localUserConfiguration.raw
      },
      userRemote: {
        contents: this.remoteUserConfiguration.contents,
        overrides: this.remoteUserConfiguration.overrides,
        keys: this.remoteUserConfiguration.keys,
        raw: Array.isArray(this.remoteUserConfiguration.raw) ? void 0 : this.remoteUserConfiguration.raw
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((result, folder) => {
        const { contents, overrides, keys } = this._folderConfigurations.get(folder);
        result.push([folder, { contents, overrides, keys }]);
        return result;
      }, [])
    };
  }
  allKeys() {
    const keys = /* @__PURE__ */ new Set();
    this._defaultConfiguration.keys.forEach((key) => keys.add(key));
    this.userConfiguration.keys.forEach((key) => keys.add(key));
    this._workspaceConfiguration.keys.forEach((key) => keys.add(key));
    this._folderConfigurations.forEach((folderConfiguration) => folderConfiguration.keys.forEach((key) => keys.add(key)));
    return [...keys.values()];
  }
  allOverrideIdentifiers() {
    const keys = /* @__PURE__ */ new Set();
    this._defaultConfiguration.getAllOverrideIdentifiers().forEach((key) => keys.add(key));
    this.userConfiguration.getAllOverrideIdentifiers().forEach((key) => keys.add(key));
    this._workspaceConfiguration.getAllOverrideIdentifiers().forEach((key) => keys.add(key));
    this._folderConfigurations.forEach((folderConfiguration) => folderConfiguration.getAllOverrideIdentifiers().forEach((key) => keys.add(key)));
    return [...keys.values()];
  }
  getAllKeysForOverrideIdentifier(overrideIdentifier) {
    const keys = /* @__PURE__ */ new Set();
    this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach((key) => keys.add(key));
    this.userConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach((key) => keys.add(key));
    this._workspaceConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach((key) => keys.add(key));
    this._folderConfigurations.forEach((folderConfiguration) => folderConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach((key) => keys.add(key)));
    return [...keys.values()];
  }
  static parse(data2, logService) {
    const defaultConfiguration = this.parseConfigurationModel(data2.defaults, logService);
    const policyConfiguration = this.parseConfigurationModel(data2.policy, logService);
    const applicationConfiguration = this.parseConfigurationModel(data2.application, logService);
    const userLocalConfiguration = this.parseConfigurationModel(data2.userLocal, logService);
    const userRemoteConfiguration = this.parseConfigurationModel(data2.userRemote, logService);
    const workspaceConfiguration = this.parseConfigurationModel(data2.workspace, logService);
    const folders = data2.folders.reduce((result, value) => {
      result.set(URI.revive(value[0]), this.parseConfigurationModel(value[1], logService));
      return result;
    }, new ResourceMap());
    return new _Configuration(defaultConfiguration, policyConfiguration, applicationConfiguration, userLocalConfiguration, userRemoteConfiguration, workspaceConfiguration, folders, ConfigurationModel.createEmptyModel(logService), new ResourceMap(), logService);
  }
  static parseConfigurationModel(model, logService) {
    return new ConfigurationModel(model.contents, model.keys, model.overrides, model.raw, logService);
  }
};
var ConfigurationChangeEvent = class {
  constructor(change, previous, currentConfiguraiton, currentWorkspace, logService) {
    this.change = change;
    this.previous = previous;
    this.currentConfiguraiton = currentConfiguraiton;
    this.currentWorkspace = currentWorkspace;
    this.logService = logService;
    this._marker = "\n";
    this._markerCode1 = this._marker.charCodeAt(0);
    this._markerCode2 = ".".charCodeAt(0);
    this.affectedKeys = /* @__PURE__ */ new Set();
    this._previousConfiguration = void 0;
    for (const key of change.keys) {
      this.affectedKeys.add(key);
    }
    for (const [, keys] of change.overrides) {
      for (const key of keys) {
        this.affectedKeys.add(key);
      }
    }
    this._affectsConfigStr = this._marker;
    for (const key of this.affectedKeys) {
      this._affectsConfigStr += key + this._marker;
    }
  }
  get previousConfiguration() {
    if (!this._previousConfiguration && this.previous) {
      this._previousConfiguration = Configuration.parse(this.previous.data, this.logService);
    }
    return this._previousConfiguration;
  }
  affectsConfiguration(section, overrides) {
    const needle = this._marker + section;
    const idx = this._affectsConfigStr.indexOf(needle);
    if (idx < 0) {
      return false;
    }
    const pos = idx + needle.length;
    if (pos >= this._affectsConfigStr.length) {
      return false;
    }
    const code = this._affectsConfigStr.charCodeAt(pos);
    if (code !== this._markerCode1 && code !== this._markerCode2) {
      return false;
    }
    if (overrides) {
      const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, this.previous?.workspace) : void 0;
      const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);
      return !equals2(value1, value2);
    }
    return true;
  }
};
function compare2(from, to) {
  const { added, removed, updated } = compareConfigurationContents(to?.rawConfiguration, from?.rawConfiguration);
  const overrides = [];
  const fromOverrideIdentifiers = from?.getAllOverrideIdentifiers() || [];
  const toOverrideIdentifiers = to?.getAllOverrideIdentifiers() || [];
  if (to) {
    const addedOverrideIdentifiers = toOverrideIdentifiers.filter((key) => !fromOverrideIdentifiers.includes(key));
    for (const identifier of addedOverrideIdentifiers) {
      overrides.push([identifier, to.getKeysForOverrideIdentifier(identifier)]);
    }
  }
  if (from) {
    const removedOverrideIdentifiers = fromOverrideIdentifiers.filter((key) => !toOverrideIdentifiers.includes(key));
    for (const identifier of removedOverrideIdentifiers) {
      overrides.push([identifier, from.getKeysForOverrideIdentifier(identifier)]);
    }
  }
  if (to && from) {
    for (const identifier of fromOverrideIdentifiers) {
      if (toOverrideIdentifiers.includes(identifier)) {
        const result = compareConfigurationContents({ contents: from.getOverrideValue(void 0, identifier) || {}, keys: from.getKeysForOverrideIdentifier(identifier) }, { contents: to.getOverrideValue(void 0, identifier) || {}, keys: to.getKeysForOverrideIdentifier(identifier) });
        overrides.push([identifier, [...result.added, ...result.removed, ...result.updated]]);
      }
    }
  }
  return { added, removed, updated, overrides };
}
function compareConfigurationContents(to, from) {
  const added = to ? from ? to.keys.filter((key) => from.keys.indexOf(key) === -1) : [...to.keys] : [];
  const removed = from ? to ? from.keys.filter((key) => to.keys.indexOf(key) === -1) : [...from.keys] : [];
  const updated = [];
  if (to && from) {
    for (const key of from.keys) {
      if (to.keys.indexOf(key) !== -1) {
        const value1 = getConfigurationValue(from.contents, key);
        const value2 = getConfigurationValue(to.contents, key);
        if (!equals2(value1, value2)) {
          updated.push(key);
        }
      }
    }
  }
  return { added, removed, updated };
}

// out-build/vs/workbench/api/common/extHostConfiguration.js
function lookUp(tree, key) {
  if (key) {
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return void 0;
}
function isUri(thing) {
  return thing instanceof URI;
}
function isResourceLanguage(thing) {
  return isObject(thing) && thing.uri instanceof URI && !!thing.languageId && typeof thing.languageId === "string";
}
function isLanguage(thing) {
  return isObject(thing) && !thing.uri && !!thing.languageId && typeof thing.languageId === "string";
}
function isWorkspaceFolder(thing) {
  return isObject(thing) && thing.uri instanceof URI && (!thing.name || typeof thing.name === "string") && (!thing.index || typeof thing.index === "number");
}
function scopeToOverrides(scope) {
  if (isUri(scope)) {
    return { resource: scope };
  }
  if (isResourceLanguage(scope)) {
    return { resource: scope.uri, overrideIdentifier: scope.languageId };
  }
  if (isLanguage(scope)) {
    return { overrideIdentifier: scope.languageId };
  }
  if (isWorkspaceFolder(scope)) {
    return { resource: scope.uri };
  }
  if (scope === null) {
    return { resource: null };
  }
  return void 0;
}
var ExtHostConfiguration = class ExtHostConfiguration2 {
  constructor(extHostRpc, extHostWorkspace, logService) {
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadConfiguration);
    this._extHostWorkspace = extHostWorkspace;
    this._logService = logService;
    this._barrier = new Barrier();
    this._actual = null;
  }
  getConfigProvider() {
    return this._barrier.wait().then((_) => this._actual);
  }
  $initializeConfiguration(data2) {
    this._actual = new ExtHostConfigProvider(this._proxy, this._extHostWorkspace, data2, this._logService);
    this._barrier.open();
  }
  $acceptConfigurationChanged(data2, change) {
    this.getConfigProvider().then((provider) => provider.$acceptConfigurationChanged(data2, change));
  }
};
ExtHostConfiguration = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostWorkspace),
  __param(2, ILogService)
], ExtHostConfiguration);
var ExtHostConfigProvider = class {
  constructor(proxy, extHostWorkspace, data2, logService) {
    this._onDidChangeConfiguration = new Emitter();
    this._proxy = proxy;
    this._logService = logService;
    this._extHostWorkspace = extHostWorkspace;
    this._configuration = Configuration.parse(data2, logService);
    this._configurationScopes = this._toMap(data2.configurationScopes);
  }
  get onDidChangeConfiguration() {
    return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
  }
  $acceptConfigurationChanged(data2, change) {
    const previous = { data: this._configuration.toData(), workspace: this._extHostWorkspace.workspace };
    this._configuration = Configuration.parse(data2, this._logService);
    this._configurationScopes = this._toMap(data2.configurationScopes);
    this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(change, previous));
  }
  getConfiguration(section, scope, extensionDescription) {
    const overrides = scopeToOverrides(scope) || {};
    const config = this._toReadonlyValue(this._configuration.getValue(section, overrides, this._extHostWorkspace.workspace));
    if (section) {
      this._validateConfigurationAccess(section, overrides, extensionDescription?.identifier);
    }
    function parseConfigurationTarget(arg) {
      if (arg === void 0 || arg === null) {
        return null;
      }
      if (typeof arg === "boolean") {
        return arg ? 2 : 5;
      }
      switch (arg) {
        case ConfigurationTarget2.Global:
          return 2;
        case ConfigurationTarget2.Workspace:
          return 5;
        case ConfigurationTarget2.WorkspaceFolder:
          return 6;
      }
    }
    const result = {
      has(key) {
        return typeof lookUp(config, key) !== "undefined";
      },
      get: (key, defaultValue) => {
        this._validateConfigurationAccess(section ? `${section}.${key}` : key, overrides, extensionDescription?.identifier);
        let result2 = lookUp(config, key);
        if (typeof result2 === "undefined") {
          result2 = defaultValue;
        } else {
          let clonedConfig = void 0;
          const cloneOnWriteProxy = (target, accessor) => {
            if (isObject(target)) {
              let clonedTarget = void 0;
              const cloneTarget = () => {
                clonedConfig = clonedConfig ? clonedConfig : deepClone(config);
                clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
              };
              return new Proxy(target, {
                get: (target2, property) => {
                  if (typeof property === "string" && property.toLowerCase() === "tojson") {
                    cloneTarget();
                    return () => clonedTarget;
                  }
                  if (clonedConfig) {
                    clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                    return clonedTarget[property];
                  }
                  const result3 = target2[property];
                  if (typeof property === "string") {
                    return cloneOnWriteProxy(result3, `${accessor}.${property}`);
                  }
                  return result3;
                },
                set: (_target, property, value) => {
                  cloneTarget();
                  if (clonedTarget) {
                    clonedTarget[property] = value;
                  }
                  return true;
                },
                deleteProperty: (_target, property) => {
                  cloneTarget();
                  if (clonedTarget) {
                    delete clonedTarget[property];
                  }
                  return true;
                },
                defineProperty: (_target, property, descriptor) => {
                  cloneTarget();
                  if (clonedTarget) {
                    Object.defineProperty(clonedTarget, property, descriptor);
                  }
                  return true;
                }
              });
            }
            if (Array.isArray(target)) {
              return deepClone(target);
            }
            return target;
          };
          result2 = cloneOnWriteProxy(result2, key);
        }
        return result2;
      },
      update: (key, value, extHostConfigurationTarget, scopeToLanguage) => {
        key = section ? `${section}.${key}` : key;
        const target = parseConfigurationTarget(extHostConfigurationTarget);
        if (value !== void 0) {
          return this._proxy.$updateConfigurationOption(target, key, value, overrides, scopeToLanguage);
        } else {
          return this._proxy.$removeConfigurationOption(target, key, overrides, scopeToLanguage);
        }
      },
      inspect: (key) => {
        key = section ? `${section}.${key}` : key;
        const config2 = this._configuration.inspect(key, overrides, this._extHostWorkspace.workspace);
        if (config2) {
          return {
            key,
            defaultValue: deepClone(config2.policy?.value ?? config2.default?.value),
            globalLocalValue: deepClone(config2.userLocal?.value),
            globalRemoteValue: deepClone(config2.userRemote?.value),
            globalValue: deepClone(config2.user?.value ?? config2.application?.value),
            workspaceValue: deepClone(config2.workspace?.value),
            workspaceFolderValue: deepClone(config2.workspaceFolder?.value),
            defaultLanguageValue: deepClone(config2.default?.override),
            globalLocalLanguageValue: deepClone(config2.userLocal?.override),
            globalRemoteLanguageValue: deepClone(config2.userRemote?.override),
            globalLanguageValue: deepClone(config2.user?.override ?? config2.application?.override),
            workspaceLanguageValue: deepClone(config2.workspace?.override),
            workspaceFolderLanguageValue: deepClone(config2.workspaceFolder?.override),
            languageIds: deepClone(config2.overrideIdentifiers)
          };
        }
        return void 0;
      }
    };
    if (typeof config === "object") {
      mixin(result, config, false);
    }
    return Object.freeze(result);
  }
  _toReadonlyValue(result) {
    const readonlyProxy = (target) => {
      return isObject(target) ? new Proxy(target, {
        get: (target2, property) => readonlyProxy(target2[property]),
        set: (_target, property, _value) => {
          throw new Error(`TypeError: Cannot assign to read only property '${String(property)}' of object`);
        },
        deleteProperty: (_target, property) => {
          throw new Error(`TypeError: Cannot delete read only property '${String(property)}' of object`);
        },
        defineProperty: (_target, property) => {
          throw new Error(`TypeError: Cannot define property '${String(property)}' for a readonly object`);
        },
        setPrototypeOf: (_target) => {
          throw new Error(`TypeError: Cannot set prototype for a readonly object`);
        },
        isExtensible: () => false,
        preventExtensions: () => true
      }) : target;
    };
    return readonlyProxy(result);
  }
  _validateConfigurationAccess(key, overrides, extensionId) {
    const scope = OVERRIDE_PROPERTY_REGEX.test(key) ? 5 : this._configurationScopes.get(key);
    const extensionIdText = extensionId ? `[${extensionId.value}] ` : "";
    if (5 === scope) {
      if (typeof overrides?.resource === "undefined") {
        this._logService.warn(`${extensionIdText}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${key}', provide the URI of a resource or 'null' for any resource.`);
      }
      return;
    }
    if (4 === scope) {
      if (overrides?.resource) {
        this._logService.warn(`${extensionIdText}Accessing a window scoped configuration for a resource is not expected. To associate '${key}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);
      }
      return;
    }
  }
  _toConfigurationChangeEvent(change, previous) {
    const event = new ConfigurationChangeEvent(change, previous, this._configuration, this._extHostWorkspace.workspace, this._logService);
    return Object.freeze({
      affectsConfiguration: (section, scope) => event.affectsConfiguration(section, scopeToOverrides(scope))
    });
  }
  _toMap(scopes) {
    return scopes.reduce((result, scope) => {
      result.set(scope[0], scope[1]);
      return result;
    }, /* @__PURE__ */ new Map());
  }
};
var IExtHostConfiguration = createDecorator("IExtHostConfiguration");

// out-build/vs/workbench/services/extensions/common/extensionDescriptionRegistry.js
var DeltaExtensionsResult = class {
  constructor(versionId, removedDueToLooping) {
    this.versionId = versionId;
    this.removedDueToLooping = removedDueToLooping;
  }
};
var ExtensionDescriptionRegistry = class _ExtensionDescriptionRegistry extends Disposable {
  static isHostExtension(extensionId, myRegistry, globalRegistry) {
    if (myRegistry.getExtensionDescription(extensionId)) {
      return false;
    }
    const extensionDescription = globalRegistry.getExtensionDescription(extensionId);
    if (!extensionDescription) {
      return false;
    }
    if ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === "none") {
      return true;
    }
    return false;
  }
  constructor(_activationEventsReader, extensionDescriptions) {
    super();
    this._activationEventsReader = _activationEventsReader;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._versionId = 0;
    this._extensionDescriptions = extensionDescriptions;
    this._initialize();
  }
  _initialize() {
    this._extensionDescriptions.sort(extensionCmp);
    this._extensionsMap = new ExtensionIdentifierMap();
    this._extensionsArr = [];
    this._activationMap = /* @__PURE__ */ new Map();
    for (const extensionDescription of this._extensionDescriptions) {
      if (this._extensionsMap.has(extensionDescription.identifier)) {
        console.error("Extension `" + extensionDescription.identifier.value + "` is already registered");
        continue;
      }
      this._extensionsMap.set(extensionDescription.identifier, extensionDescription);
      this._extensionsArr.push(extensionDescription);
      const activationEvents = this._activationEventsReader.readActivationEvents(extensionDescription);
      for (const activationEvent of activationEvents) {
        if (!this._activationMap.has(activationEvent)) {
          this._activationMap.set(activationEvent, []);
        }
        this._activationMap.get(activationEvent).push(extensionDescription);
      }
    }
  }
  set(extensionDescriptions) {
    this._extensionDescriptions = extensionDescriptions;
    this._initialize();
    this._versionId++;
    this._onDidChange.fire(void 0);
    return {
      versionId: this._versionId
    };
  }
  deltaExtensions(toAdd, toRemove) {
    this._extensionDescriptions = removeExtensions(this._extensionDescriptions, toRemove);
    this._extensionDescriptions = this._extensionDescriptions.concat(toAdd);
    const looping = _ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);
    this._extensionDescriptions = removeExtensions(this._extensionDescriptions, looping.map((ext) => ext.identifier));
    this._initialize();
    this._versionId++;
    this._onDidChange.fire(void 0);
    return new DeltaExtensionsResult(this._versionId, looping);
  }
  static _findLoopingExtensions(extensionDescriptions) {
    const G = new class {
      constructor() {
        this._arcs = /* @__PURE__ */ new Map();
        this._nodesSet = /* @__PURE__ */ new Set();
        this._nodesArr = [];
      }
      addNode(id2) {
        if (!this._nodesSet.has(id2)) {
          this._nodesSet.add(id2);
          this._nodesArr.push(id2);
        }
      }
      addArc(from, to) {
        this.addNode(from);
        this.addNode(to);
        if (this._arcs.has(from)) {
          this._arcs.get(from).push(to);
        } else {
          this._arcs.set(from, [to]);
        }
      }
      getArcs(id2) {
        if (this._arcs.has(id2)) {
          return this._arcs.get(id2);
        }
        return [];
      }
      hasOnlyGoodArcs(id2, good2) {
        const dependencies = G.getArcs(id2);
        for (let i = 0; i < dependencies.length; i++) {
          if (!good2.has(dependencies[i])) {
            return false;
          }
        }
        return true;
      }
      getNodes() {
        return this._nodesArr;
      }
    }();
    const descs = new ExtensionIdentifierMap();
    for (const extensionDescription of extensionDescriptions) {
      descs.set(extensionDescription.identifier, extensionDescription);
      if (extensionDescription.extensionDependencies) {
        for (const depId of extensionDescription.extensionDependencies) {
          G.addArc(ExtensionIdentifier.toKey(extensionDescription.identifier), ExtensionIdentifier.toKey(depId));
        }
      }
    }
    const good = /* @__PURE__ */ new Set();
    G.getNodes().filter((id2) => G.getArcs(id2).length === 0).forEach((id2) => good.add(id2));
    const nodes = G.getNodes().filter((id2) => !good.has(id2));
    let madeProgress;
    do {
      madeProgress = false;
      for (let i = 0; i < nodes.length; i++) {
        const id2 = nodes[i];
        if (G.hasOnlyGoodArcs(id2, good)) {
          nodes.splice(i, 1);
          i--;
          good.add(id2);
          madeProgress = true;
        }
      }
    } while (madeProgress);
    return nodes.map((id2) => descs.get(id2));
  }
  containsActivationEvent(activationEvent) {
    return this._activationMap.has(activationEvent);
  }
  containsExtension(extensionId) {
    return this._extensionsMap.has(extensionId);
  }
  getExtensionDescriptionsForActivationEvent(activationEvent) {
    const extensions = this._activationMap.get(activationEvent);
    return extensions ? extensions.slice(0) : [];
  }
  getAllExtensionDescriptions() {
    return this._extensionsArr.slice(0);
  }
  getSnapshot() {
    return new ExtensionDescriptionRegistrySnapshot(this._versionId, this.getAllExtensionDescriptions());
  }
  getExtensionDescription(extensionId) {
    const extension = this._extensionsMap.get(extensionId);
    return extension ? extension : void 0;
  }
  getExtensionDescriptionByUUID(uuid) {
    for (const extensionDescription of this._extensionsArr) {
      if (extensionDescription.uuid === uuid) {
        return extensionDescription;
      }
    }
    return void 0;
  }
  getExtensionDescriptionByIdOrUUID(extensionId, uuid) {
    return this.getExtensionDescription(extensionId) ?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : void 0);
  }
};
var ExtensionDescriptionRegistrySnapshot = class {
  constructor(versionId, extensions) {
    this.versionId = versionId;
    this.extensions = extensions;
  }
};
var SortBucket;
(function(SortBucket2) {
  SortBucket2[SortBucket2["Builtin"] = 0] = "Builtin";
  SortBucket2[SortBucket2["User"] = 1] = "User";
  SortBucket2[SortBucket2["Dev"] = 2] = "Dev";
})(SortBucket || (SortBucket = {}));
function extensionCmp(a, b) {
  const aSortBucket = a.isBuiltin ? 0 : a.isUnderDevelopment ? 2 : 1;
  const bSortBucket = b.isBuiltin ? 0 : b.isUnderDevelopment ? 2 : 1;
  if (aSortBucket !== bSortBucket) {
    return aSortBucket - bSortBucket;
  }
  const aLastSegment = posix.basename(a.extensionLocation.path);
  const bLastSegment = posix.basename(b.extensionLocation.path);
  if (aLastSegment < bLastSegment) {
    return -1;
  }
  if (aLastSegment > bLastSegment) {
    return 1;
  }
  return 0;
}
function removeExtensions(arr, toRemove) {
  const toRemoveSet = new ExtensionIdentifierSet(toRemove);
  return arr.filter((extension) => !toRemoveSet.has(extension.identifier));
}

// out-build/vs/workbench/api/common/extHostExtensionActivator.js
var ExtensionActivationTimes = class _ExtensionActivationTimes {
  static {
    this.NONE = new _ExtensionActivationTimes(false, -1, -1, -1);
  }
  constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {
    this.startup = startup;
    this.codeLoadingTime = codeLoadingTime;
    this.activateCallTime = activateCallTime;
    this.activateResolvedTime = activateResolvedTime;
  }
};
var ExtensionActivationTimesBuilder = class {
  constructor(startup) {
    this._startup = startup;
    this._codeLoadingStart = -1;
    this._codeLoadingStop = -1;
    this._activateCallStart = -1;
    this._activateCallStop = -1;
    this._activateResolveStart = -1;
    this._activateResolveStop = -1;
  }
  _delta(start, stop) {
    if (start === -1 || stop === -1) {
      return -1;
    }
    return stop - start;
  }
  build() {
    return new ExtensionActivationTimes(this._startup, this._delta(this._codeLoadingStart, this._codeLoadingStop), this._delta(this._activateCallStart, this._activateCallStop), this._delta(this._activateResolveStart, this._activateResolveStop));
  }
  codeLoadingStart() {
    this._codeLoadingStart = Date.now();
  }
  codeLoadingStop() {
    this._codeLoadingStop = Date.now();
  }
  activateCallStart() {
    this._activateCallStart = Date.now();
  }
  activateCallStop() {
    this._activateCallStop = Date.now();
  }
  activateResolveStart() {
    this._activateResolveStart = Date.now();
  }
  activateResolveStop() {
    this._activateResolveStop = Date.now();
  }
};
var ActivatedExtension = class {
  constructor(activationFailed, activationFailedError, activationTimes, module2, exports2, disposable) {
    this.activationFailed = activationFailed;
    this.activationFailedError = activationFailedError;
    this.activationTimes = activationTimes;
    this.module = module2;
    this.exports = exports2;
    this.disposable = disposable;
  }
};
var EmptyExtension = class extends ActivatedExtension {
  constructor(activationTimes) {
    super(false, null, activationTimes, { activate: void 0, deactivate: void 0 }, void 0, Disposable.None);
  }
};
var HostExtension = class extends ActivatedExtension {
  constructor() {
    super(false, null, ExtensionActivationTimes.NONE, { activate: void 0, deactivate: void 0 }, void 0, Disposable.None);
  }
};
var FailedExtension = class extends ActivatedExtension {
  constructor(activationError) {
    super(true, activationError, ExtensionActivationTimes.NONE, { activate: void 0, deactivate: void 0 }, void 0, Disposable.None);
  }
};
var ExtensionsActivator = class ExtensionsActivator2 {
  constructor(registry, globalRegistry, host, _logService) {
    this._logService = _logService;
    this._registry = registry;
    this._globalRegistry = globalRegistry;
    this._host = host;
    this._operations = new ExtensionIdentifierMap();
    this._alreadyActivatedEvents = /* @__PURE__ */ Object.create(null);
  }
  dispose() {
    for (const [_, op] of this._operations) {
      op.dispose();
    }
  }
  async waitForActivatingExtensions() {
    const res = [];
    for (const [_, op] of this._operations) {
      res.push(op.wait());
    }
    await Promise.all(res);
  }
  isActivated(extensionId) {
    const op = this._operations.get(extensionId);
    return Boolean(op && op.value);
  }
  getActivatedExtension(extensionId) {
    const op = this._operations.get(extensionId);
    if (!op || !op.value) {
      throw new Error(`Extension '${extensionId.value}' is not known or not activated`);
    }
    return op.value;
  }
  async activateByEvent(activationEvent, startup) {
    if (this._alreadyActivatedEvents[activationEvent]) {
      return;
    }
    const activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);
    await this._activateExtensions(activateExtensions.map((e) => ({
      id: e.identifier,
      reason: { startup, extensionId: e.identifier, activationEvent }
    })));
    this._alreadyActivatedEvents[activationEvent] = true;
  }
  activateById(extensionId, reason) {
    const desc = this._registry.getExtensionDescription(extensionId);
    if (!desc) {
      throw new Error(`Extension '${extensionId.value}' is not known`);
    }
    return this._activateExtensions([{ id: desc.identifier, reason }]);
  }
  async _activateExtensions(extensions) {
    const operations = extensions.filter((p) => !this.isActivated(p.id)).map((ext) => this._handleActivationRequest(ext));
    await Promise.all(operations.map((op) => op.wait()));
  }
  /**
   * Handle semantics related to dependencies for `currentExtension`.
   * We don't need to worry about dependency loops because they are handled by the registry.
   */
  _handleActivationRequest(currentActivation) {
    if (this._operations.has(currentActivation.id)) {
      return this._operations.get(currentActivation.id);
    }
    if (this._isHostExtension(currentActivation.id)) {
      return this._createAndSaveOperation(currentActivation, null, [], null);
    }
    const currentExtension = this._registry.getExtensionDescription(currentActivation.id);
    if (!currentExtension) {
      const error = new Error(`Cannot activate unknown extension '${currentActivation.id.value}'`);
      const result = this._createAndSaveOperation(currentActivation, null, [], new FailedExtension(error));
      this._host.onExtensionActivationError(currentActivation.id, error, new MissingExtensionDependency(currentActivation.id.value));
      return result;
    }
    const deps = [];
    const depIds = typeof currentExtension.extensionDependencies === "undefined" ? [] : currentExtension.extensionDependencies;
    for (const depId of depIds) {
      if (this._isResolvedExtension(depId)) {
        continue;
      }
      const dep = this._operations.get(depId);
      if (dep) {
        deps.push(dep);
        continue;
      }
      if (this._isHostExtension(depId)) {
        deps.push(this._handleActivationRequest({
          id: this._globalRegistry.getExtensionDescription(depId).identifier,
          reason: currentActivation.reason
        }));
        continue;
      }
      const depDesc = this._registry.getExtensionDescription(depId);
      if (depDesc) {
        if (!depDesc.main && !depDesc.browser) {
          continue;
        }
        deps.push(this._handleActivationRequest({
          id: depDesc.identifier,
          reason: currentActivation.reason
        }));
        continue;
      }
      const currentExtensionFriendlyName = currentExtension.displayName || currentExtension.identifier.value;
      const error = new Error(`Cannot activate the '${currentExtensionFriendlyName}' extension because it depends on unknown extension '${depId}'`);
      const result = this._createAndSaveOperation(currentActivation, currentExtension.displayName, [], new FailedExtension(error));
      this._host.onExtensionActivationError(currentExtension.identifier, error, new MissingExtensionDependency(depId));
      return result;
    }
    return this._createAndSaveOperation(currentActivation, currentExtension.displayName, deps, null);
  }
  _createAndSaveOperation(activation, displayName, deps, value) {
    const operation = new ActivationOperation(activation.id, displayName, activation.reason, deps, value, this._host, this._logService);
    this._operations.set(activation.id, operation);
    return operation;
  }
  _isHostExtension(extensionId) {
    return ExtensionDescriptionRegistry.isHostExtension(extensionId, this._registry, this._globalRegistry);
  }
  _isResolvedExtension(extensionId) {
    const extensionDescription = this._globalRegistry.getExtensionDescription(extensionId);
    if (!extensionDescription) {
      return false;
    }
    return !extensionDescription.main && !extensionDescription.browser;
  }
};
ExtensionsActivator = __decorate([
  __param(3, ILogService)
], ExtensionsActivator);
var ActivationOperation = class ActivationOperation2 {
  get value() {
    return this._value;
  }
  get friendlyName() {
    return this._displayName || this._id.value;
  }
  constructor(_id, _displayName, _reason, _deps, _value, _host, _logService) {
    this._id = _id;
    this._displayName = _displayName;
    this._reason = _reason;
    this._deps = _deps;
    this._value = _value;
    this._host = _host;
    this._logService = _logService;
    this._barrier = new Barrier();
    this._isDisposed = false;
    this._initialize();
  }
  dispose() {
    this._isDisposed = true;
  }
  wait() {
    return this._barrier.wait();
  }
  async _initialize() {
    await this._waitForDepsThenActivate();
    this._barrier.open();
  }
  async _waitForDepsThenActivate() {
    if (this._value) {
      return;
    }
    while (this._deps.length > 0) {
      for (let i = 0; i < this._deps.length; i++) {
        const dep = this._deps[i];
        if (dep.value && !dep.value.activationFailed) {
          this._deps.splice(i, 1);
          i--;
          continue;
        }
        if (dep.value && dep.value.activationFailed) {
          const error = new Error(`Cannot activate the '${this.friendlyName}' extension because its dependency '${dep.friendlyName}' failed to activate`);
          error.detail = dep.value.activationFailedError;
          this._value = new FailedExtension(error);
          this._host.onExtensionActivationError(this._id, error, null);
          return;
        }
      }
      if (this._deps.length > 0) {
        await Promise.race(this._deps.map((dep) => dep.wait()));
      }
    }
    await this._activate();
  }
  async _activate() {
    try {
      this._value = await this._host.actualActivateExtension(this._id, this._reason);
    } catch (err) {
      const error = new Error();
      if (err && err.name) {
        error.name = err.name;
      }
      if (err && err.message) {
        error.message = `Activating extension '${this._id.value}' failed: ${err.message}.`;
      } else {
        error.message = `Activating extension '${this._id.value}' failed: ${err}.`;
      }
      if (err && err.stack) {
        error.stack = err.stack;
      }
      this._value = new FailedExtension(error);
      if (this._isDisposed && isCancellationError(err)) {
        return;
      }
      this._host.onExtensionActivationError(this._id, error, null);
      this._logService.error(`Activating extension ${this._id.value} failed due to an error:`);
      this._logService.error(err);
    }
  }
};
ActivationOperation = __decorate([
  __param(6, ILogService)
], ActivationOperation);

// out-build/vs/workbench/api/common/extHostStorage.js
var ExtHostStorage = class {
  constructor(mainContext, _logService) {
    this._logService = _logService;
    this._onDidChangeStorage = new Emitter();
    this.onDidChangeStorage = this._onDidChangeStorage.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadStorage);
  }
  registerExtensionStorageKeysToSync(extension, keys) {
    this._proxy.$registerExtensionStorageKeysToSync(extension, keys);
  }
  async initializeExtensionStorage(shared, key, defaultValue) {
    const value = await this._proxy.$initializeExtensionStorage(shared, key);
    let parsedValue;
    if (value) {
      parsedValue = this.safeParseValue(shared, key, value);
    }
    return parsedValue || defaultValue;
  }
  setValue(shared, key, value) {
    return this._proxy.$setValue(shared, key, value);
  }
  $acceptValue(shared, key, value) {
    const parsedValue = this.safeParseValue(shared, key, value);
    if (parsedValue) {
      this._onDidChangeStorage.fire({ shared, key, value: parsedValue });
    }
  }
  safeParseValue(shared, key, value) {
    try {
      return JSON.parse(value);
    } catch (error) {
      this._logService.error(`[extHostStorage] unexpected error parsing storage contents (extensionId: ${key}, global: ${shared}): ${error}`);
    }
    return void 0;
  }
};
var IExtHostStorage = createDecorator("IExtHostStorage");

// out-build/vs/workbench/api/common/extHostMemento.js
var ExtensionMemento = class {
  constructor(id2, global, storage) {
    this._deferredPromises = /* @__PURE__ */ new Map();
    this._id = id2;
    this._shared = global;
    this._storage = storage;
    this._init = this._storage.initializeExtensionStorage(this._shared, this._id, /* @__PURE__ */ Object.create(null)).then((value) => {
      this._value = value;
      return this;
    });
    this._storageListener = this._storage.onDidChangeStorage((e) => {
      if (e.shared === this._shared && e.key === this._id) {
        this._value = e.value;
      }
    });
    this._scheduler = new RunOnceScheduler(() => {
      const records = this._deferredPromises;
      this._deferredPromises = /* @__PURE__ */ new Map();
      (async () => {
        try {
          await this._storage.setValue(this._shared, this._id, this._value);
          for (const value of records.values()) {
            value.complete();
          }
        } catch (e) {
          for (const value of records.values()) {
            value.error(e);
          }
        }
      })();
    }, 0);
  }
  keys() {
    return Object.entries(this._value ?? {}).filter(([, value]) => value !== void 0).map(([key]) => key);
  }
  get whenReady() {
    return this._init;
  }
  get(key, defaultValue) {
    let value = this._value[key];
    if (typeof value === "undefined") {
      value = defaultValue;
    }
    return value;
  }
  update(key, value) {
    if (value !== null && typeof value === "object") {
      this._value[key] = JSON.parse(JSON.stringify(value));
    } else {
      this._value[key] = value;
    }
    const record = this._deferredPromises.get(key);
    if (record !== void 0) {
      return record.p;
    }
    const promise = new DeferredPromise();
    this._deferredPromises.set(key, promise);
    if (!this._scheduler.isScheduled()) {
      this._scheduler.schedule();
    }
    return promise.p;
  }
  dispose() {
    this._storageListener.dispose();
  }
};
var ExtensionGlobalMemento = class extends ExtensionMemento {
  setKeysForSync(keys) {
    this._storage.registerExtensionStorageKeysToSync({ id: this._id, version: this._extension.version }, keys);
  }
  constructor(extensionDescription, storage) {
    super(extensionDescription.identifier.value, true, storage);
    this._extension = extensionDescription;
  }
};

// out-build/vs/workbench/api/common/extHostFileSystemConsumer.js
var ExtHostConsumerFileSystem_1;
var ExtHostConsumerFileSystem = ExtHostConsumerFileSystem_1 = class ExtHostConsumerFileSystem2 {
  constructor(extHostRpc, fileSystemInfo) {
    this._fileSystemProvider = /* @__PURE__ */ new Map();
    this._writeQueue = new ResourceQueue();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadFileSystem);
    const that = this;
    this.value = Object.freeze({
      async stat(uri) {
        try {
          let stat;
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider) {
            await that._proxy.$ensureActivation(uri.scheme);
            stat = await provider.impl.stat(uri);
          } else {
            stat = await that._proxy.$stat(uri);
          }
          return {
            type: stat.type,
            ctime: stat.ctime,
            mtime: stat.mtime,
            size: stat.size,
            permissions: stat.permissions === FilePermission.Readonly ? 1 : void 0
          };
        } catch (err) {
          ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async readDirectory(uri) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider) {
            await that._proxy.$ensureActivation(uri.scheme);
            return (await provider.impl.readDirectory(uri)).slice();
          } else {
            return await that._proxy.$readdir(uri);
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async createDirectory(uri) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider && !provider.isReadonly) {
            await that._proxy.$ensureActivation(uri.scheme);
            return await that.mkdirp(provider.impl, provider.extUri, uri);
          } else {
            return await that._proxy.$mkdir(uri);
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async readFile(uri) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider) {
            await that._proxy.$ensureActivation(uri.scheme);
            return (await provider.impl.readFile(uri)).slice();
          } else {
            const buff = await that._proxy.$readFile(uri);
            return buff.buffer;
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async writeFile(uri, content) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider && !provider.isReadonly) {
            await that._proxy.$ensureActivation(uri.scheme);
            await that.mkdirp(provider.impl, provider.extUri, provider.extUri.dirname(uri));
            return await that._writeQueue.queueFor(uri, () => Promise.resolve(provider.impl.writeFile(uri, content, { create: true, overwrite: true })));
          } else {
            return await that._proxy.$writeFile(uri, VSBuffer.wrap(content));
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async delete(uri, options2) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider && !provider.isReadonly && !options2?.useTrash) {
            await that._proxy.$ensureActivation(uri.scheme);
            return await provider.impl.delete(uri, { recursive: false, ...options2 });
          } else {
            return await that._proxy.$delete(uri, { recursive: false, useTrash: false, atomic: false, ...options2 });
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async rename(oldUri, newUri, options2) {
        try {
          return await that._proxy.$rename(oldUri, newUri, { ...{ overwrite: false }, ...options2 });
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async copy(source, destination, options2) {
        try {
          return await that._proxy.$copy(source, destination, { ...{ overwrite: false }, ...options2 });
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      isWritableFileSystem(scheme) {
        const capabilities = fileSystemInfo.getCapabilities(scheme);
        if (typeof capabilities === "number") {
          return !(capabilities & 2048);
        }
        return void 0;
      }
    });
  }
  async mkdirp(provider, providerExtUri, directory) {
    const directoriesToCreate = [];
    while (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {
      try {
        const stat = await provider.stat(directory);
        if ((stat.type & FileType.Directory) === 0) {
          throw FileSystemError.FileExists(`Unable to create folder '${directory.scheme === Schemas.file ? directory.fsPath : directory.toString(true)}' that already exists but is not a directory`);
        }
        break;
      } catch (error) {
        if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {
          throw error;
        }
        directoriesToCreate.push(providerExtUri.basename(directory));
        directory = providerExtUri.dirname(directory);
      }
    }
    for (let i = directoriesToCreate.length - 1; i >= 0; i--) {
      directory = providerExtUri.joinPath(directory, directoriesToCreate[i]);
      try {
        await provider.createDirectory(directory);
      } catch (error) {
        if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {
          throw error;
        }
      }
    }
  }
  static _handleError(err) {
    if (err instanceof FileSystemError) {
      throw err;
    }
    if (err instanceof FileSystemProviderError) {
      switch (err.code) {
        case FileSystemProviderErrorCode.FileExists:
          throw FileSystemError.FileExists(err.message);
        case FileSystemProviderErrorCode.FileNotFound:
          throw FileSystemError.FileNotFound(err.message);
        case FileSystemProviderErrorCode.FileNotADirectory:
          throw FileSystemError.FileNotADirectory(err.message);
        case FileSystemProviderErrorCode.FileIsADirectory:
          throw FileSystemError.FileIsADirectory(err.message);
        case FileSystemProviderErrorCode.NoPermissions:
          throw FileSystemError.NoPermissions(err.message);
        case FileSystemProviderErrorCode.Unavailable:
          throw FileSystemError.Unavailable(err.message);
        default:
          throw new FileSystemError(err.message, err.name);
      }
    }
    if (!(err instanceof Error)) {
      throw new FileSystemError(String(err));
    }
    if (err.name === "ENOPRO" || err.message.includes("ENOPRO")) {
      throw FileSystemError.Unavailable(err.message);
    }
    switch (err.name) {
      case FileSystemProviderErrorCode.FileExists:
        throw FileSystemError.FileExists(err.message);
      case FileSystemProviderErrorCode.FileNotFound:
        throw FileSystemError.FileNotFound(err.message);
      case FileSystemProviderErrorCode.FileNotADirectory:
        throw FileSystemError.FileNotADirectory(err.message);
      case FileSystemProviderErrorCode.FileIsADirectory:
        throw FileSystemError.FileIsADirectory(err.message);
      case FileSystemProviderErrorCode.NoPermissions:
        throw FileSystemError.NoPermissions(err.message);
      case FileSystemProviderErrorCode.Unavailable:
        throw FileSystemError.Unavailable(err.message);
      default:
        throw new FileSystemError(err.message, err.name);
    }
  }
  // ---
  addFileSystemProvider(scheme, provider, options2) {
    this._fileSystemProvider.set(scheme, { impl: provider, extUri: options2?.isCaseSensitive ? extUri : extUriIgnorePathCase, isReadonly: !!options2?.isReadonly });
    return toDisposable(() => this._fileSystemProvider.delete(scheme));
  }
  getFileSystemProviderExtUri(scheme) {
    return this._fileSystemProvider.get(scheme)?.extUri ?? extUri;
  }
};
ExtHostConsumerFileSystem = ExtHostConsumerFileSystem_1 = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostFileSystemInfo)
], ExtHostConsumerFileSystem);
var IExtHostConsumerFileSystem = createDecorator("IExtHostConsumerFileSystem");

// out-build/vs/workbench/api/common/extHostStoragePaths.js
var IExtensionStoragePaths = createDecorator("IExtensionStoragePaths");
var ExtensionStoragePaths = class ExtensionStoragePaths2 {
  constructor(initData, _logService, _extHostFileSystem) {
    this._logService = _logService;
    this._extHostFileSystem = _extHostFileSystem;
    this._workspace = initData.workspace ?? void 0;
    this._environment = initData.environment;
    this.whenReady = this._getOrCreateWorkspaceStoragePath().then((value) => this._value = value);
  }
  async _getWorkspaceStorageURI(storageName) {
    return URI.joinPath(this._environment.workspaceStorageHome, storageName);
  }
  async _getOrCreateWorkspaceStoragePath() {
    if (!this._workspace) {
      return Promise.resolve(void 0);
    }
    const storageName = this._workspace.id;
    const storageUri = await this._getWorkspaceStorageURI(storageName);
    try {
      await this._extHostFileSystem.value.stat(storageUri);
      this._logService.trace("[ExtHostStorage] storage dir already exists", storageUri);
      return storageUri;
    } catch {
    }
    try {
      this._logService.trace("[ExtHostStorage] creating dir and metadata-file", storageUri);
      await this._extHostFileSystem.value.createDirectory(storageUri);
      await this._extHostFileSystem.value.writeFile(URI.joinPath(storageUri, "meta.json"), new TextEncoder().encode(JSON.stringify({
        id: this._workspace.id,
        configuration: URI.revive(this._workspace.configuration)?.toString(),
        name: this._workspace.name
      }, void 0, 2)));
      return storageUri;
    } catch (e) {
      this._logService.error("[ExtHostStorage]", e);
      return void 0;
    }
  }
  workspaceValue(extension) {
    if (this._value) {
      return URI.joinPath(this._value, extension.identifier.value);
    }
    return void 0;
  }
  globalValue(extension) {
    return URI.joinPath(this._environment.globalStorageHome, extension.identifier.value.toLowerCase());
  }
  onWillDeactivateAll() {
  }
};
ExtensionStoragePaths = __decorate([
  __param(0, IExtHostInitDataService),
  __param(1, ILogService),
  __param(2, IExtHostConsumerFileSystem)
], ExtensionStoragePaths);

// out-build/vs/platform/tunnel/common/tunnel.js
var ITunnelService = createDecorator("tunnelService");
var ISharedTunnelsService = createDecorator("sharedTunnelsService");
var TunnelProtocol;
(function(TunnelProtocol2) {
  TunnelProtocol2["Http"] = "http";
  TunnelProtocol2["Https"] = "https";
})(TunnelProtocol || (TunnelProtocol = {}));
var TunnelPrivacyId;
(function(TunnelPrivacyId2) {
  TunnelPrivacyId2["ConstantPrivate"] = "constantPrivate";
  TunnelPrivacyId2["Private"] = "private";
  TunnelPrivacyId2["Public"] = "public";
})(TunnelPrivacyId || (TunnelPrivacyId = {}));
var ProvidedOnAutoForward;
(function(ProvidedOnAutoForward2) {
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["Notify"] = 1] = "Notify";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["OpenBrowser"] = 2] = "OpenBrowser";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["OpenPreview"] = 3] = "OpenPreview";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["Silent"] = 4] = "Silent";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["Ignore"] = 5] = "Ignore";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["OpenBrowserOnce"] = 6] = "OpenBrowserOnce";
})(ProvidedOnAutoForward || (ProvidedOnAutoForward = {}));
function extractLocalHostUriMetaDataForPortMapping(uri) {
  if (uri.scheme !== "http" && uri.scheme !== "https") {
    return void 0;
  }
  const localhostMatch = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(uri.authority);
  if (!localhostMatch) {
    return void 0;
  }
  return {
    address: localhostMatch[1],
    port: +localhostMatch[2]
  };
}
var LOCALHOST_ADDRESSES = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"];
function isLocalhost(host) {
  return LOCALHOST_ADDRESSES.indexOf(host) >= 0;
}
var ALL_INTERFACES_ADDRESSES = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"];
function isAllInterfaces(host) {
  return ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;
}
var DisposableTunnel = class {
  constructor(remoteAddress, localAddress, _dispose) {
    this.remoteAddress = remoteAddress;
    this.localAddress = localAddress;
    this._dispose = _dispose;
    this._onDispose = new Emitter();
    this.onDidDispose = this._onDispose.event;
  }
  dispose() {
    this._onDispose.fire();
    return this._dispose();
  }
};
var AbstractTunnelService = class AbstractTunnelService2 extends Disposable {
  constructor(logService, configurationService) {
    super();
    this.logService = logService;
    this.configurationService = configurationService;
    this._onTunnelOpened = new Emitter();
    this.onTunnelOpened = this._onTunnelOpened.event;
    this._onTunnelClosed = new Emitter();
    this.onTunnelClosed = this._onTunnelClosed.event;
    this._onAddedTunnelProvider = new Emitter();
    this.onAddedTunnelProvider = this._onAddedTunnelProvider.event;
    this._tunnels = /* @__PURE__ */ new Map();
    this._canElevate = false;
    this._canChangeProtocol = true;
    this._privacyOptions = [];
    this._factoryInProgress = /* @__PURE__ */ new Set();
  }
  get hasTunnelProvider() {
    return !!this._tunnelProvider;
  }
  get defaultTunnelHost() {
    const settingValue = this.configurationService.getValue("remote.localPortHost");
    return !settingValue || settingValue === "localhost" ? "127.0.0.1" : "0.0.0.0";
  }
  setTunnelProvider(provider) {
    this._tunnelProvider = provider;
    if (!provider) {
      this._canElevate = false;
      this._privacyOptions = [];
      this._onAddedTunnelProvider.fire();
      return {
        dispose: () => {
        }
      };
    }
    this._onAddedTunnelProvider.fire();
    return {
      dispose: () => {
        this._tunnelProvider = void 0;
        this._canElevate = false;
        this._privacyOptions = [];
      }
    };
  }
  setTunnelFeatures(features) {
    this._canElevate = features.elevation;
    this._privacyOptions = features.privacyOptions;
    this._canChangeProtocol = features.protocol;
  }
  get canChangeProtocol() {
    return this._canChangeProtocol;
  }
  get canElevate() {
    return this._canElevate;
  }
  get canChangePrivacy() {
    return this._privacyOptions.length > 0;
  }
  get privacyOptions() {
    return this._privacyOptions;
  }
  get tunnels() {
    return this.getTunnels();
  }
  async getTunnels() {
    const tunnels = [];
    const tunnelArray = Array.from(this._tunnels.values());
    for (const portMap of tunnelArray) {
      const portArray = Array.from(portMap.values());
      for (const x of portArray) {
        const tunnelValue = await x.value;
        if (tunnelValue && typeof tunnelValue !== "string") {
          tunnels.push(tunnelValue);
        }
      }
    }
    return tunnels;
  }
  async dispose() {
    super.dispose();
    for (const portMap of this._tunnels.values()) {
      for (const { value } of portMap.values()) {
        await value.then((tunnel) => typeof tunnel !== "string" ? tunnel?.dispose() : void 0);
      }
      portMap.clear();
    }
    this._tunnels.clear();
  }
  setEnvironmentTunnel(remoteHost, remotePort, localAddress, privacy, protocol) {
    this.addTunnelToMap(remoteHost, remotePort, Promise.resolve({
      tunnelRemoteHost: remoteHost,
      tunnelRemotePort: remotePort,
      localAddress,
      privacy,
      protocol,
      dispose: () => Promise.resolve()
    }));
  }
  async getExistingTunnel(remoteHost, remotePort) {
    if (isAllInterfaces(remoteHost) || isLocalhost(remoteHost)) {
      remoteHost = LOCALHOST_ADDRESSES[0];
    }
    const existing = this.getTunnelFromMap(remoteHost, remotePort);
    if (existing) {
      ++existing.refcount;
      return existing.value;
    }
    return void 0;
  }
  openTunnel(addressProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded = false, privacy, protocol) {
    this.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);
    const addressOrTunnelProvider = this._tunnelProvider ?? addressProvider;
    if (!addressOrTunnelProvider) {
      return void 0;
    }
    if (!remoteHost) {
      remoteHost = "localhost";
    }
    if (!localHost) {
      localHost = this.defaultTunnelHost;
    }
    if (this._tunnelProvider && this._factoryInProgress.has(remotePort)) {
      this.logService.debug(`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`);
      return;
    }
    const resolvedTunnel = this.retainOrCreateTunnel(addressOrTunnelProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);
    if (!resolvedTunnel) {
      this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);
      return resolvedTunnel;
    }
    return resolvedTunnel.then((tunnel) => {
      if (!tunnel) {
        this.logService.trace("ForwardedPorts: (TunnelService) New tunnel is undefined.");
        this.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);
        return void 0;
      } else if (typeof tunnel === "string") {
        this.logService.trace("ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.");
        this.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);
        return tunnel;
      }
      this.logService.trace("ForwardedPorts: (TunnelService) New tunnel established.");
      const newTunnel = this.makeTunnel(tunnel);
      if (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {
        this.logService.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.");
      }
      if (privacy && tunnel.privacy !== privacy) {
        this.logService.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.");
      }
      this._onTunnelOpened.fire(newTunnel);
      return newTunnel;
    });
  }
  makeTunnel(tunnel) {
    return {
      tunnelRemotePort: tunnel.tunnelRemotePort,
      tunnelRemoteHost: tunnel.tunnelRemoteHost,
      tunnelLocalPort: tunnel.tunnelLocalPort,
      localAddress: tunnel.localAddress,
      privacy: tunnel.privacy,
      protocol: tunnel.protocol,
      dispose: async () => {
        this.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);
        const existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);
        if (existingHost) {
          const existing = existingHost.get(tunnel.tunnelRemotePort);
          if (existing) {
            existing.refcount--;
            await this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);
          }
        }
      }
    };
  }
  async tryDisposeTunnel(remoteHost, remotePort, tunnel) {
    if (tunnel.refcount <= 0) {
      this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);
      const disposePromise = tunnel.value.then(async (tunnel2) => {
        if (tunnel2 && typeof tunnel2 !== "string") {
          await tunnel2.dispose(true);
          this._onTunnelClosed.fire({ host: tunnel2.tunnelRemoteHost, port: tunnel2.tunnelRemotePort });
        }
      });
      if (this._tunnels.has(remoteHost)) {
        this._tunnels.get(remoteHost).delete(remotePort);
      }
      return disposePromise;
    }
  }
  async closeTunnel(remoteHost, remotePort) {
    this.logService.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);
    const portMap = this._tunnels.get(remoteHost);
    if (portMap && portMap.has(remotePort)) {
      const value = portMap.get(remotePort);
      value.refcount = 0;
      await this.tryDisposeTunnel(remoteHost, remotePort, value);
    }
  }
  addTunnelToMap(remoteHost, remotePort, tunnel) {
    if (!this._tunnels.has(remoteHost)) {
      this._tunnels.set(remoteHost, /* @__PURE__ */ new Map());
    }
    this._tunnels.get(remoteHost).set(remotePort, { refcount: 1, value: tunnel });
  }
  async removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort) {
    const hostMap = this._tunnels.get(remoteHost);
    if (hostMap) {
      const tunnel = hostMap.get(remotePort);
      const tunnelResult = tunnel ? await tunnel.value : void 0;
      if (!tunnelResult || typeof tunnelResult === "string") {
        hostMap.delete(remotePort);
      }
      if (hostMap.size === 0) {
        this._tunnels.delete(remoteHost);
      }
    }
  }
  getTunnelFromMap(remoteHost, remotePort) {
    const hosts = [remoteHost];
    if (isLocalhost(remoteHost)) {
      hosts.push(...LOCALHOST_ADDRESSES);
      hosts.push(...ALL_INTERFACES_ADDRESSES);
    } else if (isAllInterfaces(remoteHost)) {
      hosts.push(...ALL_INTERFACES_ADDRESSES);
    }
    const existingPortMaps = hosts.map((host) => this._tunnels.get(host));
    for (const map of existingPortMaps) {
      const existingTunnel = map?.get(remotePort);
      if (existingTunnel) {
        return existingTunnel;
      }
    }
    return void 0;
  }
  canTunnel(uri) {
    return !!extractLocalHostUriMetaDataForPortMapping(uri);
  }
  createWithProvider(tunnelProvider, remoteHost, remotePort, localPort, elevateIfNeeded, privacy, protocol) {
    this.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);
    const key = remotePort;
    this._factoryInProgress.add(key);
    const preferredLocalPort = localPort === void 0 ? remotePort : localPort;
    const creationInfo = { elevationRequired: elevateIfNeeded ? this.isPortPrivileged(preferredLocalPort) : false };
    const tunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, privacy, public: privacy ? privacy !== TunnelPrivacyId.Private : void 0, protocol };
    const tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);
    if (tunnel) {
      this.addTunnelToMap(remoteHost, remotePort, tunnel);
      tunnel.finally(() => {
        this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created by provider.");
        this._factoryInProgress.delete(key);
      });
    } else {
      this._factoryInProgress.delete(key);
    }
    return tunnel;
  }
};
AbstractTunnelService = __decorate([
  __param(0, ILogService),
  __param(1, IConfigurationService)
], AbstractTunnelService);

// out-build/vs/workbench/api/common/extHostTunnelService.js
var ExtensionTunnel = class extends DisposableTunnel {
};
var TunnelDtoConverter;
(function(TunnelDtoConverter2) {
  function fromApiTunnel(tunnel) {
    return {
      remoteAddress: tunnel.remoteAddress,
      localAddress: tunnel.localAddress,
      public: !!tunnel.public,
      privacy: tunnel.privacy ?? (tunnel.public ? TunnelPrivacyId.Public : TunnelPrivacyId.Private),
      protocol: tunnel.protocol
    };
  }
  TunnelDtoConverter2.fromApiTunnel = fromApiTunnel;
  function fromServiceTunnel(tunnel) {
    return {
      remoteAddress: {
        host: tunnel.tunnelRemoteHost,
        port: tunnel.tunnelRemotePort
      },
      localAddress: tunnel.localAddress,
      public: tunnel.privacy !== TunnelPrivacyId.ConstantPrivate && tunnel.privacy !== TunnelPrivacyId.ConstantPrivate,
      privacy: tunnel.privacy,
      protocol: tunnel.protocol
    };
  }
  TunnelDtoConverter2.fromServiceTunnel = fromServiceTunnel;
})(TunnelDtoConverter || (TunnelDtoConverter = {}));
var IExtHostTunnelService = createDecorator("IExtHostTunnelService");
var ExtHostTunnelService = class ExtHostTunnelService2 extends Disposable {
  constructor(extHostRpc, initData, logService) {
    super();
    this.logService = logService;
    this._showCandidatePort = () => {
      return Promise.resolve(true);
    };
    this._extensionTunnels = /* @__PURE__ */ new Map();
    this._onDidChangeTunnels = new Emitter();
    this.onDidChangeTunnels = this._onDidChangeTunnels.event;
    this._providerHandleCounter = 0;
    this._portAttributesProviders = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadTunnelService);
  }
  async openTunnel(extension, forward) {
    this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) ${extension.identifier.value} called openTunnel API for ${forward.remoteAddress.host}:${forward.remoteAddress.port}.`);
    const tunnel = await this._proxy.$openTunnel(forward, extension.displayName);
    if (tunnel) {
      const disposableTunnel = new ExtensionTunnel(tunnel.remoteAddress, tunnel.localAddress, () => {
        return this._proxy.$closeTunnel(tunnel.remoteAddress);
      });
      this._register(disposableTunnel);
      return disposableTunnel;
    }
    return void 0;
  }
  async getTunnels() {
    return this._proxy.$getTunnels();
  }
  nextPortAttributesProviderHandle() {
    return this._providerHandleCounter++;
  }
  registerPortsAttributesProvider(portSelector, provider) {
    if (portSelector.portRange === void 0 && portSelector.commandPattern === void 0) {
      this.logService.error("PortAttributesProvider must specify either a portRange or a commandPattern");
    }
    const providerHandle = this.nextPortAttributesProviderHandle();
    this._portAttributesProviders.set(providerHandle, { selector: portSelector, provider });
    this._proxy.$registerPortsAttributesProvider(portSelector, providerHandle);
    return new Disposable2(() => {
      this._portAttributesProviders.delete(providerHandle);
      this._proxy.$unregisterPortsAttributesProvider(providerHandle);
    });
  }
  async $providePortAttributes(handles, ports, pid, commandLine, cancellationToken) {
    const providedAttributes = [];
    for (const handle of handles) {
      const provider = this._portAttributesProviders.get(handle);
      if (!provider) {
        return [];
      }
      providedAttributes.push(...await Promise.all(ports.map(async (port) => {
        let providedAttributes2;
        try {
          providedAttributes2 = await provider.provider.providePortAttributes({ port, pid, commandLine }, cancellationToken);
        } catch (e) {
          providedAttributes2 = await provider.provider.providePortAttributes(port, pid, commandLine, cancellationToken);
        }
        return { providedAttributes: providedAttributes2, port };
      })));
    }
    const allAttributes = providedAttributes.filter((attribute) => !!attribute.providedAttributes);
    return allAttributes.length > 0 ? allAttributes.map((attributes) => {
      return {
        autoForwardAction: attributes.providedAttributes.autoForwardAction,
        port: attributes.port
      };
    }) : [];
  }
  async $registerCandidateFinder(_enable) {
  }
  registerTunnelProvider(provider, information) {
    if (this._forwardPortProvider) {
      throw new Error("A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.");
    }
    this._forwardPortProvider = async (tunnelOptions, tunnelCreationOptions) => {
      const result = await provider.provideTunnel(tunnelOptions, tunnelCreationOptions, CancellationToken.None);
      return result ?? void 0;
    };
    const tunnelFeatures = information.tunnelFeatures ? {
      elevation: !!information.tunnelFeatures?.elevation,
      privacyOptions: information.tunnelFeatures?.privacyOptions,
      protocol: information.tunnelFeatures.protocol === void 0 ? true : information.tunnelFeatures.protocol
    } : void 0;
    this._proxy.$setTunnelProvider(tunnelFeatures, true);
    return Promise.resolve(toDisposable(() => {
      this._forwardPortProvider = void 0;
      this._proxy.$setTunnelProvider(void 0, false);
    }));
  }
  hasTunnelProvider() {
    return this._proxy.$hasTunnelProvider();
  }
  /**
   * Applies the tunnel metadata and factory found in the remote authority
   * resolver to the tunnel system.
   *
   * `managedRemoteAuthority` should be be passed if the resolver returned on.
   * If this is the case, the tunnel cannot be connected to via a websocket from
   * the share process, so a synethic tunnel factory is used as a default.
   */
  async setTunnelFactory(provider, managedRemoteAuthority) {
    if (provider) {
      if (provider.candidatePortSource !== void 0) {
        this._proxy.$setCandidatePortSource(provider.candidatePortSource);
      }
      if (provider.showCandidatePort) {
        this._showCandidatePort = provider.showCandidatePort;
        this._proxy.$setCandidateFilter();
      }
      const tunnelFactory = provider.tunnelFactory ?? (managedRemoteAuthority ? this.makeManagedTunnelFactory(managedRemoteAuthority) : void 0);
      if (tunnelFactory) {
        this._forwardPortProvider = tunnelFactory;
        let privacyOptions = provider.tunnelFeatures?.privacyOptions ?? [];
        if (provider.tunnelFeatures?.public && privacyOptions.length === 0) {
          privacyOptions = [
            {
              id: "private",
              label: localize(3025, null),
              themeIcon: "lock"
            },
            {
              id: "public",
              label: localize(3026, null),
              themeIcon: "eye"
            }
          ];
        }
        const tunnelFeatures = provider.tunnelFeatures ? {
          elevation: !!provider.tunnelFeatures?.elevation,
          public: !!provider.tunnelFeatures?.public,
          privacyOptions,
          protocol: true
        } : void 0;
        this._proxy.$setTunnelProvider(tunnelFeatures, !!provider.tunnelFactory);
      }
    } else {
      this._forwardPortProvider = void 0;
    }
    return toDisposable(() => {
      this._forwardPortProvider = void 0;
    });
  }
  makeManagedTunnelFactory(_authority) {
    return void 0;
  }
  async $closeTunnel(remote, silent) {
    if (this._extensionTunnels.has(remote.host)) {
      const hostMap = this._extensionTunnels.get(remote.host);
      if (hostMap.has(remote.port)) {
        if (silent) {
          hostMap.get(remote.port).disposeListener.dispose();
        }
        await hostMap.get(remote.port).tunnel.dispose();
        hostMap.delete(remote.port);
      }
    }
  }
  async $onDidTunnelsChange() {
    this._onDidChangeTunnels.fire();
  }
  async $forwardPort(tunnelOptions, tunnelCreationOptions) {
    if (this._forwardPortProvider) {
      try {
        this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.");
        const providedPort = this._forwardPortProvider(tunnelOptions, tunnelCreationOptions);
        this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.");
        if (providedPort !== void 0) {
          const tunnel = await providedPort;
          this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.");
          if (tunnel === void 0) {
            this.logService.error("ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined");
            return void 0;
          }
          if (!this._extensionTunnels.has(tunnelOptions.remoteAddress.host)) {
            this._extensionTunnels.set(tunnelOptions.remoteAddress.host, /* @__PURE__ */ new Map());
          }
          const disposeListener = this._register(tunnel.onDidDispose(() => {
            this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel's onDidDispose.");
            return this._proxy.$closeTunnel(tunnel.remoteAddress);
          }));
          this._extensionTunnels.get(tunnelOptions.remoteAddress.host).set(tunnelOptions.remoteAddress.port, { tunnel, disposeListener });
          return TunnelDtoConverter.fromApiTunnel(tunnel);
        } else {
          this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined");
        }
      } catch (e) {
        this.logService.trace("ForwardedPorts: (ExtHostTunnelService) tunnel provider error");
        if (e instanceof Error) {
          return e.message;
        }
      }
    }
    return void 0;
  }
  async $applyCandidateFilter(candidates) {
    const filter2 = await Promise.all(candidates.map((candidate) => this._showCandidatePort(candidate.host, candidate.port, candidate.detail ?? "")));
    const result = candidates.filter((candidate, index) => filter2[index]);
    this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) filtered from ${candidates.map((port) => port.port).join(", ")} to ${result.map((port) => port.port).join(", ")}`);
    return result;
  }
};
ExtHostTunnelService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, ILogService)
], ExtHostTunnelService);

// out-build/vs/platform/terminal/common/environmentVariableShared.js
function serializeEnvironmentVariableCollection(collection) {
  return [...collection.entries()];
}
function serializeEnvironmentDescriptionMap(descriptionMap) {
  return descriptionMap ? [...descriptionMap.entries()] : [];
}

// out-build/vs/platform/terminal/common/terminalDataBuffering.js
var TerminalDataBufferer = class {
  constructor(_callback) {
    this._callback = _callback;
    this._terminalBufferMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    for (const buffer of this._terminalBufferMap.values()) {
      buffer.dispose();
    }
  }
  startBuffering(id2, event, throttleBy = 5) {
    const disposable = event((e) => {
      const data2 = isString(e) ? e : e.data;
      let buffer = this._terminalBufferMap.get(id2);
      if (buffer) {
        buffer.data.push(data2);
        return;
      }
      const timeoutId = setTimeout(() => this.flushBuffer(id2), throttleBy);
      buffer = {
        data: [data2],
        timeoutId,
        dispose: () => {
          clearTimeout(timeoutId);
          this.flushBuffer(id2);
          disposable.dispose();
        }
      };
      this._terminalBufferMap.set(id2, buffer);
    });
    return disposable;
  }
  stopBuffering(id2) {
    const buffer = this._terminalBufferMap.get(id2);
    buffer?.dispose();
  }
  flushBuffer(id2) {
    const buffer = this._terminalBufferMap.get(id2);
    if (buffer) {
      this._terminalBufferMap.delete(id2);
      this._callback(id2, buffer.data.join(""));
    }
  }
};

// out-build/vs/workbench/api/common/extHostTestItem.js
var testItemPropAccessor = (api, defaultValue, equals3, toUpdate) => {
  let value = defaultValue;
  return {
    enumerable: true,
    configurable: false,
    get() {
      return value;
    },
    set(newValue) {
      if (!equals3(value, newValue)) {
        const oldValue = value;
        value = newValue;
        api.listener?.(toUpdate(newValue, oldValue));
      }
    }
  };
};
var strictEqualComparator2 = (a, b) => a === b;
var propComparators = {
  range: (a, b) => {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.isEqual(b);
  },
  label: strictEqualComparator2,
  description: strictEqualComparator2,
  sortText: strictEqualComparator2,
  busy: strictEqualComparator2,
  error: strictEqualComparator2,
  canResolveChildren: strictEqualComparator2,
  tags: (a, b) => {
    if (a.length !== b.length) {
      return false;
    }
    if (a.some((t1) => !b.find((t2) => t1.id === t2.id))) {
      return false;
    }
    return true;
  }
};
var evSetProps = (fn) => (v) => ({ op: 4, update: fn(v) });
var makePropDescriptors = (api, label) => ({
  range: (() => {
    let value;
    const updateProps = evSetProps((r) => ({ range: Range.lift(Range4.from(r)) }));
    return {
      enumerable: true,
      configurable: false,
      get() {
        return value;
      },
      set(newValue) {
        api.listener?.({
          op: 6
          /* TestItemEventOp.DocumentSynced */
        });
        if (!propComparators.range(value, newValue)) {
          value = newValue;
          api.listener?.(updateProps(newValue));
        }
      }
    };
  })(),
  label: testItemPropAccessor(api, label, propComparators.label, evSetProps((label2) => ({ label: label2 }))),
  description: testItemPropAccessor(api, void 0, propComparators.description, evSetProps((description) => ({ description }))),
  sortText: testItemPropAccessor(api, void 0, propComparators.sortText, evSetProps((sortText) => ({ sortText }))),
  canResolveChildren: testItemPropAccessor(api, false, propComparators.canResolveChildren, (state) => ({
    op: 2,
    state
  })),
  busy: testItemPropAccessor(api, false, propComparators.busy, evSetProps((busy) => ({ busy }))),
  error: testItemPropAccessor(api, void 0, propComparators.error, evSetProps((error) => ({ error: MarkdownString4.fromStrict(error) || null }))),
  tags: testItemPropAccessor(api, [], propComparators.tags, (current, previous) => ({
    op: 1,
    new: current.map(TestTag3.from),
    old: previous.map(TestTag3.from)
  }))
});
var toItemFromPlain = (item) => {
  const testId = TestId.fromString(item.extId);
  const testItem = new TestItemImpl(testId.controllerId, testId.localId, item.label, URI.revive(item.uri) || void 0);
  testItem.range = Range4.to(item.range || void 0);
  testItem.description = item.description || void 0;
  testItem.sortText = item.sortText || void 0;
  testItem.tags = item.tags.map((t) => TestTag3.to({ id: denamespaceTestTag(t).tagId }));
  return testItem;
};
var toItemFromContext = (context) => {
  let node;
  for (const test of context.tests) {
    const next = toItemFromPlain(test.item);
    getPrivateApiFor(next).parent = node;
    node = next;
  }
  return node;
};
var TestItemImpl = class _TestItemImpl {
  /**
   * Note that data is deprecated and here for back-compat only
   */
  constructor(controllerId, id2, label, uri) {
    if (id2.includes(
      "\0"
      /* TestIdPathParts.Delimiter */
    )) {
      throw new Error(`Test IDs may not include the ${JSON.stringify(id2)} symbol`);
    }
    const api = createPrivateApiFor(this, controllerId);
    Object.defineProperties(this, {
      id: {
        value: id2,
        enumerable: true,
        writable: false
      },
      uri: {
        value: uri,
        enumerable: true,
        writable: false
      },
      parent: {
        enumerable: false,
        get() {
          return api.parent instanceof TestItemRootImpl ? void 0 : api.parent;
        }
      },
      children: {
        value: createTestItemChildren(api, getPrivateApiFor, _TestItemImpl),
        enumerable: true,
        writable: false
      },
      ...makePropDescriptors(api, label)
    });
  }
};
var TestItemRootImpl = class extends TestItemImpl {
  constructor(controllerId, label) {
    super(controllerId, controllerId, label, void 0);
    this._isRoot = true;
  }
};
var ExtHostTestItemCollection = class extends TestItemCollection {
  constructor(controllerId, controllerLabel, editors) {
    super({
      controllerId,
      getDocumentVersion: (uri) => uri && editors.getDocument(uri)?.version,
      getApiFor: getPrivateApiFor,
      getChildren: (item) => item.children,
      root: new TestItemRootImpl(controllerId, controllerLabel),
      toITestItem: TestItem.from
    });
  }
};

// out-build/vs/workbench/api/common/extHostTelemetry.js
var ExtHostTelemetry = class ExtHostTelemetry2 extends Disposable {
  constructor(isWorker, initData, loggerService) {
    super();
    this.initData = initData;
    this._onDidChangeTelemetryEnabled = this._register(new Emitter());
    this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event;
    this._onDidChangeTelemetryConfiguration = this._register(new Emitter());
    this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event;
    this._productConfig = { usage: true, error: true };
    this._level = 0;
    this._inLoggingOnlyMode = false;
    this._telemetryLoggers = /* @__PURE__ */ new Map();
    this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly;
    const id2 = initData.remote.isRemote ? "remoteExtHostTelemetry" : isWorker ? "workerExtHostTelemetry" : "extHostTelemetry";
    this._outputLogger = this._register(loggerService.createLogger(id2, {
      name: localize(3022, null, this._inLoggingOnlyMode ? " (Not Sent)" : ""),
      hidden: true,
      group: TelemetryLogGroup
    }));
  }
  getTelemetryConfiguration() {
    return this._level === 3;
  }
  getTelemetryDetails() {
    return {
      isCrashEnabled: this._level >= 1,
      isErrorsEnabled: this._productConfig.error ? this._level >= 2 : false,
      isUsageEnabled: this._productConfig.usage ? this._level >= 3 : false
    };
  }
  instantiateLogger(extension, sender, options2) {
    const telemetryDetails = this.getTelemetryDetails();
    const logger = new ExtHostTelemetryLogger(sender, options2, extension, this._outputLogger, this._inLoggingOnlyMode, this.getBuiltInCommonProperties(extension), { isUsageEnabled: telemetryDetails.isUsageEnabled, isErrorsEnabled: telemetryDetails.isErrorsEnabled });
    const loggers = this._telemetryLoggers.get(extension.identifier.value) ?? [];
    this._telemetryLoggers.set(extension.identifier.value, [...loggers, logger]);
    return logger.apiTelemetryLogger;
  }
  $initializeTelemetryLevel(level, supportsTelemetry, productConfig) {
    this._level = level;
    this._productConfig = productConfig ?? { usage: true, error: true };
  }
  getBuiltInCommonProperties(extension) {
    const commonProperties = /* @__PURE__ */ Object.create(null);
    commonProperties["common.extname"] = `${extension.publisher}.${extension.name}`;
    commonProperties["common.extversion"] = extension.version;
    commonProperties["common.vscodemachineid"] = this.initData.telemetryInfo.machineId;
    commonProperties["common.vscodesessionid"] = this.initData.telemetryInfo.sessionId;
    commonProperties["common.vscodecommithash"] = this.initData.commit;
    commonProperties["common.sqmid"] = this.initData.telemetryInfo.sqmId;
    commonProperties["common.devDeviceId"] = this.initData.telemetryInfo.devDeviceId ?? this.initData.telemetryInfo.machineId;
    commonProperties["common.vscodeversion"] = this.initData.version;
    commonProperties["common.vscodereleasedate"] = this.initData.date;
    commonProperties["common.isnewappinstall"] = isNewAppInstall(this.initData.telemetryInfo.firstSessionDate);
    commonProperties["common.product"] = this.initData.environment.appHost;
    switch (this.initData.uiKind) {
      case UIKind.Web:
        commonProperties["common.uikind"] = "web";
        break;
      case UIKind.Desktop:
        commonProperties["common.uikind"] = "desktop";
        break;
      default:
        commonProperties["common.uikind"] = "unknown";
    }
    commonProperties["common.remotename"] = getRemoteName(cleanRemoteAuthority(this.initData.remote.authority));
    return commonProperties;
  }
  $onDidChangeTelemetryLevel(level) {
    this._oldTelemetryEnablement = this.getTelemetryConfiguration();
    this._level = level;
    const telemetryDetails = this.getTelemetryDetails();
    this._telemetryLoggers.forEach((loggers, key) => {
      const newLoggers = loggers.filter((l) => !l.isDisposed);
      if (newLoggers.length === 0) {
        this._telemetryLoggers.delete(key);
      } else {
        this._telemetryLoggers.set(key, newLoggers);
      }
    });
    this._telemetryLoggers.forEach((loggers) => {
      for (const logger of loggers) {
        logger.updateTelemetryEnablements(telemetryDetails.isUsageEnabled, telemetryDetails.isErrorsEnabled);
      }
    });
    if (this._oldTelemetryEnablement !== this.getTelemetryConfiguration()) {
      this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration());
    }
    this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails());
  }
  onExtensionError(extension, error) {
    const loggers = this._telemetryLoggers.get(extension.value);
    const nonDisposedLoggers = loggers?.filter((l) => !l.isDisposed);
    if (!nonDisposedLoggers) {
      this._telemetryLoggers.delete(extension.value);
      return false;
    }
    let errorEmitted = false;
    for (const logger of nonDisposedLoggers) {
      if (logger.ignoreUnhandledExtHostErrors) {
        continue;
      }
      logger.logError(error);
      errorEmitted = true;
    }
    return errorEmitted;
  }
};
ExtHostTelemetry = __decorate([
  __param(1, IExtHostInitDataService),
  __param(2, ILoggerService)
], ExtHostTelemetry);
var ExtHostTelemetryLogger = class {
  static validateSender(sender) {
    if (typeof sender !== "object") {
      throw new TypeError("TelemetrySender argument is invalid");
    }
    if (typeof sender.sendEventData !== "function") {
      throw new TypeError("TelemetrySender.sendEventData must be a function");
    }
    if (typeof sender.sendErrorData !== "function") {
      throw new TypeError("TelemetrySender.sendErrorData must be a function");
    }
    if (typeof sender.flush !== "undefined" && typeof sender.flush !== "function") {
      throw new TypeError("TelemetrySender.flush must be a function or undefined");
    }
  }
  constructor(sender, options2, _extension, _logger, _inLoggingOnlyMode, _commonProperties, telemetryEnablements) {
    this._extension = _extension;
    this._logger = _logger;
    this._inLoggingOnlyMode = _inLoggingOnlyMode;
    this._commonProperties = _commonProperties;
    this._onDidChangeEnableStates = new Emitter();
    this.ignoreUnhandledExtHostErrors = options2?.ignoreUnhandledErrors ?? false;
    this._ignoreBuiltinCommonProperties = options2?.ignoreBuiltInCommonProperties ?? false;
    this._additionalCommonProperties = options2?.additionalCommonProperties;
    this._sender = sender;
    this._telemetryEnablements = { isUsageEnabled: telemetryEnablements.isUsageEnabled, isErrorsEnabled: telemetryEnablements.isErrorsEnabled };
  }
  updateTelemetryEnablements(isUsageEnabled, isErrorsEnabled) {
    if (this._apiObject) {
      this._telemetryEnablements = { isUsageEnabled, isErrorsEnabled };
      this._onDidChangeEnableStates.fire(this._apiObject);
    }
  }
  mixInCommonPropsAndCleanData(data2) {
    let updatedData = data2.properties ? data2.properties ?? {} : data2;
    updatedData = cleanData(updatedData, []);
    if (this._additionalCommonProperties) {
      updatedData = mixin(updatedData, this._additionalCommonProperties);
    }
    if (!this._ignoreBuiltinCommonProperties) {
      updatedData = mixin(updatedData, this._commonProperties);
    }
    if (data2.properties) {
      data2.properties = updatedData;
    } else {
      data2 = updatedData;
    }
    return data2;
  }
  logEvent(eventName, data2) {
    if (!this._sender) {
      return;
    }
    if (this._extension.publisher === "vscode") {
      eventName = this._extension.name + "/" + eventName;
    } else {
      eventName = this._extension.identifier.value + "/" + eventName;
    }
    data2 = this.mixInCommonPropsAndCleanData(data2 || {});
    if (!this._inLoggingOnlyMode) {
      this._sender?.sendEventData(eventName, data2);
    }
    this._logger.trace(eventName, data2);
  }
  logUsage(eventName, data2) {
    if (!this._telemetryEnablements.isUsageEnabled) {
      return;
    }
    this.logEvent(eventName, data2);
  }
  logError(eventNameOrException, data2) {
    if (!this._telemetryEnablements.isErrorsEnabled || !this._sender) {
      return;
    }
    if (typeof eventNameOrException === "string") {
      this.logEvent(eventNameOrException, data2);
    } else {
      const errorData = {
        name: eventNameOrException.name,
        message: eventNameOrException.message,
        stack: eventNameOrException.stack,
        cause: eventNameOrException.cause
      };
      const cleanedErrorData = cleanData(errorData, []);
      const cleanedError = new Error(typeof cleanedErrorData.message === "string" ? cleanedErrorData.message : void 0, {
        cause: cleanedErrorData.cause
      });
      cleanedError.stack = typeof cleanedErrorData.stack === "string" ? cleanedErrorData.stack : void 0;
      cleanedError.name = typeof cleanedErrorData.name === "string" ? cleanedErrorData.name : "unknown";
      data2 = this.mixInCommonPropsAndCleanData(data2 || {});
      if (!this._inLoggingOnlyMode) {
        this._sender.sendErrorData(cleanedError, data2);
      }
      this._logger.trace("exception", data2);
    }
  }
  get apiTelemetryLogger() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        logUsage: that.logUsage.bind(that),
        get isUsageEnabled() {
          return that._telemetryEnablements.isUsageEnabled;
        },
        get isErrorsEnabled() {
          return that._telemetryEnablements.isErrorsEnabled;
        },
        logError: that.logError.bind(that),
        dispose: that.dispose.bind(that),
        onDidChangeEnableStates: that._onDidChangeEnableStates.event.bind(that)
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  get isDisposed() {
    return !this._sender;
  }
  dispose() {
    if (this._sender?.flush) {
      let tempSender = this._sender;
      this._sender = void 0;
      Promise.resolve(tempSender.flush()).then(tempSender = void 0);
      this._apiObject = void 0;
    } else {
      this._sender = void 0;
    }
  }
};
function isNewAppInstall(firstSessionDate) {
  const installAge = Date.now() - new Date(firstSessionDate).getTime();
  return isNaN(installAge) ? false : installAge < 1e3 * 60 * 60 * 24;
}
var IExtHostTelemetry = createDecorator("IExtHostTelemetry");

// out-build/vs/workbench/api/common/extHostCommands.js
var ExtHostCommands = class ExtHostCommands2 {
  #proxy;
  #telemetry;
  #extHostTelemetry;
  constructor(extHostRpc, logService, extHostTelemetry) {
    this._commands = /* @__PURE__ */ new Map();
    this._apiCommands = /* @__PURE__ */ new Map();
    this.#proxy = extHostRpc.getProxy(MainContext.MainThreadCommands);
    this._logService = logService;
    this.#extHostTelemetry = extHostTelemetry;
    this.#telemetry = extHostRpc.getProxy(MainContext.MainThreadTelemetry);
    this.converter = new CommandsConverter(this, (id2) => {
      const candidate = this._apiCommands.get(id2);
      return candidate?.result === ApiCommandResult.Void ? candidate : void 0;
    }, logService);
    this._argumentProcessors = [
      {
        processArgument(a) {
          return revive(a);
        }
      },
      {
        processArgument(arg) {
          return cloneAndChange(arg, function(obj) {
            if (Range.isIRange(obj)) {
              return Range4.to(obj);
            }
            if (Position.isIPosition(obj)) {
              return Position4.to(obj);
            }
            if (Range.isIRange(obj.range) && URI.isUri(obj.uri)) {
              return location.to(obj);
            }
            if (obj instanceof VSBuffer) {
              return obj.buffer.buffer;
            }
            if (!Array.isArray(obj)) {
              return obj;
            }
          });
        }
      }
    ];
  }
  registerArgumentProcessor(processor) {
    this._argumentProcessors.push(processor);
  }
  registerApiCommand(apiCommand) {
    const registration = this.registerCommand(false, apiCommand.id, async (...apiArgs) => {
      const internalArgs = apiCommand.args.map((arg, i) => {
        if (!arg.validate(apiArgs[i])) {
          throw new Error(`Invalid argument '${arg.name}' when running '${apiCommand.id}', received: ${typeof apiArgs[i] === "object" ? JSON.stringify(apiArgs[i], null, "	") : apiArgs[i]} `);
        }
        return arg.convert(apiArgs[i]);
      });
      const internalResult = await this.executeCommand(apiCommand.internalId, ...internalArgs);
      return apiCommand.result.convert(internalResult, apiArgs, this.converter);
    }, void 0, {
      description: apiCommand.description,
      args: apiCommand.args,
      returns: apiCommand.result.description
    });
    this._apiCommands.set(apiCommand.id, apiCommand);
    return new Disposable2(() => {
      registration.dispose();
      this._apiCommands.delete(apiCommand.id);
    });
  }
  registerCommand(global, id2, callback, thisArg, metadata, extension) {
    this._logService.trace("ExtHostCommands#registerCommand", id2);
    if (!id2.trim().length) {
      throw new Error("invalid id");
    }
    if (this._commands.has(id2)) {
      throw new Error(`command '${id2}' already exists`);
    }
    this._commands.set(id2, { callback, thisArg, metadata, extension });
    if (global) {
      this.#proxy.$registerCommand(id2);
    }
    return new Disposable2(() => {
      if (this._commands.delete(id2)) {
        if (global) {
          this.#proxy.$unregisterCommand(id2);
        }
      }
    });
  }
  executeCommand(id2, ...args) {
    this._logService.trace("ExtHostCommands#executeCommand", id2);
    return this._doExecuteCommand(id2, args, true);
  }
  async _doExecuteCommand(id2, args, retry) {
    if (this._commands.has(id2)) {
      this.#proxy.$fireCommandActivationEvent(id2);
      return this._executeContributedCommand(id2, args, false);
    } else {
      let hasBuffers = false;
      const toArgs = cloneAndChange(args, function(value) {
        if (value instanceof Position2) {
          return Position4.from(value);
        } else if (value instanceof Range2) {
          return Range4.from(value);
        } else if (value instanceof Location) {
          return location.from(value);
        } else if (NotebookRange.isNotebookRange(value)) {
          return NotebookRange2.from(value);
        } else if (value instanceof ArrayBuffer) {
          hasBuffers = true;
          return VSBuffer.wrap(new Uint8Array(value));
        } else if (value instanceof Uint8Array) {
          hasBuffers = true;
          return VSBuffer.wrap(value);
        } else if (value instanceof VSBuffer) {
          hasBuffers = true;
          return value;
        }
        if (!Array.isArray(value)) {
          return value;
        }
      });
      try {
        const result = await this.#proxy.$executeCommand(id2, hasBuffers ? new SerializableObjectWithBuffers(toArgs) : toArgs, retry);
        return revive(result);
      } catch (e) {
        if (e instanceof Error && e.message === "$executeCommand:retry") {
          return this._doExecuteCommand(id2, args, false);
        } else {
          throw e;
        }
      }
    }
  }
  async _executeContributedCommand(id2, args, annotateError) {
    const command = this._commands.get(id2);
    if (!command) {
      throw new Error("Unknown command");
    }
    const { callback, thisArg, metadata } = command;
    if (metadata?.args) {
      for (let i = 0; i < metadata.args.length; i++) {
        try {
          validateConstraint(args[i], metadata.args[i].constraint);
        } catch (err) {
          throw new Error(`Running the contributed command: '${id2}' failed. Illegal argument '${metadata.args[i].name}' - ${metadata.args[i].description}`);
        }
      }
    }
    const stopWatch = StopWatch.create();
    try {
      return await callback.apply(thisArg, args);
    } catch (err) {
      if (id2 === this.converter.delegatingCommandId) {
        const actual = this.converter.getActualCommand(...args);
        if (actual) {
          id2 = actual.command;
        }
      }
      if (!isCancellationError(err)) {
        this._logService.error(err, id2, command.extension?.identifier);
      }
      if (!annotateError) {
        throw err;
      }
      if (command.extension?.identifier) {
        const reported = this.#extHostTelemetry.onExtensionError(command.extension.identifier, err);
        this._logService.trace("forwarded error to extension?", reported, command.extension?.identifier);
      }
      throw new class CommandError extends Error {
        constructor() {
          super(toErrorMessage(err));
          this.id = id2;
          this.source = command.extension?.displayName ?? command.extension?.name;
        }
      }();
    } finally {
      this._reportTelemetry(command, id2, stopWatch.elapsed());
    }
  }
  _reportTelemetry(command, id2, duration) {
    if (!command.extension) {
      return;
    }
    if (id2.startsWith("code.copilot.logStructured")) {
      return;
    }
    this.#telemetry.$publicLog2("Extension:ActionExecuted", {
      extensionId: command.extension.identifier.value,
      id: new TelemetryTrustedValue(id2),
      duration
    });
  }
  $executeContributedCommand(id2, ...args) {
    this._logService.trace("ExtHostCommands#$executeContributedCommand", id2);
    const cmdHandler = this._commands.get(id2);
    if (!cmdHandler) {
      return Promise.reject(new Error(`Contributed command '${id2}' does not exist.`));
    } else {
      args = args.map((arg) => this._argumentProcessors.reduce((r, p) => p.processArgument(r, cmdHandler.extension), arg));
      return this._executeContributedCommand(id2, args, true);
    }
  }
  getCommands(filterUnderscoreCommands = false) {
    this._logService.trace("ExtHostCommands#getCommands", filterUnderscoreCommands);
    return this.#proxy.$getCommands().then((result) => {
      if (filterUnderscoreCommands) {
        result = result.filter((command) => command[0] !== "_");
      }
      return result;
    });
  }
  $getContributedCommandMetadata() {
    const result = /* @__PURE__ */ Object.create(null);
    for (const [id2, command] of this._commands) {
      const { metadata } = command;
      if (metadata) {
        result[id2] = metadata;
      }
    }
    return Promise.resolve(result);
  }
};
ExtHostCommands = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService),
  __param(2, IExtHostTelemetry)
], ExtHostCommands);
var IExtHostCommands = createDecorator("IExtHostCommands");
var CommandsConverter = class {
  // --- conversion between internal and api commands
  constructor(_commands, _lookupApiCommand, _logService) {
    this._commands = _commands;
    this._lookupApiCommand = _lookupApiCommand;
    this._logService = _logService;
    this.delegatingCommandId = `__vsc${generateUuid()}`;
    this._cache = /* @__PURE__ */ new Map();
    this._cachIdPool = 0;
    this._commands.registerCommand(true, this.delegatingCommandId, this._executeConvertedCommand, this);
  }
  toInternal(command, disposables) {
    if (!command) {
      return void 0;
    }
    const result = {
      $ident: void 0,
      id: command.command,
      title: command.title,
      tooltip: command.tooltip
    };
    if (!command.command) {
      return result;
    }
    const apiCommand = this._lookupApiCommand(command.command);
    if (apiCommand) {
      result.id = apiCommand.internalId;
      result.arguments = apiCommand.args.map((arg, i) => arg.convert(command.arguments && command.arguments[i]));
    } else if (isNonEmptyArray(command.arguments)) {
      const id2 = `${command.command} /${++this._cachIdPool}`;
      this._cache.set(id2, command);
      disposables.add(toDisposable(() => {
        this._cache.delete(id2);
        this._logService.trace("CommandsConverter#DISPOSE", id2);
      }));
      result.$ident = id2;
      result.id = this.delegatingCommandId;
      result.arguments = [id2];
      this._logService.trace("CommandsConverter#CREATE", command.command, id2);
    }
    return result;
  }
  fromInternal(command) {
    if (typeof command.$ident === "string") {
      return this._cache.get(command.$ident);
    } else {
      return {
        command: command.id,
        title: command.title,
        arguments: command.arguments
      };
    }
  }
  getActualCommand(...args) {
    return this._cache.get(args[0]);
  }
  _executeConvertedCommand(...args) {
    const actualCmd = this.getActualCommand(...args);
    this._logService.trace("CommandsConverter#EXECUTE", args[0], actualCmd ? actualCmd.command : "MISSING");
    if (!actualCmd) {
      return Promise.reject(`Actual command not found, wanted to execute ${args[0]}`);
    }
    return this._commands.executeCommand(actualCmd.command, ...actualCmd.arguments || []);
  }
};
var ApiCommandArgument = class _ApiCommandArgument {
  static {
    this.Uri = new _ApiCommandArgument("uri", "Uri of a text document", (v) => URI.isUri(v), (v) => v);
  }
  static {
    this.Position = new _ApiCommandArgument("position", "A position in a text document", (v) => Position2.isPosition(v), Position4.from);
  }
  static {
    this.Range = new _ApiCommandArgument("range", "A range in a text document", (v) => Range2.isRange(v), Range4.from);
  }
  static {
    this.Selection = new _ApiCommandArgument("selection", "A selection in a text document", (v) => Selection.isSelection(v), Selection3.from);
  }
  static {
    this.Number = new _ApiCommandArgument("number", "", (v) => typeof v === "number", (v) => v);
  }
  static {
    this.String = new _ApiCommandArgument("string", "", (v) => typeof v === "string", (v) => v);
  }
  static Arr(element) {
    return new _ApiCommandArgument(`${element.name}_array`, `Array of ${element.name}, ${element.description}`, (v) => Array.isArray(v) && v.every((e) => element.validate(e)), (v) => v.map((e) => element.convert(e)));
  }
  static {
    this.CallHierarchyItem = new _ApiCommandArgument("item", "A call hierarchy item", (v) => v instanceof CallHierarchyItem, CallHierarchyItem2.from);
  }
  static {
    this.TypeHierarchyItem = new _ApiCommandArgument("item", "A type hierarchy item", (v) => v instanceof TypeHierarchyItem, TypeHierarchyItem2.from);
  }
  static {
    this.TestItem = new _ApiCommandArgument("testItem", "A VS Code TestItem", (v) => v instanceof TestItemImpl, TestItem.from);
  }
  static {
    this.TestProfile = new _ApiCommandArgument("testProfile", "A VS Code test profile", (v) => v instanceof TestRunProfileBase, TestRunProfile.from);
  }
  constructor(name2, description, validate, convert) {
    this.name = name2;
    this.description = description;
    this.validate = validate;
    this.convert = convert;
  }
  optional() {
    return new _ApiCommandArgument(this.name, `(optional) ${this.description}`, (value) => value === void 0 || value === null || this.validate(value), (value) => value === void 0 ? void 0 : value === null ? null : this.convert(value));
  }
  with(name2, description) {
    return new _ApiCommandArgument(name2 ?? this.name, description ?? this.description, this.validate, this.convert);
  }
};
var ApiCommandResult = class _ApiCommandResult {
  static {
    this.Void = new _ApiCommandResult("no result", (v) => v);
  }
  constructor(description, convert) {
    this.description = description;
    this.convert = convert;
  }
};
var ApiCommand = class {
  constructor(id2, internalId, description, args, result) {
    this.id = id2;
    this.internalId = internalId;
    this.description = description;
    this.args = args;
    this.result = result;
  }
};

// out-build/vs/workbench/api/common/extHostTerminalService.js
var IExtHostTerminalService = createDecorator("IExtHostTerminalService");
var ExtHostTerminal = class extends Disposable {
  constructor(_proxy, _id, _creationOptions, _name) {
    super();
    this._proxy = _proxy;
    this._id = _id;
    this._creationOptions = _creationOptions;
    this._name = _name;
    this._disposed = false;
    this._state = { isInteractedWith: false, shell: void 0 };
    this.isOpen = false;
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this._creationOptions = Object.freeze(this._creationOptions);
    this._pidPromise = new Promise((c) => this._pidPromiseComplete = c);
    const that = this;
    this.value = {
      get name() {
        return that._name || "";
      },
      get processId() {
        return that._pidPromise;
      },
      get creationOptions() {
        return that._creationOptions;
      },
      get exitStatus() {
        return that._exitStatus;
      },
      get state() {
        return that._state;
      },
      get selection() {
        return that._selection;
      },
      get shellIntegration() {
        return that.shellIntegration;
      },
      sendText(text, shouldExecute = true) {
        that._checkDisposed();
        that._proxy.$sendText(that._id, text, shouldExecute);
      },
      show(preserveFocus) {
        that._checkDisposed();
        that._proxy.$show(that._id, preserveFocus);
      },
      hide() {
        that._checkDisposed();
        that._proxy.$hide(that._id);
      },
      dispose() {
        if (!that._disposed) {
          that._disposed = true;
          that._proxy.$dispose(that._id);
        }
      },
      get dimensions() {
        if (that._cols === void 0 || that._rows === void 0) {
          return void 0;
        }
        return {
          columns: that._cols,
          rows: that._rows
        };
      }
    };
  }
  dispose() {
    this._onWillDispose.fire();
    super.dispose();
  }
  async create(options2, internalOptions) {
    if (typeof this._id !== "string") {
      throw new Error("Terminal has already been created");
    }
    await this._proxy.$createTerminal(this._id, {
      name: options2.name,
      shellPath: options2.shellPath ?? void 0,
      shellArgs: options2.shellArgs ?? void 0,
      cwd: options2.cwd ?? internalOptions?.cwd ?? void 0,
      env: options2.env ?? void 0,
      icon: asTerminalIcon(options2.iconPath) ?? void 0,
      color: ThemeColor.isThemeColor(options2.color) ? options2.color.id : void 0,
      initialText: options2.message ?? void 0,
      strictEnv: options2.strictEnv ?? void 0,
      hideFromUser: options2.hideFromUser ?? void 0,
      forceShellIntegration: internalOptions?.forceShellIntegration ?? void 0,
      isFeatureTerminal: internalOptions?.isFeatureTerminal ?? void 0,
      isExtensionOwnedTerminal: true,
      useShellEnvironment: internalOptions?.useShellEnvironment ?? void 0,
      location: internalOptions?.location || this._serializeParentTerminal(options2.location, internalOptions?.resolvedExtHostIdentifier),
      isTransient: options2.isTransient ?? void 0,
      shellIntegrationNonce: options2.shellIntegrationNonce ?? void 0
    });
  }
  async createExtensionTerminal(location2, internalOptions, parentTerminal, iconPath, color, shellIntegrationNonce) {
    if (typeof this._id !== "string") {
      throw new Error("Terminal has already been created");
    }
    await this._proxy.$createTerminal(this._id, {
      name: this._name,
      isExtensionCustomPtyTerminal: true,
      icon: iconPath,
      color: ThemeColor.isThemeColor(color) ? color.id : void 0,
      location: internalOptions?.location || this._serializeParentTerminal(location2, parentTerminal),
      isTransient: true,
      shellIntegrationNonce: shellIntegrationNonce ?? void 0
    });
    if (typeof this._id === "string") {
      throw new Error("Terminal creation failed");
    }
    return this._id;
  }
  _serializeParentTerminal(location2, parentTerminal) {
    if (typeof location2 === "object") {
      if (hasKey(location2, { parentTerminal: true }) && location2.parentTerminal && parentTerminal) {
        return { parentTerminal };
      }
      if (hasKey(location2, { viewColumn: true })) {
        return { viewColumn: ViewColumn2.from(location2.viewColumn), preserveFocus: location2.preserveFocus };
      }
      return void 0;
    }
    return location2;
  }
  _checkDisposed() {
    if (this._disposed) {
      throw new Error("Terminal has already been disposed");
    }
  }
  set name(name2) {
    this._name = name2;
  }
  setExitStatus(code, reason) {
    this._exitStatus = Object.freeze({ code, reason });
  }
  setDimensions(cols, rows) {
    if (cols === this._cols && rows === this._rows) {
      return false;
    }
    if (cols === 0 || rows === 0) {
      return false;
    }
    this._cols = cols;
    this._rows = rows;
    return true;
  }
  setInteractedWith() {
    if (!this._state.isInteractedWith) {
      this._state = {
        ...this._state,
        isInteractedWith: true
      };
      return true;
    }
    return false;
  }
  setShellType(shellType) {
    if (this._state.shell !== shellType) {
      this._state = {
        ...this._state,
        shell: shellType
      };
      return true;
    }
    return false;
  }
  setSelection(selection) {
    this._selection = selection;
  }
  _setProcessId(processId) {
    if (this._pidPromiseComplete) {
      this._pidPromiseComplete(processId);
      this._pidPromiseComplete = void 0;
    } else {
      this._pidPromise.then((pid) => {
        if (pid !== processId) {
          this._pidPromise = Promise.resolve(processId);
        }
      });
    }
  }
};
var ExtHostPseudoterminal = class {
  get onProcessReady() {
    return this._onProcessReady.event;
  }
  constructor(_pty) {
    this._pty = _pty;
    this.id = 0;
    this.shouldPersist = false;
    this._onProcessData = new Emitter();
    this.onProcessData = this._onProcessData.event;
    this._onProcessReady = new Emitter();
    this._onDidChangeProperty = new Emitter();
    this.onDidChangeProperty = this._onDidChangeProperty.event;
    this._onProcessExit = new Emitter();
    this.onProcessExit = this._onProcessExit.event;
  }
  refreshProperty(property) {
    throw new Error(`refreshProperty is not suppported in extension owned terminals. property: ${property}`);
  }
  updateProperty(property, value) {
    throw new Error(`updateProperty is not suppported in extension owned terminals. property: ${property}, value: ${value}`);
  }
  async start() {
    return void 0;
  }
  shutdown() {
    this._pty.close();
  }
  input(data2) {
    this._pty.handleInput?.(data2);
  }
  sendSignal(signal) {
  }
  resize(cols, rows) {
    this._pty.setDimensions?.({ columns: cols, rows });
  }
  clearBuffer() {
  }
  async processBinary(data2) {
  }
  acknowledgeDataEvent(charCount) {
  }
  async setUnicodeVersion(version) {
  }
  getInitialCwd() {
    return Promise.resolve("");
  }
  getCwd() {
    return Promise.resolve("");
  }
  startSendingEvents(initialDimensions) {
    this._pty.onDidWrite((e) => this._onProcessData.fire(e));
    this._pty.onDidClose?.((e = void 0) => {
      this._onProcessExit.fire(e === void 0 ? void 0 : e);
    });
    this._pty.onDidOverrideDimensions?.((e) => {
      if (e) {
        this._onDidChangeProperty.fire({ type: "overrideDimensions", value: { cols: e.columns, rows: e.rows } });
      }
    });
    this._pty.onDidChangeName?.((title) => {
      this._onDidChangeProperty.fire({ type: "title", value: title });
    });
    this._pty.open(initialDimensions ? initialDimensions : void 0);
    if (initialDimensions) {
      this._pty.setDimensions?.(initialDimensions);
    }
    this._onProcessReady.fire({ pid: -1, cwd: "", windowsPty: void 0 });
  }
};
var nextLinkId = 1;
var BaseExtHostTerminalService = class BaseExtHostTerminalService2 extends Disposable {
  get activeTerminal() {
    return this._activeTerminal?.value;
  }
  get terminals() {
    return this._terminals.map((term) => term.value);
  }
  constructor(supportsProcesses, _extHostCommands, extHostRpc) {
    super();
    this._extHostCommands = _extHostCommands;
    this._terminals = [];
    this._terminalProcesses = /* @__PURE__ */ new Map();
    this._terminalProcessDisposables = {};
    this._extensionTerminalAwaitingStart = {};
    this._getTerminalPromises = {};
    this._environmentVariableCollections = /* @__PURE__ */ new Map();
    this._lastQuickFixCommands = this._register(new MutableDisposable());
    this._linkProviders = /* @__PURE__ */ new Set();
    this._completionProviders = /* @__PURE__ */ new Map();
    this._profileProviders = /* @__PURE__ */ new Map();
    this._quickFixProviders = /* @__PURE__ */ new Map();
    this._terminalLinkCache = /* @__PURE__ */ new Map();
    this._terminalLinkCancellationSource = /* @__PURE__ */ new Map();
    this._onDidCloseTerminal = new Emitter();
    this.onDidCloseTerminal = this._onDidCloseTerminal.event;
    this._onDidOpenTerminal = new Emitter();
    this.onDidOpenTerminal = this._onDidOpenTerminal.event;
    this._onDidChangeActiveTerminal = new Emitter();
    this.onDidChangeActiveTerminal = this._onDidChangeActiveTerminal.event;
    this._onDidChangeTerminalDimensions = new Emitter();
    this.onDidChangeTerminalDimensions = this._onDidChangeTerminalDimensions.event;
    this._onDidChangeTerminalState = new Emitter();
    this.onDidChangeTerminalState = this._onDidChangeTerminalState.event;
    this._onDidChangeShell = new Emitter();
    this.onDidChangeShell = this._onDidChangeShell.event;
    this._onDidWriteTerminalData = new Emitter({
      onWillAddFirstListener: () => this._proxy.$startSendingDataEvents(),
      onDidRemoveLastListener: () => this._proxy.$stopSendingDataEvents()
    });
    this.onDidWriteTerminalData = this._onDidWriteTerminalData.event;
    this._onDidExecuteCommand = new Emitter({
      onWillAddFirstListener: () => this._proxy.$startSendingCommandEvents(),
      onDidRemoveLastListener: () => this._proxy.$stopSendingCommandEvents()
    });
    this.onDidExecuteTerminalCommand = this._onDidExecuteCommand.event;
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadTerminalService);
    this._bufferer = new TerminalDataBufferer(this._proxy.$sendProcessData);
    this._proxy.$registerProcessSupport(supportsProcesses);
    this._extHostCommands.registerArgumentProcessor({
      processArgument: (arg) => {
        const deserialize = (arg2) => {
          return this.getTerminalById(arg2.instanceId)?.value;
        };
        switch (arg?.$mid) {
          case 15:
            return deserialize(arg);
          default: {
            if (Array.isArray(arg)) {
              for (let i = 0; i < arg.length; i++) {
                if (arg[i].$mid === 15) {
                  arg[i] = deserialize(arg[i]);
                } else {
                  break;
                }
              }
            }
            return arg;
          }
        }
      }
    });
    this._register({
      dispose: () => {
        for (const [_, terminalProcess] of this._terminalProcesses) {
          terminalProcess.shutdown(true);
        }
      }
    });
  }
  getDefaultShell(useAutomationShell) {
    const profile = useAutomationShell ? this._defaultAutomationProfile : this._defaultProfile;
    return profile?.path || "";
  }
  getDefaultShellArgs(useAutomationShell) {
    const profile = useAutomationShell ? this._defaultAutomationProfile : this._defaultProfile;
    return profile?.args || [];
  }
  createExtensionTerminal(options2, internalOptions) {
    const terminal = new ExtHostTerminal(this._proxy, generateUuid(), options2, options2.name);
    const p = new ExtHostPseudoterminal(options2.pty);
    terminal.createExtensionTerminal(options2.location, internalOptions, this._serializeParentTerminal(options2, internalOptions).resolvedExtHostIdentifier, asTerminalIcon(options2.iconPath), asTerminalColor(options2.color), options2.shellIntegrationNonce).then((id2) => {
      const disposable = this._setupExtHostProcessListeners(id2, p);
      this._terminalProcessDisposables[id2] = disposable;
    });
    this._terminals.push(terminal);
    return terminal.value;
  }
  _serializeParentTerminal(options2, internalOptions) {
    internalOptions = internalOptions ? internalOptions : {};
    if (options2.location && typeof options2.location === "object" && hasKey(options2.location, { parentTerminal: true })) {
      const parentTerminal = options2.location.parentTerminal;
      if (parentTerminal) {
        const parentExtHostTerminal = this._terminals.find((t) => t.value === parentTerminal);
        if (parentExtHostTerminal) {
          internalOptions.resolvedExtHostIdentifier = parentExtHostTerminal._id;
        }
      }
    } else if (options2.location && typeof options2.location !== "object") {
      internalOptions.location = options2.location;
    } else if (internalOptions.location && typeof internalOptions.location === "object" && hasKey(internalOptions.location, { splitActiveTerminal: true })) {
      internalOptions.location = { splitActiveTerminal: true };
    }
    return internalOptions;
  }
  attachPtyToTerminal(id2, pty) {
    const terminal = this.getTerminalById(id2);
    if (!terminal) {
      throw new Error(`Cannot resolve terminal with id ${id2} for virtual process`);
    }
    const p = new ExtHostPseudoterminal(pty);
    const disposable = this._setupExtHostProcessListeners(id2, p);
    this._terminalProcessDisposables[id2] = disposable;
  }
  async $acceptActiveTerminalChanged(id2) {
    const original = this._activeTerminal;
    if (id2 === null) {
      this._activeTerminal = void 0;
      if (original !== this._activeTerminal) {
        this._onDidChangeActiveTerminal.fire(this._activeTerminal);
      }
      return;
    }
    const terminal = this.getTerminalById(id2);
    if (terminal) {
      this._activeTerminal = terminal;
      if (original !== this._activeTerminal) {
        this._onDidChangeActiveTerminal.fire(this._activeTerminal.value);
      }
    }
  }
  async $acceptTerminalProcessData(id2, data2) {
    const terminal = this.getTerminalById(id2);
    if (terminal) {
      this._onDidWriteTerminalData.fire({ terminal: terminal.value, data: data2 });
    }
  }
  async $acceptTerminalDimensions(id2, cols, rows) {
    const terminal = this.getTerminalById(id2);
    if (terminal) {
      if (terminal.setDimensions(cols, rows)) {
        this._onDidChangeTerminalDimensions.fire({
          terminal: terminal.value,
          dimensions: terminal.value.dimensions
        });
      }
    }
  }
  async $acceptDidExecuteCommand(id2, command) {
    const terminal = this.getTerminalById(id2);
    if (terminal) {
      this._onDidExecuteCommand.fire({ terminal: terminal.value, ...command });
    }
  }
  async $acceptTerminalMaximumDimensions(id2, cols, rows) {
    this._terminalProcesses.get(id2)?.resize(cols, rows);
  }
  async $acceptTerminalTitleChange(id2, name2) {
    const terminal = this.getTerminalById(id2);
    if (terminal) {
      terminal.name = name2;
    }
  }
  async $acceptTerminalClosed(id2, exitCode, exitReason) {
    const index = this._getTerminalObjectIndexById(this._terminals, id2);
    if (index !== null) {
      const terminal = this._terminals.splice(index, 1)[0];
      terminal.setExitStatus(exitCode, exitReason);
      this._onDidCloseTerminal.fire(terminal.value);
    }
  }
  $acceptTerminalOpened(id2, extHostTerminalId, name2, shellLaunchConfigDto) {
    if (extHostTerminalId) {
      const index = this._getTerminalObjectIndexById(this._terminals, extHostTerminalId);
      if (index !== null) {
        this._terminals[index]._id = id2;
        this._onDidOpenTerminal.fire(this.terminals[index]);
        this._terminals[index].isOpen = true;
        return;
      }
    }
    const creationOptions = {
      name: shellLaunchConfigDto.name,
      shellPath: shellLaunchConfigDto.executable,
      shellArgs: shellLaunchConfigDto.args,
      cwd: typeof shellLaunchConfigDto.cwd === "string" ? shellLaunchConfigDto.cwd : URI.revive(shellLaunchConfigDto.cwd),
      env: shellLaunchConfigDto.env,
      hideFromUser: shellLaunchConfigDto.hideFromUser
    };
    const terminal = new ExtHostTerminal(this._proxy, id2, creationOptions, name2);
    this._terminals.push(terminal);
    this._onDidOpenTerminal.fire(terminal.value);
    terminal.isOpen = true;
  }
  async $acceptTerminalProcessId(id2, processId) {
    const terminal = this.getTerminalById(id2);
    terminal?._setProcessId(processId);
  }
  async $startExtensionTerminal(id2, initialDimensions) {
    const terminal = this.getTerminalById(id2);
    if (!terminal) {
      return { message: localize(3023, null, id2) };
    }
    if (!terminal.isOpen) {
      await new Promise((r) => {
        const listener = this.onDidOpenTerminal(async (e) => {
          if (e === terminal.value) {
            listener.dispose();
            r();
          }
        });
      });
    }
    const terminalProcess = this._terminalProcesses.get(id2);
    if (terminalProcess) {
      terminalProcess.startSendingEvents(initialDimensions);
    } else {
      this._extensionTerminalAwaitingStart[id2] = { initialDimensions };
    }
    return void 0;
  }
  _setupExtHostProcessListeners(id2, p) {
    const disposables = new DisposableStore();
    disposables.add(p.onProcessReady((e) => this._proxy.$sendProcessReady(id2, e.pid, e.cwd, e.windowsPty)));
    disposables.add(p.onDidChangeProperty((property) => this._proxy.$sendProcessProperty(id2, property)));
    this._bufferer.startBuffering(id2, p.onProcessData);
    disposables.add(p.onProcessExit((exitCode) => this._onProcessExit(id2, exitCode)));
    this._terminalProcesses.set(id2, p);
    const awaitingStart = this._extensionTerminalAwaitingStart[id2];
    if (awaitingStart && p instanceof ExtHostPseudoterminal) {
      p.startSendingEvents(awaitingStart.initialDimensions);
      delete this._extensionTerminalAwaitingStart[id2];
    }
    return disposables;
  }
  $acceptProcessAckDataEvent(id2, charCount) {
    this._terminalProcesses.get(id2)?.acknowledgeDataEvent(charCount);
  }
  $acceptProcessInput(id2, data2) {
    this._terminalProcesses.get(id2)?.input(data2);
  }
  $acceptTerminalInteraction(id2) {
    const terminal = this.getTerminalById(id2);
    if (terminal?.setInteractedWith()) {
      this._onDidChangeTerminalState.fire(terminal.value);
    }
  }
  $acceptTerminalSelection(id2, selection) {
    this.getTerminalById(id2)?.setSelection(selection);
  }
  $acceptProcessResize(id2, cols, rows) {
    try {
      this._terminalProcesses.get(id2)?.resize(cols, rows);
    } catch (error) {
      if (error.code !== "EPIPE" && error.code !== "ERR_IPC_CHANNEL_CLOSED") {
        throw error;
      }
    }
  }
  $acceptProcessShutdown(id2, immediate) {
    this._terminalProcesses.get(id2)?.shutdown(immediate);
  }
  $acceptProcessRequestInitialCwd(id2) {
    this._terminalProcesses.get(id2)?.getInitialCwd().then((initialCwd) => this._proxy.$sendProcessProperty(id2, { type: "initialCwd", value: initialCwd }));
  }
  $acceptProcessRequestCwd(id2) {
    this._terminalProcesses.get(id2)?.getCwd().then((cwd2) => this._proxy.$sendProcessProperty(id2, { type: "cwd", value: cwd2 }));
  }
  $acceptProcessRequestLatency(id2) {
    return Promise.resolve(id2);
  }
  registerProfileProvider(extension, id2, provider) {
    if (this._profileProviders.has(id2)) {
      throw new Error(`Terminal profile provider "${id2}" already registered`);
    }
    this._profileProviders.set(id2, provider);
    this._proxy.$registerProfileProvider(id2, extension.identifier.value);
    return new Disposable2(() => {
      this._profileProviders.delete(id2);
      this._proxy.$unregisterProfileProvider(id2);
    });
  }
  registerTerminalCompletionProvider(extension, provider, ...triggerCharacters) {
    if (this._completionProviders.has(extension.identifier.value)) {
      throw new Error(`Terminal completion provider "${extension.identifier.value}" already registered`);
    }
    this._completionProviders.set(extension.identifier.value, provider);
    this._proxy.$registerCompletionProvider(extension.identifier.value, extension.identifier.value, ...triggerCharacters);
    return new Disposable2(() => {
      this._completionProviders.delete(extension.identifier.value);
      this._proxy.$unregisterCompletionProvider(extension.identifier.value);
    });
  }
  async $provideTerminalCompletions(id2, options2) {
    const token = new CancellationTokenSource().token;
    if (token.isCancellationRequested || !this.activeTerminal) {
      return void 0;
    }
    const provider = this._completionProviders.get(id2);
    if (!provider) {
      return;
    }
    const completions = await provider.provideTerminalCompletions(this.activeTerminal, options2, token);
    if (completions === null || completions === void 0) {
      return void 0;
    }
    const pathSeparator = !isWindows || this.activeTerminal.state?.shell === "gitbash" ? "/" : "\\";
    return TerminalCompletionList2.from(completions, pathSeparator);
  }
  $acceptTerminalShellType(id2, shellType) {
    const terminal = this.getTerminalById(id2);
    if (terminal?.setShellType(shellType)) {
      this._onDidChangeTerminalState.fire(terminal.value);
    }
  }
  registerTerminalQuickFixProvider(id2, extensionId, provider) {
    if (this._quickFixProviders.has(id2)) {
      throw new Error(`Terminal quick fix provider "${id2}" is already registered`);
    }
    this._quickFixProviders.set(id2, provider);
    this._proxy.$registerQuickFixProvider(id2, extensionId);
    return new Disposable2(() => {
      this._quickFixProviders.delete(id2);
      this._proxy.$unregisterQuickFixProvider(id2);
    });
  }
  async $provideTerminalQuickFixes(id2, matchResult) {
    const token = new CancellationTokenSource().token;
    if (token.isCancellationRequested) {
      return;
    }
    const provider = this._quickFixProviders.get(id2);
    if (!provider) {
      return;
    }
    const quickFixes = await provider.provideTerminalQuickFixes(matchResult, token);
    if (quickFixes === null || Array.isArray(quickFixes) && quickFixes.length === 0) {
      return void 0;
    }
    const store = new DisposableStore();
    this._lastQuickFixCommands.value = store;
    if (!Array.isArray(quickFixes)) {
      return quickFixes ? TerminalQuickFix.from(quickFixes, this._extHostCommands.converter, store) : void 0;
    }
    const result = [];
    for (const fix of quickFixes) {
      const converted = TerminalQuickFix.from(fix, this._extHostCommands.converter, store);
      if (converted) {
        result.push(converted);
      }
    }
    return result;
  }
  async $createContributedProfileTerminal(id2, options2) {
    const token = new CancellationTokenSource().token;
    let profile = await this._profileProviders.get(id2)?.provideTerminalProfile(token);
    if (token.isCancellationRequested) {
      return;
    }
    if (profile && !hasKey(profile, { options: true })) {
      profile = { options: profile };
    }
    if (!profile || !hasKey(profile, { options: true })) {
      throw new Error(`No terminal profile options provided for id "${id2}"`);
    }
    if (hasKey(profile.options, { pty: true })) {
      this.createExtensionTerminal(profile.options, options2);
      return;
    }
    this.createTerminalFromOptions(profile.options, options2);
  }
  registerLinkProvider(provider) {
    this._linkProviders.add(provider);
    if (this._linkProviders.size === 1) {
      this._proxy.$startLinkProvider();
    }
    return new Disposable2(() => {
      this._linkProviders.delete(provider);
      if (this._linkProviders.size === 0) {
        this._proxy.$stopLinkProvider();
      }
    });
  }
  async $provideLinks(terminalId, line) {
    const terminal = this.getTerminalById(terminalId);
    if (!terminal) {
      return [];
    }
    this._terminalLinkCache.delete(terminalId);
    const oldToken = this._terminalLinkCancellationSource.get(terminalId);
    oldToken?.dispose(true);
    const cancellationSource = new CancellationTokenSource();
    this._terminalLinkCancellationSource.set(terminalId, cancellationSource);
    const result = [];
    const context = { terminal: terminal.value, line };
    const promises = [];
    for (const provider of this._linkProviders) {
      promises.push(Promises.withAsyncBody(async (r) => {
        cancellationSource.token.onCancellationRequested(() => r({ provider, links: [] }));
        const links = await provider.provideTerminalLinks(context, cancellationSource.token) || [];
        if (!cancellationSource.token.isCancellationRequested) {
          r({ provider, links });
        }
      }));
    }
    const provideResults = await Promise.all(promises);
    if (cancellationSource.token.isCancellationRequested) {
      return [];
    }
    const cacheLinkMap = /* @__PURE__ */ new Map();
    for (const provideResult of provideResults) {
      if (provideResult && provideResult.links.length > 0) {
        result.push(...provideResult.links.map((providerLink) => {
          const link2 = {
            id: nextLinkId++,
            startIndex: providerLink.startIndex,
            length: providerLink.length,
            label: providerLink.tooltip
          };
          cacheLinkMap.set(link2.id, {
            provider: provideResult.provider,
            link: providerLink
          });
          return link2;
        }));
      }
    }
    this._terminalLinkCache.set(terminalId, cacheLinkMap);
    return result;
  }
  $activateLink(terminalId, linkId) {
    const cachedLink = this._terminalLinkCache.get(terminalId)?.get(linkId);
    if (!cachedLink) {
      return;
    }
    cachedLink.provider.handleTerminalLink(cachedLink.link);
  }
  _onProcessExit(id2, exitCode) {
    this._bufferer.stopBuffering(id2);
    this._terminalProcesses.delete(id2);
    delete this._extensionTerminalAwaitingStart[id2];
    const processDiposable = this._terminalProcessDisposables[id2];
    if (processDiposable) {
      processDiposable.dispose();
      delete this._terminalProcessDisposables[id2];
    }
    this._proxy.$sendProcessExit(id2, exitCode);
  }
  getTerminalById(id2) {
    return this._getTerminalObjectById(this._terminals, id2);
  }
  getTerminalIdByApiObject(terminal) {
    const index = this._terminals.findIndex((item) => {
      return item.value === terminal;
    });
    return index >= 0 ? index : null;
  }
  _getTerminalObjectById(array, id2) {
    const index = this._getTerminalObjectIndexById(array, id2);
    return index !== null ? array[index] : null;
  }
  _getTerminalObjectIndexById(array, id2) {
    const index = array.findIndex((item) => {
      return item._id === id2;
    });
    return index >= 0 ? index : null;
  }
  getEnvironmentVariableCollection(extension) {
    let collection = this._environmentVariableCollections.get(extension.identifier.value);
    if (!collection) {
      collection = this._register(new UnifiedEnvironmentVariableCollection());
      this._setEnvironmentVariableCollection(extension.identifier.value, collection);
    }
    return collection.getScopedEnvironmentVariableCollection(void 0);
  }
  _syncEnvironmentVariableCollection(extensionIdentifier, collection) {
    const serialized = serializeEnvironmentVariableCollection(collection.map);
    const serializedDescription = serializeEnvironmentDescriptionMap(collection.descriptionMap);
    this._proxy.$setEnvironmentVariableCollection(extensionIdentifier, collection.persistent, serialized.length === 0 ? void 0 : serialized, serializedDescription);
  }
  $initEnvironmentVariableCollections(collections) {
    collections.forEach((entry) => {
      const extensionIdentifier = entry[0];
      const collection = this._register(new UnifiedEnvironmentVariableCollection(entry[1]));
      this._setEnvironmentVariableCollection(extensionIdentifier, collection);
    });
  }
  $acceptDefaultProfile(profile, automationProfile) {
    const oldProfile = this._defaultProfile;
    this._defaultProfile = profile;
    this._defaultAutomationProfile = automationProfile;
    if (oldProfile?.path !== profile.path) {
      this._onDidChangeShell.fire(profile.path);
    }
  }
  _setEnvironmentVariableCollection(extensionIdentifier, collection) {
    this._environmentVariableCollections.set(extensionIdentifier, collection);
    this._register(collection.onDidChangeCollection(() => {
      this._syncEnvironmentVariableCollection(extensionIdentifier, collection);
    }));
  }
};
BaseExtHostTerminalService = __decorate([
  __param(1, IExtHostCommands),
  __param(2, IExtHostRpcService)
], BaseExtHostTerminalService);
var UnifiedEnvironmentVariableCollection = class extends Disposable {
  get persistent() {
    return this._persistent;
  }
  set persistent(value) {
    this._persistent = value;
    this._onDidChangeCollection.fire();
  }
  get onDidChangeCollection() {
    return this._onDidChangeCollection && this._onDidChangeCollection.event;
  }
  constructor(serialized) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.scopedCollections = /* @__PURE__ */ new Map();
    this.descriptionMap = /* @__PURE__ */ new Map();
    this._persistent = true;
    this._onDidChangeCollection = new Emitter();
    this.map = new Map(serialized);
  }
  getScopedEnvironmentVariableCollection(scope) {
    const scopedCollectionKey = this.getScopeKey(scope);
    let scopedCollection = this.scopedCollections.get(scopedCollectionKey);
    if (!scopedCollection) {
      scopedCollection = new ScopedEnvironmentVariableCollection(this, scope);
      this.scopedCollections.set(scopedCollectionKey, scopedCollection);
      this._register(scopedCollection.onDidChangeCollection(() => this._onDidChangeCollection.fire()));
    }
    return scopedCollection;
  }
  replace(variable, value, options2, scope) {
    this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Replace, options: options2 ?? { applyAtProcessCreation: true }, scope });
  }
  append(variable, value, options2, scope) {
    this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Append, options: options2 ?? { applyAtProcessCreation: true }, scope });
  }
  prepend(variable, value, options2, scope) {
    this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Prepend, options: options2 ?? { applyAtProcessCreation: true }, scope });
  }
  _setIfDiffers(variable, mutator) {
    if (mutator.options && mutator.options.applyAtProcessCreation === false && !mutator.options.applyAtShellIntegration) {
      throw new Error("EnvironmentVariableMutatorOptions must apply at either process creation or shell integration");
    }
    const key = this.getKey(variable, mutator.scope);
    const current = this.map.get(key);
    const newOptions = mutator.options ? {
      applyAtProcessCreation: mutator.options.applyAtProcessCreation ?? false,
      applyAtShellIntegration: mutator.options.applyAtShellIntegration ?? false
    } : {
      applyAtProcessCreation: true
    };
    if (!current || current.value !== mutator.value || current.type !== mutator.type || current.options?.applyAtProcessCreation !== newOptions.applyAtProcessCreation || current.options?.applyAtShellIntegration !== newOptions.applyAtShellIntegration || current.scope?.workspaceFolder?.index !== mutator.scope?.workspaceFolder?.index) {
      const key2 = this.getKey(variable, mutator.scope);
      const value = {
        variable,
        ...mutator,
        options: newOptions
      };
      this.map.set(key2, value);
      this._onDidChangeCollection.fire();
    }
  }
  get(variable, scope) {
    const key = this.getKey(variable, scope);
    const value = this.map.get(key);
    return value ? convertMutator(value) : void 0;
  }
  getKey(variable, scope) {
    const scopeKey = this.getScopeKey(scope);
    return scopeKey.length ? `${variable}:::${scopeKey}` : variable;
  }
  getScopeKey(scope) {
    return this.getWorkspaceKey(scope?.workspaceFolder) ?? "";
  }
  getWorkspaceKey(workspaceFolder) {
    return workspaceFolder ? workspaceFolder.uri.toString() : void 0;
  }
  getVariableMap(scope) {
    const map = /* @__PURE__ */ new Map();
    for (const [_, value] of this.map) {
      if (this.getScopeKey(value.scope) === this.getScopeKey(scope)) {
        map.set(value.variable, convertMutator(value));
      }
    }
    return map;
  }
  delete(variable, scope) {
    const key = this.getKey(variable, scope);
    this.map.delete(key);
    this._onDidChangeCollection.fire();
  }
  clear(scope) {
    if (scope?.workspaceFolder) {
      for (const [key, mutator] of this.map) {
        if (mutator.scope?.workspaceFolder?.index === scope.workspaceFolder.index) {
          this.map.delete(key);
        }
      }
      this.clearDescription(scope);
    } else {
      this.map.clear();
      this.descriptionMap.clear();
    }
    this._onDidChangeCollection.fire();
  }
  setDescription(description, scope) {
    const key = this.getScopeKey(scope);
    const current = this.descriptionMap.get(key);
    if (!current || current.description !== description) {
      let descriptionStr;
      if (typeof description === "string") {
        descriptionStr = description;
      } else {
        descriptionStr = description?.value.split("\n\n")[0];
      }
      const value = { description: descriptionStr, scope };
      this.descriptionMap.set(key, value);
      this._onDidChangeCollection.fire();
    }
  }
  getDescription(scope) {
    const key = this.getScopeKey(scope);
    return this.descriptionMap.get(key)?.description;
  }
  clearDescription(scope) {
    const key = this.getScopeKey(scope);
    this.descriptionMap.delete(key);
  }
};
var ScopedEnvironmentVariableCollection = class {
  get persistent() {
    return this.collection.persistent;
  }
  set persistent(value) {
    this.collection.persistent = value;
  }
  get onDidChangeCollection() {
    return this._onDidChangeCollection && this._onDidChangeCollection.event;
  }
  constructor(collection, scope) {
    this.collection = collection;
    this.scope = scope;
    this._onDidChangeCollection = new Emitter();
  }
  getScoped(scope) {
    return this.collection.getScopedEnvironmentVariableCollection(scope);
  }
  replace(variable, value, options2) {
    this.collection.replace(variable, value, options2, this.scope);
  }
  append(variable, value, options2) {
    this.collection.append(variable, value, options2, this.scope);
  }
  prepend(variable, value, options2) {
    this.collection.prepend(variable, value, options2, this.scope);
  }
  get(variable) {
    return this.collection.get(variable, this.scope);
  }
  forEach(callback, thisArg) {
    this.collection.getVariableMap(this.scope).forEach((value, variable) => callback.call(thisArg, variable, value, this), this.scope);
  }
  [Symbol.iterator]() {
    return this.collection.getVariableMap(this.scope).entries();
  }
  delete(variable) {
    this.collection.delete(variable, this.scope);
    this._onDidChangeCollection.fire(void 0);
  }
  clear() {
    this.collection.clear(this.scope);
  }
  set description(description) {
    this.collection.setDescription(description, this.scope);
  }
  get description() {
    return this.collection.getDescription(this.scope);
  }
};
var WorkerExtHostTerminalService = class WorkerExtHostTerminalService2 extends BaseExtHostTerminalService {
  constructor(extHostCommands, extHostRpc) {
    super(false, extHostCommands, extHostRpc);
  }
  createTerminal(name2, shellPath, shellArgs) {
    throw new NotSupportedError();
  }
  createTerminalFromOptions(options2, internalOptions) {
    throw new NotSupportedError();
  }
};
WorkerExtHostTerminalService = __decorate([
  __param(0, IExtHostCommands),
  __param(1, IExtHostRpcService)
], WorkerExtHostTerminalService);
function asTerminalIcon(iconPath) {
  if (!iconPath || typeof iconPath === "string") {
    return void 0;
  }
  if (!hasKey(iconPath, { id: true })) {
    return iconPath;
  }
  return {
    id: iconPath.id,
    color: iconPath.color
  };
}
function asTerminalColor(color) {
  return ThemeColor.isThemeColor(color) ? color : void 0;
}
function convertMutator(mutator) {
  const newMutator = { ...mutator };
  delete newMutator.scope;
  newMutator.options = newMutator.options ?? void 0;
  return newMutator;
}

// out-build/vs/platform/progress/common/progress.js
var IProgressService = createDecorator("progressService");
var ProgressLocation3;
(function(ProgressLocation4) {
  ProgressLocation4[ProgressLocation4["Explorer"] = 1] = "Explorer";
  ProgressLocation4[ProgressLocation4["Scm"] = 3] = "Scm";
  ProgressLocation4[ProgressLocation4["Extensions"] = 5] = "Extensions";
  ProgressLocation4[ProgressLocation4["Window"] = 10] = "Window";
  ProgressLocation4[ProgressLocation4["Notification"] = 15] = "Notification";
  ProgressLocation4[ProgressLocation4["Dialog"] = 20] = "Dialog";
})(ProgressLocation3 || (ProgressLocation3 = {}));
var emptyProgressRunner = Object.freeze({
  total() {
  },
  worked() {
  },
  done() {
  }
});
var Progress = class {
  static {
    this.None = Object.freeze({ report() {
    } });
  }
  get value() {
    return this._value;
  }
  constructor(callback) {
    this.callback = callback;
  }
  report(item) {
    this._value = item;
    this.callback(this._value);
  }
};
var UnmanagedProgress = class UnmanagedProgress2 extends Disposable {
  constructor(options2, progressService) {
    super();
    this.deferred = new DeferredPromise();
    progressService.withProgress(options2, (reporter) => {
      this.reporter = reporter;
      if (this.lastStep) {
        reporter.report(this.lastStep);
      }
      return this.deferred.p;
    });
    this._register(toDisposable(() => this.deferred.complete()));
  }
  report(step) {
    if (this.reporter) {
      this.reporter.report(step);
    } else {
      this.lastStep = step;
    }
  }
};
UnmanagedProgress = __decorate([
  __param(1, IProgressService)
], UnmanagedProgress);
var IEditorProgressService = createDecorator("editorProgressService");

// out-build/vs/workbench/contrib/chat/common/modelPicker/modelPickerWidget.js
var DEFAULT_MODEL_PICKER_CATEGORY = { label: localize(6456, null), order: Number.MAX_SAFE_INTEGER };

// out-build/vs/workbench/services/authentication/common/authentication.js
var INTERNAL_AUTH_PROVIDER_PREFIX = "__";
function isAuthenticationWwwAuthenticateRequest(obj) {
  return typeof obj === "object" && obj !== null && "wwwAuthenticate" in obj && typeof obj.wwwAuthenticate === "string";
}
var IAuthenticationService = createDecorator("IAuthenticationService");
var IAuthenticationExtensionsService = createDecorator("IAuthenticationExtensionsService");

// out-build/vs/base/common/oauth.js
var WELL_KNOWN_ROUTE = "/.well-known";
var AUTH_PROTECTED_RESOURCE_METADATA_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/oauth-protected-resource`;
var AUTH_SERVER_METADATA_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/oauth-authorization-server`;
var OPENID_CONNECT_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/openid-configuration`;
var AUTH_SCOPE_SEPARATOR = " ";
var AuthorizationErrorType;
(function(AuthorizationErrorType2) {
  AuthorizationErrorType2["InvalidRequest"] = "invalid_request";
  AuthorizationErrorType2["InvalidClient"] = "invalid_client";
  AuthorizationErrorType2["InvalidGrant"] = "invalid_grant";
  AuthorizationErrorType2["UnauthorizedClient"] = "unauthorized_client";
  AuthorizationErrorType2["UnsupportedGrantType"] = "unsupported_grant_type";
  AuthorizationErrorType2["InvalidScope"] = "invalid_scope";
})(AuthorizationErrorType || (AuthorizationErrorType = {}));
var AuthorizationDeviceCodeErrorType;
(function(AuthorizationDeviceCodeErrorType2) {
  AuthorizationDeviceCodeErrorType2["AuthorizationPending"] = "authorization_pending";
  AuthorizationDeviceCodeErrorType2["SlowDown"] = "slow_down";
  AuthorizationDeviceCodeErrorType2["AccessDenied"] = "access_denied";
  AuthorizationDeviceCodeErrorType2["ExpiredToken"] = "expired_token";
})(AuthorizationDeviceCodeErrorType || (AuthorizationDeviceCodeErrorType = {}));
var AuthorizationRegistrationErrorType;
(function(AuthorizationRegistrationErrorType2) {
  AuthorizationRegistrationErrorType2["InvalidRedirectUri"] = "invalid_redirect_uri";
  AuthorizationRegistrationErrorType2["InvalidClientMetadata"] = "invalid_client_metadata";
  AuthorizationRegistrationErrorType2["InvalidSoftwareStatement"] = "invalid_software_statement";
  AuthorizationRegistrationErrorType2["UnapprovedSoftwareStatement"] = "unapproved_software_statement";
})(AuthorizationRegistrationErrorType || (AuthorizationRegistrationErrorType = {}));
function isAuthorizationProtectedResourceMetadata(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const metadata = obj;
  if (!metadata.resource) {
    return false;
  }
  if (metadata.scopes_supported !== void 0 && !Array.isArray(metadata.scopes_supported)) {
    return false;
  }
  return true;
}
var urisToCheck = [
  "issuer",
  "authorization_endpoint",
  "token_endpoint",
  "registration_endpoint",
  "jwks_uri"
];
function isAuthorizationServerMetadata(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const metadata = obj;
  if (!metadata.issuer) {
    throw new Error("Authorization server metadata must have an issuer");
  }
  for (const uri of urisToCheck) {
    if (!metadata[uri]) {
      continue;
    }
    if (typeof metadata[uri] !== "string") {
      throw new Error(`Authorization server metadata '${uri}' must be a string`);
    }
    if (!metadata[uri].startsWith("https://") && !metadata[uri].startsWith("http://")) {
      throw new Error(`Authorization server metadata '${uri}' must start with http:// or https://`);
    }
  }
  return true;
}
function isAuthorizationDynamicClientRegistrationResponse(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const response = obj;
  return response.client_id !== void 0;
}
function isAuthorizationTokenResponse(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const response = obj;
  return response.access_token !== void 0 && response.token_type !== void 0;
}
function isAuthorizationErrorResponse(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const response = obj;
  return response.error !== void 0;
}
function isAuthorizationRegistrationErrorResponse(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const response = obj;
  return response.error !== void 0;
}
function getDefaultMetadataForUrl(authorizationServer) {
  return {
    issuer: authorizationServer.toString(),
    authorization_endpoint: new URL("/authorize", authorizationServer).toString(),
    token_endpoint: new URL("/token", authorizationServer).toString(),
    registration_endpoint: new URL("/register", authorizationServer).toString(),
    // Default values for Dynamic OpenID Providers
    // https://openid.net/specs/openid-connect-discovery-1_0.html
    response_types_supported: ["code", "id_token", "id_token token"]
  };
}
var grantTypesSupported = ["authorization_code", "refresh_token", "urn:ietf:params:oauth:grant-type:device_code"];
var DEFAULT_AUTH_FLOW_PORT = 33418;
async function fetchDynamicRegistration(serverMetadata, clientName, scopes) {
  if (!serverMetadata.registration_endpoint) {
    throw new Error("Server does not support dynamic registration");
  }
  const requestBody = {
    client_name: clientName,
    client_uri: "https://code.visualstudio.com",
    grant_types: serverMetadata.grant_types_supported ? serverMetadata.grant_types_supported.filter((gt2) => grantTypesSupported.includes(gt2)) : grantTypesSupported,
    response_types: ["code"],
    redirect_uris: [
      "https://insiders.vscode.dev/redirect",
      "https://vscode.dev/redirect",
      "http://127.0.0.1/",
      // Added these for any server that might do
      // only exact match on the redirect URI even
      // though the spec says it should not care
      // about the port.
      `http://127.0.0.1:${DEFAULT_AUTH_FLOW_PORT}/`
    ],
    scope: scopes?.join(AUTH_SCOPE_SEPARATOR),
    token_endpoint_auth_method: "none",
    application_type: "native"
  };
  const response = await fetch(serverMetadata.registration_endpoint, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(requestBody)
  });
  if (!response.ok) {
    const result = await response.text();
    let errorDetails = result;
    try {
      const errorResponse = JSON.parse(result);
      if (isAuthorizationRegistrationErrorResponse(errorResponse)) {
        errorDetails = `${errorResponse.error}${errorResponse.error_description ? `: ${errorResponse.error_description}` : ""}`;
      }
    } catch {
    }
    throw new Error(`Registration to ${serverMetadata.registration_endpoint} failed: ${errorDetails}`);
  }
  const registration = await response.json();
  if (isAuthorizationDynamicClientRegistrationResponse(registration)) {
    return registration;
  }
  throw new Error(`Invalid authorization dynamic client registration response: ${JSON.stringify(registration)}`);
}
function parseWWWAuthenticateHeader(wwwAuthenticateHeaderValue) {
  const challenges = [];
  const tokens = [];
  let current = "";
  let inQuotes = false;
  for (let i = 0; i < wwwAuthenticateHeaderValue.length; i++) {
    const char = wwwAuthenticateHeaderValue[i];
    if (char === '"') {
      inQuotes = !inQuotes;
      current += char;
    } else if (char === "," && !inQuotes) {
      if (current.trim()) {
        tokens.push(current.trim());
      }
      current = "";
    } else {
      current += char;
    }
  }
  if (current.trim()) {
    tokens.push(current.trim());
  }
  let currentChallenge;
  for (const token of tokens) {
    const hasEquals = token.includes("=");
    if (!hasEquals) {
      if (currentChallenge) {
        challenges.push(currentChallenge);
      }
      currentChallenge = { scheme: token.trim(), params: {} };
    } else {
      const spaceIndex = token.indexOf(" ");
      if (spaceIndex > 0) {
        const beforeSpace = token.substring(0, spaceIndex);
        const afterSpace = token.substring(spaceIndex + 1);
        if (!beforeSpace.includes("=") && afterSpace.includes("=")) {
          if (currentChallenge) {
            challenges.push(currentChallenge);
          }
          currentChallenge = { scheme: beforeSpace.trim(), params: {} };
          const equalIndex = afterSpace.indexOf("=");
          if (equalIndex > 0) {
            const key = afterSpace.substring(0, equalIndex).trim();
            const value = afterSpace.substring(equalIndex + 1).trim().replace(/^"|"$/g, "");
            if (key && value !== void 0) {
              currentChallenge.params[key] = value;
            }
          }
          continue;
        }
      }
      if (currentChallenge) {
        const equalIndex = token.indexOf("=");
        if (equalIndex > 0) {
          const key = token.substring(0, equalIndex).trim();
          const value = token.substring(equalIndex + 1).trim().replace(/^"|"$/g, "");
          if (key && value !== void 0) {
            currentChallenge.params[key] = value;
          }
        }
      }
    }
  }
  if (currentChallenge) {
    challenges.push(currentChallenge);
  }
  return challenges;
}
function getClaimsFromJWT(token) {
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new Error("Invalid JWT token format: token must have three parts separated by dots");
  }
  const [header, payload, _signature] = parts;
  try {
    const decodedHeader = JSON.parse(decodeBase64(header).toString());
    if (typeof decodedHeader !== "object") {
      throw new Error("Invalid JWT token format: header is not a JSON object");
    }
    const decodedPayload = JSON.parse(decodeBase64(payload).toString());
    if (typeof decodedPayload !== "object") {
      throw new Error("Invalid JWT token format: payload is not a JSON object");
    }
    return decodedPayload;
  } catch (e) {
    if (e instanceof Error) {
      throw new Error(`Failed to parse JWT token: ${e.message}`);
    }
    throw new Error("Failed to parse JWT token");
  }
}
function scopesMatch(scopes1, scopes2) {
  if (scopes1 === scopes2) {
    return true;
  }
  if (!scopes1 || !scopes2) {
    return false;
  }
  if (scopes1.length !== scopes2.length) {
    return false;
  }
  const sortedScopes1 = [...scopes1].sort();
  const sortedScopes2 = [...scopes2].sort();
  return sortedScopes1.every((scope, index) => scope === sortedScopes2[index]);
}
async function fetchResourceMetadata(targetResource, resourceMetadataUrl, options2 = {}) {
  const { sameOriginHeaders = {}, fetch: fetchImpl = fetch } = options2;
  const targetResourceUrlObj = new URL(targetResource);
  let urlsToTry;
  if (!resourceMetadataUrl) {
    const pathComponent = targetResourceUrlObj.pathname === "/" ? void 0 : targetResourceUrlObj.pathname;
    const rootUrl = `${targetResourceUrlObj.origin}${AUTH_PROTECTED_RESOURCE_METADATA_DISCOVERY_PATH}`;
    if (pathComponent) {
      urlsToTry = [
        `${rootUrl}${pathComponent}`,
        rootUrl
      ];
    } else {
      urlsToTry = [rootUrl];
    }
  } else {
    urlsToTry = [resourceMetadataUrl];
  }
  const errors = [];
  for (const urlToTry of urlsToTry) {
    try {
      let headers = {
        "Accept": "application/json"
      };
      const resourceMetadataUrlObj = new URL(urlToTry);
      if (resourceMetadataUrlObj.origin === targetResourceUrlObj.origin) {
        headers = {
          ...headers,
          ...sameOriginHeaders
        };
      }
      const response = await fetchImpl(urlToTry, { method: "GET", headers });
      if (response.status !== 200) {
        let errorText;
        try {
          errorText = await response.text();
        } catch {
          errorText = response.statusText;
        }
        errors.push(new Error(`Failed to fetch resource metadata from ${urlToTry}: ${response.status} ${errorText}`));
        continue;
      }
      const body = await response.json();
      if (isAuthorizationProtectedResourceMetadata(body)) {
        const prmValue = new URL(body.resource).toString();
        const targetValue = targetResourceUrlObj.toString();
        if (prmValue !== targetValue) {
          throw new Error(`Protected Resource Metadata resource property value "${prmValue}" (length: ${prmValue.length}) does not match target server url "${targetValue}" (length: ${targetValue.length}). These MUST match to follow OAuth spec https://datatracker.ietf.org/doc/html/rfc9728#PRConfigurationValidation`);
        }
        return body;
      } else {
        errors.push(new Error(`Invalid resource metadata from ${urlToTry}. Expected to follow shape of https://datatracker.ietf.org/doc/html/rfc9728#name-protected-resource-metadata (Hints: is scopes_supported an array? Is resource a string?). Current payload: ${JSON.stringify(body)}`));
        continue;
      }
    } catch (e) {
      errors.push(e instanceof Error ? e : new Error(String(e)));
      continue;
    }
  }
  if (errors.length === 1) {
    throw errors[0];
  } else {
    throw new AggregateError(errors, "Failed to fetch resource metadata from all attempted URLs");
  }
}
async function tryParseAuthServerMetadata(response) {
  if (response.status !== 200) {
    return void 0;
  }
  try {
    const body = await response.json();
    if (isAuthorizationServerMetadata(body)) {
      return body;
    }
  } catch {
  }
  return void 0;
}
async function getErrText(res) {
  try {
    return await res.text();
  } catch {
    return res.statusText;
  }
}
async function fetchAuthorizationServerMetadata(authorizationServer, options2 = {}) {
  const { additionalHeaders = {}, fetch: fetchImpl = fetch } = options2;
  const authorizationServerUrl = new URL(authorizationServer);
  const extraPath = authorizationServerUrl.pathname === "/" ? "" : authorizationServerUrl.pathname;
  const errors = [];
  const doFetch = async (url) => {
    try {
      const rawResponse = await fetchImpl(url, {
        method: "GET",
        headers: {
          ...additionalHeaders,
          "Accept": "application/json"
        }
      });
      const metadata2 = await tryParseAuthServerMetadata(rawResponse);
      if (metadata2) {
        return metadata2;
      }
      errors.push(new Error(`Failed to fetch authorization server metadata from ${url}: ${rawResponse.status} ${await getErrText(rawResponse)}`));
      return void 0;
    } catch (e) {
      errors.push(e instanceof Error ? e : new Error(String(e)));
      return void 0;
    }
  };
  const pathToFetch = new URL(AUTH_SERVER_METADATA_DISCOVERY_PATH, authorizationServer).toString() + extraPath;
  let metadata = await doFetch(pathToFetch);
  if (metadata) {
    return metadata;
  }
  const openidPathInsertionUrl = new URL(OPENID_CONNECT_DISCOVERY_PATH, authorizationServer).toString() + extraPath;
  metadata = await doFetch(openidPathInsertionUrl);
  if (metadata) {
    return metadata;
  }
  const openidPathAdditionUrl = authorizationServer.endsWith("/") ? authorizationServer + OPENID_CONNECT_DISCOVERY_PATH.substring(1) : authorizationServer + OPENID_CONNECT_DISCOVERY_PATH;
  metadata = await doFetch(openidPathAdditionUrl);
  if (metadata) {
    return metadata;
  }
  if (errors.length === 1) {
    throw errors[0];
  } else {
    throw new AggregateError(errors, "Failed to fetch authorization server metadata from all attempted URLs");
  }
}

// out-build/vs/workbench/api/common/extHostWindow.js
var ExtHostWindow_1;
var ExtHostWindow = class ExtHostWindow2 {
  static {
    ExtHostWindow_1 = this;
  }
  static {
    this.InitialState = {
      focused: true,
      active: true
    };
  }
  getState() {
    const state = this._state;
    return {
      get focused() {
        return state.focused;
      },
      get active() {
        return state.active;
      }
    };
  }
  constructor(initData, extHostRpc) {
    this._onDidChangeWindowState = new Emitter();
    this.onDidChangeWindowState = this._onDidChangeWindowState.event;
    this._state = ExtHostWindow_1.InitialState;
    if (initData.handle) {
      this._nativeHandle = decodeBase64(initData.handle).buffer;
    }
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadWindow);
    this._proxy.$getInitialState().then(({ isFocused, isActive }) => {
      this.onDidChangeWindowProperty("focused", isFocused);
      this.onDidChangeWindowProperty("active", isActive);
    });
  }
  get nativeHandle() {
    return this._nativeHandle;
  }
  $onDidChangeActiveNativeWindowHandle(handle) {
    this._nativeHandle = handle ? decodeBase64(handle).buffer : void 0;
  }
  $onDidChangeWindowFocus(value) {
    this.onDidChangeWindowProperty("focused", value);
  }
  $onDidChangeWindowActive(value) {
    this.onDidChangeWindowProperty("active", value);
  }
  onDidChangeWindowProperty(property, value) {
    if (value === this._state[property]) {
      return;
    }
    this._state = { ...this._state, [property]: value };
    this._onDidChangeWindowState.fire(this._state);
  }
  openUri(stringOrUri, options2) {
    let uriAsString;
    if (typeof stringOrUri === "string") {
      uriAsString = stringOrUri;
      try {
        stringOrUri = URI.parse(stringOrUri);
      } catch (e) {
        return Promise.reject(`Invalid uri - '${stringOrUri}'`);
      }
    }
    if (isFalsyOrWhitespace(stringOrUri.scheme)) {
      return Promise.reject("Invalid scheme - cannot be empty");
    } else if (stringOrUri.scheme === Schemas.command) {
      return Promise.reject(`Invalid scheme '${stringOrUri.scheme}'`);
    }
    return this._proxy.$openUri(stringOrUri, uriAsString, options2);
  }
  async asExternalUri(uri, options2) {
    if (isFalsyOrWhitespace(uri.scheme)) {
      return Promise.reject("Invalid scheme - cannot be empty");
    }
    const result = await this._proxy.$asExternalUri(uri, options2);
    return URI.from(result);
  }
};
ExtHostWindow = ExtHostWindow_1 = __decorate([
  __param(0, IExtHostInitDataService),
  __param(1, IExtHostRpcService)
], ExtHostWindow);
var IExtHostWindow = createDecorator("IExtHostWindow");

// out-build/vs/workbench/api/common/extHostUrls.js
var ExtHostUrls_1;
var ExtHostUrls = class ExtHostUrls2 {
  static {
    ExtHostUrls_1 = this;
  }
  static {
    this.HandlePool = 0;
  }
  constructor(extHostRpc) {
    this.handles = new ExtensionIdentifierSet();
    this.handlers = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadUrls);
  }
  registerUriHandler(extension, handler) {
    const extensionId = extension.identifier;
    if (this.handles.has(extensionId)) {
      throw new Error(`Protocol handler already registered for extension ${extensionId}`);
    }
    const handle = ExtHostUrls_1.HandlePool++;
    this.handles.add(extensionId);
    this.handlers.set(handle, handler);
    this._proxy.$registerUriHandler(handle, extensionId, extension.displayName || extension.name);
    return toDisposable(() => {
      this.handles.delete(extensionId);
      this.handlers.delete(handle);
      this._proxy.$unregisterUriHandler(handle);
    });
  }
  $handleExternalUri(handle, uri) {
    const handler = this.handlers.get(handle);
    if (!handler) {
      return Promise.resolve(void 0);
    }
    try {
      handler.handleUri(URI.revive(uri));
    } catch (err) {
      onUnexpectedError(err);
    }
    return Promise.resolve(void 0);
  }
  async createAppUri(uri) {
    return URI.revive(await this._proxy.$createAppUri(uri));
  }
};
ExtHostUrls = ExtHostUrls_1 = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostUrls);
var IExtHostUrlsService = createDecorator("IExtHostUrlsService");

// out-build/vs/base/common/decorators.js
function createDecorator2(mapFn) {
  return (_target, key, descriptor) => {
    let fnKey = null;
    let fn = null;
    if (typeof descriptor.value === "function") {
      fnKey = "value";
      fn = descriptor.value;
    } else if (typeof descriptor.get === "function") {
      fnKey = "get";
      fn = descriptor.get;
    }
    if (!fn || typeof key === "symbol") {
      throw new Error("not supported");
    }
    descriptor[fnKey] = mapFn(fn, key);
  };
}
function debounce(delay, reducer, initialValueProvider) {
  return createDecorator2((fn, key) => {
    const timerKey = `$debounce$${key}`;
    const resultKey = `$debounce$result$${key}`;
    return function(...args) {
      if (!this[resultKey]) {
        this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
      }
      clearTimeout(this[timerKey]);
      if (reducer) {
        this[resultKey] = reducer(this[resultKey], ...args);
        args = [this[resultKey]];
      }
      this[timerKey] = setTimeout(() => {
        fn.apply(this, args);
        this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
      }, delay);
    };
  });
}
function throttle(delay, reducer, initialValueProvider) {
  return createDecorator2((fn, key) => {
    const timerKey = `$throttle$timer$${key}`;
    const resultKey = `$throttle$result$${key}`;
    const lastRunKey = `$throttle$lastRun$${key}`;
    const pendingKey = `$throttle$pending$${key}`;
    return function(...args) {
      if (!this[resultKey]) {
        this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
      }
      if (this[lastRunKey] === null || this[lastRunKey] === void 0) {
        this[lastRunKey] = -Number.MAX_VALUE;
      }
      if (reducer) {
        this[resultKey] = reducer(this[resultKey], ...args);
      }
      if (this[pendingKey]) {
        return;
      }
      const nextTime = this[lastRunKey] + delay;
      if (nextTime <= Date.now()) {
        this[lastRunKey] = Date.now();
        fn.apply(this, [this[resultKey]]);
        this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
      } else {
        this[pendingKey] = true;
        this[timerKey] = setTimeout(() => {
          this[pendingKey] = false;
          this[lastRunKey] = Date.now();
          fn.apply(this, [this[resultKey]]);
          this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
        }, nextTime - Date.now());
      }
    };
  });
}

// out-build/vs/workbench/api/common/extHostProgress.js
var IExtHostProgress = createDecorator("IExtHostProgress");
var ExtHostProgress = class ExtHostProgress2 {
  constructor(extHostRpc) {
    this._handles = 0;
    this._mapHandleToCancellationSource = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadProgress);
  }
  async withProgress(extension, options2, task) {
    const handle = this._handles++;
    const { title, location: location2, cancellable } = options2;
    const source = { label: extension.displayName || extension.name, id: extension.identifier.value };
    this._proxy.$startProgress(handle, { location: ProgressLocation2.from(location2), title, source, cancellable }, !extension.isUnderDevelopment ? extension.identifier.value : void 0).catch(onUnexpectedExternalError);
    return this._withProgress(handle, task, !!cancellable);
  }
  async withProgressFromSource(source, options2, task) {
    const handle = this._handles++;
    const { title, location: location2, cancellable } = options2;
    this._proxy.$startProgress(handle, { location: ProgressLocation2.from(location2), title, source, cancellable }, void 0).catch(onUnexpectedExternalError);
    return this._withProgress(handle, task, !!cancellable);
  }
  _withProgress(handle, task, cancellable) {
    let source;
    if (cancellable) {
      source = new CancellationTokenSource();
      this._mapHandleToCancellationSource.set(handle, source);
    }
    const progressEnd = (handle2) => {
      this._proxy.$progressEnd(handle2);
      this._mapHandleToCancellationSource.delete(handle2);
      source?.dispose();
    };
    let p;
    try {
      p = task(new ProgressCallback(this._proxy, handle), cancellable && source ? source.token : CancellationToken.None);
    } catch (err) {
      progressEnd(handle);
      throw err;
    }
    p.then((result) => progressEnd(handle), (err) => progressEnd(handle));
    return p;
  }
  $acceptProgressCanceled(handle) {
    const source = this._mapHandleToCancellationSource.get(handle);
    if (source) {
      source.cancel();
      this._mapHandleToCancellationSource.delete(handle);
    }
  }
};
ExtHostProgress = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostProgress);
function mergeProgress(result, currentValue) {
  result.message = currentValue.message;
  if (typeof currentValue.increment === "number") {
    if (typeof result.increment === "number") {
      result.increment += currentValue.increment;
    } else {
      result.increment = currentValue.increment;
    }
  }
  return result;
}
var ProgressCallback = class extends Progress {
  constructor(_proxy, _handle) {
    super((p) => this.throttledReport(p));
    this._proxy = _proxy;
    this._handle = _handle;
  }
  throttledReport(p) {
    this._proxy.$progressReport(this._handle, p);
  }
};
__decorate([
  throttle(100, (result, currentValue) => mergeProgress(result, currentValue), () => /* @__PURE__ */ Object.create(null))
], ProgressCallback.prototype, "throttledReport", null);

// out-build/vs/workbench/api/common/extHostAuthentication.js
var IExtHostAuthentication = createDecorator("IExtHostAuthentication");
var ExtHostAuthentication = class ExtHostAuthentication2 {
  constructor(extHostRpc, _initData, _extHostWindow, _extHostUrls, _extHostProgress, _extHostLoggerService, _logService) {
    this._initData = _initData;
    this._extHostWindow = _extHostWindow;
    this._extHostUrls = _extHostUrls;
    this._extHostProgress = _extHostProgress;
    this._extHostLoggerService = _extHostLoggerService;
    this._logService = _logService;
    this._dynamicAuthProviderCtor = DynamicAuthProvider;
    this._authenticationProviders = /* @__PURE__ */ new Map();
    this._providerOperations = new SequencerByKey();
    this._onDidChangeSessions = new Emitter();
    this._getSessionTaskSingler = new TaskSingler();
    this._onDidDynamicAuthProviderTokensChange = new Emitter();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadAuthentication);
  }
  /**
   * This sets up an event that will fire when the auth sessions change with a built-in filter for the extensionId
   * if a session change only affects a specific extension.
   * @param extensionId The extension that is interested in the event.
   * @returns An event with a built-in filter for the extensionId
   */
  getExtensionScopedSessionsEvent(extensionId) {
    const normalizedExtensionId = extensionId.toLowerCase();
    return Event.chain(this._onDidChangeSessions.event, ($) => $.filter((e) => !e.extensionIdFilter || e.extensionIdFilter.includes(normalizedExtensionId)).map((e) => ({ provider: e.provider })));
  }
  async getSession(requestingExtension, providerId, scopesOrRequest, options2 = {}) {
    const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);
    const keys = Object.keys(options2);
    const optionsStr = keys.map((key) => {
      switch (key) {
        case "account":
          return `${key}:${options2.account?.id}`;
        case "createIfNone":
        case "forceNewSession": {
          const value = typeof options2[key] === "boolean" ? `${options2[key]}` : `'${options2[key]?.detail}/${options2[key]?.learnMore?.toString()}'`;
          return `${key}:${value}`;
        }
        case "authorizationServer":
          return `${key}:${options2.authorizationServer?.toString(true)}`;
        default:
          return `${key}:${!!options2[key]}`;
      }
    }).sort().join(", ");
    let singlerKey;
    if (isAuthenticationWwwAuthenticateRequest(scopesOrRequest)) {
      const challenge = scopesOrRequest;
      const challengeStr = challenge.wwwAuthenticate;
      const scopesStr = challenge.fallbackScopes ? [...challenge.fallbackScopes].sort().join(" ") : "";
      singlerKey = `${extensionId} ${providerId} challenge:${challengeStr} ${scopesStr} ${optionsStr}`;
    } else {
      const sortedScopes = [...scopesOrRequest].sort().join(" ");
      singlerKey = `${extensionId} ${providerId} ${sortedScopes} ${optionsStr}`;
    }
    return await this._getSessionTaskSingler.getOrCreate(singlerKey, async () => {
      await this._proxy.$ensureProvider(providerId);
      const extensionName = requestingExtension.displayName || requestingExtension.name;
      return this._proxy.$getSession(providerId, scopesOrRequest, extensionId, extensionName, options2);
    });
  }
  async getAccounts(providerId) {
    await this._proxy.$ensureProvider(providerId);
    return await this._proxy.$getAccounts(providerId);
  }
  registerAuthenticationProvider(id2, label, provider, options2) {
    void this._providerOperations.queue(id2, async () => {
      if (this._authenticationProviders.get(id2)) {
        this._logService.error(`An authentication provider with id '${id2}' is already registered. The existing provider will not be replaced.`);
        return;
      }
      const listener = provider.onDidChangeSessions((e) => this._proxy.$sendDidChangeSessions(id2, e));
      this._authenticationProviders.set(id2, { label, provider, disposable: listener, options: options2 ?? { supportsMultipleAccounts: false } });
      await this._proxy.$registerAuthenticationProvider({
        id: id2,
        label,
        supportsMultipleAccounts: options2?.supportsMultipleAccounts ?? false,
        supportedAuthorizationServers: options2?.supportedAuthorizationServers,
        supportsChallenges: options2?.supportsChallenges
      });
    });
    return new Disposable2(() => {
      void this._providerOperations.queue(id2, async () => {
        const providerData = this._authenticationProviders.get(id2);
        if (providerData) {
          providerData.disposable?.dispose();
          this._authenticationProviders.delete(id2);
          await this._proxy.$unregisterAuthenticationProvider(id2);
        }
      });
    });
  }
  $createSession(providerId, scopes, options2) {
    return this._providerOperations.queue(providerId, async () => {
      const providerData = this._authenticationProviders.get(providerId);
      if (providerData) {
        options2.authorizationServer = URI.revive(options2.authorizationServer);
        return await providerData.provider.createSession(scopes, options2);
      }
      throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    });
  }
  $removeSession(providerId, sessionId) {
    return this._providerOperations.queue(providerId, async () => {
      const providerData = this._authenticationProviders.get(providerId);
      if (providerData) {
        return await providerData.provider.removeSession(sessionId);
      }
      throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    });
  }
  $getSessions(providerId, scopes, options2) {
    return this._providerOperations.queue(providerId, async () => {
      const providerData = this._authenticationProviders.get(providerId);
      if (providerData) {
        options2.authorizationServer = URI.revive(options2.authorizationServer);
        return await providerData.provider.getSessions(scopes, options2);
      }
      throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    });
  }
  $getSessionsFromChallenges(providerId, constraint, options2) {
    return this._providerOperations.queue(providerId, async () => {
      const providerData = this._authenticationProviders.get(providerId);
      if (providerData) {
        const provider = providerData.provider;
        if (typeof provider.getSessionsFromChallenges === "function") {
          options2.authorizationServer = URI.revive(options2.authorizationServer);
          return await provider.getSessionsFromChallenges(constraint, options2);
        }
        throw new Error(`Authentication provider with handle: ${providerId} does not support getSessionsFromChallenges`);
      }
      throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    });
  }
  $createSessionFromChallenges(providerId, constraint, options2) {
    return this._providerOperations.queue(providerId, async () => {
      const providerData = this._authenticationProviders.get(providerId);
      if (providerData) {
        const provider = providerData.provider;
        if (typeof provider.createSessionFromChallenges === "function") {
          options2.authorizationServer = URI.revive(options2.authorizationServer);
          return await provider.createSessionFromChallenges(constraint, options2);
        }
        throw new Error(`Authentication provider with handle: ${providerId} does not support createSessionFromChallenges`);
      }
      throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    });
  }
  $onDidChangeAuthenticationSessions(id2, label, extensionIdFilter) {
    if (!id2.startsWith(INTERNAL_AUTH_PROVIDER_PREFIX)) {
      this._onDidChangeSessions.fire({ provider: { id: id2, label }, extensionIdFilter });
    }
    return Promise.resolve();
  }
  $onDidUnregisterAuthenticationProvider(id2) {
    return this._providerOperations.queue(id2, async () => {
      const providerData = this._authenticationProviders.get(id2);
      if (providerData) {
        providerData.disposable?.dispose();
        this._authenticationProviders.delete(id2);
      }
    });
  }
  async $registerDynamicAuthProvider(authorizationServerComponents, serverMetadata, resourceMetadata, clientId, clientSecret, initialTokens) {
    if (!clientId) {
      const authorizationServer = URI.revive(authorizationServerComponents);
      if (serverMetadata.registration_endpoint) {
        try {
          const registration = await fetchDynamicRegistration(serverMetadata, this._initData.environment.appName, resourceMetadata?.scopes_supported);
          clientId = registration.client_id;
          clientSecret = registration.client_secret;
        } catch (err) {
          this._logService.warn(`Dynamic registration failed for ${authorizationServer.toString()}: ${err.message}. Prompting user for client ID and client secret...`);
        }
      }
      if (!clientId) {
        this._logService.info(`Prompting user for client registration details for ${authorizationServer.toString()}`);
        const clientDetails = await this._proxy.$promptForClientRegistration(authorizationServer.toString());
        if (!clientDetails) {
          throw new Error("User did not provide client details");
        }
        clientId = clientDetails.clientId;
        clientSecret = clientDetails.clientSecret;
        this._logService.info(`User provided client registration for ${authorizationServer.toString()}`);
        if (clientSecret) {
          this._logService.trace(`User provided client secret for ${authorizationServer.toString()}`);
        } else {
          this._logService.trace(`User did not provide client secret for ${authorizationServer.toString()}`);
        }
      }
    }
    const provider = new this._dynamicAuthProviderCtor(this._extHostWindow, this._extHostUrls, this._initData, this._extHostProgress, this._extHostLoggerService, this._proxy, URI.revive(authorizationServerComponents), serverMetadata, resourceMetadata, clientId, clientSecret, this._onDidDynamicAuthProviderTokensChange, initialTokens || []);
    await this._providerOperations.queue(provider.id, async () => {
      this._authenticationProviders.set(provider.id, {
        label: provider.label,
        provider,
        disposable: Disposable2.from(provider, provider.onDidChangeSessions((e) => this._proxy.$sendDidChangeSessions(provider.id, e)), provider.onDidChangeClientId(() => this._proxy.$sendDidChangeDynamicProviderInfo({
          providerId: provider.id,
          clientId: provider.clientId,
          clientSecret: provider.clientSecret
        }))),
        options: { supportsMultipleAccounts: true }
      });
      await this._proxy.$registerDynamicAuthenticationProvider({
        id: provider.id,
        label: provider.label,
        supportsMultipleAccounts: true,
        authorizationServer: authorizationServerComponents,
        resourceServer: resourceMetadata ? URI.parse(resourceMetadata.resource) : void 0,
        clientId: provider.clientId,
        clientSecret: provider.clientSecret
      });
    });
    return provider.id;
  }
  async $onDidChangeDynamicAuthProviderTokens(authProviderId, clientId, tokens) {
    this._onDidDynamicAuthProviderTokensChange.fire({ authProviderId, clientId, tokens });
  }
};
ExtHostAuthentication = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostWindow),
  __param(3, IExtHostUrlsService),
  __param(4, IExtHostProgress),
  __param(5, ILoggerService),
  __param(6, ILogService)
], ExtHostAuthentication);
var TaskSingler = class {
  constructor() {
    this._inFlightPromises = /* @__PURE__ */ new Map();
  }
  getOrCreate(key, promiseFactory) {
    const inFlight = this._inFlightPromises.get(key);
    if (inFlight) {
      return inFlight;
    }
    const promise = promiseFactory().finally(() => this._inFlightPromises.delete(key));
    this._inFlightPromises.set(key, promise);
    return promise;
  }
};
var DynamicAuthProvider = class DynamicAuthProvider2 {
  constructor(_extHostWindow, _extHostUrls, _initData, _extHostProgress, loggerService, _proxy, authorizationServer, _serverMetadata, _resourceMetadata, _clientId, _clientSecret, onDidDynamicAuthProviderTokensChange, initialTokens) {
    this._extHostWindow = _extHostWindow;
    this._extHostUrls = _extHostUrls;
    this._initData = _initData;
    this._extHostProgress = _extHostProgress;
    this._proxy = _proxy;
    this.authorizationServer = authorizationServer;
    this._serverMetadata = _serverMetadata;
    this._resourceMetadata = _resourceMetadata;
    this._clientId = _clientId;
    this._clientSecret = _clientSecret;
    this._onDidChangeSessions = new Emitter();
    this.onDidChangeSessions = this._onDidChangeSessions.event;
    this._onDidChangeClientId = new Emitter();
    this.onDidChangeClientId = this._onDidChangeClientId.event;
    const stringifiedServer = authorizationServer.toString(true);
    this.id = _resourceMetadata?.resource ? stringifiedServer + " " + _resourceMetadata?.resource : stringifiedServer;
    this.label = _resourceMetadata?.resource_name ?? this.authorizationServer.authority;
    this._logger = loggerService.createLogger(this.id, { name: `Auth: ${this.label}` });
    this._disposable = new DisposableStore();
    this._disposable.add(this._onDidChangeSessions);
    const scopedEvent = Event.chain(onDidDynamicAuthProviderTokensChange.event, ($) => $.filter((e) => e.authProviderId === this.id && e.clientId === _clientId).map((e) => e.tokens));
    this._tokenStore = this._disposable.add(new TokenStore({
      onDidChange: scopedEvent,
      set: (tokens) => _proxy.$setSessionsForDynamicAuthProvider(this.id, this.clientId, tokens)
    }, initialTokens, this._logger));
    this._disposable.add(this._tokenStore.onDidChangeSessions((e) => this._onDidChangeSessions.fire(e)));
    this._createFlows = [];
    if (_serverMetadata.authorization_endpoint) {
      this._createFlows.push({
        label: localize(3004, null),
        handler: (scopes, progress, token) => this._createWithUrlHandler(scopes, progress, token)
      });
    }
  }
  get clientId() {
    return this._clientId;
  }
  get clientSecret() {
    return this._clientSecret;
  }
  async getSessions(scopes, _options) {
    this._logger.info(`Getting sessions for scopes: ${scopes?.join(" ") ?? "all"}`);
    if (!scopes) {
      return this._tokenStore.sessions;
    }
    const sortedScopes = [...scopes].sort();
    const scopeStr = scopes.join(" ");
    let sessions = this._tokenStore.sessions.filter((session) => equals([...session.scopes].sort(), sortedScopes));
    this._logger.info(`Found ${sessions.length} sessions for scopes: ${scopeStr}`);
    if (sessions.length) {
      const newTokens = [];
      const removedTokens = [];
      const tokenMap = new Map(this._tokenStore.tokens.map((token) => [token.access_token, token]));
      for (const session of sessions) {
        const token = tokenMap.get(session.accessToken);
        if (token && token.expires_in) {
          const now = Date.now();
          const expiresInMS = token.expires_in * 1e3;
          if (now > token.created_at + expiresInMS - 5 * 60 * 1e3) {
            this._logger.info(`Token for session ${session.id} is about to expire, refreshing...`);
            removedTokens.push(token);
            if (!token.refresh_token) {
              this._logger.warn(`No refresh token available for scopes ${session.scopes.join(" ")}. Throwing away token.`);
              continue;
            }
            try {
              const newToken = await this.exchangeRefreshTokenForToken(token.refresh_token);
              if (newToken.scope !== scopeStr) {
                this._logger.warn(`Token scopes '${newToken.scope}' do not match requested scopes '${scopeStr}'. Overwriting token with what was requested...`);
                newToken.scope = scopeStr;
              }
              this._logger.info(`Successfully created a new token for scopes ${session.scopes.join(" ")}.`);
              newTokens.push(newToken);
            } catch (err) {
              this._logger.error(`Failed to refresh token: ${err}`);
            }
          }
        }
      }
      if (newTokens.length || removedTokens.length) {
        this._tokenStore.update({ added: newTokens, removed: removedTokens });
        sessions = this._tokenStore.sessions.filter((session) => equals([...session.scopes].sort(), sortedScopes));
      }
      this._logger.info(`Found ${sessions.length} sessions for scopes: ${scopeStr}`);
      return sessions;
    }
    return [];
  }
  async createSession(scopes, _options) {
    this._logger.info(`Creating session for scopes: ${scopes.join(" ")}`);
    let token;
    for (let i = 0; i < this._createFlows.length; i++) {
      const { handler } = this._createFlows[i];
      try {
        token = await this._extHostProgress.withProgressFromSource({ label: this.label, id: this.id }, {
          location: ProgressLocation.Notification,
          title: localize(3005, null, this.label),
          cancellable: true
        }, (progress, token2) => handler(scopes, progress, token2));
        if (token) {
          break;
        }
      } catch (err) {
        const nextMode = this._createFlows[i + 1]?.label;
        if (!nextMode) {
          break;
        }
        const message = isCancellationError(err) ? localize(3006, null, this.label, nextMode) : localize(3007, null, this.label, nextMode);
        const result = await this._proxy.$showContinueNotification(message);
        if (!result) {
          throw new CancellationError();
        }
        this._logger.error(`Failed to create token via flow '${nextMode}': ${err}`);
      }
    }
    if (!token) {
      throw new Error("Failed to create authentication token");
    }
    if (token.scope !== scopes.join(" ")) {
      this._logger.warn(`Token scopes '${token.scope}' do not match requested scopes '${scopes.join(" ")}'. Overwriting token with what was requested...`);
      token.scope = scopes.join(" ");
    }
    this._tokenStore.update({ added: [{ ...token, created_at: Date.now() }], removed: [] });
    const session = this._tokenStore.sessions.find((t) => t.accessToken === token.access_token);
    this._logger.info(`Created ${token.refresh_token ? "refreshable" : "non-refreshable"} session for scopes: ${token.scope}${token.expires_in ? ` that expires in ${token.expires_in} seconds` : ""}`);
    return session;
  }
  async removeSession(sessionId) {
    this._logger.info(`Removing session with id: ${sessionId}`);
    const session = this._tokenStore.sessions.find((session2) => session2.id === sessionId);
    if (!session) {
      this._logger.error(`Session with id ${sessionId} not found`);
      return;
    }
    const token = this._tokenStore.tokens.find((token2) => token2.access_token === session.accessToken);
    if (!token) {
      this._logger.error(`Failed to retrieve token for removed session: ${session.id}`);
      return;
    }
    this._tokenStore.update({ added: [], removed: [token] });
    this._logger.info(`Removed token for session: ${session.id} with scopes: ${session.scopes.join(" ")}`);
  }
  dispose() {
    this._disposable.dispose();
  }
  async _createWithUrlHandler(scopes, progress, token) {
    if (!this._serverMetadata.authorization_endpoint) {
      throw new Error("Authorization Endpoint required");
    }
    if (!this._serverMetadata.token_endpoint) {
      throw new Error("Token endpoint not available in server metadata");
    }
    const codeVerifier = this.generateRandomString(64);
    const codeChallenge = await this.generateCodeChallenge(codeVerifier);
    const nonce = this.generateRandomString(32);
    const callbackUri = URI.parse(`${this._initData.environment.appUriScheme}://dynamicauthprovider/${this.authorizationServer.authority}/authorize?nonce=${nonce}`);
    let state;
    try {
      state = await this._extHostUrls.createAppUri(callbackUri);
    } catch (error) {
      throw new Error(`Failed to create external URI: ${error}`);
    }
    const authorizationUrl = new URL(this._serverMetadata.authorization_endpoint);
    authorizationUrl.searchParams.append("client_id", this._clientId);
    authorizationUrl.searchParams.append("response_type", "code");
    authorizationUrl.searchParams.append("state", state.toString());
    authorizationUrl.searchParams.append("code_challenge", codeChallenge);
    authorizationUrl.searchParams.append("code_challenge_method", "S256");
    const scopeString = scopes.join(" ");
    if (scopeString) {
      authorizationUrl.searchParams.append("scope", scopeString);
    }
    if (this._resourceMetadata?.resource) {
      authorizationUrl.searchParams.append("resource", this._resourceMetadata.resource);
    }
    const redirectUri = "https://vscode.dev/redirect";
    authorizationUrl.searchParams.append("redirect_uri", redirectUri);
    const promise = this.waitForAuthorizationCode(callbackUri);
    this._logger.info(`Opening authorization URL for scopes: ${scopeString}`);
    this._logger.trace(`Authorization URL: ${authorizationUrl.toString()}`);
    const opened = await this._extHostWindow.openUri(authorizationUrl.toString(), {});
    if (!opened) {
      throw new CancellationError();
    }
    progress.report({
      message: localize(3008, null)
    });
    let code;
    try {
      const response = await raceCancellationError(promise, token);
      code = response.code;
    } catch (err) {
      if (isCancellationError(err)) {
        this._logger.info("Authorization code request was cancelled by the user.");
        throw err;
      }
      this._logger.error(`Failed to receive authorization code: ${err}`);
      throw new Error(`Failed to receive authorization code: ${err}`);
    }
    this._logger.info(`Authorization code received for scopes: ${scopeString}`);
    const tokenResponse = await this.exchangeCodeForToken(code, codeVerifier, redirectUri);
    return tokenResponse;
  }
  generateRandomString(length) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array).map((b) => b.toString(16).padStart(2, "0")).join("").substring(0, length);
  }
  async generateCodeChallenge(codeVerifier) {
    const encoder = new TextEncoder();
    const data2 = encoder.encode(codeVerifier);
    const digest = await crypto.subtle.digest("SHA-256", data2);
    return encodeBase64(VSBuffer.wrap(new Uint8Array(digest)), false, false).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  async waitForAuthorizationCode(expectedState) {
    const result = await this._proxy.$waitForUriHandler(expectedState);
    const codeMatch = /[?&]code=([^&]+)/.exec(result.query || "");
    if (!codeMatch || codeMatch.length < 2) {
      throw new Error("Authentication failed: No authorization code received");
    }
    return { code: codeMatch[1] };
  }
  async exchangeCodeForToken(code, codeVerifier, redirectUri) {
    if (!this._serverMetadata.token_endpoint) {
      throw new Error("Token endpoint not available in server metadata");
    }
    const tokenRequest = new URLSearchParams();
    tokenRequest.append("client_id", this._clientId);
    tokenRequest.append("grant_type", "authorization_code");
    tokenRequest.append("code", code);
    tokenRequest.append("redirect_uri", redirectUri);
    tokenRequest.append("code_verifier", codeVerifier);
    if (this._resourceMetadata?.resource) {
      tokenRequest.append("resource", this._resourceMetadata.resource);
    }
    if (this._clientSecret) {
      tokenRequest.append("client_secret", this._clientSecret);
    }
    this._logger.info("Exchanging authorization code for token...");
    this._logger.trace(`Url: ${this._serverMetadata.token_endpoint}`);
    this._logger.trace(`Token request body: ${tokenRequest.toString()}`);
    let response;
    try {
      response = await fetch(this._serverMetadata.token_endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Accept": "application/json"
        },
        body: tokenRequest.toString()
      });
    } catch (err) {
      this._logger.error(`Failed to exchange authorization code for token: ${err}`);
      throw new Error(`Failed to exchange authorization code for token: ${err}`);
    }
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Token exchange failed: ${response.status} ${response.statusText} - ${text}`);
    }
    const result = await response.json();
    if (isAuthorizationTokenResponse(result)) {
      this._logger.info(`Successfully exchanged authorization code for token.`);
      return result;
    } else if (isAuthorizationErrorResponse(result) && result.error === "invalid_client") {
      this._logger.warn(`Client ID (${this._clientId}) was invalid, generated a new one.`);
      await this._generateNewClientId();
      throw new Error(`Client ID was invalid, generated a new one. Please try again.`);
    }
    throw new Error(`Invalid authorization token response: ${JSON.stringify(result)}`);
  }
  async exchangeRefreshTokenForToken(refreshToken) {
    if (!this._serverMetadata.token_endpoint) {
      throw new Error("Token endpoint not available in server metadata");
    }
    const tokenRequest = new URLSearchParams();
    tokenRequest.append("client_id", this._clientId);
    tokenRequest.append("grant_type", "refresh_token");
    tokenRequest.append("refresh_token", refreshToken);
    if (this._resourceMetadata?.resource) {
      tokenRequest.append("resource", this._resourceMetadata.resource);
    }
    if (this._clientSecret) {
      tokenRequest.append("client_secret", this._clientSecret);
    }
    const response = await fetch(this._serverMetadata.token_endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json"
      },
      body: tokenRequest.toString()
    });
    const result = await response.json();
    if (isAuthorizationTokenResponse(result)) {
      return {
        ...result,
        created_at: Date.now()
      };
    } else if (isAuthorizationErrorResponse(result) && result.error === "invalid_client") {
      this._logger.warn(`Client ID (${this._clientId}) was invalid, generated a new one.`);
      await this._generateNewClientId();
      throw new Error(`Client ID was invalid, generated a new one. Please try again.`);
    }
    throw new Error(`Invalid authorization token response: ${JSON.stringify(result)}`);
  }
  async _generateNewClientId() {
    try {
      const registration = await fetchDynamicRegistration(this._serverMetadata, this._initData.environment.appName, this._resourceMetadata?.scopes_supported);
      this._clientId = registration.client_id;
      this._clientSecret = registration.client_secret;
      this._onDidChangeClientId.fire();
    } catch (err) {
      this._logger.info(`Dynamic registration failed for ${this.authorizationServer.toString()}: ${err}. Prompting user for client ID and client secret.`);
      try {
        const clientDetails = await this._proxy.$promptForClientRegistration(this.authorizationServer.toString());
        if (!clientDetails) {
          throw new Error("User did not provide client details");
        }
        this._clientId = clientDetails.clientId;
        this._clientSecret = clientDetails.clientSecret;
        this._logger.info(`User provided client ID for ${this.authorizationServer.toString()}`);
        if (clientDetails.clientSecret) {
          this._logger.info(`User provided client secret for ${this.authorizationServer.toString()}`);
        } else {
          this._logger.info(`User did not provide client secret for ${this.authorizationServer.toString()} (optional)`);
        }
        this._onDidChangeClientId.fire();
      } catch (promptErr) {
        this._logger.error(`Failed to fetch new client ID and user did not provide one: ${err}`);
        throw new Error(`Failed to fetch new client ID and user did not provide one: ${err}`);
      }
    }
  }
};
DynamicAuthProvider = __decorate([
  __param(0, IExtHostWindow),
  __param(1, IExtHostUrlsService),
  __param(2, IExtHostInitDataService),
  __param(3, IExtHostProgress),
  __param(4, ILoggerService)
], DynamicAuthProvider);
var TokenStore = class {
  constructor(_persistence, initialTokens, _logger) {
    this._persistence = _persistence;
    this._logger = _logger;
    this._onDidChangeSessions = new Emitter();
    this.onDidChangeSessions = this._onDidChangeSessions.event;
    this._disposable = new DisposableStore();
    this._tokensObservable = observableValue("tokens", initialTokens);
    this._sessionsObservable = derivedOpts({ equalsFn: (a, b) => equals(a, b, (a2, b2) => a2.accessToken === b2.accessToken) }, (reader) => this._tokensObservable.read(reader).map((t) => this._getSessionFromToken(t)));
    this._disposable.add(this._registerChangeEventAutorun());
    this._disposable.add(this._persistence.onDidChange((tokens) => this._tokensObservable.set(tokens, void 0)));
  }
  get tokens() {
    return this._tokensObservable.get();
  }
  get sessions() {
    return this._sessionsObservable.get();
  }
  dispose() {
    this._disposable.dispose();
  }
  update({ added, removed }) {
    this._logger.trace(`Updating tokens: added ${added.length}, removed ${removed.length}`);
    const currentTokens = [...this._tokensObservable.get()];
    for (const token of removed) {
      const index = currentTokens.findIndex((t) => t.access_token === token.access_token);
      if (index !== -1) {
        currentTokens.splice(index, 1);
      }
    }
    for (const token of added) {
      const index = currentTokens.findIndex((t) => t.access_token === token.access_token);
      if (index === -1) {
        currentTokens.push(token);
      } else {
        currentTokens[index] = token;
      }
    }
    if (added.length || removed.length) {
      this._tokensObservable.set(currentTokens, void 0);
      void this._persistence.set(currentTokens);
    }
    this._logger.trace(`Tokens updated: ${currentTokens.length} tokens stored.`);
  }
  _registerChangeEventAutorun() {
    let previousSessions = [];
    return autorun((reader) => {
      this._logger.trace("Checking for session changes...");
      const currentSessions = this._sessionsObservable.read(reader);
      if (previousSessions === currentSessions) {
        this._logger.trace("No session changes detected.");
        return;
      }
      if (!currentSessions || currentSessions.length === 0) {
        this._logger.trace("All sessions removed.");
        if (previousSessions.length > 0) {
          this._onDidChangeSessions.fire({
            added: [],
            removed: previousSessions,
            changed: []
          });
          previousSessions = [];
        }
        return;
      }
      const added = [];
      const removed = [];
      for (const current of currentSessions) {
        const exists = previousSessions.some((prev) => prev.accessToken === current.accessToken);
        if (!exists) {
          added.push(current);
        }
      }
      for (const prev of previousSessions) {
        const exists = currentSessions.some((current) => current.accessToken === prev.accessToken);
        if (!exists) {
          removed.push(prev);
        }
      }
      if (added.length > 0 || removed.length > 0) {
        this._logger.trace(`Sessions changed: added ${added.length}, removed ${removed.length}`);
        this._onDidChangeSessions.fire({ added, removed, changed: [] });
      }
      previousSessions = currentSessions;
    });
  }
  _getSessionFromToken(token) {
    let claims;
    if (token.id_token) {
      try {
        claims = getClaimsFromJWT(token.id_token);
      } catch (e) {
      }
    }
    if (!claims) {
      try {
        claims = getClaimsFromJWT(token.access_token);
      } catch (e) {
      }
    }
    const scopes = token.scope ? token.scope.split(" ") : claims?.scope ? claims.scope.split(" ") : [];
    return {
      id: stringHash(token.access_token, 0).toString(),
      accessToken: token.access_token,
      account: {
        id: claims?.sub || "unknown",
        // TODO: Don't say MCP...
        label: claims?.preferred_username || claims?.name || claims?.email || "MCP"
      },
      scopes,
      idToken: token.id_token
    };
  }
};

// out-build/vs/workbench/api/common/extHostLanguageModels.js
var ExtHostLanguageModels_1;
var IExtHostLanguageModels = createDecorator("IExtHostLanguageModels");
var LanguageModelResponse = class {
  constructor() {
    this._defaultStream = new AsyncIterableSource();
    this._isDone = false;
    const that = this;
    const [stream1, stream2] = AsyncIterableProducer.tee(that._defaultStream.asyncIterable);
    this.apiObject = {
      // result: promise,
      get stream() {
        return stream1;
      },
      get text() {
        return stream2.map((part) => {
          if (part instanceof LanguageModelTextPart) {
            return part.value;
          } else {
            return void 0;
          }
        }).coalesce();
      }
    };
  }
  handleResponsePart(parts) {
    if (this._isDone) {
      return;
    }
    const lmResponseParts = [];
    for (const part of Iterable.wrap(parts)) {
      let out;
      if (part.type === "text") {
        out = new LanguageModelTextPart(part.value, part.audience);
      } else if (part.type === "thinking") {
        out = new LanguageModelThinkingPart(part.value, part.id, part.metadata);
      } else if (part.type === "data") {
        out = new LanguageModelDataPart(part.data.buffer, part.mimeType, part.audience);
      } else {
        out = new LanguageModelToolCallPart(part.toolCallId, part.name, part.parameters);
      }
      lmResponseParts.push(out);
    }
    this._defaultStream.emitMany(lmResponseParts);
  }
  reject(err) {
    this._isDone = true;
    this._defaultStream.reject(err);
  }
  resolve() {
    this._isDone = true;
    this._defaultStream.resolve();
  }
};
var ExtHostLanguageModels = class ExtHostLanguageModels2 {
  static {
    ExtHostLanguageModels_1 = this;
  }
  static {
    this._idPool = 1;
  }
  constructor(extHostRpc, _logService, _extHostAuthentication) {
    this._logService = _logService;
    this._extHostAuthentication = _extHostAuthentication;
    this._onDidChangeModelAccess = new Emitter();
    this._onDidChangeProviders = new Emitter();
    this.onDidChangeProviders = this._onDidChangeProviders.event;
    this._onDidChangeModelProxyAvailability = new Emitter();
    this.onDidChangeModelProxyAvailability = this._onDidChangeModelProxyAvailability.event;
    this._languageModelProviders = /* @__PURE__ */ new Map();
    this._localModels = /* @__PURE__ */ new Map();
    this._modelAccessList = new ExtensionIdentifierMap();
    this._pendingRequest = /* @__PURE__ */ new Map();
    this._ignoredFileProviders = /* @__PURE__ */ new Map();
    this._languageAccessInformationExtensions = /* @__PURE__ */ new Set();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadLanguageModels);
  }
  dispose() {
    this._onDidChangeModelAccess.dispose();
    this._onDidChangeProviders.dispose();
    this._onDidChangeModelProxyAvailability.dispose();
  }
  registerLanguageModelChatProvider(extension, vendor, provider) {
    this._languageModelProviders.set(vendor, { extension, provider });
    this._proxy.$registerLanguageModelProvider(vendor);
    let providerChangeEventDisposable;
    if (provider.onDidChangeLanguageModelChatInformation) {
      providerChangeEventDisposable = provider.onDidChangeLanguageModelChatInformation(() => {
        this._proxy.$onLMProviderChange(vendor);
      });
    }
    return toDisposable(() => {
      this._languageModelProviders.delete(vendor);
      this._clearModelCache(vendor);
      providerChangeEventDisposable?.dispose();
      this._proxy.$unregisterProvider(vendor);
    });
  }
  // Helper function to clear the local cache for a specific vendor. There's no lookup, so this involves iterating over all models.
  _clearModelCache(vendor) {
    this._localModels.forEach((value, key) => {
      if (value.metadata.vendor === vendor) {
        this._localModels.delete(key);
      }
    });
  }
  async $provideLanguageModelChatInfo(vendor, options2, token) {
    const data2 = this._languageModelProviders.get(vendor);
    if (!data2) {
      return [];
    }
    const modelInformation = await data2.provider.provideLanguageModelChatInformation(options2, token) ?? [];
    const modelMetadataAndIdentifier = modelInformation.map((m) => {
      let auth;
      if (m.requiresAuthorization && isProposedApiEnabled(data2.extension, "chatProvider")) {
        auth = {
          providerLabel: data2.extension.displayName || data2.extension.name,
          accountLabel: typeof m.requiresAuthorization === "object" ? m.requiresAuthorization.label : void 0
        };
      }
      if (m.capabilities.editTools) {
        checkProposedApiEnabled(data2.extension, "chatProvider");
      }
      return {
        metadata: {
          extension: data2.extension.identifier,
          id: m.id,
          vendor,
          name: m.name ?? "",
          family: m.family ?? "",
          detail: m.detail,
          tooltip: m.tooltip,
          version: m.version,
          maxInputTokens: m.maxInputTokens,
          maxOutputTokens: m.maxOutputTokens,
          auth,
          isDefault: m.isDefault,
          isUserSelectable: m.isUserSelectable,
          statusIcon: m.statusIcon,
          modelPickerCategory: m.category ?? DEFAULT_MODEL_PICKER_CATEGORY,
          capabilities: m.capabilities ? {
            vision: m.capabilities.imageInput,
            editTools: m.capabilities.editTools,
            toolCalling: !!m.capabilities.toolCalling,
            agentMode: !!m.capabilities.toolCalling
          } : void 0
        },
        identifier: `${vendor}/${m.id}`
      };
    });
    this._clearModelCache(vendor);
    for (let i = 0; i < modelMetadataAndIdentifier.length; i++) {
      this._localModels.set(modelMetadataAndIdentifier[i].identifier, {
        metadata: modelMetadataAndIdentifier[i].metadata,
        info: modelInformation[i]
      });
    }
    return modelMetadataAndIdentifier;
  }
  async $startChatRequest(modelId, requestId, from, messages, options2, token) {
    const knownModel = this._localModels.get(modelId);
    if (!knownModel) {
      throw new Error("Model not found");
    }
    const data2 = this._languageModelProviders.get(knownModel.metadata.vendor);
    if (!data2) {
      throw new Error(`Language model provider for '${knownModel.metadata.id}' not found.`);
    }
    const queue = [];
    const sendNow = () => {
      if (queue.length > 0) {
        this._proxy.$reportResponsePart(requestId, new SerializableObjectWithBuffers(queue));
        queue.length = 0;
      }
    };
    const queueScheduler = new RunOnceScheduler(sendNow, 30);
    const sendSoon = (part) => {
      const newLen = queue.push(part);
      if (newLen > 30) {
        sendNow();
        queueScheduler.cancel();
      } else {
        queueScheduler.schedule();
      }
    };
    const progress = new Progress(async (fragment) => {
      if (token.isCancellationRequested) {
        this._logService.warn(`[CHAT](${data2.extension.identifier.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
        return;
      }
      let part;
      if (fragment instanceof LanguageModelToolCallPart) {
        part = { type: "tool_use", name: fragment.name, parameters: fragment.input, toolCallId: fragment.callId };
      } else if (fragment instanceof LanguageModelTextPart) {
        part = { type: "text", value: fragment.value, audience: fragment.audience };
      } else if (fragment instanceof LanguageModelDataPart) {
        part = { type: "data", mimeType: fragment.mimeType, data: VSBuffer.wrap(fragment.data), audience: fragment.audience };
      } else if (fragment instanceof LanguageModelThinkingPart) {
        part = { type: "thinking", value: fragment.value, id: fragment.id, metadata: fragment.metadata };
      }
      if (!part) {
        this._logService.warn(`[CHAT](${data2.extension.identifier.value}) UNKNOWN part ${JSON.stringify(fragment)}`);
        return;
      }
      sendSoon(part);
    });
    let value;
    try {
      value = data2.provider.provideLanguageModelChatResponse(knownModel.info, messages.value.map(LanguageModelChatMessage22.to), { ...options2, modelOptions: options2.modelOptions ?? {}, requestInitiator: ExtensionIdentifier.toKey(from), toolMode: options2.toolMode ?? LanguageModelChatToolMode.Auto }, progress, token);
    } catch (err) {
      throw err;
    }
    Promise.resolve(value).then(() => {
      sendNow();
      this._proxy.$reportResponseDone(requestId, void 0);
    }, (err) => {
      sendNow();
      this._proxy.$reportResponseDone(requestId, transformErrorForSerialization(err));
    });
  }
  //#region --- token counting
  $provideTokenLength(modelId, value, token) {
    const knownModel = this._localModels.get(modelId);
    if (!knownModel) {
      return Promise.resolve(0);
    }
    const data2 = this._languageModelProviders.get(knownModel.metadata.vendor);
    if (!data2) {
      return Promise.resolve(0);
    }
    return Promise.resolve(data2.provider.provideTokenCount(knownModel.info, value, token));
  }
  //#region --- making request
  async getDefaultLanguageModel(extension, forceResolveModels) {
    let defaultModelId;
    if (forceResolveModels) {
      await this.selectLanguageModels(extension, {});
    }
    for (const [modelIdentifier, modelData] of this._localModels) {
      if (modelData.metadata.isDefault) {
        defaultModelId = modelIdentifier;
        break;
      }
    }
    if (!defaultModelId && !forceResolveModels) {
      return this.getDefaultLanguageModel(extension, true);
    }
    return this.getLanguageModelByIdentifier(extension, defaultModelId);
  }
  async getLanguageModelByIdentifier(extension, modelId) {
    if (!modelId) {
      return void 0;
    }
    const model = this._localModels.get(modelId);
    if (!model) {
      return (await this.selectLanguageModels(extension, { id: modelId }))[0];
    }
    if (this._isUsingAuth(extension.identifier, model.metadata)) {
      await this._fakeAuthPopulate(model.metadata);
    }
    let apiObject;
    if (!apiObject) {
      const that = this;
      apiObject = {
        id: model.info.id,
        vendor: model.metadata.vendor,
        family: model.info.family,
        version: model.info.version,
        name: model.info.name,
        capabilities: {
          supportsImageToText: model.metadata.capabilities?.vision ?? false,
          supportsToolCalling: !!model.metadata.capabilities?.toolCalling,
          editToolsHint: model.metadata.capabilities?.editTools
        },
        maxInputTokens: model.metadata.maxInputTokens,
        countTokens(text, token) {
          if (!that._localModels.has(modelId)) {
            throw LanguageModelError.NotFound(modelId);
          }
          return that._computeTokenLength(modelId, text, token ?? CancellationToken.None);
        },
        sendRequest(messages, options2, token) {
          if (!that._localModels.has(modelId)) {
            throw LanguageModelError.NotFound(modelId);
          }
          return that._sendChatRequest(extension, modelId, messages, options2 ?? {}, token ?? CancellationToken.None);
        }
      };
      Object.freeze(apiObject);
    }
    return apiObject;
  }
  async selectLanguageModels(extension, selector) {
    const models = await this._proxy.$selectChatModels({ ...selector, extension: extension.identifier });
    const result = [];
    const modelPromises = models.map((identifier) => this.getLanguageModelByIdentifier(extension, identifier));
    const modelResults = await Promise.all(modelPromises);
    for (const model of modelResults) {
      if (model) {
        result.push(model);
      }
    }
    return result;
  }
  async _sendChatRequest(extension, languageModelId, messages, options2, token) {
    const internalMessages = this._convertMessages(extension, messages);
    const from = extension.identifier;
    const metadata = this._localModels.get(languageModelId)?.metadata;
    if (!metadata || !this._localModels.has(languageModelId)) {
      throw LanguageModelError.NotFound(`Language model '${languageModelId}' is unknown.`);
    }
    if (this._isUsingAuth(from, metadata)) {
      const success = await this._getAuthAccess(extension, { identifier: metadata.extension, displayName: metadata.auth.providerLabel }, options2.justification, false);
      if (!success || !this._modelAccessList.get(from)?.has(metadata.extension)) {
        throw LanguageModelError.NoPermissions(`Language model '${languageModelId}' cannot be used by '${from.value}'.`);
      }
    }
    const requestId = Math.random() * 1e6 | 0;
    const res = new LanguageModelResponse();
    this._pendingRequest.set(requestId, { languageModelId, res });
    try {
      await this._proxy.$tryStartChatRequest(from, languageModelId, requestId, new SerializableObjectWithBuffers(internalMessages), options2, token);
    } catch (error) {
      this._pendingRequest.delete(requestId);
      throw LanguageModelError.tryDeserialize(error) ?? error;
    }
    return res.apiObject;
  }
  _convertMessages(extension, messages) {
    const internalMessages = [];
    for (const message of messages) {
      if (message.role === LanguageModelChatMessageRole.System) {
        checkProposedApiEnabled(extension, "languageModelSystem");
      }
      internalMessages.push(LanguageModelChatMessage22.from(message));
    }
    return internalMessages;
  }
  async $acceptResponsePart(requestId, chunk) {
    const data2 = this._pendingRequest.get(requestId);
    if (data2) {
      data2.res.handleResponsePart(chunk.value);
    }
  }
  async $acceptResponseDone(requestId, error) {
    const data2 = this._pendingRequest.get(requestId);
    if (!data2) {
      return;
    }
    this._pendingRequest.delete(requestId);
    if (error) {
      data2.res.reject(LanguageModelError.tryDeserialize(error) ?? transformErrorFromSerialization(error));
    } else {
      data2.res.resolve();
    }
  }
  // BIG HACK: Using AuthenticationProviders to check access to Language Models
  async _getAuthAccess(from, to, justification, silent) {
    const providerId = INTERNAL_AUTH_PROVIDER_PREFIX + to.identifier.value;
    const session = await this._extHostAuthentication.getSession(from, providerId, [], { silent: true });
    if (session) {
      this.$updateModelAccesslist([{ from: from.identifier, to: to.identifier, enabled: true }]);
      return true;
    }
    if (silent) {
      return false;
    }
    try {
      const detail = justification ? localize(3014, null, to.displayName, justification) : void 0;
      await this._extHostAuthentication.getSession(from, providerId, [], { forceNewSession: { detail } });
      this.$updateModelAccesslist([{ from: from.identifier, to: to.identifier, enabled: true }]);
      return true;
    } catch (err) {
      return false;
    }
  }
  _isUsingAuth(from, toMetadata) {
    return !!toMetadata.auth && !ExtensionIdentifier.equals(toMetadata.extension, from);
  }
  async _fakeAuthPopulate(metadata) {
    if (!metadata.auth) {
      return;
    }
    for (const from of this._languageAccessInformationExtensions) {
      try {
        await this._getAuthAccess(from, { identifier: metadata.extension, displayName: "" }, void 0, true);
      } catch (err) {
        this._logService.error("Fake Auth request failed");
        this._logService.error(err);
      }
    }
  }
  async _computeTokenLength(modelId, value, token) {
    const data2 = this._localModels.get(modelId);
    if (!data2) {
      throw LanguageModelError.NotFound(`Language model '${modelId}' is unknown.`);
    }
    return this._languageModelProviders.get(data2.metadata.vendor)?.provider.provideTokenCount(data2.info, value, token) ?? 0;
  }
  $updateModelAccesslist(data2) {
    const updated = new Array();
    for (const { from, to, enabled } of data2) {
      const set = this._modelAccessList.get(from) ?? new ExtensionIdentifierSet();
      const oldValue = set.has(to);
      if (oldValue !== enabled) {
        if (enabled) {
          set.add(to);
        } else {
          set.delete(to);
        }
        this._modelAccessList.set(from, set);
        const newItem = { from, to };
        updated.push(newItem);
        this._onDidChangeModelAccess.fire(newItem);
      }
    }
  }
  createLanguageModelAccessInformation(from) {
    this._languageAccessInformationExtensions.add(from);
    const _onDidChangeAccess = Event.signal(Event.filter(this._onDidChangeModelAccess.event, (e) => ExtensionIdentifier.equals(e.from, from.identifier)));
    const _onDidAddRemove = Event.signal(this._onDidChangeProviders.event);
    return {
      get onDidChange() {
        return Event.any(_onDidChangeAccess, _onDidAddRemove);
      },
      canSendRequest(chat) {
        return true;
      }
    };
  }
  fileIsIgnored(extension, uri, token = CancellationToken.None) {
    checkProposedApiEnabled(extension, "chatParticipantAdditions");
    return this._proxy.$fileIsIgnored(uri, token);
  }
  get isModelProxyAvailable() {
    return !!this._languageModelProxyProvider;
  }
  async getModelProxy(extension) {
    checkProposedApiEnabled(extension, "languageModelProxy");
    if (!this._languageModelProxyProvider) {
      this._logService.trace("[LanguageModelProxy] No LanguageModelProxyProvider registered");
      throw new Error("No language model proxy provider is registered.");
    }
    const requestingExtensionId = ExtensionIdentifier.toKey(extension.identifier);
    try {
      const result = await Promise.resolve(this._languageModelProxyProvider.provideModelProxy(requestingExtensionId, CancellationToken.None));
      if (!result) {
        this._logService.warn(`[LanguageModelProxy] Provider returned no proxy for ${requestingExtensionId}`);
        throw new Error("Language model proxy is not available.");
      }
      return result;
    } catch (err) {
      this._logService.error(`[LanguageModelProxy] Provider failed to return proxy for ${requestingExtensionId}`, err);
      throw err;
    }
  }
  async $isFileIgnored(handle, uri, token) {
    const provider = this._ignoredFileProviders.get(handle);
    if (!provider) {
      throw new Error("Unknown LanguageModelIgnoredFileProvider");
    }
    return await provider.provideFileIgnored(URI.revive(uri), token) ?? false;
  }
  registerIgnoredFileProvider(extension, provider) {
    checkProposedApiEnabled(extension, "chatParticipantPrivate");
    const handle = ExtHostLanguageModels_1._idPool++;
    this._proxy.$registerFileIgnoreProvider(handle);
    this._ignoredFileProviders.set(handle, provider);
    return toDisposable(() => {
      this._proxy.$unregisterFileIgnoreProvider(handle);
      this._ignoredFileProviders.delete(handle);
    });
  }
  registerLanguageModelProxyProvider(extension, provider) {
    checkProposedApiEnabled(extension, "chatParticipantPrivate");
    this._languageModelProxyProvider = provider;
    this._onDidChangeModelProxyAvailability.fire();
    return toDisposable(() => {
      if (this._languageModelProxyProvider === provider) {
        this._languageModelProxyProvider = void 0;
        this._onDidChangeModelProxyAvailability.fire();
      }
    });
  }
};
ExtHostLanguageModels = ExtHostLanguageModels_1 = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService),
  __param(2, IExtHostAuthentication)
], ExtHostLanguageModels);

// out-build/vs/base/common/labels.js
function normalizeDriveLetter(path, isWindowsOS = isWindows) {
  if (hasDriveLetter(path, isWindowsOS)) {
    return path.charAt(0).toUpperCase() + path.slice(1);
  }
  return path;
}
function untildify(path, userHome) {
  return path.replace(/^~($|\/|\\)/, `${userHome}$1`);
}
var ellipsis = "\u2026";
var unc = "\\\\";
var home = "~";
function shorten(paths, pathSeparator = sep) {
  const shortenedPaths = new Array(paths.length);
  let match2 = false;
  for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {
    const originalPath = paths[pathIndex];
    if (originalPath === "") {
      shortenedPaths[pathIndex] = `.${pathSeparator}`;
      continue;
    }
    if (!originalPath) {
      shortenedPaths[pathIndex] = originalPath;
      continue;
    }
    match2 = true;
    let prefix = "";
    let trimmedPath = originalPath;
    if (trimmedPath.indexOf(unc) === 0) {
      prefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);
      trimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);
    } else if (trimmedPath.indexOf(pathSeparator) === 0) {
      prefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
      trimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
    } else if (trimmedPath.indexOf(home) === 0) {
      prefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);
      trimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);
    }
    const segments = trimmedPath.split(pathSeparator);
    for (let subpathLength = 1; match2 && subpathLength <= segments.length; subpathLength++) {
      for (let start = segments.length - subpathLength; match2 && start >= 0; start--) {
        match2 = false;
        let subpath = segments.slice(start, start + subpathLength).join(pathSeparator);
        for (let otherPathIndex = 0; !match2 && otherPathIndex < paths.length; otherPathIndex++) {
          if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
            const isSubpathEnding = start + subpathLength === segments.length;
            const subpathWithSep = start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1 ? pathSeparator + subpath : subpath;
            const isOtherPathEnding = paths[otherPathIndex].endsWith(subpathWithSep);
            match2 = !isSubpathEnding || isOtherPathEnding;
          }
        }
        if (!match2) {
          let result = "";
          if (segments[0].endsWith(":") || prefix !== "") {
            if (start === 1) {
              start = 0;
              subpathLength++;
              subpath = segments[0] + pathSeparator + subpath;
            }
            if (start > 0) {
              result = segments[0] + pathSeparator;
            }
            result = prefix + result;
          }
          if (start > 0) {
            result = result + ellipsis + pathSeparator;
          }
          result = result + subpath;
          if (start + subpathLength < segments.length) {
            result = result + pathSeparator + ellipsis;
          }
          shortenedPaths[pathIndex] = result;
        }
      }
    }
    if (match2) {
      shortenedPaths[pathIndex] = originalPath;
    }
  }
  return shortenedPaths;
}
var Type;
(function(Type2) {
  Type2[Type2["TEXT"] = 0] = "TEXT";
  Type2[Type2["VARIABLE"] = 1] = "VARIABLE";
  Type2[Type2["SEPARATOR"] = 2] = "SEPARATOR";
})(Type || (Type = {}));

// out-build/vs/base/common/date.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var month = day * 30;
var year = day * 365;
function toLocalISOString(date) {
  return date.getFullYear() + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0") + "T" + String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0") + "." + (date.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
}
var safeIntl = {
  DateTimeFormat(locales, options2) {
    return new Lazy(() => {
      try {
        return new Intl.DateTimeFormat(locales, options2);
      } catch {
        return new Intl.DateTimeFormat(void 0, options2);
      }
    });
  },
  Collator(locales, options2) {
    return new Lazy(() => {
      try {
        return new Intl.Collator(locales, options2);
      } catch {
        return new Intl.Collator(void 0, options2);
      }
    });
  },
  Segmenter(locales, options2) {
    return new Lazy(() => {
      try {
        return new Intl.Segmenter(locales, options2);
      } catch {
        return new Intl.Segmenter(void 0, options2);
      }
    });
  },
  Locale(tag2, options2) {
    return new Lazy(() => {
      try {
        return new Intl.Locale(tag2, options2);
      } catch {
        return new Intl.Locale(LANGUAGE_DEFAULT, options2);
      }
    });
  },
  NumberFormat(locales, options2) {
    return new Lazy(() => {
      try {
        return new Intl.NumberFormat(locales, options2);
      } catch {
        return new Intl.NumberFormat(void 0, options2);
      }
    });
  }
};

// out-build/vs/base/common/uint.js
var Constants;
(function(Constants2) {
  Constants2[Constants2["MAX_SAFE_SMALL_INTEGER"] = 1073741824] = "MAX_SAFE_SMALL_INTEGER";
  Constants2[Constants2["MIN_SAFE_SMALL_INTEGER"] = -1073741824] = "MIN_SAFE_SMALL_INTEGER";
  Constants2[Constants2["MAX_UINT_8"] = 255] = "MAX_UINT_8";
  Constants2[Constants2["MAX_UINT_16"] = 65535] = "MAX_UINT_16";
  Constants2[Constants2["MAX_UINT_32"] = 4294967295] = "MAX_UINT_32";
  Constants2[Constants2["UNICODE_SUPPLEMENTARY_PLANE_BEGIN"] = 65536] = "UNICODE_SUPPLEMENTARY_PLANE_BEGIN";
})(Constants || (Constants = {}));
function toUint8(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 255) {
    return 255;
  }
  return v | 0;
}
function toUint32(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 4294967295) {
    return 4294967295;
  }
  return v | 0;
}

// out-build/vs/editor/common/core/characterClassifier.js
var CharacterClassifier = class _CharacterClassifier {
  constructor(_defaultValue) {
    const defaultValue = toUint8(_defaultValue);
    this._defaultValue = defaultValue;
    this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
    this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(defaultValue) {
    const asciiMap = new Uint8Array(256);
    asciiMap.fill(defaultValue);
    return asciiMap;
  }
  set(charCode, _value) {
    const value = toUint8(_value);
    if (charCode >= 0 && charCode < 256) {
      this._asciiMap[charCode] = value;
    } else {
      this._map.set(charCode, value);
    }
  }
  get(charCode) {
    if (charCode >= 0 && charCode < 256) {
      return this._asciiMap[charCode];
    } else {
      return this._map.get(charCode) || this._defaultValue;
    }
  }
  clear() {
    this._asciiMap.fill(this._defaultValue);
    this._map.clear();
  }
};
var Boolean2;
(function(Boolean3) {
  Boolean3[Boolean3["False"] = 0] = "False";
  Boolean3[Boolean3["True"] = 1] = "True";
})(Boolean2 || (Boolean2 = {}));

// out-build/vs/editor/common/core/wordCharacterClassifier.js
var WordCharacterClass;
(function(WordCharacterClass2) {
  WordCharacterClass2[WordCharacterClass2["Regular"] = 0] = "Regular";
  WordCharacterClass2[WordCharacterClass2["Whitespace"] = 1] = "Whitespace";
  WordCharacterClass2[WordCharacterClass2["WordSeparator"] = 2] = "WordSeparator";
})(WordCharacterClass || (WordCharacterClass = {}));
var WordCharacterClassifier = class extends CharacterClassifier {
  constructor(wordSeparators2, intlSegmenterLocales) {
    super(
      0
      /* WordCharacterClass.Regular */
    );
    this._segmenter = null;
    this._cachedLine = null;
    this._cachedSegments = [];
    this.intlSegmenterLocales = intlSegmenterLocales;
    if (this.intlSegmenterLocales.length > 0) {
      this._segmenter = safeIntl.Segmenter(this.intlSegmenterLocales, { granularity: "word" });
    } else {
      this._segmenter = null;
    }
    for (let i = 0, len = wordSeparators2.length; i < len; i++) {
      this.set(
        wordSeparators2.charCodeAt(i),
        2
        /* WordCharacterClass.WordSeparator */
      );
    }
    this.set(
      32,
      1
      /* WordCharacterClass.Whitespace */
    );
    this.set(
      9,
      1
      /* WordCharacterClass.Whitespace */
    );
  }
  findPrevIntlWordBeforeOrAtOffset(line, offset) {
    let candidate = null;
    for (const segment of this._getIntlSegmenterWordsOnLine(line)) {
      if (segment.index > offset) {
        break;
      }
      candidate = segment;
    }
    return candidate;
  }
  findNextIntlWordAtOrAfterOffset(lineContent, offset) {
    for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {
      if (segment.index < offset) {
        continue;
      }
      return segment;
    }
    return null;
  }
  _getIntlSegmenterWordsOnLine(line) {
    if (!this._segmenter) {
      return [];
    }
    if (this._cachedLine === line) {
      return this._cachedSegments;
    }
    this._cachedLine = line;
    this._cachedSegments = this._filterWordSegments(this._segmenter.value.segment(line));
    return this._cachedSegments;
  }
  _filterWordSegments(segments) {
    const result = [];
    for (const segment of segments) {
      if (this._isWordLike(segment)) {
        result.push(segment);
      }
    }
    return result;
  }
  _isWordLike(segment) {
    if (segment.isWordLike) {
      return true;
    }
    return false;
  }
};
var wordClassifierCache = new LRUCache(10);
function getMapForWordSeparators(wordSeparators2, intlSegmenterLocales) {
  const key = `${wordSeparators2}/${intlSegmenterLocales.join(",")}`;
  let result = wordClassifierCache.get(key);
  if (!result) {
    result = new WordCharacterClassifier(wordSeparators2, intlSegmenterLocales);
    wordClassifierCache.set(key, result);
  }
  return result;
}

// out-build/vs/editor/common/model.js
var OverviewRulerLane;
(function(OverviewRulerLane2) {
  OverviewRulerLane2[OverviewRulerLane2["Left"] = 1] = "Left";
  OverviewRulerLane2[OverviewRulerLane2["Center"] = 2] = "Center";
  OverviewRulerLane2[OverviewRulerLane2["Right"] = 4] = "Right";
  OverviewRulerLane2[OverviewRulerLane2["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
var GlyphMarginLane;
(function(GlyphMarginLane2) {
  GlyphMarginLane2[GlyphMarginLane2["Left"] = 1] = "Left";
  GlyphMarginLane2[GlyphMarginLane2["Center"] = 2] = "Center";
  GlyphMarginLane2[GlyphMarginLane2["Right"] = 3] = "Right";
})(GlyphMarginLane || (GlyphMarginLane = {}));
var MinimapPosition;
(function(MinimapPosition2) {
  MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
  MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
var MinimapSectionHeaderStyle;
(function(MinimapSectionHeaderStyle2) {
  MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Normal"] = 1] = "Normal";
  MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Underlined"] = 2] = "Underlined";
})(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));
var TextDirection;
(function(TextDirection2) {
  TextDirection2[TextDirection2["LTR"] = 0] = "LTR";
  TextDirection2[TextDirection2["RTL"] = 1] = "RTL";
})(TextDirection || (TextDirection = {}));
var InjectedTextCursorStops;
(function(InjectedTextCursorStops2) {
  InjectedTextCursorStops2[InjectedTextCursorStops2["Both"] = 0] = "Both";
  InjectedTextCursorStops2[InjectedTextCursorStops2["Right"] = 1] = "Right";
  InjectedTextCursorStops2[InjectedTextCursorStops2["Left"] = 2] = "Left";
  InjectedTextCursorStops2[InjectedTextCursorStops2["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
var EndOfLinePreference;
(function(EndOfLinePreference2) {
  EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
  EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
  EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
var DefaultEndOfLine;
(function(DefaultEndOfLine2) {
  DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
  DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
var EndOfLineSequence;
(function(EndOfLineSequence2) {
  EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
  EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
var FindMatch = class {
  /**
   * @internal
   */
  constructor(range, matches) {
    this._findMatchBrand = void 0;
    this.range = range;
    this.matches = matches;
  }
};
var TrackedRangeStickiness;
(function(TrackedRangeStickiness2) {
  TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
var PositionAffinity;
(function(PositionAffinity2) {
  PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
  PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
  PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
  PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
  PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
})(PositionAffinity || (PositionAffinity = {}));
var ModelConstants;
(function(ModelConstants2) {
  ModelConstants2[ModelConstants2["FIRST_LINE_DETECTION_LENGTH_LIMIT"] = 1e3] = "FIRST_LINE_DETECTION_LENGTH_LIMIT";
})(ModelConstants || (ModelConstants = {}));
var SearchData = class {
  constructor(regex, wordSeparators2, simpleSearch) {
    this.regex = regex;
    this.wordSeparators = wordSeparators2;
    this.simpleSearch = simpleSearch;
  }
};
var ApplyEditsResult = class {
  constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
    this.reverseEdits = reverseEdits;
    this.changes = changes;
    this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
  }
};

// out-build/vs/editor/common/model/textModelSearch.js
var SearchParams = class {
  constructor(searchString, isRegex, matchCase, wordSeparators2) {
    this.searchString = searchString;
    this.isRegex = isRegex;
    this.matchCase = matchCase;
    this.wordSeparators = wordSeparators2;
  }
  parseSearchRequest() {
    if (this.searchString === "") {
      return null;
    }
    let multiline;
    if (this.isRegex) {
      multiline = isMultilineRegexSource(this.searchString);
    } else {
      multiline = this.searchString.indexOf("\n") >= 0;
    }
    let regex = null;
    try {
      regex = createRegExp(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: false,
        multiline,
        global: true,
        unicode: true
      });
    } catch (err) {
      return null;
    }
    if (!regex) {
      return null;
    }
    let canUseSimpleSearch = !this.isRegex && !multiline;
    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
      canUseSimpleSearch = this.matchCase;
    }
    return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);
  }
};
function isMultilineRegexSource(searchString) {
  if (!searchString || searchString.length === 0) {
    return false;
  }
  for (let i = 0, len = searchString.length; i < len; i++) {
    const chCode = searchString.charCodeAt(i);
    if (chCode === 10) {
      return true;
    }
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = searchString.charCodeAt(i);
      if (nextChCode === 110 || nextChCode === 114 || nextChCode === 87) {
        return true;
      }
    }
  }
  return false;
}
function createFindMatch(range, rawMatches, captureMatches) {
  if (!captureMatches) {
    return new FindMatch(range, null);
  }
  const matches = [];
  for (let i = 0, len = rawMatches.length; i < len; i++) {
    matches[i] = rawMatches[i];
  }
  return new FindMatch(range, matches);
}
function leftIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex === 0) {
    return true;
  }
  const charBefore = text.charCodeAt(matchStartIndex - 1);
  if (wordSeparators2.get(charBefore) !== 0) {
    return true;
  }
  if (charBefore === 13 || charBefore === 10) {
    return true;
  }
  if (matchLength > 0) {
    const firstCharInMatch = text.charCodeAt(matchStartIndex);
    if (wordSeparators2.get(firstCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function rightIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex + matchLength === textLength) {
    return true;
  }
  const charAfter = text.charCodeAt(matchStartIndex + matchLength);
  if (wordSeparators2.get(charAfter) !== 0) {
    return true;
  }
  if (charAfter === 13 || charAfter === 10) {
    return true;
  }
  if (matchLength > 0) {
    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
    if (wordSeparators2.get(lastCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function isValidMatch(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  return leftIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength);
}
var Searcher = class {
  constructor(wordSeparators2, searchRegex) {
    this._wordSeparators = wordSeparators2;
    this._searchRegex = searchRegex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  reset(lastIndex) {
    this._searchRegex.lastIndex = lastIndex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  next(text) {
    const textLength = text.length;
    let m;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
        return null;
      }
      m = this._searchRegex.exec(text);
      if (!m) {
        return null;
      }
      const matchStartIndex = m.index;
      const matchLength = m[0].length;
      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
        if (matchLength === 0) {
          if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
            this._searchRegex.lastIndex += 2;
          } else {
            this._searchRegex.lastIndex += 1;
          }
          continue;
        }
        return null;
      }
      this._prevMatchStartIndex = matchStartIndex;
      this._prevMatchLength = matchLength;
      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
        return m;
      }
    } while (m);
    return null;
  }
};

// out-build/vs/platform/uriIdentity/common/uriIdentity.js
var IUriIdentityService = createDecorator("IUriIdentityService");

// out-build/vs/platform/workspace/common/virtualWorkspace.js
function isVirtualResource(resource) {
  return resource.scheme !== Schemas.file && resource.scheme !== Schemas.vscodeRemote;
}
function getVirtualWorkspaceLocation(workspace) {
  if (workspace.folders.length) {
    return workspace.folders.every((f) => isVirtualResource(f.uri)) ? workspace.folders[0].uri : void 0;
  } else if (workspace.configuration && isVirtualResource(workspace.configuration)) {
    return workspace.configuration;
  }
  return void 0;
}
function getVirtualWorkspaceScheme(workspace) {
  return getVirtualWorkspaceLocation(workspace)?.scheme;
}

// out-build/vs/platform/environment/common/environment.js
var IEnvironmentService = createDecorator("environmentService");
var INativeEnvironmentService = refineServiceDecorator(IEnvironmentService);

// out-build/vs/workbench/services/environment/common/environmentService.js
var IWorkbenchEnvironmentService = refineServiceDecorator(IEnvironmentService);

// out-build/vs/workbench/services/remote/common/remoteAgentService.js
var IRemoteAgentService = createDecorator("remoteAgentService");
var remoteConnectionLatencyMeasurer = new class {
  constructor() {
    this.maxSampleCount = 5;
    this.sampleDelay = 2e3;
    this.initial = [];
    this.maxInitialCount = 3;
    this.average = [];
    this.maxAverageCount = 100;
    this.highLatencyMultiple = 2;
    this.highLatencyMinThreshold = 500;
    this.highLatencyMaxThreshold = 1500;
    this.lastMeasurement = void 0;
  }
  get latency() {
    return this.lastMeasurement;
  }
  async measure(remoteAgentService) {
    let currentLatency = Infinity;
    for (let i = 0; i < this.maxSampleCount; i++) {
      const rtt = await remoteAgentService.getRoundTripTime();
      if (rtt === void 0) {
        return void 0;
      }
      currentLatency = Math.min(
        currentLatency,
        rtt / 2
        /* we want just one way, not round trip time */
      );
      await timeout(this.sampleDelay);
    }
    this.average.push(currentLatency);
    if (this.average.length > this.maxAverageCount) {
      this.average.shift();
    }
    let initialLatency = void 0;
    if (this.initial.length < this.maxInitialCount) {
      this.initial.push(currentLatency);
    } else {
      initialLatency = this.initial.reduce((sum, value) => sum + value, 0) / this.initial.length;
    }
    this.lastMeasurement = {
      initial: initialLatency,
      current: currentLatency,
      average: this.average.reduce((sum, value) => sum + value, 0) / this.average.length,
      high: (() => {
        if (typeof initialLatency === "undefined") {
          return false;
        }
        if (currentLatency > this.highLatencyMaxThreshold) {
          return true;
        }
        if (currentLatency > this.highLatencyMinThreshold && currentLatency > initialLatency * this.highLatencyMultiple) {
          return true;
        }
        return false;
      })()
    };
    return this.lastMeasurement;
  }
}();

// out-build/vs/workbench/services/path/common/pathService.js
var AbstractPathService_1;
var IPathService = createDecorator("pathService");
var AbstractPathService = AbstractPathService_1 = class AbstractPathService2 {
  constructor(localUserHome, remoteAgentService, environmentService, contextService) {
    this.localUserHome = localUserHome;
    this.remoteAgentService = remoteAgentService;
    this.environmentService = environmentService;
    this.contextService = contextService;
    this.resolveOS = (async () => {
      const env2 = await this.remoteAgentService.getEnvironment();
      return env2?.os || OS;
    })();
    this.resolveUserHome = (async () => {
      const env2 = await this.remoteAgentService.getEnvironment();
      const userHome = this.maybeUnresolvedUserHome = env2?.userHome ?? localUserHome;
      return userHome;
    })();
  }
  hasValidBasename(resource, arg2, basename3) {
    if (typeof arg2 === "string" || typeof arg2 === "undefined") {
      return this.resolveOS.then((os) => this.doHasValidBasename(resource, os, arg2));
    }
    return this.doHasValidBasename(resource, arg2, basename3);
  }
  doHasValidBasename(resource, os, name2) {
    if (resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote) {
      return isValidBasename(
        name2 ?? basename2(resource),
        os === 1
        /* OperatingSystem.Windows */
      );
    }
    return true;
  }
  get defaultUriScheme() {
    return AbstractPathService_1.findDefaultUriScheme(this.environmentService, this.contextService);
  }
  static findDefaultUriScheme(environmentService, contextService) {
    if (environmentService.remoteAuthority) {
      return Schemas.vscodeRemote;
    }
    const virtualWorkspace = getVirtualWorkspaceScheme(contextService.getWorkspace());
    if (virtualWorkspace) {
      return virtualWorkspace;
    }
    const firstFolder = contextService.getWorkspace().folders[0];
    if (firstFolder) {
      return firstFolder.uri.scheme;
    }
    const configuration = contextService.getWorkspace().configuration;
    if (configuration) {
      return configuration.scheme;
    }
    return Schemas.file;
  }
  userHome(options2) {
    return options2?.preferLocal ? this.localUserHome : this.resolveUserHome;
  }
  get resolvedUserHome() {
    return this.maybeUnresolvedUserHome;
  }
  get path() {
    return this.resolveOS.then((os) => {
      return os === 1 ? win32 : posix;
    });
  }
  async fileURI(_path) {
    let authority = "";
    const os = await this.resolveOS;
    if (os === 1) {
      _path = _path.replace(/\\/g, "/");
    }
    if (_path[0] === "/" && _path[1] === "/") {
      const idx = _path.indexOf("/", 2);
      if (idx === -1) {
        authority = _path.substring(2);
        _path = "/";
      } else {
        authority = _path.substring(2, idx);
        _path = _path.substring(idx) || "/";
      }
    }
    return URI.from({
      scheme: Schemas.file,
      authority,
      path: _path,
      query: "",
      fragment: ""
    });
  }
};
AbstractPathService = AbstractPathService_1 = __decorate([
  __param(1, IRemoteAgentService),
  __param(2, IWorkbenchEnvironmentService),
  __param(3, IWorkspaceContextService)
], AbstractPathService);

// out-build/vs/workbench/services/search/common/queryBuilder.js
function isISearchPatternBuilder(object) {
  return typeof object === "object" && "uri" in object && "pattern" in object;
}
var QueryBuilder = class QueryBuilder2 {
  constructor(configurationService, workspaceContextService, editorGroupsService, logService, pathService, uriIdentityService) {
    this.configurationService = configurationService;
    this.workspaceContextService = workspaceContextService;
    this.editorGroupsService = editorGroupsService;
    this.logService = logService;
    this.pathService = pathService;
    this.uriIdentityService = uriIdentityService;
  }
  aiText(contentPattern, folderResources, options2 = {}) {
    const commonQuery = this.commonQuery(folderResources?.map(toWorkspaceFolder), options2);
    return {
      ...commonQuery,
      type: 3,
      contentPattern
    };
  }
  text(contentPattern, folderResources, options2 = {}) {
    contentPattern = this.getContentPattern(contentPattern, options2);
    const searchConfig = this.configurationService.getValue();
    const fallbackToPCRE = folderResources && folderResources.some((folder) => {
      const folderConfig = this.configurationService.getValue({ resource: folder });
      return !folderConfig.search.useRipgrep;
    });
    const commonQuery = this.commonQuery(folderResources?.map(toWorkspaceFolder), options2);
    return {
      ...commonQuery,
      type: 2,
      contentPattern,
      previewOptions: options2.previewOptions,
      maxFileSize: options2.maxFileSize,
      usePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,
      surroundingContext: options2.surroundingContext,
      userDisabledExcludesAndIgnoreFiles: options2.disregardExcludeSettings && options2.disregardIgnoreFiles
    };
  }
  /**
   * Adjusts input pattern for config
   */
  getContentPattern(inputPattern, options2) {
    const searchConfig = this.configurationService.getValue();
    if (inputPattern.isRegExp) {
      inputPattern.pattern = inputPattern.pattern.replace(/\r?\n/g, "\\n");
    }
    const newPattern = {
      ...inputPattern,
      wordSeparators: searchConfig.editor.wordSeparators
    };
    if (this.isCaseSensitive(inputPattern, options2)) {
      newPattern.isCaseSensitive = true;
    }
    if (this.isMultiline(inputPattern)) {
      newPattern.isMultiline = true;
    }
    if (options2.notebookSearchConfig?.includeMarkupInput) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookMarkdownInput = options2.notebookSearchConfig.includeMarkupInput;
    }
    if (options2.notebookSearchConfig?.includeMarkupPreview) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookMarkdownPreview = options2.notebookSearchConfig.includeMarkupPreview;
    }
    if (options2.notebookSearchConfig?.includeCodeInput) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookCellInput = options2.notebookSearchConfig.includeCodeInput;
    }
    if (options2.notebookSearchConfig?.includeOutput) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookCellOutput = options2.notebookSearchConfig.includeOutput;
    }
    return newPattern;
  }
  file(folders, options2 = {}) {
    const commonQuery = this.commonQuery(folders, options2);
    return {
      ...commonQuery,
      type: 1,
      filePattern: options2.filePattern ? options2.filePattern.trim() : options2.filePattern,
      exists: options2.exists,
      sortByScore: options2.sortByScore,
      cacheKey: options2.cacheKey,
      shouldGlobMatchFilePattern: options2.shouldGlobSearch
    };
  }
  handleIncludeExclude(pattern, expandPatterns) {
    if (!pattern) {
      return {};
    }
    if (Array.isArray(pattern)) {
      pattern = pattern.filter((p) => p.length > 0).map(normalizeSlashes);
      if (!pattern.length) {
        return {};
      }
    } else {
      pattern = normalizeSlashes(pattern);
    }
    return expandPatterns ? this.parseSearchPaths(pattern) : { pattern: patternListToIExpression(...Array.isArray(pattern) ? pattern : [pattern]) };
  }
  commonQuery(folderResources = [], options2 = {}) {
    let excludePatterns = Array.isArray(options2.excludePattern) ? options2.excludePattern.map((p) => p.pattern).flat() : options2.excludePattern;
    excludePatterns = excludePatterns?.length === 1 ? excludePatterns[0] : excludePatterns;
    const includeSearchPathsInfo = this.handleIncludeExclude(options2.includePattern, options2.expandPatterns);
    const excludeSearchPathsInfo = this.handleIncludeExclude(excludePatterns, options2.expandPatterns);
    const includeFolderName = folderResources.length > 1;
    const folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ? includeSearchPathsInfo.searchPaths.map((searchPath) => this.getFolderQueryForSearchPath(searchPath, options2, excludeSearchPathsInfo)) : folderResources.map((folder) => this.getFolderQueryForRoot(folder, options2, excludeSearchPathsInfo, includeFolderName))).filter((query) => !!query);
    const queryProps = {
      _reason: options2._reason,
      folderQueries,
      usingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),
      extraFileResources: options2.extraFileResources,
      excludePattern: excludeSearchPathsInfo.pattern,
      includePattern: includeSearchPathsInfo.pattern,
      onlyOpenEditors: options2.onlyOpenEditors,
      maxResults: options2.maxResults,
      onlyFileScheme: options2.onlyFileScheme
    };
    if (options2.onlyOpenEditors) {
      const openEditors = coalesce(this.editorGroupsService.groups.flatMap((group) => group.editors.map((editor) => editor.resource)));
      this.logService.trace("QueryBuilder#commonQuery - openEditor URIs", JSON.stringify(openEditors));
      const openEditorsInQuery = openEditors.filter((editor) => pathIncludedInQuery(queryProps, editor.fsPath));
      const openEditorsQueryProps = this.commonQueryFromFileList(openEditorsInQuery);
      this.logService.trace("QueryBuilder#commonQuery - openEditor Query", JSON.stringify(openEditorsQueryProps));
      return { ...queryProps, ...openEditorsQueryProps };
    }
    const extraFileResources = options2.extraFileResources && options2.extraFileResources.filter((extraFile) => pathIncludedInQuery(queryProps, extraFile.fsPath));
    queryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : void 0;
    return queryProps;
  }
  commonQueryFromFileList(files) {
    const folderQueries = [];
    const foldersToSearch = new ResourceMap();
    const includePattern = {};
    let hasIncludedFile = false;
    files.forEach((file) => {
      if (file.scheme === Schemas.walkThrough) {
        return;
      }
      const providerExists = isAbsolutePath(file);
      if (providerExists) {
        const searchRoot = this.workspaceContextService.getWorkspaceFolder(file)?.uri ?? this.uriIdentityService.extUri.dirname(file);
        let folderQuery = foldersToSearch.get(searchRoot);
        if (!folderQuery) {
          hasIncludedFile = true;
          folderQuery = { folder: searchRoot, includePattern: {} };
          folderQueries.push(folderQuery);
          foldersToSearch.set(searchRoot, folderQuery);
        }
        const relPath = relative(searchRoot.fsPath, file.fsPath);
        assertReturnsDefined(folderQuery.includePattern)[escapeGlobPattern(relPath.replace(/\\/g, "/"))] = true;
      } else {
        if (file.fsPath) {
          hasIncludedFile = true;
          includePattern[escapeGlobPattern(file.fsPath)] = true;
        }
      }
    });
    return {
      folderQueries,
      includePattern,
      usingSearchPaths: true,
      excludePattern: hasIncludedFile ? void 0 : { "**/*": true }
    };
  }
  /**
   * Resolve isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.
   */
  isCaseSensitive(contentPattern, options2) {
    if (options2.isSmartCase) {
      if (contentPattern.isRegExp) {
        if (containsUppercaseCharacter(contentPattern.pattern, true)) {
          return true;
        }
      } else if (containsUppercaseCharacter(contentPattern.pattern)) {
        return true;
      }
    }
    return !!contentPattern.isCaseSensitive;
  }
  isMultiline(contentPattern) {
    if (contentPattern.isMultiline) {
      return true;
    }
    if (contentPattern.isRegExp && isMultilineRegexSource(contentPattern.pattern)) {
      return true;
    }
    if (contentPattern.pattern.indexOf("\n") >= 0) {
      return true;
    }
    return !!contentPattern.isMultiline;
  }
  /**
   * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and
   * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\/foo/bar}.
   *
   * Public for test.
   */
  parseSearchPaths(pattern) {
    const isSearchPath = (segment) => {
      return isAbsolute(segment) || /^\.\.?([\/\\]|$)/.test(segment);
    };
    const patterns = Array.isArray(pattern) ? pattern : splitGlobPattern(pattern);
    const segments = patterns.map((segment) => {
      const userHome = this.pathService.resolvedUserHome;
      if (userHome) {
        return untildify(segment, userHome.scheme === Schemas.file ? userHome.fsPath : userHome.path);
      }
      return segment;
    });
    const groups = groupBy2(segments, (segment) => isSearchPath(segment) ? "searchPaths" : "exprSegments");
    const expandedExprSegments = (groups.exprSegments || []).map((s) => rtrim(s, "/")).map((s) => rtrim(s, "\\")).map((p) => {
      if (p[0] === ".") {
        p = "*" + p;
      }
      return expandGlobalGlob(p);
    });
    const result = {};
    const searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);
    if (searchPaths && searchPaths.length) {
      result.searchPaths = searchPaths;
    }
    const exprSegments = expandedExprSegments.flat();
    const includePattern = patternListToIExpression(...exprSegments);
    if (includePattern) {
      result.pattern = includePattern;
    }
    return result;
  }
  getExcludesForFolder(folderConfig, options2) {
    return options2.disregardExcludeSettings ? void 0 : getExcludes(folderConfig, !options2.disregardSearchExcludeSettings);
  }
  /**
   * Split search paths (./ or ../ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths
   */
  expandSearchPathPatterns(searchPaths) {
    if (!searchPaths || !searchPaths.length) {
      return [];
    }
    const expandedSearchPaths = searchPaths.flatMap((searchPath) => {
      let { pathPortion, globPortion } = splitGlobFromPath(searchPath);
      if (globPortion) {
        globPortion = normalizeGlobPattern(globPortion);
      }
      const oneExpanded = this.expandOneSearchPath(pathPortion);
      return oneExpanded.flatMap((oneExpandedResult) => this.resolveOneSearchPathPattern(oneExpandedResult, globPortion));
    });
    const searchPathPatternMap = /* @__PURE__ */ new Map();
    expandedSearchPaths.forEach((oneSearchPathPattern) => {
      const key = oneSearchPathPattern.searchPath.toString();
      const existing = searchPathPatternMap.get(key);
      if (existing) {
        if (oneSearchPathPattern.pattern) {
          existing.pattern = existing.pattern || {};
          existing.pattern[oneSearchPathPattern.pattern] = true;
        }
      } else {
        searchPathPatternMap.set(key, {
          searchPath: oneSearchPathPattern.searchPath,
          pattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : void 0
        });
      }
    });
    return Array.from(searchPathPatternMap.values());
  }
  /**
   * Takes a searchPath like `./a/foo` or `../a/foo` and expands it to absolute paths for all the workspaces it matches.
   */
  expandOneSearchPath(searchPath) {
    if (isAbsolute(searchPath)) {
      const workspaceFolders = this.workspaceContextService.getWorkspace().folders;
      if (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== Schemas.file) {
        return [{
          searchPath: workspaceFolders[0].uri.with({ path: searchPath })
        }];
      }
      return [{
        searchPath: URI.file(normalize(searchPath))
      }];
    }
    if (this.workspaceContextService.getWorkbenchState() === 2) {
      const workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;
      searchPath = normalizeSlashes(searchPath);
      if (searchPath.startsWith("../") || searchPath === "..") {
        const resolvedPath = posix.resolve(workspaceUri.path, searchPath);
        return [{
          searchPath: workspaceUri.with({ path: resolvedPath })
        }];
      }
      const cleanedPattern = normalizeGlobPattern(searchPath);
      return [{
        searchPath: workspaceUri,
        pattern: cleanedPattern
      }];
    } else if (searchPath === "./" || searchPath === ".\\") {
      return [];
    } else {
      const searchPathWithoutDotSlash = searchPath.replace(/^\.[\/\\]/, "");
      const folders = this.workspaceContextService.getWorkspace().folders;
      const folderMatches = folders.map((folder) => {
        const match2 = searchPathWithoutDotSlash.match(new RegExp(`^${escapeRegExpCharacters(folder.name)}(?:/(.*)|$)`));
        return match2 ? {
          match: match2,
          folder
        } : null;
      }).filter(isDefined);
      if (folderMatches.length) {
        return folderMatches.map((match2) => {
          const patternMatch = match2.match[1];
          return {
            searchPath: match2.folder.uri,
            pattern: patternMatch && normalizeGlobPattern(patternMatch)
          };
        });
      } else {
        const probableWorkspaceFolderNameMatch = searchPath.match(/\.[\/\\](.+)[\/\\]?/);
        const probableWorkspaceFolderName = probableWorkspaceFolderNameMatch ? probableWorkspaceFolderNameMatch[1] : searchPath;
        const searchPathNotFoundError = localize(15692, null, probableWorkspaceFolderName);
        throw new Error(searchPathNotFoundError);
      }
    }
  }
  resolveOneSearchPathPattern(oneExpandedResult, globPortion) {
    const pattern = oneExpandedResult.pattern && globPortion ? `${oneExpandedResult.pattern}/${globPortion}` : oneExpandedResult.pattern || globPortion;
    const results = [
      {
        searchPath: oneExpandedResult.searchPath,
        pattern
      }
    ];
    if (pattern && !pattern.endsWith("**")) {
      results.push({
        searchPath: oneExpandedResult.searchPath,
        pattern: pattern + "/**"
      });
    }
    return results;
  }
  getFolderQueryForSearchPath(searchPath, options2, searchPathExcludes) {
    const rootConfig = this.getFolderQueryForRoot(toWorkspaceFolder(searchPath.searchPath), options2, searchPathExcludes, false);
    if (!rootConfig) {
      return null;
    }
    return {
      ...rootConfig,
      ...{
        includePattern: searchPath.pattern
      }
    };
  }
  getFolderQueryForRoot(folder, options2, searchPathExcludes, includeFolderName) {
    let thisFolderExcludeSearchPathPattern;
    const folderUri = URI.isUri(folder) ? folder : folder.uri;
    let excludeFolderRoots = options2.excludePattern?.map((excludePattern2) => {
      const excludeRoot = options2.excludePattern && isISearchPatternBuilder(excludePattern2) ? excludePattern2.uri : void 0;
      const shouldUseExcludeRoot = !excludeRoot || !(URI.isUri(folder) && this.uriIdentityService.extUri.isEqual(folder, excludeRoot));
      return shouldUseExcludeRoot ? excludeRoot : void 0;
    });
    if (!excludeFolderRoots?.length) {
      excludeFolderRoots = [void 0];
    }
    if (searchPathExcludes.searchPaths) {
      const thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter((sp) => isEqual(sp.searchPath, folderUri))[0];
      if (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {
        return null;
      } else if (thisFolderExcludeSearchPath) {
        thisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;
      }
    }
    const folderConfig = this.configurationService.getValue({ resource: folderUri });
    const settingExcludes = this.getExcludesForFolder(folderConfig, options2);
    const excludePattern = {
      ...settingExcludes || {},
      ...thisFolderExcludeSearchPathPattern || {}
    };
    const folderName = URI.isUri(folder) ? basename2(folder) : folder.name;
    const excludePatternRet = excludeFolderRoots.map((excludeFolderRoot) => {
      return Object.keys(excludePattern).length > 0 ? {
        folder: excludeFolderRoot,
        pattern: excludePattern
      } : void 0;
    }).filter((e) => e);
    return {
      folder: folderUri,
      folderName: includeFolderName ? folderName : void 0,
      excludePattern: excludePatternRet,
      fileEncoding: folderConfig.files && folderConfig.files.encoding,
      disregardIgnoreFiles: typeof options2.disregardIgnoreFiles === "boolean" ? options2.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,
      disregardGlobalIgnoreFiles: typeof options2.disregardGlobalIgnoreFiles === "boolean" ? options2.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,
      disregardParentIgnoreFiles: typeof options2.disregardParentIgnoreFiles === "boolean" ? options2.disregardParentIgnoreFiles : !folderConfig.search.useParentIgnoreFiles,
      ignoreSymlinks: typeof options2.ignoreSymlinks === "boolean" ? options2.ignoreSymlinks : !folderConfig.search.followSymlinks
    };
  }
};
QueryBuilder = __decorate([
  __param(0, IConfigurationService),
  __param(1, IWorkspaceContextService),
  __param(2, IEditorGroupsService),
  __param(3, ILogService),
  __param(4, IPathService),
  __param(5, IUriIdentityService)
], QueryBuilder);
function splitGlobFromPath(searchPath) {
  const globCharMatch = searchPath.match(/[\*\{\}\(\)\[\]\?]/);
  if (globCharMatch) {
    const globCharIdx = globCharMatch.index;
    const lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\][^/\\]*$/);
    if (lastSlashMatch) {
      let pathPortion = searchPath.substr(0, lastSlashMatch.index);
      if (!pathPortion.match(/[/\\]/)) {
        pathPortion += "/";
      }
      return {
        pathPortion,
        globPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)
      };
    }
  }
  return {
    pathPortion: searchPath
  };
}
function patternListToIExpression(...patterns) {
  return patterns.length ? patterns.reduce((glob, cur) => {
    glob[cur] = true;
    return glob;
  }, /* @__PURE__ */ Object.create(null)) : void 0;
}
function splitGlobPattern(pattern) {
  return splitGlobAware(pattern, ",").map((s) => s.trim()).filter((s) => !!s.length);
}
function expandGlobalGlob(pattern) {
  const patterns = [
    `**/${pattern}/**`,
    `**/${pattern}`
  ];
  return patterns.map((p) => p.replace(/\*\*\/\*\*/g, "**"));
}
function normalizeSlashes(pattern) {
  return pattern.replace(/\\/g, "/");
}
function normalizeGlobPattern(pattern) {
  return normalizeSlashes(pattern).replace(/^\.\//, "").replace(/\/+$/g, "");
}
function escapeGlobPattern(path) {
  return path.replace(/([?*[\]])/g, "[$1]");
}

// out-build/vs/workbench/services/extensions/common/workspaceContains.js
var WORKSPACE_CONTAINS_TIMEOUT = 7e3;
function checkActivateWorkspaceContainsExtension(host, desc) {
  const activationEvents = desc.activationEvents;
  if (!activationEvents) {
    return Promise.resolve(void 0);
  }
  const fileNames = [];
  const globPatterns = [];
  for (const activationEvent of activationEvents) {
    if (/^workspaceContains:/.test(activationEvent)) {
      const fileNameOrGlob = activationEvent.substr("workspaceContains:".length);
      if (fileNameOrGlob.indexOf("*") >= 0 || fileNameOrGlob.indexOf("?") >= 0 || host.forceUsingSearch) {
        globPatterns.push(fileNameOrGlob);
      } else {
        fileNames.push(fileNameOrGlob);
      }
    }
  }
  if (fileNames.length === 0 && globPatterns.length === 0) {
    return Promise.resolve(void 0);
  }
  const { promise, resolve: resolve2 } = promiseWithResolvers();
  const activate = (activationEvent) => resolve2({ activationEvent });
  const fileNamePromise = Promise.all(fileNames.map((fileName) => _activateIfFileName(host, fileName, activate))).then(() => {
  });
  const globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);
  Promise.all([fileNamePromise, globPatternPromise]).then(() => {
    resolve2(void 0);
  });
  return promise;
}
async function _activateIfFileName(host, fileName, activate) {
  for (const uri of host.folders) {
    if (await host.exists(joinPath(URI.revive(uri), fileName))) {
      activate(`workspaceContains:${fileName}`);
      return;
    }
  }
}
async function _activateIfGlobPatterns(host, extensionId, globPatterns, activate) {
  if (globPatterns.length === 0) {
    return Promise.resolve(void 0);
  }
  const tokenSource = new CancellationTokenSource();
  const searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);
  const timer = setTimeout(async () => {
    tokenSource.cancel();
    host.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(",")}`);
  }, WORKSPACE_CONTAINS_TIMEOUT);
  let exists = false;
  try {
    exists = await searchP;
  } catch (err) {
    if (!isCancellationError(err)) {
      onUnexpectedError(err);
    }
  }
  tokenSource.dispose();
  clearTimeout(timer);
  if (exists) {
    activate(`workspaceContains:${globPatterns.join(",")}`);
  }
}

// out-build/vs/workbench/api/common/extHostSecretState.js
var ExtHostSecretState = class {
  constructor(mainContext) {
    this._onDidChangePassword = new Emitter();
    this.onDidChangePassword = this._onDidChangePassword.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadSecretState);
  }
  async $onDidChangePassword(e) {
    this._onDidChangePassword.fire(e);
  }
  get(extensionId, key) {
    return this._proxy.$getPassword(extensionId, key);
  }
  store(extensionId, key, value) {
    return this._proxy.$setPassword(extensionId, key, value);
  }
  delete(extensionId, key) {
    return this._proxy.$deletePassword(extensionId, key);
  }
  keys(extensionId) {
    return this._proxy.$getKeys(extensionId);
  }
};
var IExtHostSecretState = createDecorator("IExtHostSecretState");

// out-build/vs/workbench/api/common/extHostSecrets.js
var ExtensionSecrets = class {
  #secretState;
  constructor(extensionDescription, secretState) {
    this.disposables = new DisposableStore();
    this._id = ExtensionIdentifier.toKey(extensionDescription.identifier);
    this.#secretState = secretState;
    this.onDidChange = Event.map(Event.filter(this.#secretState.onDidChangePassword, (e) => e.extensionId === this._id), (e) => ({ key: e.key }), this.disposables);
  }
  dispose() {
    this.disposables.dispose();
  }
  get(key) {
    return this.#secretState.get(this._id, key);
  }
  store(key, value) {
    return this.#secretState.store(this._id, key, value);
  }
  delete(key) {
    return this.#secretState.delete(this._id, key);
  }
  keys() {
    return this.#secretState.keys(this._id) || [];
  }
};

// out-build/vs/workbench/api/common/extHostLocalizationService.js
var ExtHostLocalizationService = class ExtHostLocalizationService2 {
  constructor(initData, rpc, logService) {
    this.logService = logService;
    this.bundleCache = /* @__PURE__ */ new Map();
    this._proxy = rpc.getProxy(MainContext.MainThreadLocalization);
    this.currentLanguage = initData.environment.appLanguage;
    this.isDefaultLanguage = this.currentLanguage === LANGUAGE_DEFAULT;
  }
  getMessage(extensionId, details) {
    const { message, args, comment } = details;
    if (this.isDefaultLanguage) {
      return format2(message, args ?? {});
    }
    let key = message;
    if (comment && comment.length > 0) {
      key += `/${Array.isArray(comment) ? comment.join("") : comment}`;
    }
    const str = this.bundleCache.get(extensionId)?.contents[key];
    if (!str) {
      this.logService.warn(`Using default string since no string found in i18n bundle that has the key: ${key}`);
    }
    return format2(str ?? message, args ?? {});
  }
  getBundle(extensionId) {
    return this.bundleCache.get(extensionId)?.contents;
  }
  getBundleUri(extensionId) {
    return this.bundleCache.get(extensionId)?.uri;
  }
  async initializeLocalizedMessages(extension) {
    if (this.isDefaultLanguage || !extension.l10n && !extension.isBuiltin) {
      return;
    }
    if (this.bundleCache.has(extension.identifier.value)) {
      return;
    }
    let contents;
    const bundleUri = await this.getBundleLocation(extension);
    if (!bundleUri) {
      this.logService.error(`No bundle location found for extension ${extension.identifier.value}`);
      return;
    }
    try {
      const response = await this._proxy.$fetchBundleContents(bundleUri);
      const result = JSON.parse(response);
      contents = extension.isBuiltin ? result.contents?.bundle : result;
    } catch (e) {
      this.logService.error(`Failed to load translations for ${extension.identifier.value} from ${bundleUri}: ${e.message}`);
      return;
    }
    if (contents) {
      this.bundleCache.set(extension.identifier.value, {
        contents,
        uri: bundleUri
      });
    }
  }
  async getBundleLocation(extension) {
    if (extension.isBuiltin) {
      const uri = await this._proxy.$fetchBuiltInBundleUri(extension.identifier.value, this.currentLanguage);
      return URI.revive(uri);
    }
    return extension.l10n ? URI.joinPath(extension.extensionLocation, extension.l10n, `bundle.l10n.${this.currentLanguage}.json`) : void 0;
  }
};
ExtHostLocalizationService = __decorate([
  __param(0, IExtHostInitDataService),
  __param(1, IExtHostRpcService),
  __param(2, ILogService)
], ExtHostLocalizationService);
var IExtHostLocalizationService = createDecorator("IExtHostLocalizationService");

// out-build/vs/workbench/api/common/extHostManagedSockets.js
var IExtHostManagedSockets = createDecorator("IExtHostManagedSockets");
var ExtHostManagedSockets = class ExtHostManagedSockets2 {
  constructor(extHostRpc) {
    this._remoteSocketIdCounter = 0;
    this._factory = null;
    this._managedRemoteSockets = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadManagedSockets);
  }
  setFactory(socketFactoryId, makeConnection) {
    for (const socket of this._managedRemoteSockets.values()) {
      socket.dispose();
    }
    if (this._factory) {
      this._proxy.$unregisterSocketFactory(this._factory.socketFactoryId);
    }
    this._factory = new ManagedSocketFactory(socketFactoryId, makeConnection);
    this._proxy.$registerSocketFactory(this._factory.socketFactoryId);
  }
  async $openRemoteSocket(socketFactoryId) {
    if (!this._factory || this._factory.socketFactoryId !== socketFactoryId) {
      throw new Error(`No socket factory with id ${socketFactoryId}`);
    }
    const id2 = ++this._remoteSocketIdCounter;
    const socket = await this._factory.makeConnection();
    const disposable = new DisposableStore();
    this._managedRemoteSockets.set(id2, new ManagedSocket(id2, socket, disposable));
    disposable.add(toDisposable(() => this._managedRemoteSockets.delete(id2)));
    disposable.add(socket.onDidEnd(() => {
      this._proxy.$onDidManagedSocketEnd(id2);
      disposable.dispose();
    }));
    disposable.add(socket.onDidClose((e) => {
      this._proxy.$onDidManagedSocketClose(id2, e?.stack ?? e?.message);
      disposable.dispose();
    }));
    disposable.add(socket.onDidReceiveMessage((e) => this._proxy.$onDidManagedSocketHaveData(id2, VSBuffer.wrap(e))));
    return id2;
  }
  $remoteSocketWrite(socketId, buffer) {
    this._managedRemoteSockets.get(socketId)?.actual.send(buffer.buffer);
  }
  $remoteSocketEnd(socketId) {
    const socket = this._managedRemoteSockets.get(socketId);
    if (socket) {
      socket.actual.end();
      socket.dispose();
    }
  }
  async $remoteSocketDrain(socketId) {
    await this._managedRemoteSockets.get(socketId)?.actual.drain?.();
  }
};
ExtHostManagedSockets = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostManagedSockets);
var ManagedSocketFactory = class {
  constructor(socketFactoryId, makeConnection) {
    this.socketFactoryId = socketFactoryId;
    this.makeConnection = makeConnection;
  }
};
var ManagedSocket = class extends Disposable {
  constructor(socketId, actual, disposer) {
    super();
    this.socketId = socketId;
    this.actual = actual;
    this._register(disposer);
  }
};

// out-build/vs/workbench/api/common/extHostExtensionService.js
var AbstractExtHostExtensionService_1;
var IHostUtils = createDecorator("IHostUtils");
var AbstractExtHostExtensionService = AbstractExtHostExtensionService_1 = class AbstractExtHostExtensionService2 extends Disposable {
  constructor(instaService, hostUtils, extHostContext, extHostWorkspace, extHostConfiguration, logService, initData, storagePath, extHostTunnelService, extHostTerminalService, extHostLocalizationService, _extHostManagedSockets, _extHostLanguageModels) {
    super();
    this._extHostManagedSockets = _extHostManagedSockets;
    this._extHostLanguageModels = _extHostLanguageModels;
    this._onDidChangeRemoteConnectionData = this._register(new Emitter());
    this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event;
    this._realPathCache = /* @__PURE__ */ new Map();
    this._isTerminating = false;
    this._hostUtils = hostUtils;
    this._extHostContext = extHostContext;
    this._initData = initData;
    this._extHostWorkspace = extHostWorkspace;
    this._extHostConfiguration = extHostConfiguration;
    this._logService = logService;
    this._extHostTunnelService = extHostTunnelService;
    this._extHostTerminalService = extHostTerminalService;
    this._extHostLocalizationService = extHostLocalizationService;
    this._mainThreadWorkspaceProxy = this._extHostContext.getProxy(MainContext.MainThreadWorkspace);
    this._mainThreadTelemetryProxy = this._extHostContext.getProxy(MainContext.MainThreadTelemetry);
    this._mainThreadExtensionsProxy = this._extHostContext.getProxy(MainContext.MainThreadExtensionService);
    this._almostReadyToRunExtensions = new Barrier();
    this._readyToStartExtensionHost = new Barrier();
    this._readyToRunExtensions = new Barrier();
    this._eagerExtensionsActivated = new Barrier();
    this._activationEventsReader = new SyncedActivationEventsReader(this._initData.extensions.activationEvents);
    this._globalRegistry = new ExtensionDescriptionRegistry(this._activationEventsReader, this._initData.extensions.allExtensions);
    const myExtensionsSet = new ExtensionIdentifierSet(this._initData.extensions.myExtensions);
    this._myRegistry = new ExtensionDescriptionRegistry(this._activationEventsReader, filterExtensions(this._globalRegistry, myExtensionsSet));
    if (isCI) {
      this._logService.info(`Creating extension host with the following global extensions: ${printExtIds(this._globalRegistry)}`);
      this._logService.info(`Creating extension host with the following local extensions: ${printExtIds(this._myRegistry)}`);
    }
    this._storage = new ExtHostStorage(this._extHostContext, this._logService);
    this._secretState = new ExtHostSecretState(this._extHostContext);
    this._storagePath = storagePath;
    this._instaService = this._store.add(instaService.createChild(new ServiceCollection([IExtHostStorage, this._storage], [IExtHostSecretState, this._secretState])));
    this._activator = this._register(new ExtensionsActivator(this._myRegistry, this._globalRegistry, {
      onExtensionActivationError: (extensionId, error, missingExtensionDependency) => {
        this._mainThreadExtensionsProxy.$onExtensionActivationError(extensionId, transformErrorForSerialization(error), missingExtensionDependency);
      },
      actualActivateExtension: async (extensionId, reason) => {
        if (ExtensionDescriptionRegistry.isHostExtension(extensionId, this._myRegistry, this._globalRegistry)) {
          await this._mainThreadExtensionsProxy.$activateExtension(extensionId, reason);
          return new HostExtension();
        }
        const extensionDescription = this._myRegistry.getExtensionDescription(extensionId);
        return this._activateExtension(extensionDescription, reason);
      }
    }, this._logService));
    this._extensionPathIndex = null;
    this._resolvers = /* @__PURE__ */ Object.create(null);
    this._started = false;
    this._remoteConnectionData = this._initData.remote.connectionData;
  }
  getRemoteConnectionData() {
    return this._remoteConnectionData;
  }
  async initialize() {
    try {
      await this._beforeAlmostReadyToRunExtensions();
      this._almostReadyToRunExtensions.open();
      await this._extHostWorkspace.waitForInitializeCall();
      mark("code/extHost/ready");
      this._readyToStartExtensionHost.open();
      if (this._initData.autoStart) {
        this._startExtensionHost();
      }
    } catch (err) {
      onUnexpectedError(err);
    }
  }
  async _deactivateAll() {
    this._storagePath.onWillDeactivateAll();
    let allPromises = [];
    try {
      const allExtensions = this._myRegistry.getAllExtensionDescriptions();
      const allExtensionsIds = allExtensions.map((ext) => ext.identifier);
      const activatedExtensions = allExtensionsIds.filter((id2) => this.isActivated(id2));
      allPromises = activatedExtensions.map((extensionId) => {
        return this._deactivate(extensionId);
      });
    } catch (err) {
    }
    await Promise.all(allPromises);
  }
  terminate(reason, code = 0) {
    if (this._isTerminating) {
      return;
    }
    this._isTerminating = true;
    this._logService.info(`Extension host terminating: ${reason}`);
    this._logService.flush();
    this._extHostTerminalService.dispose();
    this._activator.dispose();
    setUnexpectedErrorHandler((err) => {
      this._logService.error(err);
    });
    this._extHostContext.dispose();
    const extensionsDeactivated = this._deactivateAll();
    Promise.race([timeout(5e3), extensionsDeactivated]).finally(() => {
      if (this._hostUtils.pid) {
        this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${code}`);
      } else {
        this._logService.info(`Extension host exiting with code ${code}`);
      }
      this._logService.flush();
      this._logService.dispose();
      this._hostUtils.exit(code);
    });
  }
  isActivated(extensionId) {
    if (this._readyToRunExtensions.isOpen()) {
      return this._activator.isActivated(extensionId);
    }
    return false;
  }
  async getExtension(extensionId) {
    const ext = await this._mainThreadExtensionsProxy.$getExtension(extensionId);
    return ext && {
      ...ext,
      identifier: new ExtensionIdentifier(ext.identifier.value),
      extensionLocation: URI.revive(ext.extensionLocation)
    };
  }
  _activateByEvent(activationEvent, startup) {
    return this._activator.activateByEvent(activationEvent, startup);
  }
  _activateById(extensionId, reason) {
    return this._activator.activateById(extensionId, reason);
  }
  activateByIdWithErrors(extensionId, reason) {
    return this._activateById(extensionId, reason).then(() => {
      const extension = this._activator.getActivatedExtension(extensionId);
      if (extension.activationFailed) {
        return Promise.reject(extension.activationFailedError);
      }
      return void 0;
    });
  }
  getExtensionRegistry() {
    return this._readyToRunExtensions.wait().then((_) => this._myRegistry);
  }
  getExtensionExports(extensionId) {
    if (this._readyToRunExtensions.isOpen()) {
      return this._activator.getActivatedExtension(extensionId).exports;
    } else {
      try {
        return this._activator.getActivatedExtension(extensionId).exports;
      } catch (err) {
        return null;
      }
    }
  }
  /**
   * Applies realpath to file-uris and returns all others uris unmodified.
   * The real path is cached for the lifetime of the extension host.
   */
  async _realPathExtensionUri(uri) {
    if (uri.scheme === Schemas.file && this._hostUtils.fsRealpath) {
      const fsPath = uri.fsPath;
      if (!this._realPathCache.has(fsPath)) {
        this._realPathCache.set(fsPath, this._hostUtils.fsRealpath(fsPath));
      }
      const realpathValue = await this._realPathCache.get(fsPath);
      return URI.file(realpathValue);
    }
    return uri;
  }
  // create trie to enable fast 'filename -> extension id' look up
  async getExtensionPathIndex() {
    if (!this._extensionPathIndex) {
      this._extensionPathIndex = this._createExtensionPathIndex(this._myRegistry.getAllExtensionDescriptions()).then((searchTree) => {
        return new ExtensionPaths(searchTree);
      });
    }
    return this._extensionPathIndex;
  }
  /**
   * create trie to enable fast 'filename -> extension id' look up
   */
  async _createExtensionPathIndex(extensions) {
    const tst = TernarySearchTree.forUris((key) => {
      return extUriBiasedIgnorePathCase.ignorePathCasing(key);
    });
    await Promise.all(extensions.map(async (ext) => {
      if (this._getEntryPoint(ext)) {
        const uri = await this._realPathExtensionUri(ext.extensionLocation);
        tst.set(uri, ext);
      }
    }));
    return tst;
  }
  _deactivate(extensionId) {
    let result = Promise.resolve(void 0);
    if (!this._readyToRunExtensions.isOpen()) {
      return result;
    }
    if (!this._activator.isActivated(extensionId)) {
      return result;
    }
    const extension = this._activator.getActivatedExtension(extensionId);
    if (!extension) {
      return result;
    }
    try {
      if (typeof extension.module.deactivate === "function") {
        result = Promise.resolve(extension.module.deactivate()).then(void 0, (err) => {
          this._logService.error(err);
          return Promise.resolve(void 0);
        });
      }
    } catch (err) {
      this._logService.error(`An error occurred when deactivating the extension '${extensionId.value}':`);
      this._logService.error(err);
    }
    try {
      extension.disposable.dispose();
    } catch (err) {
      this._logService.error(`An error occurred when disposing the subscriptions for extension '${extensionId.value}':`);
      this._logService.error(err);
    }
    return result;
  }
  // --- impl
  async _activateExtension(extensionDescription, reason) {
    if (!this._initData.remote.isRemote) {
      await this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);
    } else {
      this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);
    }
    return this._doActivateExtension(extensionDescription, reason).then((activatedExtension) => {
      const activationTimes = activatedExtension.activationTimes;
      this._mainThreadExtensionsProxy.$onDidActivateExtension(extensionDescription.identifier, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, reason);
      this._logExtensionActivationTimes(extensionDescription, reason, "success", activationTimes);
      return activatedExtension;
    }, (err) => {
      this._logExtensionActivationTimes(extensionDescription, reason, "failure");
      throw err;
    });
  }
  _logExtensionActivationTimes(extensionDescription, reason, outcome, activationTimes) {
    const event = getTelemetryActivationEvent(extensionDescription, reason);
    this._mainThreadTelemetryProxy.$publicLog2("extensionActivationTimes", {
      ...event,
      ...activationTimes || {},
      outcome
    });
  }
  _doActivateExtension(extensionDescription, reason) {
    const event = getTelemetryActivationEvent(extensionDescription, reason);
    this._mainThreadTelemetryProxy.$publicLog2("activatePlugin", event);
    const entryPoint = this._getEntryPoint(extensionDescription);
    if (!entryPoint) {
      return Promise.resolve(new EmptyExtension(ExtensionActivationTimes.NONE));
    }
    this._logService.info(`ExtensionService#_doActivateExtension ${extensionDescription.identifier.value}, startup: ${reason.startup}, activationEvent: '${reason.activationEvent}'${extensionDescription.identifier.value !== reason.extensionId.value ? `, root cause: ${reason.extensionId.value}` : ``}`);
    this._logService.flush();
    const isESM = this._isESM(extensionDescription);
    const extensionInternalStore = new DisposableStore();
    const activationTimesBuilder = new ExtensionActivationTimesBuilder(reason.startup);
    return Promise.all([
      isESM ? this._loadESMModule(extensionDescription, joinPath(extensionDescription.extensionLocation, entryPoint), activationTimesBuilder) : this._loadCommonJSModule(extensionDescription, joinPath(extensionDescription.extensionLocation, entryPoint), activationTimesBuilder),
      this._loadExtensionContext(extensionDescription, extensionInternalStore)
    ]).then((values) => {
      mark(`code/extHost/willActivateExtension/${extensionDescription.identifier.value}`);
      return AbstractExtHostExtensionService_1._callActivate(this._logService, extensionDescription.identifier, values[0], values[1], extensionInternalStore, activationTimesBuilder);
    }).then((activatedExtension) => {
      mark(`code/extHost/didActivateExtension/${extensionDescription.identifier.value}`);
      return activatedExtension;
    });
  }
  _loadExtensionContext(extensionDescription, extensionInternalStore) {
    const languageModelAccessInformation = this._extHostLanguageModels.createLanguageModelAccessInformation(extensionDescription);
    const globalState = extensionInternalStore.add(new ExtensionGlobalMemento(extensionDescription, this._storage));
    const workspaceState = extensionInternalStore.add(new ExtensionMemento(extensionDescription.identifier.value, false, this._storage));
    const secrets = extensionInternalStore.add(new ExtensionSecrets(extensionDescription, this._secretState));
    const extensionMode = extensionDescription.isUnderDevelopment ? this._initData.environment.extensionTestsLocationURI ? ExtensionMode.Test : ExtensionMode.Development : ExtensionMode.Production;
    const extensionKind = this._initData.remote.isRemote ? ExtensionKind.Workspace : ExtensionKind.UI;
    this._logService.trace(`ExtensionService#loadExtensionContext ${extensionDescription.identifier.value}`);
    return Promise.all([
      globalState.whenReady,
      workspaceState.whenReady,
      this._storagePath.whenReady
    ]).then(() => {
      const that = this;
      let extension;
      let messagePassingProtocol;
      const messagePort = isProposedApiEnabled(extensionDescription, "ipc") ? this._initData.messagePorts?.get(ExtensionIdentifier.toKey(extensionDescription.identifier)) : void 0;
      return Object.freeze({
        globalState,
        workspaceState,
        secrets,
        subscriptions: [],
        get languageModelAccessInformation() {
          return languageModelAccessInformation;
        },
        get extensionUri() {
          return extensionDescription.extensionLocation;
        },
        get extensionPath() {
          return extensionDescription.extensionLocation.fsPath;
        },
        asAbsolutePath(relativePath2) {
          return join(extensionDescription.extensionLocation.fsPath, relativePath2);
        },
        get storagePath() {
          return that._storagePath.workspaceValue(extensionDescription)?.fsPath;
        },
        get globalStoragePath() {
          return that._storagePath.globalValue(extensionDescription).fsPath;
        },
        get logPath() {
          return join(that._initData.logsLocation.fsPath, extensionDescription.identifier.value);
        },
        get logUri() {
          return URI.joinPath(that._initData.logsLocation, extensionDescription.identifier.value);
        },
        get storageUri() {
          return that._storagePath.workspaceValue(extensionDescription);
        },
        get globalStorageUri() {
          return that._storagePath.globalValue(extensionDescription);
        },
        get extensionMode() {
          return extensionMode;
        },
        get extension() {
          if (extension === void 0) {
            extension = new Extension(that, extensionDescription.identifier, extensionDescription, extensionKind, false);
          }
          return extension;
        },
        get extensionRuntime() {
          checkProposedApiEnabled(extensionDescription, "extensionRuntime");
          return that.extensionRuntime;
        },
        get environmentVariableCollection() {
          return that._extHostTerminalService.getEnvironmentVariableCollection(extensionDescription);
        },
        get messagePassingProtocol() {
          if (!messagePassingProtocol) {
            if (!messagePort) {
              return void 0;
            }
            const onDidReceiveMessage = Event.buffer(Event.fromDOMEventEmitter(messagePort, "message", (e) => e.data));
            messagePort.start();
            messagePassingProtocol = {
              onDidReceiveMessage,
              // eslint-disable-next-line local/code-no-any-casts
              postMessage: messagePort.postMessage.bind(messagePort)
            };
          }
          return messagePassingProtocol;
        }
      });
    });
  }
  static _callActivate(logService, extensionId, extensionModule, context, extensionInternalStore, activationTimesBuilder) {
    extensionModule = extensionModule || {
      activate: void 0,
      deactivate: void 0
    };
    return this._callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder).then((extensionExports) => {
      return new ActivatedExtension(false, null, activationTimesBuilder.build(), extensionModule, extensionExports, toDisposable(() => {
        extensionInternalStore.dispose();
        dispose(context.subscriptions);
      }));
    });
  }
  static _callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder) {
    if (typeof extensionModule.activate === "function") {
      try {
        activationTimesBuilder.activateCallStart();
        logService.trace(`ExtensionService#_callActivateOptional ${extensionId.value}`);
        const activateResult = extensionModule.activate.apply(globalThis, [context]);
        activationTimesBuilder.activateCallStop();
        activationTimesBuilder.activateResolveStart();
        return Promise.resolve(activateResult).then((value) => {
          activationTimesBuilder.activateResolveStop();
          return value;
        });
      } catch (err) {
        return Promise.reject(err);
      }
    } else {
      return Promise.resolve(extensionModule);
    }
  }
  // -- eager activation
  _activateOneStartupFinished(desc, activationEvent) {
    this._activateById(desc.identifier, {
      startup: false,
      extensionId: desc.identifier,
      activationEvent
    }).then(void 0, (err) => {
      this._logService.error(err);
    });
  }
  _activateAllStartupFinishedDeferred(extensions, start = 0) {
    const timeBudget = 50;
    const startTime = Date.now();
    setTimeout0(() => {
      for (let i = start; i < extensions.length; i += 1) {
        const desc = extensions[i];
        for (const activationEvent of desc.activationEvents ?? []) {
          if (activationEvent === "onStartupFinished") {
            if (Date.now() - startTime > timeBudget) {
              this._activateAllStartupFinishedDeferred(extensions, i);
              break;
            } else {
              this._activateOneStartupFinished(desc, activationEvent);
            }
          }
        }
      }
    });
  }
  _activateAllStartupFinished() {
    this._mainThreadExtensionsProxy.$setPerformanceMarks(getMarks());
    this._extHostConfiguration.getConfigProvider().then((configProvider) => {
      const shouldDeferActivation = configProvider.getConfiguration("extensions.experimental").get("deferredStartupFinishedActivation");
      const allExtensionDescriptions = this._myRegistry.getAllExtensionDescriptions();
      if (shouldDeferActivation) {
        this._activateAllStartupFinishedDeferred(allExtensionDescriptions);
      } else {
        for (const desc of allExtensionDescriptions) {
          if (desc.activationEvents) {
            for (const activationEvent of desc.activationEvents) {
              if (activationEvent === "onStartupFinished") {
                this._activateOneStartupFinished(desc, activationEvent);
              }
            }
          }
        }
      }
    });
  }
  // Handle "eager" activation extensions
  _handleEagerExtensions() {
    const starActivation = this._activateByEvent("*", true).then(void 0, (err) => {
      this._logService.error(err);
    });
    this._register(this._extHostWorkspace.onDidChangeWorkspace((e) => this._handleWorkspaceContainsEagerExtensions(e.added)));
    const folders = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [];
    const workspaceContainsActivation = this._handleWorkspaceContainsEagerExtensions(folders);
    const remoteResolverActivation = this._handleRemoteResolverEagerExtensions();
    const eagerExtensionsActivation = Promise.all([remoteResolverActivation, starActivation, workspaceContainsActivation]).then(() => {
    });
    Promise.race([eagerExtensionsActivation, timeout(1e4)]).then(() => {
      this._activateAllStartupFinished();
    });
    return eagerExtensionsActivation;
  }
  _handleWorkspaceContainsEagerExtensions(folders) {
    if (folders.length === 0) {
      return Promise.resolve(void 0);
    }
    return Promise.all(this._myRegistry.getAllExtensionDescriptions().map((desc) => {
      return this._handleWorkspaceContainsEagerExtension(folders, desc);
    })).then(() => {
    });
  }
  async _handleWorkspaceContainsEagerExtension(folders, desc) {
    if (this.isActivated(desc.identifier)) {
      return;
    }
    const localWithRemote = !this._initData.remote.isRemote && !!this._initData.remote.authority;
    const host = {
      logService: this._logService,
      folders: folders.map((folder) => folder.uri),
      forceUsingSearch: localWithRemote || !this._hostUtils.fsExists,
      exists: (uri) => this._hostUtils.fsExists(uri.fsPath),
      checkExists: (folders2, includes, token) => this._mainThreadWorkspaceProxy.$checkExists(folders2, includes, token)
    };
    const result = await checkActivateWorkspaceContainsExtension(host, desc);
    if (!result) {
      return;
    }
    return this._activateById(desc.identifier, { startup: true, extensionId: desc.identifier, activationEvent: result.activationEvent }).then(void 0, (err) => this._logService.error(err));
  }
  async _handleRemoteResolverEagerExtensions() {
    if (this._initData.remote.authority) {
      return this._activateByEvent(`onResolveRemoteAuthority:${this._initData.remote.authority}`, false);
    }
  }
  async $extensionTestsExecute() {
    await this._eagerExtensionsActivated.wait();
    try {
      return await this._doHandleExtensionTests();
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
  async _doHandleExtensionTests() {
    const { extensionDevelopmentLocationURI, extensionTestsLocationURI } = this._initData.environment;
    if (!extensionDevelopmentLocationURI || !extensionTestsLocationURI) {
      throw new Error(localize(3010, null));
    }
    const extensionDescription = (await this.getExtensionPathIndex()).findSubstr(extensionTestsLocationURI);
    const isESM = this._isESM(extensionDescription, extensionTestsLocationURI.path);
    const testRunner = await (isESM ? this._loadESMModule(null, extensionTestsLocationURI, new ExtensionActivationTimesBuilder(false)) : this._loadCommonJSModule(null, extensionTestsLocationURI, new ExtensionActivationTimesBuilder(false)));
    if (!testRunner || typeof testRunner.run !== "function") {
      throw new Error(localize(3011, null, extensionTestsLocationURI.toString()));
    }
    return new Promise((resolve2, reject) => {
      const oldTestRunnerCallback = (error, failures) => {
        if (error) {
          if (isCI) {
            this._logService.error(`Test runner called back with error`, error);
          }
          reject(error);
        } else {
          if (isCI) {
            if (failures) {
              this._logService.info(`Test runner called back with ${failures} failures.`);
            } else {
              this._logService.info(`Test runner called back with successful outcome.`);
            }
          }
          resolve2(
            typeof failures === "number" && failures > 0 ? 1 : 0
            /* OK */
          );
        }
      };
      const extensionTestsPath = originalFSPath(extensionTestsLocationURI);
      const runResult = testRunner.run(extensionTestsPath, oldTestRunnerCallback);
      if (runResult && runResult.then) {
        runResult.then(() => {
          if (isCI) {
            this._logService.info(`Test runner finished successfully.`);
          }
          resolve2(0);
        }).catch((err) => {
          if (isCI) {
            this._logService.error(`Test runner finished with error`, err);
          }
          reject(err instanceof Error && err.stack ? err.stack : String(err));
        });
      }
    });
  }
  _startExtensionHost() {
    if (this._started) {
      throw new Error(`Extension host is already started!`);
    }
    this._started = true;
    return this._readyToStartExtensionHost.wait().then(() => this._readyToRunExtensions.open()).then(() => {
      return Promise.race([this._activator.waitForActivatingExtensions(), timeout(1e3)]);
    }).then(() => this._handleEagerExtensions()).then(() => {
      this._eagerExtensionsActivated.open();
      this._logService.info(`Eager extensions activated`);
    });
  }
  // -- called by extensions
  registerRemoteAuthorityResolver(authorityPrefix, resolver) {
    this._resolvers[authorityPrefix] = resolver;
    return toDisposable(() => {
      delete this._resolvers[authorityPrefix];
    });
  }
  async getRemoteExecServer(remoteAuthority) {
    const { resolver } = await this._activateAndGetResolver(remoteAuthority);
    return resolver?.resolveExecServer?.(remoteAuthority, { resolveAttempt: 0 });
  }
  // -- called by main thread
  async _activateAndGetResolver(remoteAuthority) {
    const authorityPlusIndex = remoteAuthority.indexOf("+");
    if (authorityPlusIndex === -1) {
      throw new RemoteAuthorityResolverError(`Not an authority that can be resolved!`, RemoteAuthorityResolverErrorCode.InvalidAuthority);
    }
    const authorityPrefix = remoteAuthority.substr(0, authorityPlusIndex);
    await this._almostReadyToRunExtensions.wait();
    await this._activateByEvent(`onResolveRemoteAuthority:${authorityPrefix}`, false);
    return { authorityPrefix, resolver: this._resolvers[authorityPrefix] };
  }
  async $resolveAuthority(remoteAuthorityChain, resolveAttempt) {
    const sw = StopWatch.create(false);
    const prefix = () => `[resolveAuthority(${getRemoteAuthorityPrefix(remoteAuthorityChain)},${resolveAttempt})][${sw.elapsed()}ms] `;
    const logInfo = (msg) => this._logService.info(`${prefix()}${msg}`);
    const logWarning = (msg) => this._logService.warn(`${prefix()}${msg}`);
    const logError = (msg, err = void 0) => this._logService.error(`${prefix()}${msg}`, err);
    const normalizeError = (err) => {
      if (err instanceof RemoteAuthorityResolverError) {
        return {
          type: "error",
          error: {
            code: err._code,
            message: err._message,
            detail: err._detail
          }
        };
      }
      throw err;
    };
    const getResolver = async (remoteAuthority) => {
      logInfo(`activating resolver for ${remoteAuthority}...`);
      const { resolver, authorityPrefix } = await this._activateAndGetResolver(remoteAuthority);
      if (!resolver) {
        logError(`no resolver for ${authorityPrefix}`);
        throw new RemoteAuthorityResolverError(`No remote extension installed to resolve ${authorityPrefix}.`, RemoteAuthorityResolverErrorCode.NoResolverFound);
      }
      return { resolver, authorityPrefix, remoteAuthority };
    };
    const chain = remoteAuthorityChain.split(/@|%40/g).reverse();
    logInfo(`activating remote resolvers ${chain.join(" -> ")}`);
    let resolvers;
    try {
      resolvers = await Promise.all(chain.map(getResolver)).catch(async (e) => {
        if (!(e instanceof RemoteAuthorityResolverError) || e._code !== RemoteAuthorityResolverErrorCode.InvalidAuthority) {
          throw e;
        }
        logWarning(`resolving nested authorities failed: ${e.message}`);
        return [await getResolver(remoteAuthorityChain)];
      });
    } catch (e) {
      return normalizeError(e);
    }
    const intervalLogger = new IntervalTimer();
    intervalLogger.cancelAndSet(() => logInfo("waiting..."), 1e3);
    let result;
    let execServer;
    for (const [i, { authorityPrefix, resolver, remoteAuthority }] of resolvers.entries()) {
      try {
        if (i === resolvers.length - 1) {
          logInfo(`invoking final resolve()...`);
          mark(`code/extHost/willResolveAuthority/${authorityPrefix}`);
          result = await resolver.resolve(remoteAuthority, { resolveAttempt, execServer });
          mark(`code/extHost/didResolveAuthorityOK/${authorityPrefix}`);
          logInfo(`setting tunnel factory...`);
          this._register(await this._extHostTunnelService.setTunnelFactory(resolver, ManagedResolvedAuthority.isManagedResolvedAuthority(result) ? result : void 0));
        } else {
          logInfo(`invoking resolveExecServer() for ${remoteAuthority}`);
          mark(`code/extHost/willResolveExecServer/${authorityPrefix}`);
          execServer = await resolver.resolveExecServer?.(remoteAuthority, { resolveAttempt, execServer });
          if (!execServer) {
            throw new RemoteAuthorityResolverError(`Exec server was not available for ${remoteAuthority}`, RemoteAuthorityResolverErrorCode.NoResolverFound);
          }
          mark(`code/extHost/didResolveExecServerOK/${authorityPrefix}`);
        }
      } catch (e) {
        mark(`code/extHost/didResolveAuthorityError/${authorityPrefix}`);
        logError(`returned an error`, e);
        intervalLogger.dispose();
        return normalizeError(e);
      }
    }
    intervalLogger.dispose();
    const tunnelInformation = {
      environmentTunnels: result.environmentTunnels,
      features: result.tunnelFeatures ? {
        elevation: result.tunnelFeatures.elevation,
        privacyOptions: result.tunnelFeatures.privacyOptions,
        protocol: result.tunnelFeatures.protocol === void 0 ? true : result.tunnelFeatures.protocol
      } : void 0
    };
    const options2 = {
      extensionHostEnv: result.extensionHostEnv,
      isTrusted: result.isTrusted,
      authenticationSession: result.authenticationSessionForInitializingExtensions ? { id: result.authenticationSessionForInitializingExtensions.id, providerId: result.authenticationSessionForInitializingExtensions.providerId } : void 0
    };
    logInfo(`returned ${ManagedResolvedAuthority.isManagedResolvedAuthority(result) ? "managed authority" : `${result.host}:${result.port}`}`);
    let authority;
    if (ManagedResolvedAuthority.isManagedResolvedAuthority(result)) {
      const socketFactoryId = resolveAttempt;
      this._extHostManagedSockets.setFactory(socketFactoryId, result.makeConnection);
      authority = {
        authority: remoteAuthorityChain,
        connectTo: new ManagedRemoteConnection(socketFactoryId),
        connectionToken: result.connectionToken
      };
    } else {
      authority = {
        authority: remoteAuthorityChain,
        connectTo: new WebSocketRemoteConnection(result.host, result.port),
        connectionToken: result.connectionToken
      };
    }
    return {
      type: "ok",
      value: {
        authority,
        options: options2,
        tunnelInformation
      }
    };
  }
  async $getCanonicalURI(remoteAuthority, uriComponents) {
    this._logService.info(`$getCanonicalURI invoked for authority (${getRemoteAuthorityPrefix(remoteAuthority)})`);
    const { resolver } = await this._activateAndGetResolver(remoteAuthority);
    if (!resolver) {
      return null;
    }
    const uri = URI.revive(uriComponents);
    if (typeof resolver.getCanonicalURI === "undefined") {
      return uri;
    }
    const result = await asPromise(() => resolver.getCanonicalURI(uri));
    if (!result) {
      return uri;
    }
    return result;
  }
  async $startExtensionHost(extensionsDelta) {
    extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));
    const { globalRegistry, myExtensions } = applyExtensionsDelta(this._activationEventsReader, this._globalRegistry, this._myRegistry, extensionsDelta);
    const newSearchTree = await this._createExtensionPathIndex(myExtensions);
    const extensionsPaths = await this.getExtensionPathIndex();
    extensionsPaths.setSearchTree(newSearchTree);
    this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());
    this._myRegistry.set(myExtensions);
    if (isCI) {
      this._logService.info(`$startExtensionHost: global extensions: ${printExtIds(this._globalRegistry)}`);
      this._logService.info(`$startExtensionHost: local extensions: ${printExtIds(this._myRegistry)}`);
    }
    return this._startExtensionHost();
  }
  $activateByEvent(activationEvent, activationKind) {
    if (activationKind === 1) {
      return this._almostReadyToRunExtensions.wait().then((_) => this._activateByEvent(activationEvent, false));
    }
    return this._readyToRunExtensions.wait().then((_) => this._activateByEvent(activationEvent, false));
  }
  async $activate(extensionId, reason) {
    await this._readyToRunExtensions.wait();
    if (!this._myRegistry.getExtensionDescription(extensionId)) {
      return false;
    }
    await this._activateById(extensionId, reason);
    return true;
  }
  async $deltaExtensions(extensionsDelta) {
    extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));
    const { globalRegistry, myExtensions } = applyExtensionsDelta(this._activationEventsReader, this._globalRegistry, this._myRegistry, extensionsDelta);
    const newSearchTree = await this._createExtensionPathIndex(myExtensions);
    const extensionsPaths = await this.getExtensionPathIndex();
    extensionsPaths.setSearchTree(newSearchTree);
    this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());
    this._myRegistry.set(myExtensions);
    if (isCI) {
      this._logService.info(`$deltaExtensions: global extensions: ${printExtIds(this._globalRegistry)}`);
      this._logService.info(`$deltaExtensions: local extensions: ${printExtIds(this._myRegistry)}`);
    }
    return Promise.resolve(void 0);
  }
  async $test_latency(n) {
    return n;
  }
  async $test_up(b) {
    return b.byteLength;
  }
  async $test_down(size) {
    const buff = VSBuffer.alloc(size);
    const value = Math.random() % 256;
    for (let i = 0; i < size; i++) {
      buff.writeUInt8(value, i);
    }
    return buff;
  }
  async $updateRemoteConnectionData(connectionData) {
    this._remoteConnectionData = connectionData;
    this._onDidChangeRemoteConnectionData.fire();
  }
  _isESM(extensionDescription, modulePath) {
    modulePath ??= extensionDescription ? this._getEntryPoint(extensionDescription) : modulePath;
    return modulePath?.endsWith(".mjs") || extensionDescription?.type === "module" && !modulePath?.endsWith(".cjs");
  }
};
AbstractExtHostExtensionService = AbstractExtHostExtensionService_1 = __decorate([
  __param(0, IInstantiationService),
  __param(1, IHostUtils),
  __param(2, IExtHostRpcService),
  __param(3, IExtHostWorkspace),
  __param(4, IExtHostConfiguration),
  __param(5, ILogService),
  __param(6, IExtHostInitDataService),
  __param(7, IExtensionStoragePaths),
  __param(8, IExtHostTunnelService),
  __param(9, IExtHostTerminalService),
  __param(10, IExtHostLocalizationService),
  __param(11, IExtHostManagedSockets),
  __param(12, IExtHostLanguageModels)
], AbstractExtHostExtensionService);
function applyExtensionsDelta(activationEventsReader, oldGlobalRegistry, oldMyRegistry, extensionsDelta) {
  activationEventsReader.addActivationEvents(extensionsDelta.addActivationEvents);
  const globalRegistry = new ExtensionDescriptionRegistry(activationEventsReader, oldGlobalRegistry.getAllExtensionDescriptions());
  globalRegistry.deltaExtensions(extensionsDelta.toAdd, extensionsDelta.toRemove);
  const myExtensionsSet = new ExtensionIdentifierSet(oldMyRegistry.getAllExtensionDescriptions().map((extension) => extension.identifier));
  for (const extensionId of extensionsDelta.myToRemove) {
    myExtensionsSet.delete(extensionId);
  }
  for (const extensionId of extensionsDelta.myToAdd) {
    myExtensionsSet.add(extensionId);
  }
  const myExtensions = filterExtensions(globalRegistry, myExtensionsSet);
  return { globalRegistry, myExtensions };
}
function getTelemetryActivationEvent(extensionDescription, reason) {
  const event = {
    id: extensionDescription.identifier.value,
    name: extensionDescription.name,
    extensionVersion: extensionDescription.version,
    publisherDisplayName: extensionDescription.publisher,
    activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(",") : null,
    isBuiltin: extensionDescription.isBuiltin,
    reason: reason.activationEvent,
    reasonId: reason.extensionId.value
  };
  return event;
}
function printExtIds(registry) {
  return registry.getAllExtensionDescriptions().map((ext) => ext.identifier.value).join(",");
}
var IExtHostExtensionService = createDecorator("IExtHostExtensionService");
var Extension = class {
  #extensionService;
  #originExtensionId;
  #identifier;
  constructor(extensionService, originExtensionId, description, kind, isFromDifferentExtensionHost) {
    this.#extensionService = extensionService;
    this.#originExtensionId = originExtensionId;
    this.#identifier = description.identifier;
    this.id = description.identifier.value;
    this.extensionUri = description.extensionLocation;
    this.extensionPath = normalize(originalFSPath(description.extensionLocation));
    this.packageJSON = description;
    this.extensionKind = kind;
    this.isFromDifferentExtensionHost = isFromDifferentExtensionHost;
  }
  get isActive() {
    return this.#extensionService.isActivated(this.#identifier);
  }
  get exports() {
    if (this.packageJSON.api === "none" || this.isFromDifferentExtensionHost) {
      return void 0;
    }
    return this.#extensionService.getExtensionExports(this.#identifier);
  }
  async activate() {
    if (this.isFromDifferentExtensionHost) {
      throw new Error("Cannot activate foreign extension");
    }
    await this.#extensionService.activateByIdWithErrors(this.#identifier, { startup: false, extensionId: this.#originExtensionId, activationEvent: "api" });
    return this.exports;
  }
};
function filterExtensions(globalRegistry, desiredExtensions) {
  return globalRegistry.getAllExtensionDescriptions().filter((extension) => desiredExtensions.has(extension.identifier));
}
var ExtensionPaths = class {
  constructor(_searchTree) {
    this._searchTree = _searchTree;
  }
  setSearchTree(searchTree) {
    this._searchTree = searchTree;
  }
  findSubstr(key) {
    return this._searchTree.findSubstr(key);
  }
  forEach(callback) {
    return this._searchTree.forEach(callback);
  }
};
var SyncedActivationEventsReader = class {
  constructor(activationEvents) {
    this._map = new ExtensionIdentifierMap();
    this.addActivationEvents(activationEvents);
  }
  readActivationEvents(extensionDescription) {
    return this._map.get(extensionDescription.identifier) ?? [];
  }
  addActivationEvents(activationEvents) {
    for (const extensionId of Object.keys(activationEvents)) {
      this._map.set(extensionId, activationEvents[extensionId]);
    }
  }
};

// out-build/vs/workbench/api/common/extHostApiDeprecationService.js
var IExtHostApiDeprecationService = createDecorator("IExtHostApiDeprecationService");
var ExtHostApiDeprecationService = class ExtHostApiDeprecationService2 {
  constructor(rpc, _extHostLogService) {
    this._extHostLogService = _extHostLogService;
    this._reportedUsages = /* @__PURE__ */ new Set();
    this._telemetryShape = rpc.getProxy(MainContext.MainThreadTelemetry);
  }
  report(apiId, extension, migrationSuggestion) {
    const key = this.getUsageKey(apiId, extension);
    if (this._reportedUsages.has(key)) {
      return;
    }
    this._reportedUsages.add(key);
    if (extension.isUnderDevelopment) {
      this._extHostLogService.warn(`[Deprecation Warning] '${apiId}' is deprecated. ${migrationSuggestion}`);
    }
    this._telemetryShape.$publicLog2("extHostDeprecatedApiUsage", {
      extensionId: extension.identifier.value,
      apiId
    });
  }
  getUsageKey(apiId, extension) {
    return `${apiId}-${extension.identifier.value}`;
  }
};
ExtHostApiDeprecationService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService)
], ExtHostApiDeprecationService);
var NullApiDeprecationService = Object.freeze(new class {
  report(_apiId, _extension, _warningMessage) {
  }
}());

// out-build/vs/workbench/api/common/extensionHostMain.js
var ErrorHandler2 = class {
  static async installEarlyHandler(accessor) {
    Error.stackTraceLimit = 100;
    const logService = accessor.get(ILogService);
    const rpcService = accessor.get(IExtHostRpcService);
    const mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);
    setUnexpectedErrorHandler((err) => {
      logService.error(err);
      const data2 = transformErrorForSerialization(err);
      mainThreadErrors.$onUnexpectedError(data2);
    });
  }
  static async installFullHandler(accessor) {
    const logService = accessor.get(ILogService);
    const rpcService = accessor.get(IExtHostRpcService);
    const extensionService = accessor.get(IExtHostExtensionService);
    const extensionTelemetry = accessor.get(IExtHostTelemetry);
    const apiDeprecationService = accessor.get(IExtHostApiDeprecationService);
    const mainThreadExtensions = rpcService.getProxy(MainContext.MainThreadExtensionService);
    const mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);
    const extensionsRegistry = await extensionService.getExtensionRegistry();
    const extensionsMap = await extensionService.getExtensionPathIndex();
    const extensionErrors = /* @__PURE__ */ new WeakMap();
    function prepareStackTraceAndFindExtension(error, stackTrace) {
      if (extensionErrors.has(error)) {
        return extensionErrors.get(error).stack;
      }
      let stackTraceMessage = "";
      let extension;
      let fileName;
      for (const call of stackTrace) {
        stackTraceMessage += `
	at ${call.toString()}`;
        fileName = call.getFileName();
        if (!extension && fileName) {
          extension = extensionsMap.findSubstr(URI.file(fileName));
        }
      }
      const result = `${error.name || "Error"}: ${error.message || ""}${stackTraceMessage}`;
      extensionErrors.set(error, { extensionIdentifier: extension?.identifier, stack: result });
      return result;
    }
    const _wasWrapped = Symbol("prepareStackTrace wrapped");
    let _prepareStackTrace = prepareStackTraceAndFindExtension;
    Object.defineProperty(Error, "prepareStackTrace", {
      configurable: false,
      get() {
        return _prepareStackTrace;
      },
      set(v) {
        if (v === prepareStackTraceAndFindExtension || !v || v[_wasWrapped]) {
          _prepareStackTrace = v || prepareStackTraceAndFindExtension;
          return;
        }
        _prepareStackTrace = function(error, stackTrace) {
          prepareStackTraceAndFindExtension(error, stackTrace);
          return v.call(Error, error, stackTrace);
        };
        Object.assign(_prepareStackTrace, { [_wasWrapped]: true });
      }
    });
    setUnexpectedErrorHandler((err) => {
      if (!PendingMigrationError.is(err)) {
        logService.error(err);
      }
      const errorData = transformErrorForSerialization(err);
      let extension;
      if (err instanceof ExtensionError) {
        extension = err.extension;
      } else {
        const stackData = extensionErrors.get(err);
        extension = stackData?.extensionIdentifier;
      }
      if (!extension) {
        return;
      }
      if (PendingMigrationError.is(err)) {
        const extensionDesc = extensionsRegistry.getExtensionDescription(extension);
        if (extensionDesc) {
          apiDeprecationService.report(err.name, extensionDesc, `${err.message}
 FROM: ${err.stack}`);
        }
      } else {
        mainThreadExtensions.$onExtensionRuntimeError(extension, errorData);
        const reported = extensionTelemetry.onExtensionError(extension, err);
        logService.trace("forwarded error to extension?", reported, extension);
      }
    });
    errorHandler.addListener((err) => {
      mainThreadErrors.$onUnexpectedError(err);
    });
  }
};
var ExtensionHostMain = class _ExtensionHostMain {
  constructor(protocol, initData, hostUtils, uriTransformer, messagePorts) {
    this._hostUtils = hostUtils;
    this._rpcProtocol = new RPCProtocol(protocol, null, uriTransformer);
    initData = _ExtensionHostMain._transform(initData, this._rpcProtocol);
    const services = new ServiceCollection(...getSingletonServiceDescriptors());
    services.set(IExtHostInitDataService, { _serviceBrand: void 0, ...initData, messagePorts });
    services.set(IExtHostRpcService, new ExtHostRpcService(this._rpcProtocol));
    services.set(IURITransformerService, new URITransformerService(uriTransformer));
    services.set(IHostUtils, hostUtils);
    const instaService = new InstantiationService(services, true);
    instaService.invokeFunction(ErrorHandler2.installEarlyHandler);
    this._logService = instaService.invokeFunction((accessor) => accessor.get(ILogService));
    mark(`code/extHost/didCreateServices`);
    if (this._hostUtils.pid) {
      this._logService.info(`Extension host with pid ${this._hostUtils.pid} started`);
    } else {
      this._logService.info(`Extension host started`);
    }
    this._logService.trace("initData", initData);
    this._extensionService = instaService.invokeFunction((accessor) => accessor.get(IExtHostExtensionService));
    this._extensionService.initialize();
    instaService.invokeFunction(ErrorHandler2.installFullHandler);
  }
  async asBrowserUri(uri) {
    const mainThreadExtensionsProxy = this._rpcProtocol.getProxy(MainContext.MainThreadExtensionService);
    return URI.revive(await mainThreadExtensionsProxy.$asBrowserUri(uri));
  }
  terminate(reason) {
    this._extensionService.terminate(reason);
  }
  static _transform(initData, rpcProtocol) {
    initData.extensions.allExtensions.forEach((ext) => {
      ext.extensionLocation = URI.revive(rpcProtocol.transformIncomingURIs(ext.extensionLocation));
    });
    initData.environment.appRoot = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.appRoot));
    const extDevLocs = initData.environment.extensionDevelopmentLocationURI;
    if (extDevLocs) {
      initData.environment.extensionDevelopmentLocationURI = extDevLocs.map((url) => URI.revive(rpcProtocol.transformIncomingURIs(url)));
    }
    initData.environment.extensionTestsLocationURI = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTestsLocationURI));
    initData.environment.globalStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.globalStorageHome));
    initData.environment.workspaceStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.workspaceStorageHome));
    initData.nlsBaseUrl = URI.revive(rpcProtocol.transformIncomingURIs(initData.nlsBaseUrl));
    initData.logsLocation = URI.revive(rpcProtocol.transformIncomingURIs(initData.logsLocation));
    initData.workspace = rpcProtocol.transformIncomingURIs(initData.workspace);
    return initData;
  }
};

// out-build/vs/workbench/services/extensions/worker/polyfillNestedWorker.js
var _bootstrapFnSource = function _bootstrapFn(workerUrl) {
  const listener = (event) => {
    globalThis.removeEventListener("message", listener);
    const port = event.data;
    Object.defineProperties(globalThis, {
      "postMessage": {
        value(data2, transferOrOptions) {
          port.postMessage(data2, transferOrOptions);
        }
      },
      "onmessage": {
        get() {
          return port.onmessage;
        },
        set(value) {
          port.onmessage = value;
        }
      }
      // todo onerror
    });
    port.addEventListener("message", (msg) => {
      globalThis.dispatchEvent(new MessageEvent("message", { data: msg.data, ports: msg.ports ? [...msg.ports] : void 0 }));
    });
    port.start();
    globalThis.Worker = class {
      constructor() {
        throw new TypeError("Nested workers from within nested worker are NOT supported.");
      }
    };
    importScripts(workerUrl);
  };
  globalThis.addEventListener("message", listener);
}.toString();
var NestedWorker = class extends EventTarget {
  constructor(nativePostMessage2, stringOrUrl, options2) {
    super();
    this.onmessage = null;
    this.onmessageerror = null;
    this.onerror = null;
    const bootstrap = `((${_bootstrapFnSource})('${stringOrUrl}'))`;
    const blob = new Blob([bootstrap], { type: "application/javascript" });
    const blobUrl = URL.createObjectURL(blob);
    const channel = new MessageChannel();
    const id2 = blobUrl;
    const msg = {
      type: "_newWorker",
      id: id2,
      port: channel.port2,
      url: blobUrl,
      options: options2
    };
    nativePostMessage2(msg, [channel.port2]);
    this.postMessage = channel.port1.postMessage.bind(channel.port1);
    this.terminate = () => {
      const msg2 = {
        type: "_terminateWorker",
        id: id2
      };
      nativePostMessage2(msg2);
      URL.revokeObjectURL(blobUrl);
      channel.port1.close();
      channel.port2.close();
    };
    Object.defineProperties(this, {
      "onmessage": {
        get() {
          return channel.port1.onmessage;
        },
        set(value) {
          channel.port1.onmessage = value;
        }
      },
      "onmessageerror": {
        get() {
          return channel.port1.onmessageerror;
        },
        set(value) {
          channel.port1.onmessageerror = value;
        }
      }
      // todo onerror
    });
    channel.port1.addEventListener("messageerror", (evt) => {
      const msgEvent = new MessageEvent("messageerror", { data: evt.data });
      this.dispatchEvent(msgEvent);
    });
    channel.port1.addEventListener("message", (evt) => {
      const msgEvent = new MessageEvent("message", { data: evt.data });
      this.dispatchEvent(msgEvent);
    });
    channel.port1.start();
  }
};

// out-build/vs/workbench/services/output/common/output.js
var CONTEXT_IN_OUTPUT = new RawContextKey("inOutput", false);
var CONTEXT_ACTIVE_FILE_OUTPUT = new RawContextKey("activeLogOutput", false);
var CONTEXT_ACTIVE_LOG_FILE_OUTPUT = new RawContextKey("activeLogOutput.isLog", false);
var CONTEXT_ACTIVE_OUTPUT_LEVEL_SETTABLE = new RawContextKey("activeLogOutput.levelSettable", false);
var CONTEXT_ACTIVE_OUTPUT_LEVEL = new RawContextKey("activeLogOutput.level", "");
var CONTEXT_ACTIVE_OUTPUT_LEVEL_IS_DEFAULT = new RawContextKey("activeLogOutput.levelIsDefault", false);
var CONTEXT_OUTPUT_SCROLL_LOCK = new RawContextKey(`outputView.scrollLock`, false);
var ACTIVE_OUTPUT_CHANNEL_CONTEXT = new RawContextKey("activeOutputChannel", "");
var SHOW_TRACE_FILTER_CONTEXT = new RawContextKey("output.filter.trace", true);
var SHOW_DEBUG_FILTER_CONTEXT = new RawContextKey("output.filter.debug", true);
var SHOW_INFO_FILTER_CONTEXT = new RawContextKey("output.filter.info", true);
var SHOW_WARNING_FILTER_CONTEXT = new RawContextKey("output.filter.warning", true);
var SHOW_ERROR_FILTER_CONTEXT = new RawContextKey("output.filter.error", true);
var OUTPUT_FILTER_FOCUS_CONTEXT = new RawContextKey("outputFilterFocus", false);
var HIDE_CATEGORY_FILTER_CONTEXT = new RawContextKey("output.filter.categories", "");
var IOutputService = createDecorator("outputService");
var OutputChannelUpdateMode;
(function(OutputChannelUpdateMode2) {
  OutputChannelUpdateMode2[OutputChannelUpdateMode2["Append"] = 1] = "Append";
  OutputChannelUpdateMode2[OutputChannelUpdateMode2["Replace"] = 2] = "Replace";
  OutputChannelUpdateMode2[OutputChannelUpdateMode2["Clear"] = 3] = "Clear";
})(OutputChannelUpdateMode || (OutputChannelUpdateMode = {}));
var Extensions3 = {
  OutputChannels: "workbench.contributions.outputChannels"
};
function isMultiSourceOutputChannelDescriptor(descriptor) {
  return Array.isArray(descriptor.source);
}
var OutputChannelRegistry = class extends Disposable {
  constructor() {
    super(...arguments);
    this.channels = /* @__PURE__ */ new Map();
    this._onDidRegisterChannel = this._register(new Emitter());
    this.onDidRegisterChannel = this._onDidRegisterChannel.event;
    this._onDidRemoveChannel = this._register(new Emitter());
    this.onDidRemoveChannel = this._onDidRemoveChannel.event;
    this._onDidUpdateChannelFiles = this._register(new Emitter());
    this.onDidUpdateChannelSources = this._onDidUpdateChannelFiles.event;
  }
  registerChannel(descriptor) {
    if (!this.channels.has(descriptor.id)) {
      this.channels.set(descriptor.id, descriptor);
      this._onDidRegisterChannel.fire(descriptor.id);
    }
  }
  getChannels() {
    const result = [];
    this.channels.forEach((value) => result.push(value));
    return result;
  }
  getChannel(id2) {
    return this.channels.get(id2);
  }
  updateChannelSources(id2, sources) {
    const channel = this.channels.get(id2);
    if (channel && isMultiSourceOutputChannelDescriptor(channel)) {
      channel.source = sources;
      this._onDidUpdateChannelFiles.fire(channel);
    }
  }
  removeChannel(id2) {
    const channel = this.channels.get(id2);
    if (channel) {
      this.channels.delete(id2);
      this._onDidRemoveChannel.fire(channel);
    }
  }
};
Registry.add(Extensions3.OutputChannels, new OutputChannelRegistry());

// out-build/vs/workbench/api/common/extHostOutput.js
var ExtHostOutputChannel = class extends AbstractMessageLogger {
  constructor(id2, name2, logger, proxy, extension) {
    super();
    this.id = id2;
    this.name = name2;
    this.logger = logger;
    this.proxy = proxy;
    this.extension = extension;
    this.offset = 0;
    this.visible = false;
    this.setLevel(logger.getLevel());
    this._register(logger.onDidChangeLogLevel((level) => this.setLevel(level)));
    this._register(toDisposable(() => this.proxy.$dispose(this.id)));
  }
  get logLevel() {
    return this.getLevel();
  }
  appendLine(value) {
    this.append(value + "\n");
  }
  append(value) {
    this.info(value);
  }
  clear() {
    const till = this.offset;
    this.logger.flush();
    this.proxy.$update(this.id, OutputChannelUpdateMode.Clear, till);
  }
  replace(value) {
    const till = this.offset;
    this.info(value);
    this.proxy.$update(this.id, OutputChannelUpdateMode.Replace, till);
    if (this.visible) {
      this.logger.flush();
    }
  }
  show(columnOrPreserveFocus, preserveFocus) {
    this.logger.flush();
    this.proxy.$reveal(this.id, !!(typeof columnOrPreserveFocus === "boolean" ? columnOrPreserveFocus : preserveFocus));
  }
  hide() {
    this.proxy.$close(this.id);
  }
  log(level, message) {
    this.offset += VSBuffer.fromString(message).byteLength;
    log(this.logger, level, message);
    if (this.visible) {
      this.logger.flush();
      this.proxy.$update(this.id, OutputChannelUpdateMode.Append);
    }
  }
};
var ExtHostLogOutputChannel = class extends ExtHostOutputChannel {
  appendLine(value) {
    this.append(value);
  }
};
var ExtHostOutputService = class ExtHostOutputService2 {
  constructor(extHostRpc, initData, extHostFileSystem, extHostFileSystemInfo, loggerService, logService) {
    this.initData = initData;
    this.extHostFileSystem = extHostFileSystem;
    this.extHostFileSystemInfo = extHostFileSystemInfo;
    this.loggerService = loggerService;
    this.logService = logService;
    this.extensionLogDirectoryPromise = /* @__PURE__ */ new Map();
    this.namePool = 1;
    this.channels = /* @__PURE__ */ new Map();
    this.visibleChannelId = null;
    this.proxy = extHostRpc.getProxy(MainContext.MainThreadOutputService);
    this.outputsLocation = this.extHostFileSystemInfo.extUri.joinPath(initData.logsLocation, `output_logging_${toLocalISOString(/* @__PURE__ */ new Date()).replace(/-|:|\.\d+Z$/g, "")}`);
  }
  $setVisibleChannel(visibleChannelId) {
    this.visibleChannelId = visibleChannelId;
    for (const [id2, channel] of this.channels) {
      channel.visible = id2 === this.visibleChannelId;
    }
  }
  createOutputChannel(name2, options2, extension) {
    name2 = name2.trim();
    if (!name2) {
      throw new Error("illegal argument `name`. must not be falsy");
    }
    const log2 = typeof options2 === "object" && options2.log;
    const languageId = isString(options2) ? options2 : void 0;
    if (isString(languageId) && !languageId.trim()) {
      throw new Error("illegal argument `languageId`. must not be empty");
    }
    let logLevel;
    const logLevelValue = this.initData.environment.extensionLogLevel?.find(([identifier]) => ExtensionIdentifier.equals(extension.identifier, identifier))?.[1];
    if (logLevelValue) {
      logLevel = parseLogLevel(logLevelValue);
    }
    const channelDisposables = new DisposableStore();
    const extHostOutputChannel = log2 ? this.doCreateLogOutputChannel(name2, logLevel, extension, channelDisposables) : this.doCreateOutputChannel(name2, languageId, extension, channelDisposables);
    extHostOutputChannel.then((channel) => {
      this.channels.set(channel.id, channel);
      channel.visible = channel.id === this.visibleChannelId;
      channelDisposables.add(toDisposable(() => this.channels.delete(channel.id)));
    });
    return log2 ? this.createExtHostLogOutputChannel(name2, logLevel ?? this.logService.getLevel(), extHostOutputChannel, channelDisposables) : this.createExtHostOutputChannel(name2, extHostOutputChannel, channelDisposables);
  }
  async doCreateOutputChannel(name2, languageId, extension, channelDisposables) {
    if (!this.outputDirectoryPromise) {
      this.outputDirectoryPromise = this.extHostFileSystem.value.createDirectory(this.outputsLocation).then(() => this.outputsLocation);
    }
    const outputDir = await this.outputDirectoryPromise;
    const file = this.extHostFileSystemInfo.extUri.joinPath(outputDir, `${this.namePool++}-${name2.replace(/[\\/:\*\?"<>\|]/g, "")}.log`);
    const logger = channelDisposables.add(this.loggerService.createLogger(file, { logLevel: "always", donotRotate: true, donotUseFormatters: true, hidden: true }));
    const id2 = await this.proxy.$register(name2, file, languageId, extension.identifier.value);
    channelDisposables.add(toDisposable(() => this.loggerService.deregisterLogger(file)));
    return new ExtHostOutputChannel(id2, name2, logger, this.proxy, extension);
  }
  async doCreateLogOutputChannel(name2, logLevel, extension, channelDisposables) {
    const extensionLogDir = await this.createExtensionLogDirectory(extension);
    const fileName = name2.replace(/[\\/:\*\?"<>\|]/g, "");
    const file = this.extHostFileSystemInfo.extUri.joinPath(extensionLogDir, `${fileName}.log`);
    const id2 = `${extension.identifier.value}.${fileName}`;
    const logger = channelDisposables.add(this.loggerService.createLogger(file, { id: id2, name: name2, logLevel, extensionId: extension.identifier.value }));
    channelDisposables.add(toDisposable(() => this.loggerService.deregisterLogger(file)));
    return new ExtHostLogOutputChannel(id2, name2, logger, this.proxy, extension);
  }
  createExtensionLogDirectory(extension) {
    let extensionLogDirectoryPromise = this.extensionLogDirectoryPromise.get(extension.identifier.value);
    if (!extensionLogDirectoryPromise) {
      const extensionLogDirectory = this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation, extension.identifier.value);
      this.extensionLogDirectoryPromise.set(extension.identifier.value, extensionLogDirectoryPromise = (async () => {
        try {
          await this.extHostFileSystem.value.createDirectory(extensionLogDirectory);
        } catch (err) {
          if (toFileSystemProviderErrorCode(err) !== FileSystemProviderErrorCode.FileExists) {
            throw err;
          }
        }
        return extensionLogDirectory;
      })());
    }
    return extensionLogDirectoryPromise;
  }
  createExtHostOutputChannel(name2, channelPromise, channelDisposables) {
    const validate = () => {
      if (channelDisposables.isDisposed) {
        throw new Error("Channel has been closed");
      }
    };
    channelPromise.then((channel) => channelDisposables.add(channel));
    return {
      get name() {
        return name2;
      },
      append(value) {
        validate();
        channelPromise.then((channel) => channel.append(value));
      },
      appendLine(value) {
        validate();
        channelPromise.then((channel) => channel.appendLine(value));
      },
      clear() {
        validate();
        channelPromise.then((channel) => channel.clear());
      },
      replace(value) {
        validate();
        channelPromise.then((channel) => channel.replace(value));
      },
      show(columnOrPreserveFocus, preserveFocus) {
        validate();
        channelPromise.then((channel) => channel.show(columnOrPreserveFocus, preserveFocus));
      },
      hide() {
        validate();
        channelPromise.then((channel) => channel.hide());
      },
      dispose() {
        channelDisposables.dispose();
      }
    };
  }
  createExtHostLogOutputChannel(name2, logLevel, channelPromise, channelDisposables) {
    const validate = () => {
      if (channelDisposables.isDisposed) {
        throw new Error("Channel has been closed");
      }
    };
    const onDidChangeLogLevel = channelDisposables.add(new Emitter());
    function setLogLevel(newLogLevel) {
      logLevel = newLogLevel;
      onDidChangeLogLevel.fire(newLogLevel);
    }
    channelPromise.then((channel) => {
      if (channel.logLevel !== logLevel) {
        setLogLevel(channel.logLevel);
      }
      channelDisposables.add(channel.onDidChangeLogLevel((e) => setLogLevel(e)));
    });
    return {
      ...this.createExtHostOutputChannel(name2, channelPromise, channelDisposables),
      get logLevel() {
        return logLevel;
      },
      onDidChangeLogLevel: onDidChangeLogLevel.event,
      trace(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.trace(value, ...args));
      },
      debug(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.debug(value, ...args));
      },
      info(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.info(value, ...args));
      },
      warn(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.warn(value, ...args));
      },
      error(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.error(value, ...args));
      }
    };
  }
};
ExtHostOutputService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostConsumerFileSystem),
  __param(3, IExtHostFileSystemInfo),
  __param(4, ILoggerService),
  __param(5, ILogService)
], ExtHostOutputService);
var IExtHostOutputService = createDecorator("IExtHostOutputService");

// out-build/vs/workbench/api/common/extHostDecorations.js
var ExtHostDecorations_1;
var ExtHostDecorations = class ExtHostDecorations2 {
  static {
    ExtHostDecorations_1 = this;
  }
  static {
    this._handlePool = 0;
  }
  static {
    this._maxEventSize = 250;
  }
  constructor(extHostRpc, _logService) {
    this._logService = _logService;
    this._provider = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadDecorations);
  }
  registerFileDecorationProvider(provider, extensionDescription) {
    const handle = ExtHostDecorations_1._handlePool++;
    this._provider.set(handle, { provider, extensionDescription });
    this._proxy.$registerDecorationProvider(handle, extensionDescription.identifier.value);
    const listener = provider.onDidChangeFileDecorations && provider.onDidChangeFileDecorations((e) => {
      if (!e) {
        this._proxy.$onDidChange(handle, null);
        return;
      }
      const array = asArray(e);
      if (array.length <= ExtHostDecorations_1._maxEventSize) {
        this._proxy.$onDidChange(handle, array);
        return;
      }
      this._logService.warn("[Decorations] CAPPING events from decorations provider", extensionDescription.identifier.value, array.length);
      const mapped = array.map((uri) => ({ uri, rank: count(uri.path, "/") }));
      const groups = groupBy(mapped, (a, b) => a.rank - b.rank || compare(a.uri.path, b.uri.path));
      const picked = [];
      outer: for (const uris of groups) {
        let lastDirname;
        for (const obj of uris) {
          const myDirname = dirname(obj.uri.path);
          if (lastDirname !== myDirname) {
            lastDirname = myDirname;
            if (picked.push(obj.uri) >= ExtHostDecorations_1._maxEventSize) {
              break outer;
            }
          }
        }
      }
      this._proxy.$onDidChange(handle, picked);
    });
    return new Disposable2(() => {
      listener?.dispose();
      this._proxy.$unregisterDecorationProvider(handle);
      this._provider.delete(handle);
    });
  }
  async $provideDecorations(handle, requests, token) {
    if (!this._provider.has(handle)) {
      return /* @__PURE__ */ Object.create(null);
    }
    const result = /* @__PURE__ */ Object.create(null);
    const { provider, extensionDescription: extensionId } = this._provider.get(handle);
    await Promise.all(requests.map(async (request) => {
      try {
        const { uri, id: id2 } = request;
        const data2 = await Promise.resolve(provider.provideFileDecoration(URI.revive(uri), token));
        if (!data2) {
          return;
        }
        try {
          FileDecoration.validate(data2);
          if (data2.badge && typeof data2.badge !== "string") {
            checkProposedApiEnabled(extensionId, "codiconDecoration");
          }
          result[id2] = [data2.propagate, data2.tooltip, data2.badge, data2.color];
        } catch (e) {
          this._logService.warn(`INVALID decoration from extension '${extensionId.identifier.value}': ${e}`);
        }
      } catch (err) {
        this._logService.error(err);
      }
    }));
    return result;
  }
};
ExtHostDecorations = ExtHostDecorations_1 = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService)
], ExtHostDecorations);
var IExtHostDecorations = createDecorator("IExtHostDecorations");

// out-build/vs/editor/common/model/prefixSumComputer.js
var PrefixSumComputer = class {
  constructor(values) {
    this.values = values;
    this.prefixSum = new Uint32Array(values.length);
    this.prefixSumValidIndex = new Int32Array(1);
    this.prefixSumValidIndex[0] = -1;
  }
  getCount() {
    return this.values.length;
  }
  insertValues(insertIndex, insertValues) {
    insertIndex = toUint32(insertIndex);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    const insertValuesLen = insertValues.length;
    if (insertValuesLen === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length + insertValuesLen);
    this.values.set(oldValues.subarray(0, insertIndex), 0);
    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
    this.values.set(insertValues, insertIndex);
    if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = insertIndex - 1;
    }
    this.prefixSum = new Uint32Array(this.values.length);
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  setValue(index, value) {
    index = toUint32(index);
    value = toUint32(value);
    if (this.values[index] === value) {
      return false;
    }
    this.values[index] = value;
    if (index - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = index - 1;
    }
    return true;
  }
  removeValues(startIndex, count2) {
    startIndex = toUint32(startIndex);
    count2 = toUint32(count2);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    if (startIndex >= oldValues.length) {
      return false;
    }
    const maxCount = oldValues.length - startIndex;
    if (count2 >= maxCount) {
      count2 = maxCount;
    }
    if (count2 === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length - count2);
    this.values.set(oldValues.subarray(0, startIndex), 0);
    this.values.set(oldValues.subarray(startIndex + count2), startIndex);
    this.prefixSum = new Uint32Array(this.values.length);
    if (startIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = startIndex - 1;
    }
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  getTotalSum() {
    if (this.values.length === 0) {
      return 0;
    }
    return this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(index) {
    if (index < 0) {
      return 0;
    }
    index = toUint32(index);
    return this._getPrefixSum(index);
  }
  _getPrefixSum(index) {
    if (index <= this.prefixSumValidIndex[0]) {
      return this.prefixSum[index];
    }
    let startIndex = this.prefixSumValidIndex[0] + 1;
    if (startIndex === 0) {
      this.prefixSum[0] = this.values[0];
      startIndex++;
    }
    if (index >= this.values.length) {
      index = this.values.length - 1;
    }
    for (let i = startIndex; i <= index; i++) {
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    }
    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
    return this.prefixSum[index];
  }
  getIndexOf(sum) {
    sum = Math.floor(sum);
    this.getTotalSum();
    let low = 0;
    let high = this.values.length - 1;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStop = this.prefixSum[mid];
      midStart = midStop - this.values[mid];
      if (sum < midStart) {
        high = mid - 1;
      } else if (sum >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    return new PrefixSumIndexOfResult(mid, sum - midStart);
  }
};
var PrefixSumIndexOfResult = class {
  constructor(index, remainder) {
    this.index = index;
    this.remainder = remainder;
    this._prefixSumIndexOfResultBrand = void 0;
    this.index = index;
    this.remainder = remainder;
  }
};

// out-build/vs/editor/common/model/mirrorTextModel.js
var MirrorTextModel = class {
  constructor(uri, lines, eol, versionId) {
    this._uri = uri;
    this._lines = lines;
    this._eol = eol;
    this._versionId = versionId;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    if (this._cachedTextValue === null) {
      this._cachedTextValue = this._lines.join(this._eol);
    }
    return this._cachedTextValue;
  }
  onEvents(e) {
    if (e.eol && e.eol !== this._eol) {
      this._eol = e.eol;
      this._lineStarts = null;
    }
    const changes = e.changes;
    for (const change of changes) {
      this._acceptDeleteRange(change.range);
      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
    }
    this._versionId = e.versionId;
    this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const eolLength = this._eol.length;
      const linesLength = this._lines.length;
      const lineStartValues = new Uint32Array(linesLength);
      for (let i = 0; i < linesLength; i++) {
        lineStartValues[i] = this._lines[i].length + eolLength;
      }
      this._lineStarts = new PrefixSumComputer(lineStartValues);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(lineIndex, newValue) {
    this._lines[lineIndex] = newValue;
    if (this._lineStarts) {
      this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
    }
  }
  _acceptDeleteRange(range) {
    if (range.startLineNumber === range.endLineNumber) {
      if (range.startColumn === range.endColumn) {
        return;
      }
      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
      return;
    }
    this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
    this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
    if (this._lineStarts) {
      this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
    }
  }
  _acceptInsertText(position, insertText) {
    if (insertText.length === 0) {
      return;
    }
    const insertLines = splitLines(insertText);
    if (insertLines.length === 1) {
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
      return;
    }
    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
    const newLengths = new Uint32Array(insertLines.length - 1);
    for (let i = 1; i < insertLines.length; i++) {
      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
      newLengths[i - 1] = insertLines[i].length + this._eol.length;
    }
    if (this._lineStarts) {
      this._lineStarts.insertValues(position.lineNumber, newLengths);
    }
  }
};

// out-build/vs/editor/common/core/wordHelper.js
var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function createWordRegExp(allowInWords = "") {
  let source = "(-?\\d*\\.\\d\\w*)|([^";
  for (const sep2 of USUAL_WORD_SEPARATORS) {
    if (allowInWords.indexOf(sep2) >= 0) {
      continue;
    }
    source += "\\" + sep2;
  }
  source += "\\s]+)";
  return new RegExp(source, "g");
}
var DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
  let result = DEFAULT_WORD_REGEXP;
  if (wordDefinition && wordDefinition instanceof RegExp) {
    if (!wordDefinition.global) {
      let flags = "g";
      if (wordDefinition.ignoreCase) {
        flags += "i";
      }
      if (wordDefinition.multiline) {
        flags += "m";
      }
      if (wordDefinition.unicode) {
        flags += "u";
      }
      result = new RegExp(wordDefinition.source, flags);
    } else {
      result = wordDefinition;
    }
  }
  result.lastIndex = 0;
  return result;
}
var _defaultConfig = new LinkedList();
_defaultConfig.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function getWordAtText(column, wordDefinition, text, textOffset, config) {
  wordDefinition = ensureValidWordDefinition(wordDefinition);
  if (!config) {
    config = Iterable.first(_defaultConfig);
  }
  if (text.length > config.maxLen) {
    let start = column - config.maxLen / 2;
    if (start < 0) {
      start = 0;
    } else {
      textOffset += start;
    }
    text = text.substring(start, column + config.maxLen / 2);
    return getWordAtText(column, wordDefinition, text, textOffset, config);
  }
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match2 = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config.timeBudget) {
      break;
    }
    const regexIndex = pos - config.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
    if (!thisMatch && match2) {
      break;
    }
    match2 = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match2) {
    const result = {
      word: match2[0],
      startColumn: textOffset + 1 + match2.index,
      endColumn: textOffset + 1 + match2.index + match2[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
  let match2;
  while (match2 = wordDefinition.exec(text)) {
    const matchIndex = match2.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match2;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}

// out-build/vs/workbench/api/common/extHostDocumentData.js
var _languageId2WordDefinition = /* @__PURE__ */ new Map();
function setWordDefinitionFor(languageId, wordDefinition) {
  if (!wordDefinition) {
    _languageId2WordDefinition.delete(languageId);
  } else {
    _languageId2WordDefinition.set(languageId, wordDefinition);
  }
}
function getWordDefinitionFor(languageId) {
  return _languageId2WordDefinition.get(languageId);
}
var ExtHostDocumentData = class extends MirrorTextModel {
  constructor(_proxy, uri, lines, eol, versionId, _languageId, _isDirty, _encoding, _strictInstanceofChecks = true) {
    super(uri, lines, eol, versionId);
    this._proxy = _proxy;
    this._languageId = _languageId;
    this._isDirty = _isDirty;
    this._encoding = _encoding;
    this._strictInstanceofChecks = _strictInstanceofChecks;
    this._isDisposed = false;
  }
  // eslint-disable-next-line local/code-must-use-super-dispose
  dispose() {
    ok(!this._isDisposed);
    this._isDisposed = true;
    this._isDirty = false;
  }
  equalLines(lines) {
    return equals(this._lines, lines);
  }
  get document() {
    if (!this._document) {
      const that = this;
      this._document = {
        get uri() {
          return that._uri;
        },
        get fileName() {
          return that._uri.fsPath;
        },
        get isUntitled() {
          return that._uri.scheme === Schemas.untitled;
        },
        get languageId() {
          return that._languageId;
        },
        get version() {
          return that._versionId;
        },
        get isClosed() {
          return that._isDisposed;
        },
        get isDirty() {
          return that._isDirty;
        },
        get encoding() {
          return that._encoding;
        },
        save() {
          return that._save();
        },
        getText(range) {
          return range ? that._getTextInRange(range) : that.getText();
        },
        get eol() {
          return that._eol === "\n" ? EndOfLine.LF : EndOfLine.CRLF;
        },
        get lineCount() {
          return that._lines.length;
        },
        lineAt(lineOrPos) {
          return that._lineAt(lineOrPos);
        },
        offsetAt(pos) {
          return that._offsetAt(pos);
        },
        positionAt(offset) {
          return that._positionAt(offset);
        },
        validateRange(ran) {
          return that._validateRange(ran);
        },
        validatePosition(pos) {
          return that._validatePosition(pos);
        },
        getWordRangeAtPosition(pos, regexp) {
          return that._getWordRangeAtPosition(pos, regexp);
        },
        [Symbol.for("debug.description")]() {
          return `TextDocument(${that._uri.toString()})`;
        }
      };
    }
    return Object.freeze(this._document);
  }
  _acceptLanguageId(newLanguageId) {
    ok(!this._isDisposed);
    this._languageId = newLanguageId;
  }
  _acceptIsDirty(isDirty) {
    ok(!this._isDisposed);
    this._isDirty = isDirty;
  }
  _acceptEncoding(encoding) {
    ok(!this._isDisposed);
    this._encoding = encoding;
  }
  _save() {
    if (this._isDisposed) {
      return Promise.reject(new Error("Document has been closed"));
    }
    return this._proxy.$trySaveDocument(this._uri);
  }
  _getTextInRange(_range) {
    const range = this._validateRange(_range);
    if (range.isEmpty) {
      return "";
    }
    if (range.isSingleLine) {
      return this._lines[range.start.line].substring(range.start.character, range.end.character);
    }
    const lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
    resultLines.push(this._lines[startLineIndex].substring(range.start.character));
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
    return resultLines.join(lineEnding);
  }
  _lineAt(lineOrPosition) {
    let line;
    if (lineOrPosition instanceof Position2) {
      line = lineOrPosition.line;
    } else if (typeof lineOrPosition === "number") {
      line = lineOrPosition;
    } else if (!this._strictInstanceofChecks && Position2.isPosition(lineOrPosition)) {
      line = lineOrPosition.line;
    }
    if (typeof line !== "number" || line < 0 || line >= this._lines.length || Math.floor(line) !== line) {
      throw new Error("Illegal value for `line`");
    }
    return new ExtHostDocumentLine(line, this._lines[line], line === this._lines.length - 1);
  }
  _offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getPrefixSum(position.line - 1) + position.character;
  }
  _positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    const out = this._lineStarts.getIndexOf(offset);
    const lineLength = this._lines[out.index].length;
    return new Position2(out.index, Math.min(out.remainder, lineLength));
  }
  // ---- range math
  _validateRange(range) {
    if (this._strictInstanceofChecks) {
      if (!(range instanceof Range2)) {
        throw new Error("Invalid argument");
      }
    } else {
      if (!Range2.isRange(range)) {
        throw new Error("Invalid argument");
      }
    }
    const start = this._validatePosition(range.start);
    const end = this._validatePosition(range.end);
    if (start === range.start && end === range.end) {
      return range;
    }
    return new Range2(start.line, start.character, end.line, end.character);
  }
  _validatePosition(position) {
    if (this._strictInstanceofChecks) {
      if (!(position instanceof Position2)) {
        throw new Error("Invalid argument");
      }
    } else {
      if (!Position2.isPosition(position)) {
        throw new Error("Invalid argument");
      }
    }
    if (this._lines.length === 0) {
      return position.with(0, 0);
    }
    let { line, character } = position;
    let hasChanged = false;
    if (line < 0) {
      line = 0;
      character = 0;
      hasChanged = true;
    } else if (line >= this._lines.length) {
      line = this._lines.length - 1;
      character = this._lines[line].length;
      hasChanged = true;
    } else {
      const maxCharacter = this._lines[line].length;
      if (character < 0) {
        character = 0;
        hasChanged = true;
      } else if (character > maxCharacter) {
        character = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    }
    return new Position2(line, character);
  }
  _getWordRangeAtPosition(_position, regexp) {
    const position = this._validatePosition(_position);
    if (!regexp) {
      regexp = getWordDefinitionFor(this._languageId);
    } else if (regExpLeadsToEndlessLoop(regexp)) {
      throw new Error(`[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`);
    }
    const wordAtText = getWordAtText(position.character + 1, ensureValidWordDefinition(regexp), this._lines[position.line], 0);
    if (wordAtText) {
      return new Range2(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
    }
    return void 0;
  }
};
var ExtHostDocumentLine = class {
  constructor(line, text, isLastLine) {
    this._line = line;
    this._text = text;
    this._isLastLine = isLastLine;
  }
  get lineNumber() {
    return this._line;
  }
  get text() {
    return this._text;
  }
  get range() {
    return new Range2(this._line, 0, this._line, this._text.length);
  }
  get rangeIncludingLineBreak() {
    if (this._isLastLine) {
      return this.range;
    }
    return new Range2(this._line, 0, this._line + 1, 0);
  }
  get firstNonWhitespaceCharacterIndex() {
    return /^(\s*)/.exec(this._text)[1].length;
  }
  get isEmptyOrWhitespace() {
    return this.firstNonWhitespaceCharacterIndex === this._text.length;
  }
};

// out-build/vs/base/common/idGenerator.js
var IdGenerator = class {
  constructor(prefix) {
    this._prefix = prefix;
    this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
};
var defaultGenerator = new IdGenerator("id#");

// out-build/vs/workbench/api/common/extHostTextEditor.js
var TextEditorDecorationType = class _TextEditorDecorationType {
  static {
    this._Keys = new IdGenerator("TextEditorDecorationType");
  }
  constructor(proxy, extension, options2) {
    const key = _TextEditorDecorationType._Keys.nextId();
    proxy.$registerTextEditorDecorationType(extension.identifier, key, DecorationRenderOptions.from(options2));
    this.value = Object.freeze({
      key,
      dispose() {
        proxy.$removeTextEditorDecorationType(key);
      }
    });
  }
};
var TextEditorEdit = class {
  constructor(document2, options2) {
    this._collectedEdits = [];
    this._setEndOfLine = void 0;
    this._finalized = false;
    this._document = document2;
    this._documentVersionId = document2.version;
    this._undoStopBefore = options2.undoStopBefore;
    this._undoStopAfter = options2.undoStopAfter;
  }
  finalize() {
    this._finalized = true;
    return {
      documentVersionId: this._documentVersionId,
      edits: this._collectedEdits,
      setEndOfLine: this._setEndOfLine,
      undoStopBefore: this._undoStopBefore,
      undoStopAfter: this._undoStopAfter
    };
  }
  _throwIfFinalized() {
    if (this._finalized) {
      throw new Error("Edit is only valid while callback runs");
    }
  }
  replace(location2, value) {
    this._throwIfFinalized();
    let range = null;
    if (location2 instanceof Position2) {
      range = new Range2(location2, location2);
    } else if (location2 instanceof Range2) {
      range = location2;
    } else {
      throw new Error("Unrecognized location");
    }
    this._pushEdit(range, value, false);
  }
  insert(location2, value) {
    this._throwIfFinalized();
    this._pushEdit(new Range2(location2, location2), value, true);
  }
  delete(location2) {
    this._throwIfFinalized();
    let range = null;
    if (location2 instanceof Range2) {
      range = location2;
    } else {
      throw new Error("Unrecognized location");
    }
    this._pushEdit(range, null, true);
  }
  _pushEdit(range, text, forceMoveMarkers) {
    const validRange2 = this._document.validateRange(range);
    this._collectedEdits.push({
      range: validRange2,
      text,
      forceMoveMarkers
    });
  }
  setEndOfLine(endOfLine) {
    this._throwIfFinalized();
    if (endOfLine !== EndOfLine.LF && endOfLine !== EndOfLine.CRLF) {
      throw illegalArgument("endOfLine");
    }
    this._setEndOfLine = endOfLine;
  }
};
var ExtHostTextEditorOptions = class {
  constructor(proxy, id2, source, logService) {
    this._proxy = proxy;
    this._id = id2;
    this._accept(source);
    this._logService = logService;
    const that = this;
    this.value = {
      get tabSize() {
        return that._tabSize;
      },
      set tabSize(value) {
        that._setTabSize(value);
      },
      get indentSize() {
        return that._indentSize;
      },
      set indentSize(value) {
        that._setIndentSize(value);
      },
      get insertSpaces() {
        return that._insertSpaces;
      },
      set insertSpaces(value) {
        that._setInsertSpaces(value);
      },
      get cursorStyle() {
        return that._cursorStyle;
      },
      set cursorStyle(value) {
        that._setCursorStyle(value);
      },
      get lineNumbers() {
        return that._lineNumbers;
      },
      set lineNumbers(value) {
        that._setLineNumbers(value);
      }
    };
  }
  _accept(source) {
    this._tabSize = source.tabSize;
    this._indentSize = source.indentSize;
    this._originalIndentSize = source.originalIndentSize;
    this._insertSpaces = source.insertSpaces;
    this._cursorStyle = source.cursorStyle;
    this._lineNumbers = TextEditorLineNumbersStyle2.to(source.lineNumbers);
  }
  // --- internal: tabSize
  _validateTabSize(value) {
    if (value === "auto") {
      return "auto";
    }
    if (typeof value === "number") {
      const r = Math.floor(value);
      return r > 0 ? r : null;
    }
    if (typeof value === "string") {
      const r = parseInt(value, 10);
      if (isNaN(r)) {
        return null;
      }
      return r > 0 ? r : null;
    }
    return null;
  }
  _setTabSize(value) {
    const tabSize = this._validateTabSize(value);
    if (tabSize === null) {
      return;
    }
    if (typeof tabSize === "number") {
      if (this._tabSize === tabSize) {
        return;
      }
      this._tabSize = tabSize;
    }
    this._warnOnError("setTabSize", this._proxy.$trySetOptions(this._id, {
      tabSize
    }));
  }
  // --- internal: indentSize
  _validateIndentSize(value) {
    if (value === "tabSize") {
      return "tabSize";
    }
    if (typeof value === "number") {
      const r = Math.floor(value);
      return r > 0 ? r : null;
    }
    if (typeof value === "string") {
      const r = parseInt(value, 10);
      if (isNaN(r)) {
        return null;
      }
      return r > 0 ? r : null;
    }
    return null;
  }
  _setIndentSize(value) {
    const indentSize = this._validateIndentSize(value);
    if (indentSize === null) {
      return;
    }
    if (typeof indentSize === "number") {
      if (this._originalIndentSize === indentSize) {
        return;
      }
      this._indentSize = indentSize;
      this._originalIndentSize = indentSize;
    }
    this._warnOnError("setIndentSize", this._proxy.$trySetOptions(this._id, {
      indentSize
    }));
  }
  // --- internal: insert spaces
  _validateInsertSpaces(value) {
    if (value === "auto") {
      return "auto";
    }
    return value === "false" ? false : Boolean(value);
  }
  _setInsertSpaces(value) {
    const insertSpaces = this._validateInsertSpaces(value);
    if (typeof insertSpaces === "boolean") {
      if (this._insertSpaces === insertSpaces) {
        return;
      }
      this._insertSpaces = insertSpaces;
    }
    this._warnOnError("setInsertSpaces", this._proxy.$trySetOptions(this._id, {
      insertSpaces
    }));
  }
  // --- internal: cursor style
  _setCursorStyle(value) {
    if (this._cursorStyle === value) {
      return;
    }
    this._cursorStyle = value;
    this._warnOnError("setCursorStyle", this._proxy.$trySetOptions(this._id, {
      cursorStyle: value
    }));
  }
  // --- internal: line number
  _setLineNumbers(value) {
    if (this._lineNumbers === value) {
      return;
    }
    this._lineNumbers = value;
    this._warnOnError("setLineNumbers", this._proxy.$trySetOptions(this._id, {
      lineNumbers: TextEditorLineNumbersStyle2.from(value)
    }));
  }
  assign(newOptions) {
    const bulkConfigurationUpdate = {};
    let hasUpdate = false;
    if (typeof newOptions.tabSize !== "undefined") {
      const tabSize = this._validateTabSize(newOptions.tabSize);
      if (tabSize === "auto") {
        hasUpdate = true;
        bulkConfigurationUpdate.tabSize = tabSize;
      } else if (typeof tabSize === "number" && this._tabSize !== tabSize) {
        this._tabSize = tabSize;
        hasUpdate = true;
        bulkConfigurationUpdate.tabSize = tabSize;
      }
    }
    if (typeof newOptions.indentSize !== "undefined") {
      const indentSize = this._validateIndentSize(newOptions.indentSize);
      if (indentSize === "tabSize") {
        hasUpdate = true;
        bulkConfigurationUpdate.indentSize = indentSize;
      } else if (typeof indentSize === "number" && this._originalIndentSize !== indentSize) {
        this._indentSize = indentSize;
        this._originalIndentSize = indentSize;
        hasUpdate = true;
        bulkConfigurationUpdate.indentSize = indentSize;
      }
    }
    if (typeof newOptions.insertSpaces !== "undefined") {
      const insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);
      if (insertSpaces === "auto") {
        hasUpdate = true;
        bulkConfigurationUpdate.insertSpaces = insertSpaces;
      } else if (this._insertSpaces !== insertSpaces) {
        this._insertSpaces = insertSpaces;
        hasUpdate = true;
        bulkConfigurationUpdate.insertSpaces = insertSpaces;
      }
    }
    if (typeof newOptions.cursorStyle !== "undefined") {
      if (this._cursorStyle !== newOptions.cursorStyle) {
        this._cursorStyle = newOptions.cursorStyle;
        hasUpdate = true;
        bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;
      }
    }
    if (typeof newOptions.lineNumbers !== "undefined") {
      if (this._lineNumbers !== newOptions.lineNumbers) {
        this._lineNumbers = newOptions.lineNumbers;
        hasUpdate = true;
        bulkConfigurationUpdate.lineNumbers = TextEditorLineNumbersStyle2.from(newOptions.lineNumbers);
      }
    }
    if (hasUpdate) {
      this._warnOnError("setOptions", this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));
    }
  }
  _warnOnError(action, promise) {
    promise.catch((err) => {
      this._logService.warn(`ExtHostTextEditorOptions '${action}' failed:'`);
      this._logService.warn(err);
    });
  }
};
var ExtHostTextEditor = class {
  constructor(id2, _proxy, _logService, document2, selections, options2, visibleRanges, viewColumn) {
    this.id = id2;
    this._proxy = _proxy;
    this._logService = _logService;
    this._disposed = false;
    this._hasDecorationsForKey = /* @__PURE__ */ new Set();
    this._selections = selections;
    this._options = new ExtHostTextEditorOptions(this._proxy, this.id, options2, _logService);
    this._visibleRanges = visibleRanges;
    this._viewColumn = viewColumn;
    const that = this;
    this.value = Object.freeze({
      get document() {
        return document2.value;
      },
      set document(_value) {
        throw new ReadonlyError("document");
      },
      // --- selection
      get selection() {
        return that._selections && that._selections[0];
      },
      set selection(value) {
        if (!(value instanceof Selection)) {
          throw illegalArgument("selection");
        }
        that._selections = [value];
        that._trySetSelection();
      },
      get selections() {
        return that._selections;
      },
      set selections(value) {
        if (!Array.isArray(value) || value.some((a) => !(a instanceof Selection))) {
          throw illegalArgument("selections");
        }
        if (value.length === 0) {
          value = [new Selection(0, 0, 0, 0)];
        }
        that._selections = value;
        that._trySetSelection();
      },
      // --- visible ranges
      get visibleRanges() {
        return that._visibleRanges;
      },
      set visibleRanges(_value) {
        throw new ReadonlyError("visibleRanges");
      },
      get diffInformation() {
        return that._diffInformation;
      },
      // --- options
      get options() {
        return that._options.value;
      },
      set options(value) {
        if (!that._disposed) {
          that._options.assign(value);
        }
      },
      // --- view column
      get viewColumn() {
        return that._viewColumn;
      },
      set viewColumn(_value) {
        throw new ReadonlyError("viewColumn");
      },
      // --- edit
      edit(callback, options3 = { undoStopBefore: true, undoStopAfter: true }) {
        if (that._disposed) {
          return Promise.reject(new Error("TextEditor#edit not possible on closed editors"));
        }
        const edit2 = new TextEditorEdit(document2.value, options3);
        callback(edit2);
        return that._applyEdit(edit2);
      },
      // --- snippet edit
      insertSnippet(snippet, where, options3 = { undoStopBefore: true, undoStopAfter: true }) {
        if (that._disposed) {
          return Promise.reject(new Error("TextEditor#insertSnippet not possible on closed editors"));
        }
        let ranges;
        if (!where || Array.isArray(where) && where.length === 0) {
          ranges = that._selections.map((range) => Range4.from(range));
        } else if (where instanceof Position2) {
          const { lineNumber, column } = Position4.from(where);
          ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
        } else if (where instanceof Range2) {
          ranges = [Range4.from(where)];
        } else {
          ranges = [];
          for (const posOrRange of where) {
            if (posOrRange instanceof Range2) {
              ranges.push(Range4.from(posOrRange));
            } else {
              const { lineNumber, column } = Position4.from(posOrRange);
              ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
            }
          }
        }
        if (options3.keepWhitespace === void 0) {
          options3.keepWhitespace = false;
        }
        return _proxy.$tryInsertSnippet(id2, document2.value.version, snippet.value, ranges, options3);
      },
      setDecorations(decorationType, ranges) {
        const willBeEmpty = ranges.length === 0;
        if (willBeEmpty && !that._hasDecorationsForKey.has(decorationType.key)) {
          return;
        }
        if (willBeEmpty) {
          that._hasDecorationsForKey.delete(decorationType.key);
        } else {
          that._hasDecorationsForKey.add(decorationType.key);
        }
        that._runOnProxy(() => {
          if (isDecorationOptionsArr(ranges)) {
            return _proxy.$trySetDecorations(id2, decorationType.key, fromRangeOrRangeWithMessage(ranges));
          } else {
            const _ranges = new Array(4 * ranges.length);
            for (let i = 0, len = ranges.length; i < len; i++) {
              const range = ranges[i];
              _ranges[4 * i] = range.start.line + 1;
              _ranges[4 * i + 1] = range.start.character + 1;
              _ranges[4 * i + 2] = range.end.line + 1;
              _ranges[4 * i + 3] = range.end.character + 1;
            }
            return _proxy.$trySetDecorationsFast(id2, decorationType.key, _ranges);
          }
        });
      },
      revealRange(range, revealType) {
        that._runOnProxy(() => _proxy.$tryRevealRange(id2, Range4.from(range), revealType || TextEditorRevealType2.Default));
      },
      show(column) {
        _proxy.$tryShowEditor(id2, ViewColumn2.from(column));
      },
      hide() {
        _proxy.$tryHideEditor(id2);
      },
      [Symbol.for("debug.description")]() {
        return `TextEditor(${this.document.uri.toString()})`;
      }
    });
  }
  dispose() {
    ok(!this._disposed);
    this._disposed = true;
  }
  // --- incoming: extension host MUST accept what the renderer says
  _acceptOptions(options2) {
    ok(!this._disposed);
    this._options._accept(options2);
  }
  _acceptVisibleRanges(value) {
    ok(!this._disposed);
    this._visibleRanges = value;
  }
  _acceptViewColumn(value) {
    ok(!this._disposed);
    this._viewColumn = value;
  }
  _acceptSelections(selections) {
    ok(!this._disposed);
    this._selections = selections;
  }
  _acceptDiffInformation(diffInformation) {
    ok(!this._disposed);
    this._diffInformation = diffInformation;
  }
  async _trySetSelection() {
    const selection = this._selections.map(Selection3.from);
    await this._runOnProxy(() => this._proxy.$trySetSelections(this.id, selection));
    return this.value;
  }
  _applyEdit(editBuilder) {
    const editData = editBuilder.finalize();
    if (editData.edits.length === 0 && !editData.setEndOfLine) {
      return Promise.resolve(true);
    }
    const editRanges = editData.edits.map((edit2) => edit2.range);
    editRanges.sort((a, b) => {
      if (a.end.line === b.end.line) {
        if (a.end.character === b.end.character) {
          if (a.start.line === b.start.line) {
            return a.start.character - b.start.character;
          }
          return a.start.line - b.start.line;
        }
        return a.end.character - b.end.character;
      }
      return a.end.line - b.end.line;
    });
    for (let i = 0, count2 = editRanges.length - 1; i < count2; i++) {
      const rangeEnd = editRanges[i].end;
      const nextRangeStart = editRanges[i + 1].start;
      if (nextRangeStart.isBefore(rangeEnd)) {
        return Promise.reject(new Error("Overlapping ranges are not allowed!"));
      }
    }
    const edits = editData.edits.map((edit2) => {
      return {
        range: Range4.from(edit2.range),
        text: edit2.text,
        forceMoveMarkers: edit2.forceMoveMarkers
      };
    });
    return this._proxy.$tryApplyEdits(this.id, editData.documentVersionId, edits, {
      setEndOfLine: typeof editData.setEndOfLine === "number" ? EndOfLine2.from(editData.setEndOfLine) : void 0,
      undoStopBefore: editData.undoStopBefore,
      undoStopAfter: editData.undoStopAfter
    });
  }
  _runOnProxy(callback) {
    if (this._disposed) {
      this._logService.warn("TextEditor is closed/disposed");
      return Promise.resolve(void 0);
    }
    return callback().then(() => this, (err) => {
      if (!(err instanceof Error && err.name === "DISPOSED")) {
        this._logService.warn(err);
      }
      return null;
    });
  }
};

// out-build/vs/workbench/api/common/extHostDocumentsAndEditors.js
var Reference = class {
  constructor(value) {
    this.value = value;
    this._count = 0;
  }
  ref() {
    this._count++;
  }
  unref() {
    return --this._count === 0;
  }
};
var ExtHostDocumentsAndEditors = class ExtHostDocumentsAndEditors2 {
  constructor(_extHostRpc, _logService) {
    this._extHostRpc = _extHostRpc;
    this._logService = _logService;
    this._activeEditorId = null;
    this._editors = /* @__PURE__ */ new Map();
    this._documents = new ResourceMap();
    this._onDidAddDocuments = new Emitter();
    this._onDidRemoveDocuments = new Emitter();
    this._onDidChangeVisibleTextEditors = new Emitter();
    this._onDidChangeActiveTextEditor = new Emitter();
    this.onDidAddDocuments = this._onDidAddDocuments.event;
    this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;
    this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
    this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
  }
  $acceptDocumentsAndEditorsDelta(delta3) {
    this.acceptDocumentsAndEditorsDelta(delta3);
  }
  acceptDocumentsAndEditorsDelta(delta3) {
    const removedDocuments = [];
    const addedDocuments = [];
    const removedEditors = [];
    if (delta3.removedDocuments) {
      for (const uriComponent of delta3.removedDocuments) {
        const uri = URI.revive(uriComponent);
        const data2 = this._documents.get(uri);
        if (data2?.unref()) {
          this._documents.delete(uri);
          removedDocuments.push(data2.value);
        }
      }
    }
    if (delta3.addedDocuments) {
      for (const data2 of delta3.addedDocuments) {
        const resource = URI.revive(data2.uri);
        let ref = this._documents.get(resource);
        if (ref) {
          if (resource.scheme !== Schemas.vscodeNotebookCell && resource.scheme !== Schemas.vscodeInteractiveInput) {
            throw new Error(`document '${resource} already exists!'`);
          }
        }
        if (!ref) {
          ref = new Reference(new ExtHostDocumentData(this._extHostRpc.getProxy(MainContext.MainThreadDocuments), resource, data2.lines, data2.EOL, data2.versionId, data2.languageId, data2.isDirty, data2.encoding));
          this._documents.set(resource, ref);
          addedDocuments.push(ref.value);
        }
        ref.ref();
      }
    }
    if (delta3.removedEditors) {
      for (const id2 of delta3.removedEditors) {
        const editor = this._editors.get(id2);
        this._editors.delete(id2);
        if (editor) {
          removedEditors.push(editor);
        }
      }
    }
    if (delta3.addedEditors) {
      for (const data2 of delta3.addedEditors) {
        const resource = URI.revive(data2.documentUri);
        ok(this._documents.has(resource), `document '${resource}' does not exist`);
        ok(!this._editors.has(data2.id), `editor '${data2.id}' already exists!`);
        const documentData = this._documents.get(resource).value;
        const editor = new ExtHostTextEditor(data2.id, this._extHostRpc.getProxy(MainContext.MainThreadTextEditors), this._logService, new Lazy(() => documentData.document), data2.selections.map(Selection3.to), data2.options, data2.visibleRanges.map((range) => Range4.to(range)), typeof data2.editorPosition === "number" ? ViewColumn2.to(data2.editorPosition) : void 0);
        this._editors.set(data2.id, editor);
      }
    }
    if (delta3.newActiveEditor !== void 0) {
      ok(delta3.newActiveEditor === null || this._editors.has(delta3.newActiveEditor), `active editor '${delta3.newActiveEditor}' does not exist`);
      this._activeEditorId = delta3.newActiveEditor;
    }
    dispose(removedDocuments);
    dispose(removedEditors);
    if (delta3.removedDocuments) {
      this._onDidRemoveDocuments.fire(removedDocuments);
    }
    if (delta3.addedDocuments) {
      this._onDidAddDocuments.fire(addedDocuments);
    }
    if (delta3.removedEditors || delta3.addedEditors) {
      this._onDidChangeVisibleTextEditors.fire(this.allEditors().map((editor) => editor.value));
    }
    if (delta3.newActiveEditor !== void 0) {
      this._onDidChangeActiveTextEditor.fire(this.activeEditor());
    }
  }
  getDocument(uri) {
    return this._documents.get(uri)?.value;
  }
  allDocuments() {
    return Iterable.map(this._documents.values(), (ref) => ref.value);
  }
  getEditor(id2) {
    return this._editors.get(id2);
  }
  activeEditor(internal) {
    if (!this._activeEditorId) {
      return void 0;
    }
    const editor = this._editors.get(this._activeEditorId);
    if (internal) {
      return editor;
    } else {
      return editor?.value;
    }
  }
  allEditors() {
    return [...this._editors.values()];
  }
};
ExtHostDocumentsAndEditors = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService)
], ExtHostDocumentsAndEditors);
var IExtHostDocumentsAndEditors = createDecorator("IExtHostDocumentsAndEditors");

// out-build/vs/platform/product/common/productService.js
var IProductService = createDecorator("productService");
var productSchemaId = "vscode://schemas/vscode-product";

// out-build/vs/platform/extensions/common/extensionsApiProposals.js
var _allApiProposals = {
  activeComment: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts"
  },
  aiRelatedInformation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts"
  },
  aiSettingsSearch: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiSettingsSearch.d.ts"
  },
  aiTextSearchProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts",
    version: 2
  },
  authIssuers: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authIssuers.d.ts"
  },
  authLearnMore: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts"
  },
  authProviderSpecific: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authProviderSpecific.d.ts"
  },
  authSession: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts"
  },
  authenticationChallenges: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authenticationChallenges.d.ts"
  },
  canonicalUriProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts"
  },
  chatContextProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatContextProvider.d.ts"
  },
  chatEditing: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatEditing.d.ts"
  },
  chatOutputRenderer: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatOutputRenderer.d.ts"
  },
  chatParticipantAdditions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts"
  },
  chatParticipantPrivate: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts",
    version: 11
  },
  chatProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts",
    version: 4
  },
  chatReferenceBinaryData: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts"
  },
  chatReferenceDiagnostic: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceDiagnostic.d.ts"
  },
  chatSessionsProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatSessionsProvider.d.ts",
    version: 3
  },
  chatStatusItem: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatStatusItem.d.ts"
  },
  chatTab: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts"
  },
  codeActionAI: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts"
  },
  codeActionRanges: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts"
  },
  codiconDecoration: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts"
  },
  commentReactor: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts"
  },
  commentReveal: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts"
  },
  commentThreadApplicability: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts"
  },
  commentingRangeHint: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts"
  },
  commentsDraftState: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts"
  },
  contribAccessibilityHelpContent: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts"
  },
  contribCommentEditorActionsMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts"
  },
  contribCommentPeekContext: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts"
  },
  contribCommentThreadAdditionalMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts"
  },
  contribCommentsViewThreadMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts"
  },
  contribDebugCreateConfiguration: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts"
  },
  contribDiffEditorGutterToolBarMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts"
  },
  contribEditSessions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts"
  },
  contribEditorContentMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts"
  },
  contribLabelFormatterWorkspaceTooltip: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts"
  },
  contribLanguageModelToolSets: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLanguageModelToolSets.d.ts"
  },
  contribMenuBarHome: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts"
  },
  contribMergeEditorMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts"
  },
  contribMultiDiffEditorMenus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts"
  },
  contribNotebookStaticPreloads: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts"
  },
  contribRemoteHelp: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts"
  },
  contribShareMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts"
  },
  contribSourceControlArtifactGroupMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlArtifactGroupMenu.d.ts"
  },
  contribSourceControlArtifactMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlArtifactMenu.d.ts"
  },
  contribSourceControlHistoryItemMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts"
  },
  contribSourceControlHistoryTitleMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts"
  },
  contribSourceControlInputBoxMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts"
  },
  contribSourceControlTitleMenu: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts"
  },
  contribStatusBarItems: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts"
  },
  contribViewContainerTitle: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts"
  },
  contribViewsRemote: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts"
  },
  contribViewsWelcome: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts"
  },
  customEditorMove: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts"
  },
  dataChannels: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.dataChannels.d.ts"
  },
  debugVisualization: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts"
  },
  defaultChatParticipant: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts",
    version: 4
  },
  devDeviceId: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.devDeviceId.d.ts"
  },
  diffCommand: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts"
  },
  diffContentOptions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts"
  },
  documentFiltersExclusive: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts"
  },
  editSessionIdentityProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts"
  },
  editorHoverVerbosityLevel: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts"
  },
  editorInsets: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts"
  },
  embeddings: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts"
  },
  extensionRuntime: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts"
  },
  extensionsAny: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts"
  },
  externalUriOpener: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts"
  },
  fileSearchProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts"
  },
  fileSearchProvider2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider2.d.ts"
  },
  findFiles2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts",
    version: 2
  },
  findTextInFiles: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts"
  },
  findTextInFiles2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles2.d.ts"
  },
  fsChunks: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts"
  },
  inlineCompletionsAdditions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts"
  },
  interactive: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts"
  },
  interactiveWindow: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts"
  },
  ipc: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts"
  },
  languageModelCapabilities: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelCapabilities.d.ts"
  },
  languageModelProxy: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelProxy.d.ts"
  },
  languageModelSystem: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts"
  },
  languageModelThinkingPart: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelThinkingPart.d.ts",
    version: 1
  },
  languageModelToolResultAudience: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelToolResultAudience.d.ts"
  },
  languageStatusText: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts"
  },
  mappedEditsProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts"
  },
  markdownAlertSyntax: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.markdownAlertSyntax.d.ts"
  },
  mcpToolDefinitions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mcpToolDefinitions.d.ts"
  },
  multiDocumentHighlightProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts"
  },
  nativeWindowHandle: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.nativeWindowHandle.d.ts"
  },
  newSymbolNamesProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts"
  },
  notebookCellExecution: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts"
  },
  notebookControllerAffinityHidden: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts"
  },
  notebookDeprecated: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts"
  },
  notebookExecution: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts"
  },
  notebookKernelSource: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts"
  },
  notebookLiveShare: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts"
  },
  notebookMessaging: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts"
  },
  notebookMime: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts"
  },
  notebookReplDocument: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts"
  },
  notebookVariableProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts"
  },
  portsAttributes: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts"
  },
  profileContentHandlers: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts"
  },
  quickDiffProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts"
  },
  quickInputButtonLocation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts"
  },
  quickPickItemResource: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemResource.d.ts"
  },
  quickPickItemTooltip: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts"
  },
  quickPickPrompt: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickPrompt.d.ts"
  },
  quickPickSortByLabel: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts"
  },
  remoteCodingAgents: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.remoteCodingAgents.d.ts"
  },
  resolvers: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts"
  },
  scmActionButton: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts"
  },
  scmArtifactProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmArtifactProvider.d.ts"
  },
  scmHistoryProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts"
  },
  scmMultiDiffEditor: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts"
  },
  scmProviderOptions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmProviderOptions.d.ts"
  },
  scmSelectedProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts"
  },
  scmTextDocument: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts"
  },
  scmValidation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts"
  },
  shareProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts"
  },
  speech: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts"
  },
  statusBarItemTooltip: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.statusBarItemTooltip.d.ts"
  },
  tabInputMultiDiff: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts"
  },
  tabInputTextMerge: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts"
  },
  taskExecutionTerminal: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskExecutionTerminal.d.ts"
  },
  taskPresentationGroup: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts"
  },
  taskProblemMatcherStatus: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskProblemMatcherStatus.d.ts"
  },
  telemetry: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts"
  },
  terminalCompletionProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalCompletionProvider.d.ts"
  },
  terminalDataWriteEvent: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts"
  },
  terminalDimensions: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts"
  },
  terminalExecuteCommandEvent: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts"
  },
  terminalQuickFixProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts"
  },
  terminalSelection: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts"
  },
  terminalShellEnv: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalShellEnv.d.ts"
  },
  testObserver: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts"
  },
  testRelatedCode: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts"
  },
  textDocumentChangeReason: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textDocumentChangeReason.d.ts"
  },
  textEditorDiffInformation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textEditorDiffInformation.d.ts"
  },
  textSearchComplete2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchComplete2.d.ts"
  },
  textSearchProvider: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts"
  },
  textSearchProvider2: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider2.d.ts"
  },
  timeline: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts"
  },
  tokenInformation: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts"
  },
  toolProgress: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.toolProgress.d.ts"
  },
  treeItemMarkdownLabel: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeItemMarkdownLabel.d.ts"
  },
  treeViewActiveItem: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts"
  },
  treeViewMarkdownMessage: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts"
  },
  treeViewReveal: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts"
  },
  tunnelFactory: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts"
  },
  tunnels: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts"
  },
  valueSelectionInQuickPick: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.valueSelectionInQuickPick.d.ts"
  },
  workspaceTrust: {
    proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts"
  }
};
var allApiProposals = Object.freeze(_allApiProposals);

// out-build/vs/workbench/services/extensions/common/extensionsRegistry.js
var schemaRegistry = Registry.as(Extensions.JSONContribution);
var ExtensionPointUserDelta = class _ExtensionPointUserDelta {
  static _toSet(arr) {
    const result = new ExtensionIdentifierSet();
    for (let i = 0, len = arr.length; i < len; i++) {
      result.add(arr[i].description.identifier);
    }
    return result;
  }
  static compute(previous, current) {
    if (!previous || !previous.length) {
      return new _ExtensionPointUserDelta(current, []);
    }
    if (!current || !current.length) {
      return new _ExtensionPointUserDelta([], previous);
    }
    const previousSet = this._toSet(previous);
    const currentSet = this._toSet(current);
    const added = current.filter((user) => !previousSet.has(user.description.identifier));
    const removed = previous.filter((user) => !currentSet.has(user.description.identifier));
    return new _ExtensionPointUserDelta(added, removed);
  }
  constructor(added, removed) {
    this.added = added;
    this.removed = removed;
  }
};
var ExtensionPoint = class {
  constructor(name2, defaultExtensionKind, canHandleResolver) {
    this.name = name2;
    this.defaultExtensionKind = defaultExtensionKind;
    this.canHandleResolver = canHandleResolver;
    this._handler = null;
    this._users = null;
    this._delta = null;
  }
  setHandler(handler) {
    if (this._handler !== null) {
      throw new Error("Handler already set!");
    }
    this._handler = handler;
    this._handle();
    return {
      dispose: () => {
        this._handler = null;
      }
    };
  }
  acceptUsers(users) {
    this._delta = ExtensionPointUserDelta.compute(this._users, users);
    this._users = users;
    this._handle();
  }
  _handle() {
    if (this._handler === null || this._users === null || this._delta === null) {
      return;
    }
    try {
      this._handler(this._users, this._delta);
    } catch (err) {
      onUnexpectedError(err);
    }
  }
};
var extensionKindSchema = {
  type: "string",
  enum: [
    "ui",
    "workspace"
  ],
  enumDescriptions: [
    localize(15385, null),
    localize(15386, null)
  ]
};
var schemaId = "vscode://schemas/vscode-extensions";
var schema = {
  properties: {
    engines: {
      type: "object",
      description: localize(15387, null),
      properties: {
        "vscode": {
          type: "string",
          description: localize(15388, null),
          default: "^1.22.0"
        }
      }
    },
    publisher: {
      description: localize(15389, null),
      type: "string"
    },
    displayName: {
      description: localize(15390, null),
      type: "string"
    },
    categories: {
      description: localize(15391, null),
      type: "array",
      uniqueItems: true,
      items: {
        oneOf: [
          {
            type: "string",
            enum: EXTENSION_CATEGORIES
          },
          {
            type: "string",
            const: "Languages",
            deprecationMessage: localize(15392, null)
          }
        ]
      }
    },
    galleryBanner: {
      type: "object",
      description: localize(15393, null),
      properties: {
        color: {
          description: localize(15394, null),
          type: "string"
        },
        theme: {
          description: localize(15395, null),
          type: "string",
          enum: ["dark", "light"]
        }
      }
    },
    contributes: {
      description: localize(15396, null),
      type: "object",
      // eslint-disable-next-line local/code-no-any-casts
      properties: {
        // extensions will fill in
      },
      default: {}
    },
    preview: {
      type: "boolean",
      description: localize(15397, null)
    },
    enableProposedApi: {
      type: "boolean",
      deprecationMessage: localize(15398, null)
    },
    enabledApiProposals: {
      markdownDescription: localize(15399, null),
      type: "array",
      uniqueItems: true,
      items: {
        type: "string",
        enum: Object.keys(allApiProposals).map((proposalName) => proposalName),
        markdownEnumDescriptions: Object.values(allApiProposals).map((value) => value.proposal)
      }
    },
    api: {
      markdownDescription: localize(15400, null),
      type: "string",
      enum: ["none"],
      enumDescriptions: [
        localize(15401, null)
      ]
    },
    activationEvents: {
      description: localize(15402, null),
      type: "array",
      items: {
        type: "string",
        defaultSnippets: [
          {
            label: "onWebviewPanel",
            description: localize(15403, null),
            body: "onWebviewPanel:viewType"
          },
          {
            label: "onLanguage",
            description: localize(15404, null),
            body: "onLanguage:${1:languageId}"
          },
          {
            label: "onCommand",
            description: localize(15405, null),
            body: "onCommand:${2:commandId}"
          },
          {
            label: "onDebug",
            description: localize(15406, null),
            body: "onDebug"
          },
          {
            label: "onDebugInitialConfigurations",
            description: localize(15407, null),
            body: "onDebugInitialConfigurations"
          },
          {
            label: "onDebugDynamicConfigurations",
            description: localize(15408, null),
            body: "onDebugDynamicConfigurations"
          },
          {
            label: "onDebugResolve",
            description: localize(15409, null),
            body: "onDebugResolve:${6:type}"
          },
          {
            label: "onDebugAdapterProtocolTracker",
            description: localize(15410, null),
            body: "onDebugAdapterProtocolTracker:${6:type}"
          },
          {
            label: "workspaceContains",
            description: localize(15411, null),
            body: "workspaceContains:${4:filePattern}"
          },
          {
            label: "onStartupFinished",
            description: localize(15412, null),
            body: "onStartupFinished"
          },
          {
            label: "onTaskType",
            description: localize(15413, null),
            body: "onTaskType:${1:taskType}"
          },
          {
            label: "onFileSystem",
            description: localize(15414, null),
            body: "onFileSystem:${1:scheme}"
          },
          {
            label: "onEditSession",
            description: localize(15415, null),
            body: "onEditSession:${1:scheme}"
          },
          {
            label: "onSearch",
            description: localize(15416, null),
            body: "onSearch:${7:scheme}"
          },
          {
            label: "onView",
            body: "onView:${5:viewId}",
            description: localize(15417, null)
          },
          {
            label: "onUri",
            body: "onUri",
            description: localize(15418, null)
          },
          {
            label: "onOpenExternalUri",
            body: "onOpenExternalUri",
            description: localize(15419, null)
          },
          {
            label: "onCustomEditor",
            body: "onCustomEditor:${9:viewType}",
            description: localize(15420, null)
          },
          {
            label: "onNotebook",
            body: "onNotebook:${1:type}",
            description: localize(15421, null)
          },
          {
            label: "onAuthenticationRequest",
            body: "onAuthenticationRequest:${11:authenticationProviderId}",
            description: localize(15422, null)
          },
          {
            label: "onRenderer",
            description: localize(15423, null),
            body: "onRenderer:${11:rendererId}"
          },
          {
            label: "onTerminalProfile",
            body: "onTerminalProfile:${1:terminalId}",
            description: localize(15424, null)
          },
          {
            label: "onTerminalQuickFixRequest",
            body: "onTerminalQuickFixRequest:${1:quickFixId}",
            description: localize(15425, null)
          },
          {
            label: "onWalkthrough",
            body: "onWalkthrough:${1:walkthroughID}",
            description: localize(15426, null)
          },
          {
            label: "onIssueReporterOpened",
            body: "onIssueReporterOpened",
            description: localize(15427, null)
          },
          {
            label: "onChatParticipant",
            body: "onChatParticipant:${1:participantId}",
            description: localize(15428, null)
          },
          {
            label: "onLanguageModelChatProvider",
            body: "onLanguageModelChatProvider:${1:vendor}",
            description: localize(15429, null)
          },
          {
            label: "onLanguageModelTool",
            body: "onLanguageModelTool:${1:toolId}",
            description: localize(15430, null)
          },
          {
            label: "onTerminal",
            body: "onTerminal:{1:shellType}",
            description: localize(15431, null)
          },
          {
            label: "onTerminalShellIntegration",
            body: "onTerminalShellIntegration:${1:shellType}",
            description: localize(15432, null)
          },
          {
            label: "onMcpCollection",
            description: localize(15433, null),
            body: "onMcpCollection:${2:collectionId}"
          },
          {
            label: "*",
            description: localize(15434, null),
            body: "*"
          }
        ]
      }
    },
    badges: {
      type: "array",
      description: localize(15435, null),
      items: {
        type: "object",
        required: ["url", "href", "description"],
        properties: {
          url: {
            type: "string",
            description: localize(15436, null)
          },
          href: {
            type: "string",
            description: localize(15437, null)
          },
          description: {
            type: "string",
            description: localize(15438, null)
          }
        }
      }
    },
    markdown: {
      type: "string",
      description: localize(15439, null),
      enum: ["github", "standard"],
      default: "github"
    },
    qna: {
      default: "marketplace",
      description: localize(15440, null),
      anyOf: [
        {
          type: ["string", "boolean"],
          enum: ["marketplace", false]
        },
        {
          type: "string"
        }
      ]
    },
    extensionDependencies: {
      description: localize(15441, null),
      type: "array",
      uniqueItems: true,
      items: {
        type: "string",
        pattern: EXTENSION_IDENTIFIER_PATTERN
      }
    },
    extensionPack: {
      description: localize(15442, null),
      type: "array",
      uniqueItems: true,
      items: {
        type: "string",
        pattern: EXTENSION_IDENTIFIER_PATTERN
      }
    },
    extensionKind: {
      description: localize(15443, null),
      type: "array",
      items: extensionKindSchema,
      default: ["workspace"],
      defaultSnippets: [
        {
          body: ["ui"],
          description: localize(15444, null)
        },
        {
          body: ["workspace"],
          description: localize(15445, null)
        },
        {
          body: ["ui", "workspace"],
          description: localize(15446, null)
        },
        {
          body: ["workspace", "ui"],
          description: localize(15447, null)
        },
        {
          body: [],
          description: localize(15448, null)
        }
      ]
    },
    capabilities: {
      description: localize(15449, null),
      type: "object",
      properties: {
        virtualWorkspaces: {
          description: localize(15450, null),
          type: ["boolean", "object"],
          defaultSnippets: [
            { label: "limited", body: { supported: "${1:limited}", description: "${2}" } },
            { label: "false", body: { supported: false, description: "${2}" } }
          ],
          default: true.valueOf,
          properties: {
            supported: {
              markdownDescription: localize(15451, null),
              type: ["string", "boolean"],
              enum: ["limited", true, false],
              enumDescriptions: [
                localize(15452, null),
                localize(15453, null),
                localize(15454, null)
              ]
            },
            description: {
              type: "string",
              markdownDescription: localize(15455, null)
            }
          }
        },
        untrustedWorkspaces: {
          description: localize(15456, null),
          type: "object",
          required: ["supported"],
          defaultSnippets: [
            { body: { supported: "${1:limited}", description: "${2}" } }
          ],
          properties: {
            supported: {
              markdownDescription: localize(15457, null),
              type: ["string", "boolean"],
              enum: ["limited", true, false],
              enumDescriptions: [
                localize(15458, null),
                localize(15459, null),
                localize(15460, null)
              ]
            },
            restrictedConfigurations: {
              description: localize(15461, null),
              type: "array",
              items: {
                type: "string"
              }
            },
            description: {
              type: "string",
              markdownDescription: localize(15462, null)
            }
          }
        }
      }
    },
    sponsor: {
      description: localize(15463, null),
      type: "object",
      defaultSnippets: [
        { body: { url: "${1:https:}" } }
      ],
      properties: {
        "url": {
          description: localize(15464, null),
          type: "string"
        }
      }
    },
    scripts: {
      type: "object",
      properties: {
        "vscode:prepublish": {
          description: localize(15465, null),
          type: "string"
        },
        "vscode:uninstall": {
          description: localize(15466, null),
          type: "string"
        }
      }
    },
    icon: {
      type: "string",
      description: localize(15467, null)
    },
    l10n: {
      type: "string",
      description: localize(15468, null)
    },
    pricing: {
      type: "string",
      markdownDescription: localize(15469, null),
      enum: ["Free", "Trial"],
      default: "Free"
    }
  }
};
var ExtensionsRegistryImpl = class {
  constructor() {
    this._extensionPoints = /* @__PURE__ */ new Map();
  }
  registerExtensionPoint(desc) {
    if (this._extensionPoints.has(desc.extensionPoint)) {
      throw new Error("Duplicate extension point: " + desc.extensionPoint);
    }
    const result = new ExtensionPoint(desc.extensionPoint, desc.defaultExtensionKind, desc.canHandleResolver);
    this._extensionPoints.set(desc.extensionPoint, result);
    if (desc.activationEventsGenerator) {
      ImplicitActivationEvents.register(desc.extensionPoint, desc.activationEventsGenerator);
    }
    schema.properties["contributes"].properties[desc.extensionPoint] = desc.jsonSchema;
    schemaRegistry.registerSchema(schemaId, schema);
    return result;
  }
  getExtensionPoints() {
    return Array.from(this._extensionPoints.values());
  }
};
var PRExtensions = {
  ExtensionsRegistry: "ExtensionsRegistry"
};
Registry.add(PRExtensions.ExtensionsRegistry, new ExtensionsRegistryImpl());
var ExtensionsRegistry = Registry.as(PRExtensions.ExtensionsRegistry);
schemaRegistry.registerSchema(schemaId, schema);
schemaRegistry.registerSchema(productSchemaId, {
  properties: {
    extensionEnabledApiProposals: {
      description: localize(15470, null),
      type: "object",
      properties: {},
      additionalProperties: {
        anyOf: [{
          type: "array",
          uniqueItems: true,
          items: {
            type: "string",
            enum: Object.keys(allApiProposals),
            markdownEnumDescriptions: Object.values(allApiProposals).map((value) => value.proposal)
          }
        }]
      }
    }
  }
});

// out-build/vs/workbench/contrib/tasks/common/taskDefinitionRegistry.js
var taskDefinitionSchema = {
  type: "object",
  additionalProperties: false,
  properties: {
    type: {
      type: "string",
      description: localize(12528, null)
    },
    required: {
      type: "array",
      items: {
        type: "string"
      }
    },
    properties: {
      type: "object",
      description: localize(12529, null),
      additionalProperties: {
        $ref: "http://json-schema.org/draft-07/schema#"
      }
    },
    when: {
      type: "string",
      markdownDescription: localize(12530, null),
      default: ""
    }
  }
};
var Configuration2;
(function(Configuration3) {
  function from(value, extensionId, messageCollector) {
    if (!value) {
      return void 0;
    }
    const taskType = isString(value.type) ? value.type : void 0;
    if (!taskType || taskType.length === 0) {
      messageCollector.error(localize(12531, null));
      return void 0;
    }
    const required = [];
    if (Array.isArray(value.required)) {
      for (const element of value.required) {
        if (isString(element)) {
          required.push(element);
        }
      }
    }
    return {
      extensionId: extensionId.value,
      taskType,
      required,
      properties: value.properties ? deepClone(value.properties) : {},
      when: value.when ? ContextKeyExpr.deserialize(value.when) : void 0
    };
  }
  Configuration3.from = from;
})(Configuration2 || (Configuration2 = {}));
var taskDefinitionsExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "taskDefinitions",
  activationEventsGenerator: function* (contributions) {
    for (const task of contributions) {
      if (task.type) {
        yield `onTaskType:${task.type}`;
      }
    }
  },
  jsonSchema: {
    description: localize(12532, null),
    type: "array",
    items: taskDefinitionSchema
  }
});
var TaskDefinitionRegistryImpl = class {
  constructor() {
    this._onDefinitionsChanged = new Emitter();
    this.onDefinitionsChanged = this._onDefinitionsChanged.event;
    this.taskTypes = /* @__PURE__ */ Object.create(null);
    this.readyPromise = new Promise((resolve2, reject) => {
      taskDefinitionsExtPoint.setHandler((extensions, delta3) => {
        this._schema = void 0;
        try {
          for (const extension of delta3.removed) {
            const taskTypes = extension.value;
            for (const taskType of taskTypes) {
              if (this.taskTypes && taskType.type && this.taskTypes[taskType.type]) {
                delete this.taskTypes[taskType.type];
              }
            }
          }
          for (const extension of delta3.added) {
            const taskTypes = extension.value;
            for (const taskType of taskTypes) {
              const type = Configuration2.from(taskType, extension.description.identifier, extension.collector);
              if (type) {
                this.taskTypes[type.taskType] = type;
              }
            }
          }
          if (delta3.removed.length > 0 || delta3.added.length > 0) {
            this._onDefinitionsChanged.fire();
          }
        } catch (error) {
        }
        resolve2(void 0);
      });
    });
  }
  onReady() {
    return this.readyPromise;
  }
  get(key) {
    return this.taskTypes[key];
  }
  all() {
    return Object.keys(this.taskTypes).map((key) => this.taskTypes[key]);
  }
  getJsonSchema() {
    if (this._schema === void 0) {
      const schemas = [];
      for (const definition of this.all()) {
        const schema2 = {
          type: "object",
          additionalProperties: false
        };
        if (definition.required.length > 0) {
          schema2.required = definition.required.slice(0);
        }
        if (definition.properties !== void 0) {
          schema2.properties = deepClone(definition.properties);
        } else {
          schema2.properties = /* @__PURE__ */ Object.create(null);
        }
        schema2.properties.type = {
          type: "string",
          enum: [definition.taskType]
        };
        schemas.push(schema2);
      }
      this._schema = { oneOf: schemas };
    }
    return this._schema;
  }
};
var TaskDefinitionRegistry = new TaskDefinitionRegistryImpl();

// out-build/vs/platform/theme/common/iconRegistry.js
var Extensions4 = {
  IconContribution: "base.contributions.icons"
};
var IconContribution;
(function(IconContribution2) {
  function getDefinition(contribution, registry) {
    let definition = contribution.defaults;
    while (ThemeIcon.isThemeIcon(definition)) {
      const c = iconRegistry.getIcon(definition.id);
      if (!c) {
        return void 0;
      }
      definition = c.defaults;
    }
    return definition;
  }
  IconContribution2.getDefinition = getDefinition;
})(IconContribution || (IconContribution = {}));
var IconFontDefinition;
(function(IconFontDefinition2) {
  function toJSONObject(iconFont) {
    return {
      weight: iconFont.weight,
      style: iconFont.style,
      src: iconFont.src.map((s) => ({ format: s.format, location: s.location.toString() }))
    };
  }
  IconFontDefinition2.toJSONObject = toJSONObject;
  function fromJSONObject(json) {
    const stringOrUndef = (s) => isString(s) ? s : void 0;
    if (json && Array.isArray(json.src) && json.src.every((s) => isString(s.format) && isString(s.location))) {
      return {
        weight: stringOrUndef(json.weight),
        style: stringOrUndef(json.style),
        src: json.src.map((s) => ({ format: s.format, location: URI.parse(s.location) }))
      };
    }
    return void 0;
  }
  IconFontDefinition2.fromJSONObject = fromJSONObject;
})(IconFontDefinition || (IconFontDefinition = {}));
var fontIdRegex = /^([\w_-]+)$/;
var fontIdErrorMessage = localize(2621, null);
var IconRegistry = class extends Disposable {
  constructor() {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: localize(2622, null), pattern: fontIdRegex.source, patternErrorMessage: fontIdErrorMessage },
            fontCharacter: { type: "string", description: localize(2623, null) }
          },
          additionalProperties: false,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    };
    this.iconReferenceSchema = { type: "string", pattern: `^${ThemeIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };
    this.iconsById = {};
    this.iconFontsById = {};
  }
  registerIcon(id2, defaults, description, deprecationMessage) {
    const existing = this.iconsById[id2];
    if (existing) {
      if (description && !existing.description) {
        existing.description = description;
        this.iconSchema.properties[id2].markdownDescription = `${description} $(${id2})`;
        const enumIndex = this.iconReferenceSchema.enum.indexOf(id2);
        if (enumIndex !== -1) {
          this.iconReferenceSchema.enumDescriptions[enumIndex] = description;
        }
        this._onDidChange.fire();
      }
      return existing;
    }
    const iconContribution = { id: id2, description, defaults, deprecationMessage };
    this.iconsById[id2] = iconContribution;
    const propertySchema = { $ref: "#/definitions/icons" };
    if (deprecationMessage) {
      propertySchema.deprecationMessage = deprecationMessage;
    }
    if (description) {
      propertySchema.markdownDescription = `${description}: $(${id2})`;
    }
    this.iconSchema.properties[id2] = propertySchema;
    this.iconReferenceSchema.enum.push(id2);
    this.iconReferenceSchema.enumDescriptions.push(description || "");
    this._onDidChange.fire();
    return { id: id2 };
  }
  deregisterIcon(id2) {
    delete this.iconsById[id2];
    delete this.iconSchema.properties[id2];
    const index = this.iconReferenceSchema.enum.indexOf(id2);
    if (index !== -1) {
      this.iconReferenceSchema.enum.splice(index, 1);
      this.iconReferenceSchema.enumDescriptions.splice(index, 1);
    }
    this._onDidChange.fire();
  }
  getIcons() {
    return Object.keys(this.iconsById).map((id2) => this.iconsById[id2]);
  }
  getIcon(id2) {
    return this.iconsById[id2];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  getIconReferenceSchema() {
    return this.iconReferenceSchema;
  }
  registerIconFont(id2, definition) {
    const existing = this.iconFontsById[id2];
    if (existing) {
      return existing;
    }
    this.iconFontsById[id2] = definition;
    this._onDidChange.fire();
    return definition;
  }
  deregisterIconFont(id2) {
    delete this.iconFontsById[id2];
  }
  getIconFont(id2) {
    return this.iconFontsById[id2];
  }
  toString() {
    const sorter2 = (i1, i2) => {
      return i1.id.localeCompare(i2.id);
    };
    const classNames = (i) => {
      while (ThemeIcon.isThemeIcon(i.defaults)) {
        i = this.iconsById[i.defaults.id];
      }
      return `codicon codicon-${i ? i.id : ""}`;
    };
    const reference = [];
    reference.push(`| preview     | identifier                        | default codicon ID                | description`);
    reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);
    const contributions = Object.keys(this.iconsById).map((key) => this.iconsById[key]);
    for (const i of contributions.filter((i2) => !!i2.description).sort(sorter2)) {
      reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ""}|`);
    }
    reference.push(`| preview     | identifier                        `);
    reference.push(`| ----------- | --------------------------------- |`);
    for (const i of contributions.filter((i2) => !ThemeIcon.isThemeIcon(i2.defaults)).sort(sorter2)) {
      reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|`);
    }
    return reference.join("\n");
  }
};
var iconRegistry = new IconRegistry();
Registry.add(Extensions4.IconContribution, iconRegistry);
function registerIcon(id2, defaults, description, deprecationMessage) {
  return iconRegistry.registerIcon(id2, defaults, description, deprecationMessage);
}
function initialize() {
  const codiconFontCharacters = getCodiconFontCharacters();
  for (const icon in codiconFontCharacters) {
    const fontCharacter = "\\" + codiconFontCharacters[icon].toString(16);
    iconRegistry.registerIcon(icon, { fontCharacter });
  }
}
initialize();
var iconsSchemaId = "vscode://schemas/icons";
var schemaRegistry2 = Registry.as(Extensions.JSONContribution);
schemaRegistry2.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());
var delayer = new RunOnceScheduler(() => schemaRegistry2.notifySchemaChanged(iconsSchemaId), 200);
iconRegistry.onDidChange(() => {
  if (!delayer.isScheduled()) {
    delayer.schedule();
  }
});
var widgetClose = registerIcon("widget-close", Codicon.close, localize(2624, null));
var gotoPreviousLocation = registerIcon("goto-previous-location", Codicon.arrowUp, localize(2625, null));
var gotoNextLocation = registerIcon("goto-next-location", Codicon.arrowDown, localize(2626, null));
var syncing = ThemeIcon.modify(Codicon.sync, "spin");
var spinningLoading = ThemeIcon.modify(Codicon.loading, "spin");

// out-build/vs/workbench/contrib/tasks/common/tasks.js
var USER_TASKS_GROUP_KEY = "settings";
var TASK_RUNNING_STATE = new RawContextKey("taskRunning", false, localize(12533, null));
var TASK_TERMINAL_ACTIVE = new RawContextKey("taskTerminalActive", false, localize(12534, null));
var TASKS_CATEGORY = localize2(12537, "Tasks");
var ShellQuoting2;
(function(ShellQuoting3) {
  ShellQuoting3[ShellQuoting3["Escape"] = 1] = "Escape";
  ShellQuoting3[ShellQuoting3["Strong"] = 2] = "Strong";
  ShellQuoting3[ShellQuoting3["Weak"] = 3] = "Weak";
})(ShellQuoting2 || (ShellQuoting2 = {}));
(function(ShellQuoting3) {
  function from(value) {
    if (!value) {
      return ShellQuoting3.Strong;
    }
    switch (value.toLowerCase()) {
      case "escape":
        return ShellQuoting3.Escape;
      case "strong":
        return ShellQuoting3.Strong;
      case "weak":
        return ShellQuoting3.Weak;
      default:
        return ShellQuoting3.Strong;
    }
  }
  ShellQuoting3.from = from;
})(ShellQuoting2 || (ShellQuoting2 = {}));
var CommandOptions;
(function(CommandOptions2) {
  CommandOptions2.defaults = { cwd: "${workspaceFolder}" };
})(CommandOptions || (CommandOptions = {}));
var RevealKind;
(function(RevealKind2) {
  RevealKind2[RevealKind2["Always"] = 1] = "Always";
  RevealKind2[RevealKind2["Silent"] = 2] = "Silent";
  RevealKind2[RevealKind2["Never"] = 3] = "Never";
})(RevealKind || (RevealKind = {}));
(function(RevealKind2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "always":
        return RevealKind2.Always;
      case "silent":
        return RevealKind2.Silent;
      case "never":
        return RevealKind2.Never;
      default:
        return RevealKind2.Always;
    }
  }
  RevealKind2.fromString = fromString;
})(RevealKind || (RevealKind = {}));
var RevealProblemKind;
(function(RevealProblemKind2) {
  RevealProblemKind2[RevealProblemKind2["Never"] = 1] = "Never";
  RevealProblemKind2[RevealProblemKind2["OnProblem"] = 2] = "OnProblem";
  RevealProblemKind2[RevealProblemKind2["Always"] = 3] = "Always";
})(RevealProblemKind || (RevealProblemKind = {}));
(function(RevealProblemKind2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "always":
        return RevealProblemKind2.Always;
      case "never":
        return RevealProblemKind2.Never;
      case "onproblem":
        return RevealProblemKind2.OnProblem;
      default:
        return RevealProblemKind2.OnProblem;
    }
  }
  RevealProblemKind2.fromString = fromString;
})(RevealProblemKind || (RevealProblemKind = {}));
var PanelKind;
(function(PanelKind2) {
  PanelKind2[PanelKind2["Shared"] = 1] = "Shared";
  PanelKind2[PanelKind2["Dedicated"] = 2] = "Dedicated";
  PanelKind2[PanelKind2["New"] = 3] = "New";
})(PanelKind || (PanelKind = {}));
(function(PanelKind2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "shared":
        return PanelKind2.Shared;
      case "dedicated":
        return PanelKind2.Dedicated;
      case "new":
        return PanelKind2.New;
      default:
        return PanelKind2.Shared;
    }
  }
  PanelKind2.fromString = fromString;
})(PanelKind || (PanelKind = {}));
var PresentationOptions;
(function(PresentationOptions2) {
  PresentationOptions2.defaults = {
    echo: true,
    reveal: RevealKind.Always,
    revealProblems: RevealProblemKind.Never,
    focus: false,
    panel: PanelKind.Shared,
    showReuseMessage: true,
    clear: false,
    preserveTerminalName: false
  };
})(PresentationOptions || (PresentationOptions = {}));
var RuntimeType;
(function(RuntimeType2) {
  RuntimeType2[RuntimeType2["Shell"] = 1] = "Shell";
  RuntimeType2[RuntimeType2["Process"] = 2] = "Process";
  RuntimeType2[RuntimeType2["CustomExecution"] = 3] = "CustomExecution";
})(RuntimeType || (RuntimeType = {}));
(function(RuntimeType2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "shell":
        return RuntimeType2.Shell;
      case "process":
        return RuntimeType2.Process;
      case "customExecution":
        return RuntimeType2.CustomExecution;
      default:
        return RuntimeType2.Process;
    }
  }
  RuntimeType2.fromString = fromString;
  function toString(value) {
    switch (value) {
      case RuntimeType2.Shell:
        return "shell";
      case RuntimeType2.Process:
        return "process";
      case RuntimeType2.CustomExecution:
        return "customExecution";
      default:
        return "process";
    }
  }
  RuntimeType2.toString = toString;
})(RuntimeType || (RuntimeType = {}));
var CommandString;
(function(CommandString2) {
  function value(value2) {
    if (isString(value2)) {
      return value2;
    } else {
      return value2.value;
    }
  }
  CommandString2.value = value;
})(CommandString || (CommandString = {}));
var TaskGroup3;
(function(TaskGroup4) {
  TaskGroup4.Clean = { _id: "clean", isDefault: false };
  TaskGroup4.Build = { _id: "build", isDefault: false };
  TaskGroup4.Rebuild = { _id: "rebuild", isDefault: false };
  TaskGroup4.Test = { _id: "test", isDefault: false };
  function is(value) {
    return value === TaskGroup4.Clean._id || value === TaskGroup4.Build._id || value === TaskGroup4.Rebuild._id || value === TaskGroup4.Test._id;
  }
  TaskGroup4.is = is;
  function from(value) {
    if (value === void 0) {
      return void 0;
    } else if (isString(value)) {
      if (is(value)) {
        return { _id: value, isDefault: false };
      }
      return void 0;
    } else {
      return value;
    }
  }
  TaskGroup4.from = from;
})(TaskGroup3 || (TaskGroup3 = {}));
var TaskScope2;
(function(TaskScope3) {
  TaskScope3[TaskScope3["Global"] = 1] = "Global";
  TaskScope3[TaskScope3["Workspace"] = 2] = "Workspace";
  TaskScope3[TaskScope3["Folder"] = 3] = "Folder";
})(TaskScope2 || (TaskScope2 = {}));
var TaskSourceKind;
(function(TaskSourceKind2) {
  TaskSourceKind2.Workspace = "workspace";
  TaskSourceKind2.Extension = "extension";
  TaskSourceKind2.InMemory = "inMemory";
  TaskSourceKind2.WorkspaceFile = "workspaceFile";
  TaskSourceKind2.User = "user";
  function toConfigurationTarget(kind) {
    switch (kind) {
      case TaskSourceKind2.User:
        return 2;
      case TaskSourceKind2.WorkspaceFile:
        return 5;
      default:
        return 6;
    }
  }
  TaskSourceKind2.toConfigurationTarget = toConfigurationTarget;
})(TaskSourceKind || (TaskSourceKind = {}));
var DependsOrder;
(function(DependsOrder2) {
  DependsOrder2["parallel"] = "parallel";
  DependsOrder2["sequence"] = "sequence";
})(DependsOrder || (DependsOrder = {}));
var RunOnOptions;
(function(RunOnOptions2) {
  RunOnOptions2[RunOnOptions2["default"] = 1] = "default";
  RunOnOptions2[RunOnOptions2["folderOpen"] = 2] = "folderOpen";
})(RunOnOptions || (RunOnOptions = {}));
var InstancePolicy;
(function(InstancePolicy2) {
  InstancePolicy2["terminateNewest"] = "terminateNewest";
  InstancePolicy2["terminateOldest"] = "terminateOldest";
  InstancePolicy2["prompt"] = "prompt";
  InstancePolicy2["warn"] = "warn";
  InstancePolicy2["silent"] = "silent";
})(InstancePolicy || (InstancePolicy = {}));
var RunOptions;
(function(RunOptions2) {
  RunOptions2.defaults = {
    reevaluateOnRerun: true,
    runOn: RunOnOptions.default,
    instanceLimit: 1,
    instancePolicy: "prompt"
    /* InstancePolicy.prompt */
  };
})(RunOptions || (RunOptions = {}));
var ExecutionEngine;
(function(ExecutionEngine2) {
  ExecutionEngine2[ExecutionEngine2["Process"] = 1] = "Process";
  ExecutionEngine2[ExecutionEngine2["Terminal"] = 2] = "Terminal";
})(ExecutionEngine || (ExecutionEngine = {}));
(function(ExecutionEngine2) {
  ExecutionEngine2._default = ExecutionEngine2.Terminal;
})(ExecutionEngine || (ExecutionEngine = {}));
var JsonSchemaVersion;
(function(JsonSchemaVersion2) {
  JsonSchemaVersion2[JsonSchemaVersion2["V0_1_0"] = 1] = "V0_1_0";
  JsonSchemaVersion2[JsonSchemaVersion2["V2_0_0"] = 2] = "V2_0_0";
})(JsonSchemaVersion || (JsonSchemaVersion = {}));
var TaskRunType;
(function(TaskRunType2) {
  TaskRunType2["SingleRun"] = "singleRun";
  TaskRunType2["Background"] = "background";
})(TaskRunType || (TaskRunType = {}));
var TaskEventKind2;
(function(TaskEventKind3) {
  TaskEventKind3["Changed"] = "changed";
  TaskEventKind3["ProcessStarted"] = "processStarted";
  TaskEventKind3["ProcessEnded"] = "processEnded";
  TaskEventKind3["Terminated"] = "terminated";
  TaskEventKind3["Start"] = "start";
  TaskEventKind3["AcquiredInput"] = "acquiredInput";
  TaskEventKind3["DependsOnStarted"] = "dependsOnStarted";
  TaskEventKind3["Active"] = "active";
  TaskEventKind3["Inactive"] = "inactive";
  TaskEventKind3["End"] = "end";
  TaskEventKind3["ProblemMatcherStarted"] = "problemMatcherStarted";
  TaskEventKind3["ProblemMatcherEnded"] = "problemMatcherEnded";
  TaskEventKind3["ProblemMatcherFoundErrors"] = "problemMatcherFoundErrors";
})(TaskEventKind2 || (TaskEventKind2 = {}));
var TaskRunSource;
(function(TaskRunSource2) {
  TaskRunSource2[TaskRunSource2["System"] = 0] = "System";
  TaskRunSource2[TaskRunSource2["User"] = 1] = "User";
  TaskRunSource2[TaskRunSource2["FolderOpen"] = 2] = "FolderOpen";
  TaskRunSource2[TaskRunSource2["ConfigurationChange"] = 3] = "ConfigurationChange";
  TaskRunSource2[TaskRunSource2["Reconnect"] = 4] = "Reconnect";
  TaskRunSource2[TaskRunSource2["ChatAgent"] = 5] = "ChatAgent";
})(TaskRunSource || (TaskRunSource = {}));
var TaskEvent;
(function(TaskEvent2) {
  function common(task) {
    return {
      taskId: task._id,
      taskName: task.configurationProperties.name,
      runType: task.configurationProperties.isBackground ? "background" : "singleRun",
      group: task.configurationProperties.group,
      __task: task
    };
  }
  function start(task, terminalId, resolvedVariables) {
    return {
      ...common(task),
      kind: TaskEventKind2.Start,
      terminalId,
      resolvedVariables
    };
  }
  TaskEvent2.start = start;
  function processStarted(task, terminalId, processId) {
    return {
      ...common(task),
      kind: TaskEventKind2.ProcessStarted,
      terminalId,
      processId
    };
  }
  TaskEvent2.processStarted = processStarted;
  function processEnded(task, terminalId, exitCode, durationMs) {
    return {
      ...common(task),
      kind: TaskEventKind2.ProcessEnded,
      terminalId,
      exitCode,
      durationMs
    };
  }
  TaskEvent2.processEnded = processEnded;
  function inactive(task, terminalId, durationMs) {
    return {
      ...common(task),
      kind: TaskEventKind2.Inactive,
      terminalId,
      durationMs
    };
  }
  TaskEvent2.inactive = inactive;
  function terminated(task, terminalId, exitReason) {
    return {
      ...common(task),
      kind: TaskEventKind2.Terminated,
      exitReason,
      terminalId
    };
  }
  TaskEvent2.terminated = terminated;
  function general(kind, task, terminalId) {
    return {
      ...common(task),
      kind,
      terminalId
    };
  }
  TaskEvent2.general = general;
  function problemMatcherEnded(task, hasErrors, terminalId) {
    return {
      ...common(task),
      kind: TaskEventKind2.ProblemMatcherEnded,
      hasErrors
    };
  }
  TaskEvent2.problemMatcherEnded = problemMatcherEnded;
  function changed() {
    return { kind: TaskEventKind2.Changed };
  }
  TaskEvent2.changed = changed;
})(TaskEvent || (TaskEvent = {}));
var KeyedTaskIdentifier;
(function(KeyedTaskIdentifier2) {
  function sortedStringify(literal) {
    const keys = Object.keys(literal).sort();
    let result = "";
    for (const key of keys) {
      let stringified = literal[key];
      if (stringified instanceof Object) {
        stringified = sortedStringify(stringified);
      } else if (typeof stringified === "string") {
        stringified = stringified.replace(/,/g, ",,");
      }
      result += key + "," + stringified + ",";
    }
    return result;
  }
  function create2(value) {
    const resultKey = sortedStringify(value);
    const result = { _key: resultKey, type: value.taskType };
    Object.assign(result, value);
    return result;
  }
  KeyedTaskIdentifier2.create = create2;
})(KeyedTaskIdentifier || (KeyedTaskIdentifier = {}));
var TaskSettingId;
(function(TaskSettingId2) {
  TaskSettingId2["AutoDetect"] = "task.autoDetect";
  TaskSettingId2["SaveBeforeRun"] = "task.saveBeforeRun";
  TaskSettingId2["ShowDecorations"] = "task.showDecorations";
  TaskSettingId2["ProblemMatchersNeverPrompt"] = "task.problemMatchers.neverPrompt";
  TaskSettingId2["SlowProviderWarning"] = "task.slowProviderWarning";
  TaskSettingId2["QuickOpenHistory"] = "task.quickOpen.history";
  TaskSettingId2["QuickOpenDetail"] = "task.quickOpen.detail";
  TaskSettingId2["QuickOpenSkip"] = "task.quickOpen.skip";
  TaskSettingId2["QuickOpenShowAll"] = "task.quickOpen.showAll";
  TaskSettingId2["AllowAutomaticTasks"] = "task.allowAutomaticTasks";
  TaskSettingId2["Reconnection"] = "task.reconnection";
  TaskSettingId2["VerboseLogging"] = "task.verboseLogging";
  TaskSettingId2["NotifyWindowOnTaskCompletion"] = "task.notifyWindowOnTaskCompletion";
})(TaskSettingId || (TaskSettingId = {}));
var TasksSchemaProperties;
(function(TasksSchemaProperties2) {
  TasksSchemaProperties2["Tasks"] = "tasks";
  TasksSchemaProperties2["SuppressTaskName"] = "tasks.suppressTaskName";
  TasksSchemaProperties2["Windows"] = "tasks.windows";
  TasksSchemaProperties2["Osx"] = "tasks.osx";
  TasksSchemaProperties2["Linux"] = "tasks.linux";
  TasksSchemaProperties2["ShowOutput"] = "tasks.showOutput";
  TasksSchemaProperties2["IsShellCommand"] = "tasks.isShellCommand";
  TasksSchemaProperties2["ServiceTestSetting"] = "tasks.service.testSetting";
})(TasksSchemaProperties || (TasksSchemaProperties = {}));
var TaskDefinition;
(function(TaskDefinition2) {
  function createTaskIdentifier(external, reporter) {
    const definition = TaskDefinitionRegistry.get(external.type);
    if (definition === void 0) {
      const copy = deepClone(external);
      delete copy._key;
      return KeyedTaskIdentifier.create(copy);
    }
    const literal = /* @__PURE__ */ Object.create(null);
    literal.type = definition.taskType;
    const required = /* @__PURE__ */ new Set();
    definition.required.forEach((element) => required.add(element));
    const properties = definition.properties;
    for (const property of Object.keys(properties)) {
      const value = external[property];
      if (value !== void 0 && value !== null) {
        literal[property] = value;
      } else if (required.has(property)) {
        const schema2 = properties[property];
        if (schema2.default !== void 0) {
          literal[property] = deepClone(schema2.default);
        } else {
          switch (schema2.type) {
            case "boolean":
              literal[property] = false;
              break;
            case "number":
            case "integer":
              literal[property] = 0;
              break;
            case "string":
              literal[property] = "";
              break;
            default:
              reporter.error(localize(12535, null, JSON.stringify(external, void 0, 0), property));
              return void 0;
          }
        }
      }
    }
    return KeyedTaskIdentifier.create(literal);
  }
  TaskDefinition2.createTaskIdentifier = createTaskIdentifier;
})(TaskDefinition || (TaskDefinition = {}));
var rerunTaskIcon = registerIcon("rerun-task", Codicon.refresh, localize(12536, null));

// out-build/vs/workbench/api/common/extHostTask.js
var TaskDefinitionDTO;
(function(TaskDefinitionDTO2) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskDefinitionDTO2.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskDefinitionDTO2.to = to;
})(TaskDefinitionDTO || (TaskDefinitionDTO = {}));
var TaskPresentationOptionsDTO;
(function(TaskPresentationOptionsDTO2) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskPresentationOptionsDTO2.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskPresentationOptionsDTO2.to = to;
})(TaskPresentationOptionsDTO || (TaskPresentationOptionsDTO = {}));
var ProcessExecutionOptionsDTO;
(function(ProcessExecutionOptionsDTO2) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ProcessExecutionOptionsDTO2.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ProcessExecutionOptionsDTO2.to = to;
})(ProcessExecutionOptionsDTO || (ProcessExecutionOptionsDTO = {}));
var ProcessExecutionDTO;
(function(ProcessExecutionDTO2) {
  function is(value) {
    if (value) {
      const candidate = value;
      return candidate && !!candidate.process;
    } else {
      return false;
    }
  }
  ProcessExecutionDTO2.is = is;
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    const result = {
      process: value.process,
      args: value.args
    };
    if (value.options) {
      result.options = ProcessExecutionOptionsDTO.from(value.options);
    }
    return result;
  }
  ProcessExecutionDTO2.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return new ProcessExecution(value.process, value.args, value.options);
  }
  ProcessExecutionDTO2.to = to;
})(ProcessExecutionDTO || (ProcessExecutionDTO = {}));
var ShellExecutionOptionsDTO;
(function(ShellExecutionOptionsDTO2) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ShellExecutionOptionsDTO2.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ShellExecutionOptionsDTO2.to = to;
})(ShellExecutionOptionsDTO || (ShellExecutionOptionsDTO = {}));
var ShellExecutionDTO;
(function(ShellExecutionDTO2) {
  function is(value) {
    if (value) {
      const candidate = value;
      return candidate && (!!candidate.commandLine || !!candidate.command);
    } else {
      return false;
    }
  }
  ShellExecutionDTO2.is = is;
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    const result = {};
    if (value.commandLine !== void 0) {
      result.commandLine = value.commandLine;
    } else {
      result.command = value.command;
      result.args = value.args;
    }
    if (value.options) {
      result.options = ShellExecutionOptionsDTO.from(value.options);
    }
    return result;
  }
  ShellExecutionDTO2.from = from;
  function to(value) {
    if (value === void 0 || value === null || value.command === void 0 && value.commandLine === void 0) {
      return void 0;
    }
    if (value.commandLine) {
      return new ShellExecution(value.commandLine, value.options);
    } else {
      return new ShellExecution(value.command, value.args ? value.args : [], value.options);
    }
  }
  ShellExecutionDTO2.to = to;
})(ShellExecutionDTO || (ShellExecutionDTO = {}));
var CustomExecutionDTO;
(function(CustomExecutionDTO2) {
  function is(value) {
    if (value) {
      const candidate = value;
      return candidate && candidate.customExecution === "customExecution";
    } else {
      return false;
    }
  }
  CustomExecutionDTO2.is = is;
  function from(value) {
    return {
      customExecution: "customExecution"
    };
  }
  CustomExecutionDTO2.from = from;
  function to(taskId, providedCustomExeutions) {
    return providedCustomExeutions.get(taskId);
  }
  CustomExecutionDTO2.to = to;
})(CustomExecutionDTO || (CustomExecutionDTO = {}));
var TaskHandleDTO;
(function(TaskHandleDTO2) {
  function from(value, workspaceService) {
    let folder;
    if (value.scope !== void 0 && typeof value.scope !== "number") {
      folder = value.scope.uri;
    } else if (value.scope !== void 0 && typeof value.scope === "number") {
      if (value.scope === TaskScope.Workspace && workspaceService && workspaceService.workspaceFile) {
        folder = workspaceService.workspaceFile;
      } else {
        folder = USER_TASKS_GROUP_KEY;
      }
    }
    return {
      id: value._id,
      workspaceFolder: folder
    };
  }
  TaskHandleDTO2.from = from;
})(TaskHandleDTO || (TaskHandleDTO = {}));
var TaskGroupDTO;
(function(TaskGroupDTO2) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return { _id: value.id, isDefault: value.isDefault };
  }
  TaskGroupDTO2.from = from;
})(TaskGroupDTO || (TaskGroupDTO = {}));
var TaskDTO;
(function(TaskDTO2) {
  function fromMany(tasks, extension) {
    if (tasks === void 0 || tasks === null) {
      return [];
    }
    const result = [];
    for (const task of tasks) {
      const converted = from(task, extension);
      if (converted) {
        result.push(converted);
      }
    }
    return result;
  }
  TaskDTO2.fromMany = fromMany;
  function from(value, extension) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    let execution;
    if (value.execution instanceof ProcessExecution) {
      execution = ProcessExecutionDTO.from(value.execution);
    } else if (value.execution instanceof ShellExecution) {
      execution = ShellExecutionDTO.from(value.execution);
    } else if (value.execution && value.execution instanceof CustomExecution) {
      execution = CustomExecutionDTO.from(value.execution);
    }
    const definition = TaskDefinitionDTO.from(value.definition);
    let scope;
    if (value.scope) {
      if (typeof value.scope === "number") {
        scope = value.scope;
      } else {
        scope = value.scope.uri;
      }
    } else {
      scope = TaskScope.Workspace;
    }
    if (!definition || !scope) {
      return void 0;
    }
    const result = {
      _id: value._id,
      definition,
      name: value.name,
      source: {
        extensionId: extension.identifier.value,
        label: value.source,
        scope
      },
      execution,
      isBackground: value.isBackground,
      group: TaskGroupDTO.from(value.group),
      presentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),
      problemMatchers: asArray(value.problemMatchers),
      hasDefinedMatchers: value.hasDefinedMatchers,
      runOptions: value.runOptions ? value.runOptions : { reevaluateOnRerun: true },
      detail: value.detail
    };
    return result;
  }
  TaskDTO2.from = from;
  async function to(value, workspace, providedCustomExeutions) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    let execution;
    if (ProcessExecutionDTO.is(value.execution)) {
      execution = ProcessExecutionDTO.to(value.execution);
    } else if (ShellExecutionDTO.is(value.execution)) {
      execution = ShellExecutionDTO.to(value.execution);
    } else if (CustomExecutionDTO.is(value.execution)) {
      execution = CustomExecutionDTO.to(value._id, providedCustomExeutions);
    }
    const definition = TaskDefinitionDTO.to(value.definition);
    let scope;
    if (value.source) {
      if (value.source.scope !== void 0) {
        if (typeof value.source.scope === "number") {
          scope = value.source.scope;
        } else {
          scope = await workspace.resolveWorkspaceFolder(URI.revive(value.source.scope));
        }
      } else {
        scope = TaskScope.Workspace;
      }
    }
    if (!definition || !scope) {
      return void 0;
    }
    const result = new Task(definition, scope, value.name, value.source.label, execution, value.problemMatchers);
    if (value.isBackground !== void 0) {
      result.isBackground = value.isBackground;
    }
    if (value.group !== void 0) {
      result.group = TaskGroup.from(value.group._id);
      if (result.group && value.group.isDefault) {
        result.group = new TaskGroup(result.group.id, result.group.label);
        if (value.group.isDefault === true) {
          result.group.isDefault = value.group.isDefault;
        }
      }
    }
    if (value.presentationOptions) {
      result.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions);
    }
    if (value._id) {
      result._id = value._id;
    }
    if (value.detail) {
      result.detail = value.detail;
    }
    return result;
  }
  TaskDTO2.to = to;
})(TaskDTO || (TaskDTO = {}));
var TaskFilterDTO;
(function(TaskFilterDTO2) {
  function from(value) {
    return value;
  }
  TaskFilterDTO2.from = from;
  function to(value) {
    if (!value) {
      return void 0;
    }
    return Object.assign(/* @__PURE__ */ Object.create(null), value);
  }
  TaskFilterDTO2.to = to;
})(TaskFilterDTO || (TaskFilterDTO = {}));
var TaskExecutionImpl = class {
  #tasks;
  constructor(tasks, _id, _task) {
    this._id = _id;
    this._task = _task;
    this.#tasks = tasks;
  }
  get task() {
    return this._task;
  }
  terminate() {
    this.#tasks.terminateTask(this);
  }
  fireDidStartProcess(value) {
  }
  fireDidEndProcess(value) {
  }
  get terminal() {
    return this._terminal;
  }
  set terminal(term) {
    this._terminal = term;
  }
};
var ExtHostTaskBase = class ExtHostTaskBase2 {
  constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {
    this._onDidExecuteTask = new Emitter();
    this._onDidTerminateTask = new Emitter();
    this._onDidTaskProcessStarted = new Emitter();
    this._onDidTaskProcessEnded = new Emitter();
    this._onDidStartTaskProblemMatchers = new Emitter();
    this._onDidEndTaskProblemMatchers = new Emitter();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadTask);
    this._workspaceProvider = workspaceService;
    this._editorService = editorService;
    this._configurationService = configurationService;
    this._terminalService = extHostTerminalService;
    this._handleCounter = 0;
    this._handlers = /* @__PURE__ */ new Map();
    this._taskExecutions = /* @__PURE__ */ new Map();
    this._taskExecutionPromises = /* @__PURE__ */ new Map();
    this._providedCustomExecutions2 = /* @__PURE__ */ new Map();
    this._notProvidedCustomExecutions = /* @__PURE__ */ new Set();
    this._activeCustomExecutions2 = /* @__PURE__ */ new Map();
    this._logService = logService;
    this._deprecationService = deprecationService;
    this._proxy.$registerSupportedExecutions(true);
  }
  registerTaskProvider(extension, type, provider) {
    if (!provider) {
      return new Disposable2(() => {
      });
    }
    const handle = this.nextHandle();
    this._handlers.set(handle, { type, provider, extension });
    this._proxy.$registerTaskProvider(handle, type);
    return new Disposable2(() => {
      this._handlers.delete(handle);
      this._proxy.$unregisterTaskProvider(handle);
    });
  }
  registerTaskSystem(scheme, info) {
    this._proxy.$registerTaskSystem(scheme, info);
  }
  fetchTasks(filter2) {
    return this._proxy.$fetchTasks(TaskFilterDTO.from(filter2)).then(async (values) => {
      const result = [];
      for (const value of values) {
        const task = await TaskDTO.to(value, this._workspaceProvider, this._providedCustomExecutions2);
        if (task) {
          result.push(task);
        }
      }
      return result;
    });
  }
  get taskExecutions() {
    const result = [];
    this._taskExecutions.forEach((value) => result.push(value));
    return result;
  }
  terminateTask(execution) {
    if (!(execution instanceof TaskExecutionImpl)) {
      throw new Error("No valid task execution provided");
    }
    return this._proxy.$terminateTask(execution._id);
  }
  get onDidStartTask() {
    return this._onDidExecuteTask.event;
  }
  async $onDidStartTask(execution, terminalId, resolvedDefinition) {
    const customExecution = this._providedCustomExecutions2.get(execution.id);
    if (customExecution) {
      this._activeCustomExecutions2.set(execution.id, customExecution);
      this._terminalService.attachPtyToTerminal(terminalId, await customExecution.callback(resolvedDefinition));
    }
    this._lastStartedTask = execution.id;
    const taskExecution = await this.getTaskExecution(execution);
    const terminal = this._terminalService.getTerminalById(terminalId)?.value;
    if (taskExecution) {
      taskExecution.terminal = terminal;
    }
    this._onDidExecuteTask.fire({
      execution: taskExecution
    });
  }
  get onDidEndTask() {
    return this._onDidTerminateTask.event;
  }
  async $OnDidEndTask(execution) {
    if (!this._taskExecutionPromises.has(execution.id)) {
      return;
    }
    const _execution = await this.getTaskExecution(execution);
    this._taskExecutionPromises.delete(execution.id);
    this._taskExecutions.delete(execution.id);
    this.customExecutionComplete(execution);
    this._onDidTerminateTask.fire({
      execution: _execution
    });
  }
  get onDidStartTaskProcess() {
    return this._onDidTaskProcessStarted.event;
  }
  async $onDidStartTaskProcess(value) {
    const execution = await this.getTaskExecution(value.id);
    this._onDidTaskProcessStarted.fire({
      execution,
      processId: value.processId
    });
  }
  get onDidEndTaskProcess() {
    return this._onDidTaskProcessEnded.event;
  }
  async $onDidEndTaskProcess(value) {
    const execution = await this.getTaskExecution(value.id);
    this._onDidTaskProcessEnded.fire({
      execution,
      exitCode: value.exitCode
    });
  }
  get onDidStartTaskProblemMatchers() {
    return this._onDidStartTaskProblemMatchers.event;
  }
  async $onDidStartTaskProblemMatchers(value) {
    let execution;
    try {
      execution = await this.getTaskExecution(value.execution.id);
    } catch (error) {
      return;
    }
    this._onDidStartTaskProblemMatchers.fire({ execution });
  }
  get onDidEndTaskProblemMatchers() {
    return this._onDidEndTaskProblemMatchers.event;
  }
  async $onDidEndTaskProblemMatchers(value) {
    let execution;
    try {
      execution = await this.getTaskExecution(value.execution.id);
    } catch (error) {
      return;
    }
    this._onDidEndTaskProblemMatchers.fire({ execution, hasErrors: value.hasErrors });
  }
  $provideTasks(handle, validTypes) {
    const handler = this._handlers.get(handle);
    if (!handler) {
      return Promise.reject(new Error("no handler found"));
    }
    const taskIdPromises = [];
    const fetchPromise = asPromise(() => handler.provider.provideTasks(CancellationToken.None)).then((value) => {
      return this.provideTasksInternal(validTypes, taskIdPromises, handler, value);
    });
    return new Promise((resolve2) => {
      fetchPromise.then((result) => {
        Promise.all(taskIdPromises).then(() => {
          resolve2(result);
        });
      });
    });
  }
  async $resolveTask(handle, taskDTO) {
    const handler = this._handlers.get(handle);
    if (!handler) {
      return Promise.reject(new Error("no handler found"));
    }
    if (taskDTO.definition.type !== handler.type) {
      throw new Error(`Unexpected: Task of type [${taskDTO.definition.type}] cannot be resolved by provider of type [${handler.type}].`);
    }
    const task = await TaskDTO.to(taskDTO, this._workspaceProvider, this._providedCustomExecutions2);
    if (!task) {
      throw new Error("Unexpected: Task cannot be resolved.");
    }
    const resolvedTask = await handler.provider.resolveTask(task, CancellationToken.None);
    if (!resolvedTask) {
      return;
    }
    this.checkDeprecation(resolvedTask, handler);
    const resolvedTaskDTO = TaskDTO.from(resolvedTask, handler.extension);
    if (!resolvedTaskDTO) {
      throw new Error("Unexpected: Task cannot be resolved.");
    }
    if (resolvedTask.definition !== task.definition) {
      throw new Error("Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.");
    }
    if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {
      await this.addCustomExecution(resolvedTaskDTO, resolvedTask, true);
    }
    return await this.resolveTaskInternal(resolvedTaskDTO);
  }
  nextHandle() {
    return this._handleCounter++;
  }
  async addCustomExecution(taskDTO, task, isProvided) {
    const taskId = await this._proxy.$createTaskId(taskDTO);
    if (!isProvided && !this._providedCustomExecutions2.has(taskId)) {
      this._notProvidedCustomExecutions.add(taskId);
      this._activeCustomExecutions2.set(taskId, task.execution);
    }
    this._providedCustomExecutions2.set(taskId, task.execution);
  }
  async getTaskExecution(execution, task) {
    if (typeof execution === "string") {
      const taskExecution = this._taskExecutionPromises.get(execution);
      if (!taskExecution) {
        throw new ErrorNoTelemetry("Unexpected: The specified task is missing an execution");
      }
      return taskExecution;
    }
    const result = this._taskExecutionPromises.get(execution.id);
    if (result) {
      return result;
    }
    let executionPromise;
    if (!task) {
      executionPromise = TaskDTO.to(execution.task, this._workspaceProvider, this._providedCustomExecutions2).then((t) => {
        if (!t) {
          throw new ErrorNoTelemetry("Unexpected: Task does not exist.");
        }
        return new TaskExecutionImpl(this, execution.id, t);
      });
    } else {
      executionPromise = Promise.resolve(new TaskExecutionImpl(this, execution.id, task));
    }
    this._taskExecutionPromises.set(execution.id, executionPromise);
    return executionPromise.then((taskExecution) => {
      this._taskExecutions.set(execution.id, taskExecution);
      return taskExecution;
    });
  }
  checkDeprecation(task, handler) {
    const tTask = task;
    if (tTask._deprecated) {
      this._deprecationService.report("Task.constructor", handler.extension, "Use the Task constructor that takes a `scope` instead.");
    }
  }
  customExecutionComplete(execution) {
    const extensionCallback2 = this._activeCustomExecutions2.get(execution.id);
    if (extensionCallback2) {
      this._activeCustomExecutions2.delete(execution.id);
    }
    if (this._notProvidedCustomExecutions.has(execution.id) && this._lastStartedTask !== execution.id) {
      this._providedCustomExecutions2.delete(execution.id);
      this._notProvidedCustomExecutions.delete(execution.id);
    }
    const iterator = this._notProvidedCustomExecutions.values();
    let iteratorResult = iterator.next();
    while (!iteratorResult.done) {
      if (!this._activeCustomExecutions2.has(iteratorResult.value) && this._lastStartedTask !== iteratorResult.value) {
        this._providedCustomExecutions2.delete(iteratorResult.value);
        this._notProvidedCustomExecutions.delete(iteratorResult.value);
      }
      iteratorResult = iterator.next();
    }
  }
};
ExtHostTaskBase = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostWorkspace),
  __param(3, IExtHostDocumentsAndEditors),
  __param(4, IExtHostConfiguration),
  __param(5, IExtHostTerminalService),
  __param(6, ILogService),
  __param(7, IExtHostApiDeprecationService)
], ExtHostTaskBase);
var WorkerExtHostTask = class WorkerExtHostTask2 extends ExtHostTaskBase {
  constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {
    super(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);
    this.registerTaskSystem(Schemas.vscodeRemote, {
      scheme: Schemas.vscodeRemote,
      authority: "",
      platform: PlatformToString(
        0
        /* Platform.Platform.Web */
      )
    });
  }
  async executeTask(extension, task) {
    if (!task.execution) {
      throw new Error("Tasks to execute must include an execution");
    }
    const dto = TaskDTO.from(task, extension);
    if (dto === void 0) {
      throw new Error("Task is not valid");
    }
    if (CustomExecutionDTO.is(dto.execution)) {
      await this.addCustomExecution(dto, task, false);
    } else {
      throw new NotSupportedError();
    }
    const execution = await this.getTaskExecution(await this._proxy.$getTaskExecution(dto), task);
    this._proxy.$executeTask(dto).catch((error) => {
      throw new Error(error);
    });
    return execution;
  }
  provideTasksInternal(validTypes, taskIdPromises, handler, value) {
    const taskDTOs = [];
    if (value) {
      for (const task of value) {
        this.checkDeprecation(task, handler);
        if (!task.definition || !validTypes[task.definition.type]) {
          const source = task.source ? task.source : "No task source";
          this._logService.warn(`The task [${source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);
        }
        const taskDTO = TaskDTO.from(task, handler.extension);
        if (taskDTO && CustomExecutionDTO.is(taskDTO.execution)) {
          taskDTOs.push(taskDTO);
          taskIdPromises.push(this.addCustomExecution(taskDTO, task, true));
        } else {
          this._logService.warn("Only custom execution tasks supported.");
        }
      }
    }
    return {
      tasks: taskDTOs,
      extension: handler.extension
    };
  }
  async resolveTaskInternal(resolvedTaskDTO) {
    if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {
      return resolvedTaskDTO;
    } else {
      this._logService.warn("Only custom execution tasks supported.");
    }
    return void 0;
  }
  async $resolveVariables(uriComponents, toResolve) {
    const result = {
      process: void 0,
      variables: /* @__PURE__ */ Object.create(null)
    };
    return result;
  }
  async $jsonTasksSupported() {
    return false;
  }
  async $findExecutable(command, cwd2, paths) {
    return void 0;
  }
};
WorkerExtHostTask = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostWorkspace),
  __param(3, IExtHostDocumentsAndEditors),
  __param(4, IExtHostConfiguration),
  __param(5, IExtHostTerminalService),
  __param(6, ILogService),
  __param(7, IExtHostApiDeprecationService)
], WorkerExtHostTask);
var IExtHostTask = createDecorator("IExtHostTask");

// out-build/vs/workbench/contrib/debug/common/abstractDebugAdapter.js
var AbstractDebugAdapter = class {
  constructor() {
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.queue = [];
    this._onError = new Emitter();
    this._onExit = new Emitter();
    this.sequence = 1;
  }
  get onError() {
    return this._onError.event;
  }
  get onExit() {
    return this._onExit.event;
  }
  onMessage(callback) {
    if (this.messageCallback) {
      this._onError.fire(new Error(`attempt to set more than one 'Message' callback`));
    }
    this.messageCallback = callback;
  }
  onEvent(callback) {
    if (this.eventCallback) {
      this._onError.fire(new Error(`attempt to set more than one 'Event' callback`));
    }
    this.eventCallback = callback;
  }
  onRequest(callback) {
    if (this.requestCallback) {
      this._onError.fire(new Error(`attempt to set more than one 'Request' callback`));
    }
    this.requestCallback = callback;
  }
  sendResponse(response) {
    if (response.seq > 0) {
      this._onError.fire(new Error(`attempt to send more than one response for command ${response.command}`));
    } else {
      this.internalSend("response", response);
    }
  }
  sendRequest(command, args, clb, timeout2) {
    const request = {
      command
    };
    if (args && Object.keys(args).length > 0) {
      request.arguments = args;
    }
    this.internalSend("request", request);
    if (typeof timeout2 === "number") {
      const timer = setTimeout(() => {
        clearTimeout(timer);
        const clb2 = this.pendingRequests.get(request.seq);
        if (clb2) {
          this.pendingRequests.delete(request.seq);
          const err = {
            type: "response",
            seq: 0,
            request_seq: request.seq,
            success: false,
            command,
            message: localize(7635, null, timeout2, command)
          };
          clb2(err);
        }
      }, timeout2);
    }
    if (clb) {
      this.pendingRequests.set(request.seq, clb);
    }
    return request.seq;
  }
  acceptMessage(message) {
    if (this.messageCallback) {
      this.messageCallback(message);
    } else {
      this.queue.push(message);
      if (this.queue.length === 1) {
        this.processQueue();
      }
    }
  }
  /**
   * Returns whether we should insert a timeout between processing messageA
   * and messageB. Artificially queueing protocol messages guarantees that any
   * microtasks for previous message finish before next message is processed.
   * This is essential ordering when using promises anywhere along the call path.
   *
   * For example, take the following, where `chooseAndSendGreeting` returns
   * a person name and then emits a greeting event:
   *
   * ```
   * let person: string;
   * adapter.onGreeting(() => console.log('hello', person));
   * person = await adapter.chooseAndSendGreeting();
   * ```
   *
   * Because the event is dispatched synchronously, it may fire before person
   * is assigned if they're processed in the same task. Inserting a task
   * boundary avoids this issue.
   */
  needsTaskBoundaryBetween(messageA, messageB) {
    return messageA.type !== "event" || messageB.type !== "event";
  }
  /**
   * Reads and dispatches items from the queue until it is empty.
   */
  async processQueue() {
    let message;
    while (this.queue.length) {
      if (!message || this.needsTaskBoundaryBetween(this.queue[0], message)) {
        await timeout(0);
      }
      message = this.queue.shift();
      if (!message) {
        return;
      }
      switch (message.type) {
        case "event":
          this.eventCallback?.(message);
          break;
        case "request":
          this.requestCallback?.(message);
          break;
        case "response": {
          const response = message;
          const clb = this.pendingRequests.get(response.request_seq);
          if (clb) {
            this.pendingRequests.delete(response.request_seq);
            clb(response);
          }
          break;
        }
      }
    }
  }
  internalSend(typ, message) {
    message.type = typ;
    message.seq = this.sequence++;
    this.sendMessage(message);
  }
  async cancelPendingRequests() {
    if (this.pendingRequests.size === 0) {
      return Promise.resolve();
    }
    const pending = /* @__PURE__ */ new Map();
    this.pendingRequests.forEach((value, key) => pending.set(key, value));
    await timeout(500);
    pending.forEach((callback, request_seq) => {
      const err = {
        type: "response",
        seq: 0,
        request_seq,
        success: false,
        command: "canceled",
        message: "canceled"
      };
      callback(err);
      this.pendingRequests.delete(request_seq);
    });
  }
  getPendingRequestIds() {
    return Array.from(this.pendingRequests.keys());
  }
  dispose() {
    this.queue = [];
  }
};

// out-build/vs/workbench/contrib/debug/common/debugUtils.js
function isDebuggerMainContribution(dbg) {
  return dbg.type && (dbg.label || dbg.program || dbg.runtime);
}
var _schemePattern2 = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;
function isUriString(s) {
  return !!(s && s.match(_schemePattern2));
}
function stringToUri(source) {
  if (typeof source.path === "string") {
    if (typeof source.sourceReference === "number" && source.sourceReference > 0) {
    } else {
      if (isUriString(source.path)) {
        return URI.parse(source.path);
      } else {
        if (isAbsolute(source.path)) {
          return URI.file(source.path);
        } else {
        }
      }
    }
  }
  return source.path;
}
function uriToString(source) {
  if (typeof source.path === "object") {
    const u = URI.revive(source.path);
    if (u) {
      if (u.scheme === Schemas.file) {
        return u.fsPath;
      } else {
        return u.toString();
      }
    }
  }
  return source.path;
}
function convertToDAPaths(message, toUri) {
  const fixPath = toUri ? stringToUri : uriToString;
  const msg = deepClone(message);
  convertPaths(msg, (toDA, source) => {
    if (toDA && source) {
      source.path = fixPath(source);
    }
  });
  return msg;
}
function convertToVSCPaths(message, toUri) {
  const fixPath = toUri ? stringToUri : uriToString;
  const msg = deepClone(message);
  convertPaths(msg, (toDA, source) => {
    if (!toDA && source) {
      source.path = fixPath(source);
    }
  });
  return msg;
}
function convertPaths(msg, fixSourcePath) {
  switch (msg.type) {
    case "event": {
      const event = msg;
      switch (event.event) {
        case "output":
          fixSourcePath(false, event.body.source);
          break;
        case "loadedSource":
          fixSourcePath(false, event.body.source);
          break;
        case "breakpoint":
          fixSourcePath(false, event.body.breakpoint.source);
          break;
        default:
          break;
      }
      break;
    }
    case "request": {
      const request = msg;
      switch (request.command) {
        case "setBreakpoints":
          fixSourcePath(true, request.arguments.source);
          break;
        case "breakpointLocations":
          fixSourcePath(true, request.arguments.source);
          break;
        case "source":
          fixSourcePath(true, request.arguments.source);
          break;
        case "gotoTargets":
          fixSourcePath(true, request.arguments.source);
          break;
        case "launchVSCode":
          request.arguments.args.forEach((arg) => fixSourcePath(false, arg));
          break;
        default:
          break;
      }
      break;
    }
    case "response": {
      const response = msg;
      if (response.success && response.body) {
        switch (response.command) {
          case "stackTrace":
            response.body.stackFrames.forEach((frame) => fixSourcePath(false, frame.source));
            break;
          case "loadedSources":
            response.body.sources.forEach((source) => fixSourcePath(false, source));
            break;
          case "scopes":
            response.body.scopes.forEach((scope) => fixSourcePath(false, scope.source));
            break;
          case "setFunctionBreakpoints":
            response.body.breakpoints.forEach((bp) => fixSourcePath(false, bp.source));
            break;
          case "setBreakpoints":
            response.body.breakpoints.forEach((bp) => fixSourcePath(false, bp.source));
            break;
          case "disassemble":
            {
              const di = response;
              di.body?.instructions.forEach((di2) => fixSourcePath(false, di2.location));
            }
            break;
          case "locations":
            fixSourcePath(false, response.body?.source);
            break;
          default:
            break;
        }
      }
      break;
    }
  }
}

// out-build/vs/workbench/api/common/extHostEditorTabs.js
var IExtHostEditorTabs = createDecorator("IExtHostEditorTabs");
var ExtHostEditorTab = class {
  constructor(dto, parentGroup, activeTabIdGetter) {
    this._activeTabIdGetter = activeTabIdGetter;
    this._parentGroup = parentGroup;
    this.acceptDtoUpdate(dto);
  }
  get apiObject() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        get isActive() {
          return that._dto.id === that._activeTabIdGetter();
        },
        get label() {
          return that._dto.label;
        },
        get input() {
          return that._input;
        },
        get isDirty() {
          return that._dto.isDirty;
        },
        get isPinned() {
          return that._dto.isPinned;
        },
        get isPreview() {
          return that._dto.isPreview;
        },
        get group() {
          return that._parentGroup.apiObject;
        }
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  get tabId() {
    return this._dto.id;
  }
  acceptDtoUpdate(dto) {
    this._dto = dto;
    this._input = this._initInput();
  }
  _initInput() {
    switch (this._dto.input.kind) {
      case 1:
        return new TextTabInput(URI.revive(this._dto.input.uri));
      case 2:
        return new TextDiffTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified));
      case 3:
        return new TextMergeTabInput(URI.revive(this._dto.input.base), URI.revive(this._dto.input.input1), URI.revive(this._dto.input.input2), URI.revive(this._dto.input.result));
      case 6:
        return new CustomEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.viewType);
      case 7:
        return new WebviewEditorTabInput(this._dto.input.viewType);
      case 4:
        return new NotebookEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.notebookType);
      case 5:
        return new NotebookDiffEditorTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified), this._dto.input.notebookType);
      case 8:
        return new TerminalEditorTabInput();
      case 9:
        return new InteractiveWindowInput(URI.revive(this._dto.input.uri), URI.revive(this._dto.input.inputBoxUri));
      case 10:
        return new ChatEditorTabInput();
      case 11:
        return new TextMultiDiffTabInput(this._dto.input.diffEditors.map((diff2) => new TextDiffTabInput(URI.revive(diff2.original), URI.revive(diff2.modified))));
      default:
        return void 0;
    }
  }
};
var ExtHostEditorTabGroup = class {
  constructor(dto, activeGroupIdGetter) {
    this._tabs = [];
    this._activeTabId = "";
    this._dto = dto;
    this._activeGroupIdGetter = activeGroupIdGetter;
    for (const tabDto of dto.tabs) {
      if (tabDto.isActive) {
        this._activeTabId = tabDto.id;
      }
      this._tabs.push(new ExtHostEditorTab(tabDto, this, () => this.activeTabId()));
    }
  }
  get apiObject() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        get isActive() {
          return that._dto.groupId === that._activeGroupIdGetter();
        },
        get viewColumn() {
          return ViewColumn2.to(that._dto.viewColumn);
        },
        get activeTab() {
          return that._tabs.find((tab) => tab.tabId === that._activeTabId)?.apiObject;
        },
        get tabs() {
          return Object.freeze(that._tabs.map((tab) => tab.apiObject));
        }
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  get groupId() {
    return this._dto.groupId;
  }
  get tabs() {
    return this._tabs;
  }
  acceptGroupDtoUpdate(dto) {
    this._dto = dto;
  }
  acceptTabOperation(operation) {
    if (operation.kind === 0) {
      const tab2 = new ExtHostEditorTab(operation.tabDto, this, () => this.activeTabId());
      this._tabs.splice(operation.index, 0, tab2);
      if (operation.tabDto.isActive) {
        this._activeTabId = tab2.tabId;
      }
      return tab2;
    } else if (operation.kind === 1) {
      const tab2 = this._tabs.splice(operation.index, 1)[0];
      if (!tab2) {
        throw new Error(`Tab close updated received for index ${operation.index} which does not exist`);
      }
      if (tab2.tabId === this._activeTabId) {
        this._activeTabId = "";
      }
      return tab2;
    } else if (operation.kind === 3) {
      if (operation.oldIndex === void 0) {
        throw new Error("Invalid old index on move IPC");
      }
      const tab2 = this._tabs.splice(operation.oldIndex, 1)[0];
      if (!tab2) {
        throw new Error(`Tab move updated received for index ${operation.oldIndex} which does not exist`);
      }
      this._tabs.splice(operation.index, 0, tab2);
      return tab2;
    }
    const tab = this._tabs.find((extHostTab) => extHostTab.tabId === operation.tabDto.id);
    if (!tab) {
      throw new Error("INVALID tab");
    }
    if (operation.tabDto.isActive) {
      this._activeTabId = operation.tabDto.id;
    } else if (this._activeTabId === operation.tabDto.id && !operation.tabDto.isActive) {
      this._activeTabId = "";
    }
    tab.acceptDtoUpdate(operation.tabDto);
    return tab;
  }
  // Not a getter since it must be a function to be used as a callback for the tabs
  activeTabId() {
    return this._activeTabId;
  }
};
var ExtHostEditorTabs = class ExtHostEditorTabs2 {
  constructor(extHostRpc) {
    this._onDidChangeTabs = new Emitter();
    this._onDidChangeTabGroups = new Emitter();
    this._extHostTabGroups = [];
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadEditorTabs);
  }
  get tabGroups() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        // never changes -> simple value
        onDidChangeTabGroups: that._onDidChangeTabGroups.event,
        onDidChangeTabs: that._onDidChangeTabs.event,
        // dynamic -> getters
        get all() {
          return Object.freeze(that._extHostTabGroups.map((group) => group.apiObject));
        },
        get activeTabGroup() {
          const activeTabGroupId = that._activeGroupId;
          const activeTabGroup = assertReturnsDefined(that._extHostTabGroups.find((candidate) => candidate.groupId === activeTabGroupId)?.apiObject);
          return activeTabGroup;
        },
        close: async (tabOrTabGroup, preserveFocus) => {
          const tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];
          if (!tabsOrTabGroups.length) {
            return true;
          }
          if (isTabGroup(tabsOrTabGroups[0])) {
            return this._closeGroups(tabsOrTabGroups, preserveFocus);
          } else {
            return this._closeTabs(tabsOrTabGroups, preserveFocus);
          }
        }
        // move: async (tab: vscode.Tab, viewColumn: ViewColumn, index: number, preserveFocus?: boolean) => {
        // 	const extHostTab = this._findExtHostTabFromApi(tab);
        // 	if (!extHostTab) {
        // 		throw new Error('Invalid tab');
        // 	}
        // 	this._proxy.$moveTab(extHostTab.tabId, index, typeConverters.ViewColumn.from(viewColumn), preserveFocus);
        // 	return;
        // }
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  $acceptEditorTabModel(tabGroups) {
    const groupIdsBefore = new Set(this._extHostTabGroups.map((group) => group.groupId));
    const groupIdsAfter = new Set(tabGroups.map((dto) => dto.groupId));
    const diff2 = diffSets(groupIdsBefore, groupIdsAfter);
    const closed = this._extHostTabGroups.filter((group) => diff2.removed.includes(group.groupId)).map((group) => group.apiObject);
    const opened = [];
    const changed = [];
    this._extHostTabGroups = tabGroups.map((tabGroup) => {
      const group = new ExtHostEditorTabGroup(tabGroup, () => this._activeGroupId);
      if (diff2.added.includes(group.groupId)) {
        opened.push(group.apiObject);
      } else {
        changed.push(group.apiObject);
      }
      return group;
    });
    const activeTabGroupId = assertReturnsDefined(tabGroups.find((group) => group.isActive === true)?.groupId);
    if (activeTabGroupId !== void 0 && this._activeGroupId !== activeTabGroupId) {
      this._activeGroupId = activeTabGroupId;
    }
    this._onDidChangeTabGroups.fire(Object.freeze({ opened, closed, changed }));
  }
  $acceptTabGroupUpdate(groupDto) {
    const group = this._extHostTabGroups.find((group2) => group2.groupId === groupDto.groupId);
    if (!group) {
      throw new Error("Update Group IPC call received before group creation.");
    }
    group.acceptGroupDtoUpdate(groupDto);
    if (groupDto.isActive) {
      this._activeGroupId = groupDto.groupId;
    }
    this._onDidChangeTabGroups.fire(Object.freeze({ changed: [group.apiObject], opened: [], closed: [] }));
  }
  $acceptTabOperation(operation) {
    const group = this._extHostTabGroups.find((group2) => group2.groupId === operation.groupId);
    if (!group) {
      throw new Error("Update Tabs IPC call received before group creation.");
    }
    const tab = group.acceptTabOperation(operation);
    switch (operation.kind) {
      case 0:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [tab.apiObject],
          closed: [],
          changed: []
        }));
        return;
      case 1:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [],
          closed: [tab.apiObject],
          changed: []
        }));
        return;
      case 3:
      case 2:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [],
          closed: [],
          changed: [tab.apiObject]
        }));
        return;
    }
  }
  _findExtHostTabFromApi(apiTab) {
    for (const group of this._extHostTabGroups) {
      for (const tab of group.tabs) {
        if (tab.apiObject === apiTab) {
          return tab;
        }
      }
    }
    return;
  }
  _findExtHostTabGroupFromApi(apiTabGroup) {
    return this._extHostTabGroups.find((candidate) => candidate.apiObject === apiTabGroup);
  }
  async _closeTabs(tabs, preserveFocus) {
    const extHostTabIds = [];
    for (const tab of tabs) {
      const extHostTab = this._findExtHostTabFromApi(tab);
      if (!extHostTab) {
        throw new Error("Tab close: Invalid tab not found!");
      }
      extHostTabIds.push(extHostTab.tabId);
    }
    return this._proxy.$closeTab(extHostTabIds, preserveFocus);
  }
  async _closeGroups(groups, preserverFoucs) {
    const extHostGroupIds = [];
    for (const group of groups) {
      const extHostGroup = this._findExtHostTabGroupFromApi(group);
      if (!extHostGroup) {
        throw new Error("Group close: Invalid group not found!");
      }
      extHostGroupIds.push(extHostGroup.groupId);
    }
    return this._proxy.$closeGroup(extHostGroupIds, preserverFoucs);
  }
};
ExtHostEditorTabs = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostEditorTabs);
function isTabGroup(obj) {
  const tabGroup = obj;
  if (tabGroup.tabs !== void 0) {
    return true;
  }
  return false;
}

// out-build/vs/workbench/api/common/extHostTesting.js
var followupCounter = 0;
var testResultInternalIDs = /* @__PURE__ */ new WeakMap();
var IExtHostTesting = createDecorator("IExtHostTesting");
var ExtHostTesting = class ExtHostTesting2 extends Disposable {
  constructor(rpc, logService, commands, editors) {
    super();
    this.logService = logService;
    this.commands = commands;
    this.editors = editors;
    this.resultsChangedEmitter = this._register(new Emitter());
    this.controllers = /* @__PURE__ */ new Map();
    this.defaultProfilesChangedEmitter = this._register(new Emitter());
    this.followupProviders = /* @__PURE__ */ new Set();
    this.testFollowups = /* @__PURE__ */ new Map();
    this.onResultsChanged = this.resultsChangedEmitter.event;
    this.results = [];
    this.proxy = rpc.getProxy(MainContext.MainThreadTesting);
    this.observer = new TestObservers(this.proxy);
    this.runTracker = new TestRunCoordinator(this.proxy, logService);
    commands.registerArgumentProcessor({
      processArgument: (arg) => {
        switch (arg?.$mid) {
          case 16: {
            const cast = arg;
            const targetTest = cast.tests[cast.tests.length - 1].item.extId;
            const controller = this.controllers.get(TestId.root(targetTest));
            return controller?.collection.tree.get(targetTest)?.actual ?? toItemFromContext(arg);
          }
          case 18: {
            const { test, message } = arg;
            const extId = test.item.extId;
            return {
              test: this.controllers.get(TestId.root(extId))?.collection.tree.get(extId)?.actual ?? toItemFromContext({ $mid: 16, tests: [test] }),
              message: TestMessage3.to(message)
            };
          }
          default:
            return arg;
        }
      }
    });
    commands.registerCommand(false, "testing.getExplorerSelection", async () => {
      const inner = await commands.executeCommand(
        "_testing.getExplorerSelection"
        /* TestCommandId.GetExplorerSelection */
      );
      const lookup = (i) => {
        const controller = this.controllers.get(TestId.root(i));
        if (!controller) {
          return void 0;
        }
        return TestId.isRoot(i) ? controller.controller : controller.collection.tree.get(i)?.actual;
      };
      return {
        include: inner?.include.map(lookup).filter(isDefined) || [],
        exclude: inner?.exclude.map(lookup).filter(isDefined) || []
      };
    });
  }
  //#region public API
  /**
   * Implements vscode.test.registerTestProvider
   */
  createTestController(extension, controllerId, label, refreshHandler) {
    if (this.controllers.has(controllerId)) {
      throw new Error(`Attempt to insert a duplicate controller with ID "${controllerId}"`);
    }
    const disposable = new DisposableStore();
    const collection = disposable.add(new ExtHostTestItemCollection(controllerId, label, this.editors));
    collection.root.label = label;
    const profiles = /* @__PURE__ */ new Map();
    const activeProfiles = /* @__PURE__ */ new Set();
    const proxy = this.proxy;
    const getCapability = () => {
      let cap = 0;
      if (refreshHandler) {
        cap |= 2;
      }
      const rcp = info.relatedCodeProvider;
      if (rcp) {
        if (rcp?.provideRelatedTests) {
          cap |= 8;
        }
        if (rcp?.provideRelatedCode) {
          cap |= 4;
        }
      }
      return cap;
    };
    const controller = {
      items: collection.root.children,
      get label() {
        return label;
      },
      set label(value) {
        label = value;
        collection.root.label = value;
        proxy.$updateController(controllerId, { label });
      },
      get refreshHandler() {
        return refreshHandler;
      },
      set refreshHandler(value) {
        refreshHandler = value;
        proxy.$updateController(controllerId, { capabilities: getCapability() });
      },
      get id() {
        return controllerId;
      },
      get relatedCodeProvider() {
        return info.relatedCodeProvider;
      },
      set relatedCodeProvider(value) {
        checkProposedApiEnabled(extension, "testRelatedCode");
        info.relatedCodeProvider = value;
        proxy.$updateController(controllerId, { capabilities: getCapability() });
      },
      createRunProfile: (label2, group, runHandler, isDefault, tag2, supportsContinuousRun) => {
        let profileId = hash(label2);
        while (profiles.has(profileId)) {
          profileId++;
        }
        return new TestRunProfileImpl(this.proxy, profiles, activeProfiles, this.defaultProfilesChangedEmitter.event, controllerId, profileId, label2, group, runHandler, isDefault, tag2, supportsContinuousRun);
      },
      createTestItem(id2, label2, uri) {
        return new TestItemImpl(controllerId, id2, label2, uri);
      },
      createTestRun: (request, name2, persist = true) => {
        return this.runTracker.createTestRun(extension, controllerId, collection, request, name2, persist);
      },
      invalidateTestResults: (items) => {
        if (items === void 0) {
          this.proxy.$markTestRetired(void 0);
        } else {
          const itemsArr = items instanceof Array ? items : [items];
          this.proxy.$markTestRetired(itemsArr.map((i) => TestId.fromExtHostTestItem(i, controllerId).toString()));
        }
      },
      set resolveHandler(fn) {
        collection.resolveHandler = fn;
      },
      get resolveHandler() {
        return collection.resolveHandler;
      },
      dispose: () => {
        disposable.dispose();
      }
    };
    const info = { controller, collection, profiles, extension, activeProfiles };
    proxy.$registerTestController(controllerId, label, getCapability());
    disposable.add(toDisposable(() => proxy.$unregisterTestController(controllerId)));
    this.controllers.set(controllerId, info);
    disposable.add(toDisposable(() => this.controllers.delete(controllerId)));
    disposable.add(collection.onDidGenerateDiff((diff2) => proxy.$publishDiff(controllerId, diff2.map(TestsDiffOp.serialize))));
    return controller;
  }
  /**
   * Implements vscode.test.createTestObserver
   */
  createTestObserver() {
    return this.observer.checkout();
  }
  /**
   * Implements vscode.test.runTests
   */
  async runTests(req, token = CancellationToken.None) {
    const profile = tryGetProfileFromTestRunReq(req);
    if (!profile) {
      throw new Error("The request passed to `vscode.test.runTests` must include a profile");
    }
    const controller = this.controllers.get(profile.controllerId);
    if (!controller) {
      throw new Error("Controller not found");
    }
    await this.proxy.$runTests({
      preserveFocus: req.preserveFocus ?? true,
      group: TestRunProfileKind2.from(profile.kind),
      targets: [{
        testIds: req.include?.map((t) => TestId.fromExtHostTestItem(t, controller.collection.root.id).toString()) ?? [controller.collection.root.id],
        profileId: profile.profileId,
        controllerId: profile.controllerId
      }],
      exclude: req.exclude?.map((t) => t.id)
    }, token);
  }
  /**
   * Implements vscode.test.registerTestFollowupProvider
   */
  registerTestFollowupProvider(provider) {
    this.followupProviders.add(provider);
    return { dispose: () => {
      this.followupProviders.delete(provider);
    } };
  }
  //#endregion
  //#region RPC methods
  /**
   * @inheritdoc
   */
  async $getTestsRelatedToCode(uri, _position, token) {
    const doc = this.editors.getDocument(URI.revive(uri));
    if (!doc) {
      return [];
    }
    const position = Position4.to(_position);
    const related = [];
    await Promise.all([...this.controllers.values()].map(async (c) => {
      let tests;
      try {
        tests = await c.relatedCodeProvider?.provideRelatedTests?.(doc.document, position, token);
      } catch (e) {
        if (!token.isCancellationRequested) {
          this.logService.warn(`Error thrown while providing related tests for ${c.controller.label}`, e);
        }
      }
      if (tests) {
        for (const test of tests) {
          related.push(TestId.fromExtHostTestItem(test, c.controller.id).toString());
        }
        c.collection.flushDiff();
      }
    }));
    return related;
  }
  /**
   * @inheritdoc
   */
  async $getCodeRelatedToTest(testId, token) {
    const controller = this.controllers.get(TestId.root(testId));
    if (!controller) {
      return [];
    }
    const test = controller.collection.tree.get(testId);
    if (!test) {
      return [];
    }
    const locations = await controller.relatedCodeProvider?.provideRelatedCode?.(test.actual, token);
    return locations?.map(location.from) ?? [];
  }
  /**
   * @inheritdoc
   */
  $syncTests() {
    for (const { collection } of this.controllers.values()) {
      collection.flushDiff();
    }
    return Promise.resolve();
  }
  /**
   * @inheritdoc
   */
  async $getCoverageDetails(coverageId, testId, token) {
    const details = await this.runTracker.getCoverageDetails(coverageId, testId, token);
    return details?.map(TestCoverage.fromDetails);
  }
  /**
   * @inheritdoc
   */
  async $disposeRun(runId) {
    this.runTracker.disposeTestRun(runId);
  }
  /** @inheritdoc */
  $configureRunProfile(controllerId, profileId) {
    this.controllers.get(controllerId)?.profiles.get(profileId)?.configureHandler?.();
  }
  /** @inheritdoc */
  $setDefaultRunProfiles(profiles) {
    const evt = /* @__PURE__ */ new Map();
    for (const [controllerId, profileIds] of Object.entries(profiles)) {
      const ctrl = this.controllers.get(controllerId);
      if (!ctrl) {
        continue;
      }
      const changes = /* @__PURE__ */ new Map();
      const added = profileIds.filter((id2) => !ctrl.activeProfiles.has(id2));
      const removed = [...ctrl.activeProfiles].filter((id2) => !profileIds.includes(id2));
      for (const id2 of added) {
        changes.set(id2, true);
        ctrl.activeProfiles.add(id2);
      }
      for (const id2 of removed) {
        changes.set(id2, false);
        ctrl.activeProfiles.delete(id2);
      }
      if (changes.size) {
        evt.set(controllerId, changes);
      }
    }
    this.defaultProfilesChangedEmitter.fire(evt);
  }
  /** @inheritdoc */
  async $refreshTests(controllerId, token) {
    await this.controllers.get(controllerId)?.controller.refreshHandler?.(token);
  }
  /**
   * Updates test results shown to extensions.
   * @override
   */
  $publishTestResults(results) {
    this.results = Object.freeze(results.map((r) => {
      const o = TestResults.to(r);
      const taskWithCoverage = r.tasks.findIndex((t) => t.hasCoverage);
      if (taskWithCoverage !== -1) {
        o.getDetailedCoverage = (uri, token = CancellationToken.None) => this.proxy.$getCoverageDetails(r.id, taskWithCoverage, uri, token).then((r2) => r2.map(TestCoverage.to));
      }
      testResultInternalIDs.set(o, r.id);
      return o;
    }).concat(this.results).sort((a, b) => b.completedAt - a.completedAt).slice(0, 32));
    this.resultsChangedEmitter.fire();
  }
  /**
   * Expands the nodes in the test tree. If levels is less than zero, it will
   * be treated as infinite.
   */
  async $expandTest(testId, levels) {
    const collection = this.controllers.get(TestId.fromString(testId).controllerId)?.collection;
    if (collection) {
      await collection.expand(testId, levels < 0 ? Infinity : levels);
      collection.flushDiff();
    }
  }
  /**
   * Receives a test update from the main thread. Called (eventually) whenever
   * tests change.
   */
  $acceptDiff(diff2) {
    this.observer.applyDiff(diff2.map((d) => TestsDiffOp.deserialize({ asCanonicalUri: (u) => u }, d)));
  }
  /**
   * Runs tests with the given set of IDs. Allows for test from multiple
   * providers to be run.
   * @inheritdoc
   */
  async $runControllerTests(reqs, token) {
    return Promise.all(reqs.map((req) => this.runControllerTestRequest(req, false, token)));
  }
  /**
   * Starts continuous test runs with the given set of IDs. Allows for test from
   * multiple providers to be run.
   * @inheritdoc
   */
  async $startContinuousRun(reqs, token) {
    const cts = new CancellationTokenSource(token);
    const res = await Promise.all(reqs.map((req) => this.runControllerTestRequest(req, true, cts.token)));
    if (!token.isCancellationRequested && !res.some((r) => r.error)) {
      await new Promise((r) => token.onCancellationRequested(r));
    }
    cts.dispose(true);
    return res;
  }
  /** @inheritdoc */
  async $provideTestFollowups(req, token) {
    const results = this.results.find((r) => testResultInternalIDs.get(r) === req.resultId);
    const test = results && findTestInResultSnapshot(TestId.fromString(req.extId), results?.results);
    if (!test) {
      return [];
    }
    let followups = [];
    await Promise.all([...this.followupProviders].map(async (provider) => {
      try {
        const r = await provider.provideFollowup(results, test, req.taskIndex, req.messageIndex, token);
        if (r) {
          followups = followups.concat(r);
        }
      } catch (e) {
        this.logService.error(`Error thrown while providing followup for test message`, e);
      }
    }));
    if (token.isCancellationRequested) {
      return [];
    }
    return followups.map((command) => {
      const id2 = followupCounter++;
      this.testFollowups.set(id2, command);
      return { title: command.title, id: id2 };
    });
  }
  $disposeTestFollowups(id2) {
    for (const i of id2) {
      this.testFollowups.delete(i);
    }
  }
  $executeTestFollowup(id2) {
    const command = this.testFollowups.get(id2);
    if (!command) {
      return Promise.resolve();
    }
    return this.commands.executeCommand(command.command, ...command.arguments || []);
  }
  /**
   * Cancels an ongoing test run.
   */
  $cancelExtensionTestRun(runId, taskId) {
    if (runId === void 0) {
      this.runTracker.cancelAllRuns();
    } else {
      this.runTracker.cancelRunById(runId, taskId);
    }
  }
  //#endregion
  getMetadataForRun(run) {
    for (const tracker of this.runTracker.trackers) {
      const taskId = tracker.getTaskIdForRun(run);
      if (taskId) {
        return { taskId, runId: tracker.id };
      }
    }
    return void 0;
  }
  async runControllerTestRequest(req, isContinuous, token) {
    const lookup = this.controllers.get(req.controllerId);
    if (!lookup) {
      return {};
    }
    const { collection, profiles, extension } = lookup;
    const profile = profiles.get(req.profileId);
    if (!profile) {
      return {};
    }
    const includeTests = req.testIds.map((testId) => collection.tree.get(testId)).filter(isDefined);
    const excludeTests = req.excludeExtIds.map((id2) => lookup.collection.tree.get(id2)).filter(isDefined).filter((exclude) => includeTests.some(
      (include) => include.fullId.compare(exclude.fullId) === 2
      /* TestPosition.IsChild */
    ));
    if (!includeTests.length) {
      return {};
    }
    const publicReq = new TestRunRequest(includeTests.some((i) => i.actual instanceof TestItemRootImpl) ? void 0 : includeTests.map((t) => t.actual), excludeTests.map((t) => t.actual), profile, isContinuous);
    const tracker = isStartControllerTests(req) && this.runTracker.prepareForMainThreadTestRun(extension, publicReq, TestRunDto.fromInternal(req, lookup.collection), profile, token);
    try {
      await profile.runHandler(publicReq, token);
      return {};
    } catch (e) {
      return { error: String(e) };
    } finally {
      if (tracker) {
        if (tracker.hasRunningTasks && !token.isCancellationRequested) {
          await Event.toPromise(tracker.onEnd);
        }
      }
    }
  }
};
ExtHostTesting = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService),
  __param(2, IExtHostCommands),
  __param(3, IExtHostDocumentsAndEditors)
], ExtHostTesting);
var RUN_CANCEL_DEADLINE = 1e4;
var TestRunTrackerState;
(function(TestRunTrackerState2) {
  TestRunTrackerState2[TestRunTrackerState2["Running"] = 0] = "Running";
  TestRunTrackerState2[TestRunTrackerState2["Cancelling"] = 1] = "Cancelling";
  TestRunTrackerState2[TestRunTrackerState2["Ended"] = 2] = "Ended";
})(TestRunTrackerState || (TestRunTrackerState = {}));
var TestRunTracker = class extends Disposable {
  /**
   * Gets whether there are any tests running.
   */
  get hasRunningTasks() {
    return this.running > 0;
  }
  /**
   * Gets the run ID.
   */
  get id() {
    return this.dto.id;
  }
  constructor(dto, proxy, logService, profile, extension, parentToken) {
    super();
    this.dto = dto;
    this.proxy = proxy;
    this.logService = logService;
    this.profile = profile;
    this.extension = extension;
    this.state = 0;
    this.running = 0;
    this.tasks = /* @__PURE__ */ new Map();
    this.sharedTestIds = /* @__PURE__ */ new Set();
    this.endEmitter = this._register(new Emitter());
    this.publishedCoverage = /* @__PURE__ */ new Map();
    this.onEnd = this.endEmitter.event;
    this.cts = this._register(new CancellationTokenSource(parentToken));
    const forciblyEnd = this._register(new RunOnceScheduler(() => this.forciblyEndTasks(), RUN_CANCEL_DEADLINE));
    this._register(this.cts.token.onCancellationRequested(() => forciblyEnd.schedule()));
    const didDisposeEmitter = new Emitter();
    this.onDidDispose = didDisposeEmitter.event;
    this._register(toDisposable(() => {
      didDisposeEmitter.fire();
      didDisposeEmitter.dispose();
    }));
  }
  /** Gets the task ID from a test run object. */
  getTaskIdForRun(run) {
    for (const [taskId, { run: r }] of this.tasks) {
      if (r === run) {
        return taskId;
      }
    }
    return void 0;
  }
  /** Requests cancellation of the run. On the second call, forces cancellation. */
  cancel(taskId) {
    if (taskId) {
      this.tasks.get(taskId)?.cts.cancel();
    } else if (this.state === 0) {
      this.cts.cancel();
      this.state = 1;
    } else if (this.state === 1) {
      this.forciblyEndTasks();
    }
  }
  /** Gets details for a previously-emitted coverage object. */
  async getCoverageDetails(id2, testId, token) {
    const [, taskId] = TestId.fromString(id2).path;
    const coverage = this.publishedCoverage.get(id2);
    if (!coverage) {
      return [];
    }
    const { report, extIds } = coverage;
    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error("unreachable: run task was not found");
    }
    let testItem;
    if (testId && report instanceof FileCoverage) {
      const index = extIds.indexOf(testId);
      if (index === -1) {
        return [];
      }
      testItem = report.includesTests[index];
    }
    const details = testItem ? this.profile?.loadDetailedCoverageForTest?.(task.run, report, testItem, token) : this.profile?.loadDetailedCoverage?.(task.run, report, token);
    return await details ?? [];
  }
  /** Creates the public test run interface to give to extensions. */
  createRun(name2) {
    const runId = this.dto.id;
    const ctrlId = this.dto.controllerId;
    const taskId = generateUuid();
    const guardTestMutation = (fn) => (test, ...args) => {
      if (ended) {
        this.logService.warn(`Setting the state of test "${test.id}" is a no-op after the run ends.`);
        return;
      }
      this.ensureTestIsKnown(test);
      fn(test, ...args);
    };
    const appendMessages = (test, messages) => {
      const converted = messages instanceof Array ? messages.map(TestMessage3.from) : [TestMessage3.from(messages)];
      if (test.uri && test.range) {
        const defaultLocation = { range: Range4.from(test.range), uri: test.uri };
        for (const message of converted) {
          message.location = message.location || defaultLocation;
        }
      }
      this.proxy.$appendTestMessagesInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), converted);
    };
    let ended = false;
    const cts = this._register(new CancellationTokenSource(this.cts.token));
    const run = {
      isPersisted: this.dto.isPersisted,
      token: cts.token,
      name: name2,
      onDidDispose: this.onDidDispose,
      addCoverage: (coverage) => {
        if (ended) {
          return;
        }
        const includesTests = coverage instanceof FileCoverage ? coverage.includesTests : [];
        if (includesTests.length) {
          for (const test of includesTests) {
            this.ensureTestIsKnown(test);
          }
        }
        const uriStr = coverage.uri.toString();
        const id2 = new TestId([runId, taskId, uriStr]).toString();
        this.publishedCoverage.set(id2, { report: coverage, extIds: includesTests.map((t) => TestId.fromExtHostTestItem(t, ctrlId).toString()) });
        this.proxy.$appendCoverage(runId, taskId, TestCoverage.fromFile(ctrlId, id2, coverage));
      },
      //#region state mutation
      enqueued: guardTestMutation((test) => {
        this.proxy.$updateTestStateInRun(
          runId,
          taskId,
          TestId.fromExtHostTestItem(test, ctrlId).toString(),
          1
          /* TestResultState.Queued */
        );
      }),
      skipped: guardTestMutation((test) => {
        this.proxy.$updateTestStateInRun(
          runId,
          taskId,
          TestId.fromExtHostTestItem(test, ctrlId).toString(),
          5
          /* TestResultState.Skipped */
        );
      }),
      started: guardTestMutation((test) => {
        this.proxy.$updateTestStateInRun(
          runId,
          taskId,
          TestId.fromExtHostTestItem(test, ctrlId).toString(),
          2
          /* TestResultState.Running */
        );
      }),
      errored: guardTestMutation((test, messages, duration) => {
        appendMessages(test, messages);
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), 6, duration);
      }),
      failed: guardTestMutation((test, messages, duration) => {
        appendMessages(test, messages);
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), 4, duration);
      }),
      passed: guardTestMutation((test, duration) => {
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, this.dto.controllerId).toString(), 3, duration);
      }),
      //#endregion
      appendOutput: (output, location2, test) => {
        if (ended) {
          return;
        }
        if (test) {
          this.ensureTestIsKnown(test);
        }
        this.proxy.$appendOutputToRun(runId, taskId, VSBuffer.fromString(output), location2 && location.from(location2), test && TestId.fromExtHostTestItem(test, ctrlId).toString());
      },
      end: () => {
        if (ended) {
          return;
        }
        ended = true;
        this.proxy.$finishedTestRunTask(runId, taskId);
        if (!--this.running) {
          this.markEnded();
        }
      }
    };
    this.running++;
    this.tasks.set(taskId, { run, cts });
    this.proxy.$startedTestRunTask(runId, {
      id: taskId,
      ctrlId: this.dto.controllerId,
      name: name2 || this.extension.displayName || this.extension.identifier.value,
      running: true
    });
    return run;
  }
  forciblyEndTasks() {
    for (const { run } of this.tasks.values()) {
      run.end();
    }
  }
  markEnded() {
    if (this.state !== 2) {
      this.state = 2;
      this.endEmitter.fire();
    }
  }
  ensureTestIsKnown(test) {
    if (!(test instanceof TestItemImpl)) {
      throw new InvalidTestItemError(test.id);
    }
    if (this.sharedTestIds.has(TestId.fromExtHostTestItem(test, this.dto.controllerId).toString())) {
      return;
    }
    const chain = [];
    const root = this.dto.colllection.root;
    while (true) {
      const converted = TestItem.from(test);
      chain.unshift(converted);
      if (this.sharedTestIds.has(converted.extId)) {
        break;
      }
      this.sharedTestIds.add(converted.extId);
      if (test === root) {
        break;
      }
      test = test.parent || root;
    }
    this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, chain);
  }
  dispose() {
    this.markEnded();
    super.dispose();
  }
};
var TestRunCoordinator = class {
  get trackers() {
    return this.tracked.values();
  }
  constructor(proxy, logService) {
    this.proxy = proxy;
    this.logService = logService;
    this.tracked = /* @__PURE__ */ new Map();
    this.trackedById = /* @__PURE__ */ new Map();
  }
  /**
   * Gets a coverage report for a given run and task ID.
   */
  getCoverageDetails(id2, testId, token) {
    const runId = TestId.root(id2);
    return this.trackedById.get(runId)?.getCoverageDetails(id2, testId, token) || [];
  }
  /**
   * Disposes the test run, called when the main thread is no longer interested
   * in associated data.
   */
  disposeTestRun(runId) {
    this.trackedById.get(runId)?.dispose();
    this.trackedById.delete(runId);
    for (const [req, { id: id2 }] of this.tracked) {
      if (id2 === runId) {
        this.tracked.delete(req);
      }
    }
  }
  /**
   * Registers a request as being invoked by the main thread, so
   * `$startedExtensionTestRun` is not invoked. The run must eventually
   * be cancelled manually.
   */
  prepareForMainThreadTestRun(extension, req, dto, profile, token) {
    return this.getTracker(req, dto, profile, extension, token);
  }
  /**
   * Cancels an existing test run via its cancellation token.
   */
  cancelRunById(runId, taskId) {
    this.trackedById.get(runId)?.cancel(taskId);
  }
  /**
   * Cancels an existing test run via its cancellation token.
   */
  cancelAllRuns() {
    for (const tracker of this.tracked.values()) {
      tracker.cancel();
    }
  }
  /**
   * Implements the public `createTestRun` API.
   */
  createTestRun(extension, controllerId, collection, request, name2, persist) {
    const existing = this.tracked.get(request);
    if (existing) {
      return existing.createRun(name2);
    }
    const dto = TestRunDto.fromPublic(controllerId, collection, request, persist);
    const profile = tryGetProfileFromTestRunReq(request);
    this.proxy.$startedExtensionTestRun({
      controllerId,
      continuous: !!request.continuous,
      profile: profile && { group: TestRunProfileKind2.from(profile.kind), id: profile.profileId },
      exclude: request.exclude?.map((t) => TestId.fromExtHostTestItem(t, collection.root.id).toString()) ?? [],
      id: dto.id,
      include: request.include?.map((t) => TestId.fromExtHostTestItem(t, collection.root.id).toString()) ?? [collection.root.id],
      preserveFocus: request.preserveFocus ?? true,
      persist
    });
    const tracker = this.getTracker(request, dto, request.profile, extension);
    Event.once(tracker.onEnd)(() => {
      this.proxy.$finishedExtensionTestRun(dto.id);
    });
    return tracker.createRun(name2);
  }
  getTracker(req, dto, profile, extension, token) {
    const tracker = new TestRunTracker(dto, this.proxy, this.logService, profile, extension, token);
    this.tracked.set(req, tracker);
    this.trackedById.set(tracker.id, tracker);
    return tracker;
  }
};
var tryGetProfileFromTestRunReq = (request) => {
  if (!request.profile) {
    return void 0;
  }
  if (!(request.profile instanceof TestRunProfileImpl)) {
    throw new Error(`TestRunRequest.profile is not an instance created from TestController.createRunProfile`);
  }
  return request.profile;
};
var TestRunDto = class _TestRunDto {
  static fromPublic(controllerId, collection, request, persist) {
    return new _TestRunDto(controllerId, generateUuid(), persist, collection);
  }
  static fromInternal(request, collection) {
    return new _TestRunDto(request.controllerId, request.runId, true, collection);
  }
  constructor(controllerId, id2, isPersisted, colllection) {
    this.controllerId = controllerId;
    this.id = id2;
    this.isPersisted = isPersisted;
    this.colllection = colllection;
  }
};
var MirroredChangeCollector = class {
  get isEmpty() {
    return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;
  }
  constructor(emitter) {
    this.emitter = emitter;
    this.added = /* @__PURE__ */ new Set();
    this.updated = /* @__PURE__ */ new Set();
    this.removed = /* @__PURE__ */ new Set();
    this.alreadyRemoved = /* @__PURE__ */ new Set();
  }
  /**
   * @inheritdoc
   */
  add(node) {
    this.added.add(node);
  }
  /**
   * @inheritdoc
   */
  update(node) {
    Object.assign(node.revived, TestItem.toPlain(node.item));
    if (!this.added.has(node)) {
      this.updated.add(node);
    }
  }
  /**
   * @inheritdoc
   */
  remove(node) {
    if (this.added.has(node)) {
      this.added.delete(node);
      return;
    }
    this.updated.delete(node);
    const parentId = TestId.parentId(node.item.extId);
    if (parentId && this.alreadyRemoved.has(parentId.toString())) {
      this.alreadyRemoved.add(node.item.extId);
      return;
    }
    this.removed.add(node);
  }
  /**
   * @inheritdoc
   */
  getChangeEvent() {
    const { added, updated, removed } = this;
    return {
      get added() {
        return [...added].map((n) => n.revived);
      },
      get updated() {
        return [...updated].map((n) => n.revived);
      },
      get removed() {
        return [...removed].map((n) => n.revived);
      }
    };
  }
  complete() {
    if (!this.isEmpty) {
      this.emitter.fire(this.getChangeEvent());
    }
  }
};
var MirroredTestCollection = class extends AbstractIncrementalTestCollection {
  constructor() {
    super(...arguments);
    this.changeEmitter = new Emitter();
    this.onDidChangeTests = this.changeEmitter.event;
  }
  /**
   * Gets a list of root test items.
   */
  get rootTests() {
    return this.roots;
  }
  /**
   *
   * If the test ID exists, returns its underlying ID.
   */
  getMirroredTestDataById(itemId) {
    return this.items.get(itemId);
  }
  /**
   * If the test item is a mirrored test item, returns its underlying ID.
   */
  getMirroredTestDataByReference(item) {
    return this.items.get(item.id);
  }
  /**
   * @override
   */
  createItem(item, parent) {
    return {
      ...item,
      // todo@connor4312: make this work well again with children
      revived: TestItem.toPlain(item.item),
      depth: parent ? parent.depth + 1 : 0,
      children: /* @__PURE__ */ new Set()
    };
  }
  /**
   * @override
   */
  createChangeCollector() {
    return new MirroredChangeCollector(this.changeEmitter);
  }
};
var TestObservers = class {
  constructor(proxy) {
    this.proxy = proxy;
  }
  checkout() {
    if (!this.current) {
      this.current = this.createObserverData();
    }
    const current = this.current;
    current.observers++;
    return {
      onDidChangeTest: current.tests.onDidChangeTests,
      get tests() {
        return [...current.tests.rootTests].map((t) => t.revived);
      },
      dispose: createSingleCallFunction(() => {
        if (--current.observers === 0) {
          this.proxy.$unsubscribeFromDiffs();
          this.current = void 0;
        }
      })
    };
  }
  /**
   * Gets the internal test data by its reference.
   */
  getMirroredTestDataByReference(ref) {
    return this.current?.tests.getMirroredTestDataByReference(ref);
  }
  /**
   * Applies test diffs to the current set of observed tests.
   */
  applyDiff(diff2) {
    this.current?.tests.apply(diff2);
  }
  createObserverData() {
    const tests = new MirroredTestCollection({ asCanonicalUri: (u) => u });
    this.proxy.$subscribeToDiffs();
    return { observers: 0, tests };
  }
};
var updateProfile = (impl, proxy, initial, update) => {
  if (initial) {
    Object.assign(initial, update);
  } else {
    proxy.$updateTestRunConfig(impl.controllerId, impl.profileId, update);
  }
};
var TestRunProfileImpl = class extends TestRunProfileBase {
  #proxy;
  #activeProfiles;
  #onDidChangeDefaultProfiles;
  #initialPublish;
  #profiles;
  get label() {
    return this._label;
  }
  set label(label) {
    if (label !== this._label) {
      this._label = label;
      updateProfile(this, this.#proxy, this.#initialPublish, { label });
    }
  }
  get supportsContinuousRun() {
    return this._supportsContinuousRun;
  }
  set supportsContinuousRun(supports) {
    if (supports !== this._supportsContinuousRun) {
      this._supportsContinuousRun = supports;
      updateProfile(this, this.#proxy, this.#initialPublish, { supportsContinuousRun: supports });
    }
  }
  get isDefault() {
    return this.#activeProfiles.has(this.profileId);
  }
  set isDefault(isDefault) {
    if (isDefault !== this.isDefault) {
      if (isDefault) {
        this.#activeProfiles.add(this.profileId);
      } else {
        this.#activeProfiles.delete(this.profileId);
      }
      updateProfile(this, this.#proxy, this.#initialPublish, { isDefault });
    }
  }
  get tag() {
    return this._tag;
  }
  set tag(tag2) {
    if (tag2?.id !== this._tag?.id) {
      this._tag = tag2;
      updateProfile(this, this.#proxy, this.#initialPublish, {
        tag: tag2 ? TestTag3.namespace(this.controllerId, tag2.id) : null
      });
    }
  }
  get configureHandler() {
    return this._configureHandler;
  }
  set configureHandler(handler) {
    if (handler !== this._configureHandler) {
      this._configureHandler = handler;
      updateProfile(this, this.#proxy, this.#initialPublish, { hasConfigurationHandler: !!handler });
    }
  }
  get onDidChangeDefault() {
    return Event.chain(this.#onDidChangeDefaultProfiles, ($) => $.map((ev) => ev.get(this.controllerId)?.get(this.profileId)).filter(isDefined));
  }
  constructor(proxy, profiles, activeProfiles, onDidChangeActiveProfiles, controllerId, profileId, _label, kind, runHandler, _isDefault = false, _tag2 = void 0, _supportsContinuousRun = false) {
    super(controllerId, profileId, kind);
    this._label = _label;
    this.runHandler = runHandler;
    this._tag = _tag2;
    this._supportsContinuousRun = _supportsContinuousRun;
    this.#proxy = proxy;
    this.#profiles = profiles;
    this.#activeProfiles = activeProfiles;
    this.#onDidChangeDefaultProfiles = onDidChangeActiveProfiles;
    profiles.set(profileId, this);
    const groupBitset = TestRunProfileKind2.from(kind);
    if (_isDefault) {
      activeProfiles.add(profileId);
    }
    this.#initialPublish = {
      profileId,
      controllerId,
      tag: _tag2 ? TestTag3.namespace(this.controllerId, _tag2.id) : null,
      label: _label,
      group: groupBitset,
      isDefault: _isDefault,
      hasConfigurationHandler: false,
      supportsContinuousRun: _supportsContinuousRun
    };
    queueMicrotask(() => {
      if (this.#initialPublish) {
        this.#proxy.$publishTestRunProfile(this.#initialPublish);
        this.#initialPublish = void 0;
      }
    });
  }
  dispose() {
    if (this.#profiles?.delete(this.profileId)) {
      this.#profiles = void 0;
      this.#proxy.$removeTestProfile(this.controllerId, this.profileId);
    }
    this.#initialPublish = void 0;
  }
};
function findTestInResultSnapshot(extId, snapshot) {
  for (let i = 0; i < extId.path.length; i++) {
    const item = snapshot.find((s) => s.id === extId.path[i]);
    if (!item) {
      return void 0;
    }
    if (i === extId.path.length - 1) {
      return item;
    }
    snapshot = item.children;
  }
  return void 0;
}

// out-build/vs/workbench/services/configurationResolver/common/configurationResolver.js
var IConfigurationResolverService = createDecorator("configurationResolverService");
var VariableKind;
(function(VariableKind2) {
  VariableKind2["Unknown"] = "unknown";
  VariableKind2["Env"] = "env";
  VariableKind2["Config"] = "config";
  VariableKind2["Command"] = "command";
  VariableKind2["Input"] = "input";
  VariableKind2["ExtensionInstallFolder"] = "extensionInstallFolder";
  VariableKind2["WorkspaceFolder"] = "workspaceFolder";
  VariableKind2["Cwd"] = "cwd";
  VariableKind2["WorkspaceFolderBasename"] = "workspaceFolderBasename";
  VariableKind2["UserHome"] = "userHome";
  VariableKind2["LineNumber"] = "lineNumber";
  VariableKind2["ColumnNumber"] = "columnNumber";
  VariableKind2["SelectedText"] = "selectedText";
  VariableKind2["File"] = "file";
  VariableKind2["FileWorkspaceFolder"] = "fileWorkspaceFolder";
  VariableKind2["FileWorkspaceFolderBasename"] = "fileWorkspaceFolderBasename";
  VariableKind2["RelativeFile"] = "relativeFile";
  VariableKind2["RelativeFileDirname"] = "relativeFileDirname";
  VariableKind2["FileDirname"] = "fileDirname";
  VariableKind2["FileExtname"] = "fileExtname";
  VariableKind2["FileBasename"] = "fileBasename";
  VariableKind2["FileBasenameNoExtension"] = "fileBasenameNoExtension";
  VariableKind2["FileDirnameBasename"] = "fileDirnameBasename";
  VariableKind2["ExecPath"] = "execPath";
  VariableKind2["ExecInstallFolder"] = "execInstallFolder";
  VariableKind2["PathSeparator"] = "pathSeparator";
  VariableKind2["PathSeparatorAlias"] = "/";
})(VariableKind || (VariableKind = {}));
var allVariableKinds = Object.values(VariableKind).filter((value) => typeof value === "string");
var VariableError = class extends ErrorNoTelemetry {
  constructor(variable, message) {
    super(message);
    this.variable = variable;
  }
};

// out-build/vs/workbench/services/configurationResolver/common/configurationResolverExpression.js
var ConfigurationResolverExpression = class _ConfigurationResolverExpression {
  static {
    this.VARIABLE_LHS = "${";
  }
  constructor(object) {
    this.locations = /* @__PURE__ */ new Map();
    this.newReplacementNotifiers = /* @__PURE__ */ new Set();
    if (typeof object === "string") {
      this.stringRoot = true;
      this.root = { value: object };
    } else {
      this.stringRoot = false;
      this.root = structuredClone(object);
    }
  }
  /**
   * Creates a new {@link ConfigurationResolverExpression} from an object.
   * Note that platform-specific keys (i.e. `windows`, `osx`, `linux`) are
   * applied during parsing.
   */
  static parse(object) {
    if (object instanceof _ConfigurationResolverExpression) {
      return object;
    }
    const expr = new _ConfigurationResolverExpression(object);
    expr.applyPlatformSpecificKeys();
    expr.parseObject(expr.root);
    return expr;
  }
  applyPlatformSpecificKeys() {
    const config = this.root;
    const key = isWindows ? "windows" : isMacintosh ? "osx" : isLinux ? "linux" : void 0;
    if (key && config && typeof config === "object" && config.hasOwnProperty(key)) {
      Object.keys(config[key]).forEach((k) => config[k] = config[key][k]);
    }
    delete config.windows;
    delete config.osx;
    delete config.linux;
  }
  parseVariable(str, start) {
    if (str[start] !== "$" || str[start + 1] !== "{") {
      return void 0;
    }
    let end = start + 2;
    let braceCount = 1;
    while (end < str.length) {
      if (str[end] === "{") {
        braceCount++;
      } else if (str[end] === "}") {
        braceCount--;
        if (braceCount === 0) {
          break;
        }
      }
      end++;
    }
    if (braceCount !== 0) {
      return void 0;
    }
    const id2 = str.slice(start, end + 1);
    const inner = str.substring(start + 2, end);
    const colonIdx = inner.indexOf(":");
    if (colonIdx === -1) {
      return { replacement: { id: id2, name: inner, inner }, end };
    }
    return {
      replacement: {
        id: id2,
        inner,
        name: inner.slice(0, colonIdx),
        arg: inner.slice(colonIdx + 1)
      },
      end
    };
  }
  parseObject(obj) {
    if (typeof obj !== "object" || obj === null) {
      return;
    }
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; i++) {
        const value = obj[i];
        if (typeof value === "string") {
          this.parseString(obj, i, value);
        } else {
          this.parseObject(value);
        }
      }
      return;
    }
    for (const [key, value] of Object.entries(obj)) {
      this.parseString(obj, key, key, true);
      if (typeof value === "string") {
        this.parseString(obj, key, value);
      } else {
        this.parseObject(value);
      }
    }
  }
  parseString(object, propertyName, value, replaceKeyName, replacementPath) {
    let pos = 0;
    while (pos < value.length) {
      const match2 = value.indexOf("${", pos);
      if (match2 === -1) {
        break;
      }
      const parsed = this.parseVariable(value, match2);
      if (parsed) {
        pos = parsed.end + 1;
        if (replacementPath?.includes(parsed.replacement.id)) {
          continue;
        }
        const locations = this.locations.get(parsed.replacement.id) || { locations: [], replacement: parsed.replacement };
        const newLocation = { object, propertyName, replaceKeyName };
        locations.locations.push(newLocation);
        this.locations.set(parsed.replacement.id, locations);
        if (locations.resolved) {
          this._resolveAtLocation(parsed.replacement, newLocation, locations.resolved, replacementPath);
        } else {
          this.newReplacementNotifiers.forEach((n) => n(parsed.replacement));
        }
      } else {
        pos = match2 + 2;
      }
    }
  }
  *unresolved() {
    const newReplacements = /* @__PURE__ */ new Map();
    const notifier = (replacement) => {
      newReplacements.set(replacement.id, replacement);
    };
    for (const location2 of this.locations.values()) {
      if (location2.resolved === void 0) {
        newReplacements.set(location2.replacement.id, location2.replacement);
      }
    }
    this.newReplacementNotifiers.add(notifier);
    while (true) {
      const next = Iterable.first(newReplacements);
      if (!next) {
        break;
      }
      const [key, value] = next;
      yield value;
      newReplacements.delete(key);
    }
    this.newReplacementNotifiers.delete(notifier);
  }
  resolved() {
    return Iterable.map(Iterable.filter(this.locations.values(), (l) => !!l.resolved), (l) => [l.replacement, l.resolved]);
  }
  resolve(replacement, data2) {
    if (typeof data2 !== "object") {
      data2 = { value: String(data2) };
    }
    const location2 = this.locations.get(replacement.id);
    if (!location2) {
      return;
    }
    location2.resolved = data2;
    if (data2.value !== void 0) {
      for (const l of location2.locations || Iterable.empty()) {
        this._resolveAtLocation(replacement, l, data2);
      }
    }
  }
  _resolveAtLocation(replacement, { replaceKeyName, propertyName, object }, data2, path = []) {
    if (data2.value === void 0) {
      return;
    }
    path.push(replacement.id);
    if (replaceKeyName && typeof propertyName === "string") {
      const value = object[propertyName];
      const newKey = propertyName.replaceAll(replacement.id, data2.value);
      delete object[propertyName];
      object[newKey] = value;
      this._renameKeyInLocations(object, propertyName, newKey);
      this.parseString(object, newKey, data2.value, true, path);
    } else {
      object[propertyName] = object[propertyName].replaceAll(replacement.id, data2.value);
      this.parseString(object, propertyName, data2.value, false, path);
    }
    path.pop();
  }
  _renameKeyInLocations(obj, oldKey, newKey) {
    for (const location2 of this.locations.values()) {
      for (const loc of location2.locations) {
        if (loc.object === obj && loc.propertyName === oldKey) {
          loc.propertyName = newKey;
        }
      }
    }
  }
  toObject() {
    if (this.stringRoot) {
      return this.root.value;
    }
    return this.root;
  }
};

// out-build/vs/workbench/services/configurationResolver/common/variableResolver.js
var AbstractVariableResolverService = class {
  constructor(_context, _labelService, _userHomePromise, _envVariablesPromise) {
    this._contributedVariables = /* @__PURE__ */ new Map();
    this.resolvableVariables = new Set(allVariableKinds);
    this._context = _context;
    this._labelService = _labelService;
    this._userHomePromise = _userHomePromise;
    if (_envVariablesPromise) {
      this._envVariablesPromise = _envVariablesPromise.then((envVariables) => {
        return this.prepareEnv(envVariables);
      });
    }
  }
  prepareEnv(envVariables) {
    if (isWindows) {
      const ev = /* @__PURE__ */ Object.create(null);
      Object.keys(envVariables).forEach((key) => {
        ev[key.toLowerCase()] = envVariables[key];
      });
      return ev;
    }
    return envVariables;
  }
  async resolveWithEnvironment(environment, folder, value) {
    const expr = ConfigurationResolverExpression.parse(value);
    for (const replacement of expr.unresolved()) {
      const resolvedValue = await this.evaluateSingleVariable(replacement, folder?.uri, environment);
      if (resolvedValue !== void 0) {
        expr.resolve(replacement, String(resolvedValue));
      }
    }
    return expr.toObject();
  }
  async resolveAsync(folder, config) {
    const expr = ConfigurationResolverExpression.parse(config);
    for (const replacement of expr.unresolved()) {
      const resolvedValue = await this.evaluateSingleVariable(replacement, folder?.uri);
      if (resolvedValue !== void 0) {
        expr.resolve(replacement, String(resolvedValue));
      }
    }
    return expr.toObject();
  }
  resolveWithInteractionReplace(folder, config) {
    throw new Error("resolveWithInteractionReplace not implemented.");
  }
  resolveWithInteraction(folder, config) {
    throw new Error("resolveWithInteraction not implemented.");
  }
  contributeVariable(variable, resolution) {
    if (this._contributedVariables.has(variable)) {
      throw new Error("Variable " + variable + " is contributed twice.");
    } else {
      this.resolvableVariables.add(variable);
      this._contributedVariables.set(variable, resolution);
    }
  }
  fsPath(displayUri) {
    return this._labelService ? this._labelService.getUriLabel(displayUri, { noPrefix: true }) : displayUri.fsPath;
  }
  async evaluateSingleVariable(replacement, folderUri, processEnvironment, commandValueMapping) {
    const environment = {
      env: processEnvironment !== void 0 ? this.prepareEnv(processEnvironment) : await this._envVariablesPromise,
      userHome: processEnvironment !== void 0 ? void 0 : await this._userHomePromise
    };
    const { name: variable, arg: argument } = replacement;
    const getFilePath = (variableKind) => {
      const filePath = this._context.getFilePath();
      if (filePath) {
        return normalizeDriveLetter(filePath);
      }
      throw new VariableError(variableKind, localize(15180, null, replacement.id));
    };
    const getFolderPathForFile = (variableKind) => {
      const filePath = getFilePath(variableKind);
      if (this._context.getWorkspaceFolderPathForFile) {
        const folderPath = this._context.getWorkspaceFolderPathForFile();
        if (folderPath) {
          return normalizeDriveLetter(folderPath);
        }
      }
      throw new VariableError(variableKind, localize(15181, null, replacement.id, basename(filePath)));
    };
    const getFolderUri = (variableKind) => {
      if (argument) {
        const folder = this._context.getFolderUri(argument);
        if (folder) {
          return folder;
        }
        throw new VariableError(variableKind, localize(15182, null, variableKind, argument));
      }
      if (folderUri) {
        return folderUri;
      }
      if (this._context.getWorkspaceFolderCount() > 1) {
        throw new VariableError(variableKind, localize(15183, null, variableKind));
      }
      throw new VariableError(variableKind, localize(15184, null, variableKind));
    };
    switch (variable) {
      case "env":
        if (argument) {
          if (environment.env) {
            const env2 = environment.env[isWindows ? argument.toLowerCase() : argument];
            if (isString(env2)) {
              return env2;
            }
          }
          return "";
        }
        throw new VariableError(VariableKind.Env, localize(15185, null, replacement.id));
      case "config":
        if (argument) {
          const config = this._context.getConfigurationValue(folderUri, argument);
          if (isUndefinedOrNull(config)) {
            throw new VariableError(VariableKind.Config, localize(15186, null, replacement.id, argument));
          }
          if (isObject(config)) {
            throw new VariableError(VariableKind.Config, localize(15187, null, replacement.id, argument));
          }
          return config;
        }
        throw new VariableError(VariableKind.Config, localize(15188, null, replacement.id));
      case "command":
        return this.resolveFromMap(VariableKind.Command, replacement.id, argument, commandValueMapping, "command");
      case "input":
        return this.resolveFromMap(VariableKind.Input, replacement.id, argument, commandValueMapping, "input");
      case "extensionInstallFolder":
        if (argument) {
          const ext = await this._context.getExtension(argument);
          if (!ext) {
            throw new VariableError(VariableKind.ExtensionInstallFolder, localize(15189, null, replacement.id, argument));
          }
          return this.fsPath(ext.extensionLocation);
        }
        throw new VariableError(VariableKind.ExtensionInstallFolder, localize(15190, null, replacement.id));
      default: {
        switch (variable) {
          case "workspaceRoot":
          case "workspaceFolder": {
            const uri = getFolderUri(VariableKind.WorkspaceFolder);
            return uri ? normalizeDriveLetter(this.fsPath(uri)) : void 0;
          }
          case "cwd": {
            if (!folderUri && !argument) {
              return cwd();
            }
            const uri = getFolderUri(VariableKind.Cwd);
            return uri ? normalizeDriveLetter(this.fsPath(uri)) : void 0;
          }
          case "workspaceRootFolderName":
          case "workspaceFolderBasename": {
            const uri = getFolderUri(VariableKind.WorkspaceFolderBasename);
            return uri ? normalizeDriveLetter(basename(this.fsPath(uri))) : void 0;
          }
          case "userHome":
            if (environment.userHome) {
              return environment.userHome;
            }
            throw new VariableError(VariableKind.UserHome, localize(15191, null, replacement.id));
          case "lineNumber": {
            const lineNumber = this._context.getLineNumber();
            if (lineNumber) {
              return lineNumber;
            }
            throw new VariableError(VariableKind.LineNumber, localize(15192, null, replacement.id));
          }
          case "columnNumber": {
            const columnNumber = this._context.getColumnNumber();
            if (columnNumber) {
              return columnNumber;
            }
            throw new Error(localize(15193, null, replacement.id));
          }
          case "selectedText": {
            const selectedText = this._context.getSelectedText();
            if (selectedText) {
              return selectedText;
            }
            throw new VariableError(VariableKind.SelectedText, localize(15194, null, replacement.id));
          }
          case "file":
            return getFilePath(VariableKind.File);
          case "fileWorkspaceFolder":
            return getFolderPathForFile(VariableKind.FileWorkspaceFolder);
          case "fileWorkspaceFolderBasename":
            return basename(getFolderPathForFile(VariableKind.FileWorkspaceFolderBasename));
          case "relativeFile":
            if (folderUri || argument) {
              return relative(this.fsPath(getFolderUri(VariableKind.RelativeFile)), getFilePath(VariableKind.RelativeFile));
            }
            return getFilePath(VariableKind.RelativeFile);
          case "relativeFileDirname": {
            const dirname3 = dirname(getFilePath(VariableKind.RelativeFileDirname));
            if (folderUri || argument) {
              const relative2 = relative(this.fsPath(getFolderUri(VariableKind.RelativeFileDirname)), dirname3);
              return relative2.length === 0 ? "." : relative2;
            }
            return dirname3;
          }
          case "fileDirname":
            return dirname(getFilePath(VariableKind.FileDirname));
          case "fileExtname":
            return extname(getFilePath(VariableKind.FileExtname));
          case "fileBasename":
            return basename(getFilePath(VariableKind.FileBasename));
          case "fileBasenameNoExtension": {
            const basename3 = basename(getFilePath(VariableKind.FileBasenameNoExtension));
            return basename3.slice(0, basename3.length - extname(basename3).length);
          }
          case "fileDirnameBasename":
            return basename(dirname(getFilePath(VariableKind.FileDirnameBasename)));
          case "execPath": {
            const ep = this._context.getExecPath();
            if (ep) {
              return ep;
            }
            return replacement.id;
          }
          case "execInstallFolder": {
            const ar = this._context.getAppRoot();
            if (ar) {
              return ar;
            }
            return replacement.id;
          }
          case "pathSeparator":
          case "/":
            return sep;
          default: {
            try {
              return this.resolveFromMap(VariableKind.Unknown, replacement.id, argument, commandValueMapping, void 0);
            } catch {
              return replacement.id;
            }
          }
        }
      }
    }
  }
  resolveFromMap(variableKind, match2, argument, commandValueMapping, prefix) {
    if (argument && commandValueMapping) {
      const v = prefix === void 0 ? commandValueMapping[argument] : commandValueMapping[prefix + ":" + argument];
      if (typeof v === "string") {
        return v;
      }
      throw new VariableError(variableKind, localize(15195, null, match2));
    }
    return match2;
  }
};

// out-build/vs/workbench/api/common/extHostVariableResolverService.js
var IExtHostVariableResolverProvider = createDecorator("IExtHostVariableResolverProvider");
var ExtHostVariableResolverService = class extends AbstractVariableResolverService {
  constructor(extensionService, workspaceService, editorService, editorTabs, configProvider, context, homeDir) {
    function getActiveUri() {
      if (editorService) {
        const activeEditor = editorService.activeEditor();
        if (activeEditor) {
          return activeEditor.document.uri;
        }
        const activeTab = editorTabs.tabGroups.all.find((group) => group.isActive)?.activeTab;
        if (activeTab !== void 0) {
          if (activeTab.input instanceof TextDiffTabInput || activeTab.input instanceof NotebookDiffEditorTabInput) {
            return activeTab.input.modified;
          } else if (activeTab.input instanceof TextTabInput || activeTab.input instanceof NotebookEditorTabInput || activeTab.input instanceof CustomEditorTabInput) {
            return activeTab.input.uri;
          }
        }
      }
      return void 0;
    }
    super({
      getFolderUri: (folderName) => {
        const found = context.folders.filter((f) => f.name === folderName);
        if (found && found.length > 0) {
          return found[0].uri;
        }
        return void 0;
      },
      getWorkspaceFolderCount: () => {
        return context.folders.length;
      },
      getConfigurationValue: (folderUri, section) => {
        return configProvider.getConfiguration(void 0, folderUri).get(section);
      },
      getAppRoot: () => {
        return cwd();
      },
      getExecPath: () => {
        return env["VSCODE_EXEC_PATH"];
      },
      getFilePath: () => {
        const activeUri = getActiveUri();
        if (activeUri) {
          return normalize(activeUri.fsPath);
        }
        return void 0;
      },
      getWorkspaceFolderPathForFile: () => {
        if (workspaceService) {
          const activeUri = getActiveUri();
          if (activeUri) {
            const ws = workspaceService.getWorkspaceFolder(activeUri);
            if (ws) {
              return normalize(ws.uri.fsPath);
            }
          }
        }
        return void 0;
      },
      getSelectedText: () => {
        if (editorService) {
          const activeEditor = editorService.activeEditor();
          if (activeEditor && !activeEditor.selection.isEmpty) {
            return activeEditor.document.getText(activeEditor.selection);
          }
        }
        return void 0;
      },
      getLineNumber: () => {
        if (editorService) {
          const activeEditor = editorService.activeEditor();
          if (activeEditor) {
            return String(activeEditor.selection.end.line + 1);
          }
        }
        return void 0;
      },
      getColumnNumber: () => {
        if (editorService) {
          const activeEditor = editorService.activeEditor();
          if (activeEditor) {
            return String(activeEditor.selection.end.character + 1);
          }
        }
        return void 0;
      },
      getExtension: (id2) => {
        return extensionService.getExtension(id2);
      }
    }, void 0, homeDir ? Promise.resolve(homeDir) : void 0, Promise.resolve(env));
  }
};
var ExtHostVariableResolverProviderService = class ExtHostVariableResolverProviderService2 extends Disposable {
  constructor(extensionService, workspaceService, editorService, configurationService, editorTabs) {
    super();
    this.extensionService = extensionService;
    this.workspaceService = workspaceService;
    this.editorService = editorService;
    this.configurationService = configurationService;
    this.editorTabs = editorTabs;
    this._resolver = new Lazy(async () => {
      const configProvider = await this.configurationService.getConfigProvider();
      const folders = await this.workspaceService.getWorkspaceFolders2() || [];
      const dynamic = { folders };
      this._register(this.workspaceService.onDidChangeWorkspace(async (e) => {
        dynamic.folders = await this.workspaceService.getWorkspaceFolders2() || [];
      }));
      return new ExtHostVariableResolverService(this.extensionService, this.workspaceService, this.editorService, this.editorTabs, configProvider, dynamic, this.homeDir());
    });
  }
  getResolver() {
    return this._resolver.value;
  }
  homeDir() {
    return void 0;
  }
};
ExtHostVariableResolverProviderService = __decorate([
  __param(0, IExtHostExtensionService),
  __param(1, IExtHostWorkspace),
  __param(2, IExtHostDocumentsAndEditors),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostEditorTabs)
], ExtHostVariableResolverProviderService);

// out-build/vs/workbench/api/common/extHostDebugService.js
var IExtHostDebugService = createDecorator("IExtHostDebugService");
var ExtHostDebugServiceBase = class ExtHostDebugServiceBase2 extends Disposable {
  get onDidStartDebugSession() {
    return this._onDidStartDebugSession.event;
  }
  get onDidTerminateDebugSession() {
    return this._onDidTerminateDebugSession.event;
  }
  get onDidChangeActiveDebugSession() {
    return this._onDidChangeActiveDebugSession.event;
  }
  get activeDebugSession() {
    return this._activeDebugSession?.api;
  }
  get onDidReceiveDebugSessionCustomEvent() {
    return this._onDidReceiveDebugSessionCustomEvent.event;
  }
  get activeDebugConsole() {
    return this._activeDebugConsole.value;
  }
  constructor(extHostRpcService, _workspaceService, _extensionService, _configurationService, _editorTabs, _variableResolver, _commands, _testing) {
    super();
    this._workspaceService = _workspaceService;
    this._extensionService = _extensionService;
    this._configurationService = _configurationService;
    this._editorTabs = _editorTabs;
    this._variableResolver = _variableResolver;
    this._commands = _commands;
    this._testing = _testing;
    this._debugSessions = /* @__PURE__ */ new Map();
    this._debugVisualizationTreeItemIdsCounter = 0;
    this._debugVisualizationProviders = /* @__PURE__ */ new Map();
    this._debugVisualizationTrees = /* @__PURE__ */ new Map();
    this._debugVisualizationTreeItemIds = /* @__PURE__ */ new WeakMap();
    this._debugVisualizationElements = /* @__PURE__ */ new Map();
    this._visualizers = /* @__PURE__ */ new Map();
    this._visualizerIdCounter = 0;
    this._configProviderHandleCounter = 0;
    this._configProviders = [];
    this._adapterFactoryHandleCounter = 0;
    this._adapterFactories = [];
    this._trackerFactoryHandleCounter = 0;
    this._trackerFactories = [];
    this._debugAdapters = /* @__PURE__ */ new Map();
    this._debugAdaptersTrackers = /* @__PURE__ */ new Map();
    this._onDidStartDebugSession = this._register(new Emitter());
    this._onDidTerminateDebugSession = this._register(new Emitter());
    this._onDidChangeActiveDebugSession = this._register(new Emitter());
    this._onDidReceiveDebugSessionCustomEvent = this._register(new Emitter());
    this._debugServiceProxy = extHostRpcService.getProxy(MainContext.MainThreadDebugService);
    this._onDidChangeBreakpoints = this._register(new Emitter());
    this._onDidChangeActiveStackItem = this._register(new Emitter());
    this._activeDebugConsole = new ExtHostDebugConsole(this._debugServiceProxy);
    this._breakpoints = /* @__PURE__ */ new Map();
    this._extensionService.getExtensionRegistry().then((extensionRegistry) => {
      this._register(extensionRegistry.onDidChange((_) => {
        this.registerAllDebugTypes(extensionRegistry);
      }));
      this.registerAllDebugTypes(extensionRegistry);
    });
    this._telemetryProxy = extHostRpcService.getProxy(MainContext.MainThreadTelemetry);
  }
  async $getVisualizerTreeItem(treeId, element) {
    const context = this.hydrateVisualizationContext(element);
    if (!context) {
      return void 0;
    }
    const item = await this._debugVisualizationTrees.get(treeId)?.getTreeItem?.(context);
    return item ? this.convertVisualizerTreeItem(treeId, item) : void 0;
  }
  registerDebugVisualizationTree(manifest, id2, provider) {
    const extensionId = ExtensionIdentifier.toKey(manifest.identifier);
    const key = this.extensionVisKey(extensionId, id2);
    if (this._debugVisualizationProviders.has(key)) {
      throw new Error(`A debug visualization provider with id '${id2}' is already registered`);
    }
    this._debugVisualizationTrees.set(key, provider);
    this._debugServiceProxy.$registerDebugVisualizerTree(key, !!provider.editItem);
    return toDisposable(() => {
      this._debugServiceProxy.$unregisterDebugVisualizerTree(key);
      this._debugVisualizationTrees.delete(id2);
    });
  }
  async $getVisualizerTreeItemChildren(treeId, element) {
    const item = this._debugVisualizationElements.get(element)?.item;
    if (!item) {
      return [];
    }
    const children = await this._debugVisualizationTrees.get(treeId)?.getChildren?.(item);
    return children?.map((i) => this.convertVisualizerTreeItem(treeId, i)) || [];
  }
  async $editVisualizerTreeItem(element, value) {
    const e = this._debugVisualizationElements.get(element);
    if (!e) {
      return void 0;
    }
    const r = await this._debugVisualizationTrees.get(e.provider)?.editItem?.(e.item, value);
    return this.convertVisualizerTreeItem(e.provider, r || e.item);
  }
  $disposeVisualizedTree(element) {
    const root = this._debugVisualizationElements.get(element);
    if (!root) {
      return;
    }
    const queue = [root.children];
    for (const children of queue) {
      if (children) {
        for (const child of children) {
          queue.push(this._debugVisualizationElements.get(child)?.children);
          this._debugVisualizationElements.delete(child);
        }
      }
    }
  }
  convertVisualizerTreeItem(treeId, item) {
    let id2 = this._debugVisualizationTreeItemIds.get(item);
    if (!id2) {
      id2 = this._debugVisualizationTreeItemIdsCounter++;
      this._debugVisualizationTreeItemIds.set(item, id2);
      this._debugVisualizationElements.set(id2, { provider: treeId, item });
    }
    return DebugTreeItem.from(item, id2);
  }
  asDebugSourceUri(src, session) {
    const source = src;
    if (typeof source.sourceReference === "number" && source.sourceReference > 0) {
      let debug = `debug:${encodeURIComponent(source.path || "")}`;
      let sep2 = "?";
      if (session) {
        debug += `${sep2}session=${encodeURIComponent(session.id)}`;
        sep2 = "&";
      }
      debug += `${sep2}ref=${source.sourceReference}`;
      return URI.parse(debug);
    } else if (source.path) {
      return URI.file(source.path);
    } else {
      throw new Error(`cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.`);
    }
  }
  registerAllDebugTypes(extensionRegistry) {
    const debugTypes = [];
    for (const ed of extensionRegistry.getAllExtensionDescriptions()) {
      if (ed.contributes) {
        const debuggers = ed.contributes["debuggers"];
        if (debuggers && debuggers.length > 0) {
          for (const dbg of debuggers) {
            if (isDebuggerMainContribution(dbg)) {
              debugTypes.push(dbg.type);
            }
          }
        }
      }
    }
    this._debugServiceProxy.$registerDebugTypes(debugTypes);
  }
  // extension debug API
  get activeStackItem() {
    return this._activeStackItem;
  }
  get onDidChangeActiveStackItem() {
    return this._onDidChangeActiveStackItem.event;
  }
  get onDidChangeBreakpoints() {
    return this._onDidChangeBreakpoints.event;
  }
  get breakpoints() {
    const result = [];
    this._breakpoints.forEach((bp) => result.push(bp));
    return result;
  }
  async $resolveDebugVisualizer(id2, token) {
    const visualizer = this._visualizers.get(id2);
    if (!visualizer) {
      throw new Error(`No debug visualizer found with id '${id2}'`);
    }
    let { v, provider, extensionId } = visualizer;
    if (!v.visualization) {
      v = await provider.resolveDebugVisualization?.(v, token) || v;
      visualizer.v = v;
    }
    if (!v.visualization) {
      throw new Error(`No visualization returned from resolveDebugVisualization in '${provider}'`);
    }
    return this.serializeVisualization(extensionId, v.visualization);
  }
  async $executeDebugVisualizerCommand(id2) {
    const visualizer = this._visualizers.get(id2);
    if (!visualizer) {
      throw new Error(`No debug visualizer found with id '${id2}'`);
    }
    const command = visualizer.v.visualization;
    if (command && "command" in command) {
      this._commands.executeCommand(command.command, ...command.arguments || []);
    }
  }
  hydrateVisualizationContext(context) {
    const session = this._debugSessions.get(context.sessionId);
    return session && {
      session: session.api,
      variable: context.variable,
      containerId: context.containerId,
      frameId: context.frameId,
      threadId: context.threadId
    };
  }
  async $provideDebugVisualizers(extensionId, id2, context, token) {
    const contextHydrated = this.hydrateVisualizationContext(context);
    const key = this.extensionVisKey(extensionId, id2);
    const provider = this._debugVisualizationProviders.get(key);
    if (!contextHydrated || !provider) {
      return [];
    }
    const visualizations = await provider.provideDebugVisualization(contextHydrated, token);
    if (!visualizations) {
      return [];
    }
    return visualizations.map((v) => {
      const id3 = ++this._visualizerIdCounter;
      this._visualizers.set(id3, { v, provider, extensionId });
      const icon = v.iconPath ? this.getIconPathOrClass(v.iconPath) : void 0;
      return {
        id: id3,
        name: v.name,
        iconClass: icon?.iconClass,
        iconPath: icon?.iconPath,
        visualization: this.serializeVisualization(extensionId, v.visualization)
      };
    });
  }
  $disposeDebugVisualizers(ids) {
    for (const id2 of ids) {
      this._visualizers.delete(id2);
    }
  }
  registerDebugVisualizationProvider(manifest, id2, provider) {
    if (!manifest.contributes?.debugVisualizers?.some((r) => r.id === id2)) {
      throw new Error(`Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${id2})`);
    }
    const extensionId = ExtensionIdentifier.toKey(manifest.identifier);
    const key = this.extensionVisKey(extensionId, id2);
    if (this._debugVisualizationProviders.has(key)) {
      throw new Error(`A debug visualization provider with id '${id2}' is already registered`);
    }
    this._debugVisualizationProviders.set(key, provider);
    this._debugServiceProxy.$registerDebugVisualizer(extensionId, id2);
    return toDisposable(() => {
      this._debugServiceProxy.$unregisterDebugVisualizer(extensionId, id2);
      this._debugVisualizationProviders.delete(id2);
    });
  }
  addBreakpoints(breakpoints0) {
    const breakpoints = breakpoints0.filter((bp) => {
      const id2 = bp.id;
      if (!this._breakpoints.has(id2)) {
        this._breakpoints.set(id2, bp);
        return true;
      }
      return false;
    });
    this.fireBreakpointChanges(breakpoints, [], []);
    const dtos = [];
    const map = /* @__PURE__ */ new Map();
    for (const bp of breakpoints) {
      if (bp instanceof SourceBreakpoint) {
        let dto = map.get(bp.location.uri.toString());
        if (!dto) {
          dto = {
            type: "sourceMulti",
            uri: bp.location.uri,
            lines: []
          };
          map.set(bp.location.uri.toString(), dto);
          dtos.push(dto);
        }
        dto.lines.push({
          id: bp.id,
          enabled: bp.enabled,
          condition: bp.condition,
          hitCondition: bp.hitCondition,
          logMessage: bp.logMessage,
          line: bp.location.range.start.line,
          character: bp.location.range.start.character,
          mode: bp.mode
        });
      } else if (bp instanceof FunctionBreakpoint) {
        dtos.push({
          type: "function",
          id: bp.id,
          enabled: bp.enabled,
          hitCondition: bp.hitCondition,
          logMessage: bp.logMessage,
          condition: bp.condition,
          functionName: bp.functionName,
          mode: bp.mode
        });
      }
    }
    return this._debugServiceProxy.$registerBreakpoints(dtos);
  }
  removeBreakpoints(breakpoints0) {
    const breakpoints = breakpoints0.filter((b) => this._breakpoints.delete(b.id));
    this.fireBreakpointChanges([], breakpoints, []);
    const ids = breakpoints.filter((bp) => bp instanceof SourceBreakpoint).map((bp) => bp.id);
    const fids = breakpoints.filter((bp) => bp instanceof FunctionBreakpoint).map((bp) => bp.id);
    const dids = breakpoints.filter((bp) => bp instanceof DataBreakpoint).map((bp) => bp.id);
    return this._debugServiceProxy.$unregisterBreakpoints(ids, fids, dids);
  }
  startDebugging(folder, nameOrConfig, options2) {
    const testRunMeta = options2.testRun && this._testing.getMetadataForRun(options2.testRun);
    return this._debugServiceProxy.$startDebugging(folder ? folder.uri : void 0, nameOrConfig, {
      parentSessionID: options2.parentSession ? options2.parentSession.id : void 0,
      lifecycleManagedByParent: options2.lifecycleManagedByParent,
      repl: options2.consoleMode === DebugConsoleMode.MergeWithParent ? "mergeWithParent" : "separate",
      noDebug: options2.noDebug,
      compact: options2.compact,
      suppressSaveBeforeStart: options2.suppressSaveBeforeStart,
      testRun: testRunMeta && {
        runId: testRunMeta.runId,
        taskId: testRunMeta.taskId
      },
      // Check debugUI for back-compat, #147264
      // eslint-disable-next-line local/code-no-any-casts
      suppressDebugStatusbar: options2.suppressDebugStatusbar ?? options2.debugUI?.simple,
      // eslint-disable-next-line local/code-no-any-casts
      suppressDebugToolbar: options2.suppressDebugToolbar ?? options2.debugUI?.simple,
      // eslint-disable-next-line local/code-no-any-casts
      suppressDebugView: options2.suppressDebugView ?? options2.debugUI?.simple
    });
  }
  stopDebugging(session) {
    return this._debugServiceProxy.$stopDebugging(session ? session.id : void 0);
  }
  registerDebugConfigurationProvider(type, provider, trigger) {
    if (!provider) {
      return new Disposable2(() => {
      });
    }
    const handle = this._configProviderHandleCounter++;
    this._configProviders.push({ type, handle, provider });
    this._debugServiceProxy.$registerDebugConfigurationProvider(type, trigger, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.resolveDebugConfigurationWithSubstitutedVariables, handle);
    return new Disposable2(() => {
      this._configProviders = this._configProviders.filter((p) => p.provider !== provider);
      this._debugServiceProxy.$unregisterDebugConfigurationProvider(handle);
    });
  }
  registerDebugAdapterDescriptorFactory(extension, type, factory) {
    if (!factory) {
      return new Disposable2(() => {
      });
    }
    if (!this.definesDebugType(extension, type)) {
      throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${type}' debugger.`);
    }
    if (this.getAdapterDescriptorFactoryByType(type)) {
      throw new Error(`a DebugAdapterDescriptorFactory can only be registered once per a type.`);
    }
    const handle = this._adapterFactoryHandleCounter++;
    this._adapterFactories.push({ type, handle, factory });
    this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(type, handle);
    return new Disposable2(() => {
      this._adapterFactories = this._adapterFactories.filter((p) => p.factory !== factory);
      this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(handle);
    });
  }
  registerDebugAdapterTrackerFactory(type, factory) {
    if (!factory) {
      return new Disposable2(() => {
      });
    }
    const handle = this._trackerFactoryHandleCounter++;
    this._trackerFactories.push({ type, handle, factory });
    return new Disposable2(() => {
      this._trackerFactories = this._trackerFactories.filter((p) => p.factory !== factory);
    });
  }
  // RPC methods (ExtHostDebugServiceShape)
  async $runInTerminal(args, sessionId) {
    return Promise.resolve(void 0);
  }
  async $substituteVariables(folderUri, config) {
    let ws;
    const folder = await this.getFolder(folderUri);
    if (folder) {
      ws = {
        uri: folder.uri,
        name: folder.name,
        index: folder.index
      };
    }
    const variableResolver = await this._variableResolver.getResolver();
    return variableResolver.resolveAsync(ws, config);
  }
  createDebugAdapter(adapter, session) {
    if (adapter instanceof DebugAdapterInlineImplementation) {
      return new DirectDebugAdapter(adapter.implementation);
    }
    return void 0;
  }
  createSignService() {
    return void 0;
  }
  async $startDASession(debugAdapterHandle, sessionDto) {
    const mythis = this;
    const session = await this.getSession(sessionDto);
    return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(session.type), session).then((daDescriptor) => {
      if (!daDescriptor) {
        throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}' (extension might have failed to activate)`);
      }
      const da = this.createDebugAdapter(daDescriptor, session);
      if (!da) {
        throw new Error(`Couldn't create a debug adapter for type '${session.type}'.`);
      }
      const debugAdapter = da;
      this._debugAdapters.set(debugAdapterHandle, debugAdapter);
      return this.getDebugAdapterTrackers(session).then((tracker) => {
        if (tracker) {
          this._debugAdaptersTrackers.set(debugAdapterHandle, tracker);
        }
        debugAdapter.onMessage(async (message) => {
          if (message.type === "request" && message.command === "handshake") {
            const request = message;
            const response = {
              type: "response",
              seq: 0,
              command: request.command,
              request_seq: request.seq,
              success: true
            };
            if (!this._signService) {
              this._signService = this.createSignService();
            }
            try {
              if (this._signService) {
                const signature = await this._signService.sign(request.arguments.value);
                response.body = {
                  signature
                };
                debugAdapter.sendResponse(response);
              } else {
                throw new Error("no signer");
              }
            } catch (e) {
              response.success = false;
              response.message = e.message;
              debugAdapter.sendResponse(response);
            }
          } else {
            if (tracker && tracker.onDidSendMessage) {
              tracker.onDidSendMessage(message);
            }
            try {
              message = convertToVSCPaths(message, true);
            } catch (e) {
              const type = message.type + "_" + (message.command ?? message.event ?? "");
              this._telemetryProxy.$publicLog2("debugProtocolMessageError", { type, from: session.type });
              throw e;
            }
            mythis._debugServiceProxy.$acceptDAMessage(debugAdapterHandle, message);
          }
        });
        debugAdapter.onError((err) => {
          if (tracker && tracker.onError) {
            tracker.onError(err);
          }
          this._debugServiceProxy.$acceptDAError(debugAdapterHandle, err.name, err.message, err.stack);
        });
        debugAdapter.onExit((code) => {
          if (tracker && tracker.onExit) {
            tracker.onExit(code ?? void 0, void 0);
          }
          this._debugServiceProxy.$acceptDAExit(debugAdapterHandle, code ?? void 0, void 0);
        });
        if (tracker && tracker.onWillStartSession) {
          tracker.onWillStartSession();
        }
        return debugAdapter.startSession();
      });
    });
  }
  $sendDAMessage(debugAdapterHandle, message) {
    message = convertToDAPaths(message, false);
    const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
    if (tracker && tracker.onWillReceiveMessage) {
      tracker.onWillReceiveMessage(message);
    }
    const da = this._debugAdapters.get(debugAdapterHandle);
    da?.sendMessage(message);
  }
  $stopDASession(debugAdapterHandle) {
    const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
    this._debugAdaptersTrackers.delete(debugAdapterHandle);
    if (tracker && tracker.onWillStopSession) {
      tracker.onWillStopSession();
    }
    const da = this._debugAdapters.get(debugAdapterHandle);
    this._debugAdapters.delete(debugAdapterHandle);
    if (da) {
      return da.stopSession();
    } else {
      return Promise.resolve(void 0);
    }
  }
  $acceptBreakpointsDelta(delta3) {
    const a = [];
    const r = [];
    const c = [];
    if (delta3.added) {
      for (const bpd of delta3.added) {
        const id2 = bpd.id;
        if (id2 && !this._breakpoints.has(id2)) {
          let bp;
          if (bpd.type === "function") {
            bp = new FunctionBreakpoint(bpd.functionName, bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage, bpd.mode);
          } else if (bpd.type === "data") {
            bp = new DataBreakpoint(bpd.label, bpd.dataId, bpd.canPersist, bpd.enabled, bpd.hitCondition, bpd.condition, bpd.logMessage, bpd.mode);
          } else {
            const uri = URI.revive(bpd.uri);
            bp = new SourceBreakpoint(new Location(uri, new Position2(bpd.line, bpd.character)), bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage, bpd.mode);
          }
          setBreakpointId(bp, id2);
          this._breakpoints.set(id2, bp);
          a.push(bp);
        }
      }
    }
    if (delta3.removed) {
      for (const id2 of delta3.removed) {
        const bp = this._breakpoints.get(id2);
        if (bp) {
          this._breakpoints.delete(id2);
          r.push(bp);
        }
      }
    }
    if (delta3.changed) {
      for (const bpd of delta3.changed) {
        if (bpd.id) {
          const bp = this._breakpoints.get(bpd.id);
          if (bp) {
            if (bp instanceof FunctionBreakpoint && bpd.type === "function") {
              const fbp = bp;
              fbp.enabled = bpd.enabled;
              fbp.condition = bpd.condition;
              fbp.hitCondition = bpd.hitCondition;
              fbp.logMessage = bpd.logMessage;
              fbp.functionName = bpd.functionName;
            } else if (bp instanceof SourceBreakpoint && bpd.type === "source") {
              const sbp = bp;
              sbp.enabled = bpd.enabled;
              sbp.condition = bpd.condition;
              sbp.hitCondition = bpd.hitCondition;
              sbp.logMessage = bpd.logMessage;
              sbp.location = new Location(URI.revive(bpd.uri), new Position2(bpd.line, bpd.character));
            }
            c.push(bp);
          }
        }
      }
    }
    this.fireBreakpointChanges(a, r, c);
  }
  async $acceptStackFrameFocus(focusDto) {
    let focus;
    if (focusDto) {
      const session = await this.getSession(focusDto.sessionId);
      if (focusDto.kind === "thread") {
        focus = new DebugThread(session.api, focusDto.threadId);
      } else {
        focus = new DebugStackFrame(session.api, focusDto.threadId, focusDto.frameId);
      }
    }
    this._activeStackItem = focus;
    this._onDidChangeActiveStackItem.fire(this._activeStackItem);
  }
  $provideDebugConfigurations(configProviderHandle, folderUri, token) {
    return asPromise(async () => {
      const provider = this.getConfigProviderByHandle(configProviderHandle);
      if (!provider) {
        throw new Error("no DebugConfigurationProvider found");
      }
      if (!provider.provideDebugConfigurations) {
        throw new Error("DebugConfigurationProvider has no method provideDebugConfigurations");
      }
      const folder = await this.getFolder(folderUri);
      return provider.provideDebugConfigurations(folder, token);
    }).then((debugConfigurations) => {
      if (!debugConfigurations) {
        throw new Error("nothing returned from DebugConfigurationProvider.provideDebugConfigurations");
      }
      return debugConfigurations;
    });
  }
  $resolveDebugConfiguration(configProviderHandle, folderUri, debugConfiguration, token) {
    return asPromise(async () => {
      const provider = this.getConfigProviderByHandle(configProviderHandle);
      if (!provider) {
        throw new Error("no DebugConfigurationProvider found");
      }
      if (!provider.resolveDebugConfiguration) {
        throw new Error("DebugConfigurationProvider has no method resolveDebugConfiguration");
      }
      const folder = await this.getFolder(folderUri);
      return provider.resolveDebugConfiguration(folder, debugConfiguration, token);
    });
  }
  $resolveDebugConfigurationWithSubstitutedVariables(configProviderHandle, folderUri, debugConfiguration, token) {
    return asPromise(async () => {
      const provider = this.getConfigProviderByHandle(configProviderHandle);
      if (!provider) {
        throw new Error("no DebugConfigurationProvider found");
      }
      if (!provider.resolveDebugConfigurationWithSubstitutedVariables) {
        throw new Error("DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables");
      }
      const folder = await this.getFolder(folderUri);
      return provider.resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfiguration, token);
    });
  }
  async $provideDebugAdapter(adapterFactoryHandle, sessionDto) {
    const adapterDescriptorFactory = this.getAdapterDescriptorFactoryByHandle(adapterFactoryHandle);
    if (!adapterDescriptorFactory) {
      return Promise.reject(new Error("no adapter descriptor factory found for handle"));
    }
    const session = await this.getSession(sessionDto);
    return this.getAdapterDescriptor(adapterDescriptorFactory, session).then((adapterDescriptor) => {
      if (!adapterDescriptor) {
        throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}'`);
      }
      return this.convertToDto(adapterDescriptor);
    });
  }
  async $acceptDebugSessionStarted(sessionDto) {
    const session = await this.getSession(sessionDto);
    this._onDidStartDebugSession.fire(session.api);
  }
  async $acceptDebugSessionTerminated(sessionDto) {
    const session = await this.getSession(sessionDto);
    if (session) {
      this._onDidTerminateDebugSession.fire(session.api);
      this._debugSessions.delete(session.id);
    }
  }
  async $acceptDebugSessionActiveChanged(sessionDto) {
    this._activeDebugSession = sessionDto ? await this.getSession(sessionDto) : void 0;
    this._onDidChangeActiveDebugSession.fire(this._activeDebugSession?.api);
  }
  async $acceptDebugSessionNameChanged(sessionDto, name2) {
    const session = await this.getSession(sessionDto);
    session?._acceptNameChanged(name2);
  }
  async $acceptDebugSessionCustomEvent(sessionDto, event) {
    const session = await this.getSession(sessionDto);
    const ee = {
      session: session.api,
      event: event.event,
      body: event.body
    };
    this._onDidReceiveDebugSessionCustomEvent.fire(ee);
  }
  // private & dto helpers
  convertToDto(x) {
    if (x instanceof DebugAdapterExecutable) {
      return this.convertExecutableToDto(x);
    } else if (x instanceof DebugAdapterServer) {
      return this.convertServerToDto(x);
    } else if (x instanceof DebugAdapterNamedPipeServer) {
      return this.convertPipeServerToDto(x);
    } else if (x instanceof DebugAdapterInlineImplementation) {
      return this.convertImplementationToDto(x);
    } else {
      throw new Error("convertToDto unexpected type");
    }
  }
  convertExecutableToDto(x) {
    return {
      type: "executable",
      command: x.command,
      args: x.args,
      options: x.options
    };
  }
  convertServerToDto(x) {
    return {
      type: "server",
      port: x.port,
      host: x.host
    };
  }
  convertPipeServerToDto(x) {
    return {
      type: "pipeServer",
      path: x.path
    };
  }
  convertImplementationToDto(x) {
    return {
      type: "implementation"
    };
  }
  getAdapterDescriptorFactoryByType(type) {
    const results = this._adapterFactories.filter((p) => p.type === type);
    if (results.length > 0) {
      return results[0].factory;
    }
    return void 0;
  }
  getAdapterDescriptorFactoryByHandle(handle) {
    const results = this._adapterFactories.filter((p) => p.handle === handle);
    if (results.length > 0) {
      return results[0].factory;
    }
    return void 0;
  }
  getConfigProviderByHandle(handle) {
    const results = this._configProviders.filter((p) => p.handle === handle);
    if (results.length > 0) {
      return results[0].provider;
    }
    return void 0;
  }
  definesDebugType(ed, type) {
    if (ed.contributes) {
      const debuggers = ed.contributes["debuggers"];
      if (debuggers && debuggers.length > 0) {
        for (const dbg of debuggers) {
          if (dbg.label && dbg.type) {
            if (dbg.type === type) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  getDebugAdapterTrackers(session) {
    const config = session.configuration;
    const type = config.type;
    const promises = this._trackerFactories.filter((tuple) => tuple.type === type || tuple.type === "*").map((tuple) => asPromise(() => tuple.factory.createDebugAdapterTracker(session.api)).then((p) => p, (err) => null));
    return Promise.race([
      Promise.all(promises).then((result) => {
        const trackers = coalesce(result);
        if (trackers.length > 0) {
          return new MultiTracker(trackers);
        }
        return void 0;
      }),
      new Promise((resolve2) => setTimeout(() => resolve2(void 0), 1e3))
    ]).catch((err) => {
      return void 0;
    });
  }
  async getAdapterDescriptor(adapterDescriptorFactory, session) {
    const serverPort = session.configuration.debugServer;
    if (typeof serverPort === "number") {
      return Promise.resolve(new DebugAdapterServer(serverPort));
    }
    if (adapterDescriptorFactory) {
      const extensionRegistry2 = await this._extensionService.getExtensionRegistry();
      return asPromise(() => adapterDescriptorFactory.createDebugAdapterDescriptor(session.api, this.daExecutableFromPackage(session, extensionRegistry2))).then((daDescriptor) => {
        if (daDescriptor) {
          return daDescriptor;
        }
        return void 0;
      });
    }
    const extensionRegistry = await this._extensionService.getExtensionRegistry();
    return Promise.resolve(this.daExecutableFromPackage(session, extensionRegistry));
  }
  daExecutableFromPackage(session, extensionRegistry) {
    return void 0;
  }
  fireBreakpointChanges(added, removed, changed) {
    if (added.length > 0 || removed.length > 0 || changed.length > 0) {
      this._onDidChangeBreakpoints.fire(Object.freeze({
        added,
        removed,
        changed
      }));
    }
  }
  async getSession(dto) {
    if (dto) {
      if (typeof dto === "string") {
        const ds = this._debugSessions.get(dto);
        if (ds) {
          return ds;
        }
      } else {
        let ds = this._debugSessions.get(dto.id);
        if (!ds) {
          const folder = await this.getFolder(dto.folderUri);
          const parent = dto.parent ? this._debugSessions.get(dto.parent) : void 0;
          ds = new ExtHostDebugSession(this._debugServiceProxy, dto.id, dto.type, dto.name, folder, dto.configuration, parent?.api);
          this._debugSessions.set(ds.id, ds);
          this._debugServiceProxy.$sessionCached(ds.id);
        }
        return ds;
      }
    }
    throw new Error("cannot find session");
  }
  getFolder(_folderUri) {
    if (_folderUri) {
      const folderURI = URI.revive(_folderUri);
      return this._workspaceService.resolveWorkspaceFolder(folderURI);
    }
    return Promise.resolve(void 0);
  }
  extensionVisKey(extensionId, id2) {
    return `${extensionId}\0${id2}`;
  }
  serializeVisualization(extensionId, viz) {
    if (!viz) {
      return void 0;
    }
    if ("title" in viz && "command" in viz) {
      return {
        type: 0
        /* DebugVisualizationType.Command */
      };
    }
    if ("treeId" in viz) {
      return { type: 1, id: `${extensionId}\0${viz.treeId}` };
    }
    throw new Error("Unsupported debug visualization type");
  }
  getIconPathOrClass(icon) {
    const iconPathOrIconClass = this.getIconUris(icon);
    let iconPath;
    let iconClass;
    if ("id" in iconPathOrIconClass) {
      iconClass = ThemeIcon.asClassName(iconPathOrIconClass);
    } else {
      iconPath = iconPathOrIconClass;
    }
    return {
      iconPath,
      iconClass
    };
  }
  getIconUris(iconPath) {
    if (iconPath instanceof ThemeIcon2) {
      return { id: iconPath.id };
    }
    const dark = typeof iconPath === "object" && "dark" in iconPath ? iconPath.dark : iconPath;
    const light = typeof iconPath === "object" && "light" in iconPath ? iconPath.light : iconPath;
    return {
      dark: typeof dark === "string" ? URI.file(dark) : dark,
      light: typeof light === "string" ? URI.file(light) : light
    };
  }
};
ExtHostDebugServiceBase = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostWorkspace),
  __param(2, IExtHostExtensionService),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostEditorTabs),
  __param(5, IExtHostVariableResolverProvider),
  __param(6, IExtHostCommands),
  __param(7, IExtHostTesting)
], ExtHostDebugServiceBase);
var ExtHostDebugSession = class {
  constructor(_debugServiceProxy, _id, _type, _name, _workspaceFolder, _configuration, _parentSession) {
    this._debugServiceProxy = _debugServiceProxy;
    this._id = _id;
    this._type = _type;
    this._name = _name;
    this._workspaceFolder = _workspaceFolder;
    this._configuration = _configuration;
    this._parentSession = _parentSession;
  }
  get api() {
    const that = this;
    return this.apiSession ??= Object.freeze({
      id: that._id,
      type: that._type,
      get name() {
        return that._name;
      },
      set name(name2) {
        that._name = name2;
        that._debugServiceProxy.$setDebugSessionName(that._id, name2);
      },
      parentSession: that._parentSession,
      workspaceFolder: that._workspaceFolder,
      configuration: that._configuration,
      customRequest(command, args) {
        return that._debugServiceProxy.$customDebugAdapterRequest(that._id, command, args);
      },
      getDebugProtocolBreakpoint(breakpoint) {
        return that._debugServiceProxy.$getDebugProtocolBreakpoint(that._id, breakpoint.id);
      }
    });
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  _acceptNameChanged(name2) {
    this._name = name2;
  }
  get configuration() {
    return this._configuration;
  }
};
var ExtHostDebugConsole = class {
  constructor(proxy) {
    this.value = Object.freeze({
      append(value) {
        proxy.$appendDebugConsole(value);
      },
      appendLine(value) {
        this.append(value + "\n");
      }
    });
  }
};
var MultiTracker = class {
  constructor(trackers) {
    this.trackers = trackers;
  }
  onWillStartSession() {
    this.trackers.forEach((t) => t.onWillStartSession ? t.onWillStartSession() : void 0);
  }
  onWillReceiveMessage(message) {
    this.trackers.forEach((t) => t.onWillReceiveMessage ? t.onWillReceiveMessage(message) : void 0);
  }
  onDidSendMessage(message) {
    this.trackers.forEach((t) => t.onDidSendMessage ? t.onDidSendMessage(message) : void 0);
  }
  onWillStopSession() {
    this.trackers.forEach((t) => t.onWillStopSession ? t.onWillStopSession() : void 0);
  }
  onError(error) {
    this.trackers.forEach((t) => t.onError ? t.onError(error) : void 0);
  }
  onExit(code, signal) {
    this.trackers.forEach((t) => t.onExit ? t.onExit(code, signal) : void 0);
  }
};
var DirectDebugAdapter = class extends AbstractDebugAdapter {
  constructor(implementation) {
    super();
    this.implementation = implementation;
    implementation.onDidSendMessage((message) => {
      this.acceptMessage(message);
    });
  }
  startSession() {
    return Promise.resolve(void 0);
  }
  sendMessage(message) {
    this.implementation.handleMessage(message);
  }
  stopSession() {
    this.implementation.dispose();
    return Promise.resolve(void 0);
  }
};
var WorkerExtHostDebugService = class WorkerExtHostDebugService2 extends ExtHostDebugServiceBase {
  constructor(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver, commands, testing) {
    super(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver, commands, testing);
  }
};
WorkerExtHostDebugService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostWorkspace),
  __param(2, IExtHostExtensionService),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostEditorTabs),
  __param(5, IExtHostVariableResolverProvider),
  __param(6, IExtHostCommands),
  __param(7, IExtHostTesting)
], WorkerExtHostDebugService);

// out-build/vs/workbench/services/search/common/searchExtConversionTypes.js
function isTextSearchMatch(object) {
  return "uri" in object && "ranges" in object && "preview" in object;
}
function newToOldFileProviderOptions(options2) {
  return options2.folderOptions.map((folderOption) => ({
    folder: folderOption.folder,
    excludes: folderOption.excludes.map((e) => typeof e === "string" ? e : e.pattern),
    includes: folderOption.includes,
    useGlobalIgnoreFiles: folderOption.useIgnoreFiles.global,
    useIgnoreFiles: folderOption.useIgnoreFiles.local,
    useParentIgnoreFiles: folderOption.useIgnoreFiles.parent,
    followSymlinks: folderOption.followSymlinks,
    maxResults: options2.maxResults,
    session: options2.session
    // TODO: make sure that we actually use a cancellation token here.
  }));
}
var OldFileSearchProviderConverter = class {
  constructor(provider) {
    this.provider = provider;
  }
  provideFileSearchResults(pattern, options2, token) {
    const getResult = async () => {
      const newOpts = newToOldFileProviderOptions(options2);
      return Promise.all(newOpts.map((o) => this.provider.provideFileSearchResults({ pattern }, o, token)));
    };
    return getResult().then((e) => coalesce(e).flat());
  }
};
function newToOldTextProviderOptions(options2) {
  return options2.folderOptions.map((folderOption) => ({
    folder: folderOption.folder,
    excludes: folderOption.excludes.map((e) => typeof e === "string" ? e : e.pattern),
    includes: folderOption.includes,
    useGlobalIgnoreFiles: folderOption.useIgnoreFiles.global,
    useIgnoreFiles: folderOption.useIgnoreFiles.local,
    useParentIgnoreFiles: folderOption.useIgnoreFiles.parent,
    followSymlinks: folderOption.followSymlinks,
    maxResults: options2.maxResults,
    previewOptions: newToOldPreviewOptions(options2.previewOptions),
    maxFileSize: options2.maxFileSize,
    encoding: folderOption.encoding,
    afterContext: options2.surroundingContext,
    beforeContext: options2.surroundingContext
  }));
}
function newToOldPreviewOptions(options2) {
  return {
    matchLines: options2?.matchLines ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS.matchLines,
    charsPerLine: options2?.charsPerLine ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS.charsPerLine
  };
}
function oldToNewTextSearchResult(result) {
  if (isTextSearchMatch(result)) {
    const ranges = asArray(result.ranges).map((r, i) => {
      const previewArr = asArray(result.preview.matches);
      const matchingPreviewRange = previewArr[i];
      return { sourceRange: r, previewRange: matchingPreviewRange };
    });
    return new TextSearchMatch2(result.uri, ranges, result.preview.text);
  } else {
    return new TextSearchContext2(result.uri, result.text, result.lineNumber);
  }
}
var OldTextSearchProviderConverter = class {
  constructor(provider) {
    this.provider = provider;
  }
  provideTextSearchResults(query, options2, progress, token) {
    const progressShim = (oldResult2) => {
      if (!validateProviderResult(oldResult2)) {
        return;
      }
      progress.report(oldToNewTextSearchResult(oldResult2));
    };
    const getResult = async () => {
      return coalesce(await Promise.all(newToOldTextProviderOptions(options2).map((o) => this.provider.provideTextSearchResults(query, o, { report: (e) => progressShim(e) }, token)))).reduce((prev, cur) => ({ limitHit: prev.limitHit || cur.limitHit }), { limitHit: false });
    };
    const oldResult = getResult();
    return oldResult.then((e) => {
      return {
        limitHit: e.limitHit,
        message: coalesce(asArray(e.message))
      };
    });
  }
};
function validateProviderResult(result) {
  if (extensionResultIsMatch(result)) {
    if (Array.isArray(result.ranges)) {
      if (!Array.isArray(result.preview.matches)) {
        console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same type.");
        return false;
      }
      if (result.preview.matches.length !== result.ranges.length) {
        console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.");
        return false;
      }
    } else {
      if (Array.isArray(result.preview.matches)) {
        console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.");
        return false;
      }
    }
  }
  return true;
}
function extensionResultIsMatch(data2) {
  return !!data2.preview;
}

// out-build/vs/workbench/services/search/common/folderQuerySearchTree.js
var FolderQuerySearchTree = class extends TernarySearchTree {
  constructor(folderQueries, getFolderQueryInfo, ignorePathCasing2 = () => false) {
    const uriIterator = new UriIterator(ignorePathCasing2, () => false);
    super(uriIterator);
    const fqBySameBase = new ResourceMap();
    folderQueries.forEach((fq, i) => {
      const uriWithoutQueryOrFragment = fq.folder.with({ query: "", fragment: "" });
      if (fqBySameBase.has(uriWithoutQueryOrFragment)) {
        fqBySameBase.get(uriWithoutQueryOrFragment).push({ fq, i });
      } else {
        fqBySameBase.set(uriWithoutQueryOrFragment, [{ fq, i }]);
      }
    });
    fqBySameBase.forEach((values, key) => {
      const folderQueriesWithQueries = /* @__PURE__ */ new Map();
      for (const fqBases of values) {
        const folderQueryInfo = getFolderQueryInfo(fqBases.fq, fqBases.i);
        folderQueriesWithQueries.set(this.encodeKey(fqBases.fq.folder), folderQueryInfo);
      }
      super.set(key, folderQueriesWithQueries);
    });
  }
  findQueryFragmentAwareSubstr(key) {
    const baseURIResult = super.findSubstr(key.with({ query: "", fragment: "" }));
    if (!baseURIResult) {
      return void 0;
    }
    const queryAndFragmentKey = this.encodeKey(key);
    return baseURIResult.get(queryAndFragmentKey);
  }
  forEachFolderQueryInfo(fn) {
    return this.forEach((elem) => elem.forEach((mapElem) => fn(mapElem)));
  }
  encodeKey(key) {
    let str = "";
    if (key.query) {
      str += key.query;
    }
    if (key.fragment) {
      str += "#" + key.fragment;
    }
    return str;
  }
};

// out-build/vs/workbench/services/search/common/fileSearchManager.js
var FileSearchEngine = class {
  constructor(config, provider, sessionLifecycle) {
    this.config = config;
    this.provider = provider;
    this.sessionLifecycle = sessionLifecycle;
    this.isLimitHit = false;
    this.resultCount = 0;
    this.isCanceled = false;
    this.filePattern = config.filePattern;
    this.includePattern = config.includePattern && parse3(config.includePattern);
    this.maxResults = config.maxResults || void 0;
    this.exists = config.exists;
    this.activeCancellationTokens = /* @__PURE__ */ new Set();
    this.globalExcludePattern = config.excludePattern && parse3(config.excludePattern);
  }
  cancel() {
    this.isCanceled = true;
    this.activeCancellationTokens.forEach((t) => t.cancel());
    this.activeCancellationTokens = /* @__PURE__ */ new Set();
  }
  search(_onResult) {
    const folderQueries = this.config.folderQueries || [];
    return new Promise((resolve2, reject) => {
      const onResult = (match2) => {
        this.resultCount++;
        _onResult(match2);
      };
      if (this.isCanceled) {
        return resolve2({ limitHit: this.isLimitHit });
      }
      if (this.config.extraFileResources) {
        this.config.extraFileResources.forEach((extraFile) => {
          const extraFileStr = extraFile.toString();
          const basename3 = basename(extraFileStr);
          if (this.globalExcludePattern && this.globalExcludePattern(extraFileStr, basename3)) {
            return;
          }
          this.matchFile(onResult, { base: extraFile, basename: basename3 });
        });
      }
      this.doSearch(folderQueries, onResult).then((stats) => {
        resolve2({
          limitHit: this.isLimitHit,
          stats: stats || void 0
          // Only looking at single-folder workspace stats...
        });
      }, (err) => {
        reject(new Error(toErrorMessage(err)));
      });
    });
  }
  async doSearch(fqs, onResult) {
    const cancellation = new CancellationTokenSource();
    const folderOptions = fqs.map((fq) => this.getSearchOptionsForFolder(fq));
    const session = this.provider instanceof OldFileSearchProviderConverter ? this.sessionLifecycle?.tokenSource.token : this.sessionLifecycle?.obj;
    const options2 = {
      folderOptions,
      maxResults: this.config.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,
      session
    };
    const getFolderQueryInfo = (fq) => {
      const queryTester = new QueryGlobTester(this.config, fq);
      const noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();
      return { queryTester, noSiblingsClauses, folder: fq.folder, tree: this.initDirectoryTree() };
    };
    const folderMappings = new FolderQuerySearchTree(fqs, getFolderQueryInfo);
    let providerSW;
    try {
      this.activeCancellationTokens.add(cancellation);
      providerSW = StopWatch.create();
      const results = await this.provider.provideFileSearchResults(this.config.filePattern || "", options2, cancellation.token);
      const providerTime = providerSW.elapsed();
      const postProcessSW = StopWatch.create();
      if (this.isCanceled && !this.isLimitHit) {
        return null;
      }
      if (results) {
        results.forEach((result) => {
          const fqFolderInfo = folderMappings.findQueryFragmentAwareSubstr(result);
          const relativePath2 = posix.relative(fqFolderInfo.folder.path, result.path);
          if (fqFolderInfo.noSiblingsClauses) {
            const basename3 = basename(result.path);
            this.matchFile(onResult, { base: fqFolderInfo.folder, relativePath: relativePath2, basename: basename3 });
            return;
          }
          this.addDirectoryEntries(fqFolderInfo.tree, fqFolderInfo.folder, relativePath2, onResult);
        });
      }
      if (this.isCanceled && !this.isLimitHit) {
        return null;
      }
      folderMappings.forEachFolderQueryInfo((e) => {
        this.matchDirectoryTree(e.tree, e.queryTester, onResult);
      });
      return {
        providerTime,
        postProcessTime: postProcessSW.elapsed()
      };
    } finally {
      cancellation.dispose();
      this.activeCancellationTokens.delete(cancellation);
    }
  }
  getSearchOptionsForFolder(fq) {
    const includes = resolvePatternsForProvider(this.config.includePattern, fq.includePattern);
    let excludePattern = fq.excludePattern?.map((e) => ({
      folder: e.folder,
      patterns: resolvePatternsForProvider(this.config.excludePattern, e.pattern)
    }));
    if (!excludePattern?.length) {
      excludePattern = [{
        folder: void 0,
        patterns: resolvePatternsForProvider(this.config.excludePattern, void 0)
      }];
    }
    const excludes = excludeToGlobPattern(excludePattern);
    return {
      folder: fq.folder,
      excludes,
      includes,
      useIgnoreFiles: {
        local: !fq.disregardIgnoreFiles,
        parent: !fq.disregardParentIgnoreFiles,
        global: !fq.disregardGlobalIgnoreFiles
      },
      followSymlinks: !fq.ignoreSymlinks
    };
  }
  initDirectoryTree() {
    const tree = {
      rootEntries: [],
      pathToEntries: /* @__PURE__ */ Object.create(null)
    };
    tree.pathToEntries["."] = tree.rootEntries;
    return tree;
  }
  addDirectoryEntries({ pathToEntries }, base, relativeFile, onResult) {
    if (relativeFile === this.filePattern) {
      const basename3 = basename(this.filePattern);
      this.matchFile(onResult, { base, relativePath: this.filePattern, basename: basename3 });
    }
    function add(relativePath2) {
      const basename3 = basename(relativePath2);
      const dirname3 = dirname(relativePath2);
      let entries = pathToEntries[dirname3];
      if (!entries) {
        entries = pathToEntries[dirname3] = [];
        add(dirname3);
      }
      entries.push({
        base,
        relativePath: relativePath2,
        basename: basename3
      });
    }
    add(relativeFile);
  }
  matchDirectoryTree({ rootEntries, pathToEntries }, queryTester, onResult) {
    const self2 = this;
    const filePattern = this.filePattern;
    function matchDirectory(entries) {
      const hasSibling = hasSiblingFn(() => entries.map((entry) => entry.basename));
      for (let i = 0, n = entries.length; i < n; i++) {
        const entry = entries[i];
        const { relativePath: relativePath2, basename: basename3 } = entry;
        if (queryTester.matchesExcludesSync(relativePath2, basename3, filePattern !== basename3 ? hasSibling : void 0)) {
          continue;
        }
        const sub = pathToEntries[relativePath2];
        if (sub) {
          matchDirectory(sub);
        } else {
          if (relativePath2 === filePattern) {
            continue;
          }
          self2.matchFile(onResult, entry);
        }
        if (self2.isLimitHit) {
          break;
        }
      }
    }
    matchDirectory(rootEntries);
  }
  matchFile(onResult, candidate) {
    if (!this.includePattern || candidate.relativePath && this.includePattern(candidate.relativePath, candidate.basename)) {
      if (this.exists || this.maxResults && this.resultCount >= this.maxResults) {
        this.isLimitHit = true;
        this.cancel();
      }
      if (!this.isLimitHit) {
        onResult(candidate);
      }
    }
  }
};
var SessionLifecycle = class {
  constructor() {
    this._obj = new Object();
    this.tokenSource = new CancellationTokenSource();
  }
  get obj() {
    if (this._obj) {
      return this._obj;
    }
    throw new Error("Session object has been dereferenced.");
  }
  cancel() {
    this.tokenSource.cancel();
    this._obj = void 0;
  }
};
var FileSearchManager = class _FileSearchManager {
  constructor() {
    this.sessions = /* @__PURE__ */ new Map();
  }
  static {
    this.BATCH_SIZE = 512;
  }
  fileSearch(config, provider, onBatch, token) {
    const sessionTokenSource = this.getSessionTokenSource(config.cacheKey);
    const engine = new FileSearchEngine(config, provider, sessionTokenSource);
    let resultCount = 0;
    const onInternalResult = (batch) => {
      resultCount += batch.length;
      onBatch(batch.map((m) => this.rawMatchToSearchItem(m)));
    };
    return this.doSearch(engine, _FileSearchManager.BATCH_SIZE, onInternalResult, token).then((result) => {
      return {
        limitHit: result.limitHit,
        stats: result.stats ? {
          fromCache: false,
          type: "fileSearchProvider",
          resultCount,
          detailStats: result.stats
        } : void 0,
        messages: []
      };
    });
  }
  clearCache(cacheKey) {
    this.sessions.get(cacheKey)?.cancel();
    this.sessions.delete(cacheKey);
  }
  getSessionTokenSource(cacheKey) {
    if (!cacheKey) {
      return void 0;
    }
    if (!this.sessions.has(cacheKey)) {
      this.sessions.set(cacheKey, new SessionLifecycle());
    }
    return this.sessions.get(cacheKey);
  }
  rawMatchToSearchItem(match2) {
    if (match2.relativePath) {
      return {
        resource: joinPath(match2.base, match2.relativePath)
      };
    } else {
      return {
        resource: match2.base
      };
    }
  }
  doSearch(engine, batchSize, onResultBatch, token) {
    const listener = token.onCancellationRequested(() => {
      engine.cancel();
    });
    const _onResult = (match2) => {
      if (match2) {
        batch.push(match2);
        if (batchSize > 0 && batch.length >= batchSize) {
          onResultBatch(batch);
          batch = [];
        }
      }
    };
    let batch = [];
    return engine.search(_onResult).then((result) => {
      if (batch.length) {
        onResultBatch(batch);
      }
      listener.dispose();
      return result;
    }, (error) => {
      if (batch.length) {
        onResultBatch(batch);
      }
      listener.dispose();
      return Promise.reject(error);
    });
  }
};

// out-build/vs/workbench/services/search/common/textSearchManager.js
var TextSearchManager = class {
  constructor(queryProviderPair, fileUtils, processType) {
    this.queryProviderPair = queryProviderPair;
    this.fileUtils = fileUtils;
    this.processType = processType;
    this.collector = null;
    this.isLimitHit = false;
    this.resultCount = 0;
  }
  get query() {
    return this.queryProviderPair.query;
  }
  search(onProgress, token, onKeywordResult) {
    const folderQueries = this.query.folderQueries || [];
    const tokenSource = new CancellationTokenSource(token);
    return new Promise((resolve2, reject) => {
      this.collector = new TextSearchResultsCollector(onProgress);
      let isCanceled = false;
      const onResult = (result, folderIdx) => {
        if (result instanceof AISearchKeyword) {
          return;
        }
        if (isCanceled) {
          return;
        }
        if (!this.isLimitHit) {
          const resultSize = this.resultSize(result);
          if (result instanceof TextSearchMatch2 && typeof this.query.maxResults === "number" && this.resultCount + resultSize > this.query.maxResults) {
            this.isLimitHit = true;
            isCanceled = true;
            tokenSource.cancel();
            result = this.trimResultToSize(result, this.query.maxResults - this.resultCount);
          }
          const newResultSize = this.resultSize(result);
          this.resultCount += newResultSize;
          const a = result instanceof TextSearchMatch2;
          if (newResultSize > 0 || !a) {
            this.collector.add(result, folderIdx);
          }
        }
      };
      this.doSearch(folderQueries, onResult, tokenSource.token, onKeywordResult).then((result) => {
        tokenSource.dispose();
        this.collector.flush();
        resolve2({
          limitHit: this.isLimitHit || result?.limitHit,
          messages: this.getMessagesFromResults(result),
          stats: {
            type: this.processType
          }
        });
      }, (err) => {
        tokenSource.dispose();
        const errMsg = toErrorMessage(err);
        reject(new Error(errMsg));
      });
    });
  }
  getMessagesFromResults(result) {
    if (!result?.message) {
      return [];
    }
    if (Array.isArray(result.message)) {
      return result.message;
    }
    return [result.message];
  }
  resultSize(result) {
    if (result instanceof TextSearchMatch2) {
      return Array.isArray(result.ranges) ? result.ranges.length : 1;
    } else {
      return 0;
    }
  }
  trimResultToSize(result, size) {
    return new TextSearchMatch2(result.uri, result.ranges.slice(0, size), result.previewText);
  }
  async doSearch(folderQueries, onResult, token, onKeywordResult) {
    const folderMappings = new FolderQuerySearchTree(folderQueries, (fq, i) => {
      const queryTester = new QueryGlobTester(this.query, fq);
      return { queryTester, folder: fq.folder, folderIdx: i };
    }, () => true);
    const testingPs = [];
    const progress = {
      report: (result2) => {
        if (result2 instanceof AISearchKeyword) {
          onKeywordResult?.(result2);
        } else {
          if (result2.uri === void 0) {
            throw Error("Text search result URI is undefined. Please check provider implementation.");
          }
          const folderQuery = folderMappings.findQueryFragmentAwareSubstr(result2.uri);
          const hasSibling = folderQuery.folder.scheme === Schemas.file ? hasSiblingPromiseFn(() => {
            return this.fileUtils.readdir(dirname2(result2.uri));
          }) : void 0;
          const relativePath2 = relativePath(folderQuery.folder, result2.uri);
          if (relativePath2) {
            const included = folderQuery.queryTester.includedInQuery(relativePath2, basename(relativePath2), hasSibling);
            if (isThenable(included)) {
              testingPs.push(included.then((isIncluded) => {
                if (isIncluded) {
                  onResult(result2, folderQuery.folderIdx);
                }
              }));
            } else if (included) {
              onResult(result2, folderQuery.folderIdx);
            }
          }
        }
      }
    };
    const folderOptions = folderQueries.map((fq) => this.getSearchOptionsForFolder(fq));
    const searchOptions = {
      folderOptions,
      maxFileSize: this.query.maxFileSize,
      maxResults: this.query.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,
      previewOptions: this.query.previewOptions ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS,
      surroundingContext: this.query.surroundingContext ?? 0
    };
    if ("usePCRE2" in this.query) {
      searchOptions.usePCRE2 = this.query.usePCRE2;
    }
    let result;
    if (this.queryProviderPair.query.type === 3) {
      result = await this.queryProviderPair.provider.provideAITextSearchResults(this.queryProviderPair.query.contentPattern, searchOptions, progress, token);
    } else {
      result = await this.queryProviderPair.provider.provideTextSearchResults(patternInfoToQuery(this.queryProviderPair.query.contentPattern), searchOptions, progress, token);
    }
    if (testingPs.length) {
      await Promise.all(testingPs);
    }
    return result;
  }
  getSearchOptionsForFolder(fq) {
    const includes = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);
    let excludePattern = fq.excludePattern?.map((e) => ({
      folder: e.folder,
      patterns: resolvePatternsForProvider(this.query.excludePattern, e.pattern)
    }));
    if (!excludePattern || excludePattern.length === 0) {
      excludePattern = [{
        folder: void 0,
        patterns: resolvePatternsForProvider(this.query.excludePattern, void 0)
      }];
    }
    const excludes = excludeToGlobPattern(excludePattern);
    const options2 = {
      folder: URI.from(fq.folder),
      excludes,
      includes,
      useIgnoreFiles: {
        local: !fq.disregardIgnoreFiles,
        parent: !fq.disregardParentIgnoreFiles,
        global: !fq.disregardGlobalIgnoreFiles
      },
      followSymlinks: !fq.ignoreSymlinks,
      encoding: (fq.fileEncoding && this.fileUtils.toCanonicalName(fq.fileEncoding)) ?? ""
    };
    return options2;
  }
};
function patternInfoToQuery(patternInfo) {
  return {
    isCaseSensitive: patternInfo.isCaseSensitive || false,
    isRegExp: patternInfo.isRegExp || false,
    isWordMatch: patternInfo.isWordMatch || false,
    isMultiline: patternInfo.isMultiline || false,
    pattern: patternInfo.pattern
  };
}
var TextSearchResultsCollector = class {
  constructor(_onResult) {
    this._onResult = _onResult;
    this._currentFolderIdx = -1;
    this._currentFileMatch = null;
    this._batchedCollector = new BatchedCollector(512, (items) => this.sendItems(items));
  }
  add(data2, folderIdx) {
    if (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !isEqual(this._currentUri, data2.uri))) {
      this.pushToCollector();
      this._currentFileMatch = null;
    }
    if (!this._currentFileMatch) {
      this._currentFolderIdx = folderIdx;
      this._currentFileMatch = {
        resource: data2.uri,
        results: []
      };
    }
    this._currentFileMatch.results.push(extensionResultToFrontendResult(data2));
  }
  pushToCollector() {
    const size = this._currentFileMatch && this._currentFileMatch.results ? this._currentFileMatch.results.length : 0;
    this._batchedCollector.addItem(this._currentFileMatch, size);
  }
  flush() {
    this.pushToCollector();
    this._batchedCollector.flush();
  }
  sendItems(items) {
    this._onResult(items);
  }
};
function extensionResultToFrontendResult(data2) {
  if (data2 instanceof TextSearchMatch2) {
    return {
      previewText: data2.previewText,
      rangeLocations: data2.ranges.map((r) => ({
        preview: {
          startLineNumber: r.previewRange.start.line,
          startColumn: r.previewRange.start.character,
          endLineNumber: r.previewRange.end.line,
          endColumn: r.previewRange.end.character
        },
        source: {
          startLineNumber: r.sourceRange.start.line,
          startColumn: r.sourceRange.start.character,
          endLineNumber: r.sourceRange.end.line,
          endColumn: r.sourceRange.end.character
        }
      }))
    };
  } else {
    return {
      text: data2.text,
      lineNumber: data2.lineNumber
    };
  }
}
var BatchedCollector = class _BatchedCollector {
  static {
    this.TIMEOUT = 4e3;
  }
  static {
    this.START_BATCH_AFTER_COUNT = 50;
  }
  constructor(maxBatchSize, cb) {
    this.maxBatchSize = maxBatchSize;
    this.cb = cb;
    this.totalNumberCompleted = 0;
    this.batch = [];
    this.batchSize = 0;
  }
  addItem(item, size) {
    if (!item) {
      return;
    }
    this.addItemToBatch(item, size);
  }
  addItems(items, size) {
    if (!items) {
      return;
    }
    this.addItemsToBatch(items, size);
  }
  addItemToBatch(item, size) {
    this.batch.push(item);
    this.batchSize += size;
    this.onUpdate();
  }
  addItemsToBatch(item, size) {
    this.batch = this.batch.concat(item);
    this.batchSize += size;
    this.onUpdate();
  }
  onUpdate() {
    if (this.totalNumberCompleted < _BatchedCollector.START_BATCH_AFTER_COUNT) {
      this.flush();
    } else if (this.batchSize >= this.maxBatchSize) {
      this.flush();
    } else if (!this.timeoutHandle) {
      this.timeoutHandle = setTimeout(() => {
        this.flush();
      }, _BatchedCollector.TIMEOUT);
    }
  }
  flush() {
    if (this.batchSize) {
      this.totalNumberCompleted += this.batchSize;
      this.cb(this.batch);
      this.batch = [];
      this.batchSize = 0;
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = void 0;
      }
    }
  }
};

// out-build/vs/workbench/api/common/extHostSearch.js
var IExtHostSearch = createDecorator("IExtHostSearch");
var ExtHostSearch = class ExtHostSearch2 {
  constructor(extHostRpc, _uriTransformer, _logService) {
    this.extHostRpc = extHostRpc;
    this._uriTransformer = _uriTransformer;
    this._logService = _logService;
    this._proxy = this.extHostRpc.getProxy(MainContext.MainThreadSearch);
    this._handlePool = 0;
    this._textSearchProvider = /* @__PURE__ */ new Map();
    this._textSearchUsedSchemes = /* @__PURE__ */ new Set();
    this._aiTextSearchProvider = /* @__PURE__ */ new Map();
    this._aiTextSearchUsedSchemes = /* @__PURE__ */ new Set();
    this._fileSearchProvider = /* @__PURE__ */ new Map();
    this._fileSearchUsedSchemes = /* @__PURE__ */ new Set();
    this._fileSearchManager = new FileSearchManager();
  }
  _transformScheme(scheme) {
    return this._uriTransformer.transformOutgoingScheme(scheme);
  }
  registerTextSearchProviderOld(scheme, provider) {
    if (this._textSearchUsedSchemes.has(scheme)) {
      throw new Error(`a text search provider for the scheme '${scheme}' is already registered`);
    }
    this._textSearchUsedSchemes.add(scheme);
    const handle = this._handlePool++;
    this._textSearchProvider.set(handle, new OldTextSearchProviderConverter(provider));
    this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));
    return toDisposable(() => {
      this._textSearchUsedSchemes.delete(scheme);
      this._textSearchProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  registerTextSearchProvider(scheme, provider) {
    if (this._textSearchUsedSchemes.has(scheme)) {
      throw new Error(`a text search provider for the scheme '${scheme}' is already registered`);
    }
    this._textSearchUsedSchemes.add(scheme);
    const handle = this._handlePool++;
    this._textSearchProvider.set(handle, provider);
    this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));
    return toDisposable(() => {
      this._textSearchUsedSchemes.delete(scheme);
      this._textSearchProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  registerAITextSearchProvider(scheme, provider) {
    if (this._aiTextSearchUsedSchemes.has(scheme)) {
      throw new Error(`an AI text search provider for the scheme '${scheme}'is already registered`);
    }
    this._aiTextSearchUsedSchemes.add(scheme);
    const handle = this._handlePool++;
    this._aiTextSearchProvider.set(handle, provider);
    this._proxy.$registerAITextSearchProvider(handle, this._transformScheme(scheme));
    return toDisposable(() => {
      this._aiTextSearchUsedSchemes.delete(scheme);
      this._aiTextSearchProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  registerFileSearchProviderOld(scheme, provider) {
    if (this._fileSearchUsedSchemes.has(scheme)) {
      throw new Error(`a file search provider for the scheme '${scheme}' is already registered`);
    }
    this._fileSearchUsedSchemes.add(scheme);
    const handle = this._handlePool++;
    this._fileSearchProvider.set(handle, new OldFileSearchProviderConverter(provider));
    this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));
    return toDisposable(() => {
      this._fileSearchUsedSchemes.delete(scheme);
      this._fileSearchProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  registerFileSearchProvider(scheme, provider) {
    if (this._fileSearchUsedSchemes.has(scheme)) {
      throw new Error(`a file search provider for the scheme '${scheme}' is already registered`);
    }
    this._fileSearchUsedSchemes.add(scheme);
    const handle = this._handlePool++;
    this._fileSearchProvider.set(handle, provider);
    this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));
    return toDisposable(() => {
      this._fileSearchUsedSchemes.delete(scheme);
      this._fileSearchProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  $provideFileSearchResults(handle, session, rawQuery, token) {
    const query = reviveQuery(rawQuery);
    const provider = this._fileSearchProvider.get(handle);
    if (provider) {
      return this._fileSearchManager.fileSearch(query, provider, (batch) => {
        this._proxy.$handleFileMatch(handle, session, batch.map((p) => p.resource));
      }, token);
    } else {
      throw new Error("unknown provider: " + handle);
    }
  }
  async doInternalFileSearchWithCustomCallback(query, token, handleFileMatch) {
    return { messages: [] };
  }
  $clearCache(cacheKey) {
    this._fileSearchManager.clearCache(cacheKey);
    return Promise.resolve(void 0);
  }
  $provideTextSearchResults(handle, session, rawQuery, token) {
    const provider = this._textSearchProvider.get(handle);
    if (!provider || !provider.provideTextSearchResults) {
      throw new Error(`Unknown Text Search Provider ${handle}`);
    }
    const query = reviveQuery(rawQuery);
    const engine = this.createTextSearchManager(query, provider);
    return engine.search((progress) => this._proxy.$handleTextMatch(handle, session, progress), token);
  }
  $provideAITextSearchResults(handle, session, rawQuery, token) {
    const provider = this._aiTextSearchProvider.get(handle);
    if (!provider || !provider.provideAITextSearchResults) {
      throw new Error(`Unknown AI Text Search Provider ${handle}`);
    }
    const query = reviveQuery(rawQuery);
    const engine = this.createAITextSearchManager(query, provider);
    return engine.search((progress) => this._proxy.$handleTextMatch(handle, session, progress), token, (result) => this._proxy.$handleKeywordResult(handle, session, result));
  }
  $enableExtensionHostSearch() {
  }
  async $getAIName(handle) {
    const provider = this._aiTextSearchProvider.get(handle);
    if (!provider || !provider.provideAITextSearchResults) {
      return void 0;
    }
    return provider.name ?? "AI";
  }
  createTextSearchManager(query, provider) {
    return new TextSearchManager({ query, provider }, {
      readdir: (resource) => Promise.resolve([]),
      toCanonicalName: (encoding) => encoding
    }, "textSearchProvider");
  }
  createAITextSearchManager(query, provider) {
    return new TextSearchManager({ query, provider }, {
      readdir: (resource) => Promise.resolve([]),
      toCanonicalName: (encoding) => encoding
    }, "aiTextSearchProvider");
  }
};
ExtHostSearch = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IURITransformerService),
  __param(2, ILogService)
], ExtHostSearch);
function reviveQuery(rawQuery) {
  return {
    // eslint-disable-next-line local/code-no-any-casts
    ...rawQuery,
    // TODO@rob ???
    ...{
      folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),
      extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map((components) => URI.revive(components))
    }
  };
}
function reviveFolderQuery(rawFolderQuery) {
  return revive(rawFolderQuery);
}

// out-build/vs/workbench/api/common/extHostLoggerService.js
var ExtHostLoggerService = class ExtHostLoggerService2 extends AbstractLoggerService {
  constructor(rpc, initData) {
    super(initData.logLevel, initData.logsLocation, initData.loggers.map((logger) => revive(logger)));
    this._proxy = rpc.getProxy(MainContext.MainThreadLogger);
  }
  $setLogLevel(logLevel, resource) {
    if (resource) {
      this.setLogLevel(URI.revive(resource), logLevel);
    } else {
      this.setLogLevel(logLevel);
    }
  }
  setVisibility(resource, visibility) {
    super.setVisibility(resource, visibility);
    this._proxy.$setVisibility(resource, visibility);
  }
  doCreateLogger(resource, logLevel, options2) {
    return new Logger(this._proxy, resource, logLevel, options2);
  }
};
ExtHostLoggerService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService)
], ExtHostLoggerService);
var Logger = class extends AbstractMessageLogger {
  constructor(proxy, file, logLevel, loggerOptions) {
    super(loggerOptions?.logLevel === "always");
    this.proxy = proxy;
    this.file = file;
    this.isLoggerCreated = false;
    this.buffer = [];
    this.setLevel(logLevel);
    this.proxy.$createLogger(file, loggerOptions).then(() => {
      this.doLog(this.buffer);
      this.isLoggerCreated = true;
    });
  }
  log(level, message) {
    const messages = [[level, message]];
    if (this.isLoggerCreated) {
      this.doLog(messages);
    } else {
      this.buffer.push(...messages);
    }
  }
  doLog(messages) {
    this.proxy.$log(this.file, messages);
  }
  flush() {
    this.proxy.$flush(this.file);
  }
};

// out-build/vs/workbench/api/common/extHostTerminalShellIntegration.js
var IExtHostTerminalShellIntegration = createDecorator("IExtHostTerminalShellIntegration");
var ExtHostTerminalShellIntegration = class ExtHostTerminalShellIntegration2 extends Disposable {
  constructor(extHostRpc, _extHostTerminalService) {
    super();
    this._extHostTerminalService = _extHostTerminalService;
    this._activeShellIntegrations = /* @__PURE__ */ new Map();
    this._onDidChangeTerminalShellIntegration = new Emitter();
    this.onDidChangeTerminalShellIntegration = this._onDidChangeTerminalShellIntegration.event;
    this._onDidStartTerminalShellExecution = new Emitter();
    this.onDidStartTerminalShellExecution = this._onDidStartTerminalShellExecution.event;
    this._onDidEndTerminalShellExecution = new Emitter();
    this.onDidEndTerminalShellExecution = this._onDidEndTerminalShellExecution.event;
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadTerminalShellIntegration);
    this._register(toDisposable(() => {
      for (const [_, integration] of this._activeShellIntegrations) {
        integration.dispose();
      }
      this._activeShellIntegrations.clear();
    }));
  }
  $shellIntegrationChange(instanceId, supportsExecuteCommandApi) {
    const terminal = this._extHostTerminalService.getTerminalById(instanceId);
    if (!terminal) {
      return;
    }
    const apiTerminal = terminal.value;
    let shellIntegration = this._activeShellIntegrations.get(instanceId);
    if (!shellIntegration) {
      shellIntegration = new InternalTerminalShellIntegration(terminal.value, supportsExecuteCommandApi, this._onDidStartTerminalShellExecution);
      this._activeShellIntegrations.set(instanceId, shellIntegration);
      shellIntegration.store.add(terminal.onWillDispose(() => this._activeShellIntegrations.get(instanceId)?.dispose()));
      shellIntegration.store.add(shellIntegration.onDidRequestShellExecution((commandLine) => this._proxy.$executeCommand(instanceId, commandLine)));
      shellIntegration.store.add(shellIntegration.onDidRequestEndExecution((e) => this._onDidEndTerminalShellExecution.fire(e)));
      shellIntegration.store.add(shellIntegration.onDidRequestChangeShellIntegration((e) => this._onDidChangeTerminalShellIntegration.fire(e)));
      terminal.shellIntegration = shellIntegration.value;
    }
    this._onDidChangeTerminalShellIntegration.fire({
      terminal: apiTerminal,
      shellIntegration: shellIntegration.value
    });
  }
  $shellExecutionStart(instanceId, supportsExecuteCommandApi, commandLineValue, commandLineConfidence, isTrusted, cwd2) {
    if (!this._activeShellIntegrations.has(instanceId)) {
      this.$shellIntegrationChange(instanceId, supportsExecuteCommandApi);
    }
    const commandLine = {
      value: commandLineValue,
      confidence: commandLineConfidence,
      isTrusted
    };
    this._activeShellIntegrations.get(instanceId)?.startShellExecution(commandLine, this._convertCwdToUri(cwd2));
  }
  $shellExecutionEnd(instanceId, commandLineValue, commandLineConfidence, isTrusted, exitCode) {
    const commandLine = {
      value: commandLineValue,
      confidence: commandLineConfidence,
      isTrusted
    };
    this._activeShellIntegrations.get(instanceId)?.endShellExecution(commandLine, exitCode);
  }
  $shellExecutionData(instanceId, data2) {
    this._activeShellIntegrations.get(instanceId)?.emitData(data2);
  }
  $shellEnvChange(instanceId, shellEnvKeys, shellEnvValues, isTrusted) {
    this._activeShellIntegrations.get(instanceId)?.setEnv(shellEnvKeys, shellEnvValues, isTrusted);
  }
  $cwdChange(instanceId, cwd2) {
    this._activeShellIntegrations.get(instanceId)?.setCwd(this._convertCwdToUri(cwd2));
  }
  $closeTerminal(instanceId) {
    this._activeShellIntegrations.get(instanceId)?.dispose();
    this._activeShellIntegrations.delete(instanceId);
  }
  _convertCwdToUri(cwd2) {
    return cwd2 ? URI.file(cwd2) : void 0;
  }
};
ExtHostTerminalShellIntegration = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostTerminalService)
], ExtHostTerminalShellIntegration);
var InternalTerminalShellIntegration = class extends Disposable {
  get currentExecution() {
    return this._currentExecution;
  }
  constructor(_terminal, supportsExecuteCommandApi, _onDidStartTerminalShellExecution) {
    super();
    this._terminal = _terminal;
    this._onDidStartTerminalShellExecution = _onDidStartTerminalShellExecution;
    this._pendingExecutions = [];
    this.store = this._register(new DisposableStore());
    this._onDidRequestChangeShellIntegration = this._register(new Emitter());
    this.onDidRequestChangeShellIntegration = this._onDidRequestChangeShellIntegration.event;
    this._onDidRequestShellExecution = this._register(new Emitter());
    this.onDidRequestShellExecution = this._onDidRequestShellExecution.event;
    this._onDidRequestEndExecution = this._register(new Emitter());
    this.onDidRequestEndExecution = this._onDidRequestEndExecution.event;
    this._onDidRequestNewExecution = this._register(new Emitter());
    this.onDidRequestNewExecution = this._onDidRequestNewExecution.event;
    const that = this;
    this.value = {
      get cwd() {
        return that._cwd;
      },
      get env() {
        if (!that._env) {
          return void 0;
        }
        return Object.freeze({
          isTrusted: that._env.isTrusted,
          value: Object.freeze({ ...that._env.value })
        });
      },
      // executeCommand(commandLine: string): vscode.TerminalShellExecution;
      // executeCommand(executable: string, args: string[]): vscode.TerminalShellExecution;
      executeCommand(commandLineOrExecutable, args) {
        if (!supportsExecuteCommandApi) {
          throw new Error("This terminal does not support the executeCommand API.");
        }
        let commandLineValue = commandLineOrExecutable;
        if (args) {
          for (const arg of args) {
            const wrapInQuotes = !arg.match(/["'`]/) && arg.match(/\s/);
            if (wrapInQuotes) {
              commandLineValue += ` "${arg}"`;
            } else {
              commandLineValue += ` ${arg}`;
            }
          }
        }
        that._onDidRequestShellExecution.fire(commandLineValue);
        const commandLine = {
          value: commandLineValue,
          confidence: TerminalShellExecutionCommandLineConfidence.High,
          isTrusted: true
        };
        const execution = that.requestNewShellExecution(commandLine, that._cwd).value;
        return execution;
      }
    };
  }
  requestNewShellExecution(commandLine, cwd2) {
    const execution = new InternalTerminalShellExecution(commandLine, cwd2 ?? this._cwd);
    const unresolvedCommandLines = splitAndSanitizeCommandLine(commandLine.value);
    if (unresolvedCommandLines.length > 1) {
      this._currentExecutionProperties = {
        isMultiLine: true,
        unresolvedCommandLines: splitAndSanitizeCommandLine(commandLine.value)
      };
    }
    this._pendingExecutions.push(execution);
    this._onDidRequestNewExecution.fire(commandLine.value);
    return execution;
  }
  startShellExecution(commandLine, cwd2) {
    if (this._pendingEndingExecution) {
      this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._pendingEndingExecution.value, exitCode: void 0 });
      this._pendingEndingExecution = void 0;
    }
    if (this._currentExecution) {
      if (this._currentExecutionProperties?.isMultiLine && this._currentExecutionProperties.unresolvedCommandLines) {
        const subExecutionResult = isSubExecution(this._currentExecutionProperties.unresolvedCommandLines, commandLine);
        if (subExecutionResult) {
          this._currentExecutionProperties.unresolvedCommandLines = subExecutionResult.unresolvedCommandLines;
          return;
        }
      }
      this._currentExecution.endExecution(void 0);
      this._currentExecution.flush();
      this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._currentExecution.value, exitCode: void 0 });
    }
    let currentExecution;
    if (commandLine.confidence === TerminalShellExecutionCommandLineConfidence.High) {
      for (const [i, execution] of this._pendingExecutions.entries()) {
        if (execution.value.commandLine.value === commandLine.value) {
          currentExecution = execution;
          this._currentExecutionProperties = {
            isMultiLine: false,
            unresolvedCommandLines: void 0
          };
          currentExecution = execution;
          this._pendingExecutions.splice(i, 1);
          break;
        } else {
          const subExecutionResult = isSubExecution(splitAndSanitizeCommandLine(execution.value.commandLine.value), commandLine);
          if (subExecutionResult) {
            this._currentExecutionProperties = {
              isMultiLine: true,
              unresolvedCommandLines: subExecutionResult.unresolvedCommandLines
            };
            currentExecution = execution;
            this._pendingExecutions.splice(i, 1);
            break;
          }
        }
      }
    } else {
      currentExecution = this._pendingExecutions.shift();
    }
    if (!currentExecution) {
      currentExecution = new InternalTerminalShellExecution(commandLine, cwd2 ?? this._cwd);
    }
    this._currentExecution = currentExecution;
    this._onDidStartTerminalShellExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._currentExecution.value });
  }
  emitData(data2) {
    this.currentExecution?.emitData(data2);
  }
  endShellExecution(commandLine, exitCode) {
    if (this._currentExecutionProperties?.isMultiLine) {
      if (this._currentExecutionProperties.unresolvedCommandLines && this._currentExecutionProperties.unresolvedCommandLines.length > 0) {
        return;
      }
    }
    if (this._currentExecution) {
      const commandLineForEvent = this._currentExecutionProperties?.isMultiLine ? this._currentExecution.value.commandLine : commandLine;
      this._currentExecution.endExecution(commandLineForEvent);
      const currentExecution = this._currentExecution;
      this._pendingEndingExecution = currentExecution;
      this._currentExecution = void 0;
      currentExecution.flush().then(() => {
        if (this._pendingEndingExecution === currentExecution) {
          this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: currentExecution.value, exitCode });
          this._pendingEndingExecution = void 0;
        }
      });
    }
  }
  setEnv(keys, values, isTrusted) {
    const env2 = {};
    for (let i = 0; i < keys.length; i++) {
      env2[keys[i]] = values[i];
    }
    this._env = { value: env2, isTrusted };
    this._fireChangeEvent();
  }
  setCwd(cwd2) {
    let wasChanged = false;
    if (URI.isUri(this._cwd)) {
      wasChanged = !URI.isUri(cwd2) || this._cwd.toString() !== cwd2.toString();
    } else if (this._cwd !== cwd2) {
      wasChanged = true;
    }
    if (wasChanged) {
      this._cwd = cwd2;
      this._fireChangeEvent();
    }
  }
  _fireChangeEvent() {
    this._onDidRequestChangeShellIntegration.fire({ terminal: this._terminal, shellIntegration: this.value });
  }
};
var InternalTerminalShellExecution = class {
  constructor(_commandLine, cwd2) {
    this._commandLine = _commandLine;
    this.cwd = cwd2;
    this._isEnded = false;
    const that = this;
    this.value = {
      get commandLine() {
        return that._commandLine;
      },
      get cwd() {
        return that.cwd;
      },
      read() {
        return that._createDataStream();
      }
    };
  }
  _createDataStream() {
    if (!this._dataStream) {
      if (this._isEnded) {
        return AsyncIterableObject.EMPTY;
      }
      this._dataStream = new ShellExecutionDataStream();
    }
    return this._dataStream.createIterable();
  }
  emitData(data2) {
    if (!this._isEnded) {
      this._dataStream?.emitData(data2);
    }
  }
  endExecution(commandLine) {
    if (commandLine) {
      this._commandLine = commandLine;
    }
    this._dataStream?.endExecution();
    this._isEnded = true;
  }
  async flush() {
    if (this._dataStream) {
      await this._dataStream.flush();
      this._dataStream.dispose();
      this._dataStream = void 0;
    }
  }
};
var ShellExecutionDataStream = class extends Disposable {
  constructor() {
    super(...arguments);
    this._iterables = [];
    this._emitters = [];
  }
  createIterable() {
    if (!this._barrier) {
      this._barrier = new Barrier();
    }
    const barrier = this._barrier;
    const iterable = new AsyncIterableObject(async (emitter) => {
      this._emitters.push(emitter);
      await barrier.wait();
    });
    this._iterables.push(iterable);
    return iterable;
  }
  emitData(data2) {
    for (const emitter of this._emitters) {
      emitter.emitOne(data2);
    }
  }
  endExecution() {
    this._barrier?.open();
  }
  async flush() {
    await Promise.all(this._iterables.map((e) => e.toPromise()));
  }
};
function splitAndSanitizeCommandLine(commandLine) {
  return commandLine.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
}
function isSubExecution(unresolvedCommandLines, commandLine) {
  if (unresolvedCommandLines.length === 0) {
    return false;
  }
  const newUnresolvedCommandLines = [...unresolvedCommandLines];
  const subExecutionLines = splitAndSanitizeCommandLine(commandLine.value);
  if (newUnresolvedCommandLines && newUnresolvedCommandLines.length > 0) {
    while (newUnresolvedCommandLines.length > 0) {
      if (newUnresolvedCommandLines[0] !== subExecutionLines[0]) {
        break;
      }
      newUnresolvedCommandLines.shift();
      subExecutionLines.shift();
    }
    if (subExecutionLines.length === 0) {
      return { unresolvedCommandLines: newUnresolvedCommandLines };
    }
  }
  return false;
}

// out-build/vs/base/common/sseParser.js
var Chr;
(function(Chr2) {
  Chr2[Chr2["CR"] = 13] = "CR";
  Chr2[Chr2["LF"] = 10] = "LF";
  Chr2[Chr2["COLON"] = 58] = "COLON";
  Chr2[Chr2["SPACE"] = 32] = "SPACE";
})(Chr || (Chr = {}));
var SSEParser = class {
  /**
   * Creates a new SSE parser.
   * @param onEvent The callback to invoke when an event is dispatched.
   */
  constructor(onEvent) {
    this.dataBuffer = "";
    this.eventTypeBuffer = "";
    this.buffer = [];
    this.endedOnCR = false;
    this.onEventHandler = onEvent;
    this.decoder = new TextDecoder("utf-8");
  }
  /**
   * Gets the last event ID received by this parser.
   */
  getLastEventId() {
    return this.lastEventIdBuffer;
  }
  /**
   * Gets the reconnection time in milliseconds, if one was specified by the server.
   */
  getReconnectionTime() {
    return this.reconnectionTime;
  }
  /**
   * Feeds a chunk of the SSE stream to the parser.
   * @param chunk The chunk to parse as a Uint8Array of UTF-8 encoded data.
   */
  feed(chunk) {
    if (chunk.length === 0) {
      return;
    }
    let offset = 0;
    if (this.endedOnCR && chunk[0] === 10) {
      offset++;
    }
    this.endedOnCR = false;
    while (offset < chunk.length) {
      const indexCR = chunk.indexOf(13, offset);
      const indexLF = chunk.indexOf(10, offset);
      const index = indexCR === -1 ? indexLF : indexLF === -1 ? indexCR : Math.min(indexCR, indexLF);
      if (index === -1) {
        break;
      }
      let str = "";
      for (const buf of this.buffer) {
        str += this.decoder.decode(buf, { stream: true });
      }
      str += this.decoder.decode(chunk.subarray(offset, index));
      this.processLine(str);
      this.buffer.length = 0;
      offset = index + (chunk[index] === 13 && chunk[index + 1] === 10 ? 2 : 1);
    }
    if (offset < chunk.length) {
      this.buffer.push(chunk.subarray(offset));
    } else {
      this.endedOnCR = chunk[chunk.length - 1] === 13;
    }
  }
  /**
   * Processes a single line from the SSE stream.
   */
  processLine(line) {
    if (!line.length) {
      this.dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      return;
    }
    let field;
    let value;
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1) {
      field = line;
      value = "";
    } else {
      field = line.substring(0, colonIndex);
      value = line.substring(colonIndex + 1);
      if (value.startsWith(" ")) {
        value = value.substring(1);
      }
    }
    this.processField(field, value);
  }
  /**
   * Processes a field with the given name and value.
   */
  processField(field, value) {
    switch (field) {
      case "event":
        this.eventTypeBuffer = value;
        break;
      case "data":
        this.dataBuffer += value;
        this.dataBuffer += "\n";
        break;
      case "id":
        if (!value.includes("\0")) {
          this.currentEventId = this.lastEventIdBuffer = value;
        } else {
          this.currentEventId = void 0;
        }
        break;
      case "retry":
        if (/^\d+$/.test(value)) {
          this.reconnectionTime = parseInt(value, 10);
        }
        break;
    }
  }
  /**
   * Dispatches the event based on the current buffer states.
   */
  dispatchEvent() {
    if (this.dataBuffer === "") {
      this.dataBuffer = "";
      this.eventTypeBuffer = "";
      return;
    }
    if (this.dataBuffer.endsWith("\n")) {
      this.dataBuffer = this.dataBuffer.substring(0, this.dataBuffer.length - 1);
    }
    const event = {
      type: this.eventTypeBuffer || "message",
      data: this.dataBuffer
    };
    if (this.currentEventId !== void 0) {
      event.id = this.currentEventId;
    }
    if (this.reconnectionTime !== void 0) {
      event.retry = this.reconnectionTime;
    }
    this.onEventHandler(event);
    this.reset();
  }
  /**
   * Resets the parser state.
   */
  reset() {
    this.dataBuffer = "";
    this.eventTypeBuffer = "";
    this.currentEventId = void 0;
  }
};

// out-build/vs/base/common/validation.js
var ValidatorBase = class {
  validateOrThrow(content) {
    const result = this.validate(content);
    if (result.error) {
      throw new Error(result.error.message);
    }
    return result.content;
  }
};
var TypeofValidator = class extends ValidatorBase {
  constructor(type) {
    super();
    this.type = type;
  }
  validate(content) {
    if (typeof content !== this.type) {
      return { content: void 0, error: { message: `Expected ${this.type}, but got ${typeof content}` } };
    }
    return { content, error: void 0 };
  }
  getJSONSchema() {
    return { type: this.type };
  }
};
var vStringValidator = new TypeofValidator("string");
function vString() {
  return vStringValidator;
}
var vNumberValidator = new TypeofValidator("number");
function vNumber() {
  return vNumberValidator;
}
var vBooleanValidator = new TypeofValidator("boolean");
var vObjAnyValidator = new TypeofValidator("object");
function vObjAny() {
  return vObjAnyValidator;
}
var Optional = class {
  constructor(validator) {
    this.validator = validator;
  }
};
function vOptionalProp(validator) {
  return new Optional(validator);
}
var ObjValidator = class extends ValidatorBase {
  constructor(properties) {
    super();
    this.properties = properties;
  }
  validate(content) {
    if (typeof content !== "object" || content === null) {
      return { content: void 0, error: { message: "Expected object" } };
    }
    const result = {};
    for (const key in this.properties) {
      const prop = this.properties[key];
      const fieldValue = content[key];
      const isOptional = prop instanceof Optional;
      const validator = isOptional ? prop.validator : prop;
      if (isOptional && fieldValue === void 0) {
        continue;
      }
      const { content: value, error } = validator.validate(fieldValue);
      if (error) {
        return { content: void 0, error: { message: `Error in property '${key}': ${error.message}` } };
      }
      result[key] = value;
    }
    return { content: result, error: void 0 };
  }
  getJSONSchema() {
    const requiredFields = [];
    const schemaProperties = {};
    for (const [key, prop] of Object.entries(this.properties)) {
      const isOptional = prop instanceof Optional;
      const validator = isOptional ? prop.validator : prop;
      schemaProperties[key] = validator.getJSONSchema();
      if (!isOptional) {
        requiredFields.push(key);
      }
    }
    const schema2 = {
      type: "object",
      properties: schemaProperties,
      ...requiredFields.length > 0 ? { required: requiredFields } : {}
    };
    return schema2;
  }
};
function vObj(properties) {
  return new ObjValidator(properties);
}
var ArrayValidator = class extends ValidatorBase {
  constructor(validator) {
    super();
    this.validator = validator;
  }
  validate(content) {
    if (!Array.isArray(content)) {
      return { content: void 0, error: { message: "Expected array" } };
    }
    const result = [];
    for (let i = 0; i < content.length; i++) {
      const { content: value, error } = this.validator.validate(content[i]);
      if (error) {
        return { content: void 0, error: { message: `Error in element ${i}: ${error.message}` } };
      }
      result.push(value);
    }
    return { content: result, error: void 0 };
  }
  getJSONSchema() {
    return {
      type: "array",
      items: this.validator.getJSONSchema()
    };
  }
};
function vArray(validator) {
  return new ArrayValidator(validator);
}

// out-build/vs/workbench/api/common/extHostMcp.js
var IExtHostMpcService = createDecorator("IExtHostMpcService");
var serverDataValidation = vObj({
  label: vString(),
  version: vOptionalProp(vString()),
  metadata: vOptionalProp(vObj({
    capabilities: vOptionalProp(vObjAny()),
    serverInfo: vOptionalProp(vObjAny()),
    tools: vOptionalProp(vArray(vObj({
      availability: vNumber(),
      definition: vObjAny()
    })))
  })),
  authentication: vOptionalProp(vObj({
    providerId: vString(),
    scopes: vArray(vString())
  }))
});
var ExtHostMcpService = class ExtHostMcpService2 extends Disposable {
  constructor(extHostRpc, _logService, _extHostInitData, _workspaceService, _variableResolver) {
    super();
    this._logService = _logService;
    this._extHostInitData = _extHostInitData;
    this._workspaceService = _workspaceService;
    this._variableResolver = _variableResolver;
    this._initialProviderPromises = /* @__PURE__ */ new Set();
    this._sseEventSources = this._register(new DisposableMap());
    this._unresolvedMcpServers = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadMcp);
  }
  $startMcp(id2, opts) {
    this._startMcp(id2, McpServerLaunch.fromSerialized(opts.launch), opts.defaultCwd && URI.revive(opts.defaultCwd), opts.errorOnUserInteraction);
  }
  _startMcp(id2, launch, _defaultCwd, errorOnUserInteraction) {
    if (launch.type === 2) {
      this._sseEventSources.set(id2, new McpHTTPHandle(id2, launch, this._proxy, this._logService, errorOnUserInteraction));
      return;
    }
    throw new Error("not implemented");
  }
  async $substituteVariables(_workspaceFolder, value) {
    const folderURI = URI.revive(_workspaceFolder);
    const folder = folderURI && await this._workspaceService.resolveWorkspaceFolder(folderURI);
    const variableResolver = await this._variableResolver.getResolver();
    return variableResolver.resolveAsync(folder && {
      uri: folder.uri,
      name: folder.name,
      index: folder.index
    }, value);
  }
  $stopMcp(id2) {
    this._sseEventSources.get(id2)?.close().then(() => this._didClose(id2));
  }
  _didClose(id2) {
    this._sseEventSources.deleteAndDispose(id2);
  }
  $sendMessage(id2, message) {
    this._sseEventSources.get(id2)?.send(message);
  }
  async $waitForInitialCollectionProviders() {
    await Promise.all(this._initialProviderPromises);
  }
  async $resolveMcpLaunch(collectionId, label) {
    const rec = this._unresolvedMcpServers.get(collectionId);
    if (!rec) {
      return;
    }
    const server = rec.servers.find((s) => s.label === label);
    if (!server) {
      return;
    }
    if (!rec.provider.resolveMcpServerDefinition) {
      return McpServerDefinition2.from(server);
    }
    const resolved = await rec.provider.resolveMcpServerDefinition(server, CancellationToken.None);
    return resolved ? McpServerDefinition2.from(resolved) : void 0;
  }
  /** {@link vscode.lm.registerMcpServerDefinitionProvider} */
  registerMcpConfigurationProvider(extension, id2, provider) {
    const store = new DisposableStore();
    const metadata = extension.contributes?.mcpServerDefinitionProviders?.find((m) => m.id === id2);
    if (!metadata) {
      throw new Error(`MCP configuration providers must be registered in the contributes.mcpServerDefinitionProviders array within your package.json, but "${id2}" was not`);
    }
    const mcp = {
      id: extensionPrefixedIdentifier(extension.identifier, id2),
      isTrustedByDefault: true,
      label: metadata?.label ?? extension.displayName ?? extension.name,
      scope: 1,
      canResolveLaunch: typeof provider.resolveMcpServerDefinition === "function",
      extensionId: extension.identifier.value,
      configTarget: this._extHostInitData.remote.isRemote ? 4 : 2
    };
    const update = async () => {
      const list2 = await provider.provideMcpServerDefinitions(CancellationToken.None);
      this._unresolvedMcpServers.set(mcp.id, { servers: list2 ?? [], provider });
      const servers = [];
      for (const item of list2 ?? []) {
        let id3 = ExtensionIdentifier.toKey(extension.identifier) + "/" + item.label;
        if (servers.some((s) => s.id === id3)) {
          let i = 2;
          while (servers.some((s) => s.id === id3 + i)) {
            i++;
          }
          id3 = id3 + i;
        }
        serverDataValidation.validateOrThrow(item);
        if (item.authentication) {
          checkProposedApiEnabled(extension, "mcpToolDefinitions");
        }
        let staticMetadata;
        const castAs2 = item;
        if (isProposedApiEnabled(extension, "mcpToolDefinitions") && castAs2.metadata) {
          staticMetadata = {
            capabilities: castAs2.metadata.capabilities,
            instructions: castAs2.metadata.instructions,
            serverInfo: castAs2.metadata.serverInfo,
            tools: castAs2.metadata.tools?.map((t) => ({
              availability: t.availability === McpToolAvailability.Dynamic ? 1 : 0,
              definition: t.definition
            }))
          };
        }
        servers.push({
          id: id3,
          label: item.label,
          cacheNonce: item.version || "$$NONE",
          staticMetadata,
          launch: McpServerDefinition2.from(item)
        });
      }
      this._proxy.$upsertMcpCollection(mcp, servers);
    };
    store.add(toDisposable(() => {
      this._unresolvedMcpServers.delete(mcp.id);
      this._proxy.$deleteMcpCollection(mcp.id);
    }));
    if (provider.onDidChangeMcpServerDefinitions) {
      store.add(provider.onDidChangeMcpServerDefinitions(update));
    }
    if (provider.onDidChangeServerDefinitions) {
      store.add(provider.onDidChangeServerDefinitions(update));
    }
    if (provider.onDidChange) {
      store.add(provider.onDidChange(update));
    }
    const promise = new Promise((resolve2) => {
      setTimeout(() => update().finally(() => {
        this._initialProviderPromises.delete(promise);
        resolve2();
      }), 0);
    });
    this._initialProviderPromises.add(promise);
    return store;
  }
};
ExtHostMcpService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService),
  __param(2, IExtHostInitDataService),
  __param(3, IExtHostWorkspace),
  __param(4, IExtHostVariableResolverProvider)
], ExtHostMcpService);
var HttpMode;
(function(HttpMode2) {
  HttpMode2[HttpMode2["Unknown"] = 0] = "Unknown";
  HttpMode2[HttpMode2["Http"] = 1] = "Http";
  HttpMode2[HttpMode2["SSE"] = 2] = "SSE";
})(HttpMode || (HttpMode = {}));
var MAX_FOLLOW_REDIRECTS = 5;
var REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];
var McpHTTPHandle = class extends Disposable {
  constructor(_id, _launch, _proxy, _logService, _errorOnUserInteraction) {
    super();
    this._id = _id;
    this._launch = _launch;
    this._proxy = _proxy;
    this._logService = _logService;
    this._errorOnUserInteraction = _errorOnUserInteraction;
    this._requestSequencer = new Sequencer();
    this._postEndpoint = new DeferredPromise();
    this._mode = {
      value: 0
      /* HttpMode.Unknown */
    };
    this._cts = new CancellationTokenSource();
    this._abortCtrl = new AbortController();
    this._didSendClose = false;
    this._register(toDisposable(() => {
      this._abortCtrl.abort();
      this._cts.dispose(true);
    }));
    this._proxy.$onDidChangeState(this._id, {
      state: 2
      /* McpConnectionState.Kind.Running */
    });
  }
  async send(message) {
    try {
      if (this._mode.value === 0) {
        await this._requestSequencer.queue(() => this._send(message));
      } else {
        await this._send(message);
      }
    } catch (err) {
      const msg = `Error sending message to ${this._launch.uri}: ${String(err)}`;
      this._proxy.$onDidChangeState(this._id, { state: 3, message: msg });
    }
  }
  async close() {
    if (this._mode.value === 1 && this._mode.sessionId && !this._didSendClose) {
      this._didSendClose = true;
      try {
        await this._closeSession(this._mode.sessionId);
      } catch {
      }
    }
    this._proxy.$onDidChangeState(this._id, {
      state: 0
      /* McpConnectionState.Kind.Stopped */
    });
  }
  async _closeSession(sessionId) {
    const headers = {
      ...Object.fromEntries(this._launch.headers),
      "Mcp-Session-Id": sessionId
    };
    await this._addAuthHeader(headers);
    await this._fetch(this._launch.uri.toString(true), {
      method: "DELETE",
      headers
    });
  }
  _send(message) {
    if (this._mode.value === 2) {
      return this._sendLegacySSE(this._mode.endpoint, message);
    } else {
      return this._sendStreamableHttp(message, this._mode.value === 1 ? this._mode.sessionId : void 0);
    }
  }
  /**
   * Sends a streamable-HTTP request.
   * 1. Posts to the endpoint
   * 2. Updates internal state as needed. Falls back to SSE if appropriate.
   * 3. If the response body is empty, JSON, or a JSON stream, handle it appropriately.
   */
  async _sendStreamableHttp(message, sessionId) {
    const asBytes = new TextEncoder().encode(message);
    const headers = {
      ...Object.fromEntries(this._launch.headers),
      "Content-Type": "application/json",
      "Content-Length": String(asBytes.length),
      Accept: "text/event-stream, application/json"
    };
    if (sessionId) {
      headers["Mcp-Session-Id"] = sessionId;
    }
    await this._addAuthHeader(headers);
    const res = await this._fetchWithAuthRetry(this._launch.uri.toString(true), {
      method: "POST",
      headers,
      body: asBytes
    }, headers);
    const wasUnknown = this._mode.value === 0;
    const nextSessionId = res.headers.get("Mcp-Session-Id");
    if (nextSessionId) {
      this._mode = { value: 1, sessionId: nextSessionId };
    }
    if (this._mode.value === 0 && // We care about 4xx errors...
    res.status >= 400 && res.status < 500 && !isAuthStatusCode(res.status)) {
      this._log(LogLevel.Info, `${res.status} status sending message to ${this._launch.uri}, will attempt to fall back to legacy SSE`);
      this._sseFallbackWithMessage(message);
      return;
    }
    if (res.status >= 300) {
      const retryWithSessionId = this._mode.value === 1 && !!this._mode.sessionId && (res.status === 400 || res.status === 404);
      this._proxy.$onDidChangeState(this._id, {
        state: 3,
        message: `${res.status} status sending message to ${this._launch.uri}: ${await this._getErrText(res)}` + (retryWithSessionId ? `; will retry with new session ID` : ""),
        shouldRetry: retryWithSessionId
      });
      return;
    }
    if (this._mode.value === 0) {
      this._mode = { value: 1, sessionId: void 0 };
    }
    if (wasUnknown) {
      this._attachStreamableBackchannel();
    }
    await this._handleSuccessfulStreamableHttp(res, message);
  }
  async _sseFallbackWithMessage(message) {
    const endpoint = await this._attachSSE();
    if (endpoint) {
      this._mode = { value: 2, endpoint };
      await this._sendLegacySSE(endpoint, message);
    }
  }
  async _populateAuthMetadata(mcpUrl, originalResponse) {
    const { resourceMetadataChallenge, scopesChallenge: scopesChallengeFromHeader } = this._parseWWWAuthenticateHeader(originalResponse);
    let serverMetadataUrl;
    let resource;
    let scopesChallenge = scopesChallengeFromHeader;
    try {
      const resourceMetadata = await fetchResourceMetadata(mcpUrl, resourceMetadataChallenge, {
        sameOriginHeaders: {
          ...Object.fromEntries(this._launch.headers),
          "MCP-Protocol-Version": MCP.LATEST_PROTOCOL_VERSION
        },
        fetch: (url, init) => this._fetch(url, init)
      });
      serverMetadataUrl = resourceMetadata.authorization_servers?.[0];
      this._log(LogLevel.Debug, `Using auth server metadata url: ${serverMetadataUrl}`);
      scopesChallenge ??= resourceMetadata.scopes_supported;
      resource = resourceMetadata;
    } catch (e) {
      this._log(LogLevel.Debug, `Could not fetch resource metadata: ${String(e)}`);
    }
    const baseUrl = new URL(originalResponse.url).origin;
    let additionalHeaders = {};
    if (!serverMetadataUrl) {
      serverMetadataUrl = baseUrl;
      additionalHeaders = {
        ...Object.fromEntries(this._launch.headers),
        "MCP-Protocol-Version": MCP.LATEST_PROTOCOL_VERSION
      };
    }
    try {
      this._log(LogLevel.Debug, `Fetching auth server metadata for: ${serverMetadataUrl} ...`);
      const serverMetadataResponse = await fetchAuthorizationServerMetadata(serverMetadataUrl, {
        additionalHeaders,
        fetch: (url, init) => this._fetch(url, init)
      });
      this._log(LogLevel.Info, "Populated auth metadata");
      this._authMetadata = {
        authorizationServer: URI.parse(serverMetadataUrl),
        serverMetadata: serverMetadataResponse,
        resourceMetadata: resource,
        scopes: scopesChallenge
      };
      return;
    } catch (e) {
      this._log(LogLevel.Warning, `Error populating auth server metadata for ${serverMetadataUrl}: ${String(e)}`);
    }
    const defaultMetadata = getDefaultMetadataForUrl(new URL(baseUrl));
    this._authMetadata = {
      authorizationServer: URI.parse(baseUrl),
      serverMetadata: defaultMetadata,
      resourceMetadata: resource,
      scopes: scopesChallenge
    };
    this._log(LogLevel.Info, "Using default auth metadata");
  }
  async _handleSuccessfulStreamableHttp(res, message) {
    if (res.status === 202) {
      return;
    }
    const contentType = res.headers.get("Content-Type")?.toLowerCase() || "";
    if (contentType.startsWith("text/event-stream")) {
      const parser2 = new SSEParser((event) => {
        if (event.type === "message") {
          this._proxy.$onDidReceiveMessage(this._id, event.data);
        } else if (event.type === "endpoint") {
          this._log(LogLevel.Warning, `Received SSE endpoint from a POST to ${this._launch.uri}, will fall back to legacy SSE`);
          this._sseFallbackWithMessage(message);
          throw new CancellationError();
        }
      });
      try {
        await this._doSSE(parser2, res);
      } catch (err) {
        this._log(LogLevel.Warning, `Error reading SSE stream: ${String(err)}`);
      }
    } else if (contentType.startsWith("application/json")) {
      this._proxy.$onDidReceiveMessage(this._id, await res.text());
    } else {
      const responseBody = await res.text();
      if (isJSON(responseBody)) {
        this._proxy.$onDidReceiveMessage(this._id, responseBody);
      } else {
        this._log(LogLevel.Warning, `Unexpected ${res.status} response for request: ${responseBody}`);
      }
    }
  }
  /**
   * Attaches the SSE backchannel that streamable HTTP servers can use
   * for async notifications. This is a "MAY" support, so if the server gives
   * us a 4xx code, we'll stop trying to connect..
   */
  async _attachStreamableBackchannel() {
    let lastEventId;
    let canReconnectAt;
    for (let retry = 0; !this._store.isDisposed; retry++) {
      if (canReconnectAt !== void 0) {
        await timeout(Math.max(0, canReconnectAt - Date.now()), this._cts.token);
        canReconnectAt = void 0;
      } else {
        await timeout(Math.min(retry * 1e3, 3e4), this._cts.token);
      }
      let res;
      try {
        const headers = {
          ...Object.fromEntries(this._launch.headers),
          "Accept": "text/event-stream"
        };
        await this._addAuthHeader(headers);
        if (this._mode.value === 1 && this._mode.sessionId !== void 0) {
          headers["Mcp-Session-Id"] = this._mode.sessionId;
        }
        if (lastEventId) {
          headers["Last-Event-ID"] = lastEventId;
        }
        res = await this._fetchWithAuthRetry(this._launch.uri.toString(true), {
          method: "GET",
          headers
        }, headers);
      } catch (e) {
        this._log(LogLevel.Info, `Error connecting to ${this._launch.uri} for async notifications, will retry`);
        continue;
      }
      if (res.status >= 400) {
        this._log(LogLevel.Debug, `${res.status} status connecting to ${this._launch.uri} for async notifications; they will be disabled: ${await this._getErrText(res)}`);
        return;
      }
      if (res.headers.get("content-type")?.toLowerCase().includes("text/event-stream")) {
        retry = 0;
      }
      const parser2 = new SSEParser((event) => {
        if (event.retry) {
          canReconnectAt = Date.now() + event.retry;
        }
        if (event.type === "message" && event.data) {
          this._proxy.$onDidReceiveMessage(this._id, event.data);
        }
        if (event.id) {
          lastEventId = event.id;
        }
      });
      try {
        await this._doSSE(parser2, res);
      } catch (e) {
        this._log(LogLevel.Info, `Error reading from async stream, we will reconnect: ${e}`);
      }
    }
  }
  /**
   * Starts a legacy SSE attachment, where the SSE response is the session lifetime.
   * Unlike `_attachStreamableBackchannel`, this fails the server if it disconnects.
   */
  async _attachSSE() {
    const postEndpoint = new DeferredPromise();
    const headers = {
      ...Object.fromEntries(this._launch.headers),
      "Accept": "text/event-stream"
    };
    await this._addAuthHeader(headers);
    let res;
    try {
      res = await this._fetchWithAuthRetry(this._launch.uri.toString(true), {
        method: "GET",
        headers
      }, headers);
      if (res.status >= 300) {
        this._proxy.$onDidChangeState(this._id, { state: 3, message: `${res.status} status connecting to ${this._launch.uri} as SSE: ${await this._getErrText(res)}` });
        return;
      }
    } catch (e) {
      this._proxy.$onDidChangeState(this._id, { state: 3, message: `Error connecting to ${this._launch.uri} as SSE: ${e}` });
      return;
    }
    const parser2 = new SSEParser((event) => {
      if (event.type === "message") {
        this._proxy.$onDidReceiveMessage(this._id, event.data);
      } else if (event.type === "endpoint") {
        postEndpoint.complete(new URL(event.data, this._launch.uri.toString(true)).toString());
      }
    });
    this._register(toDisposable(() => postEndpoint.cancel()));
    this._doSSE(parser2, res).catch((err) => {
      this._proxy.$onDidChangeState(this._id, { state: 3, message: `Error reading SSE stream: ${String(err)}` });
    });
    return postEndpoint.p;
  }
  /**
   * Sends a legacy SSE message to the server. The response is always empty and
   * is otherwise received in {@link _attachSSE}'s loop.
   */
  async _sendLegacySSE(url, message) {
    const asBytes = new TextEncoder().encode(message);
    const headers = {
      ...Object.fromEntries(this._launch.headers),
      "Content-Type": "application/json",
      "Content-Length": String(asBytes.length)
    };
    await this._addAuthHeader(headers);
    const res = await this._fetch(url, {
      method: "POST",
      headers,
      body: asBytes
    });
    if (res.status >= 300) {
      this._log(LogLevel.Warning, `${res.status} status sending message to ${this._postEndpoint}: ${await this._getErrText(res)}`);
    }
  }
  /** Generic handle to pipe a response into an SSE parser. */
  async _doSSE(parser2, res) {
    if (!res.body) {
      return;
    }
    const reader = res.body.getReader();
    let chunk;
    do {
      try {
        chunk = await raceCancellationError(reader.read(), this._cts.token);
      } catch (err) {
        reader.cancel();
        if (this._store.isDisposed) {
          return;
        } else {
          throw err;
        }
      }
      if (chunk.value) {
        parser2.feed(chunk.value);
      }
    } while (!chunk.done);
  }
  async _addAuthHeader(headers, forceNewRegistration) {
    if (this._authMetadata) {
      try {
        const authDetails = {
          authorizationServer: this._authMetadata.authorizationServer.toJSON(),
          authorizationServerMetadata: this._authMetadata.serverMetadata,
          resourceMetadata: this._authMetadata.resourceMetadata,
          scopes: this._authMetadata.scopes
        };
        const token = await this._proxy.$getTokenFromServerMetadata(this._id, authDetails, {
          errorOnUserInteraction: this._errorOnUserInteraction,
          forceNewRegistration
        });
        if (token) {
          headers["Authorization"] = `Bearer ${token}`;
        }
      } catch (e) {
        if (UserInteractionRequiredError.is(e)) {
          this._proxy.$onDidChangeState(this._id, { state: 0, reason: "needs-user-interaction" });
          throw new CancellationError();
        }
        this._log(LogLevel.Warning, `Error getting token from server metadata: ${String(e)}`);
      }
    }
    if (this._launch.authentication) {
      try {
        this._log(LogLevel.Debug, `Using provided authentication config: providerId=${this._launch.authentication.providerId}, scopes=${this._launch.authentication.scopes.join(", ")}`);
        const token = await this._proxy.$getTokenForProviderId(this._id, this._launch.authentication.providerId, this._launch.authentication.scopes, {
          errorOnUserInteraction: this._errorOnUserInteraction,
          forceNewRegistration
        });
        if (token) {
          headers["Authorization"] = `Bearer ${token}`;
          this._log(LogLevel.Info, "Successfully obtained token from provided authentication config");
        }
      } catch (e) {
        if (UserInteractionRequiredError.is(e)) {
          this._proxy.$onDidChangeState(this._id, { state: 0, reason: "needs-user-interaction" });
          throw new CancellationError();
        }
        this._log(LogLevel.Warning, `Error getting token from provided authentication config: ${String(e)}`);
      }
    }
    return headers;
  }
  _log(level, message) {
    if (!this._store.isDisposed) {
      this._proxy.$onDidPublishLog(this._id, level, message);
    }
  }
  _parseWWWAuthenticateHeader(response) {
    let resourceMetadataChallenge;
    let scopesChallenge;
    if (response.headers.has("WWW-Authenticate")) {
      const authHeader = response.headers.get("WWW-Authenticate");
      const challenges = parseWWWAuthenticateHeader(authHeader);
      for (const challenge of challenges) {
        if (challenge.scheme === "Bearer") {
          if (!resourceMetadataChallenge && challenge.params["resource_metadata"]) {
            resourceMetadataChallenge = challenge.params["resource_metadata"];
            this._log(LogLevel.Debug, `Found resource_metadata challenge in WWW-Authenticate header: ${resourceMetadataChallenge}`);
          }
          if (!scopesChallenge && challenge.params["scope"]) {
            const scopes = challenge.params["scope"].split(AUTH_SCOPE_SEPARATOR).filter((s) => s.trim().length);
            if (scopes.length) {
              this._log(LogLevel.Debug, `Found scope challenge in WWW-Authenticate header: ${challenge.params["scope"]}`);
              scopesChallenge = scopes;
            }
          }
          if (resourceMetadataChallenge && scopesChallenge) {
            break;
          }
        }
      }
    }
    return { resourceMetadataChallenge, scopesChallenge };
  }
  async _getErrText(res) {
    try {
      return await res.text();
    } catch {
      return res.statusText;
    }
  }
  /**
   * Helper method to perform fetch with authentication retry logic.
   * If the initial request returns an auth error and we don't have auth metadata,
   * it will populate the auth metadata and retry once.
   * If we already have auth metadata, check if the scopes changed and update them.
   */
  async _fetchWithAuthRetry(mcpUrl, init, headers) {
    const doFetch = () => this._fetch(mcpUrl, init);
    let res = await doFetch();
    if (isAuthStatusCode(res.status)) {
      if (!this._authMetadata) {
        await this._populateAuthMetadata(mcpUrl, res);
        await this._addAuthHeader(headers);
        if (headers["Authorization"]) {
          init.headers = headers;
          res = await doFetch();
        }
      } else {
        const { scopesChallenge } = this._parseWWWAuthenticateHeader(res);
        if (!scopesMatch(scopesChallenge, this._authMetadata.scopes)) {
          this._log(LogLevel.Debug, `Scopes changed from ${JSON.stringify(this._authMetadata.scopes)} to ${JSON.stringify(scopesChallenge)}, updating and retrying`);
          this._authMetadata.scopes = scopesChallenge;
          await this._addAuthHeader(headers);
          if (headers["Authorization"]) {
            init.headers = headers;
            res = await doFetch();
          }
        }
      }
    }
    if (headers["Authorization"] && isAuthStatusCode(res.status)) {
      await this._addAuthHeader(headers, true);
      res = await doFetch();
    }
    return res;
  }
  async _fetch(url, init) {
    init.headers["user-agent"] = `${product_default.nameLong}/${product_default.version}`;
    if (canLog(this._logService.getLevel(), LogLevel.Trace)) {
      const traceObj = { ...init, headers: { ...init.headers } };
      if (traceObj.body) {
        traceObj.body = new TextDecoder().decode(traceObj.body);
      }
      if (traceObj.headers?.Authorization) {
        traceObj.headers.Authorization = "***";
      }
      this._log(LogLevel.Trace, `Fetching ${url} with options: ${JSON.stringify(traceObj)}`);
    }
    let currentUrl = url;
    let response;
    for (let redirectCount = 0; redirectCount < MAX_FOLLOW_REDIRECTS; redirectCount++) {
      response = await this._fetchInternal(currentUrl, {
        ...init,
        signal: this._abortCtrl.signal,
        redirect: "manual"
      });
      if (!REDIRECT_STATUS_CODES.includes(response.status)) {
        break;
      }
      const location2 = response.headers.get("location");
      if (!location2) {
        break;
      }
      const nextUrl = new URL(location2, currentUrl).toString();
      this._log(LogLevel.Trace, `Redirect (${response.status}) from ${currentUrl} to ${nextUrl}`);
      currentUrl = nextUrl;
      if (response.status === 303 || (response.status === 301 || response.status === 302) && init.method === "POST") {
        init.method = "GET";
        delete init.body;
      }
    }
    if (canLog(this._logService.getLevel(), LogLevel.Trace)) {
      const headers = {};
      response.headers.forEach((value, key) => {
        headers[key] = value;
      });
      this._log(LogLevel.Trace, `Fetched ${currentUrl}: ${JSON.stringify({
        status: response.status,
        headers
      })}`);
    }
    return response;
  }
  _fetchInternal(url, init) {
    return fetch(url, init);
  }
};
function isJSON(str) {
  try {
    JSON.parse(str);
    return true;
  } catch (e) {
    return false;
  }
}
function isAuthStatusCode(status) {
  return status === 401 || status === 403;
}

// out-build/vs/workbench/api/common/extHostDataChannels.js
var IExtHostDataChannels = createDecorator("IExtHostDataChannels");
var ExtHostDataChannels = class {
  constructor() {
    this._channels = /* @__PURE__ */ new Map();
  }
  createDataChannel(extension, channelId) {
    checkProposedApiEnabled(extension, "dataChannels");
    let channel = this._channels.get(channelId);
    if (!channel) {
      channel = new DataChannelImpl(channelId);
      this._channels.set(channelId, channel);
    }
    return channel;
  }
  $onDidReceiveData(channelId, data2) {
    const channel = this._channels.get(channelId);
    if (channel) {
      channel._fireDidReceiveData(data2);
    }
  }
};
var DataChannelImpl = class extends Disposable {
  constructor(channelId) {
    super();
    this.channelId = channelId;
    this._onDidReceiveData = new Emitter();
    this.onDidReceiveData = this._onDidReceiveData.event;
    this._register(this._onDidReceiveData);
  }
  _fireDidReceiveData(data2) {
    this._onDidReceiveData.fire({ data: data2 });
  }
  toString() {
    return `DataChannel(${this.channelId})`;
  }
};

// out-build/vs/workbench/api/common/extHost.common.services.js
registerSingleton(
  IExtHostLocalizationService,
  ExtHostLocalizationService,
  1
  /* InstantiationType.Delayed */
);
registerSingleton(
  ILoggerService,
  ExtHostLoggerService,
  1
  /* InstantiationType.Delayed */
);
registerSingleton(
  IExtHostApiDeprecationService,
  ExtHostApiDeprecationService,
  1
  /* InstantiationType.Delayed */
);
registerSingleton(
  IExtHostCommands,
  ExtHostCommands,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostProgress,
  ExtHostProgress,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostLanguageModels,
  ExtHostLanguageModels,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostConfiguration,
  ExtHostConfiguration,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostConsumerFileSystem,
  ExtHostConsumerFileSystem,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostTesting,
  ExtHostTesting,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostDebugService,
  WorkerExtHostDebugService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostDecorations,
  ExtHostDecorations,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostDocumentsAndEditors,
  ExtHostDocumentsAndEditors,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostManagedSockets,
  ExtHostManagedSockets,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostFileSystemInfo,
  ExtHostFileSystemInfo,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostOutputService,
  ExtHostOutputService,
  1
  /* InstantiationType.Delayed */
);
registerSingleton(
  IExtHostSearch,
  ExtHostSearch,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostStorage,
  ExtHostStorage,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostTask,
  WorkerExtHostTask,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostTerminalService,
  WorkerExtHostTerminalService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostTerminalShellIntegration,
  ExtHostTerminalShellIntegration,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostTunnelService,
  ExtHostTunnelService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostWindow,
  ExtHostWindow,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostUrlsService,
  ExtHostUrls,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostWorkspace,
  ExtHostWorkspace,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostSecretState,
  ExtHostSecretState,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostEditorTabs,
  ExtHostEditorTabs,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostVariableResolverProvider,
  ExtHostVariableResolverProviderService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostMpcService,
  ExtHostMcpService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostDataChannels,
  ExtHostDataChannels,
  0
  /* InstantiationType.Eager */
);

// out-build/vs/platform/log/common/logService.js
var LogService = class extends Disposable {
  constructor(primaryLogger, otherLoggers = []) {
    super();
    this.logger = new MultiplexLogger([primaryLogger, ...otherLoggers]);
    this._register(primaryLogger.onDidChangeLogLevel((level) => this.setLevel(level)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(level) {
    this.logger.setLevel(level);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(message, ...args) {
    this.logger.trace(message, ...args);
  }
  debug(message, ...args) {
    this.logger.debug(message, ...args);
  }
  info(message, ...args) {
    this.logger.info(message, ...args);
  }
  warn(message, ...args) {
    this.logger.warn(message, ...args);
  }
  error(message, ...args) {
    this.logger.error(message, ...args);
  }
  flush() {
    this.logger.flush();
  }
};

// out-build/vs/workbench/api/common/extHostLogService.js
var ExtHostLogService = class ExtHostLogService2 extends LogService {
  constructor(isWorker, loggerService, initData) {
    const id2 = initData.remote.isRemote ? "remoteexthost" : isWorker ? "workerexthost" : "exthost";
    const name2 = initData.remote.isRemote ? localize(3015, null) : isWorker ? localize(3016, null) : localize(3017, null);
    super(loggerService.createLogger(id2, { name: name2 }));
  }
};
ExtHostLogService = __decorate([
  __param(1, ILoggerService),
  __param(2, IExtHostInitDataService)
], ExtHostLogService);

// out-build/vs/editor/common/config/editorZoom.js
var EditorZoom = new class {
  constructor() {
    this._zoomLevel = 0;
    this._onDidChangeZoomLevel = new Emitter();
    this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(zoomLevel) {
    zoomLevel = Math.min(Math.max(-5, zoomLevel), 20);
    if (this._zoomLevel === zoomLevel) {
      return;
    }
    this._zoomLevel = zoomLevel;
    this._onDidChangeZoomLevel.fire(this._zoomLevel);
  }
}();

// out-build/vs/editor/common/config/fontInfo.js
var GOLDEN_LINE_HEIGHT_RATIO = isMacintosh ? 1.5 : 1.35;
var MINIMUM_LINE_HEIGHT = 8;
var BareFontInfo = class _BareFontInfo {
  /**
   * @internal
   */
  static _create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom) {
    if (lineHeight === 0) {
      lineHeight = GOLDEN_LINE_HEIGHT_RATIO * fontSize;
    } else if (lineHeight < MINIMUM_LINE_HEIGHT) {
      lineHeight = lineHeight * fontSize;
    }
    lineHeight = Math.round(lineHeight);
    if (lineHeight < MINIMUM_LINE_HEIGHT) {
      lineHeight = MINIMUM_LINE_HEIGHT;
    }
    const editorZoomLevelMultiplier = 1 + (ignoreEditorZoom ? 0 : EditorZoom.getZoomLevel() * 0.1);
    fontSize *= editorZoomLevelMultiplier;
    lineHeight *= editorZoomLevelMultiplier;
    if (fontVariationSettings === FONT_VARIATION_TRANSLATE) {
      if (fontWeight === "normal" || fontWeight === "bold") {
        fontVariationSettings = FONT_VARIATION_OFF;
      } else {
        const fontWeightAsNumber = parseInt(fontWeight, 10);
        fontVariationSettings = `'wght' ${fontWeightAsNumber}`;
        fontWeight = "normal";
      }
    }
    return new _BareFontInfo({
      pixelRatio,
      fontFamily,
      fontWeight,
      fontSize,
      fontFeatureSettings,
      fontVariationSettings,
      lineHeight,
      letterSpacing
    });
  }
  /**
   * @internal
   */
  constructor(opts) {
    this._bareFontInfoBrand = void 0;
    this.pixelRatio = opts.pixelRatio;
    this.fontFamily = String(opts.fontFamily);
    this.fontWeight = String(opts.fontWeight);
    this.fontSize = opts.fontSize;
    this.fontFeatureSettings = opts.fontFeatureSettings;
    this.fontVariationSettings = opts.fontVariationSettings;
    this.lineHeight = opts.lineHeight | 0;
    this.letterSpacing = opts.letterSpacing;
  }
  /**
   * @internal
   */
  getId() {
    return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.fontVariationSettings}-${this.lineHeight}-${this.letterSpacing}`;
  }
  /**
   * @internal
   */
  getMassagedFontFamily() {
    const fallbackFontFamily = EDITOR_FONT_DEFAULTS.fontFamily;
    const fontFamily = _BareFontInfo._wrapInQuotes(this.fontFamily);
    if (fallbackFontFamily && this.fontFamily !== fallbackFontFamily) {
      return `${fontFamily}, ${fallbackFontFamily}`;
    }
    return fontFamily;
  }
  static _wrapInQuotes(fontFamily) {
    if (/[,"']/.test(fontFamily)) {
      return fontFamily;
    }
    if (/[+ ]/.test(fontFamily)) {
      return `"${fontFamily}"`;
    }
    return fontFamily;
  }
};
var SERIALIZED_FONT_INFO_VERSION = 2;
var FontInfo = class extends BareFontInfo {
  /**
   * @internal
   */
  constructor(opts, isTrusted) {
    super(opts);
    this._editorStylingBrand = void 0;
    this.version = SERIALIZED_FONT_INFO_VERSION;
    this.isTrusted = isTrusted;
    this.isMonospace = opts.isMonospace;
    this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;
    this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;
    this.canUseHalfwidthRightwardsArrow = opts.canUseHalfwidthRightwardsArrow;
    this.spaceWidth = opts.spaceWidth;
    this.middotWidth = opts.middotWidth;
    this.wsmiddotWidth = opts.wsmiddotWidth;
    this.maxDigitWidth = opts.maxDigitWidth;
  }
  /**
   * @internal
   */
  equals(other) {
    return this.fontFamily === other.fontFamily && this.fontWeight === other.fontWeight && this.fontSize === other.fontSize && this.fontFeatureSettings === other.fontFeatureSettings && this.fontVariationSettings === other.fontVariationSettings && this.lineHeight === other.lineHeight && this.letterSpacing === other.letterSpacing && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.spaceWidth === other.spaceWidth && this.middotWidth === other.middotWidth && this.wsmiddotWidth === other.wsmiddotWidth && this.maxDigitWidth === other.maxDigitWidth;
  }
};
var FONT_VARIATION_OFF = "normal";
var FONT_VARIATION_TRANSLATE = "translate";
var DEFAULT_WINDOWS_FONT_FAMILY = "Consolas, 'Courier New', monospace";
var DEFAULT_MAC_FONT_FAMILY = "Menlo, Monaco, 'Courier New', monospace";
var DEFAULT_LINUX_FONT_FAMILY = "'Droid Sans Mono', 'monospace', monospace";
var EDITOR_FONT_DEFAULTS = {
  fontFamily: isMacintosh ? DEFAULT_MAC_FONT_FAMILY : isWindows ? DEFAULT_WINDOWS_FONT_FAMILY : DEFAULT_LINUX_FONT_FAMILY,
  fontWeight: "normal",
  fontSize: isMacintosh ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
};

// out-build/vs/editor/common/core/misc/textModelDefaults.js
var EDITOR_MODEL_DEFAULTS = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: true,
  detectIndentation: true,
  trimAutoWhitespace: true,
  largeFileOptimizations: true,
  bracketPairColorizationOptions: {
    enabled: true,
    independentColorPoolPerBracketType: false
  }
};

// out-build/vs/editor/common/config/editorOptions.js
var EditorAutoIndentStrategy;
(function(EditorAutoIndentStrategy2) {
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var MINIMAP_GUTTER_WIDTH = 8;
var ComputeOptionsMemory = class {
  constructor() {
    this.stableMinimapLayoutInput = null;
    this.stableFitMaxMinimapScale = 0;
    this.stableFitRemainingWidth = 0;
  }
};
var BaseEditorOption = class {
  constructor(id2, name2, defaultValue, schema2) {
    this.id = id2;
    this.name = name2;
    this.defaultValue = defaultValue;
    this.schema = schema2;
  }
  applyUpdate(value, update) {
    return applyUpdate(value, update);
  }
  compute(env2, options2, value) {
    return value;
  }
};
var ApplyUpdateResult = class {
  constructor(newValue, didChange) {
    this.newValue = newValue;
    this.didChange = didChange;
  }
};
function applyUpdate(value, update) {
  if (typeof value !== "object" || typeof update !== "object" || !value || !update) {
    return new ApplyUpdateResult(update, value !== update);
  }
  if (Array.isArray(value) || Array.isArray(update)) {
    const arrayEquals = Array.isArray(value) && Array.isArray(update) && equals(value, update);
    return new ApplyUpdateResult(update, !arrayEquals);
  }
  let didChange = false;
  for (const key in update) {
    if (update.hasOwnProperty(key)) {
      const result = applyUpdate(value[key], update[key]);
      if (result.didChange) {
        value[key] = result.newValue;
        didChange = true;
      }
    }
  }
  return new ApplyUpdateResult(value, didChange);
}
var ComputedEditorOption = class {
  constructor(id2, defaultValue) {
    this.schema = void 0;
    this.id = id2;
    this.name = "_never_";
    this.defaultValue = defaultValue;
  }
  applyUpdate(value, update) {
    return applyUpdate(value, update);
  }
  validate(input) {
    return this.defaultValue;
  }
};
var SimpleEditorOption = class {
  constructor(id2, name2, defaultValue, schema2) {
    this.id = id2;
    this.name = name2;
    this.defaultValue = defaultValue;
    this.schema = schema2;
  }
  applyUpdate(value, update) {
    return applyUpdate(value, update);
  }
  compute(env2, options2, value) {
    return value;
  }
};
function boolean(value, defaultValue) {
  if (typeof value === "undefined") {
    return defaultValue;
  }
  if (value === "false") {
    return false;
  }
  return Boolean(value);
}
var EditorBooleanOption = class extends SimpleEditorOption {
  constructor(id2, name2, defaultValue, schema2 = void 0) {
    if (typeof schema2 !== "undefined") {
      schema2.type = "boolean";
      schema2.default = defaultValue;
    }
    super(id2, name2, defaultValue, schema2);
  }
  validate(input) {
    return boolean(input, this.defaultValue);
  }
};
function clampedInt(value, defaultValue, minimum, maximum) {
  if (typeof value === "string") {
    value = parseInt(value, 10);
  }
  if (typeof value !== "number" || isNaN(value)) {
    return defaultValue;
  }
  let r = value;
  r = Math.max(minimum, r);
  r = Math.min(maximum, r);
  return r | 0;
}
var EditorIntOption = class _EditorIntOption extends SimpleEditorOption {
  static clampedInt(value, defaultValue, minimum, maximum) {
    return clampedInt(value, defaultValue, minimum, maximum);
  }
  constructor(id2, name2, defaultValue, minimum, maximum, schema2 = void 0) {
    if (typeof schema2 !== "undefined") {
      schema2.type = "integer";
      schema2.default = defaultValue;
      schema2.minimum = minimum;
      schema2.maximum = maximum;
    }
    super(id2, name2, defaultValue, schema2);
    this.minimum = minimum;
    this.maximum = maximum;
  }
  validate(input) {
    return _EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);
  }
};
var EditorFloatOption = class _EditorFloatOption extends SimpleEditorOption {
  static clamp(n, min, max) {
    if (n < min) {
      return min;
    }
    if (n > max) {
      return max;
    }
    return n;
  }
  static float(value, defaultValue) {
    if (typeof value === "string") {
      value = parseFloat(value);
    }
    if (typeof value !== "number" || isNaN(value)) {
      return defaultValue;
    }
    return value;
  }
  constructor(id2, name2, defaultValue, validationFn, schema2, minimum, maximum) {
    if (typeof schema2 !== "undefined") {
      schema2.type = "number";
      schema2.default = defaultValue;
      schema2.minimum = minimum;
      schema2.maximum = maximum;
    }
    super(id2, name2, defaultValue, schema2);
    this.validationFn = validationFn;
    this.minimum = minimum;
    this.maximum = maximum;
  }
  validate(input) {
    return this.validationFn(_EditorFloatOption.float(input, this.defaultValue));
  }
};
var EditorStringOption = class _EditorStringOption extends SimpleEditorOption {
  static string(value, defaultValue) {
    if (typeof value !== "string") {
      return defaultValue;
    }
    return value;
  }
  constructor(id2, name2, defaultValue, schema2 = void 0) {
    if (typeof schema2 !== "undefined") {
      schema2.type = "string";
      schema2.default = defaultValue;
    }
    super(id2, name2, defaultValue, schema2);
  }
  validate(input) {
    return _EditorStringOption.string(input, this.defaultValue);
  }
};
function stringSet(value, defaultValue, allowedValues, renamedValues) {
  if (typeof value !== "string") {
    return defaultValue;
  }
  if (renamedValues && value in renamedValues) {
    return renamedValues[value];
  }
  if (allowedValues.indexOf(value) === -1) {
    return defaultValue;
  }
  return value;
}
var EditorStringEnumOption = class extends SimpleEditorOption {
  constructor(id2, name2, defaultValue, allowedValues, schema2 = void 0) {
    if (typeof schema2 !== "undefined") {
      schema2.type = "string";
      schema2.enum = allowedValues.slice(0);
      schema2.default = defaultValue;
    }
    super(id2, name2, defaultValue, schema2);
    this._allowedValues = allowedValues;
  }
  validate(input) {
    return stringSet(input, this.defaultValue, this._allowedValues);
  }
};
var EditorEnumOption = class extends BaseEditorOption {
  constructor(id2, name2, defaultValue, defaultStringValue, allowedValues, convert, schema2 = void 0) {
    if (typeof schema2 !== "undefined") {
      schema2.type = "string";
      schema2.enum = allowedValues;
      schema2.default = defaultStringValue;
    }
    super(id2, name2, defaultValue, schema2);
    this._allowedValues = allowedValues;
    this._convert = convert;
  }
  validate(input) {
    if (typeof input !== "string") {
      return this.defaultValue;
    }
    if (this._allowedValues.indexOf(input) === -1) {
      return this.defaultValue;
    }
    return this._convert(input);
  }
};
function _autoIndentFromString(autoIndent) {
  switch (autoIndent) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
var EditorAccessibilitySupport = class extends BaseEditorOption {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        localize(315, null),
        localize(316, null),
        localize(317, null)
      ],
      default: "auto",
      tags: ["accessibility"],
      description: localize(318, null)
    });
  }
  validate(input) {
    switch (input) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(env2, options2, value) {
    if (value === 0) {
      return env2.accessibilitySupport;
    }
    return value;
  }
};
var EditorComments = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      insertSpace: true,
      ignoreEmptyLines: true
    };
    super(29, "comments", defaults, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: defaults.insertSpace,
        description: localize(319, null)
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: defaults.ignoreEmptyLines,
        description: localize(320, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
};
var TextEditorCursorBlinkingStyle;
(function(TextEditorCursorBlinkingStyle2) {
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
function cursorBlinkingStyleFromString(cursorBlinkingStyle) {
  switch (cursorBlinkingStyle) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var TextEditorCursorStyle;
(function(TextEditorCursorStyle2) {
  TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
function cursorStyleFromString(cursorStyle) {
  switch (cursorStyle) {
    case "line":
      return TextEditorCursorStyle.Line;
    case "block":
      return TextEditorCursorStyle.Block;
    case "underline":
      return TextEditorCursorStyle.Underline;
    case "line-thin":
      return TextEditorCursorStyle.LineThin;
    case "block-outline":
      return TextEditorCursorStyle.BlockOutline;
    case "underline-thin":
      return TextEditorCursorStyle.UnderlineThin;
  }
}
var EditorClassName = class extends ComputedEditorOption {
  constructor() {
    super(162, "");
  }
  compute(env2, options2, _) {
    const classNames = ["monaco-editor"];
    if (options2.get(
      48
      /* EditorOption.extraEditorClassName */
    )) {
      classNames.push(options2.get(
        48
        /* EditorOption.extraEditorClassName */
      ));
    }
    if (env2.extraEditorClassName) {
      classNames.push(env2.extraEditorClassName);
    }
    if (options2.get(
      82
      /* EditorOption.mouseStyle */
    ) === "default") {
      classNames.push("mouse-default");
    } else if (options2.get(
      82
      /* EditorOption.mouseStyle */
    ) === "copy") {
      classNames.push("mouse-copy");
    }
    if (options2.get(
      127
      /* EditorOption.showUnused */
    )) {
      classNames.push("showUnused");
    }
    if (options2.get(
      157
      /* EditorOption.showDeprecated */
    )) {
      classNames.push("showDeprecated");
    }
    return classNames.join(" ");
  }
};
var EditorEmptySelectionClipboard = class extends EditorBooleanOption {
  constructor() {
    super(45, "emptySelectionClipboard", true, { description: localize(321, null) });
  }
  compute(env2, options2, value) {
    return value && env2.emptySelectionClipboard;
  }
};
var EditorFind = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      cursorMoveOnType: true,
      findOnType: true,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: false,
      addExtraSpaceOnTop: true,
      loop: true,
      history: "workspace",
      replaceHistory: "workspace"
    };
    super(50, "find", defaults, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: defaults.cursorMoveOnType,
        description: localize(322, null)
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: defaults.seedSearchStringFromSelection,
        enumDescriptions: [
          localize(323, null),
          localize(324, null),
          localize(325, null)
        ],
        description: localize(326, null)
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: defaults.autoFindInSelection,
        enumDescriptions: [
          localize(327, null),
          localize(328, null),
          localize(329, null)
        ],
        description: localize(330, null)
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: defaults.globalFindClipboard,
        description: localize(331, null),
        included: isMacintosh
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: defaults.addExtraSpaceOnTop,
        description: localize(332, null)
      },
      "editor.find.loop": {
        type: "boolean",
        default: defaults.loop,
        description: localize(333, null)
      },
      "editor.find.history": {
        type: "string",
        enum: ["never", "workspace"],
        default: "workspace",
        enumDescriptions: [
          localize(334, null),
          localize(335, null)
        ],
        description: localize(336, null)
      },
      "editor.find.replaceHistory": {
        type: "string",
        enum: ["never", "workspace"],
        default: "workspace",
        enumDescriptions: [
          localize(337, null),
          localize(338, null)
        ],
        description: localize(339, null)
      },
      "editor.find.findOnType": {
        type: "boolean",
        default: defaults.findOnType,
        description: localize(340, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      findOnType: boolean(input.findOnType, this.defaultValue.findOnType),
      seedSearchStringFromSelection: typeof input.seedSearchStringFromSelection === "boolean" ? input.seedSearchStringFromSelection ? "always" : "never" : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof input.autoFindInSelection === "boolean" ? input.autoFindInSelection ? "always" : "never" : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: boolean(input.loop, this.defaultValue.loop),
      history: stringSet(input.history, this.defaultValue.history, ["never", "workspace"]),
      replaceHistory: stringSet(input.replaceHistory, this.defaultValue.replaceHistory, ["never", "workspace"])
    };
  }
};
var EditorFontLigatures = class _EditorFontLigatures extends BaseEditorOption {
  static {
    this.OFF = '"liga" off, "calt" off';
  }
  static {
    this.ON = '"liga" on, "calt" on';
  }
  constructor() {
    super(60, "fontLigatures", _EditorFontLigatures.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: localize(341, null)
        },
        {
          type: "string",
          description: localize(342, null)
        }
      ],
      description: localize(343, null),
      default: false
    });
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    if (typeof input === "string") {
      if (input === "false" || input.length === 0) {
        return _EditorFontLigatures.OFF;
      }
      if (input === "true") {
        return _EditorFontLigatures.ON;
      }
      return input;
    }
    if (Boolean(input)) {
      return _EditorFontLigatures.ON;
    }
    return _EditorFontLigatures.OFF;
  }
};
var EditorFontVariations = class _EditorFontVariations extends BaseEditorOption {
  static {
    this.OFF = FONT_VARIATION_OFF;
  }
  static {
    this.TRANSLATE = FONT_VARIATION_TRANSLATE;
  }
  constructor() {
    super(63, "fontVariations", _EditorFontVariations.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: localize(344, null)
        },
        {
          type: "string",
          description: localize(345, null)
        }
      ],
      description: localize(346, null),
      default: false
    });
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    if (typeof input === "string") {
      if (input === "false") {
        return _EditorFontVariations.OFF;
      }
      if (input === "true") {
        return _EditorFontVariations.TRANSLATE;
      }
      return input;
    }
    if (Boolean(input)) {
      return _EditorFontVariations.TRANSLATE;
    }
    return _EditorFontVariations.OFF;
  }
  compute(env2, options2, value) {
    return env2.fontInfo.fontVariationSettings;
  }
};
var EditorFontInfo = class extends ComputedEditorOption {
  constructor() {
    super(59, new FontInfo({
      pixelRatio: 0,
      fontFamily: "",
      fontWeight: "",
      fontSize: 0,
      fontFeatureSettings: "",
      fontVariationSettings: "",
      lineHeight: 0,
      letterSpacing: 0,
      isMonospace: false,
      typicalHalfwidthCharacterWidth: 0,
      typicalFullwidthCharacterWidth: 0,
      canUseHalfwidthRightwardsArrow: false,
      spaceWidth: 0,
      middotWidth: 0,
      wsmiddotWidth: 0,
      maxDigitWidth: 0
    }, false));
  }
  compute(env2, options2, _) {
    return env2.fontInfo;
  }
};
var EffectiveCursorStyle = class extends ComputedEditorOption {
  constructor() {
    super(161, TextEditorCursorStyle.Line);
  }
  compute(env2, options2, _) {
    return env2.inputMode === "overtype" ? options2.get(
      92
      /* EditorOption.overtypeCursorStyle */
    ) : options2.get(
      34
      /* EditorOption.cursorStyle */
    );
  }
};
var EffectiveEditContextEnabled = class extends ComputedEditorOption {
  constructor() {
    super(170, false);
  }
  compute(env2, options2) {
    return env2.editContextSupported && options2.get(
      44
      /* EditorOption.editContext */
    );
  }
};
var EffectiveAllowVariableFonts = class extends ComputedEditorOption {
  constructor() {
    super(172, false);
  }
  compute(env2, options2) {
    const accessibilitySupport = env2.accessibilitySupport;
    if (accessibilitySupport === 2) {
      return options2.get(
        7
        /* EditorOption.allowVariableFontsInAccessibilityMode */
      );
    } else {
      return options2.get(
        6
        /* EditorOption.allowVariableFonts */
      );
    }
  }
};
var EditorFontSize = class extends SimpleEditorOption {
  constructor() {
    super(61, "fontSize", EDITOR_FONT_DEFAULTS.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: EDITOR_FONT_DEFAULTS.fontSize,
      description: localize(347, null)
    });
  }
  validate(input) {
    const r = EditorFloatOption.float(input, this.defaultValue);
    if (r === 0) {
      return EDITOR_FONT_DEFAULTS.fontSize;
    }
    return EditorFloatOption.clamp(r, 6, 100);
  }
  compute(env2, options2, value) {
    return env2.fontInfo.fontSize;
  }
};
var EditorFontWeight = class _EditorFontWeight extends BaseEditorOption {
  static {
    this.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
  }
  static {
    this.MINIMUM_VALUE = 1;
  }
  static {
    this.MAXIMUM_VALUE = 1e3;
  }
  constructor() {
    super(62, "fontWeight", EDITOR_FONT_DEFAULTS.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: _EditorFontWeight.MINIMUM_VALUE,
          maximum: _EditorFontWeight.MAXIMUM_VALUE,
          errorMessage: localize(348, null)
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: _EditorFontWeight.SUGGESTION_VALUES
        }
      ],
      default: EDITOR_FONT_DEFAULTS.fontWeight,
      description: localize(349, null)
    });
  }
  validate(input) {
    if (input === "normal" || input === "bold") {
      return input;
    }
    return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, _EditorFontWeight.MINIMUM_VALUE, _EditorFontWeight.MAXIMUM_VALUE));
  }
};
var EditorGoToLocation = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      multipleTests: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: "",
      alternativeTestsCommand: ""
    };
    const jsonSubset = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: defaults.multiple,
      enumDescriptions: [
        localize(350, null),
        localize(351, null),
        localize(352, null)
      ]
    };
    const alternativeCommandOptions = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(67, "gotoLocation", defaults, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: localize(353, null)
      },
      "editor.gotoLocation.multipleDefinitions": {
        description: localize(354, null),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleTypeDefinitions": {
        description: localize(355, null),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleDeclarations": {
        description: localize(356, null),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleImplementations": {
        description: localize(357, null),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleReferences": {
        description: localize(358, null),
        ...jsonSubset
      },
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: defaults.alternativeDefinitionCommand,
        enum: alternativeCommandOptions,
        description: localize(359, null)
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: defaults.alternativeTypeDefinitionCommand,
        enum: alternativeCommandOptions,
        description: localize(360, null)
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: defaults.alternativeDeclarationCommand,
        enum: alternativeCommandOptions,
        description: localize(361, null)
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: defaults.alternativeImplementationCommand,
        enum: alternativeCommandOptions,
        description: localize(362, null)
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: defaults.alternativeReferenceCommand,
        enum: alternativeCommandOptions,
        description: localize(363, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      multiple: stringSet(input.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: stringSet(input.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: stringSet(input.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: stringSet(input.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: stringSet(input.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: stringSet(input.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTests: stringSet(input.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),
      alternativeTestsCommand: EditorStringOption.string(input.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand)
    };
  }
};
var EditorHover = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: "on",
      delay: 300,
      hidingDelay: 300,
      sticky: true,
      above: true
    };
    super(69, "hover", defaults, {
      "editor.hover.enabled": {
        type: "string",
        enum: ["on", "off", "onKeyboardModifier"],
        default: defaults.enabled,
        markdownEnumDescriptions: [
          localize(364, null),
          localize(365, null),
          localize(366, null, isMacintosh ? `Command` : `Control`)
        ],
        description: localize(367, null)
      },
      "editor.hover.delay": {
        type: "number",
        default: defaults.delay,
        minimum: 0,
        maximum: 1e4,
        description: localize(368, null)
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: defaults.sticky,
        description: localize(369, null)
      },
      "editor.hover.hidingDelay": {
        type: "integer",
        minimum: 0,
        default: defaults.hidingDelay,
        markdownDescription: localize(370, null)
      },
      "editor.hover.above": {
        type: "boolean",
        default: defaults.above,
        description: localize(371, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: stringSet(input.enabled, this.defaultValue.enabled, ["on", "off", "onKeyboardModifier"]),
      delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 1e4),
      sticky: boolean(input.sticky, this.defaultValue.sticky),
      hidingDelay: EditorIntOption.clampedInt(input.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
      above: boolean(input.above, this.defaultValue.above)
    };
  }
};
var RenderMinimap;
(function(RenderMinimap2) {
  RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
  RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
  RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var EditorLayoutInfoComputer = class _EditorLayoutInfoComputer extends ComputedEditorOption {
  constructor() {
    super(165, {
      width: 0,
      height: 0,
      glyphMarginLeft: 0,
      glyphMarginWidth: 0,
      glyphMarginDecorationLaneCount: 0,
      lineNumbersLeft: 0,
      lineNumbersWidth: 0,
      decorationsLeft: 0,
      decorationsWidth: 0,
      contentLeft: 0,
      contentWidth: 0,
      minimap: {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: false,
        minimapIsSampling: false,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: 0,
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: 0
      },
      viewportColumn: 0,
      isWordWrapMinified: false,
      isViewportWrapping: false,
      wrappingColumn: -1,
      verticalScrollbarWidth: 0,
      horizontalScrollbarHeight: 0,
      overviewRuler: {
        top: 0,
        width: 0,
        height: 0,
        right: 0
      }
    });
  }
  compute(env2, options2, _) {
    return _EditorLayoutInfoComputer.computeLayout(options2, {
      memory: env2.memory,
      outerWidth: env2.outerWidth,
      outerHeight: env2.outerHeight,
      isDominatedByLongLines: env2.isDominatedByLongLines,
      lineHeight: env2.fontInfo.lineHeight,
      viewLineCount: env2.viewLineCount,
      lineNumbersDigitCount: env2.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: env2.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: env2.fontInfo.maxDigitWidth,
      pixelRatio: env2.pixelRatio,
      glyphMarginDecorationLaneCount: env2.glyphMarginDecorationLaneCount
    });
  }
  static computeContainedMinimapLineCount(input) {
    const typicalViewportLineCount = input.height / input.lineHeight;
    const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);
    let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);
    if (input.scrollBeyondLastLine) {
      extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);
    }
    const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);
    const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);
    return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };
  }
  static _computeMinimapLayout(input, memory) {
    const outerWidth = input.outerWidth;
    const outerHeight = input.outerHeight;
    const pixelRatio = input.pixelRatio;
    if (!input.minimap.enabled) {
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: false,
        minimapIsSampling: false,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: outerHeight
      };
    }
    const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;
    const couldUseMemory = stableMinimapLayoutInput && input.outerHeight === stableMinimapLayoutInput.outerHeight && input.lineHeight === stableMinimapLayoutInput.lineHeight && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth && input.pixelRatio === stableMinimapLayoutInput.pixelRatio && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine && input.paddingTop === stableMinimapLayoutInput.paddingTop && input.paddingBottom === stableMinimapLayoutInput.paddingBottom && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled && input.minimap.side === stableMinimapLayoutInput.minimap.side && input.minimap.size === stableMinimapLayoutInput.minimap.size && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn && input.minimap.scale === stableMinimapLayoutInput.minimap.scale && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping;
    const lineHeight = input.lineHeight;
    const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;
    const scrollBeyondLastLine = input.scrollBeyondLastLine;
    const minimapRenderCharacters = input.minimap.renderCharacters;
    let minimapScale = pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale;
    const minimapMaxColumn = input.minimap.maxColumn;
    const minimapSize = input.minimap.size;
    const minimapSide = input.minimap.side;
    const verticalScrollbarWidth = input.verticalScrollbarWidth;
    const viewLineCount = input.viewLineCount;
    const remainingWidth = input.remainingWidth;
    const isViewportWrapping = input.isViewportWrapping;
    const baseCharHeight = minimapRenderCharacters ? 2 : 3;
    let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);
    const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;
    let minimapHeightIsEditorHeight = false;
    let minimapIsSampling = false;
    let minimapLineHeight = baseCharHeight * minimapScale;
    let minimapCharWidth = minimapScale / pixelRatio;
    let minimapWidthMultiplier = 1;
    if (minimapSize === "fill" || minimapSize === "fit") {
      const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = _EditorLayoutInfoComputer.computeContainedMinimapLineCount({
        viewLineCount,
        scrollBeyondLastLine,
        paddingTop: input.paddingTop,
        paddingBottom: input.paddingBottom,
        height: outerHeight,
        lineHeight,
        pixelRatio
      });
      const ratio = viewLineCount / minimapLineCount;
      if (ratio > 1) {
        minimapHeightIsEditorHeight = true;
        minimapIsSampling = true;
        minimapScale = 1;
        minimapLineHeight = 1;
        minimapCharWidth = minimapScale / pixelRatio;
      } else {
        let fitBecomesFill = false;
        let maxMinimapScale = minimapScale + 1;
        if (minimapSize === "fit") {
          const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
          if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
            fitBecomesFill = true;
            maxMinimapScale = memory.stableFitMaxMinimapScale;
          } else {
            fitBecomesFill = effectiveMinimapHeight > minimapCanvasInnerHeight;
          }
        }
        if (minimapSize === "fill" || fitBecomesFill) {
          minimapHeightIsEditorHeight = true;
          const configuredMinimapScale = minimapScale;
          minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));
          if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
            maxMinimapScale = memory.stableFitMaxMinimapScale;
          }
          minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));
          if (minimapScale > configuredMinimapScale) {
            minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);
          }
          minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;
          minimapCanvasInnerHeight = Math.ceil(Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
          if (isViewportWrapping) {
            memory.stableMinimapLayoutInput = input;
            memory.stableFitRemainingWidth = remainingWidth;
            memory.stableFitMaxMinimapScale = minimapScale;
          } else {
            memory.stableMinimapLayoutInput = null;
            memory.stableFitRemainingWidth = 0;
          }
        }
      }
    }
    const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
    const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);
    let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);
    const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;
    minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);
    const renderMinimap = minimapRenderCharacters ? 1 : 2;
    const minimapLeft = minimapSide === "left" ? 0 : outerWidth - minimapWidth - verticalScrollbarWidth;
    return {
      renderMinimap,
      minimapLeft,
      minimapWidth,
      minimapHeightIsEditorHeight,
      minimapIsSampling,
      minimapScale,
      minimapLineHeight,
      minimapCanvasInnerWidth,
      minimapCanvasInnerHeight,
      minimapCanvasOuterWidth,
      minimapCanvasOuterHeight
    };
  }
  static computeLayout(options2, env2) {
    const outerWidth = env2.outerWidth | 0;
    const outerHeight = env2.outerHeight | 0;
    const lineHeight = env2.lineHeight | 0;
    const lineNumbersDigitCount = env2.lineNumbersDigitCount | 0;
    const typicalHalfwidthCharacterWidth = env2.typicalHalfwidthCharacterWidth;
    const maxDigitWidth = env2.maxDigitWidth;
    const pixelRatio = env2.pixelRatio;
    const viewLineCount = env2.viewLineCount;
    const wordWrapOverride2 = options2.get(
      154
      /* EditorOption.wordWrapOverride2 */
    );
    const wordWrapOverride1 = wordWrapOverride2 === "inherit" ? options2.get(
      153
      /* EditorOption.wordWrapOverride1 */
    ) : wordWrapOverride2;
    const wordWrap = wordWrapOverride1 === "inherit" ? options2.get(
      149
      /* EditorOption.wordWrap */
    ) : wordWrapOverride1;
    const wordWrapColumn = options2.get(
      152
      /* EditorOption.wordWrapColumn */
    );
    const isDominatedByLongLines = env2.isDominatedByLongLines;
    const showGlyphMargin = options2.get(
      66
      /* EditorOption.glyphMargin */
    );
    const showLineNumbers = options2.get(
      76
      /* EditorOption.lineNumbers */
    ).renderType !== 0;
    const lineNumbersMinChars = options2.get(
      77
      /* EditorOption.lineNumbersMinChars */
    );
    const scrollBeyondLastLine = options2.get(
      119
      /* EditorOption.scrollBeyondLastLine */
    );
    const padding = options2.get(
      96
      /* EditorOption.padding */
    );
    const minimap = options2.get(
      81
      /* EditorOption.minimap */
    );
    const scrollbar = options2.get(
      117
      /* EditorOption.scrollbar */
    );
    const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;
    const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;
    const scrollbarArrowSize = scrollbar.arrowSize;
    const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;
    const folding = options2.get(
      52
      /* EditorOption.folding */
    );
    const showFoldingDecoration = options2.get(
      126
      /* EditorOption.showFoldingControls */
    ) !== "never";
    let lineDecorationsWidth = options2.get(
      74
      /* EditorOption.lineDecorationsWidth */
    );
    if (folding && showFoldingDecoration) {
      lineDecorationsWidth += 16;
    }
    let lineNumbersWidth = 0;
    if (showLineNumbers) {
      const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
      lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
    }
    let glyphMarginWidth = 0;
    if (showGlyphMargin) {
      glyphMarginWidth = lineHeight * env2.glyphMarginDecorationLaneCount;
    }
    let glyphMarginLeft = 0;
    let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
    let decorationsLeft = lineNumbersLeft + lineNumbersWidth;
    let contentLeft = decorationsLeft + lineDecorationsWidth;
    const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
    let isWordWrapMinified = false;
    let isViewportWrapping = false;
    let wrappingColumn = -1;
    if (options2.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 && wordWrapOverride1 === "inherit" && isDominatedByLongLines) {
      isWordWrapMinified = true;
      isViewportWrapping = true;
    } else if (wordWrap === "on" || wordWrap === "bounded") {
      isViewportWrapping = true;
    } else if (wordWrap === "wordWrapColumn") {
      wrappingColumn = wordWrapColumn;
    }
    const minimapLayout = _EditorLayoutInfoComputer._computeMinimapLayout({
      outerWidth,
      outerHeight,
      lineHeight,
      typicalHalfwidthCharacterWidth,
      pixelRatio,
      scrollBeyondLastLine,
      paddingTop: padding.top,
      paddingBottom: padding.bottom,
      minimap,
      verticalScrollbarWidth,
      viewLineCount,
      remainingWidth,
      isViewportWrapping
    }, env2.memory || new ComputeOptionsMemory());
    if (minimapLayout.renderMinimap !== 0 && minimapLayout.minimapLeft === 0) {
      glyphMarginLeft += minimapLayout.minimapWidth;
      lineNumbersLeft += minimapLayout.minimapWidth;
      decorationsLeft += minimapLayout.minimapWidth;
      contentLeft += minimapLayout.minimapWidth;
    }
    const contentWidth = remainingWidth - minimapLayout.minimapWidth;
    const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
    const verticalArrowSize = verticalScrollbarHasArrows ? scrollbarArrowSize : 0;
    if (isViewportWrapping) {
      wrappingColumn = Math.max(1, viewportColumn);
      if (wordWrap === "bounded") {
        wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);
      }
    }
    return {
      width: outerWidth,
      height: outerHeight,
      glyphMarginLeft,
      glyphMarginWidth,
      glyphMarginDecorationLaneCount: env2.glyphMarginDecorationLaneCount,
      lineNumbersLeft,
      lineNumbersWidth,
      decorationsLeft,
      decorationsWidth: lineDecorationsWidth,
      contentLeft,
      contentWidth,
      minimap: minimapLayout,
      viewportColumn,
      isWordWrapMinified,
      isViewportWrapping,
      wrappingColumn,
      verticalScrollbarWidth,
      horizontalScrollbarHeight,
      overviewRuler: {
        top: verticalArrowSize,
        width: verticalScrollbarWidth,
        height: outerHeight - 2 * verticalArrowSize,
        right: 0
      }
    };
  }
};
var WrappingStrategy = class extends BaseEditorOption {
  constructor() {
    super(156, "wrappingStrategy", "simple", {
      "editor.wrappingStrategy": {
        enumDescriptions: [
          localize(372, null),
          localize(373, null)
        ],
        type: "string",
        enum: ["simple", "advanced"],
        default: "simple",
        description: localize(374, null)
      }
    });
  }
  validate(input) {
    return stringSet(input, "simple", ["simple", "advanced"]);
  }
  compute(env2, options2, value) {
    const accessibilitySupport = options2.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    if (accessibilitySupport === 2) {
      return "advanced";
    }
    return value;
  }
};
var ShowLightbulbIconMode;
(function(ShowLightbulbIconMode2) {
  ShowLightbulbIconMode2["Off"] = "off";
  ShowLightbulbIconMode2["OnCode"] = "onCode";
  ShowLightbulbIconMode2["On"] = "on";
})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
var EditorLightbulb = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: ShowLightbulbIconMode.OnCode };
    super(73, "lightbulb", defaults, {
      "editor.lightbulb.enabled": {
        type: "string",
        enum: [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On],
        default: defaults.enabled,
        enumDescriptions: [
          localize(375, null),
          localize(376, null),
          localize(377, null)
        ],
        description: localize(378, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: stringSet(input.enabled, this.defaultValue.enabled, [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On])
    };
  }
};
var EditorStickyScroll = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: true, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: true };
    super(131, "stickyScroll", defaults, {
      "editor.stickyScroll.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize(379, null)
      },
      "editor.stickyScroll.maxLineCount": {
        type: "number",
        default: defaults.maxLineCount,
        minimum: 1,
        maximum: 20,
        description: localize(380, null)
      },
      "editor.stickyScroll.defaultModel": {
        type: "string",
        enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
        default: defaults.defaultModel,
        description: localize(381, null)
      },
      "editor.stickyScroll.scrollWithEditor": {
        type: "boolean",
        default: defaults.scrollWithEditor,
        description: localize(382, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
      defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
      scrollWithEditor: boolean(input.scrollWithEditor, this.defaultValue.scrollWithEditor)
    };
  }
};
var EditorInlayHints = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: "on", fontSize: 0, fontFamily: "", padding: false, maximumLength: 43 };
    super(159, "inlayHints", defaults, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: defaults.enabled,
        description: localize(383, null),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          localize(384, null),
          localize(385, null, isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
          localize(386, null, isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
          localize(387, null)
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: defaults.fontSize,
        markdownDescription: localize(388, null, "`#editor.fontSize#`", "`5`")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: defaults.fontFamily,
        markdownDescription: localize(389, null, "`#editor.fontFamily#`")
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: defaults.padding,
        description: localize(390, null)
      },
      "editor.inlayHints.maximumLength": {
        type: "number",
        default: defaults.maximumLength,
        markdownDescription: localize(391, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    if (typeof input.enabled === "boolean") {
      input.enabled = input.enabled ? "on" : "off";
    }
    return {
      enabled: stringSet(input.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
      padding: boolean(input.padding, this.defaultValue.padding),
      maximumLength: EditorIntOption.clampedInt(input.maximumLength, this.defaultValue.maximumLength, 0, Number.MAX_SAFE_INTEGER)
    };
  }
};
var EditorLineDecorationsWidth = class extends BaseEditorOption {
  constructor() {
    super(74, "lineDecorationsWidth", 10);
  }
  validate(input) {
    if (typeof input === "string" && /^\d+(\.\d+)?ch$/.test(input)) {
      const multiple = parseFloat(input.substring(0, input.length - 2));
      return -multiple;
    } else {
      return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1e3);
    }
  }
  compute(env2, options2, value) {
    if (value < 0) {
      return EditorIntOption.clampedInt(-value * env2.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3);
    } else {
      return value;
    }
  }
};
var EditorLineHeight = class extends EditorFloatOption {
  constructor() {
    super(75, "lineHeight", EDITOR_FONT_DEFAULTS.lineHeight, (x) => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: localize(392, null) }, 0, 150);
  }
  compute(env2, options2, value) {
    return env2.fontInfo.lineHeight;
  }
};
var EditorMinimap = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: "none",
      renderCharacters: true,
      maxColumn: 120,
      scale: 1,
      showRegionSectionHeaders: true,
      showMarkSectionHeaders: true,
      markSectionHeaderRegex: "\\bMARK:\\s*(?<separator>-?)\\s*(?<label>.*)$",
      sectionHeaderFontSize: 9,
      sectionHeaderLetterSpacing: 1
    };
    super(81, "minimap", defaults, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize(393, null)
      },
      "editor.minimap.autohide": {
        type: "string",
        enum: ["none", "mouseover", "scroll"],
        enumDescriptions: [
          localize(394, null),
          localize(395, null),
          localize(396, null)
        ],
        default: defaults.autohide,
        description: localize(397, null)
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          localize(398, null),
          localize(399, null),
          localize(400, null)
        ],
        default: defaults.size,
        description: localize(401, null)
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: defaults.side,
        description: localize(402, null)
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: defaults.showSlider,
        description: localize(403, null)
      },
      "editor.minimap.scale": {
        type: "number",
        default: defaults.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: localize(404, null)
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: defaults.renderCharacters,
        description: localize(405, null)
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: defaults.maxColumn,
        description: localize(406, null)
      },
      "editor.minimap.showRegionSectionHeaders": {
        type: "boolean",
        default: defaults.showRegionSectionHeaders,
        description: localize(407, null)
      },
      "editor.minimap.showMarkSectionHeaders": {
        type: "boolean",
        default: defaults.showMarkSectionHeaders,
        description: localize(408, null)
      },
      "editor.minimap.markSectionHeaderRegex": {
        type: "string",
        default: defaults.markSectionHeaderRegex,
        description: localize(409, null)
      },
      "editor.minimap.sectionHeaderFontSize": {
        type: "number",
        default: defaults.sectionHeaderFontSize,
        description: localize(410, null)
      },
      "editor.minimap.sectionHeaderLetterSpacing": {
        type: "number",
        default: defaults.sectionHeaderLetterSpacing,
        description: localize(411, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    let markSectionHeaderRegex = this.defaultValue.markSectionHeaderRegex;
    const inputRegex = input.markSectionHeaderRegex;
    if (typeof inputRegex === "string") {
      try {
        new RegExp(inputRegex, "d");
        markSectionHeaderRegex = inputRegex;
      } catch {
      }
    }
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      autohide: stringSet(input.autohide, this.defaultValue.autohide, ["none", "mouseover", "scroll"]),
      size: stringSet(input.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: stringSet(input.side, this.defaultValue.side, ["right", "left"]),
      showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),
      scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),
      maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
      showRegionSectionHeaders: boolean(input.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
      showMarkSectionHeaders: boolean(input.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
      markSectionHeaderRegex,
      sectionHeaderFontSize: EditorFloatOption.clamp(EditorFloatOption.float(input.sectionHeaderFontSize, this.defaultValue.sectionHeaderFontSize), 4, 32),
      sectionHeaderLetterSpacing: EditorFloatOption.clamp(EditorFloatOption.float(input.sectionHeaderLetterSpacing, this.defaultValue.sectionHeaderLetterSpacing), 0, 5)
    };
  }
};
function _multiCursorModifierFromString(multiCursorModifier) {
  if (multiCursorModifier === "ctrlCmd") {
    return isMacintosh ? "metaKey" : "ctrlKey";
  }
  return "altKey";
}
var EditorPadding = class extends BaseEditorOption {
  constructor() {
    super(96, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: localize(412, null)
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: localize(413, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      top: EditorIntOption.clampedInt(input.top, 0, 0, 1e3),
      bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1e3)
    };
  }
};
var EditorParameterHints = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      cycle: true
    };
    super(98, "parameterHints", defaults, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize(414, null)
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: defaults.cycle,
        description: localize(415, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      cycle: boolean(input.cycle, this.defaultValue.cycle)
    };
  }
};
var EditorPixelRatio = class extends ComputedEditorOption {
  constructor() {
    super(163, 1);
  }
  compute(env2, options2, _) {
    return env2.pixelRatio;
  }
};
var PlaceholderOption = class extends BaseEditorOption {
  constructor() {
    super(100, "placeholder", void 0);
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    if (typeof input === "string") {
      return input;
    }
    return this.defaultValue;
  }
};
var EditorQuickSuggestions = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      other: "on",
      comments: "off",
      strings: "off"
    };
    const types = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [localize(416, null), localize(417, null), localize(418, null)]
      }
    ];
    super(102, "quickSuggestions", defaults, {
      type: "object",
      additionalProperties: false,
      properties: {
        strings: {
          anyOf: types,
          default: defaults.strings,
          description: localize(419, null)
        },
        comments: {
          anyOf: types,
          default: defaults.comments,
          description: localize(420, null)
        },
        other: {
          anyOf: types,
          default: defaults.other,
          description: localize(421, null)
        }
      },
      default: defaults,
      markdownDescription: localize(422, null, "`#editor.suggestOnTriggerCharacters#`")
    });
    this.defaultValue = defaults;
  }
  validate(input) {
    if (typeof input === "boolean") {
      const value = input ? "on" : "off";
      return { comments: value, strings: value, other: value };
    }
    if (!input || typeof input !== "object") {
      return this.defaultValue;
    }
    const { other, comments, strings } = input;
    const allowedValues = ["on", "inline", "off"];
    let validatedOther;
    let validatedComments;
    let validatedStrings;
    if (typeof other === "boolean") {
      validatedOther = other ? "on" : "off";
    } else {
      validatedOther = stringSet(other, this.defaultValue.other, allowedValues);
    }
    if (typeof comments === "boolean") {
      validatedComments = comments ? "on" : "off";
    } else {
      validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);
    }
    if (typeof strings === "boolean") {
      validatedStrings = strings ? "on" : "off";
    } else {
      validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);
    }
    return {
      other: validatedOther,
      comments: validatedComments,
      strings: validatedStrings
    };
  }
};
var RenderLineNumbersType;
(function(RenderLineNumbersType2) {
  RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
  RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
  RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
  RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
  RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var EditorRenderLineNumbersOption = class extends BaseEditorOption {
  constructor() {
    super(76, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        localize(423, null),
        localize(424, null),
        localize(425, null),
        localize(426, null)
      ],
      default: "on",
      description: localize(427, null)
    });
  }
  validate(lineNumbers) {
    let renderType = this.defaultValue.renderType;
    let renderFn = this.defaultValue.renderFn;
    if (typeof lineNumbers !== "undefined") {
      if (typeof lineNumbers === "function") {
        renderType = 4;
        renderFn = lineNumbers;
      } else if (lineNumbers === "interval") {
        renderType = 3;
      } else if (lineNumbers === "relative") {
        renderType = 2;
      } else if (lineNumbers === "on") {
        renderType = 1;
      } else {
        renderType = 0;
      }
    }
    return {
      renderType,
      renderFn
    };
  }
};
var EditorRulers = class extends BaseEditorOption {
  constructor() {
    const defaults = [];
    const columnSchema = { type: "number", description: localize(428, null) };
    super(116, "rulers", defaults, {
      type: "array",
      items: {
        anyOf: [
          columnSchema,
          {
            type: [
              "object"
            ],
            properties: {
              column: columnSchema,
              color: {
                type: "string",
                description: localize(429, null),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: defaults,
      description: localize(430, null)
    });
  }
  validate(input) {
    if (Array.isArray(input)) {
      const rulers = [];
      for (const _element of input) {
        if (typeof _element === "number") {
          rulers.push({
            column: EditorIntOption.clampedInt(_element, 0, 0, 1e4),
            color: null
          });
        } else if (_element && typeof _element === "object") {
          const element = _element;
          rulers.push({
            column: EditorIntOption.clampedInt(element.column, 0, 0, 1e4),
            color: element.color
          });
        }
      }
      rulers.sort((a, b) => a.column - b.column);
      return rulers;
    }
    return this.defaultValue;
  }
};
var ReadonlyMessage = class extends BaseEditorOption {
  constructor() {
    const defaults = void 0;
    super(105, "readOnlyMessage", defaults);
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    return _input;
  }
};
function _scrollbarVisibilityFromString(visibility, defaultValue) {
  if (typeof visibility !== "string") {
    return defaultValue;
  }
  switch (visibility) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
var EditorScrollbar = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: true,
      verticalHasArrows: false,
      horizontalHasArrows: false,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: true,
      alwaysConsumeMouseWheel: true,
      scrollByPage: false,
      ignoreHorizontalScrollbarInContentHeight: false
    };
    super(117, "scrollbar", defaults, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          localize(431, null),
          localize(432, null),
          localize(433, null)
        ],
        default: "auto",
        description: localize(434, null)
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          localize(435, null),
          localize(436, null),
          localize(437, null)
        ],
        default: "auto",
        description: localize(438, null)
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: defaults.verticalScrollbarSize,
        description: localize(439, null)
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: defaults.horizontalScrollbarSize,
        description: localize(440, null)
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: defaults.scrollByPage,
        description: localize(441, null)
      },
      "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
        type: "boolean",
        default: defaults.ignoreHorizontalScrollbarInContentHeight,
        description: localize(442, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3);
    const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),
      horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),
      useShadows: boolean(input.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize,
      horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1e3),
      verticalScrollbarSize,
      verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1e3),
      scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),
      ignoreHorizontalScrollbarInContentHeight: boolean(input.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
    };
  }
};
var inUntrustedWorkspace = "inUntrustedWorkspace";
var unicodeHighlightConfigKeys = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
var UnicodeHighlight = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      nonBasicASCII: inUntrustedWorkspace,
      invisibleCharacters: true,
      ambiguousCharacters: true,
      includeComments: inUntrustedWorkspace,
      includeStrings: true,
      allowedCharacters: {},
      allowedLocales: { _os: true, _vscode: true }
    };
    super(142, "unicodeHighlight", defaults, {
      [unicodeHighlightConfigKeys.nonBasicASCII]: {
        restricted: true,
        type: ["boolean", "string"],
        enum: [true, false, inUntrustedWorkspace],
        default: defaults.nonBasicASCII,
        description: localize(443, null)
      },
      [unicodeHighlightConfigKeys.invisibleCharacters]: {
        restricted: true,
        type: "boolean",
        default: defaults.invisibleCharacters,
        description: localize(444, null)
      },
      [unicodeHighlightConfigKeys.ambiguousCharacters]: {
        restricted: true,
        type: "boolean",
        default: defaults.ambiguousCharacters,
        description: localize(445, null)
      },
      [unicodeHighlightConfigKeys.includeComments]: {
        restricted: true,
        type: ["boolean", "string"],
        enum: [true, false, inUntrustedWorkspace],
        default: defaults.includeComments,
        description: localize(446, null)
      },
      [unicodeHighlightConfigKeys.includeStrings]: {
        restricted: true,
        type: ["boolean", "string"],
        enum: [true, false, inUntrustedWorkspace],
        default: defaults.includeStrings,
        description: localize(447, null)
      },
      [unicodeHighlightConfigKeys.allowedCharacters]: {
        restricted: true,
        type: "object",
        default: defaults.allowedCharacters,
        description: localize(448, null),
        additionalProperties: {
          type: "boolean"
        }
      },
      [unicodeHighlightConfigKeys.allowedLocales]: {
        restricted: true,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: defaults.allowedLocales,
        description: localize(449, null)
      }
    });
  }
  applyUpdate(value, update) {
    let didChange = false;
    if (update.allowedCharacters && value) {
      if (!equals2(value.allowedCharacters, update.allowedCharacters)) {
        value = { ...value, allowedCharacters: update.allowedCharacters };
        didChange = true;
      }
    }
    if (update.allowedLocales && value) {
      if (!equals2(value.allowedLocales, update.allowedLocales)) {
        value = { ...value, allowedLocales: update.allowedLocales };
        didChange = true;
      }
    }
    const result = super.applyUpdate(value, update);
    if (didChange) {
      return new ApplyUpdateResult(result.newValue, true);
    }
    return result;
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
      invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
      includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
      allowedCharacters: this.validateBooleanMap(input.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(input.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(map, defaultValue) {
    if (typeof map !== "object" || !map) {
      return defaultValue;
    }
    const result = {};
    for (const [key, value] of Object.entries(map)) {
      if (value === true) {
        result[key] = true;
      }
    }
    return result;
  }
};
var InlineEditorSuggest = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      mode: "subwordSmart",
      showToolbar: "onHover",
      suppressSuggestions: false,
      keepOnBlur: false,
      fontFamily: "default",
      syntaxHighlightingEnabled: true,
      minShowDelay: 0,
      suppressInSnippetMode: true,
      edits: {
        enabled: true,
        showCollapsed: false,
        renderSideBySide: "auto",
        allowCodeShifting: "always",
        showLongDistanceHint: true
      },
      triggerCommandOnProviderChange: false,
      experimental: {
        suppressInlineSuggestions: "",
        showOnSuggestConflict: "never",
        emptyResponseInformation: true
      }
    };
    super(71, "inlineSuggest", defaults, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize(450, null)
      },
      "editor.inlineSuggest.showToolbar": {
        type: "string",
        default: defaults.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          localize(451, null),
          localize(452, null),
          localize(453, null)
        ],
        description: localize(454, null)
      },
      "editor.inlineSuggest.syntaxHighlightingEnabled": {
        type: "boolean",
        default: defaults.syntaxHighlightingEnabled,
        description: localize(455, null)
      },
      "editor.inlineSuggest.suppressSuggestions": {
        type: "boolean",
        default: defaults.suppressSuggestions,
        description: localize(456, null)
      },
      "editor.inlineSuggest.suppressInSnippetMode": {
        type: "boolean",
        default: defaults.suppressInSnippetMode,
        description: localize(457, null)
      },
      "editor.inlineSuggest.minShowDelay": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e4,
        description: localize(458, null)
      },
      "editor.inlineSuggest.experimental.suppressInlineSuggestions": {
        type: "string",
        default: defaults.experimental.suppressInlineSuggestions,
        tags: ["experimental"],
        description: localize(459, null),
        experiment: {
          mode: "auto"
        }
      },
      "editor.inlineSuggest.experimental.emptyResponseInformation": {
        type: "boolean",
        default: defaults.experimental.emptyResponseInformation,
        tags: ["experimental"],
        description: localize(460, null),
        experiment: {
          mode: "auto"
        }
      },
      "editor.inlineSuggest.triggerCommandOnProviderChange": {
        type: "boolean",
        default: defaults.triggerCommandOnProviderChange,
        tags: ["experimental"],
        description: localize(461, null),
        experiment: {
          mode: "auto"
        }
      },
      "editor.inlineSuggest.experimental.showOnSuggestConflict": {
        type: "string",
        default: defaults.experimental.showOnSuggestConflict,
        tags: ["experimental"],
        enum: ["always", "never", "whenSuggestListIsIncomplete"],
        description: localize(462, null),
        experiment: {
          mode: "auto"
        }
      },
      "editor.inlineSuggest.fontFamily": {
        type: "string",
        default: defaults.fontFamily,
        description: localize(463, null)
      },
      "editor.inlineSuggest.edits.allowCodeShifting": {
        type: "string",
        default: defaults.edits.allowCodeShifting,
        description: localize(464, null),
        enum: ["always", "horizontal", "never"],
        tags: ["nextEditSuggestions"]
      },
      "editor.inlineSuggest.edits.showLongDistanceHint": {
        type: "boolean",
        default: defaults.edits.showLongDistanceHint,
        description: localize(465, null),
        tags: ["nextEditSuggestions", "experimental"]
      },
      "editor.inlineSuggest.edits.renderSideBySide": {
        type: "string",
        default: defaults.edits.renderSideBySide,
        description: localize(466, null),
        enum: ["auto", "never"],
        enumDescriptions: [
          localize(467, null),
          localize(468, null)
        ],
        tags: ["nextEditSuggestions"]
      },
      "editor.inlineSuggest.edits.showCollapsed": {
        type: "boolean",
        default: defaults.edits.showCollapsed,
        description: localize(469, null),
        tags: ["nextEditSuggestions"]
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      mode: stringSet(input.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
      showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),
      keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),
      fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
      syntaxHighlightingEnabled: boolean(input.syntaxHighlightingEnabled, this.defaultValue.syntaxHighlightingEnabled),
      minShowDelay: EditorIntOption.clampedInt(input.minShowDelay, 0, 0, 1e4),
      suppressInSnippetMode: boolean(input.suppressInSnippetMode, this.defaultValue.suppressInSnippetMode),
      edits: this._validateEdits(input.edits),
      triggerCommandOnProviderChange: boolean(input.triggerCommandOnProviderChange, this.defaultValue.triggerCommandOnProviderChange),
      experimental: this._validateExperimental(input.experimental)
    };
  }
  _validateEdits(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue.edits;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.edits.enabled),
      showCollapsed: boolean(input.showCollapsed, this.defaultValue.edits.showCollapsed),
      allowCodeShifting: stringSet(input.allowCodeShifting, this.defaultValue.edits.allowCodeShifting, ["always", "horizontal", "never"]),
      showLongDistanceHint: boolean(input.showLongDistanceHint, this.defaultValue.edits.showLongDistanceHint),
      renderSideBySide: stringSet(input.renderSideBySide, this.defaultValue.edits.renderSideBySide, ["never", "auto"])
    };
  }
  _validateExperimental(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue.experimental;
    }
    const input = _input;
    return {
      suppressInlineSuggestions: EditorStringOption.string(input.suppressInlineSuggestions, this.defaultValue.experimental.suppressInlineSuggestions),
      showOnSuggestConflict: stringSet(input.showOnSuggestConflict, this.defaultValue.experimental.showOnSuggestConflict, ["always", "never", "whenSuggestListIsIncomplete"]),
      emptyResponseInformation: boolean(input.emptyResponseInformation, this.defaultValue.experimental.emptyResponseInformation)
    };
  }
};
var BracketPairColorization = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(21, "bracketPairColorization", defaults, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: defaults.enabled,
        markdownDescription: localize(470, null, "`#workbench.colorCustomizations#`")
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: defaults.independentColorPoolPerBracketType,
        description: localize(471, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
};
var GuideOptions = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      bracketPairs: false,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: true,
      indentation: true,
      highlightActiveIndentation: true
    };
    super(22, "guides", defaults, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [true, "active", false],
        enumDescriptions: [
          localize(472, null),
          localize(473, null),
          localize(474, null)
        ],
        default: defaults.bracketPairs,
        description: localize(475, null)
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [true, "active", false],
        enumDescriptions: [
          localize(476, null),
          localize(477, null),
          localize(478, null)
        ],
        default: defaults.bracketPairsHorizontal,
        description: localize(479, null)
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: defaults.highlightActiveBracketPair,
        description: localize(480, null)
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: defaults.indentation,
        description: localize(481, null)
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [true, "always", false],
        enumDescriptions: [
          localize(482, null),
          localize(483, null),
          localize(484, null)
        ],
        default: defaults.highlightActiveIndentation,
        description: localize(485, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, "active"]),
      bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, "active"]),
      highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: boolean(input.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, "always"])
    };
  }
};
function primitiveSet(value, defaultValue, allowedValues) {
  const idx = allowedValues.indexOf(value);
  if (idx === -1) {
    return defaultValue;
  }
  return allowedValues[idx];
}
var EditorSuggest = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      insertMode: "insert",
      filterGraceful: true,
      snippetsPreventQuickSuggestions: false,
      localityBonus: false,
      shareSuggestSelections: false,
      selectionMode: "always",
      showIcons: true,
      showStatusBar: false,
      preview: false,
      previewMode: "subwordSmart",
      showInlineDetails: true,
      showMethods: true,
      showFunctions: true,
      showConstructors: true,
      showDeprecated: true,
      matchOnWordStartOnly: true,
      showFields: true,
      showVariables: true,
      showClasses: true,
      showStructs: true,
      showInterfaces: true,
      showModules: true,
      showProperties: true,
      showEvents: true,
      showOperators: true,
      showUnits: true,
      showValues: true,
      showConstants: true,
      showEnums: true,
      showEnumMembers: true,
      showKeywords: true,
      showWords: true,
      showColors: true,
      showFiles: true,
      showReferences: true,
      showFolders: true,
      showTypeParameters: true,
      showSnippets: true,
      showUsers: true,
      showIssues: true
    };
    super(134, "suggest", defaults, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          localize(486, null),
          localize(487, null)
        ],
        default: defaults.insertMode,
        description: localize(488, null)
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: defaults.filterGraceful,
        description: localize(489, null)
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: defaults.localityBonus,
        description: localize(490, null)
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: defaults.shareSuggestSelections,
        markdownDescription: localize(491, null)
      },
      "editor.suggest.selectionMode": {
        type: "string",
        enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
        enumDescriptions: [
          localize(492, null),
          localize(493, null),
          localize(494, null),
          localize(495, null)
        ],
        default: defaults.selectionMode,
        markdownDescription: localize(496, null, "`#editor.quickSuggestions#`", "`#editor.suggestOnTriggerCharacters#`")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: defaults.snippetsPreventQuickSuggestions,
        description: localize(497, null)
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: defaults.showIcons,
        description: localize(498, null)
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: defaults.showStatusBar,
        description: localize(499, null)
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: defaults.preview,
        description: localize(500, null)
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: defaults.showInlineDetails,
        description: localize(501, null)
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: localize(502, null)
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: localize(503, null)
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: true,
        markdownDescription: localize(504, null)
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: true,
        markdownDescription: localize(505, null)
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: true,
        markdownDescription: localize(506, null)
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: true,
        markdownDescription: localize(507, null)
      },
      "editor.suggest.matchOnWordStartOnly": {
        type: "boolean",
        default: true,
        markdownDescription: localize(508, null)
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: true,
        markdownDescription: localize(509, null)
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: true,
        markdownDescription: localize(510, null)
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: true,
        markdownDescription: localize(511, null)
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: true,
        markdownDescription: localize(512, null)
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: true,
        markdownDescription: localize(513, null)
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: true,
        markdownDescription: localize(514, null)
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: true,
        markdownDescription: localize(515, null)
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: true,
        markdownDescription: localize(516, null)
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: true,
        markdownDescription: localize(517, null)
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: true,
        markdownDescription: localize(518, null)
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: true,
        markdownDescription: localize(519, null)
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: true,
        markdownDescription: localize(520, null)
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: true,
        markdownDescription: localize(521, null)
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: true,
        markdownDescription: localize(522, null)
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: true,
        markdownDescription: localize(523, null)
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: true,
        markdownDescription: localize(524, null)
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: true,
        markdownDescription: localize(525, null)
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: true,
        markdownDescription: localize(526, null)
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: true,
        markdownDescription: localize(527, null)
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: true,
        markdownDescription: localize(528, null)
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: true,
        markdownDescription: localize(529, null)
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: true,
        markdownDescription: localize(530, null)
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: true,
        markdownDescription: localize(531, null)
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: true,
        markdownDescription: localize(532, null)
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: true,
        markdownDescription: localize(533, null)
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
      showIcons: boolean(input.showIcons, this.defaultValue.showIcons),
      showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),
      preview: boolean(input.preview, this.defaultValue.preview),
      previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: boolean(input.showMethods, this.defaultValue.showMethods),
      showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),
      showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),
      matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
      showFields: boolean(input.showFields, this.defaultValue.showFields),
      showVariables: boolean(input.showVariables, this.defaultValue.showVariables),
      showClasses: boolean(input.showClasses, this.defaultValue.showClasses),
      showStructs: boolean(input.showStructs, this.defaultValue.showStructs),
      showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),
      showModules: boolean(input.showModules, this.defaultValue.showModules),
      showProperties: boolean(input.showProperties, this.defaultValue.showProperties),
      showEvents: boolean(input.showEvents, this.defaultValue.showEvents),
      showOperators: boolean(input.showOperators, this.defaultValue.showOperators),
      showUnits: boolean(input.showUnits, this.defaultValue.showUnits),
      showValues: boolean(input.showValues, this.defaultValue.showValues),
      showConstants: boolean(input.showConstants, this.defaultValue.showConstants),
      showEnums: boolean(input.showEnums, this.defaultValue.showEnums),
      showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),
      showWords: boolean(input.showWords, this.defaultValue.showWords),
      showColors: boolean(input.showColors, this.defaultValue.showColors),
      showFiles: boolean(input.showFiles, this.defaultValue.showFiles),
      showReferences: boolean(input.showReferences, this.defaultValue.showReferences),
      showFolders: boolean(input.showFolders, this.defaultValue.showFolders),
      showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),
      showUsers: boolean(input.showUsers, this.defaultValue.showUsers),
      showIssues: boolean(input.showIssues, this.defaultValue.showIssues)
    };
  }
};
var SmartSelect = class extends BaseEditorOption {
  constructor() {
    super(129, "smartSelect", {
      selectLeadingAndTrailingWhitespace: true,
      selectSubwords: true
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: localize(534, null),
        default: true,
        type: "boolean"
      },
      "editor.smartSelect.selectSubwords": {
        description: localize(535, null),
        default: true,
        type: "boolean"
      }
    });
  }
  validate(input) {
    if (!input || typeof input !== "object") {
      return this.defaultValue;
    }
    return {
      selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
      selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords)
    };
  }
};
var WordSegmenterLocales = class extends BaseEditorOption {
  constructor() {
    const defaults = [];
    super(147, "wordSegmenterLocales", defaults, {
      anyOf: [
        {
          type: "string"
        },
        {
          type: "array",
          items: {
            type: "string"
          }
        }
      ],
      description: localize(536, null),
      type: "array",
      items: {
        type: "string"
      },
      default: defaults
    });
  }
  validate(input) {
    if (typeof input === "string") {
      input = [input];
    }
    if (Array.isArray(input)) {
      const validLocales = [];
      for (const locale of input) {
        if (typeof locale === "string") {
          try {
            if (Intl.Segmenter.supportedLocalesOf(locale).length > 0) {
              validLocales.push(locale);
            }
          } catch {
          }
        }
      }
      return validLocales;
    }
    return this.defaultValue;
  }
};
var WrappingIndent;
(function(WrappingIndent2) {
  WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
  WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
  WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
  WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));
var WrappingIndentOption = class extends BaseEditorOption {
  constructor() {
    super(155, "wrappingIndent", 1, {
      "editor.wrappingIndent": {
        type: "string",
        enum: ["none", "same", "indent", "deepIndent"],
        enumDescriptions: [
          localize(537, null),
          localize(538, null),
          localize(539, null),
          localize(540, null)
        ],
        description: localize(541, null),
        default: "same"
      }
    });
  }
  validate(input) {
    switch (input) {
      case "none":
        return 0;
      case "same":
        return 1;
      case "indent":
        return 2;
      case "deepIndent":
        return 3;
    }
    return 1;
  }
  compute(env2, options2, value) {
    const accessibilitySupport = options2.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    if (accessibilitySupport === 2) {
      return 0;
    }
    return value;
  }
};
var EditorWrappingInfoComputer = class extends ComputedEditorOption {
  constructor() {
    super(166, {
      isDominatedByLongLines: false,
      isWordWrapMinified: false,
      isViewportWrapping: false,
      wrappingColumn: -1
    });
  }
  compute(env2, options2, _) {
    const layoutInfo = options2.get(
      165
      /* EditorOption.layoutInfo */
    );
    return {
      isDominatedByLongLines: env2.isDominatedByLongLines,
      isWordWrapMinified: layoutInfo.isWordWrapMinified,
      isViewportWrapping: layoutInfo.isViewportWrapping,
      wrappingColumn: layoutInfo.wrappingColumn
    };
  }
};
var EditorDropIntoEditor = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: true, showDropSelector: "afterDrop" };
    super(43, "dropIntoEditor", defaults, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: defaults.enabled,
        markdownDescription: localize(542, null)
      },
      "editor.dropIntoEditor.showDropSelector": {
        type: "string",
        markdownDescription: localize(543, null),
        enum: [
          "afterDrop",
          "never"
        ],
        enumDescriptions: [
          localize(544, null),
          localize(545, null)
        ],
        default: "afterDrop"
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
    };
  }
};
var EditorPasteAs = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: true, showPasteSelector: "afterPaste" };
    super(97, "pasteAs", defaults, {
      "editor.pasteAs.enabled": {
        type: "boolean",
        default: defaults.enabled,
        markdownDescription: localize(546, null)
      },
      "editor.pasteAs.showPasteSelector": {
        type: "string",
        markdownDescription: localize(547, null),
        enum: [
          "afterPaste",
          "never"
        ],
        enumDescriptions: [
          localize(548, null),
          localize(549, null)
        ],
        default: "afterPaste"
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
    };
  }
};
var editorOptionsRegistry = [];
function register2(option) {
  editorOptionsRegistry[option.id] = option;
  return option;
}
var EditorOption;
(function(EditorOption2) {
  EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
  EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
  EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
  EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
  EditorOption2[EditorOption2["allowOverflow"] = 4] = "allowOverflow";
  EditorOption2[EditorOption2["allowVariableLineHeights"] = 5] = "allowVariableLineHeights";
  EditorOption2[EditorOption2["allowVariableFonts"] = 6] = "allowVariableFonts";
  EditorOption2[EditorOption2["allowVariableFontsInAccessibilityMode"] = 7] = "allowVariableFontsInAccessibilityMode";
  EditorOption2[EditorOption2["ariaLabel"] = 8] = "ariaLabel";
  EditorOption2[EditorOption2["ariaRequired"] = 9] = "ariaRequired";
  EditorOption2[EditorOption2["autoClosingBrackets"] = 10] = "autoClosingBrackets";
  EditorOption2[EditorOption2["autoClosingComments"] = 11] = "autoClosingComments";
  EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 12] = "screenReaderAnnounceInlineSuggestion";
  EditorOption2[EditorOption2["autoClosingDelete"] = 13] = "autoClosingDelete";
  EditorOption2[EditorOption2["autoClosingOvertype"] = 14] = "autoClosingOvertype";
  EditorOption2[EditorOption2["autoClosingQuotes"] = 15] = "autoClosingQuotes";
  EditorOption2[EditorOption2["autoIndent"] = 16] = "autoIndent";
  EditorOption2[EditorOption2["autoIndentOnPaste"] = 17] = "autoIndentOnPaste";
  EditorOption2[EditorOption2["autoIndentOnPasteWithinString"] = 18] = "autoIndentOnPasteWithinString";
  EditorOption2[EditorOption2["automaticLayout"] = 19] = "automaticLayout";
  EditorOption2[EditorOption2["autoSurround"] = 20] = "autoSurround";
  EditorOption2[EditorOption2["bracketPairColorization"] = 21] = "bracketPairColorization";
  EditorOption2[EditorOption2["guides"] = 22] = "guides";
  EditorOption2[EditorOption2["codeLens"] = 23] = "codeLens";
  EditorOption2[EditorOption2["codeLensFontFamily"] = 24] = "codeLensFontFamily";
  EditorOption2[EditorOption2["codeLensFontSize"] = 25] = "codeLensFontSize";
  EditorOption2[EditorOption2["colorDecorators"] = 26] = "colorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsLimit"] = 27] = "colorDecoratorsLimit";
  EditorOption2[EditorOption2["columnSelection"] = 28] = "columnSelection";
  EditorOption2[EditorOption2["comments"] = 29] = "comments";
  EditorOption2[EditorOption2["contextmenu"] = 30] = "contextmenu";
  EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 31] = "copyWithSyntaxHighlighting";
  EditorOption2[EditorOption2["cursorBlinking"] = 32] = "cursorBlinking";
  EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 33] = "cursorSmoothCaretAnimation";
  EditorOption2[EditorOption2["cursorStyle"] = 34] = "cursorStyle";
  EditorOption2[EditorOption2["cursorSurroundingLines"] = 35] = "cursorSurroundingLines";
  EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 36] = "cursorSurroundingLinesStyle";
  EditorOption2[EditorOption2["cursorWidth"] = 37] = "cursorWidth";
  EditorOption2[EditorOption2["cursorHeight"] = 38] = "cursorHeight";
  EditorOption2[EditorOption2["disableLayerHinting"] = 39] = "disableLayerHinting";
  EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 40] = "disableMonospaceOptimizations";
  EditorOption2[EditorOption2["domReadOnly"] = 41] = "domReadOnly";
  EditorOption2[EditorOption2["dragAndDrop"] = 42] = "dragAndDrop";
  EditorOption2[EditorOption2["dropIntoEditor"] = 43] = "dropIntoEditor";
  EditorOption2[EditorOption2["editContext"] = 44] = "editContext";
  EditorOption2[EditorOption2["emptySelectionClipboard"] = 45] = "emptySelectionClipboard";
  EditorOption2[EditorOption2["experimentalGpuAcceleration"] = 46] = "experimentalGpuAcceleration";
  EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 47] = "experimentalWhitespaceRendering";
  EditorOption2[EditorOption2["extraEditorClassName"] = 48] = "extraEditorClassName";
  EditorOption2[EditorOption2["fastScrollSensitivity"] = 49] = "fastScrollSensitivity";
  EditorOption2[EditorOption2["find"] = 50] = "find";
  EditorOption2[EditorOption2["fixedOverflowWidgets"] = 51] = "fixedOverflowWidgets";
  EditorOption2[EditorOption2["folding"] = 52] = "folding";
  EditorOption2[EditorOption2["foldingStrategy"] = 53] = "foldingStrategy";
  EditorOption2[EditorOption2["foldingHighlight"] = 54] = "foldingHighlight";
  EditorOption2[EditorOption2["foldingImportsByDefault"] = 55] = "foldingImportsByDefault";
  EditorOption2[EditorOption2["foldingMaximumRegions"] = 56] = "foldingMaximumRegions";
  EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 57] = "unfoldOnClickAfterEndOfLine";
  EditorOption2[EditorOption2["fontFamily"] = 58] = "fontFamily";
  EditorOption2[EditorOption2["fontInfo"] = 59] = "fontInfo";
  EditorOption2[EditorOption2["fontLigatures"] = 60] = "fontLigatures";
  EditorOption2[EditorOption2["fontSize"] = 61] = "fontSize";
  EditorOption2[EditorOption2["fontWeight"] = 62] = "fontWeight";
  EditorOption2[EditorOption2["fontVariations"] = 63] = "fontVariations";
  EditorOption2[EditorOption2["formatOnPaste"] = 64] = "formatOnPaste";
  EditorOption2[EditorOption2["formatOnType"] = 65] = "formatOnType";
  EditorOption2[EditorOption2["glyphMargin"] = 66] = "glyphMargin";
  EditorOption2[EditorOption2["gotoLocation"] = 67] = "gotoLocation";
  EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 68] = "hideCursorInOverviewRuler";
  EditorOption2[EditorOption2["hover"] = 69] = "hover";
  EditorOption2[EditorOption2["inDiffEditor"] = 70] = "inDiffEditor";
  EditorOption2[EditorOption2["inlineSuggest"] = 71] = "inlineSuggest";
  EditorOption2[EditorOption2["letterSpacing"] = 72] = "letterSpacing";
  EditorOption2[EditorOption2["lightbulb"] = 73] = "lightbulb";
  EditorOption2[EditorOption2["lineDecorationsWidth"] = 74] = "lineDecorationsWidth";
  EditorOption2[EditorOption2["lineHeight"] = 75] = "lineHeight";
  EditorOption2[EditorOption2["lineNumbers"] = 76] = "lineNumbers";
  EditorOption2[EditorOption2["lineNumbersMinChars"] = 77] = "lineNumbersMinChars";
  EditorOption2[EditorOption2["linkedEditing"] = 78] = "linkedEditing";
  EditorOption2[EditorOption2["links"] = 79] = "links";
  EditorOption2[EditorOption2["matchBrackets"] = 80] = "matchBrackets";
  EditorOption2[EditorOption2["minimap"] = 81] = "minimap";
  EditorOption2[EditorOption2["mouseStyle"] = 82] = "mouseStyle";
  EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 83] = "mouseWheelScrollSensitivity";
  EditorOption2[EditorOption2["mouseWheelZoom"] = 84] = "mouseWheelZoom";
  EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 85] = "multiCursorMergeOverlapping";
  EditorOption2[EditorOption2["multiCursorModifier"] = 86] = "multiCursorModifier";
  EditorOption2[EditorOption2["mouseMiddleClickAction"] = 87] = "mouseMiddleClickAction";
  EditorOption2[EditorOption2["multiCursorPaste"] = 88] = "multiCursorPaste";
  EditorOption2[EditorOption2["multiCursorLimit"] = 89] = "multiCursorLimit";
  EditorOption2[EditorOption2["occurrencesHighlight"] = 90] = "occurrencesHighlight";
  EditorOption2[EditorOption2["occurrencesHighlightDelay"] = 91] = "occurrencesHighlightDelay";
  EditorOption2[EditorOption2["overtypeCursorStyle"] = 92] = "overtypeCursorStyle";
  EditorOption2[EditorOption2["overtypeOnPaste"] = 93] = "overtypeOnPaste";
  EditorOption2[EditorOption2["overviewRulerBorder"] = 94] = "overviewRulerBorder";
  EditorOption2[EditorOption2["overviewRulerLanes"] = 95] = "overviewRulerLanes";
  EditorOption2[EditorOption2["padding"] = 96] = "padding";
  EditorOption2[EditorOption2["pasteAs"] = 97] = "pasteAs";
  EditorOption2[EditorOption2["parameterHints"] = 98] = "parameterHints";
  EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 99] = "peekWidgetDefaultFocus";
  EditorOption2[EditorOption2["placeholder"] = 100] = "placeholder";
  EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 101] = "definitionLinkOpensInPeek";
  EditorOption2[EditorOption2["quickSuggestions"] = 102] = "quickSuggestions";
  EditorOption2[EditorOption2["quickSuggestionsDelay"] = 103] = "quickSuggestionsDelay";
  EditorOption2[EditorOption2["readOnly"] = 104] = "readOnly";
  EditorOption2[EditorOption2["readOnlyMessage"] = 105] = "readOnlyMessage";
  EditorOption2[EditorOption2["renameOnType"] = 106] = "renameOnType";
  EditorOption2[EditorOption2["renderRichScreenReaderContent"] = 107] = "renderRichScreenReaderContent";
  EditorOption2[EditorOption2["renderControlCharacters"] = 108] = "renderControlCharacters";
  EditorOption2[EditorOption2["renderFinalNewline"] = 109] = "renderFinalNewline";
  EditorOption2[EditorOption2["renderLineHighlight"] = 110] = "renderLineHighlight";
  EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 111] = "renderLineHighlightOnlyWhenFocus";
  EditorOption2[EditorOption2["renderValidationDecorations"] = 112] = "renderValidationDecorations";
  EditorOption2[EditorOption2["renderWhitespace"] = 113] = "renderWhitespace";
  EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 114] = "revealHorizontalRightPadding";
  EditorOption2[EditorOption2["roundedSelection"] = 115] = "roundedSelection";
  EditorOption2[EditorOption2["rulers"] = 116] = "rulers";
  EditorOption2[EditorOption2["scrollbar"] = 117] = "scrollbar";
  EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 118] = "scrollBeyondLastColumn";
  EditorOption2[EditorOption2["scrollBeyondLastLine"] = 119] = "scrollBeyondLastLine";
  EditorOption2[EditorOption2["scrollPredominantAxis"] = 120] = "scrollPredominantAxis";
  EditorOption2[EditorOption2["selectionClipboard"] = 121] = "selectionClipboard";
  EditorOption2[EditorOption2["selectionHighlight"] = 122] = "selectionHighlight";
  EditorOption2[EditorOption2["selectionHighlightMaxLength"] = 123] = "selectionHighlightMaxLength";
  EditorOption2[EditorOption2["selectionHighlightMultiline"] = 124] = "selectionHighlightMultiline";
  EditorOption2[EditorOption2["selectOnLineNumbers"] = 125] = "selectOnLineNumbers";
  EditorOption2[EditorOption2["showFoldingControls"] = 126] = "showFoldingControls";
  EditorOption2[EditorOption2["showUnused"] = 127] = "showUnused";
  EditorOption2[EditorOption2["snippetSuggestions"] = 128] = "snippetSuggestions";
  EditorOption2[EditorOption2["smartSelect"] = 129] = "smartSelect";
  EditorOption2[EditorOption2["smoothScrolling"] = 130] = "smoothScrolling";
  EditorOption2[EditorOption2["stickyScroll"] = 131] = "stickyScroll";
  EditorOption2[EditorOption2["stickyTabStops"] = 132] = "stickyTabStops";
  EditorOption2[EditorOption2["stopRenderingLineAfter"] = 133] = "stopRenderingLineAfter";
  EditorOption2[EditorOption2["suggest"] = 134] = "suggest";
  EditorOption2[EditorOption2["suggestFontSize"] = 135] = "suggestFontSize";
  EditorOption2[EditorOption2["suggestLineHeight"] = 136] = "suggestLineHeight";
  EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 137] = "suggestOnTriggerCharacters";
  EditorOption2[EditorOption2["suggestSelection"] = 138] = "suggestSelection";
  EditorOption2[EditorOption2["tabCompletion"] = 139] = "tabCompletion";
  EditorOption2[EditorOption2["tabIndex"] = 140] = "tabIndex";
  EditorOption2[EditorOption2["trimWhitespaceOnDelete"] = 141] = "trimWhitespaceOnDelete";
  EditorOption2[EditorOption2["unicodeHighlighting"] = 142] = "unicodeHighlighting";
  EditorOption2[EditorOption2["unusualLineTerminators"] = 143] = "unusualLineTerminators";
  EditorOption2[EditorOption2["useShadowDOM"] = 144] = "useShadowDOM";
  EditorOption2[EditorOption2["useTabStops"] = 145] = "useTabStops";
  EditorOption2[EditorOption2["wordBreak"] = 146] = "wordBreak";
  EditorOption2[EditorOption2["wordSegmenterLocales"] = 147] = "wordSegmenterLocales";
  EditorOption2[EditorOption2["wordSeparators"] = 148] = "wordSeparators";
  EditorOption2[EditorOption2["wordWrap"] = 149] = "wordWrap";
  EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 150] = "wordWrapBreakAfterCharacters";
  EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 151] = "wordWrapBreakBeforeCharacters";
  EditorOption2[EditorOption2["wordWrapColumn"] = 152] = "wordWrapColumn";
  EditorOption2[EditorOption2["wordWrapOverride1"] = 153] = "wordWrapOverride1";
  EditorOption2[EditorOption2["wordWrapOverride2"] = 154] = "wordWrapOverride2";
  EditorOption2[EditorOption2["wrappingIndent"] = 155] = "wrappingIndent";
  EditorOption2[EditorOption2["wrappingStrategy"] = 156] = "wrappingStrategy";
  EditorOption2[EditorOption2["showDeprecated"] = 157] = "showDeprecated";
  EditorOption2[EditorOption2["inertialScroll"] = 158] = "inertialScroll";
  EditorOption2[EditorOption2["inlayHints"] = 159] = "inlayHints";
  EditorOption2[EditorOption2["wrapOnEscapedLineFeeds"] = 160] = "wrapOnEscapedLineFeeds";
  EditorOption2[EditorOption2["effectiveCursorStyle"] = 161] = "effectiveCursorStyle";
  EditorOption2[EditorOption2["editorClassName"] = 162] = "editorClassName";
  EditorOption2[EditorOption2["pixelRatio"] = 163] = "pixelRatio";
  EditorOption2[EditorOption2["tabFocusMode"] = 164] = "tabFocusMode";
  EditorOption2[EditorOption2["layoutInfo"] = 165] = "layoutInfo";
  EditorOption2[EditorOption2["wrappingInfo"] = 166] = "wrappingInfo";
  EditorOption2[EditorOption2["defaultColorDecorators"] = 167] = "defaultColorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 168] = "colorDecoratorsActivatedOn";
  EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 169] = "inlineCompletionsAccessibilityVerbose";
  EditorOption2[EditorOption2["effectiveEditContext"] = 170] = "effectiveEditContext";
  EditorOption2[EditorOption2["scrollOnMiddleClick"] = 171] = "scrollOnMiddleClick";
  EditorOption2[EditorOption2["effectiveAllowVariableFonts"] = 172] = "effectiveAllowVariableFonts";
})(EditorOption || (EditorOption = {}));
var EditorOptions = {
  acceptSuggestionOnCommitCharacter: register2(new EditorBooleanOption(0, "acceptSuggestionOnCommitCharacter", true, { markdownDescription: localize(550, null) })),
  acceptSuggestionOnEnter: register2(new EditorStringEnumOption(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      localize(551, null),
      ""
    ],
    markdownDescription: localize(552, null)
  })),
  accessibilitySupport: register2(new EditorAccessibilitySupport()),
  accessibilityPageSize: register2(new EditorIntOption(3, "accessibilityPageSize", 500, 1, 1073741824, {
    description: localize(553, null),
    tags: ["accessibility"]
  })),
  allowOverflow: register2(new EditorBooleanOption(4, "allowOverflow", true)),
  allowVariableLineHeights: register2(new EditorBooleanOption(5, "allowVariableLineHeights", true, {
    description: localize(554, null)
  })),
  allowVariableFonts: register2(new EditorBooleanOption(6, "allowVariableFonts", true, {
    description: localize(555, null)
  })),
  allowVariableFontsInAccessibilityMode: register2(new EditorBooleanOption(7, "allowVariableFontsInAccessibilityMode", false, {
    description: localize(556, null),
    tags: ["accessibility"]
  })),
  ariaLabel: register2(new EditorStringOption(8, "ariaLabel", localize(557, null))),
  ariaRequired: register2(new EditorBooleanOption(9, "ariaRequired", false, void 0)),
  screenReaderAnnounceInlineSuggestion: register2(new EditorBooleanOption(12, "screenReaderAnnounceInlineSuggestion", true, {
    description: localize(558, null),
    tags: ["accessibility"]
  })),
  autoClosingBrackets: register2(new EditorStringEnumOption(10, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize(559, null),
      localize(560, null),
      ""
    ],
    description: localize(561, null)
  })),
  autoClosingComments: register2(new EditorStringEnumOption(11, "autoClosingComments", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize(562, null),
      localize(563, null),
      ""
    ],
    description: localize(564, null)
  })),
  autoClosingDelete: register2(new EditorStringEnumOption(13, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      localize(565, null),
      ""
    ],
    description: localize(566, null)
  })),
  autoClosingOvertype: register2(new EditorStringEnumOption(14, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      localize(567, null),
      ""
    ],
    description: localize(568, null)
  })),
  autoClosingQuotes: register2(new EditorStringEnumOption(15, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize(569, null),
      localize(570, null),
      ""
    ],
    description: localize(571, null)
  })),
  autoIndent: register2(new EditorEnumOption(16, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], _autoIndentFromString, {
    enumDescriptions: [
      localize(572, null),
      localize(573, null),
      localize(574, null),
      localize(575, null),
      localize(576, null)
    ],
    description: localize(577, null)
  })),
  autoIndentOnPaste: register2(new EditorBooleanOption(17, "autoIndentOnPaste", false, { description: localize(578, null) })),
  autoIndentOnPasteWithinString: register2(new EditorBooleanOption(18, "autoIndentOnPasteWithinString", true, { description: localize(579, null) })),
  automaticLayout: register2(new EditorBooleanOption(19, "automaticLayout", false)),
  autoSurround: register2(new EditorStringEnumOption(20, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      localize(580, null),
      localize(581, null),
      localize(582, null),
      ""
    ],
    description: localize(583, null)
  })),
  bracketPairColorization: register2(new BracketPairColorization()),
  bracketPairGuides: register2(new GuideOptions()),
  stickyTabStops: register2(new EditorBooleanOption(132, "stickyTabStops", false, { description: localize(584, null) })),
  codeLens: register2(new EditorBooleanOption(23, "codeLens", true, { description: localize(585, null) })),
  codeLensFontFamily: register2(new EditorStringOption(24, "codeLensFontFamily", "", { description: localize(586, null) })),
  codeLensFontSize: register2(new EditorIntOption(25, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    markdownDescription: localize(587, null)
  })),
  colorDecorators: register2(new EditorBooleanOption(26, "colorDecorators", true, { description: localize(588, null) })),
  colorDecoratorActivatedOn: register2(new EditorStringEnumOption(168, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
    enumDescriptions: [
      localize(589, null),
      localize(590, null),
      localize(591, null)
    ],
    description: localize(592, null)
  })),
  colorDecoratorsLimit: register2(new EditorIntOption(27, "colorDecoratorsLimit", 500, 1, 1e6, {
    markdownDescription: localize(593, null)
  })),
  columnSelection: register2(new EditorBooleanOption(28, "columnSelection", false, { description: localize(594, null) })),
  comments: register2(new EditorComments()),
  contextmenu: register2(new EditorBooleanOption(30, "contextmenu", true)),
  copyWithSyntaxHighlighting: register2(new EditorBooleanOption(31, "copyWithSyntaxHighlighting", true, { description: localize(595, null) })),
  cursorBlinking: register2(new EditorEnumOption(32, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], cursorBlinkingStyleFromString, { description: localize(596, null) })),
  cursorSmoothCaretAnimation: register2(new EditorStringEnumOption(33, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
    enumDescriptions: [
      localize(597, null),
      localize(598, null),
      localize(599, null)
    ],
    description: localize(600, null)
  })),
  cursorStyle: register2(new EditorEnumOption(34, "cursorStyle", TextEditorCursorStyle.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], cursorStyleFromString, { description: localize(601, null) })),
  overtypeCursorStyle: register2(new EditorEnumOption(92, "overtypeCursorStyle", TextEditorCursorStyle.Block, "block", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], cursorStyleFromString, { description: localize(602, null) })),
  cursorSurroundingLines: register2(new EditorIntOption(35, "cursorSurroundingLines", 0, 0, 1073741824, { description: localize(603, null) })),
  cursorSurroundingLinesStyle: register2(new EditorStringEnumOption(36, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      localize(604, null),
      localize(605, null)
    ],
    markdownDescription: localize(606, null)
  })),
  cursorWidth: register2(new EditorIntOption(37, "cursorWidth", 0, 0, 1073741824, { markdownDescription: localize(607, null) })),
  cursorHeight: register2(new EditorIntOption(38, "cursorHeight", 0, 0, 1073741824, { markdownDescription: localize(608, null) })),
  disableLayerHinting: register2(new EditorBooleanOption(39, "disableLayerHinting", false)),
  disableMonospaceOptimizations: register2(new EditorBooleanOption(40, "disableMonospaceOptimizations", false)),
  domReadOnly: register2(new EditorBooleanOption(41, "domReadOnly", false)),
  dragAndDrop: register2(new EditorBooleanOption(42, "dragAndDrop", true, { description: localize(609, null) })),
  emptySelectionClipboard: register2(new EditorEmptySelectionClipboard()),
  dropIntoEditor: register2(new EditorDropIntoEditor()),
  editContext: register2(new EditorBooleanOption(44, "editContext", true, {
    description: localize(610, null),
    included: isChrome || isEdge || isNative
  })),
  renderRichScreenReaderContent: register2(new EditorBooleanOption(107, "renderRichScreenReaderContent", false, {
    markdownDescription: localize(611, null)
  })),
  stickyScroll: register2(new EditorStickyScroll()),
  experimentalGpuAcceleration: register2(new EditorStringEnumOption(46, "experimentalGpuAcceleration", "off", ["off", "on"], {
    tags: ["experimental"],
    enumDescriptions: [
      localize(612, null),
      localize(613, null)
    ],
    description: localize(614, null)
  })),
  experimentalWhitespaceRendering: register2(new EditorStringEnumOption(47, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
    enumDescriptions: [
      localize(615, null),
      localize(616, null),
      localize(617, null)
    ],
    description: localize(618, null)
  })),
  extraEditorClassName: register2(new EditorStringOption(48, "extraEditorClassName", "")),
  fastScrollSensitivity: register2(new EditorFloatOption(49, "fastScrollSensitivity", 5, (x) => x <= 0 ? 5 : x, { markdownDescription: localize(619, null) })),
  find: register2(new EditorFind()),
  fixedOverflowWidgets: register2(new EditorBooleanOption(51, "fixedOverflowWidgets", false)),
  folding: register2(new EditorBooleanOption(52, "folding", true, { description: localize(620, null) })),
  foldingStrategy: register2(new EditorStringEnumOption(53, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      localize(621, null),
      localize(622, null)
    ],
    description: localize(623, null)
  })),
  foldingHighlight: register2(new EditorBooleanOption(54, "foldingHighlight", true, { description: localize(624, null) })),
  foldingImportsByDefault: register2(new EditorBooleanOption(55, "foldingImportsByDefault", false, { description: localize(625, null) })),
  foldingMaximumRegions: register2(new EditorIntOption(
    56,
    "foldingMaximumRegions",
    5e3,
    10,
    65e3,
    // limit must be less than foldingRanges MAX_FOLDING_REGIONS
    { description: localize(626, null) }
  )),
  unfoldOnClickAfterEndOfLine: register2(new EditorBooleanOption(57, "unfoldOnClickAfterEndOfLine", false, { description: localize(627, null) })),
  fontFamily: register2(new EditorStringOption(58, "fontFamily", EDITOR_FONT_DEFAULTS.fontFamily, { description: localize(628, null) })),
  fontInfo: register2(new EditorFontInfo()),
  fontLigatures2: register2(new EditorFontLigatures()),
  fontSize: register2(new EditorFontSize()),
  fontWeight: register2(new EditorFontWeight()),
  fontVariations: register2(new EditorFontVariations()),
  formatOnPaste: register2(new EditorBooleanOption(64, "formatOnPaste", false, { description: localize(629, null) })),
  formatOnType: register2(new EditorBooleanOption(65, "formatOnType", false, { description: localize(630, null) })),
  glyphMargin: register2(new EditorBooleanOption(66, "glyphMargin", true, { description: localize(631, null) })),
  gotoLocation: register2(new EditorGoToLocation()),
  hideCursorInOverviewRuler: register2(new EditorBooleanOption(68, "hideCursorInOverviewRuler", false, { description: localize(632, null) })),
  hover: register2(new EditorHover()),
  inDiffEditor: register2(new EditorBooleanOption(70, "inDiffEditor", false)),
  inertialScroll: register2(new EditorBooleanOption(158, "inertialScroll", false, { description: localize(633, null) })),
  letterSpacing: register2(new EditorFloatOption(72, "letterSpacing", EDITOR_FONT_DEFAULTS.letterSpacing, (x) => EditorFloatOption.clamp(x, -5, 20), { description: localize(634, null) })),
  lightbulb: register2(new EditorLightbulb()),
  lineDecorationsWidth: register2(new EditorLineDecorationsWidth()),
  lineHeight: register2(new EditorLineHeight()),
  lineNumbers: register2(new EditorRenderLineNumbersOption()),
  lineNumbersMinChars: register2(new EditorIntOption(77, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: register2(new EditorBooleanOption(78, "linkedEditing", false, { description: localize(635, null) })),
  links: register2(new EditorBooleanOption(79, "links", true, { description: localize(636, null) })),
  matchBrackets: register2(new EditorStringEnumOption(80, "matchBrackets", "always", ["always", "near", "never"], { description: localize(637, null) })),
  minimap: register2(new EditorMinimap()),
  mouseStyle: register2(new EditorStringEnumOption(82, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: register2(new EditorFloatOption(83, "mouseWheelScrollSensitivity", 1, (x) => x === 0 ? 1 : x, { markdownDescription: localize(638, null) })),
  mouseWheelZoom: register2(new EditorBooleanOption(84, "mouseWheelZoom", false, {
    markdownDescription: isMacintosh ? localize(639, null) : localize(640, null)
  })),
  multiCursorMergeOverlapping: register2(new EditorBooleanOption(85, "multiCursorMergeOverlapping", true, { description: localize(641, null) })),
  multiCursorModifier: register2(new EditorEnumOption(86, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], _multiCursorModifierFromString, {
    markdownEnumDescriptions: [
      localize(642, null),
      localize(643, null)
    ],
    markdownDescription: localize(644, null)
  })),
  mouseMiddleClickAction: register2(new EditorStringEnumOption(87, "mouseMiddleClickAction", "default", ["default", "openLink", "ctrlLeftClick"], { description: localize(645, null) })),
  multiCursorPaste: register2(new EditorStringEnumOption(88, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      localize(646, null),
      localize(647, null)
    ],
    markdownDescription: localize(648, null)
  })),
  multiCursorLimit: register2(new EditorIntOption(89, "multiCursorLimit", 1e4, 1, 1e5, {
    markdownDescription: localize(649, null)
  })),
  occurrencesHighlight: register2(new EditorStringEnumOption(90, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
    markdownEnumDescriptions: [
      localize(650, null),
      localize(651, null),
      localize(652, null)
    ],
    markdownDescription: localize(653, null)
  })),
  occurrencesHighlightDelay: register2(new EditorIntOption(91, "occurrencesHighlightDelay", 0, 0, 2e3, {
    description: localize(654, null),
    tags: ["preview"]
  })),
  overtypeOnPaste: register2(new EditorBooleanOption(93, "overtypeOnPaste", true, { description: localize(655, null) })),
  overviewRulerBorder: register2(new EditorBooleanOption(94, "overviewRulerBorder", true, { description: localize(656, null) })),
  overviewRulerLanes: register2(new EditorIntOption(95, "overviewRulerLanes", 3, 0, 3)),
  padding: register2(new EditorPadding()),
  pasteAs: register2(new EditorPasteAs()),
  parameterHints: register2(new EditorParameterHints()),
  peekWidgetDefaultFocus: register2(new EditorStringEnumOption(99, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      localize(657, null),
      localize(658, null)
    ],
    description: localize(659, null)
  })),
  placeholder: register2(new PlaceholderOption()),
  definitionLinkOpensInPeek: register2(new EditorBooleanOption(101, "definitionLinkOpensInPeek", false, { description: localize(660, null) })),
  quickSuggestions: register2(new EditorQuickSuggestions()),
  quickSuggestionsDelay: register2(new EditorIntOption(103, "quickSuggestionsDelay", 10, 0, 1073741824, {
    description: localize(661, null),
    experiment: {
      mode: "auto"
    }
  })),
  readOnly: register2(new EditorBooleanOption(104, "readOnly", false)),
  readOnlyMessage: register2(new ReadonlyMessage()),
  renameOnType: register2(new EditorBooleanOption(106, "renameOnType", false, { description: localize(662, null), markdownDeprecationMessage: localize(663, null) })),
  renderControlCharacters: register2(new EditorBooleanOption(108, "renderControlCharacters", true, { description: localize(664, null), restricted: true })),
  renderFinalNewline: register2(new EditorStringEnumOption(109, "renderFinalNewline", isLinux ? "dimmed" : "on", ["off", "on", "dimmed"], { description: localize(665, null) })),
  renderLineHighlight: register2(new EditorStringEnumOption(110, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      localize(666, null)
    ],
    description: localize(667, null)
  })),
  renderLineHighlightOnlyWhenFocus: register2(new EditorBooleanOption(111, "renderLineHighlightOnlyWhenFocus", false, { description: localize(668, null) })),
  renderValidationDecorations: register2(new EditorStringEnumOption(112, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: register2(new EditorStringEnumOption(113, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      localize(669, null),
      localize(670, null),
      localize(671, null),
      ""
    ],
    description: localize(672, null)
  })),
  revealHorizontalRightPadding: register2(new EditorIntOption(114, "revealHorizontalRightPadding", 15, 0, 1e3)),
  roundedSelection: register2(new EditorBooleanOption(115, "roundedSelection", true, { description: localize(673, null) })),
  rulers: register2(new EditorRulers()),
  scrollbar: register2(new EditorScrollbar()),
  scrollBeyondLastColumn: register2(new EditorIntOption(118, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: localize(674, null) })),
  scrollBeyondLastLine: register2(new EditorBooleanOption(119, "scrollBeyondLastLine", true, { description: localize(675, null) })),
  scrollOnMiddleClick: register2(new EditorBooleanOption(171, "scrollOnMiddleClick", false, { description: localize(676, null) })),
  scrollPredominantAxis: register2(new EditorBooleanOption(120, "scrollPredominantAxis", true, { description: localize(677, null) })),
  selectionClipboard: register2(new EditorBooleanOption(121, "selectionClipboard", true, {
    description: localize(678, null),
    included: isLinux
  })),
  selectionHighlight: register2(new EditorBooleanOption(122, "selectionHighlight", true, { description: localize(679, null) })),
  selectionHighlightMaxLength: register2(new EditorIntOption(123, "selectionHighlightMaxLength", 200, 0, 1073741824, { description: localize(680, null) })),
  selectionHighlightMultiline: register2(new EditorBooleanOption(124, "selectionHighlightMultiline", false, { description: localize(681, null) })),
  selectOnLineNumbers: register2(new EditorBooleanOption(125, "selectOnLineNumbers", true)),
  showFoldingControls: register2(new EditorStringEnumOption(126, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
    enumDescriptions: [
      localize(682, null),
      localize(683, null),
      localize(684, null)
    ],
    description: localize(685, null)
  })),
  showUnused: register2(new EditorBooleanOption(127, "showUnused", true, { description: localize(686, null) })),
  showDeprecated: register2(new EditorBooleanOption(157, "showDeprecated", true, { description: localize(687, null) })),
  inlayHints: register2(new EditorInlayHints()),
  snippetSuggestions: register2(new EditorStringEnumOption(128, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      localize(688, null),
      localize(689, null),
      localize(690, null),
      localize(691, null)
    ],
    description: localize(692, null)
  })),
  smartSelect: register2(new SmartSelect()),
  smoothScrolling: register2(new EditorBooleanOption(130, "smoothScrolling", false, { description: localize(693, null) })),
  stopRenderingLineAfter: register2(new EditorIntOption(
    133,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: register2(new EditorSuggest()),
  inlineSuggest: register2(new InlineEditorSuggest()),
  inlineCompletionsAccessibilityVerbose: register2(new EditorBooleanOption(169, "inlineCompletionsAccessibilityVerbose", false, { description: localize(694, null) })),
  suggestFontSize: register2(new EditorIntOption(135, "suggestFontSize", 0, 0, 1e3, { markdownDescription: localize(695, null, "`0`", "`#editor.fontSize#`") })),
  suggestLineHeight: register2(new EditorIntOption(136, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: localize(696, null, "`0`", "`#editor.lineHeight#`") })),
  suggestOnTriggerCharacters: register2(new EditorBooleanOption(137, "suggestOnTriggerCharacters", true, { description: localize(697, null) })),
  suggestSelection: register2(new EditorStringEnumOption(138, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      localize(698, null),
      localize(699, null),
      localize(700, null)
    ],
    description: localize(701, null)
  })),
  tabCompletion: register2(new EditorStringEnumOption(139, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      localize(702, null),
      localize(703, null),
      localize(704, null)
    ],
    description: localize(705, null)
  })),
  tabIndex: register2(new EditorIntOption(
    140,
    "tabIndex",
    0,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  trimWhitespaceOnDelete: register2(new EditorBooleanOption(141, "trimWhitespaceOnDelete", false, { description: localize(706, null) })),
  unicodeHighlight: register2(new UnicodeHighlight()),
  unusualLineTerminators: register2(new EditorStringEnumOption(143, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      localize(707, null),
      localize(708, null),
      localize(709, null)
    ],
    description: localize(710, null)
  })),
  useShadowDOM: register2(new EditorBooleanOption(144, "useShadowDOM", true)),
  useTabStops: register2(new EditorBooleanOption(145, "useTabStops", true, { description: localize(711, null) })),
  wordBreak: register2(new EditorStringEnumOption(146, "wordBreak", "normal", ["normal", "keepAll"], {
    markdownEnumDescriptions: [
      localize(712, null),
      localize(713, null)
    ],
    description: localize(714, null)
  })),
  wordSegmenterLocales: register2(new WordSegmenterLocales()),
  wordSeparators: register2(new EditorStringOption(148, "wordSeparators", USUAL_WORD_SEPARATORS, { description: localize(715, null) })),
  wordWrap: register2(new EditorStringEnumOption(149, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      localize(716, null),
      localize(717, null),
      localize(718, null),
      localize(719, null)
    ],
    description: localize(720, null)
  })),
  wordWrapBreakAfterCharacters: register2(new EditorStringOption(
    150,
    "wordWrapBreakAfterCharacters",
    // allow-any-unicode-next-line
    " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63"
  )),
  wordWrapBreakBeforeCharacters: register2(new EditorStringOption(
    151,
    "wordWrapBreakBeforeCharacters",
    // allow-any-unicode-next-line
    "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B"
  )),
  wordWrapColumn: register2(new EditorIntOption(152, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: localize(721, null)
  })),
  wordWrapOverride1: register2(new EditorStringEnumOption(153, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: register2(new EditorStringEnumOption(154, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  wrapOnEscapedLineFeeds: register2(new EditorBooleanOption(160, "wrapOnEscapedLineFeeds", false, { markdownDescription: localize(722, null) })),
  // Leave these at the end (because they have dependencies!)
  effectiveCursorStyle: register2(new EffectiveCursorStyle()),
  editorClassName: register2(new EditorClassName()),
  defaultColorDecorators: register2(new EditorStringEnumOption(167, "defaultColorDecorators", "auto", ["auto", "always", "never"], {
    enumDescriptions: [
      localize(723, null),
      localize(724, null),
      localize(725, null)
    ],
    description: localize(726, null)
  })),
  pixelRatio: register2(new EditorPixelRatio()),
  tabFocusMode: register2(new EditorBooleanOption(164, "tabFocusMode", false, { markdownDescription: localize(727, null) })),
  layoutInfo: register2(new EditorLayoutInfoComputer()),
  wrappingInfo: register2(new EditorWrappingInfoComputer()),
  wrappingIndent: register2(new WrappingIndentOption()),
  wrappingStrategy: register2(new WrappingStrategy()),
  effectiveEditContextEnabled: register2(new EffectiveEditContextEnabled()),
  effectiveAllowVariableFonts: register2(new EffectiveAllowVariableFonts())
};

// out-build/vs/editor/common/languageSelector.js
function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter2 of selector) {
      const value = score(filter2, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (!candidateIsSynchronized) {
      return 0;
    }
    if (selector === "*") {
      return 5;
    } else if (selector === candidateLanguage) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    const { language: language2, pattern, scheme, hasAccessToAllModels, notebookType } = selector;
    if (!candidateIsSynchronized && !hasAccessToAllModels) {
      return 0;
    }
    if (notebookType && candidateNotebookUri) {
      candidateUri = candidateNotebookUri;
    }
    let ret = 0;
    if (scheme) {
      if (scheme === candidateUri.scheme) {
        ret = 10;
      } else if (scheme === "*") {
        ret = 5;
      } else {
        return 0;
      }
    }
    if (language2) {
      if (language2 === candidateLanguage) {
        ret = 10;
      } else if (language2 === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (notebookType) {
      if (notebookType === candidateNotebookType) {
        ret = 10;
      } else if (notebookType === "*" && candidateNotebookType !== void 0) {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let normalizedPattern;
      if (typeof pattern === "string") {
        normalizedPattern = pattern;
      } else {
        normalizedPattern = { ...pattern, base: normalize(pattern.base) };
      }
      if (normalizedPattern === candidateUri.fsPath || match(normalizedPattern, candidateUri.fsPath)) {
        ret = 10;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}
function targetsNotebooks(selector) {
  if (typeof selector === "string") {
    return false;
  } else if (Array.isArray(selector)) {
    return selector.some(targetsNotebooks);
  } else {
    return !!selector.notebookType;
  }
}

// out-build/vs/editor/common/languages/languageConfiguration.js
var IndentAction;
(function(IndentAction2) {
  IndentAction2[IndentAction2["None"] = 0] = "None";
  IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
  IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));

// out-build/vs/platform/workspace/common/editSessions.js
var IEditSessionIdentityService = createDecorator("editSessionIdentityService");
var EditSessionIdentityMatch;
(function(EditSessionIdentityMatch2) {
  EditSessionIdentityMatch2[EditSessionIdentityMatch2["Complete"] = 100] = "Complete";
  EditSessionIdentityMatch2[EditSessionIdentityMatch2["Partial"] = 50] = "Partial";
  EditSessionIdentityMatch2[EditSessionIdentityMatch2["None"] = 0] = "None";
})(EditSessionIdentityMatch || (EditSessionIdentityMatch = {}));

// out-build/vs/workbench/contrib/debug/common/debug.js
var CONTEXT_DEBUG_TYPE = new RawContextKey("debugType", void 0, { type: "string", description: localize(7636, null) });
var CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey("debugConfigurationType", void 0, { type: "string", description: localize(7637, null) });
var CONTEXT_DEBUG_STATE = new RawContextKey("debugState", "inactive", { type: "string", description: localize(7638, null) });
var CONTEXT_DEBUG_UX_KEY = "debugUx";
var CONTEXT_DEBUG_UX = new RawContextKey(CONTEXT_DEBUG_UX_KEY, "default", { type: "string", description: localize(7639, null) });
var CONTEXT_HAS_DEBUGGED = new RawContextKey("hasDebugged", false, { type: "boolean", description: localize(7640, null) });
var CONTEXT_IN_DEBUG_MODE = new RawContextKey("inDebugMode", false, { type: "boolean", description: localize(7641, null) });
var CONTEXT_IN_DEBUG_REPL = new RawContextKey("inDebugRepl", false, { type: "boolean", description: localize(7642, null) });
var CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey("breakpointWidgetVisible", false, { type: "boolean", description: localize(7643, null) });
var CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey("inBreakpointWidget", false, { type: "boolean", description: localize(7644, null) });
var CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey("breakpointsFocused", true, { type: "boolean", description: localize(7645, null) });
var CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey("watchExpressionsFocused", true, { type: "boolean", description: localize(7646, null) });
var CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey("watchExpressionsExist", false, { type: "boolean", description: localize(7647, null) });
var CONTEXT_VARIABLES_FOCUSED = new RawContextKey("variablesFocused", true, { type: "boolean", description: localize(7648, null) });
var CONTEXT_EXPRESSION_SELECTED = new RawContextKey("expressionSelected", false, { type: "boolean", description: localize(7649, null) });
var CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey("breakpointInputFocused", false, { type: "boolean", description: localize(7650, null) });
var CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey("callStackItemType", void 0, { type: "string", description: localize(7651, null) });
var CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey("callStackSessionIsAttach", false, { type: "boolean", description: localize(7652, null) });
var CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey("callStackItemStopped", false, { type: "boolean", description: localize(7653, null) });
var CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = new RawContextKey("callStackSessionHasOneThread", false, { type: "boolean", description: localize(7654, null) });
var CONTEXT_CALLSTACK_FOCUSED = new RawContextKey("callStackFocused", true, { type: "boolean", description: localize(7655, null) });
var CONTEXT_WATCH_ITEM_TYPE = new RawContextKey("watchItemType", void 0, { type: "string", description: localize(7656, null) });
var CONTEXT_CAN_VIEW_MEMORY = new RawContextKey("canViewMemory", void 0, { type: "boolean", description: localize(7657, null) });
var CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey("breakpointItemType", void 0, { type: "string", description: localize(7658, null) });
var CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES = new RawContextKey("breakpointItemBytes", void 0, { type: "boolean", description: localize(7659, null) });
var CONTEXT_BREAKPOINT_HAS_MODES = new RawContextKey("breakpointHasModes", false, { type: "boolean", description: localize(7660, null) });
var CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey("breakpointSupportsCondition", false, { type: "boolean", description: localize(7661, null) });
var CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey("loadedScriptsSupported", false, { type: "boolean", description: localize(7662, null) });
var CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey("loadedScriptsItemType", void 0, { type: "string", description: localize(7663, null) });
var CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey("focusedSessionIsAttach", false, { type: "boolean", description: localize(7664, null) });
var CONTEXT_FOCUSED_SESSION_IS_NO_DEBUG = new RawContextKey("focusedSessionIsNoDebug", false, { type: "boolean", description: localize(7665, null) });
var CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey("stepBackSupported", false, { type: "boolean", description: localize(7666, null) });
var CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey("restartFrameSupported", false, { type: "boolean", description: localize(7667, null) });
var CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey("stackFrameSupportsRestart", false, { type: "boolean", description: localize(7668, null) });
var CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey("jumpToCursorSupported", false, { type: "boolean", description: localize(7669, null) });
var CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey("stepIntoTargetsSupported", false, { type: "boolean", description: localize(7670, null) });
var CONTEXT_BREAKPOINTS_EXIST = new RawContextKey("breakpointsExist", false, { type: "boolean", description: localize(7671, null) });
var CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey("debuggersAvailable", false, { type: "boolean", description: localize(7672, null) });
var CONTEXT_DEBUG_EXTENSION_AVAILABLE = new RawContextKey("debugExtensionAvailable", true, { type: "boolean", description: localize(7673, null) });
var CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = new RawContextKey("debugProtocolVariableMenuContext", void 0, { type: "string", description: localize(7674, null) });
var CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey("debugSetVariableSupported", false, { type: "boolean", description: localize(7675, null) });
var CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED = new RawContextKey("debugSetDataBreakpointAddressSupported", false, { type: "boolean", description: localize(7676, null) });
var CONTEXT_SET_EXPRESSION_SUPPORTED = new RawContextKey("debugSetExpressionSupported", false, { type: "boolean", description: localize(7677, null) });
var CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = new RawContextKey("breakWhenValueChangesSupported", false, { type: "boolean", description: localize(7678, null) });
var CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = new RawContextKey("breakWhenValueIsAccessedSupported", false, { type: "boolean", description: localize(7679, null) });
var CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = new RawContextKey("breakWhenValueIsReadSupported", false, { type: "boolean", description: localize(7680, null) });
var CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey("terminateDebuggeeSupported", false, { type: "boolean", description: localize(7681, null) });
var CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = new RawContextKey("suspendDebuggeeSupported", false, { type: "boolean", description: localize(7682, null) });
var CONTEXT_TERMINATE_THREADS_SUPPORTED = new RawContextKey("terminateThreadsSupported", false, { type: "boolean", description: localize(7683, null) });
var CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = new RawContextKey("variableEvaluateNamePresent", false, { type: "boolean", description: localize(7684, null) });
var CONTEXT_VARIABLE_IS_READONLY = new RawContextKey("variableIsReadonly", false, { type: "boolean", description: localize(7685, null) });
var CONTEXT_VARIABLE_VALUE = new RawContextKey("variableValue", false, { type: "string", description: localize(7686, null) });
var CONTEXT_VARIABLE_TYPE = new RawContextKey("variableType", false, { type: "string", description: localize(7687, null) });
var CONTEXT_VARIABLE_INTERFACES = new RawContextKey("variableInterfaces", false, { type: "array", description: localize(7688, null) });
var CONTEXT_VARIABLE_NAME = new RawContextKey("variableName", false, { type: "string", description: localize(7689, null) });
var CONTEXT_VARIABLE_LANGUAGE = new RawContextKey("variableLanguage", false, { type: "string", description: localize(7690, null) });
var CONTEXT_VARIABLE_EXTENSIONID = new RawContextKey("variableExtensionId", false, { type: "string", description: localize(7691, null) });
var CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey("exceptionWidgetVisible", false, { type: "boolean", description: localize(7692, null) });
var CONTEXT_MULTI_SESSION_REPL = new RawContextKey("multiSessionRepl", false, { type: "boolean", description: localize(7693, null) });
var CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey("multiSessionDebug", false, { type: "boolean", description: localize(7694, null) });
var CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = new RawContextKey("disassembleRequestSupported", false, { type: "boolean", description: localize(7695, null) });
var CONTEXT_DISASSEMBLY_VIEW_FOCUS = new RawContextKey("disassemblyViewFocus", false, { type: "boolean", description: localize(7696, null) });
var CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST = new RawContextKey("languageSupportsDisassembleRequest", false, { type: "boolean", description: localize(7697, null) });
var CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = new RawContextKey("focusedStackFrameHasInstructionReference", false, { type: "boolean", description: localize(7698, null) });
var INTERNAL_CONSOLE_OPTIONS_SCHEMA = {
  enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart"],
  default: "openOnFirstSessionStart",
  description: localize(7700, null)
};
var State;
(function(State3) {
  State3[State3["Inactive"] = 0] = "Inactive";
  State3[State3["Initializing"] = 1] = "Initializing";
  State3[State3["Stopped"] = 2] = "Stopped";
  State3[State3["Running"] = 3] = "Running";
})(State || (State = {}));
var MemoryRangeType;
(function(MemoryRangeType2) {
  MemoryRangeType2[MemoryRangeType2["Valid"] = 0] = "Valid";
  MemoryRangeType2[MemoryRangeType2["Unreadable"] = 1] = "Unreadable";
  MemoryRangeType2[MemoryRangeType2["Error"] = 2] = "Error";
})(MemoryRangeType || (MemoryRangeType = {}));
var DataBreakpointSetType;
(function(DataBreakpointSetType2) {
  DataBreakpointSetType2[DataBreakpointSetType2["Variable"] = 0] = "Variable";
  DataBreakpointSetType2[DataBreakpointSetType2["Address"] = 1] = "Address";
})(DataBreakpointSetType || (DataBreakpointSetType = {}));
var DebugConfigurationProviderTriggerKind;
(function(DebugConfigurationProviderTriggerKind2) {
  DebugConfigurationProviderTriggerKind2[DebugConfigurationProviderTriggerKind2["Initial"] = 1] = "Initial";
  DebugConfigurationProviderTriggerKind2[DebugConfigurationProviderTriggerKind2["Dynamic"] = 2] = "Dynamic";
})(DebugConfigurationProviderTriggerKind || (DebugConfigurationProviderTriggerKind = {}));
var DebuggerString;
(function(DebuggerString2) {
  DebuggerString2["UnverifiedBreakpoints"] = "unverifiedBreakpoints";
})(DebuggerString || (DebuggerString = {}));
var IDebugService = createDecorator("debugService");
var BreakpointWidgetContext;
(function(BreakpointWidgetContext2) {
  BreakpointWidgetContext2[BreakpointWidgetContext2["CONDITION"] = 0] = "CONDITION";
  BreakpointWidgetContext2[BreakpointWidgetContext2["HIT_COUNT"] = 1] = "HIT_COUNT";
  BreakpointWidgetContext2[BreakpointWidgetContext2["LOG_MESSAGE"] = 2] = "LOG_MESSAGE";
  BreakpointWidgetContext2[BreakpointWidgetContext2["TRIGGER_POINT"] = 3] = "TRIGGER_POINT";
})(BreakpointWidgetContext || (BreakpointWidgetContext = {}));
var DebugVisualizationType;
(function(DebugVisualizationType2) {
  DebugVisualizationType2[DebugVisualizationType2["Command"] = 0] = "Command";
  DebugVisualizationType2[DebugVisualizationType2["Tree"] = 1] = "Tree";
})(DebugVisualizationType || (DebugVisualizationType = {}));
var DebugTreeItemCollapsibleState;
(function(DebugTreeItemCollapsibleState2) {
  DebugTreeItemCollapsibleState2[DebugTreeItemCollapsibleState2["None"] = 0] = "None";
  DebugTreeItemCollapsibleState2[DebugTreeItemCollapsibleState2["Collapsed"] = 1] = "Collapsed";
  DebugTreeItemCollapsibleState2[DebugTreeItemCollapsibleState2["Expanded"] = 2] = "Expanded";
})(DebugTreeItemCollapsibleState || (DebugTreeItemCollapsibleState = {}));
var IDebugVisualizationTreeItem;
(function(IDebugVisualizationTreeItem2) {
  IDebugVisualizationTreeItem2.deserialize = (v) => v;
  IDebugVisualizationTreeItem2.serialize = (item) => item;
})(IDebugVisualizationTreeItem || (IDebugVisualizationTreeItem = {}));
var IDebugVisualization;
(function(IDebugVisualization2) {
  IDebugVisualization2.deserialize = (v) => ({
    id: v.id,
    name: v.name,
    iconPath: v.iconPath && { light: URI.revive(v.iconPath.light), dark: URI.revive(v.iconPath.dark) },
    iconClass: v.iconClass,
    visualization: v.visualization
  });
  IDebugVisualization2.serialize = (visualizer) => visualizer;
})(IDebugVisualization || (IDebugVisualization = {}));

// out-build/vs/workbench/api/common/extHostAiRelatedInformation.js
var ExtHostRelatedInformation = class {
  constructor(mainContext) {
    this._relatedInformationProviders = /* @__PURE__ */ new Map();
    this._nextHandle = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadAiRelatedInformation);
  }
  async $provideAiRelatedInformation(handle, query, token) {
    if (this._relatedInformationProviders.size === 0) {
      throw new Error("No related information providers registered");
    }
    const provider = this._relatedInformationProviders.get(handle);
    if (!provider) {
      throw new Error("related information provider not found");
    }
    const result = await provider.provideRelatedInformation(query, token) ?? [];
    return result;
  }
  getRelatedInformation(extension, query, types) {
    return this._proxy.$getAiRelatedInformation(query, types);
  }
  registerRelatedInformationProvider(extension, type, provider) {
    const handle = this._nextHandle;
    this._nextHandle++;
    this._relatedInformationProviders.set(handle, provider);
    this._proxy.$registerAiRelatedInformationProvider(handle, type);
    return new Disposable2(() => {
      this._proxy.$unregisterAiRelatedInformationProvider(handle);
      this._relatedInformationProviders.delete(handle);
    });
  }
};

// out-build/vs/workbench/api/common/extHostAiSettingsSearch.js
var ExtHostAiSettingsSearch = class {
  constructor(mainContext) {
    this._settingsSearchProviders = /* @__PURE__ */ new Map();
    this._nextHandle = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadAiSettingsSearch);
  }
  async $startSearch(handle, query, option, token) {
    if (this._settingsSearchProviders.size === 0) {
      throw new Error("No related information providers registered");
    }
    const provider = this._settingsSearchProviders.get(handle);
    if (!provider) {
      throw new Error("Settings search provider not found");
    }
    const progressReporter = new Progress((data2) => {
      this._proxy.$handleSearchResult(handle, AiSettingsSearch.fromSettingsSearchResult(data2));
    });
    return provider.provideSettingsSearchResults(query, option, progressReporter, token);
  }
  registerSettingsSearchProvider(extension, provider) {
    const handle = this._nextHandle;
    this._nextHandle++;
    this._settingsSearchProviders.set(handle, provider);
    this._proxy.$registerAiSettingsSearchProvider(handle);
    return new Disposable2(() => {
      this._proxy.$unregisterAiSettingsSearchProvider(handle);
      this._settingsSearchProviders.delete(handle);
    });
  }
};

// out-build/vs/editor/common/services/semanticTokensDto.js
var EncodedSemanticTokensType;
(function(EncodedSemanticTokensType2) {
  EncodedSemanticTokensType2[EncodedSemanticTokensType2["Full"] = 1] = "Full";
  EncodedSemanticTokensType2[EncodedSemanticTokensType2["Delta"] = 2] = "Delta";
})(EncodedSemanticTokensType || (EncodedSemanticTokensType = {}));
function reverseEndianness(arr) {
  for (let i = 0, len = arr.length; i < len; i += 4) {
    const b0 = arr[i + 0];
    const b1 = arr[i + 1];
    const b2 = arr[i + 2];
    const b3 = arr[i + 3];
    arr[i + 0] = b3;
    arr[i + 1] = b2;
    arr[i + 2] = b1;
    arr[i + 3] = b0;
  }
}
function toLittleEndianBuffer(arr) {
  const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);
  if (!isLittleEndian()) {
    reverseEndianness(uint8Arr);
  }
  return VSBuffer.wrap(uint8Arr);
}
function fromLittleEndianBuffer(buff) {
  const uint8Arr = buff.buffer;
  if (!isLittleEndian()) {
    reverseEndianness(uint8Arr);
  }
  if (uint8Arr.byteOffset % 4 === 0) {
    return new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);
  } else {
    const data2 = new Uint8Array(uint8Arr.byteLength);
    data2.set(uint8Arr);
    return new Uint32Array(data2.buffer, data2.byteOffset, data2.length / 4);
  }
}
function encodeSemanticTokensDto(semanticTokens) {
  const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
  let offset = 0;
  dest[offset++] = semanticTokens.id;
  if (semanticTokens.type === "full") {
    dest[offset++] = 1;
    dest[offset++] = semanticTokens.data.length;
    dest.set(semanticTokens.data, offset);
    offset += semanticTokens.data.length;
  } else {
    dest[offset++] = 2;
    dest[offset++] = semanticTokens.deltas.length;
    for (const delta3 of semanticTokens.deltas) {
      dest[offset++] = delta3.start;
      dest[offset++] = delta3.deleteCount;
      if (delta3.data) {
        dest[offset++] = delta3.data.length;
        dest.set(delta3.data, offset);
        offset += delta3.data.length;
      } else {
        dest[offset++] = 0;
      }
    }
  }
  return toLittleEndianBuffer(dest);
}
function encodeSemanticTokensDtoSize(semanticTokens) {
  let result = 0;
  result += 1 + 1;
  if (semanticTokens.type === "full") {
    result += 1 + semanticTokens.data.length;
  } else {
    result += 1;
    result += (1 + 1 + 1) * semanticTokens.deltas.length;
    for (const delta3 of semanticTokens.deltas) {
      if (delta3.data) {
        result += delta3.data.length;
      }
    }
  }
  return result;
}
function decodeSemanticTokensDto(_buff) {
  const src = fromLittleEndianBuffer(_buff);
  let offset = 0;
  const id2 = src[offset++];
  const type = src[offset++];
  if (type === 1) {
    const length = src[offset++];
    const data2 = src.subarray(offset, offset + length);
    offset += length;
    return {
      id: id2,
      type: "full",
      data: data2
    };
  }
  const deltaCount = src[offset++];
  const deltas = [];
  for (let i = 0; i < deltaCount; i++) {
    const start = src[offset++];
    const deleteCount = src[offset++];
    const length = src[offset++];
    let data2;
    if (length > 0) {
      data2 = src.subarray(offset, offset + length);
      offset += length;
    }
    deltas[i] = { start, deleteCount, data: data2 };
  }
  return {
    id: id2,
    type: "delta",
    deltas
  };
}

// out-build/vs/workbench/api/common/extHostApiCommands.js
var newCommands = [
  // -- document highlights
  new ApiCommand("vscode.executeDocumentHighlights", "_executeDocumentHighlights", "Execute document highlight provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of DocumentHighlight-instances.", tryMapWith(DocumentHighlight3.to))),
  // -- document symbols
  new ApiCommand("vscode.executeDocumentSymbolProvider", "_executeDocumentSymbolProvider", "Execute document symbol provider.", [ApiCommandArgument.Uri], new ApiCommandResult("A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.", (value, apiArgs) => {
    if (isFalsyOrEmpty(value)) {
      return void 0;
    }
    class MergedInfo extends SymbolInformation {
      constructor() {
        super(...arguments);
        this.containerName = "";
      }
      static to(symbol) {
        const res = new MergedInfo(symbol.name, SymbolKind3.to(symbol.kind), symbol.containerName || "", new Location(apiArgs[0], Range4.to(symbol.range)));
        res.detail = symbol.detail;
        res.range = res.location.range;
        res.selectionRange = Range4.to(symbol.selectionRange);
        res.children = symbol.children ? symbol.children.map(MergedInfo.to) : [];
        return res;
      }
    }
    return value.map(MergedInfo.to);
  })),
  // -- formatting
  new ApiCommand("vscode.executeFormatDocumentProvider", "_executeFormatDocumentProvider", "Execute document format provider.", [ApiCommandArgument.Uri, new ApiCommandArgument("options", "Formatting options", (_) => true, (v) => v)], new ApiCommandResult("A promise that resolves to an array of TextEdits.", tryMapWith(TextEdit3.to))),
  new ApiCommand("vscode.executeFormatRangeProvider", "_executeFormatRangeProvider", "Execute range format provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Range, new ApiCommandArgument("options", "Formatting options", (_) => true, (v) => v)], new ApiCommandResult("A promise that resolves to an array of TextEdits.", tryMapWith(TextEdit3.to))),
  new ApiCommand("vscode.executeFormatOnTypeProvider", "_executeFormatOnTypeProvider", "Execute format on type provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Position, new ApiCommandArgument("ch", "Trigger character", (v) => typeof v === "string", (v) => v), new ApiCommandArgument("options", "Formatting options", (_) => true, (v) => v)], new ApiCommandResult("A promise that resolves to an array of TextEdits.", tryMapWith(TextEdit3.to))),
  // -- go to symbol (definition, type definition, declaration, impl, references)
  new ApiCommand("vscode.executeDefinitionProvider", "_executeDefinitionProvider", "Execute all definition providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.experimental.executeDefinitionProvider_recursive", "_executeDefinitionProvider_recursive", "Execute all definition providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.executeTypeDefinitionProvider", "_executeTypeDefinitionProvider", "Execute all type definition providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.experimental.executeTypeDefinitionProvider_recursive", "_executeTypeDefinitionProvider_recursive", "Execute all type definition providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.executeDeclarationProvider", "_executeDeclarationProvider", "Execute all declaration providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.experimental.executeDeclarationProvider_recursive", "_executeDeclarationProvider_recursive", "Execute all declaration providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.executeImplementationProvider", "_executeImplementationProvider", "Execute all implementation providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.experimental.executeImplementationProvider_recursive", "_executeImplementationProvider_recursive", "Execute all implementation providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location or LocationLink instances.", mapLocationOrLocationLink)),
  new ApiCommand("vscode.executeReferenceProvider", "_executeReferenceProvider", "Execute all reference providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location-instances.", tryMapWith(location.to))),
  new ApiCommand("vscode.experimental.executeReferenceProvider", "_executeReferenceProvider_recursive", "Execute all reference providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Location-instances.", tryMapWith(location.to))),
  // -- hover
  new ApiCommand("vscode.executeHoverProvider", "_executeHoverProvider", "Execute all hover providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Hover-instances.", tryMapWith(Hover3.to))),
  new ApiCommand("vscode.experimental.executeHoverProvider_recursive", "_executeHoverProvider_recursive", "Execute all hover providers.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of Hover-instances.", tryMapWith(Hover3.to))),
  // -- selection range
  new ApiCommand("vscode.executeSelectionRangeProvider", "_executeSelectionRangeProvider", "Execute selection range provider.", [ApiCommandArgument.Uri, new ApiCommandArgument("position", "A position in a text document", (v) => Array.isArray(v) && v.every((v2) => Position2.isPosition(v2)), (v) => v.map(Position4.from))], new ApiCommandResult("A promise that resolves to an array of ranges.", (result) => {
    return result.map((ranges) => {
      let node;
      for (const range of ranges.reverse()) {
        node = new SelectionRange(Range4.to(range), node);
      }
      return node;
    });
  })),
  // -- symbol search
  new ApiCommand("vscode.executeWorkspaceSymbolProvider", "_executeWorkspaceSymbolProvider", "Execute all workspace symbol providers.", [ApiCommandArgument.String.with("query", "Search string")], new ApiCommandResult("A promise that resolves to an array of SymbolInformation-instances.", (value) => {
    return value.map(WorkspaceSymbol.to);
  })),
  // --- call hierarchy
  new ApiCommand("vscode.prepareCallHierarchy", "_executePrepareCallHierarchy", "Prepare call hierarchy at a position inside a document", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of CallHierarchyItem-instances", (v) => v.map(CallHierarchyItem2.to))),
  new ApiCommand("vscode.provideIncomingCalls", "_executeProvideIncomingCalls", "Compute incoming calls for an item", [ApiCommandArgument.CallHierarchyItem], new ApiCommandResult("A promise that resolves to an array of CallHierarchyIncomingCall-instances", (v) => v.map(CallHierarchyIncomingCall2.to))),
  new ApiCommand("vscode.provideOutgoingCalls", "_executeProvideOutgoingCalls", "Compute outgoing calls for an item", [ApiCommandArgument.CallHierarchyItem], new ApiCommandResult("A promise that resolves to an array of CallHierarchyOutgoingCall-instances", (v) => v.map(CallHierarchyOutgoingCall2.to))),
  // --- rename
  new ApiCommand("vscode.prepareRename", "_executePrepareRename", "Execute the prepareRename of rename provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to a range and placeholder text.", (value) => {
    if (!value) {
      return void 0;
    }
    return {
      range: Range4.to(value.range),
      placeholder: value.text
    };
  })),
  new ApiCommand("vscode.executeDocumentRenameProvider", "_executeDocumentRenameProvider", "Execute rename provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Position, ApiCommandArgument.String.with("newName", "The new symbol name")], new ApiCommandResult("A promise that resolves to a WorkspaceEdit.", (value) => {
    if (!value) {
      return void 0;
    }
    if (value.rejectReason) {
      throw new Error(value.rejectReason);
    }
    return WorkspaceEdit3.to(value);
  })),
  // --- links
  new ApiCommand("vscode.executeLinkProvider", "_executeLinkProvider", "Execute document link provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Number.with("linkResolveCount", "Number of links that should be resolved, only when links are unresolved.").optional()], new ApiCommandResult("A promise that resolves to an array of DocumentLink-instances.", (value) => value.map(DocumentLink3.to))),
  // --- semantic tokens
  new ApiCommand("vscode.provideDocumentSemanticTokensLegend", "_provideDocumentSemanticTokensLegend", "Provide semantic tokens legend for a document", [ApiCommandArgument.Uri], new ApiCommandResult("A promise that resolves to SemanticTokensLegend.", (value) => {
    if (!value) {
      return void 0;
    }
    return new SemanticTokensLegend(value.tokenTypes, value.tokenModifiers);
  })),
  new ApiCommand("vscode.provideDocumentSemanticTokens", "_provideDocumentSemanticTokens", "Provide semantic tokens for a document", [ApiCommandArgument.Uri], new ApiCommandResult("A promise that resolves to SemanticTokens.", (value) => {
    if (!value) {
      return void 0;
    }
    const semanticTokensDto = decodeSemanticTokensDto(value);
    if (semanticTokensDto.type !== "full") {
      return void 0;
    }
    return new SemanticTokens(semanticTokensDto.data, void 0);
  })),
  new ApiCommand("vscode.provideDocumentRangeSemanticTokensLegend", "_provideDocumentRangeSemanticTokensLegend", "Provide semantic tokens legend for a document range", [ApiCommandArgument.Uri, ApiCommandArgument.Range.optional()], new ApiCommandResult("A promise that resolves to SemanticTokensLegend.", (value) => {
    if (!value) {
      return void 0;
    }
    return new SemanticTokensLegend(value.tokenTypes, value.tokenModifiers);
  })),
  new ApiCommand("vscode.provideDocumentRangeSemanticTokens", "_provideDocumentRangeSemanticTokens", "Provide semantic tokens for a document range", [ApiCommandArgument.Uri, ApiCommandArgument.Range], new ApiCommandResult("A promise that resolves to SemanticTokens.", (value) => {
    if (!value) {
      return void 0;
    }
    const semanticTokensDto = decodeSemanticTokensDto(value);
    if (semanticTokensDto.type !== "full") {
      return void 0;
    }
    return new SemanticTokens(semanticTokensDto.data, void 0);
  })),
  // --- completions
  new ApiCommand("vscode.executeCompletionItemProvider", "_executeCompletionItemProvider", "Execute completion item provider.", [
    ApiCommandArgument.Uri,
    ApiCommandArgument.Position,
    ApiCommandArgument.String.with("triggerCharacter", "Trigger completion when the user types the character, like `,` or `(`").optional(),
    ApiCommandArgument.Number.with("itemResolveCount", "Number of completions to resolve (too large numbers slow down completions)").optional()
  ], new ApiCommandResult("A promise that resolves to a CompletionList-instance.", (value, _args, converter) => {
    if (!value) {
      return new CompletionList([]);
    }
    const items = value.suggestions.map((suggestion) => CompletionItem3.to(suggestion, converter));
    return new CompletionList(items, value.incomplete);
  })),
  // --- signature help
  new ApiCommand("vscode.executeSignatureHelpProvider", "_executeSignatureHelpProvider", "Execute signature help provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Position, ApiCommandArgument.String.with("triggerCharacter", "Trigger signature help when the user types the character, like `,` or `(`").optional()], new ApiCommandResult("A promise that resolves to SignatureHelp.", (value) => {
    if (value) {
      return SignatureHelp3.to(value);
    }
    return void 0;
  })),
  // --- code lens
  new ApiCommand("vscode.executeCodeLensProvider", "_executeCodeLensProvider", "Execute code lens provider.", [ApiCommandArgument.Uri, ApiCommandArgument.Number.with("itemResolveCount", "Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)").optional()], new ApiCommandResult("A promise that resolves to an array of CodeLens-instances.", (value, _args, converter) => {
    return tryMapWith((item) => {
      return new CodeLens(Range4.to(item.range), item.command && converter.fromInternal(item.command));
    })(value);
  })),
  // --- code actions
  new ApiCommand("vscode.executeCodeActionProvider", "_executeCodeActionProvider", "Execute code action provider.", [
    ApiCommandArgument.Uri,
    new ApiCommandArgument("rangeOrSelection", "Range in a text document. Some refactoring provider requires Selection object.", (v) => Range2.isRange(v), (v) => Selection.isSelection(v) ? Selection3.from(v) : Range4.from(v)),
    ApiCommandArgument.String.with("kind", "Code action kind to return code actions for").optional(),
    ApiCommandArgument.Number.with("itemResolveCount", "Number of code actions to resolve (too large numbers slow down code actions)").optional()
  ], new ApiCommandResult("A promise that resolves to an array of Command-instances.", (value, _args, converter) => {
    return tryMapWith((codeAction) => {
      if (codeAction._isSynthetic) {
        if (!codeAction.command) {
          throw new Error("Synthetic code actions must have a command");
        }
        return converter.fromInternal(codeAction.command);
      } else {
        const ret = new CodeAction(codeAction.title, codeAction.kind ? new CodeActionKind(codeAction.kind) : void 0);
        if (codeAction.edit) {
          ret.edit = WorkspaceEdit3.to(codeAction.edit);
        }
        if (codeAction.command) {
          ret.command = converter.fromInternal(codeAction.command);
        }
        ret.isPreferred = codeAction.isPreferred;
        return ret;
      }
    })(value);
  })),
  // --- colors
  new ApiCommand("vscode.executeDocumentColorProvider", "_executeDocumentColorProvider", "Execute document color provider.", [ApiCommandArgument.Uri], new ApiCommandResult("A promise that resolves to an array of ColorInformation objects.", (result) => {
    if (result) {
      return result.map((ci) => new ColorInformation(Range4.to(ci.range), Color3.to(ci.color)));
    }
    return [];
  })),
  new ApiCommand("vscode.executeColorPresentationProvider", "_executeColorPresentationProvider", "Execute color presentation provider.", [
    new ApiCommandArgument("color", "The color to show and insert", (v) => v instanceof Color, Color3.from),
    new ApiCommandArgument("context", "Context object with uri and range", (_v) => true, (v) => ({ uri: v.uri, range: Range4.from(v.range) }))
  ], new ApiCommandResult("A promise that resolves to an array of ColorPresentation objects.", (result) => {
    if (result) {
      return result.map(ColorPresentation3.to);
    }
    return [];
  })),
  // --- inline hints
  new ApiCommand("vscode.executeInlayHintProvider", "_executeInlayHintProvider", "Execute inlay hints provider", [ApiCommandArgument.Uri, ApiCommandArgument.Range], new ApiCommandResult("A promise that resolves to an array of Inlay objects", (result, args, converter) => {
    return result.map(InlayHint3.to.bind(void 0, converter));
  })),
  // --- folding
  new ApiCommand("vscode.executeFoldingRangeProvider", "_executeFoldingRangeProvider", "Execute folding range provider", [ApiCommandArgument.Uri], new ApiCommandResult("A promise that resolves to an array of FoldingRange objects", (result, args) => {
    if (result) {
      return result.map(FoldingRange3.to);
    }
    return void 0;
  })),
  // --- notebooks
  new ApiCommand("vscode.resolveNotebookContentProviders", "_resolveNotebookContentProvider", "Resolve Notebook Content Providers", [
    // new ApiCommandArgument<string, string>('viewType', '', v => typeof v === 'string', v => v),
    // new ApiCommandArgument<string, string>('displayName', '', v => typeof v === 'string', v => v),
    // new ApiCommandArgument<object, object>('options', '', v => typeof v === 'object', v => v),
  ], new ApiCommandResult("A promise that resolves to an array of NotebookContentProvider static info objects.", tryMapWith((item) => {
    return {
      viewType: item.viewType,
      displayName: item.displayName,
      options: {
        transientOutputs: item.options.transientOutputs,
        transientCellMetadata: item.options.transientCellMetadata,
        transientDocumentMetadata: item.options.transientDocumentMetadata
      },
      filenamePattern: item.filenamePattern.map((pattern) => NotebookExclusiveDocumentPattern.to(pattern))
    };
  }))),
  // --- debug support
  new ApiCommand("vscode.executeInlineValueProvider", "_executeInlineValueProvider", "Execute inline value provider", [
    ApiCommandArgument.Uri,
    ApiCommandArgument.Range,
    new ApiCommandArgument("context", "An InlineValueContext", (v) => v && typeof v.frameId === "number" && v.stoppedLocation instanceof Range2, (v) => InlineValueContext3.from(v))
  ], new ApiCommandResult("A promise that resolves to an array of InlineValue objects", (result) => {
    return result.map(InlineValue.to);
  })),
  // --- open'ish commands
  new ApiCommand("vscode.open", "_workbench.open", "Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.", [
    new ApiCommandArgument("uriOrString", "Uri-instance or string (only http/https)", (v) => URI.isUri(v) || typeof v === "string" && matchesSomeScheme(v, Schemas.http, Schemas.https), (v) => v),
    new ApiCommandArgument("columnOrOptions", "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions", (v) => v === void 0 || typeof v === "number" || typeof v === "object", (v) => !v ? v : typeof v === "number" ? [ViewColumn2.from(v), void 0] : [ViewColumn2.from(v.viewColumn), TextEditorOpenOptions.from(v)]).optional(),
    ApiCommandArgument.String.with("label", "").optional()
  ], ApiCommandResult.Void),
  new ApiCommand("vscode.openWith", "_workbench.openWith", "Opens the provided resource with a specific editor.", [
    ApiCommandArgument.Uri.with("resource", "Resource to open"),
    ApiCommandArgument.String.with("viewId", "Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use 'default' to use VS Code's default text editor"),
    new ApiCommandArgument("columnOrOptions", "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions", (v) => v === void 0 || typeof v === "number" || typeof v === "object", (v) => !v ? v : typeof v === "number" ? [ViewColumn2.from(v), void 0] : [ViewColumn2.from(v.viewColumn), TextEditorOpenOptions.from(v)]).optional()
  ], ApiCommandResult.Void),
  new ApiCommand("vscode.diff", "_workbench.diff", "Opens the provided resources in the diff editor to compare their contents.", [
    ApiCommandArgument.Uri.with("left", "Left-hand side resource of the diff editor"),
    ApiCommandArgument.Uri.with("right", "Right-hand side resource of the diff editor"),
    ApiCommandArgument.String.with("title", "Human readable title for the diff editor").optional(),
    new ApiCommandArgument("columnOrOptions", "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions", (v) => v === void 0 || typeof v === "object", (v) => v && [ViewColumn2.from(v.viewColumn), TextEditorOpenOptions.from(v)]).optional()
  ], ApiCommandResult.Void),
  new ApiCommand("vscode.changes", "_workbench.changes", "Opens a list of resources in the changes editor to compare their contents.", [
    ApiCommandArgument.String.with("title", "Human readable title for the changes editor"),
    new ApiCommandArgument("resourceList", "List of resources to compare", (resources) => {
      for (const resource of resources) {
        if (resource.length !== 3) {
          return false;
        }
        const [label, left, right] = resource;
        if (!URI.isUri(label) || !URI.isUri(left) && left !== void 0 && left !== null || !URI.isUri(right) && right !== void 0 && right !== null) {
          return false;
        }
      }
      return true;
    }, (v) => v)
  ], ApiCommandResult.Void),
  // --- type hierarchy
  new ApiCommand("vscode.prepareTypeHierarchy", "_executePrepareTypeHierarchy", "Prepare type hierarchy at a position inside a document", [ApiCommandArgument.Uri, ApiCommandArgument.Position], new ApiCommandResult("A promise that resolves to an array of TypeHierarchyItem-instances", (v) => v.map(TypeHierarchyItem2.to))),
  new ApiCommand("vscode.provideSupertypes", "_executeProvideSupertypes", "Compute supertypes for an item", [ApiCommandArgument.TypeHierarchyItem], new ApiCommandResult("A promise that resolves to an array of TypeHierarchyItem-instances", (v) => v.map(TypeHierarchyItem2.to))),
  new ApiCommand("vscode.provideSubtypes", "_executeProvideSubtypes", "Compute subtypes for an item", [ApiCommandArgument.TypeHierarchyItem], new ApiCommandResult("A promise that resolves to an array of TypeHierarchyItem-instances", (v) => v.map(TypeHierarchyItem2.to))),
  // --- testing
  new ApiCommand("vscode.revealTestInExplorer", "_revealTestInExplorer", "Reveals a test instance in the explorer", [ApiCommandArgument.TestItem], ApiCommandResult.Void),
  new ApiCommand("vscode.startContinuousTestRun", "testing.startContinuousRunFromExtension", "Starts running the given tests with continuous run mode.", [ApiCommandArgument.TestProfile, ApiCommandArgument.Arr(ApiCommandArgument.TestItem)], ApiCommandResult.Void),
  new ApiCommand("vscode.stopContinuousTestRun", "testing.stopContinuousRunFromExtension", "Stops running the given tests with continuous run mode.", [ApiCommandArgument.Arr(ApiCommandArgument.TestItem)], ApiCommandResult.Void),
  // --- continue edit session
  new ApiCommand("vscode.experimental.editSession.continue", "_workbench.editSessions.actions.continueEditSession", "Continue the current edit session in a different workspace", [ApiCommandArgument.Uri.with("workspaceUri", "The target workspace to continue the current edit session in")], ApiCommandResult.Void),
  // --- context keys
  new ApiCommand("setContext", "_setContext", "Set a custom context key value that can be used in when clauses.", [
    ApiCommandArgument.String.with("name", "The context key name"),
    new ApiCommandArgument("value", "The context key value", () => true, (v) => v)
  ], ApiCommandResult.Void),
  // --- inline chat
  new ApiCommand("vscode.editorChat.start", "inlineChat.start", "Invoke a new editor chat session", [new ApiCommandArgument("Run arguments", "", (_v) => true, (v) => {
    if (!v) {
      return void 0;
    }
    return {
      initialRange: v.initialRange ? Range4.from(v.initialRange) : void 0,
      initialSelection: Selection.isSelection(v.initialSelection) ? Selection3.from(v.initialSelection) : void 0,
      message: v.message,
      attachments: v.attachments,
      autoSend: v.autoSend,
      position: v.position ? Position4.from(v.position) : void 0
    };
  })], ApiCommandResult.Void)
];
var ExtHostApiCommands = class {
  static register(commands) {
    newCommands.forEach(commands.registerApiCommand, commands);
    this._registerValidateWhenClausesCommand(commands);
  }
  static _registerValidateWhenClausesCommand(commands) {
    commands.registerCommand(false, "_validateWhenClauses", validateWhenClauses);
  }
};
function tryMapWith(f) {
  return (value) => {
    if (Array.isArray(value)) {
      return value.map(f);
    }
    return void 0;
  };
}
function mapLocationOrLocationLink(values) {
  if (!Array.isArray(values)) {
    return void 0;
  }
  const result = [];
  for (const item of values) {
    if (isLocationLink(item)) {
      result.push(DefinitionLink.to(item));
    } else {
      result.push(location.to(item));
    }
  }
  return result;
}

// out-build/vs/workbench/api/common/extHostBulkEdits.js
var ExtHostBulkEdits = class ExtHostBulkEdits2 {
  constructor(extHostRpc, extHostDocumentsAndEditors) {
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadBulkEdits);
    this._versionInformationProvider = {
      getTextDocumentVersion: (uri) => extHostDocumentsAndEditors.getDocument(uri)?.version,
      getNotebookDocumentVersion: () => void 0
    };
  }
  applyWorkspaceEdit(edit2, extension, metadata) {
    const dto = new SerializableObjectWithBuffers(WorkspaceEdit3.from(edit2, this._versionInformationProvider));
    return this._proxy.$tryApplyWorkspaceEdit(dto, void 0, metadata?.isRefactoring ?? false);
  }
};
ExtHostBulkEdits = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostBulkEdits);

// out-build/vs/workbench/contrib/chat/common/chatActions.js
function isChatViewTitleActionContext(obj) {
  return !!obj && URI.isUri(obj.sessionResource) && obj.$mid === 19;
}

// out-build/vs/workbench/contrib/chat/common/chatService.js
var ChatErrorLevel2;
(function(ChatErrorLevel3) {
  ChatErrorLevel3[ChatErrorLevel3["Info"] = 0] = "Info";
  ChatErrorLevel3[ChatErrorLevel3["Warning"] = 1] = "Warning";
  ChatErrorLevel3[ChatErrorLevel3["Error"] = 2] = "Error";
})(ChatErrorLevel2 || (ChatErrorLevel2 = {}));
var ChatResponseReferencePartStatusKind2;
(function(ChatResponseReferencePartStatusKind3) {
  ChatResponseReferencePartStatusKind3[ChatResponseReferencePartStatusKind3["Complete"] = 1] = "Complete";
  ChatResponseReferencePartStatusKind3[ChatResponseReferencePartStatusKind3["Partial"] = 2] = "Partial";
  ChatResponseReferencePartStatusKind3[ChatResponseReferencePartStatusKind3["Omitted"] = 3] = "Omitted";
})(ChatResponseReferencePartStatusKind2 || (ChatResponseReferencePartStatusKind2 = {}));
var ChatResponseClearToPreviousToolInvocationReason2;
(function(ChatResponseClearToPreviousToolInvocationReason3) {
  ChatResponseClearToPreviousToolInvocationReason3[ChatResponseClearToPreviousToolInvocationReason3["NoReason"] = 0] = "NoReason";
  ChatResponseClearToPreviousToolInvocationReason3[ChatResponseClearToPreviousToolInvocationReason3["FilteredContentRetry"] = 1] = "FilteredContentRetry";
  ChatResponseClearToPreviousToolInvocationReason3[ChatResponseClearToPreviousToolInvocationReason3["CopyrightContentRetry"] = 2] = "CopyrightContentRetry";
})(ChatResponseClearToPreviousToolInvocationReason2 || (ChatResponseClearToPreviousToolInvocationReason2 = {}));
var ElicitationState;
(function(ElicitationState2) {
  ElicitationState2["Pending"] = "pending";
  ElicitationState2["Accepted"] = "accepted";
  ElicitationState2["Rejected"] = "rejected";
})(ElicitationState || (ElicitationState = {}));
var ToolConfirmKind;
(function(ToolConfirmKind2) {
  ToolConfirmKind2[ToolConfirmKind2["Denied"] = 0] = "Denied";
  ToolConfirmKind2[ToolConfirmKind2["ConfirmationNotNeeded"] = 1] = "ConfirmationNotNeeded";
  ToolConfirmKind2[ToolConfirmKind2["Setting"] = 2] = "Setting";
  ToolConfirmKind2[ToolConfirmKind2["LmServicePerTool"] = 3] = "LmServicePerTool";
  ToolConfirmKind2[ToolConfirmKind2["UserAction"] = 4] = "UserAction";
  ToolConfirmKind2[ToolConfirmKind2["Skipped"] = 5] = "Skipped";
})(ToolConfirmKind || (ToolConfirmKind = {}));
var IChatToolInvocation;
(function(IChatToolInvocation2) {
  let StateKind;
  (function(StateKind2) {
    StateKind2[StateKind2["WaitingForConfirmation"] = 0] = "WaitingForConfirmation";
    StateKind2[StateKind2["Executing"] = 1] = "Executing";
    StateKind2[StateKind2["WaitingForPostApproval"] = 2] = "WaitingForPostApproval";
    StateKind2[StateKind2["Completed"] = 3] = "Completed";
    StateKind2[StateKind2["Cancelled"] = 4] = "Cancelled";
  })(StateKind = IChatToolInvocation2.StateKind || (IChatToolInvocation2.StateKind = {}));
  function executionConfirmedOrDenied(invocation, reader) {
    if (invocation.kind === "toolInvocationSerialized") {
      if (invocation.isConfirmed === void 0 || typeof invocation.isConfirmed === "boolean") {
        return {
          type: invocation.isConfirmed ? 4 : 0
          /* ToolConfirmKind.Denied */
        };
      }
      return invocation.isConfirmed;
    }
    const state = invocation.state.read(reader);
    if (state.type === 0) {
      return void 0;
    }
    if (state.type === 4) {
      return { type: state.reason };
    }
    return state.confirmed;
  }
  IChatToolInvocation2.executionConfirmedOrDenied = executionConfirmedOrDenied;
  function awaitConfirmation(invocation, token) {
    const reason = executionConfirmedOrDenied(invocation);
    if (reason) {
      return Promise.resolve(reason);
    }
    const store = new DisposableStore();
    return new Promise((resolve2) => {
      if (token) {
        store.add(token.onCancellationRequested(() => {
          resolve2({
            type: 0
            /* ToolConfirmKind.Denied */
          });
        }));
      }
      store.add(autorun((reader) => {
        const reason2 = executionConfirmedOrDenied(invocation, reader);
        if (reason2) {
          store.dispose();
          resolve2(reason2);
        }
      }));
    }).finally(() => {
      store.dispose();
    });
  }
  IChatToolInvocation2.awaitConfirmation = awaitConfirmation;
  function postApprovalConfirmedOrDenied(invocation, reader) {
    const state = invocation.state.read(reader);
    if (state.type === 3) {
      return state.postConfirmed || {
        type: 1
        /* ToolConfirmKind.ConfirmationNotNeeded */
      };
    }
    if (state.type === 4) {
      return { type: state.reason };
    }
    return void 0;
  }
  function confirmWith(invocation, reason) {
    const state = invocation?.state.get();
    if (state?.type === 0 || state?.type === 2) {
      state.confirm(reason);
      return true;
    }
    return false;
  }
  IChatToolInvocation2.confirmWith = confirmWith;
  function awaitPostConfirmation(invocation, token) {
    const reason = postApprovalConfirmedOrDenied(invocation);
    if (reason) {
      return Promise.resolve(reason);
    }
    const store = new DisposableStore();
    return new Promise((resolve2) => {
      if (token) {
        store.add(token.onCancellationRequested(() => {
          resolve2({
            type: 0
            /* ToolConfirmKind.Denied */
          });
        }));
      }
      store.add(autorun((reader) => {
        const reason2 = postApprovalConfirmedOrDenied(invocation, reader);
        if (reason2) {
          store.dispose();
          resolve2(reason2);
        }
      }));
    }).finally(() => {
      store.dispose();
    });
  }
  IChatToolInvocation2.awaitPostConfirmation = awaitPostConfirmation;
  function resultDetails(invocation, reader) {
    if (invocation.kind === "toolInvocationSerialized") {
      return invocation.resultDetails;
    }
    const state = invocation.state.read(reader);
    if (state.type === 3 || state.type === 2) {
      return state.resultDetails;
    }
    return void 0;
  }
  IChatToolInvocation2.resultDetails = resultDetails;
  function isComplete(invocation, reader) {
    if ("isComplete" in invocation) {
      return true;
    }
    const state = invocation.state.read(reader);
    return state.type === 3 || state.type === 4;
  }
  IChatToolInvocation2.isComplete = isComplete;
})(IChatToolInvocation || (IChatToolInvocation = {}));
var ChatAgentVoteDirection;
(function(ChatAgentVoteDirection2) {
  ChatAgentVoteDirection2[ChatAgentVoteDirection2["Down"] = 0] = "Down";
  ChatAgentVoteDirection2[ChatAgentVoteDirection2["Up"] = 1] = "Up";
})(ChatAgentVoteDirection || (ChatAgentVoteDirection = {}));
var ChatAgentVoteDownReason;
(function(ChatAgentVoteDownReason2) {
  ChatAgentVoteDownReason2["IncorrectCode"] = "incorrectCode";
  ChatAgentVoteDownReason2["DidNotFollowInstructions"] = "didNotFollowInstructions";
  ChatAgentVoteDownReason2["IncompleteCode"] = "incompleteCode";
  ChatAgentVoteDownReason2["MissingContext"] = "missingContext";
  ChatAgentVoteDownReason2["PoorlyWrittenOrFormatted"] = "poorlyWrittenOrFormatted";
  ChatAgentVoteDownReason2["RefusedAValidRequest"] = "refusedAValidRequest";
  ChatAgentVoteDownReason2["OffensiveOrUnsafe"] = "offensiveOrUnsafe";
  ChatAgentVoteDownReason2["Other"] = "other";
  ChatAgentVoteDownReason2["WillReportIssue"] = "willReportIssue";
})(ChatAgentVoteDownReason || (ChatAgentVoteDownReason = {}));
var ChatCopyKind2;
(function(ChatCopyKind3) {
  ChatCopyKind3[ChatCopyKind3["Action"] = 1] = "Action";
  ChatCopyKind3[ChatCopyKind3["Toolbar"] = 2] = "Toolbar";
})(ChatCopyKind2 || (ChatCopyKind2 = {}));
var IChatService = createDecorator("IChatService");

// out-build/vs/workbench/api/common/extHostChatAgents2.js
var ChatAgentResponseStream = class {
  constructor(_extension, _request, _proxy, _commandsConverter, _sessionDisposables) {
    this._extension = _extension;
    this._request = _request;
    this._proxy = _proxy;
    this._commandsConverter = _commandsConverter;
    this._sessionDisposables = _sessionDisposables;
    this._stopWatch = StopWatch.create(false);
    this._isClosed = false;
  }
  close() {
    this._isClosed = true;
  }
  get timings() {
    return {
      firstProgress: this._firstProgress,
      totalElapsed: this._stopWatch.elapsed()
    };
  }
  get apiObject() {
    if (!this._apiObject) {
      let throwIfDone2 = function(source) {
        if (that._isClosed) {
          const err = new Error("Response stream has been closed");
          Error.captureStackTrace(err, source);
          throw err;
        }
      }, send2 = function(chunk, handle) {
        const newLen = sendQueue.push(handle !== void 0 ? [chunk, handle] : chunk);
        if (newLen === 1) {
          queueMicrotask(() => {
            const toNotify = notify;
            notify = [];
            that._proxy.$handleProgressChunk(that._request.requestId, sendQueue).finally(() => {
              toNotify.forEach((f) => f());
            });
            sendQueue.length = 0;
          });
        }
        if (handle !== void 0) {
          return new Promise((resolve2) => {
            notify.push(resolve2);
          });
        }
        return;
      };
      var throwIfDone = throwIfDone2, send = send2;
      const that = this;
      this._stopWatch.reset();
      let taskHandlePool = 0;
      const sendQueue = [];
      let notify = [];
      const _report = (progress, task) => {
        if (typeof this._firstProgress === "undefined" && (progress.kind === "markdownContent" || progress.kind === "markdownVuln" || progress.kind === "prepareToolInvocation")) {
          this._firstProgress = this._stopWatch.elapsed();
        }
        if (task) {
          const myHandle = taskHandlePool++;
          const progressReporterPromise = send2(progress, myHandle);
          const progressReporter = {
            report: (p) => {
              progressReporterPromise.then(() => {
                if (MarkdownString2.isMarkdownString(p.value)) {
                  send2(ChatResponseWarningPart2.from(p), myHandle);
                } else {
                  send2(ChatResponseReferencePart2.from(p), myHandle);
                }
              });
            }
          };
          Promise.all([progressReporterPromise, task(progressReporter)]).then(([_void, res]) => {
            send2(ChatTaskResult.from(res), myHandle);
          });
        } else {
          send2(progress);
        }
      };
      this._apiObject = Object.freeze({
        clearToPreviousToolInvocation(reason) {
          throwIfDone2(this.markdown);
          send2({ kind: "clearToPreviousToolInvocation", reason });
          return this;
        },
        markdown(value) {
          throwIfDone2(this.markdown);
          const part = new ChatResponseMarkdownPart(value);
          const dto = ChatResponseMarkdownPart2.from(part);
          _report(dto);
          return this;
        },
        markdownWithVulnerabilities(value, vulnerabilities) {
          throwIfDone2(this.markdown);
          if (vulnerabilities) {
            checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          }
          const part = new ChatResponseMarkdownWithVulnerabilitiesPart(value, vulnerabilities);
          const dto = ChatResponseMarkdownWithVulnerabilitiesPart2.from(part);
          _report(dto);
          return this;
        },
        codeblockUri(value, isEdit) {
          throwIfDone2(this.codeblockUri);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatResponseCodeblockUriPart(value, isEdit);
          const dto = ChatResponseCodeblockUriPart2.from(part);
          _report(dto);
          return this;
        },
        filetree(value, baseUri) {
          throwIfDone2(this.filetree);
          const part = new ChatResponseFileTreePart(value, baseUri);
          const dto = ChatResponseFilesPart.from(part);
          _report(dto);
          return this;
        },
        anchor(value, title) {
          const part = new ChatResponseAnchorPart(value, title);
          return this.push(part);
        },
        button(value) {
          throwIfDone2(this.anchor);
          const part = new ChatResponseCommandButtonPart(value);
          const dto = ChatResponseCommandButtonPart2.from(part, that._commandsConverter, that._sessionDisposables);
          _report(dto);
          return this;
        },
        progress(value, task) {
          throwIfDone2(this.progress);
          const part = new ChatResponseProgressPart2(value, task);
          const dto = task ? ChatTask.from(part) : ChatResponseProgressPart3.from(part);
          _report(dto, task);
          return this;
        },
        thinkingProgress(thinkingDelta) {
          throwIfDone2(this.thinkingProgress);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatResponseThinkingProgressPart(thinkingDelta.text ?? "", thinkingDelta.id, thinkingDelta.metadata);
          const dto = ChatResponseThinkingProgressPart2.from(part);
          _report(dto);
          return this;
        },
        warning(value) {
          throwIfDone2(this.progress);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatResponseWarningPart(value);
          const dto = ChatResponseWarningPart2.from(part);
          _report(dto);
          return this;
        },
        reference(value, iconPath) {
          return this.reference2(value, iconPath);
        },
        reference2(value, iconPath, options2) {
          throwIfDone2(this.reference);
          if (typeof value === "object" && "variableName" in value) {
            checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          }
          if (typeof value === "object" && "variableName" in value && !value.value) {
            const matchingVarData = that._request.variables.variables.find((v) => v.name === value.variableName);
            if (matchingVarData) {
              let references;
              if (matchingVarData.references?.length) {
                references = matchingVarData.references.map((r) => ({
                  kind: "reference",
                  reference: { variableName: value.variableName, value: r.reference }
                }));
              } else {
                const part = new ChatResponseReferencePart(value, iconPath, options2);
                const dto = ChatResponseReferencePart2.from(part);
                references = [dto];
              }
              references.forEach((r) => _report(r));
              return this;
            } else {
            }
          } else {
            const part = new ChatResponseReferencePart(value, iconPath, options2);
            const dto = ChatResponseReferencePart2.from(part);
            _report(dto);
          }
          return this;
        },
        codeCitation(value, license, snippet) {
          throwIfDone2(this.codeCitation);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatResponseCodeCitationPart(value, license, snippet);
          const dto = ChatResponseCodeCitationPart2.from(part);
          _report(dto);
        },
        textEdit(target, edits) {
          throwIfDone2(this.textEdit);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatResponseTextEditPart(target, edits);
          part.isDone = edits === true ? true : void 0;
          const dto = ChatResponseTextEditPart2.from(part);
          _report(dto);
          return this;
        },
        notebookEdit(target, edits) {
          throwIfDone2(this.notebookEdit);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatResponseNotebookEditPart(target, edits);
          const dto = ChatResponseNotebookEditPart2.from(part);
          _report(dto);
          return this;
        },
        async externalEdit(target, callback) {
          throwIfDone2(this.externalEdit);
          const resources = Array.isArray(target) ? target : [target];
          const operationId = taskHandlePool++;
          await send2({ kind: "externalEdits", start: true, resources }, operationId);
          try {
            return await callback();
          } finally {
            await send2({ kind: "externalEdits", start: false, resources }, operationId);
          }
        },
        confirmation(title, message, data2, buttons) {
          throwIfDone2(this.confirmation);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatResponseConfirmationPart(title, message, data2, buttons);
          const dto = ChatResponseConfirmationPart2.from(part);
          _report(dto);
          return this;
        },
        prepareToolInvocation(toolName) {
          throwIfDone2(this.prepareToolInvocation);
          checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          const part = new ChatPrepareToolInvocationPart(toolName);
          const dto = ChatPrepareToolInvocationPart2.from(part);
          _report(dto);
          return this;
        },
        push(part) {
          throwIfDone2(this.push);
          if (part instanceof ChatResponseTextEditPart || part instanceof ChatResponseNotebookEditPart || part instanceof ChatResponseMarkdownWithVulnerabilitiesPart || part instanceof ChatResponseWarningPart || part instanceof ChatResponseConfirmationPart || part instanceof ChatResponseCodeCitationPart || part instanceof ChatResponseMovePart || part instanceof ChatResponseExtensionsPart || part instanceof ChatResponseExternalEditPart || part instanceof ChatResponseThinkingProgressPart || part instanceof ChatResponsePullRequestPart || part instanceof ChatResponseProgressPart2) {
            checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
          }
          if (part instanceof ChatResponseReferencePart) {
            this.reference2(part.value, part.iconPath, part.options);
          } else if (part instanceof ChatResponseProgressPart2) {
            const dto = part.task ? ChatTask.from(part) : ChatResponseProgressPart3.from(part);
            _report(dto, part.task);
          } else if (part instanceof ChatResponseThinkingProgressPart) {
            const dto = ChatResponseThinkingProgressPart2.from(part);
            _report(dto);
          } else if (part instanceof ChatResponseAnchorPart) {
            const dto = ChatResponseAnchorPart2.from(part);
            if (part.resolve) {
              checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
              dto.resolveId = generateUuid();
              const cts = new CancellationTokenSource();
              part.resolve(cts.token).then(() => {
                const resolvedDto = ChatResponseAnchorPart2.from(part);
                that._proxy.$handleAnchorResolve(that._request.requestId, dto.resolveId, resolvedDto);
              }).then(() => cts.dispose(), () => cts.dispose());
              that._sessionDisposables.add(toDisposable(() => cts.dispose(true)));
            }
            _report(dto);
          } else if (part instanceof ChatPrepareToolInvocationPart) {
            checkProposedApiEnabled(that._extension, "chatParticipantAdditions");
            const dto = ChatPrepareToolInvocationPart2.from(part);
            _report(dto);
            return this;
          } else if (part instanceof ChatResponseExternalEditPart) {
            const p = this.externalEdit(part.uris, part.callback);
            p.then(() => part.didGetApplied());
            return this;
          } else {
            const dto = ChatResponsePart.from(part, that._commandsConverter, that._sessionDisposables);
            _report(dto);
          }
          return this;
        }
      });
    }
    return this._apiObject;
  }
};
var ExtHostChatAgents2 = class _ExtHostChatAgents2 extends Disposable {
  static {
    this._idPool = 0;
  }
  static {
    this._participantDetectionProviderIdPool = 0;
  }
  static {
    this._relatedFilesProviderIdPool = 0;
  }
  constructor(mainContext, _logService, _commands, _documents, _languageModels, _diagnostics, _tools) {
    super();
    this._logService = _logService;
    this._commands = _commands;
    this._documents = _documents;
    this._languageModels = _languageModels;
    this._diagnostics = _diagnostics;
    this._tools = _tools;
    this._agents = /* @__PURE__ */ new Map();
    this._participantDetectionProviders = /* @__PURE__ */ new Map();
    this._relatedFilesProviders = /* @__PURE__ */ new Map();
    this._sessionDisposables = this._register(new DisposableMap());
    this._completionDisposables = this._register(new DisposableMap());
    this._inFlightRequests = /* @__PURE__ */ new Set();
    this._onDidChangeChatRequestTools = this._register(new Emitter());
    this.onDidChangeChatRequestTools = this._onDidChangeChatRequestTools.event;
    this._onDidDisposeChatSession = this._register(new Emitter());
    this.onDidDisposeChatSession = this._onDidDisposeChatSession.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadChatAgents2);
    _commands.registerArgumentProcessor({
      processArgument: (arg) => {
        if (isChatViewTitleActionContext(arg)) {
          return null;
        }
        return arg;
      }
    });
  }
  transferActiveChat(newWorkspace) {
    this._proxy.$transferActiveChatSession(newWorkspace);
  }
  createChatAgent(extension, id2, handler) {
    const handle = _ExtHostChatAgents2._idPool++;
    const agent = new ExtHostChatAgent(extension, id2, this._proxy, handle, handler);
    this._agents.set(handle, agent);
    this._proxy.$registerAgent(handle, extension.identifier, id2, {}, void 0);
    return agent.apiAgent;
  }
  createDynamicChatAgent(extension, id2, dynamicProps, handler) {
    const handle = _ExtHostChatAgents2._idPool++;
    const agent = new ExtHostChatAgent(extension, id2, this._proxy, handle, handler);
    this._agents.set(handle, agent);
    this._proxy.$registerAgent(handle, extension.identifier, id2, { isSticky: true }, dynamicProps);
    return agent.apiAgent;
  }
  registerChatParticipantDetectionProvider(extension, provider) {
    const handle = _ExtHostChatAgents2._participantDetectionProviderIdPool++;
    this._participantDetectionProviders.set(handle, new ExtHostParticipantDetector(extension, provider));
    this._proxy.$registerChatParticipantDetectionProvider(handle);
    return toDisposable(() => {
      this._participantDetectionProviders.delete(handle);
      this._proxy.$unregisterChatParticipantDetectionProvider(handle);
    });
  }
  registerRelatedFilesProvider(extension, provider, metadata) {
    const handle = _ExtHostChatAgents2._relatedFilesProviderIdPool++;
    this._relatedFilesProviders.set(handle, new ExtHostRelatedFilesProvider(extension, provider));
    this._proxy.$registerRelatedFilesProvider(handle, metadata);
    return toDisposable(() => {
      this._relatedFilesProviders.delete(handle);
      this._proxy.$unregisterRelatedFilesProvider(handle);
    });
  }
  async $provideRelatedFiles(handle, request, token) {
    const provider = this._relatedFilesProviders.get(handle);
    if (!provider) {
      return Promise.resolve([]);
    }
    const extRequestDraft = ChatRequestDraft.to(request);
    return await provider.provider.provideRelatedFiles(extRequestDraft, token) ?? void 0;
  }
  async $detectChatParticipant(handle, requestDto, context, options2, token) {
    const detector = this._participantDetectionProviders.get(handle);
    if (!detector) {
      return void 0;
    }
    const { request, location: location2, history } = await this._createRequest(requestDto, context, detector.extension);
    const model = await this.getModelForRequest(request, detector.extension);
    const extRequest = ChatAgentRequest.to(request, location2, model, this.getDiagnosticsWhenEnabled(detector.extension), this.getToolsForRequest(detector.extension, request.userSelectedTools), detector.extension, this._logService);
    return detector.provider.provideParticipantDetection(extRequest, { history }, { participants: options2.participants, location: ChatLocation2.to(options2.location) }, token);
  }
  async _createRequest(requestDto, context, extension) {
    const request = revive(requestDto);
    const convertedHistory = await this.prepareHistoryTurns(extension, request.agentId, context);
    let location2;
    if (request.locationData?.type === ChatAgentLocation.EditorInline) {
      const document2 = this._documents.getDocument(request.locationData.document);
      location2 = new ChatRequestEditorData(document2, Selection3.to(request.locationData.selection), Range4.to(request.locationData.wholeRange));
    } else if (request.locationData?.type === ChatAgentLocation.Notebook) {
      const cell = this._documents.getDocument(request.locationData.sessionInputUri);
      location2 = new ChatRequestNotebookData(cell);
    } else if (request.locationData?.type === ChatAgentLocation.Terminal) {
    }
    return { request, location: location2, history: convertedHistory };
  }
  async getModelForRequest(request, extension) {
    let model;
    if (request.userSelectedModelId) {
      model = await this._languageModels.getLanguageModelByIdentifier(extension, request.userSelectedModelId);
    }
    if (!model) {
      model = await this._languageModels.getDefaultLanguageModel(extension);
      if (!model) {
        throw new Error("Language model unavailable");
      }
    }
    return model;
  }
  async $setRequestTools(requestId, tools) {
    const request = [...this._inFlightRequests].find((r) => r.requestId === requestId);
    if (!request) {
      return;
    }
    request.extRequest.tools.clear();
    for (const [k, v] of this.getToolsForRequest(request.extension, tools)) {
      request.extRequest.tools.set(k, v);
    }
    this._onDidChangeChatRequestTools.fire(request.extRequest);
  }
  async $invokeAgent(handle, requestDto, context, token) {
    const agent = this._agents.get(handle);
    if (!agent) {
      throw new Error(`[CHAT](${handle}) CANNOT invoke agent because the agent is not registered`);
    }
    let stream;
    let inFlightRequest;
    try {
      const { request, location: location2, history } = await this._createRequest(requestDto, context, agent.extension);
      let sessionDisposables = this._sessionDisposables.get(request.sessionId);
      if (!sessionDisposables) {
        sessionDisposables = new DisposableStore();
        this._sessionDisposables.set(request.sessionId, sessionDisposables);
      }
      stream = new ChatAgentResponseStream(agent.extension, request, this._proxy, this._commands.converter, sessionDisposables);
      const model = await this.getModelForRequest(request, agent.extension);
      const extRequest = ChatAgentRequest.to(request, location2, model, this.getDiagnosticsWhenEnabled(agent.extension), this.getToolsForRequest(agent.extension, request.userSelectedTools), agent.extension, this._logService);
      inFlightRequest = { requestId: requestDto.requestId, extRequest, extension: agent.extension };
      this._inFlightRequests.add(inFlightRequest);
      let chatSessionContext;
      if (context.chatSessionContext) {
        chatSessionContext = {
          chatSessionItem: {
            resource: URI.revive(context.chatSessionContext.chatSessionResource),
            label: context.chatSessionContext.isUntitled ? "Untitled Session" : "Session"
          },
          isUntitled: context.chatSessionContext.isUntitled
        };
      }
      const chatContext = { history, chatSessionContext };
      const task = agent.invoke(extRequest, chatContext, stream.apiObject, token);
      return await raceCancellationWithTimeout(1e3, Promise.resolve(task).then((result) => {
        if (result?.metadata) {
          try {
            JSON.stringify(result.metadata);
          } catch (err) {
            const msg = `result.metadata MUST be JSON.stringify-able. Got error: ${err.message}`;
            this._logService.error(`[${agent.extension.identifier.value}] [@${agent.id}] ${msg}`, agent.extension);
            return { errorDetails: { message: msg }, timings: stream?.timings, nextQuestion: result.nextQuestion };
          }
        }
        let errorDetails;
        if (result?.errorDetails) {
          errorDetails = {
            ...result.errorDetails,
            responseIsIncomplete: true
          };
        }
        if (errorDetails?.responseIsRedacted || errorDetails?.isQuotaExceeded || errorDetails?.isRateLimited || errorDetails?.confirmationButtons || errorDetails?.code) {
          checkProposedApiEnabled(agent.extension, "chatParticipantPrivate");
        }
        return { errorDetails, timings: stream?.timings, metadata: result?.metadata, nextQuestion: result?.nextQuestion, details: result?.details };
      }), token);
    } catch (e) {
      this._logService.error(e, agent.extension);
      if (e instanceof LanguageModelError && e.cause) {
        e = e.cause;
      }
      const isQuotaExceeded = e instanceof Error && e.name === "ChatQuotaExceeded";
      const isRateLimited = e instanceof Error && e.name === "ChatRateLimited";
      return { errorDetails: { message: toErrorMessage(e), responseIsIncomplete: true, isQuotaExceeded, isRateLimited } };
    } finally {
      if (inFlightRequest) {
        this._inFlightRequests.delete(inFlightRequest);
      }
      stream?.close();
    }
  }
  getDiagnosticsWhenEnabled(extension) {
    if (!isProposedApiEnabled(extension, "chatReferenceDiagnostic")) {
      return [];
    }
    return this._diagnostics.getDiagnostics();
  }
  getToolsForRequest(extension, tools) {
    if (!tools) {
      return /* @__PURE__ */ new Map();
    }
    const result = /* @__PURE__ */ new Map();
    for (const tool of this._tools.getTools(extension)) {
      if (typeof tools[tool.name] === "boolean") {
        result.set(tool.name, tools[tool.name]);
      }
    }
    return result;
  }
  async prepareHistoryTurns(extension, agentId, context) {
    const res = [];
    for (const h of context.history) {
      const ehResult = ChatAgentResult.to(h.result);
      const result = agentId === h.request.agentId ? ehResult : { ...ehResult, metadata: void 0 };
      const varsWithoutTools = [];
      const toolReferences = [];
      for (const v of h.request.variables.variables) {
        if (v.kind === "tool") {
          toolReferences.push(ChatLanguageModelToolReference.to(v));
        } else if (v.kind === "toolset") {
          toolReferences.push(...v.value.map(ChatLanguageModelToolReference.to));
        } else {
          const ref = ChatPromptReference.to(v, this.getDiagnosticsWhenEnabled(extension), this._logService);
          if (ref) {
            varsWithoutTools.push(ref);
          }
        }
      }
      const editedFileEvents = isProposedApiEnabled(extension, "chatParticipantPrivate") ? h.request.editedFileEvents : void 0;
      const turn = new ChatRequestTurn(h.request.message, h.request.command, varsWithoutTools, h.request.agentId, toolReferences, editedFileEvents);
      res.push(turn);
      const parts = coalesce(h.response.map((r) => ChatResponsePart.toContent(r, this._commands.converter)));
      res.push(new ChatResponseTurn(parts, result, h.request.agentId, h.request.command));
    }
    return res;
  }
  $releaseSession(sessionId) {
    this._sessionDisposables.deleteAndDispose(sessionId);
    this._onDidDisposeChatSession.fire(sessionId);
  }
  async $provideFollowups(requestDto, handle, result, context, token) {
    const agent = this._agents.get(handle);
    if (!agent) {
      return Promise.resolve([]);
    }
    const request = revive(requestDto);
    const convertedHistory = await this.prepareHistoryTurns(agent.extension, agent.id, context);
    const ehResult = ChatAgentResult.to(result);
    return (await agent.provideFollowups(ehResult, { history: convertedHistory }, token)).filter((f) => {
      const isValid = !f.participant || Iterable.some(this._agents.values(), (a) => a.id === f.participant && ExtensionIdentifier.equals(a.extension.identifier, agent.extension.identifier));
      if (!isValid) {
        this._logService.warn(`[@${agent.id}] ChatFollowup refers to an unknown participant: ${f.participant}`);
      }
      return isValid;
    }).map((f) => ChatFollowup.from(f, request));
  }
  $acceptFeedback(handle, result, voteAction) {
    const agent = this._agents.get(handle);
    if (!agent) {
      return;
    }
    const ehResult = ChatAgentResult.to(result);
    let kind;
    switch (voteAction.direction) {
      case ChatAgentVoteDirection.Down:
        kind = ChatResultFeedbackKind.Unhelpful;
        break;
      case ChatAgentVoteDirection.Up:
        kind = ChatResultFeedbackKind.Helpful;
        break;
    }
    const feedback = {
      result: ehResult,
      kind,
      unhelpfulReason: isProposedApiEnabled(agent.extension, "chatParticipantAdditions") ? voteAction.reason : void 0
    };
    agent.acceptFeedback(Object.freeze(feedback));
  }
  $acceptAction(handle, result, event) {
    const agent = this._agents.get(handle);
    if (!agent) {
      return;
    }
    if (event.action.kind === "vote") {
      return;
    }
    const ehAction = ChatAgentUserActionEvent.to(result, event, this._commands.converter);
    if (ehAction) {
      agent.acceptAction(Object.freeze(ehAction));
    }
  }
  async $invokeCompletionProvider(handle, query, token) {
    const agent = this._agents.get(handle);
    if (!agent) {
      return [];
    }
    let disposables = this._completionDisposables.get(handle);
    if (disposables) {
      disposables.clear();
    } else {
      disposables = new DisposableStore();
      this._completionDisposables.set(handle, disposables);
    }
    const items = await agent.invokeCompletionProvider(query, token);
    return items.map((i) => ChatAgentCompletionItem.from(i, this._commands.converter, disposables));
  }
  async $provideChatTitle(handle, context, token) {
    const agent = this._agents.get(handle);
    if (!agent) {
      return;
    }
    const history = await this.prepareHistoryTurns(agent.extension, agent.id, { history: context });
    return await agent.provideTitle({ history }, token);
  }
  async $provideChatSummary(handle, context, token) {
    const agent = this._agents.get(handle);
    if (!agent) {
      return;
    }
    const history = await this.prepareHistoryTurns(agent.extension, agent.id, { history: context });
    return await agent.provideSummary({ history }, token);
  }
};
var ExtHostParticipantDetector = class {
  constructor(extension, provider) {
    this.extension = extension;
    this.provider = provider;
  }
};
var ExtHostRelatedFilesProvider = class {
  constructor(extension, provider) {
    this.extension = extension;
    this.provider = provider;
  }
};
var ExtHostChatAgent = class {
  constructor(extension, id2, _proxy, _handle, _requestHandler) {
    this.extension = extension;
    this.id = id2;
    this._proxy = _proxy;
    this._handle = _handle;
    this._requestHandler = _requestHandler;
    this._onDidReceiveFeedback = new Emitter();
    this._onDidPerformAction = new Emitter();
    this._pauseStateEmitter = new Emitter();
  }
  acceptFeedback(feedback) {
    this._onDidReceiveFeedback.fire(feedback);
  }
  acceptAction(event) {
    this._onDidPerformAction.fire(event);
  }
  setChatRequestPauseState(pauseState) {
    this._pauseStateEmitter.fire(pauseState);
  }
  async invokeCompletionProvider(query, token) {
    if (!this._agentVariableProvider) {
      return [];
    }
    return await this._agentVariableProvider.provider.provideCompletionItems(query, token) ?? [];
  }
  async provideFollowups(result, context, token) {
    if (!this._followupProvider) {
      return [];
    }
    const followups = await this._followupProvider.provideFollowups(result, context, token);
    if (!followups) {
      return [];
    }
    return followups.filter((f) => !(f && "commandId" in f)).filter((f) => !(f && "message" in f));
  }
  async provideTitle(context, token) {
    if (!this._titleProvider) {
      return;
    }
    return await this._titleProvider.provideChatTitle(context, token) ?? void 0;
  }
  async provideSummary(context, token) {
    if (!this._summarizer) {
      return;
    }
    return await this._summarizer.provideChatSummary(context, token) ?? void 0;
  }
  get apiAgent() {
    let disposed = false;
    let updateScheduled = false;
    const updateMetadataSoon = () => {
      if (disposed) {
        return;
      }
      if (updateScheduled) {
        return;
      }
      updateScheduled = true;
      queueMicrotask(() => {
        this._proxy.$updateAgent(this._handle, {
          icon: !this._iconPath ? void 0 : this._iconPath instanceof URI ? this._iconPath : "light" in this._iconPath ? this._iconPath.light : void 0,
          iconDark: !this._iconPath ? void 0 : "dark" in this._iconPath ? this._iconPath.dark : void 0,
          themeIcon: this._iconPath instanceof ThemeIcon2 ? this._iconPath : void 0,
          hasFollowups: this._followupProvider !== void 0,
          helpTextPrefix: !this._helpTextPrefix || typeof this._helpTextPrefix === "string" ? this._helpTextPrefix : MarkdownString4.from(this._helpTextPrefix),
          helpTextPostfix: !this._helpTextPostfix || typeof this._helpTextPostfix === "string" ? this._helpTextPostfix : MarkdownString4.from(this._helpTextPostfix),
          supportIssueReporting: this._supportIssueReporting,
          additionalWelcomeMessage: !this._additionalWelcomeMessage || typeof this._additionalWelcomeMessage === "string" ? this._additionalWelcomeMessage : MarkdownString4.from(this._additionalWelcomeMessage)
        });
        updateScheduled = false;
      });
    };
    const that = this;
    return {
      get id() {
        return that.id;
      },
      get iconPath() {
        return that._iconPath;
      },
      set iconPath(v) {
        that._iconPath = v;
        updateMetadataSoon();
      },
      get requestHandler() {
        return that._requestHandler;
      },
      set requestHandler(v) {
        assertType(typeof v === "function", "Invalid request handler");
        that._requestHandler = v;
      },
      get followupProvider() {
        return that._followupProvider;
      },
      set followupProvider(v) {
        that._followupProvider = v;
        updateMetadataSoon();
      },
      get helpTextPrefix() {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        return that._helpTextPrefix;
      },
      set helpTextPrefix(v) {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        that._helpTextPrefix = v;
        updateMetadataSoon();
      },
      get helpTextPostfix() {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        return that._helpTextPostfix;
      },
      set helpTextPostfix(v) {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        that._helpTextPostfix = v;
        updateMetadataSoon();
      },
      get supportIssueReporting() {
        checkProposedApiEnabled(that.extension, "chatParticipantPrivate");
        return that._supportIssueReporting;
      },
      set supportIssueReporting(v) {
        checkProposedApiEnabled(that.extension, "chatParticipantPrivate");
        that._supportIssueReporting = v;
        updateMetadataSoon();
      },
      get onDidReceiveFeedback() {
        return that._onDidReceiveFeedback.event;
      },
      set participantVariableProvider(v) {
        checkProposedApiEnabled(that.extension, "chatParticipantAdditions");
        that._agentVariableProvider = v;
        if (v) {
          if (!v.triggerCharacters.length) {
            throw new Error("triggerCharacters are required");
          }
          that._proxy.$registerAgentCompletionsProvider(that._handle, that.id, v.triggerCharacters);
        } else {
          that._proxy.$unregisterAgentCompletionsProvider(that._handle, that.id);
        }
      },
      get participantVariableProvider() {
        checkProposedApiEnabled(that.extension, "chatParticipantAdditions");
        return that._agentVariableProvider;
      },
      set additionalWelcomeMessage(v) {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        that._additionalWelcomeMessage = v;
        updateMetadataSoon();
      },
      get additionalWelcomeMessage() {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        return that._additionalWelcomeMessage;
      },
      set titleProvider(v) {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        that._titleProvider = v;
        updateMetadataSoon();
      },
      get titleProvider() {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        return that._titleProvider;
      },
      set summarizer(v) {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        that._summarizer = v;
      },
      get summarizer() {
        checkProposedApiEnabled(that.extension, "defaultChatParticipant");
        return that._summarizer;
      },
      get onDidChangePauseState() {
        checkProposedApiEnabled(that.extension, "chatParticipantAdditions");
        return that._pauseStateEmitter.event;
      },
      onDidPerformAction: !isProposedApiEnabled(this.extension, "chatParticipantAdditions") ? void 0 : this._onDidPerformAction.event,
      dispose() {
        disposed = true;
        that._followupProvider = void 0;
        that._onDidReceiveFeedback.dispose();
        that._proxy.$unregisterAgent(that._handle);
      }
    };
  }
  invoke(request, context, response, token) {
    return this._requestHandler(request, context, response, token);
  }
};
function raceCancellationWithTimeout(cancelWait, promise, token) {
  return new Promise((resolve2, reject) => {
    const ref = token.onCancellationRequested(async () => {
      ref.dispose();
      await timeout(cancelWait);
      resolve2(void 0);
    });
    promise.then(resolve2, reject).finally(() => ref.dispose());
  });
}

// out-build/vs/workbench/api/common/extHostChatOutputRenderer.js
var ExtHostChatOutputRenderer = class {
  constructor(mainContext, webviews) {
    this.webviews = webviews;
    this._renderers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadChatOutputRenderer);
  }
  registerChatOutputRenderer(extension, viewType, renderer) {
    if (this._renderers.has(viewType)) {
      throw new Error(`Chat output renderer already registered for: ${viewType}`);
    }
    this._renderers.set(viewType, { extension, renderer });
    this._proxy.$registerChatOutputRenderer(viewType, extension.identifier, extension.extensionLocation);
    return new Disposable2(() => {
      this._renderers.delete(viewType);
      this._proxy.$unregisterChatOutputRenderer(viewType);
    });
  }
  async $renderChatOutput(viewType, mime, valueData, webviewHandle, token) {
    const entry = this._renderers.get(viewType);
    if (!entry) {
      throw new Error(`No chat output renderer registered for: ${viewType}`);
    }
    const webview = this.webviews.createNewWebview(webviewHandle, {}, entry.extension);
    return entry.renderer.renderChatOutput(Object.freeze({ mime, value: valueData.buffer }), webview, {}, token);
  }
};

// out-build/vs/workbench/api/common/extHostChatSessions.js
var ExtHostChatSessions_1;
var ExtHostChatSession = class {
  constructor(session, extension, request, proxy, commandsConverter, sessionDisposables) {
    this.session = session;
    this.extension = extension;
    this.proxy = proxy;
    this.commandsConverter = commandsConverter;
    this.sessionDisposables = sessionDisposables;
    this._stream = new ChatAgentResponseStream(extension, request, proxy, commandsConverter, sessionDisposables);
  }
  get activeResponseStream() {
    return this._stream;
  }
  getActiveRequestStream(request) {
    return new ChatAgentResponseStream(this.extension, request, this.proxy, this.commandsConverter, this.sessionDisposables);
  }
};
var ExtHostChatSessions = class ExtHostChatSessions2 extends Disposable {
  static {
    ExtHostChatSessions_1 = this;
  }
  static {
    this._sessionHandlePool = 0;
  }
  constructor(commands, _languageModels, _extHostRpc, _logService) {
    super();
    this.commands = commands;
    this._languageModels = _languageModels;
    this._extHostRpc = _extHostRpc;
    this._logService = _logService;
    this._chatSessionItemProviders = /* @__PURE__ */ new Map();
    this._chatSessionContentProviders = /* @__PURE__ */ new Map();
    this._nextChatSessionItemProviderHandle = 0;
    this._nextChatSessionContentProviderHandle = 0;
    this._sessionItems = new ResourceMap();
    this._extHostChatSessions = new ResourceMap();
    this._proxy = this._extHostRpc.getProxy(MainContext.MainThreadChatSessions);
    commands.registerArgumentProcessor({
      processArgument: (arg) => {
        if (arg && arg.$mid === 25) {
          const id2 = arg.session.resource || arg.sessionId;
          const sessionContent = this._sessionItems.get(id2);
          if (sessionContent) {
            return sessionContent;
          } else {
            this._logService.warn(`No chat session found for ID: ${id2}`);
            return arg;
          }
        }
        return arg;
      }
    });
  }
  registerChatSessionItemProvider(extension, chatSessionType, provider) {
    const handle = this._nextChatSessionItemProviderHandle++;
    const disposables = new DisposableStore();
    this._chatSessionItemProviders.set(handle, { provider, extension, disposable: disposables, sessionType: chatSessionType });
    this._proxy.$registerChatSessionItemProvider(handle, chatSessionType);
    if (provider.onDidChangeChatSessionItems) {
      disposables.add(provider.onDidChangeChatSessionItems(() => {
        this._proxy.$onDidChangeChatSessionItems(handle);
      }));
    }
    if (provider.onDidCommitChatSessionItem) {
      disposables.add(provider.onDidCommitChatSessionItem((e) => {
        const { original, modified } = e;
        this._proxy.$onDidCommitChatSessionItem(handle, original.resource, modified.resource);
      }));
    }
    return {
      dispose: () => {
        this._chatSessionItemProviders.delete(handle);
        disposables.dispose();
        this._proxy.$unregisterChatSessionItemProvider(handle);
      }
    };
  }
  registerChatSessionContentProvider(extension, chatSessionScheme, chatParticipant, provider, capabilities) {
    const handle = this._nextChatSessionContentProviderHandle++;
    const disposables = new DisposableStore();
    this._chatSessionContentProviders.set(handle, { provider, extension, capabilities, disposable: disposables });
    this._proxy.$registerChatSessionContentProvider(handle, chatSessionScheme);
    return new Disposable2(() => {
      this._chatSessionContentProviders.delete(handle);
      disposables.dispose();
      this._proxy.$unregisterChatSessionContentProvider(handle);
    });
  }
  convertChatSessionStatus(status) {
    if (status === void 0) {
      return void 0;
    }
    switch (status) {
      case 0:
        return 0;
      case 1:
        return 1;
      case 2:
        return 2;
      default:
        return void 0;
    }
  }
  convertChatSessionItem(sessionType, sessionContent) {
    return {
      resource: sessionContent.resource,
      label: sessionContent.label,
      description: sessionContent.description ? MarkdownString4.from(sessionContent.description) : void 0,
      status: this.convertChatSessionStatus(sessionContent.status),
      tooltip: MarkdownString4.fromStrict(sessionContent.tooltip),
      timing: {
        startTime: sessionContent.timing?.startTime ?? 0,
        endTime: sessionContent.timing?.endTime
      },
      statistics: sessionContent.statistics ? {
        files: sessionContent.statistics?.files ?? 0,
        insertions: sessionContent.statistics?.insertions ?? 0,
        deletions: sessionContent.statistics?.deletions ?? 0
      } : void 0
    };
  }
  async $provideNewChatSessionItem(handle, options2, token) {
    const entry = this._chatSessionItemProviders.get(handle);
    if (!entry || !entry.provider.provideNewChatSessionItem) {
      throw new Error(`No provider registered for handle ${handle} or provider does not support creating sessions`);
    }
    try {
      const model = await this.getModelForRequest(options2.request, entry.extension);
      const vscodeRequest = ChatAgentRequest.to(revive(options2.request), void 0, model, [], /* @__PURE__ */ new Map(), entry.extension, this._logService);
      const vscodeOptions = {
        request: vscodeRequest,
        metadata: options2.metadata
      };
      const chatSessionItem = await entry.provider.provideNewChatSessionItem(vscodeOptions, token);
      if (!chatSessionItem) {
        throw new Error("Provider did not create session");
      }
      this._sessionItems.set(chatSessionItem.resource, chatSessionItem);
      return this.convertChatSessionItem(entry.sessionType, chatSessionItem);
    } catch (error) {
      this._logService.error(`Error creating chat session: ${error}`);
      throw error;
    }
  }
  async $provideChatSessionItems(handle, token) {
    const entry = this._chatSessionItemProviders.get(handle);
    if (!entry) {
      this._logService.error(`No provider registered for handle ${handle}`);
      return [];
    }
    const sessions = await entry.provider.provideChatSessionItems(token);
    if (!sessions) {
      return [];
    }
    const response = [];
    for (const sessionContent of sessions) {
      this._sessionItems.set(sessionContent.resource, sessionContent);
      response.push(this.convertChatSessionItem(entry.sessionType, sessionContent));
    }
    return response;
  }
  async $provideChatSessionContent(handle, sessionResourceComponents, token) {
    const provider = this._chatSessionContentProviders.get(handle);
    if (!provider) {
      throw new Error(`No provider for handle ${handle}`);
    }
    const sessionResource = URI.revive(sessionResourceComponents);
    const session = await provider.provider.provideChatSessionContent(sessionResource, token);
    if (token.isCancellationRequested) {
      throw new CancellationError();
    }
    const sessionDisposables = new DisposableStore();
    const sessionId = ExtHostChatSessions_1._sessionHandlePool++;
    const id2 = sessionResource.toString();
    const chatSession = new ExtHostChatSession(session, provider.extension, {
      sessionId: `${id2}.${sessionId}`,
      sessionResource,
      requestId: "ongoing",
      agentId: id2,
      message: "",
      variables: { variables: [] },
      location: ChatAgentLocation.Chat
    }, {
      $handleProgressChunk: (requestId, chunks) => {
        return this._proxy.$handleProgressChunk(handle, sessionResource, requestId, chunks);
      },
      $handleAnchorResolve: (requestId, requestHandle, anchor) => {
        this._proxy.$handleAnchorResolve(handle, sessionResource, requestId, requestHandle, anchor);
      }
    }, this.commands.converter, sessionDisposables);
    const disposeCts = sessionDisposables.add(new CancellationTokenSource());
    this._extHostChatSessions.set(sessionResource, { sessionObj: chatSession, disposeCts });
    if (session.activeResponseCallback) {
      Promise.resolve(session.activeResponseCallback(chatSession.activeResponseStream.apiObject, disposeCts.token)).finally(() => {
        this._proxy.$handleProgressComplete(handle, sessionResource, "ongoing");
      });
    }
    const { capabilities } = provider;
    return {
      id: sessionId + "",
      resource: URI.revive(sessionResource),
      hasActiveResponseCallback: !!session.activeResponseCallback,
      hasRequestHandler: !!session.requestHandler,
      supportsInterruption: !!capabilities?.supportsInterruptions,
      options: session.options,
      history: session.history.map((turn) => {
        if (turn instanceof ChatRequestTurn) {
          return this.convertRequestTurn(turn);
        } else {
          return this.convertResponseTurn(turn, sessionDisposables);
        }
      })
    };
  }
  async $provideHandleOptionsChange(handle, sessionResourceComponents, updates, token) {
    const sessionResource = URI.revive(sessionResourceComponents);
    const provider = this._chatSessionContentProviders.get(handle);
    if (!provider) {
      this._logService.warn(`No provider for handle ${handle}`);
      return;
    }
    if (!provider.provider.provideHandleOptionsChange) {
      this._logService.debug(`Provider for handle ${handle} does not implement provideHandleOptionsChange`);
      return;
    }
    try {
      await provider.provider.provideHandleOptionsChange(sessionResource, updates, token);
    } catch (error) {
      this._logService.error(`Error calling provideHandleOptionsChange for handle ${handle}, sessionResource ${sessionResource}:`, error);
    }
  }
  async $provideChatSessionProviderOptions(handle, token) {
    const entry = this._chatSessionContentProviders.get(handle);
    if (!entry) {
      this._logService.warn(`No provider for handle ${handle} when requesting chat session options`);
      return;
    }
    const provider = entry.provider;
    if (!provider.provideChatSessionProviderOptions) {
      return;
    }
    try {
      const { optionGroups } = await provider.provideChatSessionProviderOptions(token);
      if (!optionGroups) {
        return;
      }
      return {
        optionGroups
      };
    } catch (error) {
      this._logService.error(`Error calling provideChatSessionProviderOptions for handle ${handle}:`, error);
      return;
    }
  }
  async $interruptChatSessionActiveResponse(providerHandle, sessionResource, requestId) {
    const entry = this._extHostChatSessions.get(URI.revive(sessionResource));
    entry?.disposeCts.cancel();
  }
  async $disposeChatSessionContent(providerHandle, sessionResource) {
    const entry = this._extHostChatSessions.get(URI.revive(sessionResource));
    if (!entry) {
      this._logService.warn(`No chat session found for resource: ${sessionResource}`);
      return;
    }
    entry.disposeCts.cancel();
    entry.sessionObj.sessionDisposables.dispose();
    this._extHostChatSessions.delete(URI.revive(sessionResource));
  }
  async $invokeChatSessionRequestHandler(handle, sessionResource, request, history, token) {
    const entry = this._extHostChatSessions.get(URI.revive(sessionResource));
    if (!entry || !entry.sessionObj.session.requestHandler) {
      return {};
    }
    const chatRequest = ChatAgentRequest.to(request, void 0, await this.getModelForRequest(request, entry.sessionObj.extension), [], /* @__PURE__ */ new Map(), entry.sessionObj.extension, this._logService);
    const stream = entry.sessionObj.getActiveRequestStream(request);
    await entry.sessionObj.session.requestHandler(chatRequest, { history }, stream.apiObject, token);
    return {};
  }
  async getModelForRequest(request, extension) {
    let model;
    if (request.userSelectedModelId) {
      model = await this._languageModels.getLanguageModelByIdentifier(extension, request.userSelectedModelId);
    }
    if (!model) {
      model = await this._languageModels.getDefaultLanguageModel(extension);
      if (!model) {
        throw new Error("Language model unavailable");
      }
    }
    return model;
  }
  convertRequestTurn(turn) {
    const variables = turn.references.map((ref) => this.convertReferenceToVariable(ref));
    return {
      type: "request",
      prompt: turn.prompt,
      participant: turn.participant,
      command: turn.command,
      variableData: variables.length > 0 ? { variables } : void 0
    };
  }
  convertReferenceToVariable(ref) {
    const value = ref.value && typeof ref.value === "object" && "uri" in ref.value && "range" in ref.value ? Location3.from(ref.value) : ref.value;
    const range = ref.range ? { start: ref.range[0], endExclusive: ref.range[1] } : void 0;
    const isFile = URI.isUri(value) || value && typeof value === "object" && "uri" in value;
    return {
      id: ref.id,
      name: ref.id,
      value,
      modelDescription: ref.modelDescription,
      range,
      kind: isFile ? "file" : "generic"
    };
  }
  convertResponseTurn(turn, sessionDisposables) {
    const parts = coalesce(turn.response.map((r) => ChatResponsePart.from(r, this.commands.converter, sessionDisposables)));
    return {
      type: "response",
      parts,
      participant: turn.participant
    };
  }
};
ExtHostChatSessions = ExtHostChatSessions_1 = __decorate([
  __param(2, IExtHostRpcService),
  __param(3, ILogService)
], ExtHostChatSessions);

// out-build/vs/workbench/api/common/extHostChatStatus.js
var ExtHostChatStatus = class {
  constructor(mainContext) {
    this._items = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadChatStatus);
  }
  createChatStatusItem(extension, id2) {
    const internalId = asChatItemIdentifier(extension.identifier, id2);
    if (this._items.has(internalId)) {
      throw new Error(`Chat status item '${id2}' already exists`);
    }
    const state = {
      id: internalId,
      title: "",
      description: "",
      detail: ""
    };
    let disposed = false;
    let visible = false;
    const syncState = () => {
      if (disposed) {
        throw new Error("Chat status item is disposed");
      }
      if (!visible) {
        return;
      }
      this._proxy.$setEntry(id2, state);
    };
    const item = Object.freeze({
      id: id2,
      get title() {
        return state.title;
      },
      set title(value) {
        state.title = value;
        syncState();
      },
      get description() {
        return state.description;
      },
      set description(value) {
        state.description = value;
        syncState();
      },
      get detail() {
        return state.detail;
      },
      set detail(value) {
        state.detail = value;
        syncState();
      },
      show: () => {
        visible = true;
        syncState();
      },
      hide: () => {
        visible = false;
        this._proxy.$disposeEntry(id2);
      },
      dispose: () => {
        disposed = true;
        this._proxy.$disposeEntry(id2);
        this._items.delete(internalId);
      }
    });
    this._items.set(internalId, item);
    return item;
  }
};
function asChatItemIdentifier(extension, id2) {
  return `${ExtensionIdentifier.toKey(extension)}.${id2}`;
}

// out-build/vs/workbench/api/common/extHostClipboard.js
var ExtHostClipboard = class {
  constructor(mainContext) {
    const proxy = mainContext.getProxy(MainContext.MainThreadClipboard);
    this.value = Object.freeze({
      readText() {
        return proxy.$readText();
      },
      writeText(value) {
        return proxy.$writeText(value);
      }
    });
  }
};

// out-build/vs/workbench/contrib/webview/common/webview.js
var webviewResourceBaseHost = "vscode-cdn.net";
var webviewRootResourceAuthority = `vscode-resource.${webviewResourceBaseHost}`;
var webviewGenericCspSource = `'self' https://*.${webviewResourceBaseHost}`;
function asWebviewUri(resource, remoteInfo) {
  if (resource.scheme === Schemas.http || resource.scheme === Schemas.https) {
    return resource;
  }
  if (remoteInfo && remoteInfo.authority && remoteInfo.isRemote && resource.scheme === Schemas.file) {
    resource = URI.from({
      scheme: Schemas.vscodeRemote,
      authority: remoteInfo.authority,
      path: resource.path
    });
  }
  return URI.from({
    scheme: Schemas.https,
    authority: `${resource.scheme}+${encodeAuthority(resource.authority)}.${webviewRootResourceAuthority}`,
    path: resource.path,
    fragment: resource.fragment,
    query: resource.query
  });
}
function encodeAuthority(authority) {
  return authority.replace(/./g, (char) => {
    const code = char.charCodeAt(0);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57) {
      return char;
    }
    return "-" + code.toString(16).padStart(4, "0");
  });
}

// out-build/vs/workbench/api/common/extHostCodeInsets.js
var ExtHostEditorInsets = class {
  constructor(_proxy, _editors, _remoteInfo) {
    this._proxy = _proxy;
    this._editors = _editors;
    this._remoteInfo = _remoteInfo;
    this._handlePool = 0;
    this._disposables = new DisposableStore();
    this._insets = /* @__PURE__ */ new Map();
    this._disposables.add(_editors.onDidChangeVisibleTextEditors(() => {
      const visibleEditor = _editors.getVisibleTextEditors();
      for (const value of this._insets.values()) {
        if (visibleEditor.indexOf(value.editor) < 0) {
          value.inset.dispose();
        }
      }
    }));
  }
  dispose() {
    this._insets.forEach((value) => value.inset.dispose());
    this._disposables.dispose();
  }
  createWebviewEditorInset(editor, line, height, options2, extension) {
    let apiEditor;
    for (const candidate of this._editors.getVisibleTextEditors(true)) {
      if (candidate.value === editor) {
        apiEditor = candidate;
        break;
      }
    }
    if (!apiEditor) {
      throw new Error("not a visible editor");
    }
    const that = this;
    const handle = this._handlePool++;
    const onDidReceiveMessage = new Emitter();
    const onDidDispose = new Emitter();
    const webview = new class {
      constructor() {
        this._html = "";
        this._options = /* @__PURE__ */ Object.create(null);
      }
      asWebviewUri(resource) {
        return asWebviewUri(resource, that._remoteInfo);
      }
      get cspSource() {
        return webviewGenericCspSource;
      }
      set options(value) {
        this._options = value;
        that._proxy.$setOptions(handle, value);
      }
      get options() {
        return this._options;
      }
      set html(value) {
        this._html = value;
        that._proxy.$setHtml(handle, value);
      }
      get html() {
        return this._html;
      }
      get onDidReceiveMessage() {
        return onDidReceiveMessage.event;
      }
      postMessage(message) {
        return that._proxy.$postMessage(handle, message);
      }
    }();
    const inset = new class {
      constructor() {
        this.editor = editor;
        this.line = line;
        this.height = height;
        this.webview = webview;
        this.onDidDispose = onDidDispose.event;
      }
      dispose() {
        if (that._insets.has(handle)) {
          that._insets.delete(handle);
          that._proxy.$disposeEditorInset(handle);
          onDidDispose.fire();
          onDidDispose.dispose();
          onDidReceiveMessage.dispose();
        }
      }
    }();
    this._proxy.$createEditorInset(handle, apiEditor.id, apiEditor.value.document.uri, line + 1, height, options2 || {}, extension.identifier, extension.extensionLocation);
    this._insets.set(handle, { editor, inset, onDidReceiveMessage });
    return inset;
  }
  $onDidDispose(handle) {
    const value = this._insets.get(handle);
    if (value) {
      value.inset.dispose();
    }
  }
  $onDidReceiveMessage(handle, message) {
    const value = this._insets.get(handle);
    value?.onDidReceiveMessage.fire(message);
  }
};

// out-build/vs/workbench/api/common/extHostCodeMapper.js
var ExtHostCodeMapper = class _ExtHostCodeMapper {
  static {
    this._providerHandlePool = 0;
  }
  constructor(mainContext) {
    this.providers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadCodeMapper);
  }
  async $mapCode(handle, internalRequest, token) {
    const provider = this.providers.get(handle);
    if (!provider) {
      throw new Error(`Received request to map code for unknown provider handle ${handle}`);
    }
    const stream = {
      textEdit: (target, edits) => {
        edits = asArray(edits);
        this._proxy.$handleProgress(internalRequest.requestId, {
          uri: target,
          edits: edits.map(TextEdit3.from)
        });
      },
      notebookEdit: (target, edits) => {
        edits = asArray(edits);
        this._proxy.$handleProgress(internalRequest.requestId, {
          uri: target,
          edits: edits.map(NotebookEdit3.from)
        });
      }
    };
    const request = {
      location: internalRequest.location,
      chatRequestId: internalRequest.chatRequestId,
      chatRequestModel: internalRequest.chatRequestModel,
      chatSessionId: internalRequest.chatSessionId,
      codeBlocks: internalRequest.codeBlocks.map((block2) => {
        return {
          code: block2.code,
          resource: URI.revive(block2.resource),
          markdownBeforeBlock: block2.markdownBeforeBlock
        };
      })
    };
    const result = await provider.provideMappedEdits(request, stream, token);
    return result ?? null;
  }
  registerMappedEditsProvider(extension, provider) {
    const handle = _ExtHostCodeMapper._providerHandlePool++;
    this._proxy.$registerCodeMapperProvider(handle, extension.displayName ?? extension.name);
    this.providers.set(handle, provider);
    return {
      dispose: () => {
        return this._proxy.$unregisterCodeMapperProvider(handle);
      }
    };
  }
};

// out-build/vs/workbench/api/common/extHostComments.js
function createExtHostComments(mainContext, commands, documents) {
  const proxy = mainContext.getProxy(MainContext.MainThreadComments);
  class ExtHostCommentsImpl {
    static {
      this.handlePool = 0;
    }
    constructor() {
      this._commentControllers = /* @__PURE__ */ new Map();
      this._commentControllersByExtension = new ExtensionIdentifierMap();
      commands.registerArgumentProcessor({
        processArgument: (arg) => {
          if (arg && arg.$mid === 6) {
            const commentController = this._commentControllers.get(arg.handle);
            if (!commentController) {
              return arg;
            }
            return commentController.value;
          } else if (arg && arg.$mid === 7) {
            const marshalledCommentThread = arg;
            const commentController = this._commentControllers.get(marshalledCommentThread.commentControlHandle);
            if (!commentController) {
              return marshalledCommentThread;
            }
            const commentThread = commentController.getCommentThread(marshalledCommentThread.commentThreadHandle);
            if (!commentThread) {
              return marshalledCommentThread;
            }
            return commentThread.value;
          } else if (arg && (arg.$mid === 9 || arg.$mid === 8)) {
            const commentController = this._commentControllers.get(arg.thread.commentControlHandle);
            if (!commentController) {
              return arg;
            }
            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
            if (!commentThread) {
              return arg;
            }
            if (arg.$mid === 8) {
              return commentThread.value;
            }
            return {
              thread: commentThread.value,
              text: arg.text
            };
          } else if (arg && arg.$mid === 10) {
            const commentController = this._commentControllers.get(arg.thread.commentControlHandle);
            if (!commentController) {
              return arg;
            }
            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
            if (!commentThread) {
              return arg;
            }
            const commentUniqueId = arg.commentUniqueId;
            const comment = commentThread.getCommentByUniqueId(commentUniqueId);
            if (!comment) {
              return arg;
            }
            return comment;
          } else if (arg && arg.$mid === 11) {
            const commentController = this._commentControllers.get(arg.thread.commentControlHandle);
            if (!commentController) {
              return arg;
            }
            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
            if (!commentThread) {
              return arg;
            }
            const body = arg.text;
            const commentUniqueId = arg.commentUniqueId;
            const comment = commentThread.getCommentByUniqueId(commentUniqueId);
            if (!comment) {
              return arg;
            }
            if (typeof comment.body === "string") {
              comment.body = body;
            } else {
              comment.body = new MarkdownString2(body);
            }
            return comment;
          }
          return arg;
        }
      });
    }
    createCommentController(extension, id2, label) {
      const handle = ExtHostCommentsImpl.handlePool++;
      const commentController = new ExtHostCommentController(extension, handle, id2, label);
      this._commentControllers.set(commentController.handle, commentController);
      const commentControllers = this._commentControllersByExtension.get(extension.identifier) || [];
      commentControllers.push(commentController);
      this._commentControllersByExtension.set(extension.identifier, commentControllers);
      return commentController.value;
    }
    async $createCommentThreadTemplate(commentControllerHandle, uriComponents, range, editorId) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController) {
        return;
      }
      commentController.$createCommentThreadTemplate(uriComponents, range, editorId);
    }
    async $setActiveComment(controllerHandle, commentInfo) {
      const commentController = this._commentControllers.get(controllerHandle);
      if (!commentController) {
        return;
      }
      commentController.$setActiveComment(commentInfo ?? void 0);
    }
    async $updateCommentThreadTemplate(commentControllerHandle, threadHandle, range) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController) {
        return;
      }
      commentController.$updateCommentThreadTemplate(threadHandle, range);
    }
    $deleteCommentThread(commentControllerHandle, commentThreadHandle) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      commentController?.$deleteCommentThread(commentThreadHandle);
    }
    async $updateCommentThread(commentControllerHandle, commentThreadHandle, changes) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      commentController?.$updateCommentThread(commentThreadHandle, changes);
    }
    async $provideCommentingRanges(commentControllerHandle, uriComponents, token) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController || !commentController.commentingRangeProvider) {
        return Promise.resolve(void 0);
      }
      const document2 = await documents.ensureDocumentData(URI.revive(uriComponents));
      return asPromise(async () => {
        const rangesResult = await commentController.commentingRangeProvider?.provideCommentingRanges(document2.document, token);
        let ranges;
        if (Array.isArray(rangesResult)) {
          ranges = {
            ranges: rangesResult,
            fileComments: false
          };
        } else if (rangesResult) {
          ranges = {
            ranges: rangesResult.ranges || [],
            fileComments: rangesResult.enableFileComments || false
          };
        } else {
          ranges = rangesResult ?? void 0;
        }
        return ranges;
      }).then((ranges) => {
        let convertedResult = void 0;
        if (ranges) {
          convertedResult = {
            ranges: ranges.ranges.map((x) => Range4.from(x)),
            fileComments: ranges.fileComments
          };
        }
        return convertedResult;
      });
    }
    $toggleReaction(commentControllerHandle, threadHandle, uri, comment, reaction) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController || !commentController.reactionHandler) {
        return Promise.resolve(void 0);
      }
      return asPromise(() => {
        const commentThread = commentController.getCommentThread(threadHandle);
        if (commentThread) {
          const vscodeComment = commentThread.getCommentByUniqueId(comment.uniqueIdInThread);
          if (commentController !== void 0 && vscodeComment) {
            if (commentController.reactionHandler) {
              return commentController.reactionHandler(vscodeComment, convertFromReaction(reaction));
            }
          }
        }
        return Promise.resolve(void 0);
      });
    }
  }
  class ExtHostCommentThread {
    static {
      this._handlePool = 0;
    }
    set threadId(id2) {
      this._id = id2;
    }
    get threadId() {
      return this._id;
    }
    get id() {
      return this._id;
    }
    get resource() {
      return this._uri;
    }
    get uri() {
      return this._uri;
    }
    set range(range) {
      if (range === void 0 !== (this._range === void 0) || (!range || !this._range || !range.isEqual(this._range))) {
        this._range = range;
        this.modifications.range = range;
        this._onDidUpdateCommentThread.fire();
      }
    }
    get range() {
      return this._range;
    }
    set canReply(state) {
      if (this._canReply !== state) {
        this._canReply = state;
        this.modifications.canReply = state;
        this._onDidUpdateCommentThread.fire();
      }
    }
    get canReply() {
      return this._canReply;
    }
    get label() {
      return this._label;
    }
    set label(label) {
      this._label = label;
      this.modifications.label = label;
      this._onDidUpdateCommentThread.fire();
    }
    get contextValue() {
      return this._contextValue;
    }
    set contextValue(context) {
      this._contextValue = context;
      this.modifications.contextValue = context;
      this._onDidUpdateCommentThread.fire();
    }
    get comments() {
      return this._comments;
    }
    set comments(newComments) {
      this._comments = newComments;
      this.modifications.comments = newComments;
      this._onDidUpdateCommentThread.fire();
    }
    get collapsibleState() {
      return this._collapseState;
    }
    set collapsibleState(newState) {
      if (this._collapseState === newState) {
        return;
      }
      this._collapseState = newState;
      this.modifications.collapsibleState = newState;
      this._onDidUpdateCommentThread.fire();
    }
    get state() {
      return this._state;
    }
    set state(newState) {
      this._state = newState;
      if (typeof newState === "object") {
        checkProposedApiEnabled(this.extensionDescription, "commentThreadApplicability");
        this.modifications.state = newState.resolved;
        this.modifications.applicability = newState.applicability;
      } else {
        this.modifications.state = newState;
      }
      this._onDidUpdateCommentThread.fire();
    }
    get isDisposed() {
      return this._isDiposed;
    }
    constructor(commentControllerId, _commentControllerHandle, _id, _uri, _range, _comments, extensionDescription, _isTemplate, editorId) {
      this._commentControllerHandle = _commentControllerHandle;
      this._id = _id;
      this._uri = _uri;
      this._range = _range;
      this._comments = _comments;
      this.extensionDescription = extensionDescription;
      this._isTemplate = _isTemplate;
      this.handle = ExtHostCommentThread._handlePool++;
      this.commentHandle = 0;
      this.modifications = /* @__PURE__ */ Object.create(null);
      this._onDidUpdateCommentThread = new Emitter();
      this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event;
      this._canReply = true;
      this._commentsMap = /* @__PURE__ */ new Map();
      this._acceptInputDisposables = new MutableDisposable();
      this._acceptInputDisposables.value = new DisposableStore();
      if (this._id === void 0) {
        this._id = `${commentControllerId}.${this.handle}`;
      }
      proxy.$createCommentThread(_commentControllerHandle, this.handle, this._id, this._uri, Range4.from(this._range), this._comments.map((cmt) => convertToDTOComment(this, cmt, this._commentsMap, this.extensionDescription)), extensionDescription.identifier, this._isTemplate, editorId);
      this._localDisposables = [];
      this._isDiposed = false;
      this._localDisposables.push(this.onDidUpdateCommentThread(() => {
        this.eventuallyUpdateCommentThread();
      }));
      this._localDisposables.push({
        dispose: () => {
          proxy.$deleteCommentThread(_commentControllerHandle, this.handle);
        }
      });
      const that = this;
      this.value = {
        get uri() {
          return that.uri;
        },
        get range() {
          return that.range;
        },
        set range(value) {
          that.range = value;
        },
        get comments() {
          return that.comments;
        },
        set comments(value) {
          that.comments = value;
        },
        get collapsibleState() {
          return that.collapsibleState;
        },
        set collapsibleState(value) {
          that.collapsibleState = value;
        },
        get canReply() {
          return that.canReply;
        },
        set canReply(state) {
          that.canReply = state;
        },
        get contextValue() {
          return that.contextValue;
        },
        set contextValue(value) {
          that.contextValue = value;
        },
        get label() {
          return that.label;
        },
        set label(value) {
          that.label = value;
        },
        get state() {
          return that.state;
        },
        set state(value) {
          that.state = value;
        },
        reveal: (comment, options2) => that.reveal(comment, options2),
        hide: () => that.hide(),
        dispose: () => {
          that.dispose();
        }
      };
    }
    updateIsTemplate() {
      if (this._isTemplate) {
        this._isTemplate = false;
        this.modifications.isTemplate = false;
      }
    }
    eventuallyUpdateCommentThread() {
      if (this._isDiposed) {
        return;
      }
      this.updateIsTemplate();
      if (!this._acceptInputDisposables.value) {
        this._acceptInputDisposables.value = new DisposableStore();
      }
      const modified = (value) => Object.prototype.hasOwnProperty.call(this.modifications, value);
      const formattedModifications = {};
      if (modified("range")) {
        formattedModifications.range = Range4.from(this._range);
      }
      if (modified("label")) {
        formattedModifications.label = this.label;
      }
      if (modified("contextValue")) {
        formattedModifications.contextValue = this.contextValue ?? null;
      }
      if (modified("comments")) {
        formattedModifications.comments = this._comments.map((cmt) => convertToDTOComment(this, cmt, this._commentsMap, this.extensionDescription));
      }
      if (modified("collapsibleState")) {
        formattedModifications.collapseState = convertToCollapsibleState(this._collapseState);
      }
      if (modified("canReply")) {
        formattedModifications.canReply = this.canReply;
      }
      if (modified("state")) {
        formattedModifications.state = convertToState(this._state);
      }
      if (modified("applicability")) {
        formattedModifications.applicability = convertToRelevance(this._state);
      }
      if (modified("isTemplate")) {
        formattedModifications.isTemplate = this._isTemplate;
      }
      this.modifications = {};
      proxy.$updateCommentThread(this._commentControllerHandle, this.handle, this._id, this._uri, formattedModifications);
    }
    getCommentByUniqueId(uniqueId) {
      for (const key of this._commentsMap) {
        const comment = key[0];
        const id2 = key[1];
        if (uniqueId === id2) {
          return comment;
        }
      }
      return;
    }
    async reveal(commentOrOptions, options2) {
      checkProposedApiEnabled(this.extensionDescription, "commentReveal");
      let comment;
      if (commentOrOptions && commentOrOptions.body !== void 0) {
        comment = commentOrOptions;
      } else {
        options2 = options2 ?? commentOrOptions;
      }
      let commentToReveal = comment ? this._commentsMap.get(comment) : void 0;
      commentToReveal ??= this._commentsMap.get(this._comments[0]);
      let preserveFocus = true;
      let focusReply = false;
      if (options2?.focus === CommentThreadFocus.Reply) {
        focusReply = true;
        preserveFocus = false;
      } else if (options2?.focus === CommentThreadFocus.Comment) {
        preserveFocus = false;
      }
      return proxy.$revealCommentThread(this._commentControllerHandle, this.handle, commentToReveal, { preserveFocus, focusReply });
    }
    async hide() {
      return proxy.$hideCommentThread(this._commentControllerHandle, this.handle);
    }
    dispose() {
      this._isDiposed = true;
      this._acceptInputDisposables.dispose();
      this._localDisposables.forEach((disposable) => disposable.dispose());
    }
  }
  __decorate([
    debounce(100)
  ], ExtHostCommentThread.prototype, "eventuallyUpdateCommentThread", null);
  class ExtHostCommentController {
    get id() {
      return this._id;
    }
    get label() {
      return this._label;
    }
    get handle() {
      return this._handle;
    }
    get commentingRangeProvider() {
      return this._commentingRangeProvider;
    }
    set commentingRangeProvider(provider) {
      this._commentingRangeProvider = provider;
      if (provider?.resourceHints) {
        checkProposedApiEnabled(this._extension, "commentingRangeHint");
      }
      proxy.$updateCommentingRanges(this.handle, provider?.resourceHints);
    }
    get reactionHandler() {
      return this._reactionHandler;
    }
    set reactionHandler(handler) {
      this._reactionHandler = handler;
      proxy.$updateCommentControllerFeatures(this.handle, { reactionHandler: !!handler });
    }
    get options() {
      return this._options;
    }
    set options(options2) {
      this._options = options2;
      proxy.$updateCommentControllerFeatures(this.handle, { options: this._options });
    }
    get activeComment() {
      checkProposedApiEnabled(this._extension, "activeComment");
      return this._activeComment;
    }
    get activeCommentThread() {
      checkProposedApiEnabled(this._extension, "activeComment");
      return this._activeThread?.value;
    }
    constructor(_extension, _handle, _id, _label) {
      this._extension = _extension;
      this._handle = _handle;
      this._id = _id;
      this._label = _label;
      this._threads = /* @__PURE__ */ new Map();
      proxy.$registerCommentController(this.handle, _id, _label, this._extension.identifier.value);
      const that = this;
      this.value = Object.freeze({
        id: that.id,
        label: that.label,
        get options() {
          return that.options;
        },
        set options(options2) {
          that.options = options2;
        },
        get commentingRangeProvider() {
          return that.commentingRangeProvider;
        },
        set commentingRangeProvider(commentingRangeProvider) {
          that.commentingRangeProvider = commentingRangeProvider;
        },
        get reactionHandler() {
          return that.reactionHandler;
        },
        set reactionHandler(handler) {
          that.reactionHandler = handler;
        },
        // get activeComment(): vscode.Comment | undefined { return that.activeComment; },
        get activeCommentThread() {
          return that.activeCommentThread;
        },
        createCommentThread(uri, range, comments) {
          return that.createCommentThread(uri, range, comments).value;
        },
        dispose: () => {
          that.dispose();
        }
      });
      this._localDisposables = [];
      this._localDisposables.push({
        dispose: () => {
          proxy.$unregisterCommentController(this.handle);
        }
      });
    }
    createCommentThread(resource, range, comments) {
      const commentThread = new ExtHostCommentThread(this.id, this.handle, void 0, resource, range, comments, this._extension, false);
      this._threads.set(commentThread.handle, commentThread);
      return commentThread;
    }
    $setActiveComment(commentInfo) {
      if (!commentInfo) {
        this._activeComment = void 0;
        this._activeThread = void 0;
        return;
      }
      const thread = this._threads.get(commentInfo.commentThreadHandle);
      if (thread) {
        this._activeComment = commentInfo.uniqueIdInThread ? thread.getCommentByUniqueId(commentInfo.uniqueIdInThread) : void 0;
        this._activeThread = thread;
      }
    }
    $createCommentThreadTemplate(uriComponents, range, editorId) {
      const commentThread = new ExtHostCommentThread(this.id, this.handle, void 0, URI.revive(uriComponents), Range4.to(range), [], this._extension, true, editorId);
      commentThread.collapsibleState = CommentThreadCollapsibleState.Expanded;
      this._threads.set(commentThread.handle, commentThread);
      return commentThread;
    }
    $updateCommentThreadTemplate(threadHandle, range) {
      const thread = this._threads.get(threadHandle);
      if (thread) {
        thread.range = Range4.to(range);
      }
    }
    $updateCommentThread(threadHandle, changes) {
      const thread = this._threads.get(threadHandle);
      if (!thread) {
        return;
      }
      const modified = (value) => Object.prototype.hasOwnProperty.call(changes, value);
      if (modified("collapseState")) {
        thread.collapsibleState = convertToCollapsibleState(changes.collapseState);
      }
    }
    $deleteCommentThread(threadHandle) {
      const thread = this._threads.get(threadHandle);
      thread?.dispose();
      this._threads.delete(threadHandle);
    }
    getCommentThread(handle) {
      return this._threads.get(handle);
    }
    dispose() {
      this._threads.forEach((value) => {
        value.dispose();
      });
      this._localDisposables.forEach((disposable) => disposable.dispose());
    }
  }
  function convertToDTOComment(thread, vscodeComment, commentsMap, extension) {
    let commentUniqueId = commentsMap.get(vscodeComment);
    if (!commentUniqueId) {
      commentUniqueId = ++thread.commentHandle;
      commentsMap.set(vscodeComment, commentUniqueId);
    }
    if (vscodeComment.state !== void 0) {
      checkProposedApiEnabled(extension, "commentsDraftState");
    }
    if (vscodeComment.reactions?.some((reaction) => reaction.reactors !== void 0)) {
      checkProposedApiEnabled(extension, "commentReactor");
    }
    return {
      mode: vscodeComment.mode,
      contextValue: vscodeComment.contextValue,
      uniqueIdInThread: commentUniqueId,
      body: typeof vscodeComment.body === "string" ? vscodeComment.body : MarkdownString4.from(vscodeComment.body),
      userName: vscodeComment.author.name,
      userIconPath: vscodeComment.author.iconPath,
      label: vscodeComment.label,
      commentReactions: vscodeComment.reactions ? vscodeComment.reactions.map((reaction) => convertToReaction(reaction)) : void 0,
      state: vscodeComment.state,
      timestamp: vscodeComment.timestamp?.toJSON()
    };
  }
  function convertToReaction(reaction) {
    return {
      label: reaction.label,
      iconPath: reaction.iconPath ? pathOrURIToURI(reaction.iconPath) : void 0,
      count: reaction.count,
      hasReacted: reaction.authorHasReacted,
      reactors: reaction.reactors && reaction.reactors.length > 0 && typeof reaction.reactors[0] !== "string" ? reaction.reactors.map((reactor) => reactor.name) : reaction.reactors
    };
  }
  function convertFromReaction(reaction) {
    return {
      label: reaction.label || "",
      count: reaction.count || 0,
      iconPath: reaction.iconPath ? URI.revive(reaction.iconPath) : "",
      authorHasReacted: reaction.hasReacted || false,
      reactors: reaction.reactors?.map((reactor) => ({ name: reactor }))
    };
  }
  function convertToCollapsibleState(kind) {
    if (kind !== void 0) {
      switch (kind) {
        case CommentThreadCollapsibleState2.Expanded:
          return CommentThreadCollapsibleState.Expanded;
        case CommentThreadCollapsibleState2.Collapsed:
          return CommentThreadCollapsibleState.Collapsed;
      }
    }
    return CommentThreadCollapsibleState.Collapsed;
  }
  function convertToState(kind) {
    let resolvedKind;
    if (typeof kind === "object") {
      resolvedKind = kind.resolved;
    } else {
      resolvedKind = kind;
    }
    if (resolvedKind !== void 0) {
      switch (resolvedKind) {
        case CommentThreadState2.Unresolved:
          return CommentThreadState.Unresolved;
        case CommentThreadState2.Resolved:
          return CommentThreadState.Resolved;
      }
    }
    return CommentThreadState.Unresolved;
  }
  function convertToRelevance(kind) {
    let applicabilityKind = void 0;
    if (typeof kind === "object") {
      applicabilityKind = kind.applicability;
    }
    if (applicabilityKind !== void 0) {
      switch (applicabilityKind) {
        case CommentThreadApplicability2.Current:
          return CommentThreadApplicability.Current;
        case CommentThreadApplicability2.Outdated:
          return CommentThreadApplicability.Outdated;
      }
    }
    return CommentThreadApplicability.Current;
  }
  return new ExtHostCommentsImpl();
}

// out-build/vs/base/common/semver/semver.js
var exports = {};
var module = { exports };
!function(e, r) {
  if ("object" == typeof exports && "object" == typeof module) module.exports = r();
  else if ("function" == typeof define && define.amd) define([], r);
  else {
    var t = r();
    for (var n in t) ("object" == typeof exports ? exports : e)[n] = t[n];
  }
}("undefined" != typeof self ? self : void 0, function() {
  return function(e) {
    var r = {};
    function t(n) {
      if (r[n]) return r[n].exports;
      var o = r[n] = { i: n, l: false, exports: {} };
      return e[n].call(o.exports, o, o.exports, t), o.l = true, o.exports;
    }
    return t.m = e, t.c = r, t.d = function(e2, r2, n) {
      t.o(e2, r2) || Object.defineProperty(e2, r2, { enumerable: true, get: n });
    }, t.r = function(e2) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
    }, t.t = function(e2, r2) {
      if (1 & r2 && (e2 = t(e2)), 8 & r2) return e2;
      if (4 & r2 && "object" == typeof e2 && e2 && e2.__esModule) return e2;
      var n = /* @__PURE__ */ Object.create(null);
      if (t.r(n), Object.defineProperty(n, "default", { enumerable: true, value: e2 }), 2 & r2 && "string" != typeof e2) for (var o in e2) t.d(n, o, function(r3) {
        return e2[r3];
      }.bind(null, o));
      return n;
    }, t.n = function(e2) {
      var r2 = e2 && e2.__esModule ? function() {
        return e2.default;
      } : function() {
        return e2;
      };
      return t.d(r2, "a", r2), r2;
    }, t.o = function(e2, r2) {
      return Object.prototype.hasOwnProperty.call(e2, r2);
    }, t.p = "", t(t.s = 0);
  }([function(e, r, t) {
    (function(t2) {
      var n;
      r = e.exports = H, n = "object" == typeof t2 && t2.env && t2.env.NODE_DEBUG && /\bsemver\b/i.test(t2.env.NODE_DEBUG) ? function() {
        var e2 = Array.prototype.slice.call(arguments, 0);
        e2.unshift("SEMVER"), console.log.apply(console, e2);
      } : function() {
      }, r.SEMVER_SPEC_VERSION = "2.0.0";
      var o = 256, i = Number.MAX_SAFE_INTEGER || 9007199254740991, s = r.re = [], a = r.src = [], u = 0, c = u++;
      a[c] = "0|[1-9]\\d*";
      var p = u++;
      a[p] = "[0-9]+";
      var f = u++;
      a[f] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
      var l = u++;
      a[l] = "(" + a[c] + ")\\.(" + a[c] + ")\\.(" + a[c] + ")";
      var h = u++;
      a[h] = "(" + a[p] + ")\\.(" + a[p] + ")\\.(" + a[p] + ")";
      var v = u++;
      a[v] = "(?:" + a[c] + "|" + a[f] + ")";
      var m = u++;
      a[m] = "(?:" + a[p] + "|" + a[f] + ")";
      var w = u++;
      a[w] = "(?:-(" + a[v] + "(?:\\." + a[v] + ")*))";
      var g = u++;
      a[g] = "(?:-?(" + a[m] + "(?:\\." + a[m] + ")*))";
      var y = u++;
      a[y] = "[0-9A-Za-z-]+";
      var d = u++;
      a[d] = "(?:\\+(" + a[y] + "(?:\\." + a[y] + ")*))";
      var b = u++, j = "v?" + a[l] + a[w] + "?" + a[d] + "?";
      a[b] = "^" + j + "$";
      var E = "[v=\\s]*" + a[h] + a[g] + "?" + a[d] + "?", T = u++;
      a[T] = "^" + E + "$";
      var x = u++;
      a[x] = "((?:<|>)?=?)";
      var $ = u++;
      a[$] = a[p] + "|x|X|\\*";
      var k = u++;
      a[k] = a[c] + "|x|X|\\*";
      var S = u++;
      a[S] = "[v=\\s]*(" + a[k] + ")(?:\\.(" + a[k] + ")(?:\\.(" + a[k] + ")(?:" + a[w] + ")?" + a[d] + "?)?)?";
      var R = u++;
      a[R] = "[v=\\s]*(" + a[$] + ")(?:\\.(" + a[$] + ")(?:\\.(" + a[$] + ")(?:" + a[g] + ")?" + a[d] + "?)?)?";
      var I = u++;
      a[I] = "^" + a[x] + "\\s*" + a[S] + "$";
      var _ = u++;
      a[_] = "^" + a[x] + "\\s*" + a[R] + "$";
      var O = u++;
      a[O] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
      var A = u++;
      a[A] = "(?:~>?)";
      var M = u++;
      a[M] = "(\\s*)" + a[A] + "\\s+", s[M] = new RegExp(a[M], "g");
      var V = u++;
      a[V] = "^" + a[A] + a[S] + "$";
      var P = u++;
      a[P] = "^" + a[A] + a[R] + "$";
      var C = u++;
      a[C] = "(?:\\^)";
      var L = u++;
      a[L] = "(\\s*)" + a[C] + "\\s+", s[L] = new RegExp(a[L], "g");
      var N = u++;
      a[N] = "^" + a[C] + a[S] + "$";
      var q = u++;
      a[q] = "^" + a[C] + a[R] + "$";
      var D = u++;
      a[D] = "^" + a[x] + "\\s*(" + E + ")$|^$";
      var X = u++;
      a[X] = "^" + a[x] + "\\s*(" + j + ")$|^$";
      var z = u++;
      a[z] = "(\\s*)" + a[x] + "\\s*(" + E + "|" + a[S] + ")", s[z] = new RegExp(a[z], "g");
      var G = u++;
      a[G] = "^\\s*(" + a[S] + ")\\s+-\\s+(" + a[S] + ")\\s*$";
      var Z = u++;
      a[Z] = "^\\s*(" + a[R] + ")\\s+-\\s+(" + a[R] + ")\\s*$";
      var B = u++;
      a[B] = "(<|>)?=?\\s*\\*";
      for (var U = 0; U < 35; U++) n(U, a[U]), s[U] || (s[U] = new RegExp(a[U]));
      function F(e2, r2) {
        if (e2 instanceof H) return e2;
        if ("string" != typeof e2) return null;
        if (e2.length > o) return null;
        if (!(r2 ? s[T] : s[b]).test(e2)) return null;
        try {
          return new H(e2, r2);
        } catch (e3) {
          return null;
        }
      }
      function H(e2, r2) {
        if (e2 instanceof H) {
          if (e2.loose === r2) return e2;
          e2 = e2.version;
        } else if ("string" != typeof e2) throw new TypeError("Invalid Version: " + e2);
        if (e2.length > o) throw new TypeError("version is longer than " + o + " characters");
        if (!(this instanceof H)) return new H(e2, r2);
        n("SemVer", e2, r2), this.loose = r2;
        var t3 = e2.trim().match(r2 ? s[T] : s[b]);
        if (!t3) throw new TypeError("Invalid Version: " + e2);
        if (this.raw = e2, this.major = +t3[1], this.minor = +t3[2], this.patch = +t3[3], this.major > i || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > i || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > i || this.patch < 0) throw new TypeError("Invalid patch version");
        t3[4] ? this.prerelease = t3[4].split(".").map(function(e3) {
          if (/^[0-9]+$/.test(e3)) {
            var r3 = +e3;
            if (r3 >= 0 && r3 < i) return r3;
          }
          return e3;
        }) : this.prerelease = [], this.build = t3[5] ? t3[5].split(".") : [], this.format();
      }
      r.parse = F, r.valid = function(e2, r2) {
        var t3 = F(e2, r2);
        return t3 ? t3.version : null;
      }, r.clean = function(e2, r2) {
        var t3 = F(e2.trim().replace(/^[=v]+/, ""), r2);
        return t3 ? t3.version : null;
      }, r.SemVer = H, H.prototype.format = function() {
        return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
      }, H.prototype.toString = function() {
        return this.version;
      }, H.prototype.compare = function(e2) {
        return n("SemVer.compare", this.version, this.loose, e2), e2 instanceof H || (e2 = new H(e2, this.loose)), this.compareMain(e2) || this.comparePre(e2);
      }, H.prototype.compareMain = function(e2) {
        return e2 instanceof H || (e2 = new H(e2, this.loose)), K(this.major, e2.major) || K(this.minor, e2.minor) || K(this.patch, e2.patch);
      }, H.prototype.comparePre = function(e2) {
        if (e2 instanceof H || (e2 = new H(e2, this.loose)), this.prerelease.length && !e2.prerelease.length) return -1;
        if (!this.prerelease.length && e2.prerelease.length) return 1;
        if (!this.prerelease.length && !e2.prerelease.length) return 0;
        var r2 = 0;
        do {
          var t3 = this.prerelease[r2], o2 = e2.prerelease[r2];
          if (n("prerelease compare", r2, t3, o2), void 0 === t3 && void 0 === o2) return 0;
          if (void 0 === o2) return 1;
          if (void 0 === t3) return -1;
          if (t3 !== o2) return K(t3, o2);
        } while (++r2);
      }, H.prototype.inc = function(e2, r2) {
        switch (e2) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r2);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r2);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", r2), this.inc("pre", r2);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", r2), this.inc("pre", r2);
            break;
          case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (0 === this.prerelease.length) this.prerelease = [0];
            else {
              for (var t3 = this.prerelease.length; --t3 >= 0; ) "number" == typeof this.prerelease[t3] && (this.prerelease[t3]++, t3 = -2);
              -1 === t3 && this.prerelease.push(0);
            }
            r2 && (this.prerelease[0] === r2 ? isNaN(this.prerelease[1]) && (this.prerelease = [r2, 0]) : this.prerelease = [r2, 0]);
            break;
          default:
            throw new Error("invalid increment argument: " + e2);
        }
        return this.format(), this.raw = this.version, this;
      }, r.inc = function(e2, r2, t3, n2) {
        "string" == typeof t3 && (n2 = t3, t3 = void 0);
        try {
          return new H(e2, t3).inc(r2, n2).version;
        } catch (e3) {
          return null;
        }
      }, r.diff = function(e2, r2) {
        if (ee(e2, r2)) return null;
        var t3 = F(e2), n2 = F(r2);
        if (t3.prerelease.length || n2.prerelease.length) {
          for (var o2 in t3) if (("major" === o2 || "minor" === o2 || "patch" === o2) && t3[o2] !== n2[o2]) return "pre" + o2;
          return "prerelease";
        }
        for (var o2 in t3) if (("major" === o2 || "minor" === o2 || "patch" === o2) && t3[o2] !== n2[o2]) return o2;
      }, r.compareIdentifiers = K;
      var J = /^[0-9]+$/;
      function K(e2, r2) {
        var t3 = J.test(e2), n2 = J.test(r2);
        return t3 && n2 && (e2 = +e2, r2 = +r2), t3 && !n2 ? -1 : n2 && !t3 ? 1 : e2 < r2 ? -1 : e2 > r2 ? 1 : 0;
      }
      function Q(e2, r2, t3) {
        return new H(e2, t3).compare(new H(r2, t3));
      }
      function W(e2, r2, t3) {
        return Q(e2, r2, t3) > 0;
      }
      function Y(e2, r2, t3) {
        return Q(e2, r2, t3) < 0;
      }
      function ee(e2, r2, t3) {
        return 0 === Q(e2, r2, t3);
      }
      function re(e2, r2, t3) {
        return 0 !== Q(e2, r2, t3);
      }
      function te(e2, r2, t3) {
        return Q(e2, r2, t3) >= 0;
      }
      function ne(e2, r2, t3) {
        return Q(e2, r2, t3) <= 0;
      }
      function oe(e2, r2, t3, n2) {
        var o2;
        switch (r2) {
          case "===":
            "object" == typeof e2 && (e2 = e2.version), "object" == typeof t3 && (t3 = t3.version), o2 = e2 === t3;
            break;
          case "!==":
            "object" == typeof e2 && (e2 = e2.version), "object" == typeof t3 && (t3 = t3.version), o2 = e2 !== t3;
            break;
          case "":
          case "=":
          case "==":
            o2 = ee(e2, t3, n2);
            break;
          case "!=":
            o2 = re(e2, t3, n2);
            break;
          case ">":
            o2 = W(e2, t3, n2);
            break;
          case ">=":
            o2 = te(e2, t3, n2);
            break;
          case "<":
            o2 = Y(e2, t3, n2);
            break;
          case "<=":
            o2 = ne(e2, t3, n2);
            break;
          default:
            throw new TypeError("Invalid operator: " + r2);
        }
        return o2;
      }
      function ie(e2, r2) {
        if (e2 instanceof ie) {
          if (e2.loose === r2) return e2;
          e2 = e2.value;
        }
        if (!(this instanceof ie)) return new ie(e2, r2);
        n("comparator", e2, r2), this.loose = r2, this.parse(e2), this.semver === se ? this.value = "" : this.value = this.operator + this.semver.version, n("comp", this);
      }
      r.rcompareIdentifiers = function(e2, r2) {
        return K(r2, e2);
      }, r.major = function(e2, r2) {
        return new H(e2, r2).major;
      }, r.minor = function(e2, r2) {
        return new H(e2, r2).minor;
      }, r.patch = function(e2, r2) {
        return new H(e2, r2).patch;
      }, r.compare = Q, r.compareLoose = function(e2, r2) {
        return Q(e2, r2, true);
      }, r.rcompare = function(e2, r2, t3) {
        return Q(r2, e2, t3);
      }, r.sort = function(e2, t3) {
        return e2.sort(function(e3, n2) {
          return r.compare(e3, n2, t3);
        });
      }, r.rsort = function(e2, t3) {
        return e2.sort(function(e3, n2) {
          return r.rcompare(e3, n2, t3);
        });
      }, r.gt = W, r.lt = Y, r.eq = ee, r.neq = re, r.gte = te, r.lte = ne, r.cmp = oe, r.Comparator = ie;
      var se = {};
      function ae(e2, r2) {
        if (e2 instanceof ae) return e2.loose === r2 ? e2 : new ae(e2.raw, r2);
        if (e2 instanceof ie) return new ae(e2.value, r2);
        if (!(this instanceof ae)) return new ae(e2, r2);
        if (this.loose = r2, this.raw = e2, this.set = e2.split(/\s*\|\|\s*/).map(function(e3) {
          return this.parseRange(e3.trim());
        }, this).filter(function(e3) {
          return e3.length;
        }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e2);
        this.format();
      }
      function ue(e2) {
        return !e2 || "x" === e2.toLowerCase() || "*" === e2;
      }
      function ce(e2, r2, t3, n2, o2, i2, s2, a2, u2, c2, p2, f2, l2) {
        return ((r2 = ue(t3) ? "" : ue(n2) ? ">=" + t3 + ".0.0" : ue(o2) ? ">=" + t3 + "." + n2 + ".0" : ">=" + r2) + " " + (a2 = ue(u2) ? "" : ue(c2) ? "<" + (+u2 + 1) + ".0.0" : ue(p2) ? "<" + u2 + "." + (+c2 + 1) + ".0" : f2 ? "<=" + u2 + "." + c2 + "." + p2 + "-" + f2 : "<=" + a2)).trim();
      }
      function pe(e2, r2) {
        for (var t3 = 0; t3 < e2.length; t3++) if (!e2[t3].test(r2)) return false;
        if (r2.prerelease.length) {
          for (t3 = 0; t3 < e2.length; t3++) if (n(e2[t3].semver), e2[t3].semver !== se && e2[t3].semver.prerelease.length > 0) {
            var o2 = e2[t3].semver;
            if (o2.major === r2.major && o2.minor === r2.minor && o2.patch === r2.patch) return true;
          }
          return false;
        }
        return true;
      }
      function fe(e2, r2, t3) {
        try {
          r2 = new ae(r2, t3);
        } catch (e3) {
          return false;
        }
        return r2.test(e2);
      }
      function le(e2, r2, t3, n2) {
        var o2, i2, s2, a2, u2;
        switch (e2 = new H(e2, n2), r2 = new ae(r2, n2), t3) {
          case ">":
            o2 = W, i2 = ne, s2 = Y, a2 = ">", u2 = ">=";
            break;
          case "<":
            o2 = Y, i2 = te, s2 = W, a2 = "<", u2 = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (fe(e2, r2, n2)) return false;
        for (var c2 = 0; c2 < r2.set.length; ++c2) {
          var p2 = r2.set[c2], f2 = null, l2 = null;
          if (p2.forEach(function(e3) {
            e3.semver === se && (e3 = new ie(">=0.0.0")), f2 = f2 || e3, l2 = l2 || e3, o2(e3.semver, f2.semver, n2) ? f2 = e3 : s2(e3.semver, l2.semver, n2) && (l2 = e3);
          }), f2.operator === a2 || f2.operator === u2) return false;
          if ((!l2.operator || l2.operator === a2) && i2(e2, l2.semver)) return false;
          if (l2.operator === u2 && s2(e2, l2.semver)) return false;
        }
        return true;
      }
      ie.prototype.parse = function(e2) {
        var r2 = this.loose ? s[D] : s[X], t3 = e2.match(r2);
        if (!t3) throw new TypeError("Invalid comparator: " + e2);
        this.operator = t3[1], "=" === this.operator && (this.operator = ""), t3[2] ? this.semver = new H(t3[2], this.loose) : this.semver = se;
      }, ie.prototype.toString = function() {
        return this.value;
      }, ie.prototype.test = function(e2) {
        return n("Comparator.test", e2, this.loose), this.semver === se || ("string" == typeof e2 && (e2 = new H(e2, this.loose)), oe(e2, this.operator, this.semver, this.loose));
      }, ie.prototype.intersects = function(e2, r2) {
        if (!(e2 instanceof ie)) throw new TypeError("a Comparator is required");
        var t3;
        if ("" === this.operator) return t3 = new ae(e2.value, r2), fe(this.value, t3, r2);
        if ("" === e2.operator) return t3 = new ae(this.value, r2), fe(e2.semver, t3, r2);
        var n2 = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e2.operator && ">" !== e2.operator), o2 = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e2.operator && "<" !== e2.operator), i2 = this.semver.version === e2.semver.version, s2 = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e2.operator && "<=" !== e2.operator), a2 = oe(this.semver, "<", e2.semver, r2) && (">=" === this.operator || ">" === this.operator) && ("<=" === e2.operator || "<" === e2.operator), u2 = oe(this.semver, ">", e2.semver, r2) && ("<=" === this.operator || "<" === this.operator) && (">=" === e2.operator || ">" === e2.operator);
        return n2 || o2 || i2 && s2 || a2 || u2;
      }, r.Range = ae, ae.prototype.format = function() {
        return this.range = this.set.map(function(e2) {
          return e2.join(" ").trim();
        }).join("||").trim(), this.range;
      }, ae.prototype.toString = function() {
        return this.range;
      }, ae.prototype.parseRange = function(e2) {
        var r2 = this.loose;
        e2 = e2.trim(), n("range", e2, r2);
        var t3 = r2 ? s[Z] : s[G];
        e2 = e2.replace(t3, ce), n("hyphen replace", e2), e2 = e2.replace(s[z], "$1$2$3"), n("comparator trim", e2, s[z]), e2 = (e2 = (e2 = e2.replace(s[M], "$1~")).replace(s[L], "$1^")).split(/\s+/).join(" ");
        var o2 = r2 ? s[D] : s[X], i2 = e2.split(" ").map(function(e3) {
          return function(e4, r3) {
            return n("comp", e4), e4 = function(e5, r4) {
              return e5.trim().split(/\s+/).map(function(e6) {
                return function(e7, r5) {
                  n("caret", e7, r5);
                  var t4 = r5 ? s[q] : s[N];
                  return e7.replace(t4, function(r6, t5, o3, i3, s2) {
                    var a2;
                    return n("caret", e7, r6, t5, o3, i3, s2), ue(t5) ? a2 = "" : ue(o3) ? a2 = ">=" + t5 + ".0.0 <" + (+t5 + 1) + ".0.0" : ue(i3) ? a2 = "0" === t5 ? ">=" + t5 + "." + o3 + ".0 <" + t5 + "." + (+o3 + 1) + ".0" : ">=" + t5 + "." + o3 + ".0 <" + (+t5 + 1) + ".0.0" : s2 ? (n("replaceCaret pr", s2), "-" !== s2.charAt(0) && (s2 = "-" + s2), a2 = "0" === t5 ? "0" === o3 ? ">=" + t5 + "." + o3 + "." + i3 + s2 + " <" + t5 + "." + o3 + "." + (+i3 + 1) : ">=" + t5 + "." + o3 + "." + i3 + s2 + " <" + t5 + "." + (+o3 + 1) + ".0" : ">=" + t5 + "." + o3 + "." + i3 + s2 + " <" + (+t5 + 1) + ".0.0") : (n("no pr"), a2 = "0" === t5 ? "0" === o3 ? ">=" + t5 + "." + o3 + "." + i3 + " <" + t5 + "." + o3 + "." + (+i3 + 1) : ">=" + t5 + "." + o3 + "." + i3 + " <" + t5 + "." + (+o3 + 1) + ".0" : ">=" + t5 + "." + o3 + "." + i3 + " <" + (+t5 + 1) + ".0.0"), n("caret return", a2), a2;
                  });
                }(e6, r4);
              }).join(" ");
            }(e4, r3), n("caret", e4), e4 = function(e5, r4) {
              return e5.trim().split(/\s+/).map(function(e6) {
                return function(e7, r5) {
                  var t4 = r5 ? s[P] : s[V];
                  return e7.replace(t4, function(r6, t5, o3, i3, s2) {
                    var a2;
                    return n("tilde", e7, r6, t5, o3, i3, s2), ue(t5) ? a2 = "" : ue(o3) ? a2 = ">=" + t5 + ".0.0 <" + (+t5 + 1) + ".0.0" : ue(i3) ? a2 = ">=" + t5 + "." + o3 + ".0 <" + t5 + "." + (+o3 + 1) + ".0" : s2 ? (n("replaceTilde pr", s2), "-" !== s2.charAt(0) && (s2 = "-" + s2), a2 = ">=" + t5 + "." + o3 + "." + i3 + s2 + " <" + t5 + "." + (+o3 + 1) + ".0") : a2 = ">=" + t5 + "." + o3 + "." + i3 + " <" + t5 + "." + (+o3 + 1) + ".0", n("tilde return", a2), a2;
                  });
                }(e6, r4);
              }).join(" ");
            }(e4, r3), n("tildes", e4), e4 = function(e5, r4) {
              return n("replaceXRanges", e5, r4), e5.split(/\s+/).map(function(e6) {
                return function(e7, r5) {
                  e7 = e7.trim();
                  var t4 = r5 ? s[_] : s[I];
                  return e7.replace(t4, function(r6, t5, o3, i3, s2, a2) {
                    n("xRange", e7, r6, t5, o3, i3, s2, a2);
                    var u2 = ue(o3), c2 = u2 || ue(i3), p2 = c2 || ue(s2);
                    return "=" === t5 && p2 && (t5 = ""), u2 ? r6 = ">" === t5 || "<" === t5 ? "<0.0.0" : "*" : t5 && p2 ? (c2 && (i3 = 0), p2 && (s2 = 0), ">" === t5 ? (t5 = ">=", c2 ? (o3 = +o3 + 1, i3 = 0, s2 = 0) : p2 && (i3 = +i3 + 1, s2 = 0)) : "<=" === t5 && (t5 = "<", c2 ? o3 = +o3 + 1 : i3 = +i3 + 1), r6 = t5 + o3 + "." + i3 + "." + s2) : c2 ? r6 = ">=" + o3 + ".0.0 <" + (+o3 + 1) + ".0.0" : p2 && (r6 = ">=" + o3 + "." + i3 + ".0 <" + o3 + "." + (+i3 + 1) + ".0"), n("xRange return", r6), r6;
                  });
                }(e6, r4);
              }).join(" ");
            }(e4, r3), n("xrange", e4), e4 = function(e5, r4) {
              return n("replaceStars", e5, r4), e5.trim().replace(s[B], "");
            }(e4, r3), n("stars", e4), e4;
          }(e3, r2);
        }).join(" ").split(/\s+/);
        return this.loose && (i2 = i2.filter(function(e3) {
          return !!e3.match(o2);
        })), i2 = i2.map(function(e3) {
          return new ie(e3, r2);
        });
      }, ae.prototype.intersects = function(e2, r2) {
        if (!(e2 instanceof ae)) throw new TypeError("a Range is required");
        return this.set.some(function(t3) {
          return t3.every(function(t4) {
            return e2.set.some(function(e3) {
              return e3.every(function(e4) {
                return t4.intersects(e4, r2);
              });
            });
          });
        });
      }, r.toComparators = function(e2, r2) {
        return new ae(e2, r2).set.map(function(e3) {
          return e3.map(function(e4) {
            return e4.value;
          }).join(" ").trim().split(" ");
        });
      }, ae.prototype.test = function(e2) {
        if (!e2) return false;
        "string" == typeof e2 && (e2 = new H(e2, this.loose));
        for (var r2 = 0; r2 < this.set.length; r2++) if (pe(this.set[r2], e2)) return true;
        return false;
      }, r.satisfies = fe, r.maxSatisfying = function(e2, r2, t3) {
        var n2 = null, o2 = null;
        try {
          var i2 = new ae(r2, t3);
        } catch (e3) {
          return null;
        }
        return e2.forEach(function(e3) {
          i2.test(e3) && (n2 && -1 !== o2.compare(e3) || (o2 = new H(n2 = e3, t3)));
        }), n2;
      }, r.minSatisfying = function(e2, r2, t3) {
        var n2 = null, o2 = null;
        try {
          var i2 = new ae(r2, t3);
        } catch (e3) {
          return null;
        }
        return e2.forEach(function(e3) {
          i2.test(e3) && (n2 && 1 !== o2.compare(e3) || (o2 = new H(n2 = e3, t3)));
        }), n2;
      }, r.validRange = function(e2, r2) {
        try {
          return new ae(e2, r2).range || "*";
        } catch (e3) {
          return null;
        }
      }, r.ltr = function(e2, r2, t3) {
        return le(e2, r2, "<", t3);
      }, r.gtr = function(e2, r2, t3) {
        return le(e2, r2, ">", t3);
      }, r.outside = le, r.prerelease = function(e2, r2) {
        var t3 = F(e2, r2);
        return t3 && t3.prerelease.length ? t3.prerelease : null;
      }, r.intersects = function(e2, r2, t3) {
        return e2 = new ae(e2, t3), r2 = new ae(r2, t3), e2.intersects(r2);
      }, r.coerce = function(e2) {
        if (e2 instanceof H) return e2;
        if ("string" != typeof e2) return null;
        var r2 = e2.match(s[O]);
        return null == r2 ? null : F((r2[1] || "0") + "." + (r2[2] || "0") + "." + (r2[3] || "0"));
      };
    }).call(this, t(1));
  }, function(e, r) {
    var t, n, o = e.exports = {};
    function i() {
      throw new Error("setTimeout has not been defined");
    }
    function s() {
      throw new Error("clearTimeout has not been defined");
    }
    function a(e2) {
      if (t === setTimeout) return setTimeout(e2, 0);
      if ((t === i || !t) && setTimeout) return t = setTimeout, setTimeout(e2, 0);
      try {
        return t(e2, 0);
      } catch (r2) {
        try {
          return t.call(null, e2, 0);
        } catch (r3) {
          return t.call(this, e2, 0);
        }
      }
    }
    !function() {
      try {
        t = "function" == typeof setTimeout ? setTimeout : i;
      } catch (e2) {
        t = i;
      }
      try {
        n = "function" == typeof clearTimeout ? clearTimeout : s;
      } catch (e2) {
        n = s;
      }
    }();
    var u, c = [], p = false, f = -1;
    function l() {
      p && u && (p = false, u.length ? c = u.concat(c) : f = -1, c.length && h());
    }
    function h() {
      if (!p) {
        var e2 = a(l);
        p = true;
        for (var r2 = c.length; r2; ) {
          for (u = c, c = []; ++f < r2; ) u && u[f].run();
          f = -1, r2 = c.length;
        }
        u = null, p = false, function(e3) {
          if (n === clearTimeout) return clearTimeout(e3);
          if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e3);
          try {
            n(e3);
          } catch (r3) {
            try {
              return n.call(null, e3);
            } catch (r4) {
              return n.call(this, e3);
            }
          }
        }(e2);
      }
    }
    function v(e2, r2) {
      this.fun = e2, this.array = r2;
    }
    function m() {
    }
    o.nextTick = function(e2) {
      var r2 = new Array(arguments.length - 1);
      if (arguments.length > 1) for (var t2 = 1; t2 < arguments.length; t2++) r2[t2 - 1] = arguments[t2];
      c.push(new v(e2, r2)), 1 !== c.length || p || a(h);
    }, v.prototype.run = function() {
      this.fun.apply(null, this.array);
    }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = m, o.addListener = m, o.once = m, o.off = m, o.removeListener = m, o.removeAllListeners = m, o.emit = m, o.prependListener = m, o.prependOnceListener = m, o.listeners = function(e2) {
      return [];
    }, o.binding = function(e2) {
      throw new Error("process.binding is not supported");
    }, o.cwd = function() {
      return "/";
    }, o.chdir = function(e2) {
      throw new Error("process.chdir is not supported");
    }, o.umask = function() {
      return 0;
    };
  }]);
});
var SEMVER_SPEC_VERSION = module.exports.SEMVER_SPEC_VERSION;
var parse5 = module.exports.parse;
var valid = module.exports.valid;
var coerce = module.exports.coerce;
var clean = module.exports.clean;
var inc = module.exports.inc;
var major = module.exports.major;
var minor = module.exports.minor;
var patch = module.exports.patch;
var prerelease = module.exports.prerelease;
var gt = module.exports.gt;
var gte = module.exports.gte;
var lt = module.exports.lt;
var lte = module.exports.lte;
var eq = module.exports.eq;
var neq = module.exports.neq;
var cmp3 = module.exports.cmp;
var compare3 = module.exports.compare;
var rcompare = module.exports.rcompare;
var compareIdentifiers = module.exports.compareIdentifiers;
var rcompareIdentifiers = module.exports.rcompareIdentifiers;
var compareBuild = module.exports.compareBuild;
var sort = module.exports.sort;
var rsort = module.exports.rsort;
var diff = module.exports.diff;
var validRange = module.exports.validRange;
var satisfies = module.exports.satisfies;
var maxSatisfying = module.exports.maxSatisfying;
var minSatisfying = module.exports.minSatisfying;
var minVersion = module.exports.minVersion;
var gtr = module.exports.gtr;
var ltr = module.exports.ltr;
var outside = module.exports.outside;
var intersects = module.exports.intersects;
var SemVer = module.exports.SemVer;
var Comparator = module.exports.Comparator;
var Range5 = module.exports.Range;

// out-build/vs/platform/extensions/common/extensionValidator.js
var VERSION_REGEXP = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/;
var NOT_BEFORE_REGEXP = /^-(\d{4})(\d{2})(\d{2})$/;
function isValidVersionStr(version) {
  version = version.trim();
  return version === "*" || VERSION_REGEXP.test(version);
}
function parseVersion(version) {
  if (!isValidVersionStr(version)) {
    return null;
  }
  version = version.trim();
  if (version === "*") {
    return {
      hasCaret: false,
      hasGreaterEquals: false,
      majorBase: 0,
      majorMustEqual: false,
      minorBase: 0,
      minorMustEqual: false,
      patchBase: 0,
      patchMustEqual: false,
      preRelease: null
    };
  }
  const m = version.match(VERSION_REGEXP);
  if (!m) {
    return null;
  }
  return {
    hasCaret: m[1] === "^",
    hasGreaterEquals: m[1] === ">=",
    majorBase: m[2] === "x" ? 0 : parseInt(m[2], 10),
    majorMustEqual: m[2] === "x" ? false : true,
    minorBase: m[4] === "x" ? 0 : parseInt(m[4], 10),
    minorMustEqual: m[4] === "x" ? false : true,
    patchBase: m[6] === "x" ? 0 : parseInt(m[6], 10),
    patchMustEqual: m[6] === "x" ? false : true,
    preRelease: m[8] || null
  };
}
function normalizeVersion(version) {
  if (!version) {
    return null;
  }
  const majorBase = version.majorBase;
  const majorMustEqual = version.majorMustEqual;
  const minorBase = version.minorBase;
  let minorMustEqual = version.minorMustEqual;
  const patchBase = version.patchBase;
  let patchMustEqual = version.patchMustEqual;
  if (version.hasCaret) {
    if (majorBase === 0) {
      patchMustEqual = false;
    } else {
      minorMustEqual = false;
      patchMustEqual = false;
    }
  }
  let notBefore = 0;
  if (version.preRelease) {
    const match2 = NOT_BEFORE_REGEXP.exec(version.preRelease);
    if (match2) {
      const [, year2, month2, day2] = match2;
      notBefore = Date.UTC(Number(year2), Number(month2) - 1, Number(day2));
    }
  }
  return {
    majorBase,
    majorMustEqual,
    minorBase,
    minorMustEqual,
    patchBase,
    patchMustEqual,
    isMinimum: version.hasGreaterEquals,
    notBefore
  };
}

// out-build/vs/workbench/api/common/extHostWebviewMessaging.js
var ArrayBufferSet = class {
  constructor() {
    this.buffers = [];
  }
  add(buffer) {
    let index = this.buffers.indexOf(buffer);
    if (index < 0) {
      index = this.buffers.length;
      this.buffers.push(buffer);
    }
    return index;
  }
};
function serializeWebviewMessage(message, options2) {
  if (options2.serializeBuffersForPostMessage) {
    const arrayBuffers = new ArrayBufferSet();
    const replacer2 = (_key, value) => {
      if (value instanceof ArrayBuffer) {
        const index = arrayBuffers.add(value);
        return {
          $$vscode_array_buffer_reference$$: true,
          index
        };
      } else if (ArrayBuffer.isView(value)) {
        const type = getTypedArrayType(value);
        if (type) {
          const index = arrayBuffers.add(value.buffer);
          return {
            $$vscode_array_buffer_reference$$: true,
            index,
            view: {
              type,
              byteLength: value.byteLength,
              byteOffset: value.byteOffset
            }
          };
        }
      }
      return value;
    };
    const serializedMessage = JSON.stringify(message, replacer2);
    const buffers = arrayBuffers.buffers.map((arrayBuffer) => {
      const bytes = new Uint8Array(arrayBuffer);
      return VSBuffer.wrap(bytes);
    });
    return { message: serializedMessage, buffers };
  } else {
    return { message: JSON.stringify(message), buffers: [] };
  }
}
function getTypedArrayType(value) {
  switch (value.constructor.name) {
    case "Int8Array":
      return 1;
    case "Uint8Array":
      return 2;
    case "Uint8ClampedArray":
      return 3;
    case "Int16Array":
      return 4;
    case "Uint16Array":
      return 5;
    case "Int32Array":
      return 6;
    case "Uint32Array":
      return 7;
    case "Float32Array":
      return 8;
    case "Float64Array":
      return 9;
    case "BigInt64Array":
      return 10;
    case "BigUint64Array":
      return 11;
  }
  return void 0;
}
function deserializeWebviewMessage(jsonMessage, buffers) {
  const arrayBuffers = buffers.map((buffer) => {
    const arrayBuffer = new ArrayBuffer(buffer.byteLength);
    const uint8Array = new Uint8Array(arrayBuffer);
    uint8Array.set(buffer.buffer);
    return arrayBuffer;
  });
  const reviver = !buffers.length ? void 0 : (_key, value) => {
    if (value && typeof value === "object" && value.$$vscode_array_buffer_reference$$) {
      const ref = value;
      const { index } = ref;
      const arrayBuffer = arrayBuffers[index];
      if (ref.view) {
        switch (ref.view.type) {
          case 1:
            return new Int8Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Int8Array.BYTES_PER_ELEMENT);
          case 2:
            return new Uint8Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint8Array.BYTES_PER_ELEMENT);
          case 3:
            return new Uint8ClampedArray(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT);
          case 4:
            return new Int16Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Int16Array.BYTES_PER_ELEMENT);
          case 5:
            return new Uint16Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint16Array.BYTES_PER_ELEMENT);
          case 6:
            return new Int32Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Int32Array.BYTES_PER_ELEMENT);
          case 7:
            return new Uint32Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint32Array.BYTES_PER_ELEMENT);
          case 8:
            return new Float32Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Float32Array.BYTES_PER_ELEMENT);
          case 9:
            return new Float64Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Float64Array.BYTES_PER_ELEMENT);
          case 10:
            return new BigInt64Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT);
          case 11:
            return new BigUint64Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT);
          default:
            throw new Error("Unknown array buffer view type");
        }
      }
      return arrayBuffer;
    }
    return value;
  };
  const message = JSON.parse(jsonMessage, reviver);
  return { message, arrayBuffers };
}

// out-build/vs/workbench/api/common/extHostWebview.js
var ExtHostWebview = class {
  #handle;
  #proxy;
  #deprecationService;
  #remoteInfo;
  #workspace;
  #extension;
  #html;
  #options;
  #isDisposed;
  #hasCalledAsWebviewUri;
  #serializeBuffersForPostMessage;
  #shouldRewriteOldResourceUris;
  constructor(handle, proxy, options2, remoteInfo, workspace, extension, deprecationService) {
    this.#html = "";
    this.#isDisposed = false;
    this.#hasCalledAsWebviewUri = false;
    this._onMessageEmitter = new Emitter();
    this.onDidReceiveMessage = this._onMessageEmitter.event;
    this.#onDidDisposeEmitter = new Emitter();
    this._onDidDispose = this.#onDidDisposeEmitter.event;
    this.#handle = handle;
    this.#proxy = proxy;
    this.#options = options2;
    this.#remoteInfo = remoteInfo;
    this.#workspace = workspace;
    this.#extension = extension;
    this.#serializeBuffersForPostMessage = shouldSerializeBuffersForPostMessage(extension);
    this.#shouldRewriteOldResourceUris = shouldTryRewritingOldResourceUris(extension);
    this.#deprecationService = deprecationService;
  }
  #onDidDisposeEmitter;
  dispose() {
    this.#isDisposed = true;
    this.#onDidDisposeEmitter.fire();
    this.#onDidDisposeEmitter.dispose();
    this._onMessageEmitter.dispose();
  }
  asWebviewUri(resource) {
    this.#hasCalledAsWebviewUri = true;
    return asWebviewUri(resource, this.#remoteInfo);
  }
  get cspSource() {
    const extensionLocation = this.#extension.extensionLocation;
    if (extensionLocation.scheme === Schemas.https || extensionLocation.scheme === Schemas.http) {
      let extensionCspRule = extensionLocation.toString();
      if (!extensionCspRule.endsWith("/")) {
        extensionCspRule += "/";
      }
      return extensionCspRule + " " + webviewGenericCspSource;
    }
    return webviewGenericCspSource;
  }
  get html() {
    this.assertNotDisposed();
    return this.#html;
  }
  set html(value) {
    this.assertNotDisposed();
    if (this.#html !== value) {
      this.#html = value;
      if (this.#shouldRewriteOldResourceUris && !this.#hasCalledAsWebviewUri && /(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(value)) {
        this.#hasCalledAsWebviewUri = true;
        this.#deprecationService.report("Webview vscode-resource: uris", this.#extension, `Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri`);
      }
      this.#proxy.$setHtml(this.#handle, this.rewriteOldResourceUrlsIfNeeded(value));
    }
  }
  get options() {
    this.assertNotDisposed();
    return this.#options;
  }
  set options(newOptions) {
    this.assertNotDisposed();
    if (!equals2(this.#options, newOptions)) {
      this.#proxy.$setOptions(this.#handle, serializeWebviewOptions(this.#extension, this.#workspace, newOptions));
    }
    this.#options = newOptions;
  }
  async postMessage(message) {
    if (this.#isDisposed) {
      return false;
    }
    const serialized = serializeWebviewMessage(message, { serializeBuffersForPostMessage: this.#serializeBuffersForPostMessage });
    return this.#proxy.$postMessage(this.#handle, serialized.message, ...serialized.buffers);
  }
  assertNotDisposed() {
    if (this.#isDisposed) {
      throw new Error("Webview is disposed");
    }
  }
  rewriteOldResourceUrlsIfNeeded(value) {
    if (!this.#shouldRewriteOldResourceUris) {
      return value;
    }
    const isRemote = this.#extension.extensionLocation?.scheme === Schemas.vscodeRemote;
    const remoteAuthority = this.#extension.extensionLocation.scheme === Schemas.vscodeRemote ? this.#extension.extensionLocation.authority : void 0;
    return value.replace(/(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {
      const uri = URI.from({
        scheme: scheme || "file",
        path: decodeURIComponent(path)
      });
      const webviewUri = asWebviewUri(uri, { isRemote, authority: remoteAuthority }).toString();
      return `${startQuote}${webviewUri}${endQuote}`;
    }).replace(/(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {
      const uri = URI.from({
        scheme: scheme || "file",
        path: decodeURIComponent(path)
      });
      const webviewUri = asWebviewUri(uri, { isRemote, authority: remoteAuthority }).toString();
      return `${startQuote}${webviewUri}${endQuote}`;
    });
  }
};
function shouldSerializeBuffersForPostMessage(extension) {
  try {
    const version = normalizeVersion(parseVersion(extension.engines.vscode));
    return !!version && version.majorBase >= 1 && version.minorBase >= 57;
  } catch {
    return false;
  }
}
function shouldTryRewritingOldResourceUris(extension) {
  try {
    const version = normalizeVersion(parseVersion(extension.engines.vscode));
    if (!version) {
      return false;
    }
    return version.majorBase < 1 || version.majorBase === 1 && version.minorBase < 60;
  } catch {
    return false;
  }
}
var ExtHostWebviews = class extends Disposable {
  constructor(mainContext, remoteInfo, workspace, _logService, _deprecationService) {
    super();
    this.remoteInfo = remoteInfo;
    this.workspace = workspace;
    this._logService = _logService;
    this._deprecationService = _deprecationService;
    this._webviews = /* @__PURE__ */ new Map();
    this._webviewProxy = mainContext.getProxy(MainContext.MainThreadWebviews);
  }
  dispose() {
    super.dispose();
    for (const webview of this._webviews.values()) {
      webview.dispose();
    }
    this._webviews.clear();
  }
  $onMessage(handle, jsonMessage, buffers) {
    const webview = this.getWebview(handle);
    if (webview) {
      const { message } = deserializeWebviewMessage(jsonMessage, buffers.value);
      webview._onMessageEmitter.fire(message);
    }
  }
  $onMissingCsp(_handle, extensionId) {
    this._logService.warn(`${extensionId} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`);
  }
  createNewWebview(handle, options2, extension) {
    const webview = new ExtHostWebview(handle, this._webviewProxy, reviveOptions(options2), this.remoteInfo, this.workspace, extension, this._deprecationService);
    this._webviews.set(handle, webview);
    const sub = webview._onDidDispose(() => {
      sub.dispose();
      this.deleteWebview(handle);
    });
    return webview;
  }
  deleteWebview(handle) {
    this._webviews.delete(handle);
  }
  getWebview(handle) {
    return this._webviews.get(handle);
  }
};
function toExtensionData(extension) {
  return { id: extension.identifier, location: extension.extensionLocation };
}
function serializeWebviewOptions(extension, workspace, options2) {
  return {
    enableCommandUris: options2.enableCommandUris,
    enableScripts: options2.enableScripts,
    enableForms: options2.enableForms,
    portMapping: options2.portMapping,
    localResourceRoots: options2.localResourceRoots || getDefaultLocalResourceRoots(extension, workspace)
  };
}
function reviveOptions(options2) {
  return {
    enableCommandUris: options2.enableCommandUris,
    enableScripts: options2.enableScripts,
    enableForms: options2.enableForms,
    portMapping: options2.portMapping,
    localResourceRoots: options2.localResourceRoots?.map((components) => URI.from(components))
  };
}
function getDefaultLocalResourceRoots(extension, workspace) {
  return [
    ...(workspace?.getWorkspaceFolders() || []).map((x) => x.uri),
    extension.extensionLocation
  ];
}

// out-build/vs/workbench/api/common/cache.js
var Cache2 = class _Cache {
  static {
    this.enableDebugLogging = false;
  }
  constructor(id2) {
    this.id = id2;
    this._data = /* @__PURE__ */ new Map();
    this._idPool = 1;
  }
  add(item) {
    const id2 = this._idPool++;
    this._data.set(id2, item);
    this.logDebugInfo();
    return id2;
  }
  get(pid, id2) {
    return this._data.has(pid) ? this._data.get(pid)[id2] : void 0;
  }
  delete(id2) {
    this._data.delete(id2);
    this.logDebugInfo();
  }
  logDebugInfo() {
    if (!_Cache.enableDebugLogging) {
      return;
    }
    console.log(`${this.id} cache size - ${this._data.size}`);
  }
};

// out-build/vs/workbench/api/common/extHostCustomEditors.js
var CustomDocumentStoreEntry = class {
  constructor(document2, _storagePath) {
    this.document = document2;
    this._storagePath = _storagePath;
    this._backupCounter = 1;
    this._edits = new Cache2("custom documents");
  }
  addEdit(item) {
    return this._edits.add([item]);
  }
  async undo(editId, isDirty) {
    await this.getEdit(editId).undo();
    if (!isDirty) {
      this.disposeBackup();
    }
  }
  async redo(editId, isDirty) {
    await this.getEdit(editId).redo();
    if (!isDirty) {
      this.disposeBackup();
    }
  }
  disposeEdits(editIds) {
    for (const id2 of editIds) {
      this._edits.delete(id2);
    }
  }
  getNewBackupUri() {
    if (!this._storagePath) {
      throw new Error("Backup requires a valid storage path");
    }
    const fileName = hashPath(this.document.uri) + this._backupCounter++;
    return joinPath(this._storagePath, fileName);
  }
  updateBackup(backup) {
    this._backup?.delete();
    this._backup = backup;
  }
  disposeBackup() {
    this._backup?.delete();
    this._backup = void 0;
  }
  getEdit(editId) {
    const edit2 = this._edits.get(editId, 0);
    if (!edit2) {
      throw new Error("No edit found");
    }
    return edit2;
  }
};
var CustomDocumentStore = class {
  constructor() {
    this._documents = /* @__PURE__ */ new Map();
  }
  get(viewType, resource) {
    return this._documents.get(this.key(viewType, resource));
  }
  add(viewType, document2, storagePath) {
    const key = this.key(viewType, document2.uri);
    if (this._documents.has(key)) {
      throw new Error(`Document already exists for viewType:${viewType} resource:${document2.uri}`);
    }
    const entry = new CustomDocumentStoreEntry(document2, storagePath);
    this._documents.set(key, entry);
    return entry;
  }
  delete(viewType, document2) {
    const key = this.key(viewType, document2.uri);
    this._documents.delete(key);
  }
  key(viewType, resource) {
    return `${viewType}@@@${resource}`;
  }
};
var CustomEditorType;
(function(CustomEditorType2) {
  CustomEditorType2[CustomEditorType2["Text"] = 0] = "Text";
  CustomEditorType2[CustomEditorType2["Custom"] = 1] = "Custom";
})(CustomEditorType || (CustomEditorType = {}));
var EditorProviderStore = class {
  constructor() {
    this._providers = /* @__PURE__ */ new Map();
  }
  addTextProvider(viewType, extension, provider) {
    return this.add(viewType, { type: 0, extension, provider });
  }
  addCustomProvider(viewType, extension, provider) {
    return this.add(viewType, { type: 1, extension, provider });
  }
  get(viewType) {
    return this._providers.get(viewType);
  }
  add(viewType, entry) {
    if (this._providers.has(viewType)) {
      throw new Error(`Provider for viewType:${viewType} already registered`);
    }
    this._providers.set(viewType, entry);
    return new Disposable2(() => this._providers.delete(viewType));
  }
};
var ExtHostCustomEditors = class {
  constructor(mainContext, _extHostDocuments, _extensionStoragePaths, _extHostWebview, _extHostWebviewPanels) {
    this._extHostDocuments = _extHostDocuments;
    this._extensionStoragePaths = _extensionStoragePaths;
    this._extHostWebview = _extHostWebview;
    this._extHostWebviewPanels = _extHostWebviewPanels;
    this._editorProviders = new EditorProviderStore();
    this._documents = new CustomDocumentStore();
    this._proxy = mainContext.getProxy(MainContext.MainThreadCustomEditors);
  }
  registerCustomEditorProvider(extension, viewType, provider, options2) {
    const disposables = new DisposableStore();
    if (isCustomTextEditorProvider(provider)) {
      disposables.add(this._editorProviders.addTextProvider(viewType, extension, provider));
      this._proxy.$registerTextEditorProvider(toExtensionData(extension), viewType, options2.webviewOptions || {}, {
        supportsMove: !!provider.moveCustomTextEditor
      }, shouldSerializeBuffersForPostMessage(extension));
    } else {
      disposables.add(this._editorProviders.addCustomProvider(viewType, extension, provider));
      if (isCustomEditorProviderWithEditingCapability(provider)) {
        disposables.add(provider.onDidChangeCustomDocument((e) => {
          const entry = this.getCustomDocumentEntry(viewType, e.document.uri);
          if (isEditEvent(e)) {
            const editId = entry.addEdit(e);
            this._proxy.$onDidEdit(e.document.uri, viewType, editId, e.label);
          } else {
            this._proxy.$onContentChange(e.document.uri, viewType);
          }
        }));
      }
      this._proxy.$registerCustomEditorProvider(toExtensionData(extension), viewType, options2.webviewOptions || {}, !!options2.supportsMultipleEditorsPerDocument, shouldSerializeBuffersForPostMessage(extension));
    }
    return Disposable2.from(disposables, new Disposable2(() => {
      this._proxy.$unregisterEditorProvider(viewType);
    }));
  }
  async $createCustomDocument(resource, viewType, backupId, untitledDocumentData, cancellation) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    if (entry.type !== 1) {
      throw new Error(`Invalid provide type for '${viewType}'`);
    }
    const revivedResource = URI.revive(resource);
    const document2 = await entry.provider.openCustomDocument(revivedResource, { backupId, untitledDocumentData: untitledDocumentData?.buffer }, cancellation);
    let storageRoot;
    if (isCustomEditorProviderWithEditingCapability(entry.provider) && this._extensionStoragePaths) {
      storageRoot = this._extensionStoragePaths.workspaceValue(entry.extension) ?? this._extensionStoragePaths.globalValue(entry.extension);
    }
    this._documents.add(viewType, document2, storageRoot);
    return { editable: isCustomEditorProviderWithEditingCapability(entry.provider) };
  }
  async $disposeCustomDocument(resource, viewType) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    if (entry.type !== 1) {
      throw new Error(`Invalid provider type for '${viewType}'`);
    }
    const revivedResource = URI.revive(resource);
    const { document: document2 } = this.getCustomDocumentEntry(viewType, revivedResource);
    this._documents.delete(viewType, document2);
    document2.dispose();
  }
  async $resolveCustomEditor(resource, handle, viewType, initData, position, cancellation) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    const viewColumn = ViewColumn2.to(position);
    const webview = this._extHostWebview.createNewWebview(handle, initData.contentOptions, entry.extension);
    const panel = this._extHostWebviewPanels.createNewWebviewPanel(handle, viewType, initData.title, viewColumn, initData.options, webview, initData.active);
    const revivedResource = URI.revive(resource);
    switch (entry.type) {
      case 1: {
        const { document: document2 } = this.getCustomDocumentEntry(viewType, revivedResource);
        return entry.provider.resolveCustomEditor(document2, panel, cancellation);
      }
      case 0: {
        const document2 = this._extHostDocuments.getDocument(revivedResource);
        return entry.provider.resolveCustomTextEditor(document2, panel, cancellation);
      }
      default: {
        throw new Error("Unknown webview provider type");
      }
    }
  }
  $disposeEdits(resourceComponents, viewType, editIds) {
    const document2 = this.getCustomDocumentEntry(viewType, resourceComponents);
    document2.disposeEdits(editIds);
  }
  async $onMoveCustomEditor(handle, newResourceComponents, viewType) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    if (!entry.provider.moveCustomTextEditor) {
      throw new Error(`Provider does not implement move '${viewType}'`);
    }
    const webview = this._extHostWebviewPanels.getWebviewPanel(handle);
    if (!webview) {
      throw new Error(`No webview found`);
    }
    const resource = URI.revive(newResourceComponents);
    const document2 = this._extHostDocuments.getDocument(resource);
    await entry.provider.moveCustomTextEditor(document2, webview, CancellationToken.None);
  }
  async $undo(resourceComponents, viewType, editId, isDirty) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    return entry.undo(editId, isDirty);
  }
  async $redo(resourceComponents, viewType, editId, isDirty) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    return entry.redo(editId, isDirty);
  }
  async $revert(resourceComponents, viewType, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    await provider.revertCustomDocument(entry.document, cancellation);
    entry.disposeBackup();
  }
  async $onSave(resourceComponents, viewType, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    await provider.saveCustomDocument(entry.document, cancellation);
    entry.disposeBackup();
  }
  async $onSaveAs(resourceComponents, viewType, targetResource, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    return provider.saveCustomDocumentAs(entry.document, URI.revive(targetResource), cancellation);
  }
  async $backup(resourceComponents, viewType, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    const backup = await provider.backupCustomDocument(entry.document, {
      destination: entry.getNewBackupUri()
    }, cancellation);
    entry.updateBackup(backup);
    return backup.id;
  }
  getCustomDocumentEntry(viewType, resource) {
    const entry = this._documents.get(viewType, URI.revive(resource));
    if (!entry) {
      throw new Error("No custom document found");
    }
    return entry;
  }
  getCustomEditorProvider(viewType) {
    const entry = this._editorProviders.get(viewType);
    const provider = entry?.provider;
    if (!provider || !isCustomEditorProviderWithEditingCapability(provider)) {
      throw new Error("Custom document is not editable");
    }
    return provider;
  }
};
function isCustomEditorProviderWithEditingCapability(provider) {
  return !!provider.onDidChangeCustomDocument;
}
function isCustomTextEditorProvider(provider) {
  return typeof provider.resolveCustomTextEditor === "function";
}
function isEditEvent(e) {
  return typeof e.undo === "function" && typeof e.redo === "function";
}
function hashPath(resource) {
  const str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();
  return hash(str) + "";
}

// out-build/vs/workbench/api/common/extHostDiagnostics.js
var ExtHostDiagnostics_1;
var DiagnosticCollection = class _DiagnosticCollection {
  #proxy;
  #onDidChangeDiagnostics;
  #data;
  constructor(_name, _owner, _maxDiagnosticsTotal, _maxDiagnosticsPerFile, _modelVersionIdProvider, extUri2, proxy, onDidChangeDiagnostics) {
    this._name = _name;
    this._owner = _owner;
    this._maxDiagnosticsTotal = _maxDiagnosticsTotal;
    this._maxDiagnosticsPerFile = _maxDiagnosticsPerFile;
    this._modelVersionIdProvider = _modelVersionIdProvider;
    this._isDisposed = false;
    this._maxDiagnosticsTotal = Math.max(_maxDiagnosticsPerFile, _maxDiagnosticsTotal);
    this.#data = new ResourceMap((uri) => extUri2.getComparisonKey(uri));
    this.#proxy = proxy;
    this.#onDidChangeDiagnostics = onDidChangeDiagnostics;
  }
  dispose() {
    if (!this._isDisposed) {
      this.#onDidChangeDiagnostics.fire([...this.#data.keys()]);
      this.#proxy?.$clear(this._owner);
      this.#data.clear();
      this._isDisposed = true;
    }
  }
  get name() {
    this._checkDisposed();
    return this._name;
  }
  set(first, diagnostics) {
    if (!first) {
      this.clear();
      return;
    }
    this._checkDisposed();
    let toSync = [];
    if (URI.isUri(first)) {
      if (!diagnostics) {
        this.delete(first);
        return;
      }
      this.#data.set(first, coalesce(diagnostics));
      toSync = [first];
    } else if (Array.isArray(first)) {
      toSync = [];
      let lastUri;
      first = [...first].sort(_DiagnosticCollection._compareIndexedTuplesByUri);
      for (const tuple of first) {
        const [uri, diagnostics2] = tuple;
        if (!lastUri || uri.toString() !== lastUri.toString()) {
          if (lastUri && this.#data.get(lastUri).length === 0) {
            this.#data.delete(lastUri);
          }
          lastUri = uri;
          toSync.push(uri);
          this.#data.set(uri, []);
        }
        if (!diagnostics2) {
          const currentDiagnostics = this.#data.get(uri);
          if (currentDiagnostics) {
            currentDiagnostics.length = 0;
          }
        } else {
          const currentDiagnostics = this.#data.get(uri);
          currentDiagnostics?.push(...coalesce(diagnostics2));
        }
      }
    }
    this.#onDidChangeDiagnostics.fire(toSync);
    if (!this.#proxy) {
      return;
    }
    const entries = [];
    let totalMarkerCount = 0;
    for (const uri of toSync) {
      let marker = [];
      const diagnostics2 = this.#data.get(uri);
      if (diagnostics2) {
        if (diagnostics2.length > this._maxDiagnosticsPerFile) {
          marker = [];
          const order = [DiagnosticSeverity.Error, DiagnosticSeverity.Warning, DiagnosticSeverity.Information, DiagnosticSeverity.Hint];
          orderLoop: for (let i = 0; i < 4; i++) {
            for (const diagnostic of diagnostics2) {
              if (diagnostic.severity === order[i]) {
                const len = marker.push({ ...Diagnostic3.from(diagnostic), modelVersionId: this._modelVersionIdProvider(uri) });
                if (len === this._maxDiagnosticsPerFile) {
                  break orderLoop;
                }
              }
            }
          }
          marker.push({
            severity: MarkerSeverity.Info,
            message: localize(3009, null, diagnostics2.length - this._maxDiagnosticsPerFile),
            startLineNumber: marker[marker.length - 1].startLineNumber,
            startColumn: marker[marker.length - 1].startColumn,
            endLineNumber: marker[marker.length - 1].endLineNumber,
            endColumn: marker[marker.length - 1].endColumn
          });
        } else {
          marker = diagnostics2.map((diag) => ({ ...Diagnostic3.from(diag), modelVersionId: this._modelVersionIdProvider(uri) }));
        }
      }
      entries.push([uri, marker]);
      totalMarkerCount += marker.length;
      if (totalMarkerCount > this._maxDiagnosticsTotal) {
        break;
      }
    }
    this.#proxy.$changeMany(this._owner, entries);
  }
  delete(uri) {
    this._checkDisposed();
    this.#onDidChangeDiagnostics.fire([uri]);
    this.#data.delete(uri);
    this.#proxy?.$changeMany(this._owner, [[uri, void 0]]);
  }
  clear() {
    this._checkDisposed();
    this.#onDidChangeDiagnostics.fire([...this.#data.keys()]);
    this.#data.clear();
    this.#proxy?.$clear(this._owner);
  }
  forEach(callback, thisArg) {
    this._checkDisposed();
    for (const [uri, values] of this) {
      callback.call(thisArg, uri, values, this);
    }
  }
  *[Symbol.iterator]() {
    this._checkDisposed();
    for (const uri of this.#data.keys()) {
      yield [uri, this.get(uri)];
    }
  }
  get(uri) {
    this._checkDisposed();
    const result = this.#data.get(uri);
    if (Array.isArray(result)) {
      return Object.freeze(result.slice(0));
    }
    return [];
  }
  has(uri) {
    this._checkDisposed();
    return Array.isArray(this.#data.get(uri));
  }
  _checkDisposed() {
    if (this._isDisposed) {
      throw new Error("illegal state - object is disposed");
    }
  }
  static _compareIndexedTuplesByUri(a, b) {
    if (a[0].toString() < b[0].toString()) {
      return -1;
    } else if (a[0].toString() > b[0].toString()) {
      return 1;
    } else {
      return 0;
    }
  }
};
var ExtHostDiagnostics = class ExtHostDiagnostics2 {
  static {
    ExtHostDiagnostics_1 = this;
  }
  static {
    this._idPool = 0;
  }
  static {
    this._maxDiagnosticsPerFile = 1e3;
  }
  static {
    this._maxDiagnosticsTotal = 1.1 * this._maxDiagnosticsPerFile;
  }
  static _mapper(last) {
    const map = new ResourceMap();
    for (const uri of last) {
      map.set(uri, uri);
    }
    return { uris: Object.freeze(Array.from(map.values())) };
  }
  constructor(mainContext, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors) {
    this._logService = _logService;
    this._fileSystemInfoService = _fileSystemInfoService;
    this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
    this._collections = /* @__PURE__ */ new Map();
    this._onDidChangeDiagnostics = new DebounceEmitter({ merge: (all) => all.flat(), delay: 50 });
    this.onDidChangeDiagnostics = Event.map(this._onDidChangeDiagnostics.event, ExtHostDiagnostics_1._mapper);
    this._proxy = mainContext.getProxy(MainContext.MainThreadDiagnostics);
  }
  createDiagnosticCollection(extensionId, name2) {
    const { _collections, _proxy, _onDidChangeDiagnostics, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors } = this;
    const loggingProxy = new class {
      $changeMany(owner2, entries) {
        _proxy.$changeMany(owner2, entries);
        _logService.trace("[DiagnosticCollection] change many (extension, owner, uris)", extensionId.value, owner2, entries.length === 0 ? "CLEARING" : entries);
      }
      $clear(owner2) {
        _proxy.$clear(owner2);
        _logService.trace("[DiagnosticCollection] remove all (extension, owner)", extensionId.value, owner2);
      }
      dispose() {
        _proxy.dispose();
      }
    }();
    let owner;
    if (!name2) {
      name2 = "_generated_diagnostic_collection_name_#" + ExtHostDiagnostics_1._idPool++;
      owner = name2;
    } else if (!_collections.has(name2)) {
      owner = name2;
    } else {
      this._logService.warn(`DiagnosticCollection with name '${name2}' does already exist.`);
      do {
        owner = name2 + ExtHostDiagnostics_1._idPool++;
      } while (_collections.has(owner));
    }
    const result = new class extends DiagnosticCollection {
      constructor() {
        super(name2, owner, ExtHostDiagnostics_1._maxDiagnosticsTotal, ExtHostDiagnostics_1._maxDiagnosticsPerFile, (uri) => _extHostDocumentsAndEditors.getDocument(uri)?.version, _fileSystemInfoService.extUri, loggingProxy, _onDidChangeDiagnostics);
        _collections.set(owner, this);
      }
      dispose() {
        super.dispose();
        _collections.delete(owner);
      }
    }();
    return result;
  }
  getDiagnostics(resource) {
    if (resource) {
      return this._getDiagnostics(resource);
    } else {
      const index = /* @__PURE__ */ new Map();
      const res = [];
      for (const collection of this._collections.values()) {
        collection.forEach((uri, diagnostics) => {
          let idx = index.get(uri.toString());
          if (typeof idx === "undefined") {
            idx = res.length;
            index.set(uri.toString(), idx);
            res.push([uri, []]);
          }
          res[idx][1] = res[idx][1].concat(...diagnostics);
        });
      }
      return res;
    }
  }
  _getDiagnostics(resource) {
    let res = [];
    for (const collection of this._collections.values()) {
      if (collection.has(resource)) {
        res = res.concat(collection.get(resource));
      }
    }
    return res;
  }
  $acceptMarkersChange(data2) {
    if (!this._mirrorCollection) {
      const name2 = "_generated_mirror";
      const collection = new DiagnosticCollection(
        name2,
        name2,
        Number.MAX_SAFE_INTEGER,
        Number.MAX_SAFE_INTEGER,
        // no limits because this collection is just a mirror of "sanitized" data
        // no limits because this collection is just a mirror of "sanitized" data
        (_uri) => void 0,
        this._fileSystemInfoService.extUri,
        void 0,
        this._onDidChangeDiagnostics
      );
      this._collections.set(name2, collection);
      this._mirrorCollection = collection;
    }
    for (const [uri, markers] of data2) {
      this._mirrorCollection.set(URI.revive(uri), markers.map(Diagnostic3.to));
    }
  }
};
ExtHostDiagnostics = ExtHostDiagnostics_1 = __decorate([
  __param(1, ILogService),
  __param(2, IExtHostFileSystemInfo)
], ExtHostDiagnostics);

// out-build/vs/workbench/api/common/extHostDialogs.js
var ExtHostDialogs = class {
  constructor(mainContext) {
    this._proxy = mainContext.getProxy(MainContext.MainThreadDialogs);
  }
  showOpenDialog(options2) {
    return this._proxy.$showOpenDialog(options2).then((filepaths) => {
      return filepaths ? filepaths.map((p) => URI.revive(p)) : void 0;
    });
  }
  showSaveDialog(options2) {
    return this._proxy.$showSaveDialog(options2).then((filepath) => {
      return filepath ? URI.revive(filepath) : void 0;
    });
  }
};

// out-build/vs/workbench/api/common/extHostDocumentContentProviders.js
var ExtHostDocumentContentProvider = class _ExtHostDocumentContentProvider {
  static {
    this._handlePool = 0;
  }
  constructor(mainContext, _documentsAndEditors, _logService) {
    this._documentsAndEditors = _documentsAndEditors;
    this._logService = _logService;
    this._documentContentProviders = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadDocumentContentProviders);
  }
  registerTextDocumentContentProvider(scheme, provider) {
    if (Object.keys(Schemas).indexOf(scheme) >= 0) {
      throw new Error(`scheme '${scheme}' already registered`);
    }
    const handle = _ExtHostDocumentContentProvider._handlePool++;
    this._documentContentProviders.set(handle, provider);
    this._proxy.$registerTextContentProvider(handle, scheme);
    let subscription;
    if (typeof provider.onDidChange === "function") {
      let lastEvent;
      subscription = provider.onDidChange(async (uri) => {
        if (uri.scheme !== scheme) {
          this._logService.warn(`Provider for scheme '${scheme}' is firing event for schema '${uri.scheme}' which will be IGNORED`);
          return;
        }
        if (!this._documentsAndEditors.getDocument(uri)) {
          return;
        }
        if (lastEvent) {
          await lastEvent;
        }
        const thisEvent = this.$provideTextDocumentContent(handle, uri).then(async (value) => {
          if (!value && typeof value !== "string") {
            return;
          }
          const document2 = this._documentsAndEditors.getDocument(uri);
          if (!document2) {
            return;
          }
          const lines = splitLines(value);
          if (!document2.equalLines(lines)) {
            return this._proxy.$onVirtualDocumentChange(uri, value);
          }
        }).catch(onUnexpectedError).finally(() => {
          if (lastEvent === thisEvent) {
            lastEvent = void 0;
          }
        });
        lastEvent = thisEvent;
      });
    }
    return new Disposable2(() => {
      if (this._documentContentProviders.delete(handle)) {
        this._proxy.$unregisterTextContentProvider(handle);
      }
      if (subscription) {
        subscription.dispose();
        subscription = void 0;
      }
    });
  }
  $provideTextDocumentContent(handle, uri) {
    const provider = this._documentContentProviders.get(handle);
    if (!provider) {
      return Promise.reject(new Error(`unsupported uri-scheme: ${uri.scheme}`));
    }
    return Promise.resolve(provider.provideTextDocumentContent(URI.revive(uri), CancellationToken.None));
  }
};

// out-build/vs/workbench/api/common/extHostDocumentSaveParticipant.js
var ExtHostDocumentSaveParticipant = class {
  constructor(_logService, _documents, _mainThreadBulkEdits, _thresholds = { timeout: 1500, errors: 3 }) {
    this._logService = _logService;
    this._documents = _documents;
    this._mainThreadBulkEdits = _mainThreadBulkEdits;
    this._thresholds = _thresholds;
    this._callbacks = new LinkedList();
    this._badListeners = /* @__PURE__ */ new WeakMap();
  }
  dispose() {
    this._callbacks.clear();
  }
  getOnWillSaveTextDocumentEvent(extension) {
    return (listener, thisArg, disposables) => {
      const remove = this._callbacks.push([listener, thisArg, extension]);
      const result = { dispose: remove };
      if (Array.isArray(disposables)) {
        disposables.push(result);
      }
      return result;
    };
  }
  async $participateInSave(data2, reason) {
    const resource = URI.revive(data2);
    let didTimeout = false;
    const didTimeoutHandle = setTimeout(() => didTimeout = true, this._thresholds.timeout);
    const results = [];
    try {
      for (const listener of [...this._callbacks]) {
        if (didTimeout) {
          break;
        }
        const document2 = this._documents.getDocument(resource);
        const success = await this._deliverEventAsyncAndBlameBadListeners(listener, { document: document2, reason: TextDocumentSaveReason2.to(reason) });
        results.push(success);
      }
    } finally {
      clearTimeout(didTimeoutHandle);
    }
    return results;
  }
  _deliverEventAsyncAndBlameBadListeners([listener, thisArg, extension], stubEvent) {
    const errors = this._badListeners.get(listener);
    if (typeof errors === "number" && errors > this._thresholds.errors) {
      return Promise.resolve(false);
    }
    return this._deliverEventAsync(extension, listener, thisArg, stubEvent).then(() => {
      return true;
    }, (err) => {
      this._logService.error(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' threw ERROR`);
      this._logService.error(err);
      if (!(err instanceof Error) || err.message !== "concurrent_edits") {
        const errors2 = this._badListeners.get(listener);
        this._badListeners.set(listener, !errors2 ? 1 : errors2 + 1);
        if (typeof errors2 === "number" && errors2 > this._thresholds.errors) {
          this._logService.info(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' will now be IGNORED because of timeouts and/or errors`);
        }
      }
      return false;
    });
  }
  _deliverEventAsync(extension, listener, thisArg, stubEvent) {
    const promises = [];
    const t1 = Date.now();
    const { document: document2, reason } = stubEvent;
    const { version } = document2;
    const event = Object.freeze({
      document: document2,
      reason,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      waitUntil(p) {
        if (Object.isFrozen(promises)) {
          throw illegalState("waitUntil can not be called async");
        }
        promises.push(Promise.resolve(p));
      }
    });
    try {
      listener.apply(thisArg, [event]);
    } catch (err) {
      return Promise.reject(err);
    }
    Object.freeze(promises);
    return new Promise((resolve2, reject) => {
      const handle = setTimeout(() => reject(new Error("timeout")), this._thresholds.timeout);
      return Promise.all(promises).then((edits) => {
        this._logService.debug(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' finished after ${Date.now() - t1}ms`);
        clearTimeout(handle);
        resolve2(edits);
      }).catch((err) => {
        clearTimeout(handle);
        reject(err);
      });
    }).then((values) => {
      const dto = { edits: [] };
      for (const value of values) {
        if (Array.isArray(value) && value.every((e) => e instanceof TextEdit)) {
          for (const { newText, newEol, range } of value) {
            dto.edits.push({
              resource: document2.uri,
              versionId: void 0,
              textEdit: {
                range: range && Range4.from(range),
                text: newText,
                eol: newEol && EndOfLine2.from(newEol)
              }
            });
          }
        }
      }
      if (dto.edits.length === 0) {
        return void 0;
      }
      if (version === document2.version) {
        return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new SerializableObjectWithBuffers(dto));
      }
      return Promise.reject(new Error("concurrent_edits"));
    });
  }
};

// out-build/vs/workbench/api/common/extHostDocuments.js
var ExtHostDocuments = class {
  constructor(mainContext, documentsAndEditors) {
    this._onDidAddDocument = new Emitter();
    this._onDidRemoveDocument = new Emitter();
    this._onDidChangeDocument = new Emitter();
    this._onDidChangeDocumentWithReason = new Emitter();
    this._onDidSaveDocument = new Emitter();
    this.onDidAddDocument = this._onDidAddDocument.event;
    this.onDidRemoveDocument = this._onDidRemoveDocument.event;
    this.onDidChangeDocument = this._onDidChangeDocument.event;
    this.onDidChangeDocumentWithReason = this._onDidChangeDocumentWithReason.event;
    this.onDidSaveDocument = this._onDidSaveDocument.event;
    this._toDispose = new DisposableStore();
    this._documentLoader = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadDocuments);
    this._documentsAndEditors = documentsAndEditors;
    this._documentsAndEditors.onDidRemoveDocuments((documents) => {
      for (const data2 of documents) {
        this._onDidRemoveDocument.fire(data2.document);
      }
    }, void 0, this._toDispose);
    this._documentsAndEditors.onDidAddDocuments((documents) => {
      for (const data2 of documents) {
        this._onDidAddDocument.fire(data2.document);
      }
    }, void 0, this._toDispose);
  }
  dispose() {
    this._toDispose.dispose();
  }
  getAllDocumentData() {
    return [...this._documentsAndEditors.allDocuments()];
  }
  getDocumentData(resource) {
    if (!resource) {
      return void 0;
    }
    const data2 = this._documentsAndEditors.getDocument(resource);
    if (data2) {
      return data2;
    }
    return void 0;
  }
  getDocument(resource) {
    const data2 = this.getDocumentData(resource);
    if (!data2?.document) {
      throw new Error(`Unable to retrieve document from URI '${resource}'`);
    }
    return data2.document;
  }
  ensureDocumentData(uri, options2) {
    const cached = this._documentsAndEditors.getDocument(uri);
    if (cached && (!options2?.encoding || cached.document.encoding === options2.encoding)) {
      return Promise.resolve(cached);
    }
    let promise = this._documentLoader.get(uri.toString());
    if (!promise) {
      promise = this._proxy.$tryOpenDocument(uri, options2).then((uriData) => {
        this._documentLoader.delete(uri.toString());
        const canonicalUri = URI.revive(uriData);
        return assertReturnsDefined(this._documentsAndEditors.getDocument(canonicalUri));
      }, (err) => {
        this._documentLoader.delete(uri.toString());
        return Promise.reject(err);
      });
      this._documentLoader.set(uri.toString(), promise);
    } else {
      if (options2?.encoding) {
        promise = promise.then((data2) => {
          if (data2.document.encoding !== options2.encoding) {
            return this.ensureDocumentData(uri, options2);
          }
          return data2;
        });
      }
    }
    return promise;
  }
  createDocumentData(options2) {
    return this._proxy.$tryCreateDocument(options2).then((data2) => URI.revive(data2));
  }
  $acceptModelLanguageChanged(uriComponents, newLanguageId) {
    const uri = URI.revive(uriComponents);
    const data2 = this._documentsAndEditors.getDocument(uri);
    if (!data2) {
      throw new Error("unknown document");
    }
    this._onDidRemoveDocument.fire(data2.document);
    data2._acceptLanguageId(newLanguageId);
    this._onDidAddDocument.fire(data2.document);
  }
  $acceptModelSaved(uriComponents) {
    const uri = URI.revive(uriComponents);
    const data2 = this._documentsAndEditors.getDocument(uri);
    if (!data2) {
      throw new Error("unknown document");
    }
    this.$acceptDirtyStateChanged(uriComponents, false);
    this._onDidSaveDocument.fire(data2.document);
  }
  $acceptDirtyStateChanged(uriComponents, isDirty) {
    const uri = URI.revive(uriComponents);
    const data2 = this._documentsAndEditors.getDocument(uri);
    if (!data2) {
      throw new Error("unknown document");
    }
    data2._acceptIsDirty(isDirty);
    this._onDidChangeDocument.fire({
      document: data2.document,
      contentChanges: [],
      reason: void 0
    });
    this._onDidChangeDocumentWithReason.fire({
      document: data2.document,
      contentChanges: [],
      reason: void 0,
      detailedReason: void 0
    });
  }
  $acceptEncodingChanged(uriComponents, encoding) {
    const uri = URI.revive(uriComponents);
    const data2 = this._documentsAndEditors.getDocument(uri);
    if (!data2) {
      throw new Error("unknown document");
    }
    data2._acceptEncoding(encoding);
    this._onDidChangeDocument.fire({
      document: data2.document,
      contentChanges: [],
      reason: void 0
    });
    this._onDidChangeDocumentWithReason.fire({
      document: data2.document,
      contentChanges: [],
      reason: void 0,
      detailedReason: void 0
    });
  }
  $acceptModelChanged(uriComponents, events, isDirty) {
    const uri = URI.revive(uriComponents);
    const data2 = this._documentsAndEditors.getDocument(uri);
    if (!data2) {
      throw new Error("unknown document");
    }
    data2._acceptIsDirty(isDirty);
    data2.onEvents(events);
    let reason = void 0;
    if (events.isUndoing) {
      reason = TextDocumentChangeReason.Undo;
    } else if (events.isRedoing) {
      reason = TextDocumentChangeReason.Redo;
    }
    this._onDidChangeDocument.fire(deepFreeze({
      document: data2.document,
      contentChanges: events.changes.map((change) => {
        return {
          range: Range4.to(change.range),
          rangeOffset: change.rangeOffset,
          rangeLength: change.rangeLength,
          text: change.text
        };
      }),
      reason
    }));
    this._onDidChangeDocumentWithReason.fire(deepFreeze({
      document: data2.document,
      contentChanges: events.changes.map((change) => {
        return {
          range: Range4.to(change.range),
          rangeOffset: change.rangeOffset,
          rangeLength: change.rangeLength,
          text: change.text
        };
      }),
      reason,
      detailedReason: events.detailedReason ? {
        source: events.detailedReason.source,
        metadata: events.detailedReason
      } : void 0
    }));
  }
  setWordDefinitionFor(languageId, wordDefinition) {
    setWordDefinitionFor(languageId, wordDefinition);
  }
};

// out-build/vs/workbench/api/common/extHostEmbedding.js
var ExtHostEmbeddings = class {
  constructor(mainContext) {
    this._provider = /* @__PURE__ */ new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._allKnownModels = /* @__PURE__ */ new Set();
    this._handlePool = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadEmbeddings);
  }
  registerEmbeddingsProvider(_extension, embeddingsModel, provider) {
    if (this._allKnownModels.has(embeddingsModel)) {
      throw new Error("An embeddings provider for this model is already registered");
    }
    const handle = this._handlePool++;
    this._proxy.$registerEmbeddingProvider(handle, embeddingsModel);
    this._provider.set(handle, { id: embeddingsModel, provider });
    return toDisposable(() => {
      this._allKnownModels.delete(embeddingsModel);
      this._proxy.$unregisterEmbeddingProvider(handle);
      this._provider.delete(handle);
    });
  }
  async computeEmbeddings(embeddingsModel, input, token) {
    token ??= CancellationToken.None;
    let returnSingle = false;
    if (typeof input === "string") {
      input = [input];
      returnSingle = true;
    }
    const result = await this._proxy.$computeEmbeddings(embeddingsModel, input, token);
    if (result.length !== input.length) {
      throw new Error();
    }
    if (returnSingle) {
      if (result.length !== 1) {
        throw new Error();
      }
      return result[0];
    }
    return result;
  }
  async $provideEmbeddings(handle, input, token) {
    const data2 = this._provider.get(handle);
    if (!data2) {
      return [];
    }
    const result = await data2.provider.provideEmbeddings(input, token);
    if (!result) {
      return [];
    }
    return result;
  }
  get embeddingsModels() {
    return Array.from(this._allKnownModels);
  }
  $acceptEmbeddingModels(models) {
    this._allKnownModels = new Set(models);
    this._onDidChange.fire();
  }
};

// out-build/vs/workbench/api/common/extHostEmbeddingVector.js
var ExtHostAiEmbeddingVector = class {
  constructor(mainContext) {
    this._AiEmbeddingVectorProviders = /* @__PURE__ */ new Map();
    this._nextHandle = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadAiEmbeddingVector);
  }
  async $provideAiEmbeddingVector(handle, strings, token) {
    if (this._AiEmbeddingVectorProviders.size === 0) {
      throw new Error("No embedding vector providers registered");
    }
    const provider = this._AiEmbeddingVectorProviders.get(handle);
    if (!provider) {
      throw new Error("Embedding vector provider not found");
    }
    const result = await provider.provideEmbeddingVector(strings, token);
    if (!result) {
      throw new Error("Embedding vector provider returned undefined");
    }
    return result;
  }
  registerEmbeddingVectorProvider(extension, model, provider) {
    const handle = this._nextHandle;
    this._nextHandle++;
    this._AiEmbeddingVectorProviders.set(handle, provider);
    this._proxy.$registerAiEmbeddingVectorProvider(model, handle);
    return new Disposable2(() => {
      this._proxy.$unregisterAiEmbeddingVectorProvider(handle);
      this._AiEmbeddingVectorProviders.delete(handle);
    });
  }
};

// out-build/vs/editor/common/languages/linkComputer.js
var State2;
(function(State3) {
  State3[State3["Invalid"] = 0] = "Invalid";
  State3[State3["Start"] = 1] = "Start";
  State3[State3["H"] = 2] = "H";
  State3[State3["HT"] = 3] = "HT";
  State3[State3["HTT"] = 4] = "HTT";
  State3[State3["HTTP"] = 5] = "HTTP";
  State3[State3["F"] = 6] = "F";
  State3[State3["FI"] = 7] = "FI";
  State3[State3["FIL"] = 8] = "FIL";
  State3[State3["BeforeColon"] = 9] = "BeforeColon";
  State3[State3["AfterColon"] = 10] = "AfterColon";
  State3[State3["AlmostThere"] = 11] = "AlmostThere";
  State3[State3["End"] = 12] = "End";
  State3[State3["Accept"] = 13] = "Accept";
  State3[State3["LastKnownState"] = 14] = "LastKnownState";
})(State2 || (State2 = {}));
var Uint8Matrix = class {
  constructor(rows, cols, defaultValue) {
    const data2 = new Uint8Array(rows * cols);
    for (let i = 0, len = rows * cols; i < len; i++) {
      data2[i] = defaultValue;
    }
    this._data = data2;
    this.rows = rows;
    this.cols = cols;
  }
  get(row, col) {
    return this._data[row * this.cols + col];
  }
  set(row, col, value) {
    this._data[row * this.cols + col] = value;
  }
};
var StateMachine = class {
  constructor(edges) {
    let maxCharCode = 0;
    let maxState = 0;
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      if (chCode > maxCharCode) {
        maxCharCode = chCode;
      }
      if (from > maxState) {
        maxState = from;
      }
      if (to > maxState) {
        maxState = to;
      }
    }
    maxCharCode++;
    maxState++;
    const states = new Uint8Matrix(
      maxState,
      maxCharCode,
      0
      /* State.Invalid */
    );
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      states.set(from, chCode, to);
    }
    this._states = states;
    this._maxCharCode = maxCharCode;
  }
  nextState(currentState, chCode) {
    if (chCode < 0 || chCode >= this._maxCharCode) {
      return 0;
    }
    return this._states.get(currentState, chCode);
  }
};
var _stateMachine = null;
function getStateMachine() {
  if (_stateMachine === null) {
    _stateMachine = new StateMachine([
      [
        1,
        104,
        2
        /* State.H */
      ],
      [
        1,
        72,
        2
        /* State.H */
      ],
      [
        1,
        102,
        6
        /* State.F */
      ],
      [
        1,
        70,
        6
        /* State.F */
      ],
      [
        2,
        116,
        3
        /* State.HT */
      ],
      [
        2,
        84,
        3
        /* State.HT */
      ],
      [
        3,
        116,
        4
        /* State.HTT */
      ],
      [
        3,
        84,
        4
        /* State.HTT */
      ],
      [
        4,
        112,
        5
        /* State.HTTP */
      ],
      [
        4,
        80,
        5
        /* State.HTTP */
      ],
      [
        5,
        115,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        83,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        58,
        10
        /* State.AfterColon */
      ],
      [
        6,
        105,
        7
        /* State.FI */
      ],
      [
        6,
        73,
        7
        /* State.FI */
      ],
      [
        7,
        108,
        8
        /* State.FIL */
      ],
      [
        7,
        76,
        8
        /* State.FIL */
      ],
      [
        8,
        101,
        9
        /* State.BeforeColon */
      ],
      [
        8,
        69,
        9
        /* State.BeforeColon */
      ],
      [
        9,
        58,
        10
        /* State.AfterColon */
      ],
      [
        10,
        47,
        11
        /* State.AlmostThere */
      ],
      [
        11,
        47,
        12
        /* State.End */
      ]
    ]);
  }
  return _stateMachine;
}
var CharacterClass;
(function(CharacterClass2) {
  CharacterClass2[CharacterClass2["None"] = 0] = "None";
  CharacterClass2[CharacterClass2["ForceTermination"] = 1] = "ForceTermination";
  CharacterClass2[CharacterClass2["CannotEndIn"] = 2] = "CannotEndIn";
})(CharacterClass || (CharacterClass = {}));
var _classifier = null;
function getClassifier() {
  if (_classifier === null) {
    _classifier = new CharacterClassifier(
      0
      /* CharacterClass.None */
    );
    const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026|`;
    for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
      _classifier.set(
        FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
        1
        /* CharacterClass.ForceTermination */
      );
    }
    const CANNOT_END_WITH_CHARACTERS = ".,;:";
    for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
      _classifier.set(
        CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
        2
        /* CharacterClass.CannotEndIn */
      );
    }
  }
  return _classifier;
}
var LinkComputer = class _LinkComputer {
  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
    let lastIncludedCharIndex = linkEndIndex - 1;
    do {
      const chCode = line.charCodeAt(lastIncludedCharIndex);
      const chClass = classifier.get(chCode);
      if (chClass !== 2) {
        break;
      }
      lastIncludedCharIndex--;
    } while (lastIncludedCharIndex > linkBeginIndex);
    if (linkBeginIndex > 0) {
      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
      if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
        lastIncludedCharIndex--;
      }
    }
    return {
      range: {
        startLineNumber: lineNumber,
        startColumn: linkBeginIndex + 1,
        endLineNumber: lineNumber,
        endColumn: lastIncludedCharIndex + 2
      },
      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
    };
  }
  static computeLinks(model, stateMachine = getStateMachine()) {
    const classifier = getClassifier();
    const result = [];
    for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
      const line = model.getLineContent(i);
      const len = line.length;
      let j = 0;
      let linkBeginIndex = 0;
      let linkBeginChCode = 0;
      let state = 1;
      let hasOpenParens = false;
      let hasOpenSquareBracket = false;
      let inSquareBrackets = false;
      let hasOpenCurlyBracket = false;
      while (j < len) {
        let resetStateMachine = false;
        const chCode = line.charCodeAt(j);
        if (state === 13) {
          let chClass;
          switch (chCode) {
            case 40:
              hasOpenParens = true;
              chClass = 0;
              break;
            case 41:
              chClass = hasOpenParens ? 0 : 1;
              break;
            case 91:
              inSquareBrackets = true;
              hasOpenSquareBracket = true;
              chClass = 0;
              break;
            case 93:
              inSquareBrackets = false;
              chClass = hasOpenSquareBracket ? 0 : 1;
              break;
            case 123:
              hasOpenCurlyBracket = true;
              chClass = 0;
              break;
            case 125:
              chClass = hasOpenCurlyBracket ? 0 : 1;
              break;
            // The following three rules make it that ' or " or ` are allowed inside links
            // only if the link is wrapped by some other quote character
            case 39:
            case 34:
            case 96:
              if (linkBeginChCode === chCode) {
                chClass = 1;
              } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                chClass = 0;
              } else {
                chClass = 1;
              }
              break;
            case 42:
              chClass = linkBeginChCode === 42 ? 1 : 0;
              break;
            case 32:
              chClass = inSquareBrackets ? 0 : 1;
              break;
            default:
              chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
            resetStateMachine = true;
          }
        } else if (state === 12) {
          let chClass;
          if (chCode === 91) {
            hasOpenSquareBracket = true;
            chClass = 0;
          } else {
            chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            resetStateMachine = true;
          } else {
            state = 13;
          }
        } else {
          state = stateMachine.nextState(state, chCode);
          if (state === 0) {
            resetStateMachine = true;
          }
        }
        if (resetStateMachine) {
          state = 1;
          hasOpenParens = false;
          hasOpenSquareBracket = false;
          hasOpenCurlyBracket = false;
          linkBeginIndex = j + 1;
          linkBeginChCode = chCode;
        }
        j++;
      }
      if (state === 13) {
        result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
      }
    }
    return result;
  }
};

// out-build/vs/workbench/api/common/extHostFileSystem.js
var FsLinkProvider = class {
  constructor() {
    this._schemes = [];
  }
  add(scheme) {
    this._stateMachine = void 0;
    this._schemes.push(scheme);
  }
  delete(scheme) {
    const idx = this._schemes.indexOf(scheme);
    if (idx >= 0) {
      this._schemes.splice(idx, 1);
      this._stateMachine = void 0;
    }
  }
  _initStateMachine() {
    if (!this._stateMachine) {
      const schemes = this._schemes.sort();
      const edges = [];
      let prevScheme;
      let prevState;
      let lastState = 14;
      let nextState = 14;
      for (const scheme of schemes) {
        let pos = !prevScheme ? 0 : commonPrefixLength(prevScheme, scheme);
        if (pos === 0) {
          prevState = 1;
        } else {
          prevState = nextState;
        }
        for (; pos < scheme.length; pos++) {
          if (pos + 1 === scheme.length) {
            lastState = nextState;
            nextState = 9;
          } else {
            nextState += 1;
          }
          edges.push([prevState, scheme.toUpperCase().charCodeAt(pos), nextState]);
          edges.push([prevState, scheme.toLowerCase().charCodeAt(pos), nextState]);
          prevState = nextState;
        }
        prevScheme = scheme;
        nextState = lastState;
      }
      edges.push([
        9,
        58,
        10
        /* State.AfterColon */
      ]);
      edges.push([
        10,
        47,
        12
        /* State.End */
      ]);
      this._stateMachine = new StateMachine(edges);
    }
  }
  provideDocumentLinks(document2) {
    this._initStateMachine();
    const result = [];
    const links = LinkComputer.computeLinks({
      getLineContent(lineNumber) {
        return document2.lineAt(lineNumber - 1).text;
      },
      getLineCount() {
        return document2.lineCount;
      }
    }, this._stateMachine);
    for (const link2 of links) {
      const docLink = DocumentLink3.to(link2);
      if (docLink.target) {
        result.push(docLink);
      }
    }
    return result;
  }
};
var ExtHostFileSystem = class _ExtHostFileSystem {
  constructor(mainContext, _extHostLanguageFeatures) {
    this._extHostLanguageFeatures = _extHostLanguageFeatures;
    this._linkProvider = new FsLinkProvider();
    this._fsProvider = /* @__PURE__ */ new Map();
    this._registeredSchemes = /* @__PURE__ */ new Set();
    this._watches = /* @__PURE__ */ new Map();
    this._handlePool = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadFileSystem);
  }
  dispose() {
    this._linkProviderRegistration?.dispose();
  }
  registerFileSystemProvider(extension, scheme, provider, options2 = {}) {
    _ExtHostFileSystem._validateFileSystemProvider(provider);
    if (this._registeredSchemes.has(scheme)) {
      throw new Error(`a provider for the scheme '${scheme}' is already registered`);
    }
    if (!this._linkProviderRegistration) {
      this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(extension, "*", this._linkProvider);
    }
    const handle = this._handlePool++;
    this._linkProvider.add(scheme);
    this._registeredSchemes.add(scheme);
    this._fsProvider.set(handle, provider);
    let capabilities = 2;
    if (options2.isCaseSensitive) {
      capabilities += 1024;
    }
    if (options2.isReadonly) {
      capabilities += 2048;
    }
    if (typeof provider.copy === "function") {
      capabilities += 8;
    }
    if (typeof provider.open === "function" && typeof provider.close === "function" && typeof provider.read === "function" && typeof provider.write === "function") {
      checkProposedApiEnabled(extension, "fsChunks");
      capabilities += 4;
    }
    let readOnlyMessage;
    if (options2.isReadonly && isMarkdownString(options2.isReadonly) && options2.isReadonly.value !== "") {
      readOnlyMessage = {
        value: options2.isReadonly.value,
        isTrusted: options2.isReadonly.isTrusted,
        supportThemeIcons: options2.isReadonly.supportThemeIcons,
        supportHtml: options2.isReadonly.supportHtml,
        baseUri: options2.isReadonly.baseUri,
        uris: options2.isReadonly.uris
      };
    }
    this._proxy.$registerFileSystemProvider(handle, scheme, capabilities, readOnlyMessage).catch((err) => {
      console.error(`FAILED to register filesystem provider of ${extension.identifier.value}-extension for the scheme ${scheme}`);
      console.error(err);
    });
    const subscription = provider.onDidChangeFile((event) => {
      const mapped = [];
      for (const e of event) {
        const { uri: resource, type } = e;
        if (resource.scheme !== scheme) {
          continue;
        }
        let newType;
        switch (type) {
          case FileChangeType2.Changed:
            newType = 0;
            break;
          case FileChangeType2.Created:
            newType = 1;
            break;
          case FileChangeType2.Deleted:
            newType = 2;
            break;
          default:
            throw new Error("Unknown FileChangeType");
        }
        mapped.push({ resource, type: newType });
      }
      this._proxy.$onFileSystemChange(handle, mapped);
    });
    return toDisposable(() => {
      subscription.dispose();
      this._linkProvider.delete(scheme);
      this._registeredSchemes.delete(scheme);
      this._fsProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  static _validateFileSystemProvider(provider) {
    if (!provider) {
      throw new Error("MISSING provider");
    }
    if (typeof provider.watch !== "function") {
      throw new Error("Provider does NOT implement watch");
    }
    if (typeof provider.stat !== "function") {
      throw new Error("Provider does NOT implement stat");
    }
    if (typeof provider.readDirectory !== "function") {
      throw new Error("Provider does NOT implement readDirectory");
    }
    if (typeof provider.createDirectory !== "function") {
      throw new Error("Provider does NOT implement createDirectory");
    }
    if (typeof provider.readFile !== "function") {
      throw new Error("Provider does NOT implement readFile");
    }
    if (typeof provider.writeFile !== "function") {
      throw new Error("Provider does NOT implement writeFile");
    }
    if (typeof provider.delete !== "function") {
      throw new Error("Provider does NOT implement delete");
    }
    if (typeof provider.rename !== "function") {
      throw new Error("Provider does NOT implement rename");
    }
  }
  static _asIStat(stat) {
    const { type, ctime, mtime, size, permissions } = stat;
    return { type, ctime, mtime, size, permissions };
  }
  $stat(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).stat(URI.revive(resource))).then((stat) => _ExtHostFileSystem._asIStat(stat));
  }
  $readdir(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).readDirectory(URI.revive(resource)));
  }
  $readFile(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).readFile(URI.revive(resource))).then((data2) => VSBuffer.wrap(data2));
  }
  $writeFile(handle, resource, content, opts) {
    return Promise.resolve(this._getFsProvider(handle).writeFile(URI.revive(resource), content.buffer, opts));
  }
  $delete(handle, resource, opts) {
    return Promise.resolve(this._getFsProvider(handle).delete(URI.revive(resource), opts));
  }
  $rename(handle, oldUri, newUri, opts) {
    return Promise.resolve(this._getFsProvider(handle).rename(URI.revive(oldUri), URI.revive(newUri), opts));
  }
  $copy(handle, oldUri, newUri, opts) {
    const provider = this._getFsProvider(handle);
    if (!provider.copy) {
      throw new Error('FileSystemProvider does not implement "copy"');
    }
    return Promise.resolve(provider.copy(URI.revive(oldUri), URI.revive(newUri), opts));
  }
  $mkdir(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).createDirectory(URI.revive(resource)));
  }
  $watch(handle, session, resource, opts) {
    const subscription = this._getFsProvider(handle).watch(URI.revive(resource), opts);
    this._watches.set(session, subscription);
  }
  $unwatch(_handle, session) {
    const subscription = this._watches.get(session);
    if (subscription) {
      subscription.dispose();
      this._watches.delete(session);
    }
  }
  $open(handle, resource, opts) {
    const provider = this._getFsProvider(handle);
    if (!provider.open) {
      throw new Error('FileSystemProvider does not implement "open"');
    }
    return Promise.resolve(provider.open(URI.revive(resource), opts));
  }
  $close(handle, fd) {
    const provider = this._getFsProvider(handle);
    if (!provider.close) {
      throw new Error('FileSystemProvider does not implement "close"');
    }
    return Promise.resolve(provider.close(fd));
  }
  $read(handle, fd, pos, length) {
    const provider = this._getFsProvider(handle);
    if (!provider.read) {
      throw new Error('FileSystemProvider does not implement "read"');
    }
    const data2 = VSBuffer.alloc(length);
    return Promise.resolve(provider.read(fd, pos, data2.buffer, 0, length)).then((read) => {
      return data2.slice(0, read);
    });
  }
  $write(handle, fd, pos, data2) {
    const provider = this._getFsProvider(handle);
    if (!provider.write) {
      throw new Error('FileSystemProvider does not implement "write"');
    }
    return Promise.resolve(provider.write(fd, pos, data2.buffer, 0, data2.byteLength));
  }
  _getFsProvider(handle) {
    const provider = this._fsProvider.get(handle);
    if (!provider) {
      const err = new Error();
      err.name = "ENOPRO";
      err.message = `no provider`;
      throw err;
    }
    return provider;
  }
};

// out-build/vs/platform/files/common/watcher.js
var AbstractWatcherClient = class _AbstractWatcherClient extends Disposable {
  static {
    this.MAX_RESTARTS = 5;
  }
  constructor(onFileChanges, onLogMessage, verboseLogging, options2) {
    super();
    this.onFileChanges = onFileChanges;
    this.onLogMessage = onLogMessage;
    this.verboseLogging = verboseLogging;
    this.options = options2;
    this.watcherDisposables = this._register(new MutableDisposable());
    this.requests = void 0;
    this.restartCounter = 0;
  }
  init() {
    const disposables = new DisposableStore();
    this.watcherDisposables.value = disposables;
    this.watcher = this.createWatcher(disposables);
    this.watcher.setVerboseLogging(this.verboseLogging);
    disposables.add(this.watcher.onDidChangeFile((changes) => this.onFileChanges(changes)));
    disposables.add(this.watcher.onDidLogMessage((msg) => this.onLogMessage(msg)));
    disposables.add(this.watcher.onDidError((e) => this.onError(e.error, e.request)));
  }
  onError(error, failedRequest) {
    if (this.canRestart(error, failedRequest)) {
      if (this.restartCounter < _AbstractWatcherClient.MAX_RESTARTS && this.requests) {
        this.error(`restarting watcher after unexpected error: ${error}`);
        this.restart(this.requests);
      } else {
        this.error(`gave up attempting to restart watcher after unexpected error: ${error}`);
      }
    } else {
      this.error(error);
    }
  }
  canRestart(error, failedRequest) {
    if (!this.options.restartOnError) {
      return false;
    }
    if (failedRequest) {
      return false;
    }
    if (error.indexOf("No space left on device") !== -1 || error.indexOf("EMFILE") !== -1) {
      return false;
    }
    return true;
  }
  restart(requests) {
    this.restartCounter++;
    this.init();
    this.watch(requests);
  }
  async watch(requests) {
    this.requests = requests;
    await this.watcher?.watch(requests);
  }
  async setVerboseLogging(verboseLogging) {
    this.verboseLogging = verboseLogging;
    await this.watcher?.setVerboseLogging(verboseLogging);
  }
  error(message) {
    this.onLogMessage({ type: "error", message: `[File Watcher (${this.options.type})] ${message}` });
  }
  trace(message) {
    this.onLogMessage({ type: "trace", message: `[File Watcher (${this.options.type})] ${message}` });
  }
  dispose() {
    this.watcher = void 0;
    return super.dispose();
  }
};
function normalizeWatcherPattern(path, pattern) {
  if (typeof pattern === "string" && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {
    return { base: path, pattern };
  }
  return pattern;
}

// out-build/vs/workbench/api/common/extHostFileSystemEventService.js
var FileSystemWatcher = class {
  get ignoreCreateEvents() {
    return Boolean(this._config & 1);
  }
  get ignoreChangeEvents() {
    return Boolean(this._config & 2);
  }
  get ignoreDeleteEvents() {
    return Boolean(this._config & 4);
  }
  constructor(mainContext, configuration, workspace, extension, dispatcher, globPattern, options2) {
    this.session = Math.random();
    this._onDidCreate = new Emitter();
    this._onDidChange = new Emitter();
    this._onDidDelete = new Emitter();
    this._config = 0;
    if (options2.ignoreCreateEvents) {
      this._config += 1;
    }
    if (options2.ignoreChangeEvents) {
      this._config += 2;
    }
    if (options2.ignoreDeleteEvents) {
      this._config += 4;
    }
    const parsedPattern = parse3(globPattern);
    const excludeOutOfWorkspaceEvents = typeof globPattern === "string";
    const excludeUncorrelatedEvents = false;
    const subscription = dispatcher((events) => {
      if (typeof events.session === "number" && events.session !== this.session) {
        return;
      }
      if (excludeUncorrelatedEvents && typeof events.session === "undefined") {
        return;
      }
      if (!options2.ignoreCreateEvents) {
        for (const created of events.created) {
          const uri = URI.revive(created);
          if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
            this._onDidCreate.fire(uri);
          }
        }
      }
      if (!options2.ignoreChangeEvents) {
        for (const changed of events.changed) {
          const uri = URI.revive(changed);
          if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
            this._onDidChange.fire(uri);
          }
        }
      }
      if (!options2.ignoreDeleteEvents) {
        for (const deleted of events.deleted) {
          const uri = URI.revive(deleted);
          if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
            this._onDidDelete.fire(uri);
          }
        }
      }
    });
    this._disposable = Disposable2.from(this.ensureWatching(mainContext, workspace, configuration, extension, globPattern, options2, false), this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);
  }
  ensureWatching(mainContext, workspace, configuration, extension, globPattern, options2, correlate) {
    const disposable = Disposable2.from();
    if (typeof globPattern === "string") {
      return disposable;
    }
    if (options2.ignoreChangeEvents && options2.ignoreCreateEvents && options2.ignoreDeleteEvents) {
      return disposable;
    }
    const proxy = mainContext.getProxy(MainContext.MainThreadFileSystemEventService);
    let recursive = false;
    if (globPattern.pattern.includes(GLOBSTAR) || globPattern.pattern.includes(GLOB_SPLIT)) {
      recursive = true;
    }
    const excludes = [];
    let includes = void 0;
    let filter2;
    if (correlate) {
      if (options2.ignoreChangeEvents || options2.ignoreCreateEvents || options2.ignoreDeleteEvents) {
        filter2 = 2 | 4 | 8;
        if (options2.ignoreChangeEvents) {
          filter2 &= ~2;
        }
        if (options2.ignoreCreateEvents) {
          filter2 &= ~4;
        }
        if (options2.ignoreDeleteEvents) {
          filter2 &= ~8;
        }
      }
    } else {
      if (recursive && excludes.length === 0) {
        const workspaceFolder = workspace.getWorkspaceFolder(URI.revive(globPattern.baseUri));
        const watcherExcludes = configuration.getConfiguration("files", workspaceFolder).get("watcherExclude");
        if (watcherExcludes) {
          for (const key in watcherExcludes) {
            if (key && watcherExcludes[key] === true) {
              excludes.push(key);
            }
          }
        }
      } else if (!recursive) {
        const workspaceFolder = workspace.getWorkspaceFolder(URI.revive(globPattern.baseUri));
        if (workspaceFolder) {
          const watcherExcludes = configuration.getConfiguration("files", workspaceFolder).get("watcherExclude");
          if (watcherExcludes) {
            for (const key in watcherExcludes) {
              if (key && watcherExcludes[key] === true) {
                const includePattern = `${rtrim(key, "/")}/${GLOBSTAR}`;
                if (!includes) {
                  includes = [];
                }
                includes.push(normalizeWatcherPattern(workspaceFolder.uri.fsPath, includePattern));
              }
            }
          }
          if (!includes || includes.length === 0) {
            return disposable;
          }
        }
      }
    }
    proxy.$watch(extension.identifier.value, this.session, globPattern.baseUri, { recursive, excludes, includes, filter: filter2 }, Boolean(correlate));
    return Disposable2.from({ dispose: () => proxy.$unwatch(this.session) });
  }
  dispose() {
    this._disposable.dispose();
  }
  get onDidCreate() {
    return this._onDidCreate.event;
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get onDidDelete() {
    return this._onDidDelete.event;
  }
};
var LazyRevivedFileSystemEvents = class {
  get created() {
    return this._created.value;
  }
  get changed() {
    return this._changed.value;
  }
  get deleted() {
    return this._deleted.value;
  }
  constructor(_events) {
    this._events = _events;
    this._created = new Lazy(() => this._events.created.map(URI.revive));
    this._changed = new Lazy(() => this._events.changed.map(URI.revive));
    this._deleted = new Lazy(() => this._events.deleted.map(URI.revive));
    this.session = this._events.session;
  }
};
var ExtHostFileSystemEventService = class {
  constructor(_mainContext, _logService, _extHostDocumentsAndEditors) {
    this._mainContext = _mainContext;
    this._logService = _logService;
    this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
    this._onFileSystemEvent = new Emitter();
    this._onDidRenameFile = new Emitter();
    this._onDidCreateFile = new Emitter();
    this._onDidDeleteFile = new Emitter();
    this._onWillRenameFile = new AsyncEmitter();
    this._onWillCreateFile = new AsyncEmitter();
    this._onWillDeleteFile = new AsyncEmitter();
    this.onDidRenameFile = this._onDidRenameFile.event;
    this.onDidCreateFile = this._onDidCreateFile.event;
    this.onDidDeleteFile = this._onDidDeleteFile.event;
  }
  //--- file events
  createFileSystemWatcher(workspace, configProvider, extension, globPattern, options2) {
    return new FileSystemWatcher(this._mainContext, configProvider, workspace, extension, this._onFileSystemEvent.event, GlobPattern.from(globPattern), options2);
  }
  $onFileEvent(events) {
    this._onFileSystemEvent.fire(new LazyRevivedFileSystemEvents(events));
  }
  //--- file operations
  $onDidRunFileOperation(operation, files) {
    switch (operation) {
      case 2:
        this._onDidRenameFile.fire(Object.freeze({ files: files.map((f) => ({ oldUri: URI.revive(f.source), newUri: URI.revive(f.target) })) }));
        break;
      case 1:
        this._onDidDeleteFile.fire(Object.freeze({ files: files.map((f) => URI.revive(f.target)) }));
        break;
      case 0:
      case 3:
        this._onDidCreateFile.fire(Object.freeze({ files: files.map((f) => URI.revive(f.target)) }));
        break;
      default:
    }
  }
  getOnWillRenameFileEvent(extension) {
    return this._createWillExecuteEvent(extension, this._onWillRenameFile);
  }
  getOnWillCreateFileEvent(extension) {
    return this._createWillExecuteEvent(extension, this._onWillCreateFile);
  }
  getOnWillDeleteFileEvent(extension) {
    return this._createWillExecuteEvent(extension, this._onWillDeleteFile);
  }
  _createWillExecuteEvent(extension, emitter) {
    return (listener, thisArg, disposables) => {
      const wrappedListener = function wrapped(e) {
        listener.call(thisArg, e);
      };
      wrappedListener.extension = extension;
      return emitter.event(wrappedListener, void 0, disposables);
    };
  }
  async $onWillRunFileOperation(operation, files, timeout2, token) {
    switch (operation) {
      case 2:
        return await this._fireWillEvent(this._onWillRenameFile, { files: files.map((f) => ({ oldUri: URI.revive(f.source), newUri: URI.revive(f.target) })) }, timeout2, token);
      case 1:
        return await this._fireWillEvent(this._onWillDeleteFile, { files: files.map((f) => URI.revive(f.target)) }, timeout2, token);
      case 0:
      case 3:
        return await this._fireWillEvent(this._onWillCreateFile, { files: files.map((f) => URI.revive(f.target)) }, timeout2, token);
    }
    return void 0;
  }
  async _fireWillEvent(emitter, data2, timeout2, token) {
    const extensionNames = /* @__PURE__ */ new Set();
    const edits = [];
    await emitter.fireAsync(data2, token, async (thenable, listener) => {
      const now = Date.now();
      const result = await Promise.resolve(thenable);
      if (result instanceof WorkspaceEdit) {
        edits.push([listener.extension, result]);
        extensionNames.add(listener.extension.displayName ?? listener.extension.identifier.value);
      }
      if (Date.now() - now > timeout2) {
        this._logService.warn("SLOW file-participant", listener.extension.identifier);
      }
    });
    if (token.isCancellationRequested) {
      return void 0;
    }
    if (edits.length === 0) {
      return void 0;
    }
    const dto = { edits: [] };
    for (const [, edit2] of edits) {
      const { edits: edits2 } = WorkspaceEdit3.from(edit2, {
        getTextDocumentVersion: (uri) => this._extHostDocumentsAndEditors.getDocument(uri)?.version,
        getNotebookDocumentVersion: () => void 0
      });
      dto.edits = dto.edits.concat(edits2);
    }
    return { edit: dto, extensionNames: Array.from(extensionNames) };
  }
};

// out-build/vs/workbench/api/common/extHostInteractive.js
var ExtHostInteractive = class {
  constructor(mainContext, _extHostNotebooks, _textDocumentsAndEditors, _commands, _logService) {
    this._extHostNotebooks = _extHostNotebooks;
    this._textDocumentsAndEditors = _textDocumentsAndEditors;
    this._commands = _commands;
    const openApiCommand = new ApiCommand("interactive.open", "_interactive.open", "Open interactive window and return notebook editor and input URI", [
      new ApiCommandArgument("showOptions", "Show Options", (v) => true, (v) => v),
      new ApiCommandArgument("resource", "Interactive resource Uri", (v) => true, (v) => v),
      new ApiCommandArgument("controllerId", "Notebook controller Id", (v) => true, (v) => v),
      new ApiCommandArgument("title", "Interactive editor title", (v) => true, (v) => v)
    ], new ApiCommandResult("Notebook and input URI", (v) => {
      _logService.debug("[ExtHostInteractive] open iw with notebook editor id", v.notebookEditorId);
      if (v.notebookEditorId !== void 0) {
        const editor = this._extHostNotebooks.getEditorById(v.notebookEditorId);
        _logService.debug("[ExtHostInteractive] notebook editor found", editor.id);
        return { notebookUri: URI.revive(v.notebookUri), inputUri: URI.revive(v.inputUri), notebookEditor: editor.apiEditor };
      }
      _logService.debug("[ExtHostInteractive] notebook editor not found, uris for the interactive document", v.notebookUri, v.inputUri);
      return { notebookUri: URI.revive(v.notebookUri), inputUri: URI.revive(v.inputUri) };
    }));
    this._commands.registerApiCommand(openApiCommand);
  }
  $willAddInteractiveDocument(uri, eol, languageId, notebookUri) {
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      addedDocuments: [{
        EOL: eol,
        lines: [""],
        languageId,
        uri,
        isDirty: false,
        versionId: 1,
        encoding: "utf8"
      }]
    });
  }
  $willRemoveInteractiveDocument(uri, notebookUri) {
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      removedDocuments: [uri]
    });
  }
};

// out-build/vs/workbench/api/common/extHostLabelService.js
var ExtHostLabelService = class {
  constructor(mainContext) {
    this._handlePool = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadLabelService);
  }
  $registerResourceLabelFormatter(formatter) {
    const handle = this._handlePool++;
    this._proxy.$registerResourceLabelFormatter(handle, formatter);
    return toDisposable(() => {
      this._proxy.$unregisterResourceLabelFormatter(handle);
    });
  }
};

// out-build/vs/editor/common/core/selection.js
var SelectionDirection;
(function(SelectionDirection2) {
  SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
  SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var Selection4 = class _Selection extends Range {
  constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
    super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
    this.selectionStartLineNumber = selectionStartLineNumber;
    this.selectionStartColumn = selectionStartColumn;
    this.positionLineNumber = positionLineNumber;
    this.positionColumn = positionColumn;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(other) {
    return _Selection.selectionsEqual(this, other);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(a, b) {
    return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
      return 0;
    }
    return 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(endLineNumber, endColumn) {
    if (this.getDirection() === 0) {
      return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new Position(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(startLineNumber, startColumn) {
    if (this.getDirection() === 0) {
      return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(start, end = start) {
    return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(range, direction) {
    if (direction === 0) {
      return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    } else {
      return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
    }
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(sel) {
    return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(a, b) {
    if (a && !b || !a && b) {
      return false;
    }
    if (!a && !b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length; i < len; i++) {
      if (!this.selectionsEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(obj) {
    return !!obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
    if (direction === 0) {
      return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
  }
};

// out-build/vs/workbench/api/common/extHostLanguageFeatures.js
var DocumentSymbolAdapter = class _DocumentSymbolAdapter {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentSymbols(resource, token) {
    const doc = this._documents.getDocument(resource);
    const value = await this._provider.provideDocumentSymbols(doc, token);
    if (isFalsyOrEmpty(value)) {
      return void 0;
    } else if (value[0] instanceof DocumentSymbol) {
      return value.map(DocumentSymbol3.from);
    } else {
      return _DocumentSymbolAdapter._asDocumentSymbolTree(value);
    }
  }
  static _asDocumentSymbolTree(infos) {
    infos = infos.slice(0).sort((a, b) => {
      let res2 = a.location.range.start.compareTo(b.location.range.start);
      if (res2 === 0) {
        res2 = b.location.range.end.compareTo(a.location.range.end);
      }
      return res2;
    });
    const res = [];
    const parentStack = [];
    for (const info of infos) {
      const element = {
        name: info.name || "!!MISSING: name!!",
        kind: SymbolKind3.from(info.kind),
        tags: info.tags?.map(SymbolTag3.from) || [],
        detail: "",
        containerName: info.containerName,
        range: Range4.from(info.location.range),
        selectionRange: Range4.from(info.location.range),
        children: []
      };
      while (true) {
        if (parentStack.length === 0) {
          parentStack.push(element);
          res.push(element);
          break;
        }
        const parent = parentStack[parentStack.length - 1];
        if (Range.containsRange(parent.range, element.range) && !Range.equalsRange(parent.range, element.range)) {
          parent.children?.push(element);
          parentStack.push(element);
          break;
        }
        parentStack.pop();
      }
    }
    return res;
  }
};
var CodeLensAdapter = class {
  constructor(_documents, _commands, _provider, _extension, _extTelemetry, _logService) {
    this._documents = _documents;
    this._commands = _commands;
    this._provider = _provider;
    this._extension = _extension;
    this._extTelemetry = _extTelemetry;
    this._logService = _logService;
    this._cache = new Cache2("CodeLens");
    this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCodeLenses(resource, token) {
    const doc = this._documents.getDocument(resource);
    const lenses = await this._provider.provideCodeLenses(doc, token);
    if (!lenses || token.isCancellationRequested) {
      return void 0;
    }
    const cacheId = this._cache.add(lenses);
    const disposables = new DisposableStore();
    this._disposables.set(cacheId, disposables);
    const result = {
      cacheId,
      lenses: []
    };
    for (let i = 0; i < lenses.length; i++) {
      if (!Range2.isRange(lenses[i].range)) {
        console.warn("INVALID code lens, range is not defined", this._extension.identifier.value);
        continue;
      }
      result.lenses.push({
        cacheId: [cacheId, i],
        range: Range4.from(lenses[i].range),
        command: this._commands.toInternal(lenses[i].command, disposables)
      });
    }
    return result;
  }
  async resolveCodeLens(symbol, token) {
    const lens = symbol.cacheId && this._cache.get(...symbol.cacheId);
    if (!lens) {
      return void 0;
    }
    let resolvedLens;
    if (typeof this._provider.resolveCodeLens !== "function" || lens.isResolved) {
      resolvedLens = lens;
    } else {
      resolvedLens = await this._provider.resolveCodeLens(lens, token);
    }
    if (!resolvedLens) {
      resolvedLens = lens;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    const disposables = symbol.cacheId && this._disposables.get(symbol.cacheId[0]);
    if (!disposables) {
      return void 0;
    }
    if (!resolvedLens.command) {
      const error = new Error("INVALID code lens resolved, lacks command: " + this._extension.identifier.value);
      this._extTelemetry.onExtensionError(this._extension.identifier, error);
      this._logService.error(error);
      return void 0;
    }
    symbol.command = this._commands.toInternal(resolvedLens.command, disposables);
    return symbol;
  }
  releaseCodeLenses(cachedId) {
    this._disposables.get(cachedId)?.dispose();
    this._disposables.delete(cachedId);
    this._cache.delete(cachedId);
  }
};
function convertToLocationLinks(value) {
  if (Array.isArray(value)) {
    return value.map(DefinitionLink.from);
  } else if (value) {
    return [DefinitionLink.from(value)];
  }
  return [];
}
var DefinitionAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDefinition(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideDefinition(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var DeclarationAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDeclaration(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideDeclaration(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var ImplementationAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideImplementation(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideImplementation(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var TypeDefinitionAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideTypeDefinition(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideTypeDefinition(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var HoverAdapter = class _HoverAdapter {
  static {
    this.HOVER_MAP_MAX_SIZE = 10;
  }
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._hoverCounter = 0;
    this._hoverMap = /* @__PURE__ */ new Map();
  }
  async provideHover(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    let value;
    if (context && context.verbosityRequest) {
      const previousHoverId = context.verbosityRequest.previousHover.id;
      const previousHover = this._hoverMap.get(previousHoverId);
      if (!previousHover) {
        throw new Error(`Hover with id ${previousHoverId} not found`);
      }
      const hoverContext = { verbosityDelta: context.verbosityRequest.verbosityDelta, previousHover };
      value = await this._provider.provideHover(doc, pos, token, hoverContext);
    } else {
      value = await this._provider.provideHover(doc, pos, token);
    }
    if (!value || isFalsyOrEmpty(value.contents)) {
      return void 0;
    }
    if (!value.range) {
      value.range = doc.getWordRangeAtPosition(pos);
    }
    if (!value.range) {
      value.range = new Range2(pos, pos);
    }
    const convertedHover = Hover3.from(value);
    const id2 = this._hoverCounter;
    if (this._hoverMap.size === _HoverAdapter.HOVER_MAP_MAX_SIZE) {
      const minimumId = Math.min(...this._hoverMap.keys());
      this._hoverMap.delete(minimumId);
    }
    this._hoverMap.set(id2, value);
    this._hoverCounter += 1;
    const hover = {
      ...convertedHover,
      id: id2
    };
    return hover;
  }
  releaseHover(id2) {
    this._hoverMap.delete(id2);
  }
};
var EvaluatableExpressionAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideEvaluatableExpression(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideEvaluatableExpression(doc, pos, token);
    if (value) {
      return EvaluatableExpression3.from(value);
    }
    return void 0;
  }
};
var InlineValuesAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideInlineValues(resource, viewPort, context, token) {
    const doc = this._documents.getDocument(resource);
    const value = await this._provider.provideInlineValues(doc, Range4.to(viewPort), InlineValueContext3.to(context), token);
    if (Array.isArray(value)) {
      return value.map((iv) => InlineValue.from(iv));
    }
    return void 0;
  }
};
var DocumentHighlightAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentHighlights(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideDocumentHighlights(doc, pos, token);
    if (Array.isArray(value)) {
      return value.map(DocumentHighlight3.from);
    }
    return void 0;
  }
};
var MultiDocumentHighlightAdapter = class {
  constructor(_documents, _provider, _logService) {
    this._documents = _documents;
    this._provider = _provider;
    this._logService = _logService;
  }
  async provideMultiDocumentHighlights(resource, position, otherResources, token) {
    const doc = this._documents.getDocument(resource);
    const otherDocuments = otherResources.map((r) => {
      try {
        return this._documents.getDocument(r);
      } catch (err) {
        this._logService.error("Error: Unable to retrieve document from URI: " + r + ". Error message: " + err);
        return void 0;
      }
    }).filter((doc2) => doc2 !== void 0);
    const pos = Position4.to(position);
    const value = await this._provider.provideMultiDocumentHighlights(doc, pos, otherDocuments, token);
    if (Array.isArray(value)) {
      return value.map(MultiDocumentHighlight3.from);
    }
    return void 0;
  }
};
var LinkedEditingRangeAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideLinkedEditingRanges(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideLinkedEditingRanges(doc, pos, token);
    if (value && Array.isArray(value.ranges)) {
      return {
        ranges: coalesce(value.ranges.map(Range4.from)),
        wordPattern: value.wordPattern
      };
    }
    return void 0;
  }
};
var ReferenceAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideReferences(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideReferences(doc, pos, context, token);
    if (Array.isArray(value)) {
      return value.map(location.from);
    }
    return void 0;
  }
};
var CodeActionAdapter = class _CodeActionAdapter {
  static {
    this._maxCodeActionsPerFile = 1e3;
  }
  constructor(_documents, _commands, _diagnostics, _provider, _logService, _extension, _apiDeprecation) {
    this._documents = _documents;
    this._commands = _commands;
    this._diagnostics = _diagnostics;
    this._provider = _provider;
    this._logService = _logService;
    this._extension = _extension;
    this._apiDeprecation = _apiDeprecation;
    this._cache = new Cache2("CodeAction");
    this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCodeActions(resource, rangeOrSelection, context, token) {
    const doc = this._documents.getDocument(resource);
    const ran = Selection4.isISelection(rangeOrSelection) ? Selection3.to(rangeOrSelection) : Range4.to(rangeOrSelection);
    const allDiagnostics = [];
    for (const diagnostic of this._diagnostics.getDiagnostics(resource)) {
      if (ran.intersection(diagnostic.range)) {
        const newLen = allDiagnostics.push(diagnostic);
        if (newLen > _CodeActionAdapter._maxCodeActionsPerFile) {
          break;
        }
      }
    }
    const codeActionContext = {
      diagnostics: allDiagnostics,
      only: context.only ? new CodeActionKind(context.only) : void 0,
      triggerKind: CodeActionTriggerKind2.to(context.trigger)
    };
    const commandsOrActions = await this._provider.provideCodeActions(doc, ran, codeActionContext, token);
    if (!isNonEmptyArray(commandsOrActions) || token.isCancellationRequested) {
      return void 0;
    }
    const cacheId = this._cache.add(commandsOrActions);
    const disposables = new DisposableStore();
    this._disposables.set(cacheId, disposables);
    const actions = [];
    for (let i = 0; i < commandsOrActions.length; i++) {
      const candidate = commandsOrActions[i];
      if (!candidate) {
        continue;
      }
      if (_CodeActionAdapter._isCommand(candidate) && !(candidate instanceof CodeAction)) {
        this._apiDeprecation.report("CodeActionProvider.provideCodeActions - return commands", this._extension, `Return 'CodeAction' instances instead.`);
        actions.push({
          _isSynthetic: true,
          title: candidate.title,
          command: this._commands.toInternal(candidate, disposables)
        });
      } else {
        const toConvert = candidate;
        if (codeActionContext.only) {
          if (!toConvert.kind) {
            this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);
          } else if (!codeActionContext.only.contains(toConvert.kind)) {
            this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action is of kind '${toConvert.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`);
          }
        }
        const range = toConvert.ranges ?? [];
        actions.push({
          cacheId: [cacheId, i],
          title: toConvert.title,
          command: toConvert.command && this._commands.toInternal(toConvert.command, disposables),
          diagnostics: toConvert.diagnostics && toConvert.diagnostics.map(Diagnostic3.from),
          edit: toConvert.edit && WorkspaceEdit3.from(toConvert.edit, void 0),
          kind: toConvert.kind && toConvert.kind.value,
          isPreferred: toConvert.isPreferred,
          isAI: isProposedApiEnabled(this._extension, "codeActionAI") ? toConvert.isAI : false,
          ranges: isProposedApiEnabled(this._extension, "codeActionRanges") ? coalesce(range.map(Range4.from)) : void 0,
          disabled: toConvert.disabled?.reason
        });
      }
    }
    return { cacheId, actions };
  }
  async resolveCodeAction(id2, token) {
    const [sessionId, itemId] = id2;
    const item = this._cache.get(sessionId, itemId);
    if (!item || _CodeActionAdapter._isCommand(item)) {
      return {};
    }
    if (!this._provider.resolveCodeAction) {
      return {};
    }
    const resolvedItem = await this._provider.resolveCodeAction(item, token) ?? item;
    let resolvedEdit;
    if (resolvedItem.edit) {
      resolvedEdit = WorkspaceEdit3.from(resolvedItem.edit, void 0);
    }
    let resolvedCommand;
    if (resolvedItem.command) {
      const disposables = this._disposables.get(sessionId);
      if (disposables) {
        resolvedCommand = this._commands.toInternal(resolvedItem.command, disposables);
      }
    }
    return { edit: resolvedEdit, command: resolvedCommand };
  }
  releaseCodeActions(cachedId) {
    this._disposables.get(cachedId)?.dispose();
    this._disposables.delete(cachedId);
    this._cache.delete(cachedId);
  }
  static _isCommand(thing) {
    return typeof thing.command === "string" && typeof thing.title === "string";
  }
};
var DocumentPasteEditProvider = class {
  constructor(_proxy, _documents, _provider, _handle, _extension) {
    this._proxy = _proxy;
    this._documents = _documents;
    this._provider = _provider;
    this._handle = _handle;
    this._extension = _extension;
    this._editsCache = new Cache2("DocumentPasteEdit.edits");
  }
  async prepareDocumentPaste(resource, ranges, dataTransferDto, token) {
    if (!this._provider.prepareDocumentPaste) {
      return;
    }
    this._cachedPrepare = void 0;
    const doc = this._documents.getDocument(resource);
    const vscodeRanges = ranges.map((range) => Range4.to(range));
    const dataTransfer = DataTransfer3.toDataTransfer(dataTransferDto, () => {
      throw new NotImplementedError();
    });
    await this._provider.prepareDocumentPaste(doc, vscodeRanges, dataTransfer, token);
    if (token.isCancellationRequested) {
      return;
    }
    const newEntries = Array.from(dataTransfer).filter(([, value]) => !(value instanceof InternalDataTransferItem));
    const newCache = /* @__PURE__ */ new Map();
    const items = await Promise.all(Array.from(newEntries, async ([mime, value]) => {
      const id2 = generateUuid();
      newCache.set(id2, value);
      return [mime, await DataTransferItem3.from(mime, value, id2)];
    }));
    this._cachedPrepare = newCache;
    return { items };
  }
  async providePasteEdits(requestId, resource, ranges, dataTransferDto, context, token) {
    if (!this._provider.provideDocumentPasteEdits) {
      return [];
    }
    const doc = this._documents.getDocument(resource);
    const vscodeRanges = ranges.map((range) => Range4.to(range));
    const items = dataTransferDto.items.map(([mime, value]) => {
      const cached = this._cachedPrepare?.get(value.id);
      if (cached) {
        return [mime, cached];
      }
      return [
        mime,
        DataTransferItem3.to(mime, value, async (id2) => {
          return (await this._proxy.$resolvePasteFileData(this._handle, requestId, id2)).buffer;
        })
      ];
    });
    const dataTransfer = new DataTransfer(items);
    const edits = await this._provider.provideDocumentPasteEdits(doc, vscodeRanges, dataTransfer, {
      only: context.only ? new DocumentDropOrPasteEditKind(context.only) : void 0,
      triggerKind: context.triggerKind
    }, token);
    if (!edits || token.isCancellationRequested) {
      return [];
    }
    const cacheId = this._editsCache.add(edits);
    return edits.map((edit2, i) => ({
      _cacheId: [cacheId, i],
      title: edit2.title ?? localize(3012, null, this._extension.displayName || this._extension.name),
      kind: edit2.kind,
      yieldTo: edit2.yieldTo?.map((x) => x.value),
      insertText: typeof edit2.insertText === "string" ? edit2.insertText : { snippet: edit2.insertText.value },
      additionalEdit: edit2.additionalEdit ? WorkspaceEdit3.from(edit2.additionalEdit, void 0) : void 0
    }));
  }
  async resolvePasteEdit(id2, token) {
    const [sessionId, itemId] = id2;
    const item = this._editsCache.get(sessionId, itemId);
    if (!item || !this._provider.resolveDocumentPasteEdit) {
      return {};
    }
    const resolvedItem = await this._provider.resolveDocumentPasteEdit(item, token) ?? item;
    return {
      insertText: resolvedItem.insertText,
      additionalEdit: resolvedItem.additionalEdit ? WorkspaceEdit3.from(resolvedItem.additionalEdit, void 0) : void 0
    };
  }
  releasePasteEdits(id2) {
    this._editsCache.delete(id2);
  }
};
var DocumentFormattingAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentFormattingEdits(resource, options2, token) {
    const document2 = this._documents.getDocument(resource);
    const value = await this._provider.provideDocumentFormattingEdits(document2, options2, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit3.from);
    }
    return void 0;
  }
};
var RangeFormattingAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentRangeFormattingEdits(resource, range, options2, token) {
    const document2 = this._documents.getDocument(resource);
    const ran = Range4.to(range);
    const value = await this._provider.provideDocumentRangeFormattingEdits(document2, ran, options2, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit3.from);
    }
    return void 0;
  }
  async provideDocumentRangesFormattingEdits(resource, ranges, options2, token) {
    assertType(typeof this._provider.provideDocumentRangesFormattingEdits === "function", "INVALID invocation of `provideDocumentRangesFormattingEdits`");
    const document2 = this._documents.getDocument(resource);
    const _ranges = ranges.map(Range4.to);
    const value = await this._provider.provideDocumentRangesFormattingEdits(document2, _ranges, options2, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit3.from);
    }
    return void 0;
  }
};
var OnTypeFormattingAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this.autoFormatTriggerCharacters = [];
  }
  async provideOnTypeFormattingEdits(resource, position, ch, options2, token) {
    const document2 = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const value = await this._provider.provideOnTypeFormattingEdits(document2, pos, ch, options2, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit3.from);
    }
    return void 0;
  }
};
var NavigateTypeAdapter = class {
  constructor(_provider, _logService) {
    this._provider = _provider;
    this._logService = _logService;
    this._cache = new Cache2("WorkspaceSymbols");
  }
  async provideWorkspaceSymbols(search, token) {
    const value = await this._provider.provideWorkspaceSymbols(search, token);
    if (!isNonEmptyArray(value)) {
      return { symbols: [] };
    }
    const sid = this._cache.add(value);
    const result = {
      cacheId: sid,
      symbols: []
    };
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      if (!item || !item.name) {
        this._logService.warn("INVALID SymbolInformation", item);
        continue;
      }
      result.symbols.push({
        ...WorkspaceSymbol.from(item),
        cacheId: [sid, i]
      });
    }
    return result;
  }
  async resolveWorkspaceSymbol(symbol, token) {
    if (typeof this._provider.resolveWorkspaceSymbol !== "function") {
      return symbol;
    }
    if (!symbol.cacheId) {
      return symbol;
    }
    const item = this._cache.get(...symbol.cacheId);
    if (item) {
      const value = await this._provider.resolveWorkspaceSymbol(item, token);
      return value && mixin(symbol, WorkspaceSymbol.from(value), true);
    }
    return void 0;
  }
  releaseWorkspaceSymbols(id2) {
    this._cache.delete(id2);
  }
};
var RenameAdapter = class _RenameAdapter {
  static supportsResolving(provider) {
    return typeof provider.prepareRename === "function";
  }
  constructor(_documents, _provider, _logService) {
    this._documents = _documents;
    this._provider = _provider;
    this._logService = _logService;
  }
  async provideRenameEdits(resource, position, newName, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    try {
      const value = await this._provider.provideRenameEdits(doc, pos, newName, token);
      if (!value) {
        return void 0;
      }
      return WorkspaceEdit3.from(value);
    } catch (err) {
      const rejectReason = _RenameAdapter._asMessage(err);
      if (rejectReason) {
        return { rejectReason, edits: void 0 };
      } else {
        return Promise.reject(err);
      }
    }
  }
  async resolveRenameLocation(resource, position, token) {
    if (typeof this._provider.prepareRename !== "function") {
      return Promise.resolve(void 0);
    }
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    try {
      const rangeOrLocation = await this._provider.prepareRename(doc, pos, token);
      let range;
      let text;
      if (Range2.isRange(rangeOrLocation)) {
        range = rangeOrLocation;
        text = doc.getText(rangeOrLocation);
      } else if (isObject(rangeOrLocation)) {
        range = rangeOrLocation.range;
        text = rangeOrLocation.placeholder;
      }
      if (!range || !text) {
        return void 0;
      }
      if (range.start.line > pos.line || range.end.line < pos.line) {
        this._logService.warn("INVALID rename location: position line must be within range start/end lines");
        return void 0;
      }
      return { range: Range4.from(range), text };
    } catch (err) {
      const rejectReason = _RenameAdapter._asMessage(err);
      if (rejectReason) {
        return { rejectReason, range: void 0, text: void 0 };
      } else {
        return Promise.reject(err);
      }
    }
  }
  static _asMessage(err) {
    if (typeof err === "string") {
      return err;
    } else if (err instanceof Error && typeof err.message === "string") {
      return err.message;
    } else {
      return void 0;
    }
  }
};
var NewSymbolNamesAdapter = class _NewSymbolNamesAdapter {
  static {
    this.languageTriggerKindToVSCodeTriggerKind = {
      [NewSymbolNameTriggerKind.Invoke]: NewSymbolNameTriggerKind2.Invoke,
      [NewSymbolNameTriggerKind.Automatic]: NewSymbolNameTriggerKind2.Automatic
    };
  }
  constructor(_documents, _provider, _logService) {
    this._documents = _documents;
    this._provider = _provider;
    this._logService = _logService;
  }
  async supportsAutomaticNewSymbolNamesTriggerKind() {
    return this._provider.supportsAutomaticTriggerKind;
  }
  async provideNewSymbolNames(resource, range, triggerKind, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Range4.to(range);
    try {
      const kind = _NewSymbolNamesAdapter.languageTriggerKindToVSCodeTriggerKind[triggerKind];
      const value = await this._provider.provideNewSymbolNames(doc, pos, kind, token);
      if (!value) {
        return void 0;
      }
      return value.map((v) => typeof v === "string" ? { newSymbolName: v } : { newSymbolName: v.newSymbolName, tags: v.tags });
    } catch (err) {
      this._logService.error(
        _NewSymbolNamesAdapter._asMessage(err) ?? JSON.stringify(err, null, "	")
        /* @ulugbekna: assuming `err` doesn't have circular references that could result in an exception when converting to JSON */
      );
      return void 0;
    }
  }
  // @ulugbekna: this method is also defined in RenameAdapter but seems OK to be duplicated
  static _asMessage(err) {
    if (typeof err === "string") {
      return err;
    } else if (err instanceof Error && typeof err.message === "string") {
      return err.message;
    } else {
      return void 0;
    }
  }
};
var SemanticTokensPreviousResult = class {
  constructor(resultId, tokens) {
    this.resultId = resultId;
    this.tokens = tokens;
  }
};
var DocumentSemanticTokensAdapter = class _DocumentSemanticTokensAdapter {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._nextResultId = 1;
    this._previousResults = /* @__PURE__ */ new Map();
  }
  async provideDocumentSemanticTokens(resource, previousResultId, token) {
    const doc = this._documents.getDocument(resource);
    const previousResult = previousResultId !== 0 ? this._previousResults.get(previousResultId) : null;
    let value = typeof previousResult?.resultId === "string" && typeof this._provider.provideDocumentSemanticTokensEdits === "function" ? await this._provider.provideDocumentSemanticTokensEdits(doc, previousResult.resultId, token) : await this._provider.provideDocumentSemanticTokens(doc, token);
    if (previousResult) {
      this._previousResults.delete(previousResultId);
    }
    if (!value) {
      return null;
    }
    value = _DocumentSemanticTokensAdapter._fixProvidedSemanticTokens(value);
    return this._send(_DocumentSemanticTokensAdapter._convertToEdits(previousResult, value), value);
  }
  async releaseDocumentSemanticColoring(semanticColoringResultId) {
    this._previousResults.delete(semanticColoringResultId);
  }
  static _fixProvidedSemanticTokens(v) {
    if (_DocumentSemanticTokensAdapter._isSemanticTokens(v)) {
      if (_DocumentSemanticTokensAdapter._isCorrectSemanticTokens(v)) {
        return v;
      }
      return new SemanticTokens(new Uint32Array(v.data), v.resultId);
    } else if (_DocumentSemanticTokensAdapter._isSemanticTokensEdits(v)) {
      if (_DocumentSemanticTokensAdapter._isCorrectSemanticTokensEdits(v)) {
        return v;
      }
      return new SemanticTokensEdits(v.edits.map((edit2) => new SemanticTokensEdit(edit2.start, edit2.deleteCount, edit2.data ? new Uint32Array(edit2.data) : edit2.data)), v.resultId);
    }
    return v;
  }
  static _isSemanticTokens(v) {
    return v && !!v.data;
  }
  static _isCorrectSemanticTokens(v) {
    return v.data instanceof Uint32Array;
  }
  static _isSemanticTokensEdits(v) {
    return v && Array.isArray(v.edits);
  }
  static _isCorrectSemanticTokensEdits(v) {
    for (const edit2 of v.edits) {
      if (!(edit2.data instanceof Uint32Array)) {
        return false;
      }
    }
    return true;
  }
  static _convertToEdits(previousResult, newResult) {
    if (!_DocumentSemanticTokensAdapter._isSemanticTokens(newResult)) {
      return newResult;
    }
    if (!previousResult || !previousResult.tokens) {
      return newResult;
    }
    const oldData = previousResult.tokens;
    const oldLength = oldData.length;
    const newData = newResult.data;
    const newLength = newData.length;
    let commonPrefixLength2 = 0;
    const maxCommonPrefixLength = Math.min(oldLength, newLength);
    while (commonPrefixLength2 < maxCommonPrefixLength && oldData[commonPrefixLength2] === newData[commonPrefixLength2]) {
      commonPrefixLength2++;
    }
    if (commonPrefixLength2 === oldLength && commonPrefixLength2 === newLength) {
      return new SemanticTokensEdits([], newResult.resultId);
    }
    let commonSuffixLength = 0;
    const maxCommonSuffixLength = maxCommonPrefixLength - commonPrefixLength2;
    while (commonSuffixLength < maxCommonSuffixLength && oldData[oldLength - commonSuffixLength - 1] === newData[newLength - commonSuffixLength - 1]) {
      commonSuffixLength++;
    }
    return new SemanticTokensEdits([{
      start: commonPrefixLength2,
      deleteCount: oldLength - commonPrefixLength2 - commonSuffixLength,
      data: newData.subarray(commonPrefixLength2, newLength - commonSuffixLength)
    }], newResult.resultId);
  }
  _send(value, original) {
    if (_DocumentSemanticTokensAdapter._isSemanticTokens(value)) {
      const myId = this._nextResultId++;
      this._previousResults.set(myId, new SemanticTokensPreviousResult(value.resultId, value.data));
      return encodeSemanticTokensDto({
        id: myId,
        type: "full",
        data: value.data
      });
    }
    if (_DocumentSemanticTokensAdapter._isSemanticTokensEdits(value)) {
      const myId = this._nextResultId++;
      if (_DocumentSemanticTokensAdapter._isSemanticTokens(original)) {
        this._previousResults.set(myId, new SemanticTokensPreviousResult(original.resultId, original.data));
      } else {
        this._previousResults.set(myId, new SemanticTokensPreviousResult(value.resultId));
      }
      return encodeSemanticTokensDto({
        id: myId,
        type: "delta",
        deltas: (value.edits || []).map((edit2) => ({ start: edit2.start, deleteCount: edit2.deleteCount, data: edit2.data }))
      });
    }
    return null;
  }
};
var DocumentRangeSemanticTokensAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentRangeSemanticTokens(resource, range, token) {
    const doc = this._documents.getDocument(resource);
    const value = await this._provider.provideDocumentRangeSemanticTokens(doc, Range4.to(range), token);
    if (!value) {
      return null;
    }
    return this._send(value);
  }
  _send(value) {
    return encodeSemanticTokensDto({
      id: 0,
      type: "full",
      data: value.data
    });
  }
};
var CompletionsAdapter = class _CompletionsAdapter {
  static supportsResolving(provider) {
    return typeof provider.resolveCompletionItem === "function";
  }
  constructor(_documents, _commands, _provider, _apiDeprecation, _extension) {
    this._documents = _documents;
    this._commands = _commands;
    this._provider = _provider;
    this._apiDeprecation = _apiDeprecation;
    this._extension = _extension;
    this._cache = new Cache2("CompletionItem");
    this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCompletionItems(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const replaceRange = doc.getWordRangeAtPosition(pos) || new Range2(pos, pos);
    const insertRange = replaceRange.with({ end: pos });
    const sw = new StopWatch();
    const itemsOrList = await this._provider.provideCompletionItems(doc, pos, token, CompletionContext.to(context));
    if (!itemsOrList) {
      return void 0;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    const list2 = Array.isArray(itemsOrList) ? new CompletionList(itemsOrList) : itemsOrList;
    const pid = _CompletionsAdapter.supportsResolving(this._provider) ? this._cache.add(list2.items) : this._cache.add([]);
    const disposables = new DisposableStore();
    this._disposables.set(pid, disposables);
    const completions = [];
    const result = {
      x: pid,
      [
        "b"
        /* extHostProtocol.ISuggestResultDtoField.completions */
      ]: completions,
      [
        "a"
        /* extHostProtocol.ISuggestResultDtoField.defaultRanges */
      ]: { replace: Range4.from(replaceRange), insert: Range4.from(insertRange) },
      [
        "c"
        /* extHostProtocol.ISuggestResultDtoField.isIncomplete */
      ]: list2.isIncomplete || void 0,
      [
        "d"
        /* extHostProtocol.ISuggestResultDtoField.duration */
      ]: sw.elapsed()
    };
    for (let i = 0; i < list2.items.length; i++) {
      const item = list2.items[i];
      const dto = this._convertCompletionItem(item, [pid, i], insertRange, replaceRange);
      completions.push(dto);
    }
    return result;
  }
  async resolveCompletionItem(id2, token) {
    if (typeof this._provider.resolveCompletionItem !== "function") {
      return void 0;
    }
    const item = this._cache.get(...id2);
    if (!item) {
      return void 0;
    }
    const dto1 = this._convertCompletionItem(item, id2);
    const resolvedItem = await this._provider.resolveCompletionItem(item, token);
    if (!resolvedItem) {
      return void 0;
    }
    const dto2 = this._convertCompletionItem(resolvedItem, id2);
    if (dto1[
      "h"
      /* extHostProtocol.ISuggestDataDtoField.insertText */
    ] !== dto2[
      "h"
      /* extHostProtocol.ISuggestDataDtoField.insertText */
    ] || dto1[
      "i"
      /* extHostProtocol.ISuggestDataDtoField.insertTextRules */
    ] !== dto2[
      "i"
      /* extHostProtocol.ISuggestDataDtoField.insertTextRules */
    ]) {
      this._apiDeprecation.report("CompletionItem.insertText", this._extension, "extension MAY NOT change 'insertText' of a CompletionItem during resolve");
    }
    if (dto1[
      "n"
      /* extHostProtocol.ISuggestDataDtoField.commandIdent */
    ] !== dto2[
      "n"
      /* extHostProtocol.ISuggestDataDtoField.commandIdent */
    ] || dto1[
      "o"
      /* extHostProtocol.ISuggestDataDtoField.commandId */
    ] !== dto2[
      "o"
      /* extHostProtocol.ISuggestDataDtoField.commandId */
    ] || !equals2(dto1[
      "p"
      /* extHostProtocol.ISuggestDataDtoField.commandArguments */
    ], dto2[
      "p"
      /* extHostProtocol.ISuggestDataDtoField.commandArguments */
    ])) {
      this._apiDeprecation.report("CompletionItem.command", this._extension, "extension MAY NOT change 'command' of a CompletionItem during resolve");
    }
    return {
      ...dto1,
      [
        "d"
        /* extHostProtocol.ISuggestDataDtoField.documentation */
      ]: dto2[
        "d"
        /* extHostProtocol.ISuggestDataDtoField.documentation */
      ],
      [
        "c"
        /* extHostProtocol.ISuggestDataDtoField.detail */
      ]: dto2[
        "c"
        /* extHostProtocol.ISuggestDataDtoField.detail */
      ],
      [
        "l"
        /* extHostProtocol.ISuggestDataDtoField.additionalTextEdits */
      ]: dto2[
        "l"
        /* extHostProtocol.ISuggestDataDtoField.additionalTextEdits */
      ],
      // (fishy) async insertText
      [
        "h"
        /* extHostProtocol.ISuggestDataDtoField.insertText */
      ]: dto2[
        "h"
        /* extHostProtocol.ISuggestDataDtoField.insertText */
      ],
      [
        "i"
        /* extHostProtocol.ISuggestDataDtoField.insertTextRules */
      ]: dto2[
        "i"
        /* extHostProtocol.ISuggestDataDtoField.insertTextRules */
      ],
      // (fishy) async command
      [
        "n"
        /* extHostProtocol.ISuggestDataDtoField.commandIdent */
      ]: dto2[
        "n"
        /* extHostProtocol.ISuggestDataDtoField.commandIdent */
      ],
      [
        "o"
        /* extHostProtocol.ISuggestDataDtoField.commandId */
      ]: dto2[
        "o"
        /* extHostProtocol.ISuggestDataDtoField.commandId */
      ],
      [
        "p"
        /* extHostProtocol.ISuggestDataDtoField.commandArguments */
      ]: dto2[
        "p"
        /* extHostProtocol.ISuggestDataDtoField.commandArguments */
      ]
    };
  }
  releaseCompletionItems(id2) {
    this._disposables.get(id2)?.dispose();
    this._disposables.delete(id2);
    this._cache.delete(id2);
  }
  _convertCompletionItem(item, id2, defaultInsertRange, defaultReplaceRange) {
    const disposables = this._disposables.get(id2[0]);
    if (!disposables) {
      throw Error("DisposableStore is missing...");
    }
    const command = this._commands.toInternal(item.command, disposables);
    const result = {
      //
      x: id2,
      //
      [
        "a"
        /* extHostProtocol.ISuggestDataDtoField.label */
      ]: item.label,
      [
        "b"
        /* extHostProtocol.ISuggestDataDtoField.kind */
      ]: item.kind !== void 0 ? CompletionItemKind3.from(item.kind) : void 0,
      [
        "m"
        /* extHostProtocol.ISuggestDataDtoField.kindModifier */
      ]: item.tags && item.tags.map(CompletionItemTag3.from),
      [
        "c"
        /* extHostProtocol.ISuggestDataDtoField.detail */
      ]: item.detail,
      [
        "d"
        /* extHostProtocol.ISuggestDataDtoField.documentation */
      ]: typeof item.documentation === "undefined" ? void 0 : MarkdownString4.fromStrict(item.documentation),
      [
        "e"
        /* extHostProtocol.ISuggestDataDtoField.sortText */
      ]: item.sortText !== item.label ? item.sortText : void 0,
      [
        "f"
        /* extHostProtocol.ISuggestDataDtoField.filterText */
      ]: item.filterText !== item.label ? item.filterText : void 0,
      [
        "g"
        /* extHostProtocol.ISuggestDataDtoField.preselect */
      ]: item.preselect || void 0,
      [
        "i"
        /* extHostProtocol.ISuggestDataDtoField.insertTextRules */
      ]: item.keepWhitespace ? 1 : 0,
      [
        "k"
        /* extHostProtocol.ISuggestDataDtoField.commitCharacters */
      ]: item.commitCharacters?.join(""),
      [
        "l"
        /* extHostProtocol.ISuggestDataDtoField.additionalTextEdits */
      ]: item.additionalTextEdits && item.additionalTextEdits.map(TextEdit3.from),
      [
        "n"
        /* extHostProtocol.ISuggestDataDtoField.commandIdent */
      ]: command?.$ident,
      [
        "o"
        /* extHostProtocol.ISuggestDataDtoField.commandId */
      ]: command?.id,
      [
        "p"
        /* extHostProtocol.ISuggestDataDtoField.commandArguments */
      ]: command?.$ident ? void 0 : command?.arguments
      // filled in on main side from $ident
    };
    if (item.textEdit) {
      this._apiDeprecation.report("CompletionItem.textEdit", this._extension, `Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.`);
      result[
        "h"
        /* extHostProtocol.ISuggestDataDtoField.insertText */
      ] = item.textEdit.newText;
    } else if (typeof item.insertText === "string") {
      result[
        "h"
        /* extHostProtocol.ISuggestDataDtoField.insertText */
      ] = item.insertText;
    } else if (item.insertText instanceof SnippetString) {
      result[
        "h"
        /* extHostProtocol.ISuggestDataDtoField.insertText */
      ] = item.insertText.value;
      result[
        "i"
        /* extHostProtocol.ISuggestDataDtoField.insertTextRules */
      ] |= 4;
    }
    let range;
    if (item.textEdit) {
      range = item.textEdit.range;
    } else if (item.range) {
      range = item.range;
    }
    if (Range2.isRange(range)) {
      result[
        "j"
        /* extHostProtocol.ISuggestDataDtoField.range */
      ] = Range4.from(range);
    } else if (range && (!defaultInsertRange?.isEqual(range.inserting) || !defaultReplaceRange?.isEqual(range.replacing))) {
      result[
        "j"
        /* extHostProtocol.ISuggestDataDtoField.range */
      ] = {
        insert: Range4.from(range.inserting),
        replace: Range4.from(range.replacing)
      };
    }
    return result;
  }
};
var InlineCompletionAdapter = class {
  constructor(_extension, _documents, _provider, _commands) {
    this._extension = _extension;
    this._documents = _documents;
    this._provider = _provider;
    this._commands = _commands;
    this._references = new ReferenceMap();
    this.languageTriggerKindToVSCodeTriggerKind = {
      [InlineCompletionTriggerKind.Automatic]: InlineCompletionTriggerKind2.Automatic,
      [InlineCompletionTriggerKind.Explicit]: InlineCompletionTriggerKind2.Invoke
    };
    this._isAdditionsProposedApiEnabled = isProposedApiEnabled(this._extension, "inlineCompletionsAdditions");
  }
  get supportsHandleEvents() {
    return isProposedApiEnabled(this._extension, "inlineCompletionsAdditions") && (typeof this._provider.handleDidShowCompletionItem === "function" || typeof this._provider.handleDidPartiallyAcceptCompletionItem === "function" || typeof this._provider.handleDidRejectCompletionItem === "function" || typeof this._provider.handleEndOfLifetime === "function");
  }
  async provideInlineCompletions(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const result = await this._provider.provideInlineCompletionItems(doc, pos, {
      selectedCompletionInfo: context.selectedSuggestionInfo ? {
        range: Range4.to(context.selectedSuggestionInfo.range),
        text: context.selectedSuggestionInfo.text
      } : void 0,
      triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind],
      requestUuid: context.requestUuid,
      requestIssuedDateTime: context.requestIssuedDateTime,
      earliestShownDateTime: context.earliestShownDateTime
    }, token);
    if (!result) {
      return void 0;
    }
    const { resultItems, list: list2 } = Array.isArray(result) ? { resultItems: result, list: void 0 } : { resultItems: result.items, list: result };
    const commands = this._isAdditionsProposedApiEnabled ? Array.isArray(result) ? [] : result.commands || [] : [];
    const enableForwardStability = this._isAdditionsProposedApiEnabled && !Array.isArray(result) ? result.enableForwardStability : void 0;
    let disposableStore = void 0;
    const pid = this._references.createReferenceId({
      dispose() {
        disposableStore?.dispose();
      },
      items: resultItems,
      list: list2
    });
    return {
      pid,
      languageId: doc.languageId,
      items: resultItems.map((item, idx) => {
        let command = void 0;
        if (item.command) {
          if (!disposableStore) {
            disposableStore = new DisposableStore();
          }
          command = this._commands.toInternal(item.command, disposableStore);
        }
        let action = void 0;
        if (item.action) {
          if (!disposableStore) {
            disposableStore = new DisposableStore();
          }
          action = this._commands.toInternal(item.action, disposableStore);
        }
        const insertText = item.insertText;
        return {
          insertText: insertText === void 0 ? void 0 : typeof insertText === "string" ? insertText : { snippet: insertText.value },
          range: item.range ? Range4.from(item.range) : void 0,
          showRange: this._isAdditionsProposedApiEnabled && item.showRange ? Range4.from(item.showRange) : void 0,
          command,
          gutterMenuLinkAction: action,
          idx,
          completeBracketPairs: this._isAdditionsProposedApiEnabled ? item.completeBracketPairs : false,
          isInlineEdit: this._isAdditionsProposedApiEnabled ? item.isInlineEdit : false,
          showInlineEditMenu: this._isAdditionsProposedApiEnabled ? item.showInlineEditMenu : false,
          hint: item.displayLocation && this._isAdditionsProposedApiEnabled ? {
            range: Range4.from(item.displayLocation.range),
            content: item.displayLocation.label,
            style: item.displayLocation.kind ? InlineCompletionHintStyle2.from(item.displayLocation.kind) : InlineCompletionHintStyle.Code
          } : void 0,
          warning: item.warning && this._isAdditionsProposedApiEnabled ? {
            message: MarkdownString4.from(item.warning.message),
            icon: item.warning.icon ? IconPath.fromThemeIcon(item.warning.icon) : void 0
          } : void 0,
          correlationId: this._isAdditionsProposedApiEnabled ? item.correlationId : void 0,
          suggestionId: void 0,
          uri: this._isAdditionsProposedApiEnabled && item.uri ? item.uri : void 0
        };
      }),
      commands: commands.map((c) => {
        if (!disposableStore) {
          disposableStore = new DisposableStore();
        }
        return CompletionCommand.from(c, this._commands, disposableStore);
      }),
      suppressSuggestions: false,
      enableForwardStability
    };
  }
  disposeCompletions(pid, reason) {
    const completionList = this._references.get(pid);
    if (this._provider.handleListEndOfLifetime && this._isAdditionsProposedApiEnabled && completionList?.list) {
      let translateReason2 = function(reason2) {
        switch (reason2.kind) {
          case "lostRace":
            return { kind: InlineCompletionsDisposeReasonKind.LostRace };
          case "tokenCancellation":
            return { kind: InlineCompletionsDisposeReasonKind.TokenCancellation };
          case "other":
            return { kind: InlineCompletionsDisposeReasonKind.Other };
          case "empty":
            return { kind: InlineCompletionsDisposeReasonKind.Empty };
          case "notTaken":
            return { kind: InlineCompletionsDisposeReasonKind.NotTaken };
          default:
            return { kind: InlineCompletionsDisposeReasonKind.Other };
        }
      };
      var translateReason = translateReason2;
      this._provider.handleListEndOfLifetime(completionList.list, translateReason2(reason));
    }
    const data2 = this._references.disposeReferenceId(pid);
    data2?.dispose();
  }
  handleDidShowCompletionItem(pid, idx, updatedInsertText) {
    const completionItem = this._references.get(pid)?.items[idx];
    if (completionItem) {
      if (this._provider.handleDidShowCompletionItem && this._isAdditionsProposedApiEnabled) {
        this._provider.handleDidShowCompletionItem(completionItem, updatedInsertText);
      }
    }
  }
  handlePartialAccept(pid, idx, acceptedCharacters, info) {
    const completionItem = this._references.get(pid)?.items[idx];
    if (completionItem) {
      if (this._provider.handleDidPartiallyAcceptCompletionItem && this._isAdditionsProposedApiEnabled) {
        this._provider.handleDidPartiallyAcceptCompletionItem(completionItem, acceptedCharacters);
        this._provider.handleDidPartiallyAcceptCompletionItem(completionItem, PartialAcceptInfo.to(info));
      }
    }
  }
  handleEndOfLifetime(pid, idx, reason) {
    const completionItem = this._references.get(pid)?.items[idx];
    if (completionItem) {
      if (this._provider.handleEndOfLifetime && this._isAdditionsProposedApiEnabled) {
        const r = InlineCompletionEndOfLifeReason.to(reason, (ref) => this._references.get(ref.pid)?.items[ref.idx]);
        this._provider.handleEndOfLifetime(completionItem, r);
      }
    }
  }
  handleRejection(pid, idx) {
    const completionItem = this._references.get(pid)?.items[idx];
    if (completionItem) {
      if (this._provider.handleDidRejectCompletionItem && this._isAdditionsProposedApiEnabled) {
        this._provider.handleDidRejectCompletionItem(completionItem);
      }
    }
  }
};
var ReferenceMap = class {
  constructor() {
    this._references = /* @__PURE__ */ new Map();
    this._idPool = 1;
  }
  createReferenceId(value) {
    const id2 = this._idPool++;
    this._references.set(id2, value);
    return id2;
  }
  disposeReferenceId(referenceId) {
    const value = this._references.get(referenceId);
    this._references.delete(referenceId);
    return value;
  }
  get(referenceId) {
    return this._references.get(referenceId);
  }
};
var SignatureHelpAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._cache = new Cache2("SignatureHelp");
  }
  async provideSignatureHelp(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position4.to(position);
    const vscodeContext = this.reviveContext(context);
    const value = await this._provider.provideSignatureHelp(doc, pos, token, vscodeContext);
    if (value) {
      const id2 = this._cache.add([value]);
      return { ...SignatureHelp3.from(value), id: id2 };
    }
    return void 0;
  }
  reviveContext(context) {
    let activeSignatureHelp = void 0;
    if (context.activeSignatureHelp) {
      const revivedSignatureHelp = SignatureHelp3.to(context.activeSignatureHelp);
      const saved = this._cache.get(context.activeSignatureHelp.id, 0);
      if (saved) {
        activeSignatureHelp = saved;
        activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;
        activeSignatureHelp.activeParameter = revivedSignatureHelp.activeParameter;
      } else {
        activeSignatureHelp = revivedSignatureHelp;
      }
    }
    return { ...context, activeSignatureHelp };
  }
  releaseSignatureHelp(id2) {
    this._cache.delete(id2);
  }
};
var InlayHintsAdapter = class {
  constructor(_documents, _commands, _provider, _logService, _extension) {
    this._documents = _documents;
    this._commands = _commands;
    this._provider = _provider;
    this._logService = _logService;
    this._extension = _extension;
    this._cache = new Cache2("InlayHints");
    this._disposables = /* @__PURE__ */ new Map();
  }
  async provideInlayHints(resource, ran, token) {
    const doc = this._documents.getDocument(resource);
    const range = Range4.to(ran);
    const hints = await this._provider.provideInlayHints(doc, range, token);
    if (!Array.isArray(hints) || hints.length === 0) {
      this._logService.trace(`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(ran)}`);
      return void 0;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    const pid = this._cache.add(hints);
    this._disposables.set(pid, new DisposableStore());
    const result = { hints: [], cacheId: pid };
    for (let i = 0; i < hints.length; i++) {
      if (this._isValidInlayHint(hints[i], range)) {
        result.hints.push(this._convertInlayHint(hints[i], [pid, i]));
      }
    }
    this._logService.trace(`[InlayHints] ${result.hints.length} inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(ran)}`);
    return result;
  }
  async resolveInlayHint(id2, token) {
    if (typeof this._provider.resolveInlayHint !== "function") {
      return void 0;
    }
    const item = this._cache.get(...id2);
    if (!item) {
      return void 0;
    }
    const hint = await this._provider.resolveInlayHint(item, token);
    if (!hint) {
      return void 0;
    }
    if (!this._isValidInlayHint(hint)) {
      return void 0;
    }
    return this._convertInlayHint(hint, id2);
  }
  releaseHints(id2) {
    this._disposables.get(id2)?.dispose();
    this._disposables.delete(id2);
    this._cache.delete(id2);
  }
  _isValidInlayHint(hint, range) {
    if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every((part) => part.value.length === 0)) {
      console.log("INVALID inlay hint, empty label", hint);
      return false;
    }
    if (range && !range.contains(hint.position)) {
      return false;
    }
    return true;
  }
  _convertInlayHint(hint, id2) {
    const disposables = this._disposables.get(id2[0]);
    if (!disposables) {
      throw Error("DisposableStore is missing...");
    }
    const result = {
      label: "",
      // fill-in below
      cacheId: id2,
      tooltip: MarkdownString4.fromStrict(hint.tooltip),
      position: Position4.from(hint.position),
      textEdits: hint.textEdits && hint.textEdits.map(TextEdit3.from),
      kind: hint.kind && InlayHintKind3.from(hint.kind),
      paddingLeft: hint.paddingLeft,
      paddingRight: hint.paddingRight
    };
    if (typeof hint.label === "string") {
      result.label = hint.label;
    } else {
      const parts = [];
      result.label = parts;
      for (const part of hint.label) {
        if (!part.value) {
          console.warn("INVALID inlay hint, empty label part", this._extension.identifier.value);
          continue;
        }
        const part2 = {
          label: part.value,
          tooltip: MarkdownString4.fromStrict(part.tooltip)
        };
        if (Location.isLocation(part.location)) {
          part2.location = location.from(part.location);
        }
        if (part.command) {
          part2.command = this._commands.toInternal(part.command, disposables);
        }
        parts.push(part2);
      }
    }
    return result;
  }
};
var LinkProviderAdapter = class _LinkProviderAdapter {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._cache = new Cache2("DocumentLink");
  }
  async provideLinks(resource, token) {
    const doc = this._documents.getDocument(resource);
    const links = await this._provider.provideDocumentLinks(doc, token);
    if (!Array.isArray(links) || links.length === 0) {
      return void 0;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    if (typeof this._provider.resolveDocumentLink !== "function") {
      return { links: links.filter(_LinkProviderAdapter._validateLink).map(DocumentLink3.from) };
    } else {
      const pid = this._cache.add(links);
      const result = { links: [], cacheId: pid };
      for (let i = 0; i < links.length; i++) {
        if (!_LinkProviderAdapter._validateLink(links[i])) {
          continue;
        }
        const dto = DocumentLink3.from(links[i]);
        dto.cacheId = [pid, i];
        result.links.push(dto);
      }
      return result;
    }
  }
  static _validateLink(link2) {
    if (link2.target && link2.target.path.length > 5e4) {
      console.warn("DROPPING link because it is too long");
      return false;
    }
    return true;
  }
  async resolveLink(id2, token) {
    if (typeof this._provider.resolveDocumentLink !== "function") {
      return void 0;
    }
    const item = this._cache.get(...id2);
    if (!item) {
      return void 0;
    }
    const link2 = await this._provider.resolveDocumentLink(item, token);
    if (!link2 || !_LinkProviderAdapter._validateLink(link2)) {
      return void 0;
    }
    return DocumentLink3.from(link2);
  }
  releaseLinks(id2) {
    this._cache.delete(id2);
  }
};
var ColorProviderAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideColors(resource, token) {
    const doc = this._documents.getDocument(resource);
    const colors = await this._provider.provideDocumentColors(doc, token);
    if (!Array.isArray(colors)) {
      return [];
    }
    const colorInfos = colors.map((ci) => {
      return {
        color: Color3.from(ci.color),
        range: Range4.from(ci.range)
      };
    });
    return colorInfos;
  }
  async provideColorPresentations(resource, raw, token) {
    const document2 = this._documents.getDocument(resource);
    const range = Range4.to(raw.range);
    const color = Color3.to(raw.color);
    const value = await this._provider.provideColorPresentations(color, { document: document2, range }, token);
    if (!Array.isArray(value)) {
      return void 0;
    }
    return value.map(ColorPresentation3.from);
  }
};
var FoldingProviderAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideFoldingRanges(resource, context, token) {
    const doc = this._documents.getDocument(resource);
    const ranges = await this._provider.provideFoldingRanges(doc, context, token);
    if (!Array.isArray(ranges)) {
      return void 0;
    }
    return ranges.map(FoldingRange3.from);
  }
};
var SelectionRangeAdapter = class {
  constructor(_documents, _provider, _logService) {
    this._documents = _documents;
    this._provider = _provider;
    this._logService = _logService;
  }
  async provideSelectionRanges(resource, pos, token) {
    const document2 = this._documents.getDocument(resource);
    const positions = pos.map(Position4.to);
    const allProviderRanges = await this._provider.provideSelectionRanges(document2, positions, token);
    if (!isNonEmptyArray(allProviderRanges)) {
      return [];
    }
    if (allProviderRanges.length !== positions.length) {
      this._logService.warn("BAD selection ranges, provider must return ranges for each position");
      return [];
    }
    const allResults = [];
    for (let i = 0; i < positions.length; i++) {
      const oneResult = [];
      allResults.push(oneResult);
      let last = positions[i];
      let selectionRange = allProviderRanges[i];
      while (true) {
        if (!selectionRange.range.contains(last)) {
          throw new Error("INVALID selection range, must contain the previous range");
        }
        oneResult.push(SelectionRange3.from(selectionRange));
        if (!selectionRange.parent) {
          break;
        }
        last = selectionRange.range;
        selectionRange = selectionRange.parent;
      }
    }
    return allResults;
  }
};
var CallHierarchyAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._idPool = new IdGenerator("");
    this._cache = /* @__PURE__ */ new Map();
  }
  async prepareSession(uri, position, token) {
    const doc = this._documents.getDocument(uri);
    const pos = Position4.to(position);
    const items = await this._provider.prepareCallHierarchy(doc, pos, token);
    if (!items) {
      return void 0;
    }
    const sessionId = this._idPool.nextId();
    this._cache.set(sessionId, /* @__PURE__ */ new Map());
    if (Array.isArray(items)) {
      return items.map((item) => this._cacheAndConvertItem(sessionId, item));
    } else {
      return [this._cacheAndConvertItem(sessionId, items)];
    }
  }
  async provideCallsTo(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing call hierarchy item");
    }
    const calls = await this._provider.provideCallHierarchyIncomingCalls(item, token);
    if (!calls) {
      return void 0;
    }
    return calls.map((call) => {
      return {
        from: this._cacheAndConvertItem(sessionId, call.from),
        fromRanges: call.fromRanges.map((r) => Range4.from(r))
      };
    });
  }
  async provideCallsFrom(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing call hierarchy item");
    }
    const calls = await this._provider.provideCallHierarchyOutgoingCalls(item, token);
    if (!calls) {
      return void 0;
    }
    return calls.map((call) => {
      return {
        to: this._cacheAndConvertItem(sessionId, call.to),
        fromRanges: call.fromRanges.map((r) => Range4.from(r))
      };
    });
  }
  releaseSession(sessionId) {
    this._cache.delete(sessionId);
  }
  _cacheAndConvertItem(sessionId, item) {
    const map = this._cache.get(sessionId);
    const dto = CallHierarchyItem2.from(item, sessionId, map.size.toString(36));
    map.set(dto._itemId, item);
    return dto;
  }
  _itemFromCache(sessionId, itemId) {
    const map = this._cache.get(sessionId);
    return map?.get(itemId);
  }
};
var TypeHierarchyAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._idPool = new IdGenerator("");
    this._cache = /* @__PURE__ */ new Map();
  }
  async prepareSession(uri, position, token) {
    const doc = this._documents.getDocument(uri);
    const pos = Position4.to(position);
    const items = await this._provider.prepareTypeHierarchy(doc, pos, token);
    if (!items) {
      return void 0;
    }
    const sessionId = this._idPool.nextId();
    this._cache.set(sessionId, /* @__PURE__ */ new Map());
    if (Array.isArray(items)) {
      return items.map((item) => this._cacheAndConvertItem(sessionId, item));
    } else {
      return [this._cacheAndConvertItem(sessionId, items)];
    }
  }
  async provideSupertypes(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing type hierarchy item");
    }
    const supertypes = await this._provider.provideTypeHierarchySupertypes(item, token);
    if (!supertypes) {
      return void 0;
    }
    return supertypes.map((supertype) => {
      return this._cacheAndConvertItem(sessionId, supertype);
    });
  }
  async provideSubtypes(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing type hierarchy item");
    }
    const subtypes = await this._provider.provideTypeHierarchySubtypes(item, token);
    if (!subtypes) {
      return void 0;
    }
    return subtypes.map((subtype) => {
      return this._cacheAndConvertItem(sessionId, subtype);
    });
  }
  releaseSession(sessionId) {
    this._cache.delete(sessionId);
  }
  _cacheAndConvertItem(sessionId, item) {
    const map = this._cache.get(sessionId);
    const dto = TypeHierarchyItem2.from(item, sessionId, map.size.toString(36));
    map.set(dto._itemId, item);
    return dto;
  }
  _itemFromCache(sessionId, itemId) {
    const map = this._cache.get(sessionId);
    return map?.get(itemId);
  }
};
var DocumentDropEditAdapter = class {
  constructor(_proxy, _documents, _provider, _handle, _extension) {
    this._proxy = _proxy;
    this._documents = _documents;
    this._provider = _provider;
    this._handle = _handle;
    this._extension = _extension;
    this._cache = new Cache2("DocumentDropEdit");
  }
  async provideDocumentOnDropEdits(requestId, uri, position, dataTransferDto, token) {
    const doc = this._documents.getDocument(uri);
    const pos = Position4.to(position);
    const dataTransfer = DataTransfer3.toDataTransfer(dataTransferDto, async (id2) => {
      return (await this._proxy.$resolveDocumentOnDropFileData(this._handle, requestId, id2)).buffer;
    });
    const edits = await this._provider.provideDocumentDropEdits(doc, pos, dataTransfer, token);
    if (!edits) {
      return void 0;
    }
    const editsArray = asArray(edits);
    const cacheId = this._cache.add(editsArray);
    return editsArray.map((edit2, i) => ({
      _cacheId: [cacheId, i],
      title: edit2.title ?? localize(3013, null, this._extension.displayName || this._extension.name),
      kind: edit2.kind?.value,
      yieldTo: edit2.yieldTo?.map((x) => x.value),
      insertText: typeof edit2.insertText === "string" ? edit2.insertText : { snippet: edit2.insertText.value },
      additionalEdit: edit2.additionalEdit ? WorkspaceEdit3.from(edit2.additionalEdit, void 0) : void 0
    }));
  }
  async resolveDropEdit(id2, token) {
    const [sessionId, itemId] = id2;
    const item = this._cache.get(sessionId, itemId);
    if (!item || !this._provider.resolveDocumentDropEdit) {
      return {};
    }
    const resolvedItem = await this._provider.resolveDocumentDropEdit(item, token) ?? item;
    const additionalEdit = resolvedItem.additionalEdit ? WorkspaceEdit3.from(resolvedItem.additionalEdit, void 0) : void 0;
    return { additionalEdit };
  }
  releaseDropEdits(id2) {
    this._cache.delete(id2);
  }
};
var AdapterData = class {
  constructor(adapter, extension) {
    this.adapter = adapter;
    this.extension = extension;
  }
};
var ExtHostLanguageFeatures = class _ExtHostLanguageFeatures extends Disposable {
  static {
    this._handlePool = 0;
  }
  get inlineCompletionsUnificationState() {
    return this._inlineCompletionsUnificationState;
  }
  constructor(mainContext, _uriTransformer, _documents, _commands, _diagnostics, _logService, _apiDeprecation, _extensionTelemetry) {
    super();
    this._uriTransformer = _uriTransformer;
    this._documents = _documents;
    this._commands = _commands;
    this._diagnostics = _diagnostics;
    this._logService = _logService;
    this._apiDeprecation = _apiDeprecation;
    this._extensionTelemetry = _extensionTelemetry;
    this._adapter = /* @__PURE__ */ new Map();
    this._onDidChangeInlineCompletionsUnificationState = this._register(new Emitter());
    this.onDidChangeInlineCompletionsUnificationState = this._onDidChangeInlineCompletionsUnificationState.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadLanguageFeatures);
    this._inlineCompletionsUnificationState = {
      codeUnification: false,
      modelUnification: false,
      extensionUnification: false,
      expAssignments: []
    };
  }
  _transformDocumentSelector(selector, extension) {
    return DocumentSelector.from(selector, this._uriTransformer, extension);
  }
  _createDisposable(handle) {
    return new Disposable2(() => {
      this._adapter.delete(handle);
      this._proxy.$unregister(handle);
    });
  }
  _nextHandle() {
    return _ExtHostLanguageFeatures._handlePool++;
  }
  async _withAdapter(handle, ctor, callback, fallbackValue, tokenToRaceAgainst, doNotLog = false) {
    const data2 = this._adapter.get(handle);
    if (!data2 || !(data2.adapter instanceof ctor)) {
      return fallbackValue;
    }
    const t1 = Date.now();
    if (!doNotLog) {
      this._logService.trace(`[${data2.extension.identifier.value}] INVOKE provider '${callback.toString().replace(/[\r\n]/g, "")}'`);
    }
    const result = callback(data2.adapter, data2.extension);
    Promise.resolve(result).catch((err) => {
      if (!isCancellationError(err)) {
        this._logService.error(`[${data2.extension.identifier.value}] provider FAILED`);
        this._logService.error(err);
        this._extensionTelemetry.onExtensionError(data2.extension.identifier, err);
      }
    }).finally(() => {
      if (!doNotLog) {
        this._logService.trace(`[${data2.extension.identifier.value}] provider DONE after ${Date.now() - t1}ms`);
      }
    });
    if (CancellationToken.isCancellationToken(tokenToRaceAgainst)) {
      return raceCancellationError(result, tokenToRaceAgainst);
    }
    return result;
  }
  _addNewAdapter(adapter, extension) {
    const handle = this._nextHandle();
    this._adapter.set(handle, new AdapterData(adapter, extension));
    return handle;
  }
  static _extLabel(ext) {
    return ext.displayName || ext.name;
  }
  static _extId(ext) {
    return ext.identifier.value;
  }
  // --- outline
  registerDocumentSymbolProvider(extension, selector, provider, metadata) {
    const handle = this._addNewAdapter(new DocumentSymbolAdapter(this._documents, provider), extension);
    const displayName = metadata && metadata.label || _ExtHostLanguageFeatures._extLabel(extension);
    this._proxy.$registerDocumentSymbolProvider(handle, this._transformDocumentSelector(selector, extension), displayName);
    return this._createDisposable(handle);
  }
  $provideDocumentSymbols(handle, resource, token) {
    return this._withAdapter(handle, DocumentSymbolAdapter, (adapter) => adapter.provideDocumentSymbols(URI.revive(resource), token), void 0, token);
  }
  // --- code lens
  registerCodeLensProvider(extension, selector, provider) {
    const handle = this._nextHandle();
    const eventHandle = typeof provider.onDidChangeCodeLenses === "function" ? this._nextHandle() : void 0;
    this._adapter.set(handle, new AdapterData(new CodeLensAdapter(this._documents, this._commands.converter, provider, extension, this._extensionTelemetry, this._logService), extension));
    this._proxy.$registerCodeLensSupport(handle, this._transformDocumentSelector(selector, extension), eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeCodeLenses((_) => this._proxy.$emitCodeLensEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideCodeLenses(handle, resource, token) {
    return this._withAdapter(handle, CodeLensAdapter, (adapter) => adapter.provideCodeLenses(URI.revive(resource), token), void 0, token, resource.scheme === "output");
  }
  $resolveCodeLens(handle, symbol, token) {
    return this._withAdapter(handle, CodeLensAdapter, (adapter) => adapter.resolveCodeLens(symbol, token), void 0, void 0, true);
  }
  $releaseCodeLenses(handle, cacheId) {
    this._withAdapter(handle, CodeLensAdapter, (adapter) => Promise.resolve(adapter.releaseCodeLenses(cacheId)), void 0, void 0, true);
  }
  // --- declaration
  registerDefinitionProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DefinitionAdapter(this._documents, provider), extension);
    this._proxy.$registerDefinitionSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDefinition(handle, resource, position, token) {
    return this._withAdapter(handle, DefinitionAdapter, (adapter) => adapter.provideDefinition(URI.revive(resource), position, token), [], token);
  }
  registerDeclarationProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DeclarationAdapter(this._documents, provider), extension);
    this._proxy.$registerDeclarationSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDeclaration(handle, resource, position, token) {
    return this._withAdapter(handle, DeclarationAdapter, (adapter) => adapter.provideDeclaration(URI.revive(resource), position, token), [], token);
  }
  registerImplementationProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new ImplementationAdapter(this._documents, provider), extension);
    this._proxy.$registerImplementationSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideImplementation(handle, resource, position, token) {
    return this._withAdapter(handle, ImplementationAdapter, (adapter) => adapter.provideImplementation(URI.revive(resource), position, token), [], token);
  }
  registerTypeDefinitionProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new TypeDefinitionAdapter(this._documents, provider), extension);
    this._proxy.$registerTypeDefinitionSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideTypeDefinition(handle, resource, position, token) {
    return this._withAdapter(handle, TypeDefinitionAdapter, (adapter) => adapter.provideTypeDefinition(URI.revive(resource), position, token), [], token);
  }
  // --- extra info
  registerHoverProvider(extension, selector, provider, extensionId) {
    const handle = this._addNewAdapter(new HoverAdapter(this._documents, provider), extension);
    this._proxy.$registerHoverProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideHover(handle, resource, position, context, token) {
    return this._withAdapter(handle, HoverAdapter, (adapter) => adapter.provideHover(URI.revive(resource), position, context, token), void 0, token);
  }
  $releaseHover(handle, id2) {
    this._withAdapter(handle, HoverAdapter, (adapter) => Promise.resolve(adapter.releaseHover(id2)), void 0, void 0);
  }
  // --- debug hover
  registerEvaluatableExpressionProvider(extension, selector, provider, extensionId) {
    const handle = this._addNewAdapter(new EvaluatableExpressionAdapter(this._documents, provider), extension);
    this._proxy.$registerEvaluatableExpressionProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideEvaluatableExpression(handle, resource, position, token) {
    return this._withAdapter(handle, EvaluatableExpressionAdapter, (adapter) => adapter.provideEvaluatableExpression(URI.revive(resource), position, token), void 0, token);
  }
  // --- debug inline values
  registerInlineValuesProvider(extension, selector, provider, extensionId) {
    const eventHandle = typeof provider.onDidChangeInlineValues === "function" ? this._nextHandle() : void 0;
    const handle = this._addNewAdapter(new InlineValuesAdapter(this._documents, provider), extension);
    this._proxy.$registerInlineValuesProvider(handle, this._transformDocumentSelector(selector, extension), eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeInlineValues((_) => this._proxy.$emitInlineValuesEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideInlineValues(handle, resource, range, context, token) {
    return this._withAdapter(handle, InlineValuesAdapter, (adapter) => adapter.provideInlineValues(URI.revive(resource), range, context, token), void 0, token);
  }
  // --- occurrences
  registerDocumentHighlightProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DocumentHighlightAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentHighlightProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  registerMultiDocumentHighlightProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new MultiDocumentHighlightAdapter(this._documents, provider, this._logService), extension);
    this._proxy.$registerMultiDocumentHighlightProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDocumentHighlights(handle, resource, position, token) {
    return this._withAdapter(handle, DocumentHighlightAdapter, (adapter) => adapter.provideDocumentHighlights(URI.revive(resource), position, token), void 0, token);
  }
  $provideMultiDocumentHighlights(handle, resource, position, otherModels, token) {
    return this._withAdapter(handle, MultiDocumentHighlightAdapter, (adapter) => adapter.provideMultiDocumentHighlights(URI.revive(resource), position, otherModels.map((model) => URI.revive(model)), token), void 0, token);
  }
  // --- linked editing
  registerLinkedEditingRangeProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new LinkedEditingRangeAdapter(this._documents, provider), extension);
    this._proxy.$registerLinkedEditingRangeProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideLinkedEditingRanges(handle, resource, position, token) {
    return this._withAdapter(handle, LinkedEditingRangeAdapter, async (adapter) => {
      const res = await adapter.provideLinkedEditingRanges(URI.revive(resource), position, token);
      if (res) {
        return {
          ranges: res.ranges,
          wordPattern: res.wordPattern ? _ExtHostLanguageFeatures._serializeRegExp(res.wordPattern) : void 0
        };
      }
      return void 0;
    }, void 0, token);
  }
  // --- references
  registerReferenceProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new ReferenceAdapter(this._documents, provider), extension);
    this._proxy.$registerReferenceSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideReferences(handle, resource, position, context, token) {
    return this._withAdapter(handle, ReferenceAdapter, (adapter) => adapter.provideReferences(URI.revive(resource), position, context, token), void 0, token);
  }
  // --- code actions
  registerCodeActionProvider(extension, selector, provider, metadata) {
    const store = new DisposableStore();
    const handle = this._addNewAdapter(new CodeActionAdapter(this._documents, this._commands.converter, this._diagnostics, provider, this._logService, extension, this._apiDeprecation), extension);
    this._proxy.$registerCodeActionSupport(handle, this._transformDocumentSelector(selector, extension), {
      providedKinds: metadata?.providedCodeActionKinds?.map((kind) => kind.value),
      documentation: metadata?.documentation?.map((x) => ({
        kind: x.kind.value,
        command: this._commands.converter.toInternal(x.command, store)
      }))
    }, _ExtHostLanguageFeatures._extLabel(extension), _ExtHostLanguageFeatures._extId(extension), Boolean(provider.resolveCodeAction));
    store.add(this._createDisposable(handle));
    return store;
  }
  $provideCodeActions(handle, resource, rangeOrSelection, context, token) {
    return this._withAdapter(handle, CodeActionAdapter, (adapter) => adapter.provideCodeActions(URI.revive(resource), rangeOrSelection, context, token), void 0, token);
  }
  $resolveCodeAction(handle, id2, token) {
    return this._withAdapter(handle, CodeActionAdapter, (adapter) => adapter.resolveCodeAction(id2, token), {}, void 0);
  }
  $releaseCodeActions(handle, cacheId) {
    this._withAdapter(handle, CodeActionAdapter, (adapter) => Promise.resolve(adapter.releaseCodeActions(cacheId)), void 0, void 0);
  }
  // --- formatting
  registerDocumentFormattingEditProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DocumentFormattingAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentFormattingSupport(handle, this._transformDocumentSelector(selector, extension), extension.identifier, extension.displayName || extension.name);
    return this._createDisposable(handle);
  }
  $provideDocumentFormattingEdits(handle, resource, options2, token) {
    return this._withAdapter(handle, DocumentFormattingAdapter, (adapter) => adapter.provideDocumentFormattingEdits(URI.revive(resource), options2, token), void 0, token);
  }
  registerDocumentRangeFormattingEditProvider(extension, selector, provider) {
    const canFormatMultipleRanges = typeof provider.provideDocumentRangesFormattingEdits === "function";
    const handle = this._addNewAdapter(new RangeFormattingAdapter(this._documents, provider), extension);
    this._proxy.$registerRangeFormattingSupport(handle, this._transformDocumentSelector(selector, extension), extension.identifier, extension.displayName || extension.name, canFormatMultipleRanges);
    return this._createDisposable(handle);
  }
  $provideDocumentRangeFormattingEdits(handle, resource, range, options2, token) {
    return this._withAdapter(handle, RangeFormattingAdapter, (adapter) => adapter.provideDocumentRangeFormattingEdits(URI.revive(resource), range, options2, token), void 0, token);
  }
  $provideDocumentRangesFormattingEdits(handle, resource, ranges, options2, token) {
    return this._withAdapter(handle, RangeFormattingAdapter, (adapter) => adapter.provideDocumentRangesFormattingEdits(URI.revive(resource), ranges, options2, token), void 0, token);
  }
  registerOnTypeFormattingEditProvider(extension, selector, provider, triggerCharacters) {
    const handle = this._addNewAdapter(new OnTypeFormattingAdapter(this._documents, provider), extension);
    this._proxy.$registerOnTypeFormattingSupport(handle, this._transformDocumentSelector(selector, extension), triggerCharacters, extension.identifier);
    return this._createDisposable(handle);
  }
  $provideOnTypeFormattingEdits(handle, resource, position, ch, options2, token) {
    return this._withAdapter(handle, OnTypeFormattingAdapter, (adapter) => adapter.provideOnTypeFormattingEdits(URI.revive(resource), position, ch, options2, token), void 0, token);
  }
  // --- navigate types
  registerWorkspaceSymbolProvider(extension, provider) {
    const handle = this._addNewAdapter(new NavigateTypeAdapter(provider, this._logService), extension);
    this._proxy.$registerNavigateTypeSupport(handle, typeof provider.resolveWorkspaceSymbol === "function");
    return this._createDisposable(handle);
  }
  $provideWorkspaceSymbols(handle, search, token) {
    return this._withAdapter(handle, NavigateTypeAdapter, (adapter) => adapter.provideWorkspaceSymbols(search, token), { symbols: [] }, token);
  }
  $resolveWorkspaceSymbol(handle, symbol, token) {
    return this._withAdapter(handle, NavigateTypeAdapter, (adapter) => adapter.resolveWorkspaceSymbol(symbol, token), void 0, void 0);
  }
  $releaseWorkspaceSymbols(handle, id2) {
    this._withAdapter(handle, NavigateTypeAdapter, (adapter) => adapter.releaseWorkspaceSymbols(id2), void 0, void 0);
  }
  // --- rename
  registerRenameProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new RenameAdapter(this._documents, provider, this._logService), extension);
    this._proxy.$registerRenameSupport(handle, this._transformDocumentSelector(selector, extension), RenameAdapter.supportsResolving(provider));
    return this._createDisposable(handle);
  }
  $provideRenameEdits(handle, resource, position, newName, token) {
    return this._withAdapter(handle, RenameAdapter, (adapter) => adapter.provideRenameEdits(URI.revive(resource), position, newName, token), void 0, token);
  }
  $resolveRenameLocation(handle, resource, position, token) {
    return this._withAdapter(handle, RenameAdapter, (adapter) => adapter.resolveRenameLocation(URI.revive(resource), position, token), void 0, token);
  }
  registerNewSymbolNamesProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new NewSymbolNamesAdapter(this._documents, provider, this._logService), extension);
    this._proxy.$registerNewSymbolNamesProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $supportsAutomaticNewSymbolNamesTriggerKind(handle) {
    return this._withAdapter(handle, NewSymbolNamesAdapter, (adapter) => adapter.supportsAutomaticNewSymbolNamesTriggerKind(), false, void 0);
  }
  $provideNewSymbolNames(handle, resource, range, triggerKind, token) {
    return this._withAdapter(handle, NewSymbolNamesAdapter, (adapter) => adapter.provideNewSymbolNames(URI.revive(resource), range, triggerKind, token), void 0, token);
  }
  //#region semantic coloring
  registerDocumentSemanticTokensProvider(extension, selector, provider, legend) {
    const handle = this._addNewAdapter(new DocumentSemanticTokensAdapter(this._documents, provider), extension);
    const eventHandle = typeof provider.onDidChangeSemanticTokens === "function" ? this._nextHandle() : void 0;
    this._proxy.$registerDocumentSemanticTokensProvider(handle, this._transformDocumentSelector(selector, extension), legend, eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle) {
      const subscription = provider.onDidChangeSemanticTokens((_) => this._proxy.$emitDocumentSemanticTokensEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideDocumentSemanticTokens(handle, resource, previousResultId, token) {
    return this._withAdapter(handle, DocumentSemanticTokensAdapter, (adapter) => adapter.provideDocumentSemanticTokens(URI.revive(resource), previousResultId, token), null, token);
  }
  $releaseDocumentSemanticTokens(handle, semanticColoringResultId) {
    this._withAdapter(handle, DocumentSemanticTokensAdapter, (adapter) => adapter.releaseDocumentSemanticColoring(semanticColoringResultId), void 0, void 0);
  }
  registerDocumentRangeSemanticTokensProvider(extension, selector, provider, legend) {
    const handle = this._addNewAdapter(new DocumentRangeSemanticTokensAdapter(this._documents, provider), extension);
    const eventHandle = typeof provider.onDidChangeSemanticTokens === "function" ? this._nextHandle() : void 0;
    this._proxy.$registerDocumentRangeSemanticTokensProvider(handle, this._transformDocumentSelector(selector, extension), legend, eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle) {
      const subscription = provider.onDidChangeSemanticTokens((_) => this._proxy.$emitDocumentRangeSemanticTokensEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideDocumentRangeSemanticTokens(handle, resource, range, token) {
    return this._withAdapter(handle, DocumentRangeSemanticTokensAdapter, (adapter) => adapter.provideDocumentRangeSemanticTokens(URI.revive(resource), range, token), null, token);
  }
  //#endregion
  // --- suggestion
  registerCompletionItemProvider(extension, selector, provider, triggerCharacters) {
    const handle = this._addNewAdapter(new CompletionsAdapter(this._documents, this._commands.converter, provider, this._apiDeprecation, extension), extension);
    this._proxy.$registerCompletionsProvider(handle, this._transformDocumentSelector(selector, extension), triggerCharacters, CompletionsAdapter.supportsResolving(provider), extension.identifier);
    return this._createDisposable(handle);
  }
  $provideCompletionItems(handle, resource, position, context, token) {
    return this._withAdapter(handle, CompletionsAdapter, (adapter) => adapter.provideCompletionItems(URI.revive(resource), position, context, token), void 0, token);
  }
  $resolveCompletionItem(handle, id2, token) {
    return this._withAdapter(handle, CompletionsAdapter, (adapter) => adapter.resolveCompletionItem(id2, token), void 0, token);
  }
  $releaseCompletionItems(handle, id2) {
    this._withAdapter(handle, CompletionsAdapter, (adapter) => adapter.releaseCompletionItems(id2), void 0, void 0);
  }
  // --- ghost text
  registerInlineCompletionsProvider(extension, selector, provider, metadata) {
    const eventHandle = typeof provider.onDidChange === "function" && isProposedApiEnabled(extension, "inlineCompletionsAdditions") ? this._nextHandle() : void 0;
    const adapter = new InlineCompletionAdapter(extension, this._documents, provider, this._commands.converter);
    const handle = this._addNewAdapter(adapter, extension);
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChange((_) => this._proxy.$emitInlineCompletionsChange(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    this._proxy.$registerInlineCompletionsSupport(handle, this._transformDocumentSelector(selector, extension), adapter.supportsHandleEvents, ExtensionIdentifier.toKey(extension.identifier.value), extension.version, metadata?.groupId ? ExtensionIdentifier.toKey(metadata.groupId) : void 0, metadata?.yieldTo?.map((extId) => ExtensionIdentifier.toKey(extId)) || [], metadata?.displayName, metadata?.debounceDelayMs, metadata?.excludes?.map((extId) => ExtensionIdentifier.toKey(extId)) || [], eventHandle);
    return result;
  }
  $provideInlineCompletions(handle, resource, position, context, token) {
    return this._withAdapter(handle, InlineCompletionAdapter, (adapter) => adapter.provideInlineCompletions(URI.revive(resource), position, context, token), void 0, void 0);
  }
  $handleInlineCompletionDidShow(handle, pid, idx, updatedInsertText) {
    this._withAdapter(handle, InlineCompletionAdapter, async (adapter) => {
      adapter.handleDidShowCompletionItem(pid, idx, updatedInsertText);
    }, void 0, void 0);
  }
  $handleInlineCompletionPartialAccept(handle, pid, idx, acceptedCharacters, info) {
    this._withAdapter(handle, InlineCompletionAdapter, async (adapter) => {
      adapter.handlePartialAccept(pid, idx, acceptedCharacters, info);
    }, void 0, void 0);
  }
  $handleInlineCompletionEndOfLifetime(handle, pid, idx, reason) {
    this._withAdapter(handle, InlineCompletionAdapter, async (adapter) => {
      adapter.handleEndOfLifetime(pid, idx, reason);
    }, void 0, void 0);
  }
  $handleInlineCompletionRejection(handle, pid, idx) {
    this._withAdapter(handle, InlineCompletionAdapter, async (adapter) => {
      adapter.handleRejection(pid, idx);
    }, void 0, void 0);
  }
  $freeInlineCompletionsList(handle, pid, reason) {
    this._withAdapter(handle, InlineCompletionAdapter, async (adapter) => {
      adapter.disposeCompletions(pid, reason);
    }, void 0, void 0);
  }
  $acceptInlineCompletionsUnificationState(state) {
    this._inlineCompletionsUnificationState = state;
    this._onDidChangeInlineCompletionsUnificationState.fire();
  }
  // --- parameter hints
  registerSignatureHelpProvider(extension, selector, provider, metadataOrTriggerChars) {
    const metadata = Array.isArray(metadataOrTriggerChars) ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] } : metadataOrTriggerChars;
    const handle = this._addNewAdapter(new SignatureHelpAdapter(this._documents, provider), extension);
    this._proxy.$registerSignatureHelpProvider(handle, this._transformDocumentSelector(selector, extension), metadata);
    return this._createDisposable(handle);
  }
  $provideSignatureHelp(handle, resource, position, context, token) {
    return this._withAdapter(handle, SignatureHelpAdapter, (adapter) => adapter.provideSignatureHelp(URI.revive(resource), position, context, token), void 0, token);
  }
  $releaseSignatureHelp(handle, id2) {
    this._withAdapter(handle, SignatureHelpAdapter, (adapter) => adapter.releaseSignatureHelp(id2), void 0, void 0);
  }
  // --- inline hints
  registerInlayHintsProvider(extension, selector, provider) {
    const eventHandle = typeof provider.onDidChangeInlayHints === "function" ? this._nextHandle() : void 0;
    const handle = this._addNewAdapter(new InlayHintsAdapter(this._documents, this._commands.converter, provider, this._logService, extension), extension);
    this._proxy.$registerInlayHintsProvider(handle, this._transformDocumentSelector(selector, extension), typeof provider.resolveInlayHint === "function", eventHandle, _ExtHostLanguageFeatures._extLabel(extension));
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeInlayHints((uri) => this._proxy.$emitInlayHintsEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideInlayHints(handle, resource, range, token) {
    return this._withAdapter(handle, InlayHintsAdapter, (adapter) => adapter.provideInlayHints(URI.revive(resource), range, token), void 0, token);
  }
  $resolveInlayHint(handle, id2, token) {
    return this._withAdapter(handle, InlayHintsAdapter, (adapter) => adapter.resolveInlayHint(id2, token), void 0, token);
  }
  $releaseInlayHints(handle, id2) {
    this._withAdapter(handle, InlayHintsAdapter, (adapter) => adapter.releaseHints(id2), void 0, void 0);
  }
  // --- links
  registerDocumentLinkProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new LinkProviderAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentLinkProvider(handle, this._transformDocumentSelector(selector, extension), typeof provider.resolveDocumentLink === "function");
    return this._createDisposable(handle);
  }
  $provideDocumentLinks(handle, resource, token) {
    return this._withAdapter(handle, LinkProviderAdapter, (adapter) => adapter.provideLinks(URI.revive(resource), token), void 0, token, resource.scheme === "output");
  }
  $resolveDocumentLink(handle, id2, token) {
    return this._withAdapter(handle, LinkProviderAdapter, (adapter) => adapter.resolveLink(id2, token), void 0, void 0, true);
  }
  $releaseDocumentLinks(handle, id2) {
    this._withAdapter(handle, LinkProviderAdapter, (adapter) => adapter.releaseLinks(id2), void 0, void 0, true);
  }
  registerColorProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new ColorProviderAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentColorProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDocumentColors(handle, resource, token) {
    return this._withAdapter(handle, ColorProviderAdapter, (adapter) => adapter.provideColors(URI.revive(resource), token), [], token);
  }
  $provideColorPresentations(handle, resource, colorInfo, token) {
    return this._withAdapter(handle, ColorProviderAdapter, (adapter) => adapter.provideColorPresentations(URI.revive(resource), colorInfo, token), void 0, token);
  }
  registerFoldingRangeProvider(extension, selector, provider) {
    const handle = this._nextHandle();
    const eventHandle = typeof provider.onDidChangeFoldingRanges === "function" ? this._nextHandle() : void 0;
    this._adapter.set(handle, new AdapterData(new FoldingProviderAdapter(this._documents, provider), extension));
    this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector, extension), extension.identifier, eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeFoldingRanges(() => this._proxy.$emitFoldingRangeEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideFoldingRanges(handle, resource, context, token) {
    return this._withAdapter(handle, FoldingProviderAdapter, (adapter) => adapter.provideFoldingRanges(URI.revive(resource), context, token), void 0, token);
  }
  // --- smart select
  registerSelectionRangeProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new SelectionRangeAdapter(this._documents, provider, this._logService), extension);
    this._proxy.$registerSelectionRangeProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideSelectionRanges(handle, resource, positions, token) {
    return this._withAdapter(handle, SelectionRangeAdapter, (adapter) => adapter.provideSelectionRanges(URI.revive(resource), positions, token), [], token);
  }
  // --- call hierarchy
  registerCallHierarchyProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new CallHierarchyAdapter(this._documents, provider), extension);
    this._proxy.$registerCallHierarchyProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $prepareCallHierarchy(handle, resource, position, token) {
    return this._withAdapter(handle, CallHierarchyAdapter, (adapter) => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), void 0, token);
  }
  $provideCallHierarchyIncomingCalls(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, CallHierarchyAdapter, (adapter) => adapter.provideCallsTo(sessionId, itemId, token), void 0, token);
  }
  $provideCallHierarchyOutgoingCalls(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, CallHierarchyAdapter, (adapter) => adapter.provideCallsFrom(sessionId, itemId, token), void 0, token);
  }
  $releaseCallHierarchy(handle, sessionId) {
    this._withAdapter(handle, CallHierarchyAdapter, (adapter) => Promise.resolve(adapter.releaseSession(sessionId)), void 0, void 0);
  }
  // --- type hierarchy
  registerTypeHierarchyProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new TypeHierarchyAdapter(this._documents, provider), extension);
    this._proxy.$registerTypeHierarchyProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $prepareTypeHierarchy(handle, resource, position, token) {
    return this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), void 0, token);
  }
  $provideTypeHierarchySupertypes(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => adapter.provideSupertypes(sessionId, itemId, token), void 0, token);
  }
  $provideTypeHierarchySubtypes(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => adapter.provideSubtypes(sessionId, itemId, token), void 0, token);
  }
  $releaseTypeHierarchy(handle, sessionId) {
    this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => Promise.resolve(adapter.releaseSession(sessionId)), void 0, void 0);
  }
  // --- Document on drop
  registerDocumentOnDropEditProvider(extension, selector, provider, metadata) {
    const handle = this._nextHandle();
    this._adapter.set(handle, new AdapterData(new DocumentDropEditAdapter(this._proxy, this._documents, provider, handle, extension), extension));
    this._proxy.$registerDocumentOnDropEditProvider(handle, this._transformDocumentSelector(selector, extension), metadata ? {
      supportsResolve: !!provider.resolveDocumentDropEdit,
      dropMimeTypes: metadata.dropMimeTypes,
      providedDropKinds: metadata.providedDropEditKinds?.map((x) => x.value)
    } : void 0);
    return this._createDisposable(handle);
  }
  $provideDocumentOnDropEdits(handle, requestId, resource, position, dataTransferDto, token) {
    return this._withAdapter(handle, DocumentDropEditAdapter, (adapter) => Promise.resolve(adapter.provideDocumentOnDropEdits(requestId, URI.revive(resource), position, dataTransferDto, token)), void 0, void 0);
  }
  $resolveDropEdit(handle, id2, token) {
    return this._withAdapter(handle, DocumentDropEditAdapter, (adapter) => adapter.resolveDropEdit(id2, token), {}, void 0);
  }
  $releaseDocumentOnDropEdits(handle, cacheId) {
    this._withAdapter(handle, DocumentDropEditAdapter, (adapter) => Promise.resolve(adapter.releaseDropEdits(cacheId)), void 0, void 0);
  }
  // --- copy/paste actions
  registerDocumentPasteEditProvider(extension, selector, provider, metadata) {
    const handle = this._nextHandle();
    this._adapter.set(handle, new AdapterData(new DocumentPasteEditProvider(this._proxy, this._documents, provider, handle, extension), extension));
    this._proxy.$registerPasteEditProvider(handle, this._transformDocumentSelector(selector, extension), {
      supportsCopy: !!provider.prepareDocumentPaste,
      supportsPaste: !!provider.provideDocumentPasteEdits,
      supportsResolve: !!provider.resolveDocumentPasteEdit,
      providedPasteEditKinds: metadata.providedPasteEditKinds?.map((x) => x.value),
      copyMimeTypes: metadata.copyMimeTypes,
      pasteMimeTypes: metadata.pasteMimeTypes
    });
    return this._createDisposable(handle);
  }
  $prepareDocumentPaste(handle, resource, ranges, dataTransfer, token) {
    return this._withAdapter(handle, DocumentPasteEditProvider, (adapter) => adapter.prepareDocumentPaste(URI.revive(resource), ranges, dataTransfer, token), void 0, token);
  }
  $providePasteEdits(handle, requestId, resource, ranges, dataTransferDto, context, token) {
    return this._withAdapter(handle, DocumentPasteEditProvider, (adapter) => adapter.providePasteEdits(requestId, URI.revive(resource), ranges, dataTransferDto, context, token), void 0, token);
  }
  $resolvePasteEdit(handle, id2, token) {
    return this._withAdapter(handle, DocumentPasteEditProvider, (adapter) => adapter.resolvePasteEdit(id2, token), {}, void 0);
  }
  $releasePasteEdits(handle, cacheId) {
    this._withAdapter(handle, DocumentPasteEditProvider, (adapter) => Promise.resolve(adapter.releasePasteEdits(cacheId)), void 0, void 0);
  }
  // --- configuration
  static _serializeRegExp(regExp) {
    return {
      pattern: regExp.source,
      flags: regExp.flags
    };
  }
  static _serializeIndentationRule(indentationRule) {
    return {
      decreaseIndentPattern: _ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),
      increaseIndentPattern: _ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),
      indentNextLinePattern: indentationRule.indentNextLinePattern ? _ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern) : void 0,
      unIndentedLinePattern: indentationRule.unIndentedLinePattern ? _ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern) : void 0
    };
  }
  static _serializeOnEnterRule(onEnterRule) {
    return {
      beforeText: _ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),
      afterText: onEnterRule.afterText ? _ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText) : void 0,
      previousLineText: onEnterRule.previousLineText ? _ExtHostLanguageFeatures._serializeRegExp(onEnterRule.previousLineText) : void 0,
      action: onEnterRule.action
    };
  }
  static _serializeOnEnterRules(onEnterRules) {
    return onEnterRules.map(_ExtHostLanguageFeatures._serializeOnEnterRule);
  }
  static _serializeAutoClosingPair(autoClosingPair) {
    return {
      open: autoClosingPair.open,
      close: autoClosingPair.close,
      notIn: autoClosingPair.notIn ? autoClosingPair.notIn.map((v) => SyntaxTokenType.toString(v)) : void 0
    };
  }
  static _serializeAutoClosingPairs(autoClosingPairs) {
    return autoClosingPairs.map(_ExtHostLanguageFeatures._serializeAutoClosingPair);
  }
  setLanguageConfiguration(extension, languageId, configuration) {
    const { wordPattern } = configuration;
    if (wordPattern && regExpLeadsToEndlessLoop(wordPattern)) {
      throw new Error(`Invalid language configuration: wordPattern '${wordPattern}' is not allowed to match the empty string.`);
    }
    if (wordPattern) {
      this._documents.setWordDefinitionFor(languageId, wordPattern);
    } else {
      this._documents.setWordDefinitionFor(languageId, void 0);
    }
    if (configuration.__electricCharacterSupport) {
      this._apiDeprecation.report("LanguageConfiguration.__electricCharacterSupport", extension, `Do not use.`);
    }
    if (configuration.__characterPairSupport) {
      this._apiDeprecation.report("LanguageConfiguration.__characterPairSupport", extension, `Do not use.`);
    }
    const handle = this._nextHandle();
    const serializedConfiguration = {
      comments: configuration.comments,
      brackets: configuration.brackets,
      wordPattern: configuration.wordPattern ? _ExtHostLanguageFeatures._serializeRegExp(configuration.wordPattern) : void 0,
      indentationRules: configuration.indentationRules ? _ExtHostLanguageFeatures._serializeIndentationRule(configuration.indentationRules) : void 0,
      onEnterRules: configuration.onEnterRules ? _ExtHostLanguageFeatures._serializeOnEnterRules(configuration.onEnterRules) : void 0,
      __electricCharacterSupport: configuration.__electricCharacterSupport,
      __characterPairSupport: configuration.__characterPairSupport,
      autoClosingPairs: configuration.autoClosingPairs ? _ExtHostLanguageFeatures._serializeAutoClosingPairs(configuration.autoClosingPairs) : void 0
    };
    this._proxy.$setLanguageConfiguration(handle, languageId, serializedConfiguration);
    return this._createDisposable(handle);
  }
  $setWordDefinitions(wordDefinitions) {
    for (const wordDefinition of wordDefinitions) {
      this._documents.setWordDefinitionFor(wordDefinition.languageId, new RegExp(wordDefinition.regexSource, wordDefinition.regexFlags));
    }
  }
};

// out-build/vs/workbench/contrib/notebook/common/notebookService.js
var INotebookService = createDecorator("notebookService");

// out-build/vs/workbench/contrib/chat/common/chatCodeMapperService.js
var ICodeMapperService = createDecorator("codeMapperService");

// out-build/vs/workbench/contrib/chat/common/chatUri.js
var LocalChatSessionUri;
(function(LocalChatSessionUri2) {
  LocalChatSessionUri2.scheme = Schemas.vscodeLocalChatSession;
  function forSession(sessionId) {
    const encodedId = encodeBase64(VSBuffer.wrap(new TextEncoder().encode(sessionId)), false, true);
    return URI.from({ scheme: LocalChatSessionUri2.scheme, authority: localChatSessionType, path: "/" + encodedId });
  }
  LocalChatSessionUri2.forSession = forSession;
  function parseLocalSessionId(resource) {
    const parsed = parse6(resource);
    return parsed?.chatSessionType === localChatSessionType ? parsed.sessionId : void 0;
  }
  LocalChatSessionUri2.parseLocalSessionId = parseLocalSessionId;
  function parse6(resource) {
    if (resource.scheme !== LocalChatSessionUri2.scheme) {
      return void 0;
    }
    if (!resource.authority) {
      return void 0;
    }
    const parts = resource.path.split("/");
    if (parts.length !== 2) {
      return void 0;
    }
    const chatSessionType = resource.authority;
    const decodedSessionId = decodeBase64(parts[1]);
    return { chatSessionType, sessionId: new TextDecoder().decode(decodedSessionId.buffer) };
  }
})(LocalChatSessionUri || (LocalChatSessionUri = {}));
function chatSessionResourceToId(resource) {
  const localId = LocalChatSessionUri.parseLocalSessionId(resource);
  if (localId) {
    return localId;
  }
  return resource.toString();
}

// out-build/vs/workbench/contrib/chat/common/tools/editFileTool.js
var ExtensionEditToolId = "vscode_editFile";
var InternalEditToolId = "vscode_editFile_internal";
var EditToolData = {
  id: InternalEditToolId,
  displayName: "",
  // not used
  modelDescription: "",
  // Not used
  source: ToolDataSource.Internal
};
var EditTool = class EditTool2 {
  constructor(chatService, codeMapperService, notebookService) {
    this.chatService = chatService;
    this.codeMapperService = codeMapperService;
    this.notebookService = notebookService;
  }
  async invoke(invocation, countTokens, _progress, token) {
    if (!invocation.context) {
      throw new Error("toolInvocationToken is required for this tool");
    }
    const parameters = invocation.parameters;
    const fileUri = URI.revive(parameters.uri);
    const uri = CellUri.parse(fileUri)?.notebook || fileUri;
    const model = this.chatService.getSession(LocalChatSessionUri.forSession(invocation.context?.sessionId));
    const request = model.getRequests().at(-1);
    model.acceptResponseProgress(request, {
      kind: "markdownContent",
      content: new MarkdownString("\n````\n")
    });
    model.acceptResponseProgress(request, {
      kind: "codeblockUri",
      uri,
      isEdit: true
    });
    model.acceptResponseProgress(request, {
      kind: "markdownContent",
      content: new MarkdownString("\n````\n")
    });
    if (this.notebookService.hasSupportedNotebooks(uri) && this.notebookService.getNotebookTextModel(uri)) {
      model.acceptResponseProgress(request, {
        kind: "notebookEdit",
        edits: [],
        uri
      });
    } else {
      model.acceptResponseProgress(request, {
        kind: "textEdit",
        edits: [],
        uri
      });
    }
    const editSession = model.editingSession;
    if (!editSession) {
      throw new Error("This tool must be called from within an editing session");
    }
    const result = await this.codeMapperService.mapCode({
      codeBlocks: [{ code: parameters.code, resource: uri, markdownBeforeBlock: parameters.explanation }],
      location: "tool",
      chatRequestId: invocation.chatRequestId,
      chatRequestModel: invocation.modelId,
      chatSessionId: invocation.context.sessionId
    }, {
      textEdit: (target, edits) => {
        model.acceptResponseProgress(request, { kind: "textEdit", uri: target, edits });
      },
      notebookEdit(target, edits) {
        model.acceptResponseProgress(request, { kind: "notebookEdit", uri: target, edits });
      }
    }, token);
    if (this.notebookService.hasSupportedNotebooks(uri) && this.notebookService.getNotebookTextModel(uri)) {
      model.acceptResponseProgress(request, { kind: "notebookEdit", uri, edits: [], done: true });
    } else {
      model.acceptResponseProgress(request, { kind: "textEdit", uri, edits: [], done: true });
    }
    if (result?.errorMessage) {
      throw new Error(result.errorMessage);
    }
    let dispose2;
    await new Promise((resolve2) => {
      let wasFileBeingModified = false;
      dispose2 = autorun((r) => {
        const entries = editSession.entries.read(r);
        const currentFile = entries?.find((e) => e.modifiedURI.toString() === uri.toString());
        if (currentFile) {
          if (currentFile.isCurrentlyBeingModifiedBy.read(r)) {
            wasFileBeingModified = true;
          } else if (wasFileBeingModified) {
            resolve2(true);
          }
        }
      });
    }).finally(() => {
      dispose2.dispose();
    });
    return {
      content: [{ kind: "text", value: "The file was edited successfully" }]
    };
  }
  async prepareToolInvocation(context, token) {
    return {
      presentation: ToolInvocationPresentation.Hidden
    };
  }
};
EditTool = __decorate([
  __param(0, IChatService),
  __param(1, ICodeMapperService),
  __param(2, INotebookService)
], EditTool);

// out-build/vs/workbench/contrib/chat/common/tools/confirmationTool.js
var ConfirmationToolId = "vscode_get_confirmation";
var ConfirmationToolData = {
  id: ConfirmationToolId,
  displayName: "Confirmation Tool",
  modelDescription: "A tool that demonstrates different types of confirmations. Takes a title, message, and confirmation type (basic or terminal).",
  source: ToolDataSource.Internal,
  inputSchema: {
    type: "object",
    properties: {
      title: {
        type: "string",
        description: "Title for the confirmation dialog"
      },
      message: {
        type: "string",
        description: "Message to show in the confirmation dialog"
      },
      confirmationType: {
        type: "string",
        enum: ["basic", "terminal"],
        description: "Type of confirmation to show - basic for simple confirmation, terminal for terminal command confirmation"
      },
      terminalCommand: {
        type: "string",
        description: 'Terminal command to show (only used when confirmationType is "terminal")'
      }
    },
    required: ["title", "message", "confirmationType"],
    additionalProperties: false
  }
};
var ConfirmationTool = class {
  async prepareToolInvocation(context, token) {
    const parameters = context.parameters;
    if (!parameters.title || !parameters.message) {
      throw new Error("Missing required parameters for ConfirmationTool");
    }
    const confirmationType = parameters.confirmationType ?? "basic";
    let toolSpecificData;
    if (confirmationType === "terminal") {
      toolSpecificData = {
        kind: "terminal",
        commandLine: {
          original: parameters.terminalCommand ?? ""
        },
        language: "bash"
      };
    } else {
      toolSpecificData = void 0;
    }
    return {
      confirmationMessages: {
        title: parameters.title,
        message: new MarkdownString(parameters.message),
        allowAutoConfirm: true
      },
      toolSpecificData,
      presentation: ToolInvocationPresentation.HiddenAfterComplete
    };
  }
  async invoke(invocation, countTokens, progress, token) {
    return {
      content: [{
        kind: "text",
        value: "yes"
        // Consumers should check for this label to know whether the tool was confirmed or skipped
      }]
    };
  }
};

// out-build/vs/base/parts/storage/common/storage.js
var StorageHint;
(function(StorageHint2) {
  StorageHint2[StorageHint2["STORAGE_DOES_NOT_EXIST"] = 0] = "STORAGE_DOES_NOT_EXIST";
  StorageHint2[StorageHint2["STORAGE_IN_MEMORY"] = 1] = "STORAGE_IN_MEMORY";
})(StorageHint || (StorageHint = {}));
var StorageState;
(function(StorageState2) {
  StorageState2[StorageState2["None"] = 0] = "None";
  StorageState2[StorageState2["Initialized"] = 1] = "Initialized";
  StorageState2[StorageState2["Closed"] = 2] = "Closed";
})(StorageState || (StorageState = {}));
var Storage = class _Storage extends Disposable {
  static {
    this.DEFAULT_FLUSH_DELAY = 100;
  }
  constructor(database, options2 = /* @__PURE__ */ Object.create(null)) {
    super();
    this.database = database;
    this.options = options2;
    this._onDidChangeStorage = this._register(new PauseableEmitter());
    this.onDidChangeStorage = this._onDidChangeStorage.event;
    this.state = StorageState.None;
    this.cache = /* @__PURE__ */ new Map();
    this.flushDelayer = this._register(new ThrottledDelayer(_Storage.DEFAULT_FLUSH_DELAY));
    this.pendingDeletes = /* @__PURE__ */ new Set();
    this.pendingInserts = /* @__PURE__ */ new Map();
    this.pendingClose = void 0;
    this.whenFlushedCallbacks = [];
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    this._onDidChangeStorage.pause();
    try {
      e.changed?.forEach((value, key) => this.acceptExternal(key, value));
      e.deleted?.forEach((key) => this.acceptExternal(key, void 0));
    } finally {
      this._onDidChangeStorage.resume();
    }
  }
  acceptExternal(key, value) {
    if (this.state === StorageState.Closed) {
      return;
    }
    let changed = false;
    if (isUndefinedOrNull(value)) {
      changed = this.cache.delete(key);
    } else {
      const currentValue = this.cache.get(key);
      if (currentValue !== value) {
        this.cache.set(key, value);
        changed = true;
      }
    }
    if (changed) {
      this._onDidChangeStorage.fire({ key, external: true });
    }
  }
  get items() {
    return this.cache;
  }
  get size() {
    return this.cache.size;
  }
  async init() {
    if (this.state !== StorageState.None) {
      return;
    }
    this.state = StorageState.Initialized;
    if (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {
      return;
    }
    this.cache = await this.database.getItems();
  }
  get(key, fallbackValue) {
    const value = this.cache.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value;
  }
  getBoolean(key, fallbackValue) {
    const value = this.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value === "true";
  }
  getNumber(key, fallbackValue) {
    const value = this.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return parseInt(value, 10);
  }
  getObject(key, fallbackValue) {
    const value = this.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return parse2(value);
  }
  async set(key, value, external = false) {
    if (this.state === StorageState.Closed) {
      return;
    }
    if (isUndefinedOrNull(value)) {
      return this.delete(key, external);
    }
    const valueStr = isObject(value) || Array.isArray(value) ? stringify2(value) : String(value);
    const currentValue = this.cache.get(key);
    if (currentValue === valueStr) {
      return;
    }
    this.cache.set(key, valueStr);
    this.pendingInserts.set(key, valueStr);
    this.pendingDeletes.delete(key);
    this._onDidChangeStorage.fire({ key, external });
    return this.doFlush();
  }
  async delete(key, external = false) {
    if (this.state === StorageState.Closed) {
      return;
    }
    const wasDeleted = this.cache.delete(key);
    if (!wasDeleted) {
      return;
    }
    if (!this.pendingDeletes.has(key)) {
      this.pendingDeletes.add(key);
    }
    this.pendingInserts.delete(key);
    this._onDidChangeStorage.fire({ key, external });
    return this.doFlush();
  }
  async optimize() {
    if (this.state === StorageState.Closed) {
      return;
    }
    await this.flush(0);
    return this.database.optimize();
  }
  async close() {
    if (!this.pendingClose) {
      this.pendingClose = this.doClose();
    }
    return this.pendingClose;
  }
  async doClose() {
    this.state = StorageState.Closed;
    try {
      await this.doFlush(
        0
        /* as soon as possible */
      );
    } catch {
    }
    await this.database.close(() => this.cache);
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  async flushPending() {
    if (!this.hasPending) {
      return;
    }
    const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };
    this.pendingDeletes = /* @__PURE__ */ new Set();
    this.pendingInserts = /* @__PURE__ */ new Map();
    return this.database.updateItems(updateRequest).finally(() => {
      if (!this.hasPending) {
        while (this.whenFlushedCallbacks.length) {
          this.whenFlushedCallbacks.pop()?.();
        }
      }
    });
  }
  async flush(delay) {
    if (this.state === StorageState.Closed || // Return early if we are already closed
    this.pendingClose) {
      return;
    }
    return this.doFlush(delay);
  }
  async doFlush(delay) {
    if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {
      return this.flushPending();
    }
    return this.flushDelayer.trigger(() => this.flushPending(), delay);
  }
  async whenFlushed() {
    if (!this.hasPending) {
      return;
    }
    return new Promise((resolve2) => this.whenFlushedCallbacks.push(resolve2));
  }
  isInMemory() {
    return this.options.hint === StorageHint.STORAGE_IN_MEMORY;
  }
};

// out-build/vs/platform/userDataProfile/common/userDataProfile.js
var ProfileResourceType;
(function(ProfileResourceType2) {
  ProfileResourceType2["Settings"] = "settings";
  ProfileResourceType2["Keybindings"] = "keybindings";
  ProfileResourceType2["Snippets"] = "snippets";
  ProfileResourceType2["Prompts"] = "prompts";
  ProfileResourceType2["Tasks"] = "tasks";
  ProfileResourceType2["Extensions"] = "extensions";
  ProfileResourceType2["GlobalState"] = "globalState";
  ProfileResourceType2["Mcp"] = "mcp";
})(ProfileResourceType || (ProfileResourceType = {}));
function isUserDataProfile(thing) {
  const candidate = thing;
  return !!(candidate && typeof candidate === "object" && typeof candidate.id === "string" && typeof candidate.isDefault === "boolean" && typeof candidate.name === "string" && URI.isUri(candidate.location) && URI.isUri(candidate.globalStorageHome) && URI.isUri(candidate.settingsResource) && URI.isUri(candidate.keybindingsResource) && URI.isUri(candidate.tasksResource) && URI.isUri(candidate.snippetsHome) && URI.isUri(candidate.promptsHome) && URI.isUri(candidate.extensionsResource) && URI.isUri(candidate.mcpResource));
}
var IUserDataProfilesService = createDecorator("IUserDataProfilesService");
function toUserDataProfile(id2, name2, location2, profilesCacheHome, options2, defaultProfile) {
  return {
    id: id2,
    name: name2,
    location: location2,
    isDefault: false,
    icon: options2?.icon,
    globalStorageHome: defaultProfile && options2?.useDefaultFlags?.globalState ? defaultProfile.globalStorageHome : joinPath(location2, "globalStorage"),
    settingsResource: defaultProfile && options2?.useDefaultFlags?.settings ? defaultProfile.settingsResource : joinPath(location2, "settings.json"),
    keybindingsResource: defaultProfile && options2?.useDefaultFlags?.keybindings ? defaultProfile.keybindingsResource : joinPath(location2, "keybindings.json"),
    tasksResource: defaultProfile && options2?.useDefaultFlags?.tasks ? defaultProfile.tasksResource : joinPath(location2, "tasks.json"),
    snippetsHome: defaultProfile && options2?.useDefaultFlags?.snippets ? defaultProfile.snippetsHome : joinPath(location2, "snippets"),
    promptsHome: defaultProfile && options2?.useDefaultFlags?.prompts ? defaultProfile.promptsHome : joinPath(location2, "prompts"),
    extensionsResource: defaultProfile && options2?.useDefaultFlags?.extensions ? defaultProfile.extensionsResource : joinPath(location2, "extensions.json"),
    mcpResource: defaultProfile && options2?.useDefaultFlags?.mcp ? defaultProfile.mcpResource : joinPath(location2, "mcp.json"),
    cacheHome: joinPath(profilesCacheHome, id2),
    useDefaultFlags: options2?.useDefaultFlags,
    isTransient: options2?.transient,
    workspaces: options2?.workspaces
  };
}
var UserDataProfilesService = class UserDataProfilesService2 extends Disposable {
  static {
    this.PROFILES_KEY = "userDataProfiles";
  }
  static {
    this.PROFILE_ASSOCIATIONS_KEY = "profileAssociations";
  }
  get defaultProfile() {
    return this.profiles[0];
  }
  get profiles() {
    return [...this.profilesObject.profiles, ...this.transientProfilesObject.profiles];
  }
  constructor(environmentService, fileService, uriIdentityService, logService) {
    super();
    this.environmentService = environmentService;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._onDidChangeProfiles = this._register(new Emitter());
    this.onDidChangeProfiles = this._onDidChangeProfiles.event;
    this._onWillCreateProfile = this._register(new Emitter());
    this.onWillCreateProfile = this._onWillCreateProfile.event;
    this._onWillRemoveProfile = this._register(new Emitter());
    this.onWillRemoveProfile = this._onWillRemoveProfile.event;
    this._onDidResetWorkspaces = this._register(new Emitter());
    this.onDidResetWorkspaces = this._onDidResetWorkspaces.event;
    this.profileCreationPromises = /* @__PURE__ */ new Map();
    this.transientProfilesObject = {
      profiles: [],
      emptyWindows: /* @__PURE__ */ new Map()
    };
    this.profilesHome = joinPath(this.environmentService.userRoamingDataHome, "profiles");
    this.profilesCacheHome = joinPath(this.environmentService.cacheHome, "CachedProfilesData");
  }
  init() {
    this._profilesObject = void 0;
  }
  get profilesObject() {
    if (!this._profilesObject) {
      const defaultProfile = this.createDefaultProfile();
      const profiles = [defaultProfile];
      try {
        for (const storedProfile of this.getStoredProfiles()) {
          if (!storedProfile.name || !isString(storedProfile.name) || !storedProfile.location) {
            this.logService.warn("Skipping the invalid stored profile", storedProfile.location || storedProfile.name);
            continue;
          }
          profiles.push(toUserDataProfile(basename2(storedProfile.location), storedProfile.name, storedProfile.location, this.profilesCacheHome, { icon: storedProfile.icon, useDefaultFlags: storedProfile.useDefaultFlags }, defaultProfile));
        }
      } catch (error) {
        this.logService.error(error);
      }
      const emptyWindows = /* @__PURE__ */ new Map();
      if (profiles.length) {
        try {
          const profileAssociaitions = this.getStoredProfileAssociations();
          if (profileAssociaitions.workspaces) {
            for (const [workspacePath, profileId] of Object.entries(profileAssociaitions.workspaces)) {
              const workspace = URI.parse(workspacePath);
              const profile = profiles.find((p) => p.id === profileId);
              if (profile) {
                const workspaces = profile.workspaces ? profile.workspaces.slice(0) : [];
                workspaces.push(workspace);
                profile.workspaces = workspaces;
              }
            }
          }
          if (profileAssociaitions.emptyWindows) {
            for (const [windowId, profileId] of Object.entries(profileAssociaitions.emptyWindows)) {
              const profile = profiles.find((p) => p.id === profileId);
              if (profile) {
                emptyWindows.set(windowId, profile);
              }
            }
          }
        } catch (error) {
          this.logService.error(error);
        }
      }
      this._profilesObject = { profiles, emptyWindows };
    }
    return this._profilesObject;
  }
  createDefaultProfile() {
    const defaultProfile = toUserDataProfile("__default__profile__", localize(2705, null), this.environmentService.userRoamingDataHome, this.profilesCacheHome);
    return { ...defaultProfile, extensionsResource: this.getDefaultProfileExtensionsLocation() ?? defaultProfile.extensionsResource, isDefault: true };
  }
  async createTransientProfile(workspaceIdentifier) {
    const namePrefix = `Temp`;
    const nameRegEx = new RegExp(`${escapeRegExpCharacters(namePrefix)}\\s(\\d+)`);
    let nameIndex = 0;
    for (const profile of this.profiles) {
      const matches = nameRegEx.exec(profile.name);
      const index = matches ? parseInt(matches[1]) : 0;
      nameIndex = index > nameIndex ? index : nameIndex;
    }
    const name2 = `${namePrefix} ${nameIndex + 1}`;
    return this.createProfile(hash(generateUuid()).toString(16), name2, { transient: true }, workspaceIdentifier);
  }
  async createNamedProfile(name2, options2, workspaceIdentifier) {
    return this.createProfile(hash(generateUuid()).toString(16), name2, options2, workspaceIdentifier);
  }
  async createProfile(id2, name2, options2, workspaceIdentifier) {
    const profile = await this.doCreateProfile(id2, name2, options2, workspaceIdentifier);
    return profile;
  }
  async doCreateProfile(id2, name2, options2, workspaceIdentifier) {
    if (!isString(name2) || !name2) {
      throw new Error("Name of the profile is mandatory and must be of type `string`");
    }
    let profileCreationPromise = this.profileCreationPromises.get(name2);
    if (!profileCreationPromise) {
      profileCreationPromise = (async () => {
        try {
          const existing = this.profiles.find((p) => p.id === id2 || !p.isTransient && !options2?.transient && p.name === name2);
          if (existing) {
            throw new Error(`Profile with ${name2} name already exists`);
          }
          const workspace = workspaceIdentifier ? this.getWorkspace(workspaceIdentifier) : void 0;
          if (URI.isUri(workspace)) {
            options2 = { ...options2, workspaces: [workspace] };
          }
          const profile = toUserDataProfile(id2, name2, joinPath(this.profilesHome, id2), this.profilesCacheHome, options2, this.defaultProfile);
          await this.fileService.createFolder(profile.location);
          const joiners = [];
          this._onWillCreateProfile.fire({
            profile,
            join(promise) {
              joiners.push(promise);
            }
          });
          await Promises.settled(joiners);
          if (workspace && !URI.isUri(workspace)) {
            this.updateEmptyWindowAssociation(workspace, profile, !!profile.isTransient);
          }
          this.updateProfiles([profile], [], []);
          return profile;
        } finally {
          this.profileCreationPromises.delete(name2);
        }
      })();
      this.profileCreationPromises.set(name2, profileCreationPromise);
    }
    return profileCreationPromise;
  }
  async updateProfile(profile, options2) {
    const profilesToUpdate = [];
    for (const existing of this.profiles) {
      let profileToUpdate;
      if (profile.id === existing.id) {
        if (!existing.isDefault) {
          profileToUpdate = toUserDataProfile(existing.id, options2.name ?? existing.name, existing.location, this.profilesCacheHome, {
            icon: options2.icon === null ? void 0 : options2.icon ?? existing.icon,
            transient: options2.transient ?? existing.isTransient,
            useDefaultFlags: options2.useDefaultFlags ?? existing.useDefaultFlags,
            workspaces: options2.workspaces ?? existing.workspaces
          }, this.defaultProfile);
        } else if (options2.workspaces) {
          profileToUpdate = existing;
          profileToUpdate.workspaces = options2.workspaces;
        }
      } else if (options2.workspaces) {
        const workspaces = existing.workspaces?.filter((w1) => !options2.workspaces?.some((w2) => this.uriIdentityService.extUri.isEqual(w1, w2)));
        if (existing.workspaces?.length !== workspaces?.length) {
          profileToUpdate = existing;
          profileToUpdate.workspaces = workspaces;
        }
      }
      if (profileToUpdate) {
        profilesToUpdate.push(profileToUpdate);
      }
    }
    if (!profilesToUpdate.length) {
      if (profile.isDefault) {
        throw new Error("Cannot update default profile");
      }
      throw new Error(`Profile '${profile.name}' does not exist`);
    }
    this.updateProfiles([], [], profilesToUpdate);
    const updatedProfile = this.profiles.find((p) => p.id === profile.id);
    if (!updatedProfile) {
      throw new Error(`Profile '${profile.name}' was not updated`);
    }
    return updatedProfile;
  }
  async removeProfile(profileToRemove) {
    if (profileToRemove.isDefault) {
      throw new Error("Cannot remove default profile");
    }
    const profile = this.profiles.find((p) => p.id === profileToRemove.id);
    if (!profile) {
      throw new Error(`Profile '${profileToRemove.name}' does not exist`);
    }
    const joiners = [];
    this._onWillRemoveProfile.fire({
      profile,
      join(promise) {
        joiners.push(promise);
      }
    });
    try {
      await Promise.allSettled(joiners);
    } catch (error) {
      this.logService.error(error);
    }
    this.updateProfiles([], [profile], []);
    try {
      await this.fileService.del(profile.cacheHome, { recursive: true });
    } catch (error) {
      if (toFileOperationResult(error) !== 1) {
        this.logService.error(error);
      }
    }
  }
  async setProfileForWorkspace(workspaceIdentifier, profileToSet) {
    const profile = this.profiles.find((p) => p.id === profileToSet.id);
    if (!profile) {
      throw new Error(`Profile '${profileToSet.name}' does not exist`);
    }
    const workspace = this.getWorkspace(workspaceIdentifier);
    if (URI.isUri(workspace)) {
      const workspaces = profile.workspaces ? [...profile.workspaces] : [];
      if (!workspaces.some((w) => this.uriIdentityService.extUri.isEqual(w, workspace))) {
        workspaces.push(workspace);
        await this.updateProfile(profile, { workspaces });
      }
    } else {
      this.updateEmptyWindowAssociation(workspace, profile, false);
      this.updateStoredProfiles(this.profiles);
    }
  }
  unsetWorkspace(workspaceIdentifier, transient = false) {
    const workspace = this.getWorkspace(workspaceIdentifier);
    if (URI.isUri(workspace)) {
      const currentlyAssociatedProfile = this.getProfileForWorkspace(workspaceIdentifier);
      if (currentlyAssociatedProfile) {
        this.updateProfile(currentlyAssociatedProfile, { workspaces: currentlyAssociatedProfile.workspaces?.filter((w) => !this.uriIdentityService.extUri.isEqual(w, workspace)) });
      }
    } else {
      this.updateEmptyWindowAssociation(workspace, void 0, transient);
      this.updateStoredProfiles(this.profiles);
    }
  }
  async resetWorkspaces() {
    this.transientProfilesObject.emptyWindows.clear();
    this.profilesObject.emptyWindows.clear();
    for (const profile of this.profiles) {
      profile.workspaces = void 0;
    }
    this.updateProfiles([], [], this.profiles);
    this._onDidResetWorkspaces.fire();
  }
  async cleanUp() {
    if (await this.fileService.exists(this.profilesHome)) {
      const stat = await this.fileService.resolve(this.profilesHome);
      await Promise.all((stat.children || []).filter((child) => child.isDirectory && this.profiles.every((p) => !this.uriIdentityService.extUri.isEqual(p.location, child.resource))).map((child) => this.fileService.del(child.resource, { recursive: true })));
    }
  }
  async cleanUpTransientProfiles() {
    const unAssociatedTransientProfiles = this.transientProfilesObject.profiles.filter((p) => !this.isProfileAssociatedToWorkspace(p));
    await Promise.allSettled(unAssociatedTransientProfiles.map((p) => this.removeProfile(p)));
  }
  getProfileForWorkspace(workspaceIdentifier) {
    const workspace = this.getWorkspace(workspaceIdentifier);
    return URI.isUri(workspace) ? this.profiles.find((p) => p.workspaces?.some((w) => this.uriIdentityService.extUri.isEqual(w, workspace))) : this.profilesObject.emptyWindows.get(workspace) ?? this.transientProfilesObject.emptyWindows.get(workspace);
  }
  getWorkspace(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return workspaceIdentifier.uri;
    }
    if (isWorkspaceIdentifier(workspaceIdentifier)) {
      return workspaceIdentifier.configPath;
    }
    return workspaceIdentifier.id;
  }
  isProfileAssociatedToWorkspace(profile) {
    if (profile.workspaces?.length) {
      return true;
    }
    if ([...this.profilesObject.emptyWindows.values()].some((windowProfile) => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
      return true;
    }
    if ([...this.transientProfilesObject.emptyWindows.values()].some((windowProfile) => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
      return true;
    }
    return false;
  }
  updateProfiles(added, removed, updated) {
    const allProfiles = [...this.profiles, ...added];
    const transientProfiles = this.transientProfilesObject.profiles;
    this.transientProfilesObject.profiles = [];
    const profiles = [];
    for (let profile of allProfiles) {
      if (removed.some((p) => profile.id === p.id)) {
        for (const windowId of [...this.profilesObject.emptyWindows.keys()]) {
          if (profile.id === this.profilesObject.emptyWindows.get(windowId)?.id) {
            this.profilesObject.emptyWindows.delete(windowId);
          }
        }
        continue;
      }
      if (!profile.isDefault) {
        profile = updated.find((p) => profile.id === p.id) ?? profile;
        const transientProfile = transientProfiles.find((p) => profile.id === p.id);
        if (profile.isTransient) {
          this.transientProfilesObject.profiles.push(profile);
        } else {
          if (transientProfile) {
            for (const [windowId, p] of this.transientProfilesObject.emptyWindows.entries()) {
              if (profile.id === p.id) {
                this.transientProfilesObject.emptyWindows.delete(windowId);
                this.profilesObject.emptyWindows.set(windowId, profile);
                break;
              }
            }
          }
        }
      }
      if (profile.workspaces?.length === 0) {
        profile.workspaces = void 0;
      }
      profiles.push(profile);
    }
    this.updateStoredProfiles(profiles);
    this.triggerProfilesChanges(added, removed, updated);
  }
  triggerProfilesChanges(added, removed, updated) {
    this._onDidChangeProfiles.fire({ added, removed, updated, all: this.profiles });
  }
  updateEmptyWindowAssociation(windowId, newProfile, transient) {
    transient = newProfile?.isTransient ? true : transient;
    if (transient) {
      if (newProfile) {
        this.transientProfilesObject.emptyWindows.set(windowId, newProfile);
      } else {
        this.transientProfilesObject.emptyWindows.delete(windowId);
      }
    } else {
      this.transientProfilesObject.emptyWindows.delete(windowId);
      if (newProfile) {
        this.profilesObject.emptyWindows.set(windowId, newProfile);
      } else {
        this.profilesObject.emptyWindows.delete(windowId);
      }
    }
  }
  updateStoredProfiles(profiles) {
    const storedProfiles = [];
    const workspaces = {};
    const emptyWindows = {};
    for (const profile of profiles) {
      if (profile.isTransient) {
        continue;
      }
      if (!profile.isDefault) {
        storedProfiles.push({ location: profile.location, name: profile.name, icon: profile.icon, useDefaultFlags: profile.useDefaultFlags });
      }
      if (profile.workspaces) {
        for (const workspace of profile.workspaces) {
          workspaces[workspace.toString()] = profile.id;
        }
      }
    }
    for (const [windowId, profile] of this.profilesObject.emptyWindows.entries()) {
      emptyWindows[windowId.toString()] = profile.id;
    }
    this.saveStoredProfileAssociations({ workspaces, emptyWindows });
    this.saveStoredProfiles(storedProfiles);
    this._profilesObject = void 0;
  }
  getStoredProfiles() {
    return [];
  }
  saveStoredProfiles(storedProfiles) {
    throw new Error("not implemented");
  }
  getStoredProfileAssociations() {
    return {};
  }
  saveStoredProfileAssociations(storedProfileAssociations) {
    throw new Error("not implemented");
  }
  getDefaultProfileExtensionsLocation() {
    return void 0;
  }
};
UserDataProfilesService = __decorate([
  __param(0, IEnvironmentService),
  __param(1, IFileService),
  __param(2, IUriIdentityService),
  __param(3, ILogService)
], UserDataProfilesService);

// out-build/vs/platform/storage/common/storage.js
var IS_NEW_KEY = "__$__isNewStorageMarker";
var TARGET_KEY = "__$__targetStorageMarker";
var IStorageService = createDecorator("storageService");
var WillSaveStateReason;
(function(WillSaveStateReason2) {
  WillSaveStateReason2[WillSaveStateReason2["NONE"] = 0] = "NONE";
  WillSaveStateReason2[WillSaveStateReason2["SHUTDOWN"] = 1] = "SHUTDOWN";
})(WillSaveStateReason || (WillSaveStateReason = {}));
var StorageScope;
(function(StorageScope2) {
  StorageScope2[StorageScope2["APPLICATION"] = -1] = "APPLICATION";
  StorageScope2[StorageScope2["PROFILE"] = 0] = "PROFILE";
  StorageScope2[StorageScope2["WORKSPACE"] = 1] = "WORKSPACE";
})(StorageScope || (StorageScope = {}));
var StorageTarget;
(function(StorageTarget2) {
  StorageTarget2[StorageTarget2["USER"] = 0] = "USER";
  StorageTarget2[StorageTarget2["MACHINE"] = 1] = "MACHINE";
})(StorageTarget || (StorageTarget = {}));
function loadKeyTargets(storage) {
  const keysRaw = storage.get(TARGET_KEY);
  if (keysRaw) {
    try {
      return JSON.parse(keysRaw);
    } catch (error) {
    }
  }
  return /* @__PURE__ */ Object.create(null);
}
var AbstractStorageService = class _AbstractStorageService extends Disposable {
  static {
    this.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
  }
  // every minute
  constructor(options2 = { flushInterval: _AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {
    super();
    this._onDidChangeValue = this._register(new PauseableEmitter());
    this._onDidChangeTarget = this._register(new PauseableEmitter());
    this.onDidChangeTarget = this._onDidChangeTarget.event;
    this._onWillSaveState = this._register(new Emitter());
    this.onWillSaveState = this._onWillSaveState.event;
    this.runFlushWhenIdle = this._register(new MutableDisposable());
    this._workspaceKeyTargets = void 0;
    this._profileKeyTargets = void 0;
    this._applicationKeyTargets = void 0;
    this.flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), options2.flushInterval));
  }
  onDidChangeValue(scope, key, disposable) {
    return Event.filter(this._onDidChangeValue.event, (e) => e.scope === scope && (key === void 0 || e.key === key), disposable);
  }
  doFlushWhenIdle() {
    this.runFlushWhenIdle.value = runWhenGlobalIdle(() => {
      if (this.shouldFlushWhenIdle()) {
        this.flush();
      }
      this.flushWhenIdleScheduler.schedule();
    });
  }
  shouldFlushWhenIdle() {
    return true;
  }
  stopFlushWhenIdle() {
    dispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);
  }
  initialize() {
    if (!this.initializationPromise) {
      this.initializationPromise = (async () => {
        mark("code/willInitStorage");
        try {
          await this.doInitialize();
        } finally {
          mark("code/didInitStorage");
        }
        this.flushWhenIdleScheduler.schedule();
      })();
    }
    return this.initializationPromise;
  }
  emitDidChangeValue(scope, event) {
    const { key, external } = event;
    if (key === TARGET_KEY) {
      switch (scope) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope });
    } else {
      this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key], external });
    }
  }
  emitWillSaveState(reason) {
    this._onWillSaveState.fire({ reason });
  }
  get(key, scope, fallbackValue) {
    return this.getStorage(scope)?.get(key, fallbackValue);
  }
  getBoolean(key, scope, fallbackValue) {
    return this.getStorage(scope)?.getBoolean(key, fallbackValue);
  }
  getNumber(key, scope, fallbackValue) {
    return this.getStorage(scope)?.getNumber(key, fallbackValue);
  }
  getObject(key, scope, fallbackValue) {
    return this.getStorage(scope)?.getObject(key, fallbackValue);
  }
  storeAll(entries, external) {
    this.withPausedEmitters(() => {
      for (const entry of entries) {
        this.store(entry.key, entry.value, entry.scope, entry.target, external);
      }
    });
  }
  store(key, value, scope, target, external = false) {
    if (isUndefinedOrNull(value)) {
      this.remove(key, scope, external);
      return;
    }
    this.withPausedEmitters(() => {
      this.updateKeyTarget(key, scope, target);
      this.getStorage(scope)?.set(key, value, external);
    });
  }
  remove(key, scope, external = false) {
    this.withPausedEmitters(() => {
      this.updateKeyTarget(key, scope, void 0);
      this.getStorage(scope)?.delete(key, external);
    });
  }
  withPausedEmitters(fn) {
    this._onDidChangeValue.pause();
    this._onDidChangeTarget.pause();
    try {
      fn();
    } finally {
      this._onDidChangeValue.resume();
      this._onDidChangeTarget.resume();
    }
  }
  keys(scope, target) {
    const keys = [];
    const keyTargets = this.getKeyTargets(scope);
    for (const key of Object.keys(keyTargets)) {
      const keyTarget = keyTargets[key];
      if (keyTarget === target) {
        keys.push(key);
      }
    }
    return keys;
  }
  updateKeyTarget(key, scope, target, external = false) {
    const keyTargets = this.getKeyTargets(scope);
    if (typeof target === "number") {
      if (keyTargets[key] !== target) {
        keyTargets[key] = target;
        this.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);
      }
    } else {
      if (typeof keyTargets[key] === "number") {
        delete keyTargets[key];
        this.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);
      }
    }
  }
  get workspaceKeyTargets() {
    if (!this._workspaceKeyTargets) {
      this._workspaceKeyTargets = this.loadKeyTargets(
        1
        /* StorageScope.WORKSPACE */
      );
    }
    return this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    if (!this._profileKeyTargets) {
      this._profileKeyTargets = this.loadKeyTargets(
        0
        /* StorageScope.PROFILE */
      );
    }
    return this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    if (!this._applicationKeyTargets) {
      this._applicationKeyTargets = this.loadKeyTargets(
        -1
        /* StorageScope.APPLICATION */
      );
    }
    return this._applicationKeyTargets;
  }
  getKeyTargets(scope) {
    switch (scope) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(scope) {
    const storage = this.getStorage(scope);
    return storage ? loadKeyTargets(storage) : /* @__PURE__ */ Object.create(null);
  }
  isNew(scope) {
    return this.getBoolean(IS_NEW_KEY, scope) === true;
  }
  async flush(reason = WillSaveStateReason.NONE) {
    this._onWillSaveState.fire({ reason });
    const applicationStorage = this.getStorage(
      -1
      /* StorageScope.APPLICATION */
    );
    const profileStorage = this.getStorage(
      0
      /* StorageScope.PROFILE */
    );
    const workspaceStorage = this.getStorage(
      1
      /* StorageScope.WORKSPACE */
    );
    switch (reason) {
      // Unspecific reason: just wait when data is flushed
      case WillSaveStateReason.NONE:
        await Promises.settled([
          applicationStorage?.whenFlushed() ?? Promise.resolve(),
          profileStorage?.whenFlushed() ?? Promise.resolve(),
          workspaceStorage?.whenFlushed() ?? Promise.resolve()
        ]);
        break;
      // Shutdown: we want to flush as soon as possible
      // and not hit any delays that might be there
      case WillSaveStateReason.SHUTDOWN:
        await Promises.settled([
          applicationStorage?.flush(0) ?? Promise.resolve(),
          profileStorage?.flush(0) ?? Promise.resolve(),
          workspaceStorage?.flush(0) ?? Promise.resolve()
        ]);
        break;
    }
  }
  async log() {
    const applicationItems = this.getStorage(
      -1
      /* StorageScope.APPLICATION */
    )?.items ?? /* @__PURE__ */ new Map();
    const profileItems = this.getStorage(
      0
      /* StorageScope.PROFILE */
    )?.items ?? /* @__PURE__ */ new Map();
    const workspaceItems = this.getStorage(
      1
      /* StorageScope.WORKSPACE */
    )?.items ?? /* @__PURE__ */ new Map();
    return logStorage(applicationItems, profileItems, workspaceItems, this.getLogDetails(
      -1
      /* StorageScope.APPLICATION */
    ) ?? "", this.getLogDetails(
      0
      /* StorageScope.PROFILE */
    ) ?? "", this.getLogDetails(
      1
      /* StorageScope.WORKSPACE */
    ) ?? "");
  }
  async optimize(scope) {
    await this.flush();
    return this.getStorage(scope)?.optimize();
  }
  async switch(to, preserveData) {
    this.emitWillSaveState(WillSaveStateReason.NONE);
    if (isUserDataProfile(to)) {
      return this.switchToProfile(to, preserveData);
    }
    return this.switchToWorkspace(to, preserveData);
  }
  canSwitchProfile(from, to) {
    if (from.id === to.id) {
      return false;
    }
    if (isProfileUsingDefaultStorage(to) && isProfileUsingDefaultStorage(from)) {
      return false;
    }
    return true;
  }
  switchData(oldStorage, newStorage, scope) {
    this.withPausedEmitters(() => {
      const handledkeys = /* @__PURE__ */ new Set();
      for (const [key, oldValue] of oldStorage) {
        handledkeys.add(key);
        const newValue = newStorage.get(key);
        if (newValue !== oldValue) {
          this.emitDidChangeValue(scope, { key, external: true });
        }
      }
      for (const [key] of newStorage.items) {
        if (!handledkeys.has(key)) {
          this.emitDidChangeValue(scope, { key, external: true });
        }
      }
    });
  }
};
function isProfileUsingDefaultStorage(profile) {
  return profile.isDefault || !!profile.useDefaultFlags?.globalState;
}
async function logStorage(application, profile, workspace, applicationPath, profilePath, workspacePath) {
  const safeParse = (value) => {
    try {
      return JSON.parse(value);
    } catch (error) {
      return value;
    }
  };
  const applicationItems = /* @__PURE__ */ new Map();
  const applicationItemsParsed = /* @__PURE__ */ new Map();
  application.forEach((value, key) => {
    applicationItems.set(key, value);
    applicationItemsParsed.set(key, safeParse(value));
  });
  const profileItems = /* @__PURE__ */ new Map();
  const profileItemsParsed = /* @__PURE__ */ new Map();
  profile.forEach((value, key) => {
    profileItems.set(key, value);
    profileItemsParsed.set(key, safeParse(value));
  });
  const workspaceItems = /* @__PURE__ */ new Map();
  const workspaceItemsParsed = /* @__PURE__ */ new Map();
  workspace.forEach((value, key) => {
    workspaceItems.set(key, value);
    workspaceItemsParsed.set(key, safeParse(value));
  });
  if (applicationPath !== profilePath) {
    console.group(`Storage: Application (path: ${applicationPath})`);
  } else {
    console.group(`Storage: Application & Profile (path: ${applicationPath}, default profile)`);
  }
  const applicationValues = [];
  applicationItems.forEach((value, key) => {
    applicationValues.push({ key, value });
  });
  console.table(applicationValues);
  console.groupEnd();
  console.log(applicationItemsParsed);
  if (applicationPath !== profilePath) {
    console.group(`Storage: Profile (path: ${profilePath}, profile specific)`);
    const profileValues = [];
    profileItems.forEach((value, key) => {
      profileValues.push({ key, value });
    });
    console.table(profileValues);
    console.groupEnd();
    console.log(profileItemsParsed);
  }
  console.group(`Storage: Workspace (path: ${workspacePath})`);
  const workspaceValues = [];
  workspaceItems.forEach((value, key) => {
    workspaceValues.push({ key, value });
  });
  console.table(workspaceValues);
  console.groupEnd();
  console.log(workspaceItemsParsed);
}

// out-build/vs/workbench/common/memento.js
var Memento = class _Memento {
  static {
    this.applicationMementos = /* @__PURE__ */ new Map();
  }
  static {
    this.profileMementos = /* @__PURE__ */ new Map();
  }
  static {
    this.workspaceMementos = /* @__PURE__ */ new Map();
  }
  static {
    this.COMMON_PREFIX = "memento/";
  }
  constructor(id2, storageService) {
    this.storageService = storageService;
    this.id = _Memento.COMMON_PREFIX + id2;
  }
  getMemento(scope, target) {
    switch (scope) {
      case 1: {
        let workspaceMemento = _Memento.workspaceMementos.get(this.id);
        if (!workspaceMemento) {
          workspaceMemento = new ScopedMemento(this.id, scope, target, this.storageService);
          _Memento.workspaceMementos.set(this.id, workspaceMemento);
        }
        return workspaceMemento.getMemento();
      }
      case 0: {
        let profileMemento = _Memento.profileMementos.get(this.id);
        if (!profileMemento) {
          profileMemento = new ScopedMemento(this.id, scope, target, this.storageService);
          _Memento.profileMementos.set(this.id, profileMemento);
        }
        return profileMemento.getMemento();
      }
      case -1: {
        let applicationMemento = _Memento.applicationMementos.get(this.id);
        if (!applicationMemento) {
          applicationMemento = new ScopedMemento(this.id, scope, target, this.storageService);
          _Memento.applicationMementos.set(this.id, applicationMemento);
        }
        return applicationMemento.getMemento();
      }
    }
  }
  onDidChangeValue(scope, disposables) {
    return this.storageService.onDidChangeValue(scope, this.id, disposables);
  }
  saveMemento() {
    _Memento.workspaceMementos.get(this.id)?.save();
    _Memento.profileMementos.get(this.id)?.save();
    _Memento.applicationMementos.get(this.id)?.save();
  }
  reloadMemento(scope) {
    let memento;
    switch (scope) {
      case -1:
        memento = _Memento.applicationMementos.get(this.id);
        break;
      case 0:
        memento = _Memento.profileMementos.get(this.id);
        break;
      case 1:
        memento = _Memento.workspaceMementos.get(this.id);
        break;
    }
    memento?.reload();
  }
  static clear(scope) {
    switch (scope) {
      case 1:
        _Memento.workspaceMementos.clear();
        break;
      case 0:
        _Memento.profileMementos.clear();
        break;
      case -1:
        _Memento.applicationMementos.clear();
        break;
    }
  }
};
var ScopedMemento = class {
  constructor(id2, scope, target, storageService) {
    this.id = id2;
    this.scope = scope;
    this.target = target;
    this.storageService = storageService;
    this.mementoObj = this.doLoad();
  }
  doLoad() {
    try {
      return this.storageService.getObject(this.id, this.scope, {});
    } catch (error) {
      onUnexpectedError(`[memento]: failed to parse contents: ${error} (id: ${this.id}, scope: ${this.scope}, contents: ${this.storageService.get(this.id, this.scope)})`);
    }
    return {};
  }
  getMemento() {
    return this.mementoObj;
  }
  reload() {
    for (const name2 of Object.getOwnPropertyNames(this.mementoObj)) {
      delete this.mementoObj[name2];
    }
    Object.assign(this.mementoObj, this.doLoad());
  }
  save() {
    if (!isEmptyObject(this.mementoObj)) {
      this.storageService.store(this.id, this.mementoObj, this.scope, this.target);
    } else {
      this.storageService.remove(this.id, this.scope);
    }
  }
};

// out-build/vs/workbench/contrib/chat/common/chatTodoListService.js
var IChatTodoListService = createDecorator("chatTodoListService");
var ChatTodoListStorage = class ChatTodoListStorage2 {
  constructor(storageService) {
    this.memento = new Memento("chat-todo-list", storageService);
  }
  getSessionData(sessionResource) {
    const storage = this.memento.getMemento(
      1,
      1
      /* StorageTarget.MACHINE */
    );
    return storage[this.toKey(sessionResource)] || [];
  }
  setSessionData(sessionResource, todoList) {
    const storage = this.memento.getMemento(
      1,
      1
      /* StorageTarget.MACHINE */
    );
    storage[this.toKey(sessionResource)] = todoList;
    this.memento.saveMemento();
  }
  getTodoList(sessionResource) {
    return this.getSessionData(sessionResource);
  }
  setTodoList(sessionResource, todoList) {
    this.setSessionData(sessionResource, todoList);
  }
  toKey(sessionResource) {
    return chatSessionResourceToId(sessionResource);
  }
};
ChatTodoListStorage = __decorate([
  __param(0, IStorageService)
], ChatTodoListStorage);
var ChatTodoListService = class ChatTodoListService2 extends Disposable {
  constructor(storageService) {
    super();
    this._onDidUpdateTodos = this._register(new Emitter());
    this.onDidUpdateTodos = this._onDidUpdateTodos.event;
    this.todoListStorage = new ChatTodoListStorage(storageService);
  }
  getTodos(sessionResource) {
    return this.todoListStorage.getTodoList(sessionResource);
  }
  setTodos(sessionResource, todos) {
    this.todoListStorage.setTodoList(sessionResource, todos);
    this._onDidUpdateTodos.fire(sessionResource);
  }
};
ChatTodoListService = __decorate([
  __param(0, IStorageService)
], ChatTodoListService);

// out-build/vs/workbench/contrib/chat/common/tools/manageTodoListTool.js
var TodoListToolWriteOnlySettingId = "chat.todoListTool.writeOnly";
var TodoListToolDescriptionFieldSettingId = "chat.todoListTool.descriptionField";
var ManageTodoListToolToolId = "manage_todo_list";
function createManageTodoListToolData(writeOnly, includeDescription = true) {
  const baseProperties = {
    todoList: {
      type: "array",
      description: writeOnly ? "Complete array of all todo items. Must include ALL items - both existing and new." : "Complete array of all todo items (required for write operation, ignored for read). Must include ALL items - both existing and new.",
      items: {
        type: "object",
        properties: {
          id: {
            type: "number",
            description: "Unique identifier for the todo. Use sequential numbers starting from 1."
          },
          title: {
            type: "string",
            description: "Concise action-oriented todo label (3-7 words). Displayed in UI."
          },
          ...includeDescription && {
            description: {
              type: "string",
              description: "Detailed context, requirements, or implementation notes. Include file paths, specific methods, or acceptance criteria."
            }
          },
          status: {
            type: "string",
            enum: ["not-started", "in-progress", "completed"],
            description: "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
          }
        },
        required: includeDescription ? ["id", "title", "description", "status"] : ["id", "title", "status"]
      }
    }
  };
  const requiredFields = writeOnly ? ["todoList"] : [];
  if (!writeOnly) {
    baseProperties.operation = {
      type: "string",
      enum: ["write", "read"],
      description: "write: Replace entire todo list with new content. read: Retrieve current todo list. ALWAYS provide complete list when writing - partial updates not supported."
    };
    requiredFields.unshift("operation");
  }
  return {
    id: ManageTodoListToolToolId,
    toolReferenceName: "todo",
    legacyToolReferenceFullNames: ["todos"],
    canBeReferencedInPrompt: true,
    icon: ThemeIcon.fromId(Codicon.checklist.id),
    displayName: localize(6591, null),
    userDescription: localize(6592, null),
    modelDescription: "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
    source: ToolDataSource.Internal,
    inputSchema: {
      type: "object",
      properties: baseProperties,
      required: requiredFields
    }
  };
}
var ManageTodoListToolData = createManageTodoListToolData(false);
var ManageTodoListTool = class ManageTodoListTool2 extends Disposable {
  constructor(writeOnly, includeDescription, chatTodoListService, logService, telemetryService) {
    super();
    this.writeOnly = writeOnly;
    this.includeDescription = includeDescription;
    this.chatTodoListService = chatTodoListService;
    this.logService = logService;
    this.telemetryService = telemetryService;
  }
  async invoke(invocation, _countTokens, _progress, _token) {
    const args = invocation.parameters;
    const DEFAULT_TODO_SESSION_ID = "default";
    const chatSessionId = invocation.context?.sessionId ?? args.chatSessionId ?? DEFAULT_TODO_SESSION_ID;
    this.logService.debug(`ManageTodoListTool: Invoking with options ${JSON.stringify(args)}`);
    try {
      const operation = this.writeOnly ? "write" : args.operation;
      if (!operation) {
        return {
          content: [{
            kind: "text",
            value: "Error: operation parameter is required"
          }]
        };
      }
      if (operation === "read") {
        return this.handleReadOperation(LocalChatSessionUri.forSession(chatSessionId));
      } else if (operation === "write") {
        return this.handleWriteOperation(args, LocalChatSessionUri.forSession(chatSessionId));
      } else {
        return {
          content: [{
            kind: "text",
            value: "Error: Unknown operation"
          }]
        };
      }
    } catch (error) {
      const errorMessage = `Error: ${error instanceof Error ? error.message : "Unknown error"}`;
      return {
        content: [{
          kind: "text",
          value: errorMessage
        }]
      };
    }
  }
  async prepareToolInvocation(context, _token) {
    const args = context.parameters;
    const DEFAULT_TODO_SESSION_ID = "default";
    const chatSessionId = context.chatSessionId ?? args.chatSessionId ?? DEFAULT_TODO_SESSION_ID;
    const currentTodoItems = this.chatTodoListService.getTodos(LocalChatSessionUri.forSession(chatSessionId));
    let message;
    const operation = this.writeOnly ? "write" : args.operation;
    switch (operation) {
      case "write": {
        if (args.todoList) {
          message = this.generatePastTenseMessage(currentTodoItems, args.todoList);
        }
        break;
      }
      case "read": {
        message = localize(6593, null);
        break;
      }
      default:
        break;
    }
    const items = args.todoList ?? currentTodoItems;
    const todoList = items.map((todo) => ({
      id: todo.id.toString(),
      title: todo.title,
      description: todo.description || "",
      status: todo.status
    }));
    return {
      pastTenseMessage: new MarkdownString(message ?? localize(6594, null)),
      toolSpecificData: {
        kind: "todoList",
        sessionId: chatSessionId,
        todoList
      }
    };
  }
  generatePastTenseMessage(currentTodos, newTodos) {
    if (currentTodos.length === 0) {
      return newTodos.length === 1 ? localize(6595, null) : localize(6596, null, newTodos.length);
    }
    const currentTodoMap = new Map(currentTodos.map((todo) => [todo.id, todo]));
    const startedTodos = newTodos.filter((newTodo) => {
      const currentTodo = currentTodoMap.get(newTodo.id);
      return currentTodo && currentTodo.status !== "in-progress" && newTodo.status === "in-progress";
    });
    if (startedTodos.length > 0) {
      const startedTodo = startedTodos[0];
      const totalTodos = newTodos.length;
      const currentPosition = newTodos.findIndex((todo) => todo.id === startedTodo.id) + 1;
      return localize(6597, null, startedTodo.title, currentPosition, totalTodos);
    }
    const completedTodos = newTodos.filter((newTodo) => {
      const currentTodo = currentTodoMap.get(newTodo.id);
      return currentTodo && currentTodo.status !== "completed" && newTodo.status === "completed";
    });
    if (completedTodos.length > 0) {
      const completedTodo = completedTodos[0];
      const totalTodos = newTodos.length;
      const currentPosition = newTodos.findIndex((todo) => todo.id === completedTodo.id) + 1;
      return localize(6598, null, completedTodo.title, currentPosition, totalTodos);
    }
    const addedTodos = newTodos.filter((newTodo) => !currentTodoMap.has(newTodo.id));
    if (addedTodos.length > 0) {
      return addedTodos.length === 1 ? localize(6599, null) : localize(6600, null, addedTodos.length);
    }
    return localize(6601, null);
  }
  handleRead(todoItems, sessionResource) {
    if (todoItems.length === 0) {
      return "No todo list found.";
    }
    const markdownTaskList = this.formatTodoListAsMarkdownTaskList(todoItems);
    return `# Todo List

${markdownTaskList}`;
  }
  handleReadOperation(chatSessionResource) {
    const todoItems = this.chatTodoListService.getTodos(chatSessionResource);
    const readResult = this.handleRead(todoItems, chatSessionResource);
    const statusCounts = this.calculateStatusCounts(todoItems);
    this.telemetryService.publicLog2("todoListToolInvoked", {
      operation: "read",
      notStartedCount: statusCounts.notStartedCount,
      inProgressCount: statusCounts.inProgressCount,
      completedCount: statusCounts.completedCount,
      chatSessionId: chatSessionResourceToId(chatSessionResource)
    });
    return {
      content: [{
        kind: "text",
        value: readResult
      }]
    };
  }
  handleWriteOperation(args, chatSessionResource) {
    if (!args.todoList) {
      return {
        content: [{
          kind: "text",
          value: "Error: todoList is required for write operation"
        }]
      };
    }
    const todoList = args.todoList.map((parsedTodo) => ({
      id: parsedTodo.id,
      title: parsedTodo.title,
      description: parsedTodo.description || "",
      status: parsedTodo.status
    }));
    const existingTodos = this.chatTodoListService.getTodos(chatSessionResource);
    const changes = this.calculateTodoChanges(existingTodos, todoList);
    this.chatTodoListService.setTodos(chatSessionResource, todoList);
    const statusCounts = this.calculateStatusCounts(todoList);
    const warnings = [];
    if (todoList.length < 3) {
      warnings.push("Warning: Small todo list (<3 items). This task might not need a todo list.");
    } else if (todoList.length > 10) {
      warnings.push("Warning: Large todo list (>10 items). Consider keeping the list focused and actionable.");
    }
    if (changes > 3) {
      warnings.push("Warning: Did you mean to update so many todos at the same time? Consider working on them one by one.");
    }
    this.telemetryService.publicLog2("todoListToolInvoked", {
      operation: "write",
      notStartedCount: statusCounts.notStartedCount,
      inProgressCount: statusCounts.inProgressCount,
      completedCount: statusCounts.completedCount,
      chatSessionId: chatSessionResourceToId(chatSessionResource)
    });
    return {
      content: [{
        kind: "text",
        value: `Successfully wrote todo list${warnings.length ? "\n\n" + warnings.join("\n") : ""}`
      }],
      toolMetadata: {
        warnings
      }
    };
  }
  calculateStatusCounts(todos) {
    const notStartedCount = todos.filter((todo) => todo.status === "not-started").length;
    const inProgressCount = todos.filter((todo) => todo.status === "in-progress").length;
    const completedCount = todos.filter((todo) => todo.status === "completed").length;
    return { notStartedCount, inProgressCount, completedCount };
  }
  formatTodoListAsMarkdownTaskList(todoList) {
    if (todoList.length === 0) {
      return "";
    }
    return todoList.map((todo) => {
      let checkbox;
      switch (todo.status) {
        case "completed":
          checkbox = "[x]";
          break;
        case "in-progress":
          checkbox = "[-]";
          break;
        case "not-started":
        default:
          checkbox = "[ ]";
          break;
      }
      const lines = [`- ${checkbox} ${todo.title}`];
      if (this.includeDescription && todo.description && todo.description.trim()) {
        lines.push(`  - ${todo.description.trim()}`);
      }
      return lines.join("\n");
    }).join("\n");
  }
  calculateTodoChanges(oldList, newList) {
    let modified = 0;
    const minLen = Math.min(oldList.length, newList.length);
    for (let i = 0; i < minLen; i++) {
      const o = oldList[i];
      const n = newList[i];
      if (o.title !== n.title || (o.description ?? "") !== (n.description ?? "") || o.status !== n.status) {
        modified++;
      }
    }
    const added = Math.max(0, newList.length - oldList.length);
    const removed = Math.max(0, oldList.length - newList.length);
    const totalChanges = added + removed + modified;
    return totalChanges;
  }
};
ManageTodoListTool = __decorate([
  __param(2, IChatTodoListService),
  __param(3, ILogService),
  __param(4, ITelemetryService)
], ManageTodoListTool);

// out-build/vs/platform/request/common/request.js
var IRequestService = createDecorator("requestService");
function isSuccess(context) {
  return context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300 || context.res.statusCode === 1223;
}
function hasNoContent(context) {
  return context.res.statusCode === 204;
}
async function asText(context) {
  if (hasNoContent(context)) {
    return null;
  }
  const buffer = await streamToBuffer(context.stream);
  return buffer.toString();
}
async function asJson(context) {
  if (!isSuccess(context)) {
    throw new Error("Server returned " + context.res.statusCode);
  }
  if (hasNoContent(context)) {
    return null;
  }
  const buffer = await streamToBuffer(context.stream);
  const str = buffer.toString();
  try {
    return JSON.parse(str);
  } catch (err) {
    err.message += ":\n" + str;
    throw err;
  }
}
var systemCertificatesNodeDefault = false;
var proxyConfiguration = [];
var previousUseHostProxy = void 0;
var previousUseHostProxyDefault = void 0;
function registerProxyConfigurations(useHostProxy = true, useHostProxyDefault = true) {
  if (previousUseHostProxy === useHostProxy && previousUseHostProxyDefault === useHostProxyDefault) {
    return;
  }
  previousUseHostProxy = useHostProxy;
  previousUseHostProxyDefault = useHostProxyDefault;
  const configurationRegistry3 = Registry.as(Extensions2.Configuration);
  const oldProxyConfiguration = proxyConfiguration;
  proxyConfiguration = [
    {
      id: "http",
      order: 15,
      title: localize(2282, null),
      type: "object",
      scope: 2,
      properties: {
        "http.useLocalProxyConfiguration": {
          type: "boolean",
          default: useHostProxyDefault,
          markdownDescription: localize(2283, null),
          restricted: true
        }
      }
    },
    {
      id: "http",
      order: 15,
      title: localize(2284, null),
      type: "object",
      scope: 1,
      properties: {
        "http.electronFetch": {
          type: "boolean",
          default: false,
          description: localize(2285, null),
          restricted: true
        }
      }
    },
    {
      id: "http",
      order: 15,
      title: localize(2286, null),
      type: "object",
      scope: useHostProxy ? 1 : 2,
      properties: {
        "http.proxy": {
          type: "string",
          pattern: "^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
          markdownDescription: localize(2287, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.proxyStrictSSL": {
          type: "boolean",
          default: true,
          markdownDescription: localize(2288, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.proxyKerberosServicePrincipal": {
          type: "string",
          markdownDescription: localize(2289, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.noProxy": {
          type: "array",
          items: { type: "string" },
          markdownDescription: localize(2290, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.proxyAuthorization": {
          type: ["null", "string"],
          default: null,
          markdownDescription: localize(2291, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.proxySupport": {
          type: "string",
          enum: ["off", "on", "fallback", "override"],
          enumDescriptions: [
            localize(2292, null),
            localize(2293, null),
            localize(2294, null),
            localize(2295, null)
          ],
          default: "override",
          markdownDescription: localize(2296, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.systemCertificates": {
          type: "boolean",
          default: true,
          markdownDescription: localize(2297, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.systemCertificatesNode": {
          type: "boolean",
          tags: ["experimental"],
          default: systemCertificatesNodeDefault,
          markdownDescription: localize(2298, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true,
          experiment: {
            mode: "auto"
          }
        },
        "http.experimental.systemCertificatesV2": {
          type: "boolean",
          tags: ["experimental"],
          default: false,
          markdownDescription: localize(2299, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true
        },
        "http.fetchAdditionalSupport": {
          type: "boolean",
          default: true,
          markdownDescription: localize(2300, null, "`#http.useLocalProxyConfiguration#`", "`#http.proxySupport#`", "`#http.systemCertificates#`"),
          restricted: true
        },
        "http.experimental.networkInterfaceCheckInterval": {
          type: "number",
          default: 300,
          minimum: -1,
          tags: ["experimental"],
          markdownDescription: localize(2301, null, "`#http.useLocalProxyConfiguration#`"),
          restricted: true,
          experiment: {
            mode: "auto"
          }
        }
      }
    }
  ];
  configurationRegistry3.updateConfigurations({ add: proxyConfiguration, remove: oldProxyConfiguration });
}
registerProxyConfigurations();

// out-build/vs/platform/contextkey/common/contextkeys.js
var IsMacContext = new RawContextKey("isMac", isMacintosh, localize(1854, null));
var IsLinuxContext = new RawContextKey("isLinux", isLinux, localize(1855, null));
var IsWindowsContext = new RawContextKey("isWindows", isWindows, localize(1856, null));
var IsWebContext = new RawContextKey("isWeb", isWeb, localize(1857, null));
var IsMacNativeContext = new RawContextKey("isMacNative", isMacintosh && !isWeb, localize(1858, null));
var IsIOSContext = new RawContextKey("isIOS", isIOS, localize(1859, null));
var IsMobileContext = new RawContextKey("isMobile", isMobile, localize(1860, null));
var IsDevelopmentContext = new RawContextKey("isDevelopment", false, true);
var ProductQualityContext = new RawContextKey("productQualityType", "", localize(1861, null));
var InputFocusedContextKey = "inputFocus";
var InputFocusedContext = new RawContextKey(InputFocusedContextKey, false, localize(1862, null));

// out-build/vs/editor/common/languages/language.js
var ILanguageService = createDecorator("languageService");

// out-build/vs/editor/common/services/model.js
var IModelService = createDecorator("modelService");

// out-build/vs/workbench/common/editor/editorInput.js
var EditorInput = class extends AbstractEditorInput {
  constructor() {
    super(...arguments);
    this._onDidChangeDirty = this._register(new Emitter());
    this._onDidChangeLabel = this._register(new Emitter());
    this._onDidChangeCapabilities = this._register(new Emitter());
    this._onWillDispose = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this.onDidChangeLabel = this._onDidChangeLabel.event;
    this.onDidChangeCapabilities = this._onDidChangeCapabilities.event;
    this.onWillDispose = this._onWillDispose.event;
  }
  /**
   * Identifies the type of editor this input represents
   * This ID is registered with the {@link EditorResolverService} to allow
   * for resolving an untyped input to a typed one
   */
  get editorId() {
    return void 0;
  }
  /**
   * The capabilities of the input.
   */
  get capabilities() {
    return 2;
  }
  /**
   * Figure out if the input has the provided capability.
   */
  hasCapability(capability) {
    if (capability === 0) {
      return this.capabilities === 0;
    }
    return (this.capabilities & capability) !== 0;
  }
  isReadonly() {
    return this.hasCapability(
      2
      /* EditorInputCapabilities.Readonly */
    );
  }
  /**
   * Returns the display name of this input.
   */
  getName() {
    return `Editor ${this.typeId}`;
  }
  /**
   * Returns the display description of this input.
   */
  getDescription(verbosity) {
    return void 0;
  }
  /**
   * Returns the display title of this input.
   */
  getTitle(verbosity) {
    return this.getName();
  }
  /**
   * Returns the extra classes to apply to the label of this input.
   */
  getLabelExtraClasses() {
    return [];
  }
  /**
   * Returns the aria label to be read out by a screen reader.
   */
  getAriaLabel() {
    return this.getTitle(
      0
      /* Verbosity.SHORT */
    );
  }
  /**
   * Returns the icon which represents this editor input.
   * If undefined, the default icon will be used.
   */
  getIcon() {
    return void 0;
  }
  /**
   * Returns a descriptor suitable for telemetry events.
   *
   * Subclasses should extend if they can contribute.
   */
  getTelemetryDescriptor() {
    return { typeId: this.typeId };
  }
  /**
   * Returns if this input is dirty or not.
   */
  isDirty() {
    return false;
  }
  /**
   * Returns if the input has unsaved changes.
   */
  isModified() {
    return this.isDirty();
  }
  /**
   * Returns if this input is currently being saved or soon to be
   * saved. Based on this assumption the editor may for example
   * decide to not signal the dirty state to the user assuming that
   * the save is scheduled to happen anyway.
   */
  isSaving() {
    return false;
  }
  /**
   * Returns a type of `IDisposable` that represents the resolved input.
   * Subclasses should override to provide a meaningful model or return
   * `null` if the editor does not require a model.
   *
   * The `options` parameter are passed down from the editor when the
   * input is resolved as part of it.
   */
  async resolve() {
    return null;
  }
  /**
   * Saves the editor. The provided groupId helps implementors
   * to e.g. preserve view state of the editor and re-open it
   * in the correct group after saving.
   *
   * @returns the resulting editor input (typically the same) of
   * this operation or `undefined` to indicate that the operation
   * failed or was canceled.
   */
  async save(group, options2) {
    return this;
  }
  /**
   * Saves the editor to a different location. The provided `group`
   * helps implementors to e.g. preserve view state of the editor
   * and re-open it in the correct group after saving.
   *
   * @returns the resulting editor input (typically a different one)
   * of this operation or `undefined` to indicate that the operation
   * failed or was canceled.
   */
  async saveAs(group, options2) {
    return this;
  }
  /**
   * Reverts this input from the provided group.
   */
  async revert(group, options2) {
  }
  /**
   * Called to determine how to handle a resource that is renamed that matches
   * the editors resource (or is a child of).
   *
   * Implementors are free to not implement this method to signal no intent
   * to participate. If an editor is returned though, it will replace the
   * current one with that editor and optional options.
   */
  async rename(group, target) {
    return void 0;
  }
  /**
   * Returns a copy of the current editor input. Used when we can't just reuse the input
   */
  copy() {
    return this;
  }
  /**
   * Indicates if this editor can be moved to another group. By default
   * editors can freely be moved around groups. If an editor cannot be
   * moved, a message should be returned to show to the user.
   *
   * @returns `true` if the editor can be moved to the target group, or
   * a string with a message to show to the user if the editor cannot be
   * moved.
   */
  canMove(sourceGroup, targetGroup) {
    return true;
  }
  /**
   * Returns if the other object matches this input.
   */
  matches(otherInput) {
    if (isEditorInput(otherInput)) {
      return this === otherInput;
    }
    const otherInputEditorId = otherInput.options?.override;
    if (this.editorId !== otherInputEditorId && otherInputEditorId !== void 0 && this.editorId !== void 0) {
      return false;
    }
    return isEqual(this.resource, EditorResourceAccessor.getCanonicalUri(otherInput));
  }
  /**
   * If a editor was registered onto multiple editor panes, this method
   * will be asked to return the preferred one to use.
   *
   * @param editorPanes a list of editor pane descriptors that are candidates
   * for the editor to open in.
   */
  prefersEditorPane(editorPanes) {
    return editorPanes.at(0);
  }
  /**
   * Returns a representation of this typed editor input as untyped
   * resource editor input that e.g. can be used to serialize the
   * editor input into a form that it can be restored.
   *
   * May return `undefined` if an untyped representation is not supported.
   */
  toUntyped(options2) {
    return void 0;
  }
  /**
   * Returns if this editor is disposed.
   */
  isDisposed() {
    return this._store.isDisposed;
  }
  dispose() {
    if (!this.isDisposed()) {
      this._onWillDispose.fire();
    }
    super.dispose();
  }
};

// out-build/vs/workbench/common/editor/sideBySideEditorInput.js
var SideBySideEditorInput_1;
var SideBySideEditorInput = class SideBySideEditorInput2 extends EditorInput {
  static {
    SideBySideEditorInput_1 = this;
  }
  static {
    this.ID = "workbench.editorinputs.sidebysideEditorInput";
  }
  get typeId() {
    return SideBySideEditorInput_1.ID;
  }
  get capabilities() {
    let capabilities = this.primary.capabilities;
    capabilities &= ~32;
    if (this.secondary.hasCapability(
      16
      /* EditorInputCapabilities.RequiresTrust */
    )) {
      capabilities |= 16;
    }
    if (this.secondary.hasCapability(
      8
      /* EditorInputCapabilities.Singleton */
    )) {
      capabilities |= 8;
    }
    capabilities |= 256;
    return capabilities;
  }
  get resource() {
    if (this.hasIdenticalSides) {
      return this.primary.resource;
    }
    return void 0;
  }
  constructor(preferredName, preferredDescription, secondary, primary, editorService) {
    super();
    this.preferredName = preferredName;
    this.preferredDescription = preferredDescription;
    this.secondary = secondary;
    this.primary = primary;
    this.editorService = editorService;
    this.hasIdenticalSides = this.primary.matches(this.secondary);
    this.registerListeners();
  }
  registerListeners() {
    this._register(Event.once(Event.any(this.primary.onWillDispose, this.secondary.onWillDispose))(() => {
      if (!this.isDisposed()) {
        this.dispose();
      }
    }));
    this._register(this.primary.onDidChangeDirty(() => this._onDidChangeDirty.fire()));
    this._register(this.primary.onDidChangeCapabilities(() => this._onDidChangeCapabilities.fire()));
    this._register(this.secondary.onDidChangeCapabilities(() => this._onDidChangeCapabilities.fire()));
    this._register(this.primary.onDidChangeLabel(() => this._onDidChangeLabel.fire()));
    this._register(this.secondary.onDidChangeLabel(() => this._onDidChangeLabel.fire()));
  }
  getName() {
    const preferredName = this.getPreferredName();
    if (preferredName) {
      return preferredName;
    }
    if (this.hasIdenticalSides) {
      return this.primary.getName();
    }
    return localize(4459, null, this.secondary.getName(), this.primary.getName());
  }
  getPreferredName() {
    return this.preferredName;
  }
  getDescription(verbosity) {
    const preferredDescription = this.getPreferredDescription();
    if (preferredDescription) {
      return preferredDescription;
    }
    if (this.hasIdenticalSides) {
      return this.primary.getDescription(verbosity);
    }
    return super.getDescription(verbosity);
  }
  getPreferredDescription() {
    return this.preferredDescription;
  }
  getTitle(verbosity) {
    let title;
    if (this.hasIdenticalSides) {
      title = this.primary.getTitle(verbosity) ?? this.getName();
    } else {
      title = super.getTitle(verbosity);
    }
    const preferredTitle = this.getPreferredTitle();
    if (preferredTitle) {
      title = `${preferredTitle} (${title})`;
    }
    return title;
  }
  getPreferredTitle() {
    if (this.preferredName && this.preferredDescription) {
      return `${this.preferredName} ${this.preferredDescription}`;
    }
    if (this.preferredName || this.preferredDescription) {
      return this.preferredName ?? this.preferredDescription;
    }
    return void 0;
  }
  getLabelExtraClasses() {
    if (this.hasIdenticalSides) {
      return this.primary.getLabelExtraClasses();
    }
    return super.getLabelExtraClasses();
  }
  getAriaLabel() {
    if (this.hasIdenticalSides) {
      return this.primary.getAriaLabel();
    }
    return super.getAriaLabel();
  }
  getTelemetryDescriptor() {
    const descriptor = this.primary.getTelemetryDescriptor();
    return { ...descriptor, ...super.getTelemetryDescriptor() };
  }
  isDirty() {
    return this.primary.isDirty();
  }
  isSaving() {
    return this.primary.isSaving();
  }
  async save(group, options2) {
    const primarySaveResult = await this.primary.save(group, options2);
    return this.saveResultToEditor(primarySaveResult);
  }
  async saveAs(group, options2) {
    const primarySaveResult = await this.primary.saveAs(group, options2);
    return this.saveResultToEditor(primarySaveResult);
  }
  saveResultToEditor(primarySaveResult) {
    if (!primarySaveResult || !this.hasIdenticalSides) {
      return primarySaveResult;
    }
    if (this.primary.matches(primarySaveResult)) {
      return this;
    }
    if (primarySaveResult instanceof EditorInput) {
      return new SideBySideEditorInput_1(this.preferredName, this.preferredDescription, primarySaveResult, primarySaveResult, this.editorService);
    }
    if (!isResourceDiffEditorInput(primarySaveResult) && !isResourceMultiDiffEditorInput(primarySaveResult) && !isResourceSideBySideEditorInput(primarySaveResult) && !isResourceMergeEditorInput(primarySaveResult)) {
      return {
        primary: primarySaveResult,
        secondary: primarySaveResult,
        label: this.preferredName,
        description: this.preferredDescription
      };
    }
    return void 0;
  }
  revert(group, options2) {
    return this.primary.revert(group, options2);
  }
  async rename(group, target) {
    if (!this.hasIdenticalSides) {
      return;
    }
    const renameResult = await this.primary.rename(group, target);
    if (!renameResult) {
      return void 0;
    }
    if (isEditorInput(renameResult.editor)) {
      return {
        editor: new SideBySideEditorInput_1(this.preferredName, this.preferredDescription, renameResult.editor, renameResult.editor, this.editorService),
        options: {
          ...renameResult.options,
          viewState: findViewStateForEditor(this, group, this.editorService)
        }
      };
    }
    if (isResourceEditorInput(renameResult.editor)) {
      return {
        editor: {
          label: this.preferredName,
          description: this.preferredDescription,
          primary: renameResult.editor,
          secondary: renameResult.editor,
          options: {
            ...renameResult.options,
            viewState: findViewStateForEditor(this, group, this.editorService)
          }
        }
      };
    }
    return void 0;
  }
  isReadonly() {
    return this.primary.isReadonly();
  }
  toUntyped(options2) {
    const primaryResourceEditorInput = this.primary.toUntyped(options2);
    const secondaryResourceEditorInput = this.secondary.toUntyped(options2);
    if (primaryResourceEditorInput && secondaryResourceEditorInput && !isResourceDiffEditorInput(primaryResourceEditorInput) && !isResourceDiffEditorInput(secondaryResourceEditorInput) && !isResourceMultiDiffEditorInput(primaryResourceEditorInput) && !isResourceMultiDiffEditorInput(secondaryResourceEditorInput) && !isResourceSideBySideEditorInput(primaryResourceEditorInput) && !isResourceSideBySideEditorInput(secondaryResourceEditorInput) && !isResourceMergeEditorInput(primaryResourceEditorInput) && !isResourceMergeEditorInput(secondaryResourceEditorInput)) {
      const untypedInput = {
        label: this.preferredName,
        description: this.preferredDescription,
        primary: primaryResourceEditorInput,
        secondary: secondaryResourceEditorInput
      };
      if (typeof options2?.preserveViewState === "number") {
        untypedInput.options = {
          viewState: findViewStateForEditor(this, options2.preserveViewState, this.editorService)
        };
      }
      return untypedInput;
    }
    return void 0;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (isDiffEditorInput(otherInput) || isResourceDiffEditorInput(otherInput)) {
      return false;
    }
    if (otherInput instanceof SideBySideEditorInput_1) {
      return this.primary.matches(otherInput.primary) && this.secondary.matches(otherInput.secondary);
    }
    if (isResourceSideBySideEditorInput(otherInput)) {
      return this.primary.matches(otherInput.primary) && this.secondary.matches(otherInput.secondary);
    }
    return false;
  }
};
SideBySideEditorInput = SideBySideEditorInput_1 = __decorate([
  __param(4, IEditorService)
], SideBySideEditorInput);

// out-build/vs/workbench/common/editor/editorModel.js
var EditorModel = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this.resolved = false;
  }
  /**
   * Causes this model to resolve returning a promise when loading is completed.
   */
  async resolve() {
    this.resolved = true;
  }
  /**
   * Returns whether this model was loaded or not.
   */
  isResolved() {
    return this.resolved;
  }
  /**
   * Find out if this model has been disposed.
   */
  isDisposed() {
    return this._store.isDisposed;
  }
  /**
   * Subclasses should implement to free resources that have been claimed through loading.
   */
  dispose() {
    this._onWillDispose.fire();
    super.dispose();
  }
};

// out-build/vs/editor/common/languages/modesRegistry.js
var Extensions5 = {
  ModesRegistry: "editor.modesRegistry"
};
var EditorModesRegistry = class extends Disposable {
  constructor() {
    super();
    this._onDidChangeLanguages = this._register(new Emitter());
    this.onDidChangeLanguages = this._onDidChangeLanguages.event;
    this._languages = [];
  }
  registerLanguage(def2) {
    this._languages.push(def2);
    this._onDidChangeLanguages.fire(void 0);
    return {
      dispose: () => {
        for (let i = 0, len = this._languages.length; i < len; i++) {
          if (this._languages[i] === def2) {
            this._languages.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  getLanguages() {
    return this._languages;
  }
};
var ModesRegistry = new EditorModesRegistry();
Registry.add(Extensions5.ModesRegistry, ModesRegistry);
var PLAINTEXT_LANGUAGE_ID = "plaintext";
var PLAINTEXT_EXTENSION = ".txt";
ModesRegistry.registerLanguage({
  id: PLAINTEXT_LANGUAGE_ID,
  extensions: [PLAINTEXT_EXTENSION],
  aliases: [localize(903, null), "text"],
  mimetypes: [Mimes.text]
});
Registry.as(Extensions2.Configuration).registerDefaultConfigurations([{
  overrides: {
    "[plaintext]": {
      "editor.unicodeHighlight.ambiguousCharacters": false,
      "editor.unicodeHighlight.invisibleCharacters": false
    },
    // TODO: Below is a workaround for: https://github.com/microsoft/vscode/issues/240567
    "[go]": {
      "editor.insertSpaces": false
    },
    "[makefile]": {
      "editor.insertSpaces": false
    },
    "[shellscript]": {
      "files.eol": "\n"
    },
    "[yaml]": {
      "editor.insertSpaces": true,
      "editor.tabSize": 2
    }
  }
}]);

// out-build/vs/workbench/services/languageDetection/common/languageDetectionWorkerService.js
var ILanguageDetectionService = createDecorator("ILanguageDetectionService");
var LanguageDetectionLanguageEventSource = "languageDetection";

// out-build/vs/platform/accessibility/common/accessibility.js
var IAccessibilityService = createDecorator("accessibilityService");
var AccessibilitySupport;
(function(AccessibilitySupport2) {
  AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
  AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
  AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CONTEXT_ACCESSIBILITY_MODE_ENABLED = new RawContextKey("accessibilityModeEnabled", false);

// out-build/vs/workbench/common/editor/textEditorModel.js
var BaseTextEditorModel_1;
var BaseTextEditorModel = class BaseTextEditorModel2 extends EditorModel {
  static {
    BaseTextEditorModel_1 = this;
  }
  static {
    this.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY = 600;
  }
  constructor(modelService, languageService, languageDetectionService, accessibilityService, textEditorModelHandle) {
    super();
    this.modelService = modelService;
    this.languageService = languageService;
    this.languageDetectionService = languageDetectionService;
    this.accessibilityService = accessibilityService;
    this.textEditorModelHandle = void 0;
    this.modelDisposeListener = this._register(new MutableDisposable());
    this.autoDetectLanguageThrottler = this._register(new ThrottledDelayer(BaseTextEditorModel_1.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY));
    this._blockLanguageChangeListener = false;
    this._languageChangeSource = void 0;
    if (textEditorModelHandle) {
      this.handleExistingModel(textEditorModelHandle);
    }
  }
  handleExistingModel(textEditorModelHandle) {
    const model = this.modelService.getModel(textEditorModelHandle);
    if (!model) {
      throw new Error(`Document with resource ${textEditorModelHandle.toString(true)} does not exist`);
    }
    this.textEditorModelHandle = textEditorModelHandle;
    this.registerModelDisposeListener(model);
  }
  registerModelDisposeListener(model) {
    this.modelDisposeListener.value = model.onWillDispose(() => {
      this.textEditorModelHandle = void 0;
      this.dispose();
    });
  }
  get textEditorModel() {
    return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
  }
  isReadonly() {
    return true;
  }
  get languageChangeSource() {
    return this._languageChangeSource;
  }
  get hasLanguageSetExplicitly() {
    return typeof this._languageChangeSource === "string";
  }
  setLanguageId(languageId, source) {
    this._languageChangeSource = "user";
    this.setLanguageIdInternal(languageId, source);
  }
  setLanguageIdInternal(languageId, source) {
    if (!this.isResolved()) {
      return;
    }
    if (!languageId || languageId === this.textEditorModel.getLanguageId()) {
      return;
    }
    this._blockLanguageChangeListener = true;
    try {
      this.textEditorModel.setLanguage(this.languageService.createById(languageId), source);
    } finally {
      this._blockLanguageChangeListener = false;
    }
  }
  installModelListeners(model) {
    const disposable = this._register(model.onDidChangeLanguage((e) => {
      if (e.source === LanguageDetectionLanguageEventSource || this._blockLanguageChangeListener) {
        return;
      }
      this._languageChangeSource = "api";
      disposable.dispose();
    }));
  }
  getLanguageId() {
    return this.textEditorModel?.getLanguageId();
  }
  autoDetectLanguage() {
    return this.autoDetectLanguageThrottler.trigger(() => this.doAutoDetectLanguage());
  }
  async doAutoDetectLanguage() {
    if (this.hasLanguageSetExplicitly || // skip detection when the user has made an explicit choice on the language
    !this.textEditorModelHandle || // require a URI to run the detection for
    !this.languageDetectionService.isEnabledForLanguage(this.getLanguageId() ?? PLAINTEXT_LANGUAGE_ID)) {
      return;
    }
    const lang = await this.languageDetectionService.detectLanguage(this.textEditorModelHandle);
    const prevLang = this.getLanguageId();
    if (lang && lang !== prevLang && !this.isDisposed()) {
      this.setLanguageIdInternal(lang, LanguageDetectionLanguageEventSource);
      const languageName = this.languageService.getLanguageName(lang);
      this.accessibilityService.alert(localize(4460, null, languageName ?? lang));
    }
  }
  /**
   * Creates the text editor model with the provided value, optional preferred language
   * (can be comma separated for multiple values) and optional resource URL.
   */
  createTextEditorModel(value, resource, preferredLanguageId) {
    const firstLineText = this.getFirstLineText(value);
    const languageSelection = this.getOrCreateLanguage(resource, this.languageService, preferredLanguageId, firstLineText);
    return this.doCreateTextEditorModel(value, languageSelection, resource);
  }
  doCreateTextEditorModel(value, languageSelection, resource) {
    let model = resource && this.modelService.getModel(resource);
    if (!model) {
      model = this.modelService.createModel(value, languageSelection, resource);
      this.createdEditorModel = true;
      this.registerModelDisposeListener(model);
    } else {
      this.updateTextEditorModel(value, languageSelection.languageId);
    }
    this.textEditorModelHandle = model.uri;
    return model;
  }
  getFirstLineText(value) {
    const textBufferFactory = value;
    if (typeof textBufferFactory.getFirstLineText === "function") {
      return textBufferFactory.getFirstLineText(
        1e3
        /* ModelConstants.FIRST_LINE_DETECTION_LENGTH_LIMIT */
      );
    }
    const textSnapshot = value;
    return textSnapshot.getLineContent(1).substr(
      0,
      1e3
      /* ModelConstants.FIRST_LINE_DETECTION_LENGTH_LIMIT */
    );
  }
  /**
   * Gets the language for the given identifier. Subclasses can override to provide their own implementation of this lookup.
   *
   * @param firstLineText optional first line of the text buffer to set the language on. This can be used to guess a language from content.
   */
  getOrCreateLanguage(resource, languageService, preferredLanguage, firstLineText) {
    if (!preferredLanguage || preferredLanguage === PLAINTEXT_LANGUAGE_ID) {
      return languageService.createByFilepathOrFirstLine(resource ?? null, firstLineText);
    }
    return languageService.createById(preferredLanguage);
  }
  /**
   * Updates the text editor model with the provided value. If the value is the same as the model has, this is a no-op.
   */
  updateTextEditorModel(newValue, preferredLanguageId, reason) {
    if (!this.isResolved()) {
      return;
    }
    if (newValue) {
      this.modelService.updateModel(this.textEditorModel, newValue, reason);
    }
    if (preferredLanguageId && preferredLanguageId !== PLAINTEXT_LANGUAGE_ID && this.textEditorModel.getLanguageId() !== preferredLanguageId) {
      this.textEditorModel.setLanguage(this.languageService.createById(preferredLanguageId));
    }
  }
  createSnapshot() {
    if (!this.textEditorModel) {
      return null;
    }
    return this.textEditorModel.createSnapshot(
      true
      /* preserve BOM */
    );
  }
  isResolved() {
    return !!this.textEditorModelHandle;
  }
  dispose() {
    this.modelDisposeListener.dispose();
    if (this.textEditorModelHandle && this.createdEditorModel) {
      this.modelService.destroyModel(this.textEditorModelHandle);
    }
    this.textEditorModelHandle = void 0;
    this.createdEditorModel = false;
    super.dispose();
  }
};
BaseTextEditorModel = BaseTextEditorModel_1 = __decorate([
  __param(0, IModelService),
  __param(1, ILanguageService),
  __param(2, ILanguageDetectionService),
  __param(3, IAccessibilityService)
], BaseTextEditorModel);

// out-build/vs/workbench/common/editor/diffEditorModel.js
var DiffEditorModel = class extends EditorModel {
  get originalModel() {
    return this._originalModel;
  }
  get modifiedModel() {
    return this._modifiedModel;
  }
  constructor(originalModel, modifiedModel) {
    super();
    this._originalModel = originalModel;
    this._modifiedModel = modifiedModel;
  }
  async resolve() {
    await Promise.all([
      this._originalModel?.resolve(),
      this._modifiedModel?.resolve()
    ]);
  }
  isResolved() {
    return !!(this._originalModel?.isResolved() && this._modifiedModel?.isResolved());
  }
  dispose() {
    super.dispose();
  }
};

// out-build/vs/workbench/common/editor/textDiffEditorModel.js
var TextDiffEditorModel = class extends DiffEditorModel {
  get originalModel() {
    return this._originalModel;
  }
  get modifiedModel() {
    return this._modifiedModel;
  }
  get textDiffEditorModel() {
    return this._textDiffEditorModel;
  }
  constructor(originalModel, modifiedModel) {
    super(originalModel, modifiedModel);
    this._textDiffEditorModel = void 0;
    this._originalModel = originalModel;
    this._modifiedModel = modifiedModel;
    this.updateTextDiffEditorModel();
  }
  async resolve() {
    await super.resolve();
    this.updateTextDiffEditorModel();
  }
  updateTextDiffEditorModel() {
    if (this.originalModel?.isResolved() && this.modifiedModel?.isResolved()) {
      if (!this._textDiffEditorModel) {
        this._textDiffEditorModel = {
          original: this.originalModel.textEditorModel,
          modified: this.modifiedModel.textEditorModel
        };
      } else {
        this._textDiffEditorModel.original = this.originalModel.textEditorModel;
        this._textDiffEditorModel.modified = this.modifiedModel.textEditorModel;
      }
    }
  }
  isResolved() {
    return !!this._textDiffEditorModel;
  }
  isReadonly() {
    return !!this.modifiedModel && this.modifiedModel.isReadonly();
  }
  dispose() {
    this._textDiffEditorModel = void 0;
    super.dispose();
  }
};

// out-build/vs/platform/editor/common/editor.js
function isResolvedEditorModel(model) {
  const candidate = model;
  return typeof candidate?.resolve === "function" && typeof candidate?.isResolved === "function";
}
var EditorActivation;
(function(EditorActivation2) {
  EditorActivation2[EditorActivation2["ACTIVATE"] = 1] = "ACTIVATE";
  EditorActivation2[EditorActivation2["RESTORE"] = 2] = "RESTORE";
  EditorActivation2[EditorActivation2["PRESERVE"] = 3] = "PRESERVE";
})(EditorActivation || (EditorActivation = {}));
var EditorResolution;
(function(EditorResolution2) {
  EditorResolution2[EditorResolution2["PICK"] = 0] = "PICK";
  EditorResolution2[EditorResolution2["EXCLUSIVE_ONLY"] = 1] = "EXCLUSIVE_ONLY";
})(EditorResolution || (EditorResolution = {}));
var EditorOpenSource;
(function(EditorOpenSource2) {
  EditorOpenSource2[EditorOpenSource2["API"] = 0] = "API";
  EditorOpenSource2[EditorOpenSource2["USER"] = 1] = "USER";
})(EditorOpenSource || (EditorOpenSource = {}));
var TextEditorSelectionRevealType;
(function(TextEditorSelectionRevealType2) {
  TextEditorSelectionRevealType2[TextEditorSelectionRevealType2["Center"] = 0] = "Center";
  TextEditorSelectionRevealType2[TextEditorSelectionRevealType2["CenterIfOutsideViewport"] = 1] = "CenterIfOutsideViewport";
  TextEditorSelectionRevealType2[TextEditorSelectionRevealType2["NearTop"] = 2] = "NearTop";
  TextEditorSelectionRevealType2[TextEditorSelectionRevealType2["NearTopIfOutsideViewport"] = 3] = "NearTopIfOutsideViewport";
})(TextEditorSelectionRevealType || (TextEditorSelectionRevealType = {}));
var TextEditorSelectionSource;
(function(TextEditorSelectionSource2) {
  TextEditorSelectionSource2["PROGRAMMATIC"] = "api";
  TextEditorSelectionSource2["NAVIGATION"] = "code.navigation";
  TextEditorSelectionSource2["JUMP"] = "code.jump";
})(TextEditorSelectionSource || (TextEditorSelectionSource = {}));

// out-build/vs/workbench/common/editor/diffEditorInput.js
var DiffEditorInput_1;
var DiffEditorInput = class DiffEditorInput2 extends SideBySideEditorInput {
  static {
    DiffEditorInput_1 = this;
  }
  static {
    this.ID = "workbench.editors.diffEditorInput";
  }
  get typeId() {
    return DiffEditorInput_1.ID;
  }
  get editorId() {
    return this.modified.editorId === this.original.editorId ? this.modified.editorId : void 0;
  }
  get capabilities() {
    let capabilities = super.capabilities;
    if (this.labels.forceDescription) {
      capabilities |= 64;
    }
    return capabilities;
  }
  constructor(preferredName, preferredDescription, original, modified, forceOpenAsBinary, editorService) {
    super(preferredName, preferredDescription, original, modified, editorService);
    this.original = original;
    this.modified = modified;
    this.forceOpenAsBinary = forceOpenAsBinary;
    this.cachedModel = void 0;
    this.labels = this.computeLabels();
  }
  computeLabels() {
    let name2;
    let forceDescription = false;
    if (this.preferredName) {
      name2 = this.preferredName;
    } else {
      const originalName = this.original.getName();
      const modifiedName = this.modified.getName();
      name2 = localize(4458, null, originalName, modifiedName);
      forceDescription = originalName === modifiedName;
    }
    let shortDescription;
    let mediumDescription;
    let longDescription;
    if (this.preferredDescription) {
      shortDescription = this.preferredDescription;
      mediumDescription = this.preferredDescription;
      longDescription = this.preferredDescription;
    } else {
      shortDescription = this.computeLabel(this.original.getDescription(
        0
        /* Verbosity.SHORT */
      ), this.modified.getDescription(
        0
        /* Verbosity.SHORT */
      ));
      longDescription = this.computeLabel(this.original.getDescription(
        2
        /* Verbosity.LONG */
      ), this.modified.getDescription(
        2
        /* Verbosity.LONG */
      ));
      const originalMediumDescription = this.original.getDescription(
        1
        /* Verbosity.MEDIUM */
      );
      const modifiedMediumDescription = this.modified.getDescription(
        1
        /* Verbosity.MEDIUM */
      );
      if (typeof originalMediumDescription === "string" && typeof modifiedMediumDescription === "string" && // we can only `shorten` when both sides are strings...
      (originalMediumDescription || modifiedMediumDescription)) {
        const [shortenedOriginalMediumDescription, shortenedModifiedMediumDescription] = shorten([originalMediumDescription, modifiedMediumDescription]);
        mediumDescription = this.computeLabel(shortenedOriginalMediumDescription, shortenedModifiedMediumDescription);
      }
    }
    let shortTitle = this.computeLabel(this.original.getTitle(
      0
      /* Verbosity.SHORT */
    ) ?? this.original.getName(), this.modified.getTitle(
      0
      /* Verbosity.SHORT */
    ) ?? this.modified.getName(), " \u2194 ");
    let mediumTitle = this.computeLabel(this.original.getTitle(
      1
      /* Verbosity.MEDIUM */
    ) ?? this.original.getName(), this.modified.getTitle(
      1
      /* Verbosity.MEDIUM */
    ) ?? this.modified.getName(), " \u2194 ");
    let longTitle = this.computeLabel(this.original.getTitle(
      2
      /* Verbosity.LONG */
    ) ?? this.original.getName(), this.modified.getTitle(
      2
      /* Verbosity.LONG */
    ) ?? this.modified.getName(), " \u2194 ");
    const preferredTitle = this.getPreferredTitle();
    if (preferredTitle) {
      shortTitle = `${preferredTitle} (${shortTitle})`;
      mediumTitle = `${preferredTitle} (${mediumTitle})`;
      longTitle = `${preferredTitle} (${longTitle})`;
    }
    return { name: name2, shortDescription, mediumDescription, longDescription, forceDescription, shortTitle, mediumTitle, longTitle };
  }
  computeLabel(originalLabel, modifiedLabel, separator = " - ") {
    if (!originalLabel || !modifiedLabel) {
      return void 0;
    }
    if (originalLabel === modifiedLabel) {
      return modifiedLabel;
    }
    return `${originalLabel}${separator}${modifiedLabel}`;
  }
  getName() {
    return this.labels.name;
  }
  getDescription(verbosity = 1) {
    switch (verbosity) {
      case 0:
        return this.labels.shortDescription;
      case 2:
        return this.labels.longDescription;
      case 1:
      default:
        return this.labels.mediumDescription;
    }
  }
  getTitle(verbosity) {
    switch (verbosity) {
      case 0:
        return this.labels.shortTitle;
      case 2:
        return this.labels.longTitle;
      default:
      case 1:
        return this.labels.mediumTitle;
    }
  }
  async resolve() {
    const resolvedModel = await this.createModel();
    this.cachedModel?.dispose();
    this.cachedModel = resolvedModel;
    return this.cachedModel;
  }
  prefersEditorPane(editorPanes) {
    if (this.forceOpenAsBinary) {
      return editorPanes.find((editorPane) => editorPane.typeId === BINARY_DIFF_EDITOR_ID);
    }
    return editorPanes.find((editorPane) => editorPane.typeId === TEXT_DIFF_EDITOR_ID);
  }
  async createModel() {
    const [originalEditorModel, modifiedEditorModel] = await Promise.all([
      this.original.resolve(),
      this.modified.resolve()
    ]);
    if (modifiedEditorModel instanceof BaseTextEditorModel && originalEditorModel instanceof BaseTextEditorModel) {
      return new TextDiffEditorModel(originalEditorModel, modifiedEditorModel);
    }
    return new DiffEditorModel(isResolvedEditorModel(originalEditorModel) ? originalEditorModel : void 0, isResolvedEditorModel(modifiedEditorModel) ? modifiedEditorModel : void 0);
  }
  toUntyped(options2) {
    const untyped = super.toUntyped(options2);
    if (untyped) {
      return {
        ...untyped,
        modified: untyped.primary,
        original: untyped.secondary
      };
    }
    return void 0;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (otherInput instanceof DiffEditorInput_1) {
      return this.modified.matches(otherInput.modified) && this.original.matches(otherInput.original) && otherInput.forceOpenAsBinary === this.forceOpenAsBinary;
    }
    if (isResourceDiffEditorInput(otherInput)) {
      return this.modified.matches(otherInput.modified) && this.original.matches(otherInput.original);
    }
    return false;
  }
  dispose() {
    if (this.cachedModel) {
      this.cachedModel.dispose();
      this.cachedModel = void 0;
    }
    super.dispose();
  }
};
DiffEditorInput = DiffEditorInput_1 = __decorate([
  __param(5, IEditorService)
], DiffEditorInput);

// out-build/vs/workbench/common/contextkeys.js
var ResourceContextKey_1;
var WorkbenchStateContext = new RawContextKey("workbenchState", void 0, { type: "string", description: localize(4380, null) });
var WorkspaceFolderCountContext = new RawContextKey("workspaceFolderCount", 0, localize(4381, null));
var OpenFolderWorkspaceSupportContext = new RawContextKey("openFolderWorkspaceSupport", true, true);
var EnterMultiRootWorkspaceSupportContext = new RawContextKey("enterMultiRootWorkspaceSupport", true, true);
var EmptyWorkspaceSupportContext = new RawContextKey("emptyWorkspaceSupport", true, true);
var DirtyWorkingCopiesContext = new RawContextKey("dirtyWorkingCopies", false, localize(4382, null));
var RemoteNameContext = new RawContextKey("remoteName", "", localize(4383, null));
var VirtualWorkspaceContext = new RawContextKey("virtualWorkspace", "", localize(4384, null));
var TemporaryWorkspaceContext = new RawContextKey("temporaryWorkspace", false, localize(4385, null));
var HasWebFileSystemAccess = new RawContextKey("hasWebFileSystemAccess", false, true);
var EmbedderIdentifierContext = new RawContextKey("embedderIdentifier", void 0, localize(4386, null));
var InAutomationContext = new RawContextKey("inAutomation", false, localize(4387, null));
var IsMainWindowFullscreenContext = new RawContextKey("isFullscreen", false, localize(4388, null));
var IsAuxiliaryWindowFocusedContext = new RawContextKey("isAuxiliaryWindowFocusedContext", false, localize(4389, null));
var IsWindowAlwaysOnTopContext = new RawContextKey("isWindowAlwaysOnTop", false, localize(4390, null));
var IsAuxiliaryWindowContext = new RawContextKey("isAuxiliaryWindow", false, localize(4391, null));
var ActiveEditorDirtyContext = new RawContextKey("activeEditorIsDirty", false, localize(4392, null));
var ActiveEditorPinnedContext = new RawContextKey("activeEditorIsNotPreview", false, localize(4393, null));
var ActiveEditorFirstInGroupContext = new RawContextKey("activeEditorIsFirstInGroup", false, localize(4394, null));
var ActiveEditorLastInGroupContext = new RawContextKey("activeEditorIsLastInGroup", false, localize(4395, null));
var ActiveEditorStickyContext = new RawContextKey("activeEditorIsPinned", false, localize(4396, null));
var ActiveEditorReadonlyContext = new RawContextKey("activeEditorIsReadonly", false, localize(4397, null));
var ActiveCompareEditorCanSwapContext = new RawContextKey("activeCompareEditorCanSwap", false, localize(4398, null));
var ActiveEditorCanToggleReadonlyContext = new RawContextKey("activeEditorCanToggleReadonly", true, localize(4399, null));
var ActiveEditorCanRevertContext = new RawContextKey("activeEditorCanRevert", false, localize(4400, null));
var ActiveEditorCanSplitInGroupContext = new RawContextKey("activeEditorCanSplitInGroup", true);
var ActiveEditorContext = new RawContextKey("activeEditor", null, { type: "string", description: localize(4401, null) });
var ActiveEditorAvailableEditorIdsContext = new RawContextKey("activeEditorAvailableEditorIds", "", localize(4402, null));
var TextCompareEditorVisibleContext = new RawContextKey("textCompareEditorVisible", false, localize(4403, null));
var TextCompareEditorActiveContext = new RawContextKey("textCompareEditorActive", false, localize(4404, null));
var SideBySideEditorActiveContext = new RawContextKey("sideBySideEditorActive", false, localize(4405, null));
var EditorGroupEditorsCountContext = new RawContextKey("groupEditorsCount", 0, localize(4406, null));
var ActiveEditorGroupEmptyContext = new RawContextKey("activeEditorGroupEmpty", false, localize(4407, null));
var ActiveEditorGroupIndexContext = new RawContextKey("activeEditorGroupIndex", 0, localize(4408, null));
var ActiveEditorGroupLastContext = new RawContextKey("activeEditorGroupLast", false, localize(4409, null));
var ActiveEditorGroupLockedContext = new RawContextKey("activeEditorGroupLocked", false, localize(4410, null));
var MultipleEditorGroupsContext = new RawContextKey("multipleEditorGroups", false, localize(4411, null));
var SingleEditorGroupsContext = MultipleEditorGroupsContext.toNegated();
var MultipleEditorsSelectedInGroupContext = new RawContextKey("multipleEditorsSelectedInGroup", false, localize(4412, null));
var TwoEditorsSelectedInGroupContext = new RawContextKey("twoEditorsSelectedInGroup", false, localize(4413, null));
var SelectedEditorsInGroupFileOrUntitledResourceContextKey = new RawContextKey("SelectedEditorsInGroupFileOrUntitledResourceContextKey", true, localize(4414, null));
var EditorPartMultipleEditorGroupsContext = new RawContextKey("editorPartMultipleEditorGroups", false, localize(4415, null));
var EditorPartSingleEditorGroupsContext = EditorPartMultipleEditorGroupsContext.toNegated();
var EditorPartMaximizedEditorGroupContext = new RawContextKey("editorPartMaximizedEditorGroup", false, localize(4416, null));
var EditorsVisibleContext = new RawContextKey("editorIsOpen", false, localize(4417, null));
var InEditorZenModeContext = new RawContextKey("inZenMode", false, localize(4418, null));
var IsMainEditorCenteredLayoutContext = new RawContextKey("isCenteredLayout", false, localize(4419, null));
var SplitEditorsVertically = new RawContextKey("splitEditorsVertically", false, localize(4420, null));
var MainEditorAreaVisibleContext = new RawContextKey("mainEditorAreaVisible", true, localize(4421, null));
var EditorTabsVisibleContext = new RawContextKey("editorTabsVisible", true, localize(4422, null));
var SideBarVisibleContext = new RawContextKey("sideBarVisible", false, localize(4423, null));
var SidebarFocusContext = new RawContextKey("sideBarFocus", false, localize(4424, null));
var ActiveViewletContext = new RawContextKey("activeViewlet", "", localize(4425, null));
var StatusBarFocused = new RawContextKey("statusBarFocused", false, localize(4426, null));
var TitleBarStyleContext = new RawContextKey("titleBarStyle", "custom", localize(4427, null));
var TitleBarVisibleContext = new RawContextKey("titleBarVisible", false, localize(4428, null));
var IsCompactTitleBarContext = new RawContextKey("isCompactTitleBar", false, localize(4429, null));
var BannerFocused = new RawContextKey("bannerFocused", false, localize(4430, null));
var NotificationFocusedContext = new RawContextKey("notificationFocus", true, localize(4431, null));
var NotificationsCenterVisibleContext = new RawContextKey("notificationCenterVisible", false, localize(4432, null));
var NotificationsToastsVisibleContext = new RawContextKey("notificationToastsVisible", false, localize(4433, null));
var ActiveAuxiliaryContext = new RawContextKey("activeAuxiliary", "", localize(4434, null));
var AuxiliaryBarFocusContext = new RawContextKey("auxiliaryBarFocus", false, localize(4435, null));
var AuxiliaryBarVisibleContext = new RawContextKey("auxiliaryBarVisible", false, localize(4436, null));
var AuxiliaryBarMaximizedContext = new RawContextKey("auxiliaryBarMaximized", false, localize(4437, null));
var ActivePanelContext = new RawContextKey("activePanel", "", localize(4438, null));
var PanelFocusContext = new RawContextKey("panelFocus", false, localize(4439, null));
var PanelPositionContext = new RawContextKey("panelPosition", "bottom", localize(4440, null));
var PanelAlignmentContext = new RawContextKey("panelAlignment", "center", localize(4441, null));
var PanelVisibleContext = new RawContextKey("panelVisible", false, localize(4442, null));
var PanelMaximizedContext = new RawContextKey("panelMaximized", false, localize(4443, null));
var FocusedViewContext = new RawContextKey("focusedView", "", localize(4444, null));
var ResourceContextKey = class ResourceContextKey2 {
  static {
    ResourceContextKey_1 = this;
  }
  static {
    this.Scheme = new RawContextKey("resourceScheme", void 0, { type: "string", description: localize(4445, null) });
  }
  static {
    this.Filename = new RawContextKey("resourceFilename", void 0, { type: "string", description: localize(4446, null) });
  }
  static {
    this.Dirname = new RawContextKey("resourceDirname", void 0, { type: "string", description: localize(4447, null) });
  }
  static {
    this.Path = new RawContextKey("resourcePath", void 0, { type: "string", description: localize(4448, null) });
  }
  static {
    this.LangId = new RawContextKey("resourceLangId", void 0, { type: "string", description: localize(4449, null) });
  }
  static {
    this.Resource = new RawContextKey("resource", void 0, { type: "URI", description: localize(4450, null) });
  }
  static {
    this.Extension = new RawContextKey("resourceExtname", void 0, { type: "string", description: localize(4451, null) });
  }
  static {
    this.HasResource = new RawContextKey("resourceSet", void 0, { type: "boolean", description: localize(4452, null) });
  }
  static {
    this.IsFileSystemResource = new RawContextKey("isFileSystemResource", void 0, { type: "boolean", description: localize(4453, null) });
  }
  constructor(_contextKeyService, _fileService, _languageService, _modelService) {
    this._contextKeyService = _contextKeyService;
    this._fileService = _fileService;
    this._languageService = _languageService;
    this._modelService = _modelService;
    this._disposables = new DisposableStore();
    this._schemeKey = ResourceContextKey_1.Scheme.bindTo(this._contextKeyService);
    this._filenameKey = ResourceContextKey_1.Filename.bindTo(this._contextKeyService);
    this._dirnameKey = ResourceContextKey_1.Dirname.bindTo(this._contextKeyService);
    this._pathKey = ResourceContextKey_1.Path.bindTo(this._contextKeyService);
    this._langIdKey = ResourceContextKey_1.LangId.bindTo(this._contextKeyService);
    this._resourceKey = ResourceContextKey_1.Resource.bindTo(this._contextKeyService);
    this._extensionKey = ResourceContextKey_1.Extension.bindTo(this._contextKeyService);
    this._hasResource = ResourceContextKey_1.HasResource.bindTo(this._contextKeyService);
    this._isFileSystemResource = ResourceContextKey_1.IsFileSystemResource.bindTo(this._contextKeyService);
    this._disposables.add(_fileService.onDidChangeFileSystemProviderRegistrations(() => {
      const resource = this.get();
      this._isFileSystemResource.set(Boolean(resource && _fileService.hasProvider(resource)));
    }));
    this._disposables.add(_modelService.onModelAdded((model) => {
      if (isEqual(model.uri, this.get())) {
        this._setLangId();
      }
    }));
    this._disposables.add(_modelService.onModelLanguageChanged((e) => {
      if (isEqual(e.model.uri, this.get())) {
        this._setLangId();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
  }
  _setLangId() {
    const value = this.get();
    if (!value) {
      this._langIdKey.set(null);
      return;
    }
    const langId = this._modelService.getModel(value)?.getLanguageId() ?? this._languageService.guessLanguageIdByFilepathOrFirstLine(value);
    this._langIdKey.set(langId);
  }
  set(value) {
    value = value ?? void 0;
    if (isEqual(this._value, value)) {
      return;
    }
    this._value = value;
    this._contextKeyService.bufferChangeEvents(() => {
      this._resourceKey.set(value ? value.toString() : null);
      this._schemeKey.set(value ? value.scheme : null);
      this._filenameKey.set(value ? basename2(value) : null);
      this._dirnameKey.set(value ? this.uriToPath(dirname2(value)) : null);
      this._pathKey.set(value ? this.uriToPath(value) : null);
      this._setLangId();
      this._extensionKey.set(value ? extname2(value) : null);
      this._hasResource.set(Boolean(value));
      this._isFileSystemResource.set(value ? this._fileService.hasProvider(value) : false);
    });
  }
  uriToPath(uri) {
    if (uri.scheme === Schemas.file) {
      return uri.fsPath;
    }
    return uri.path;
  }
  reset() {
    this._value = void 0;
    this._contextKeyService.bufferChangeEvents(() => {
      this._resourceKey.reset();
      this._schemeKey.reset();
      this._filenameKey.reset();
      this._dirnameKey.reset();
      this._pathKey.reset();
      this._langIdKey.reset();
      this._extensionKey.reset();
      this._hasResource.reset();
      this._isFileSystemResource.reset();
    });
  }
  get() {
    return this._value;
  }
};
ResourceContextKey = ResourceContextKey_1 = __decorate([
  __param(0, IContextKeyService),
  __param(1, IFileService),
  __param(2, ILanguageService),
  __param(3, IModelService)
], ResourceContextKey);

// out-build/vs/platform/dialogs/common/dialogs.js
var IDialogService = createDecorator("dialogService");
var DialogKind;
(function(DialogKind2) {
  DialogKind2[DialogKind2["Confirmation"] = 1] = "Confirmation";
  DialogKind2[DialogKind2["Prompt"] = 2] = "Prompt";
  DialogKind2[DialogKind2["Input"] = 3] = "Input";
})(DialogKind || (DialogKind = {}));
var IFileDialogService = createDecorator("fileDialogService");
var ConfirmResult;
(function(ConfirmResult2) {
  ConfirmResult2[ConfirmResult2["SAVE"] = 0] = "SAVE";
  ConfirmResult2[ConfirmResult2["DONT_SAVE"] = 1] = "DONT_SAVE";
  ConfirmResult2[ConfirmResult2["CANCEL"] = 2] = "CANCEL";
})(ConfirmResult || (ConfirmResult = {}));

// out-build/vs/platform/commands/common/commands.js
var ICommandService = createDecorator("commandService");
var CommandsRegistry = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
    this._onDidRegisterCommand = new Emitter();
    this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(idOrCommand, handler) {
    if (!idOrCommand) {
      throw new Error(`invalid command`);
    }
    if (typeof idOrCommand === "string") {
      if (!handler) {
        throw new Error(`invalid command`);
      }
      return this.registerCommand({ id: idOrCommand, handler });
    }
    if (idOrCommand.metadata && Array.isArray(idOrCommand.metadata.args)) {
      const constraints = [];
      for (const arg of idOrCommand.metadata.args) {
        constraints.push(arg.constraint);
      }
      const actualHandler = idOrCommand.handler;
      idOrCommand.handler = function(accessor, ...args) {
        validateConstraints(args, constraints);
        return actualHandler(accessor, ...args);
      };
    }
    const { id: id2 } = idOrCommand;
    let commands = this._commands.get(id2);
    if (!commands) {
      commands = new LinkedList();
      this._commands.set(id2, commands);
    }
    const removeFn = commands.unshift(idOrCommand);
    const ret = toDisposable(() => {
      removeFn();
      const command = this._commands.get(id2);
      if (command?.isEmpty()) {
        this._commands.delete(id2);
      }
    });
    this._onDidRegisterCommand.fire(id2);
    return markAsSingleton(ret);
  }
  registerCommandAlias(oldId, newId) {
    return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));
  }
  getCommand(id2) {
    const list2 = this._commands.get(id2);
    if (!list2 || list2.isEmpty()) {
      return void 0;
    }
    return Iterable.first(list2);
  }
  getCommands() {
    const result = /* @__PURE__ */ new Map();
    for (const key of this._commands.keys()) {
      const command = this.getCommand(key);
      if (command) {
        result.set(key, command);
      }
    }
    return result;
  }
}();
CommandsRegistry.registerCommand("noop", () => {
});

// out-build/vs/platform/opener/common/opener.js
var IOpenerService = createDecorator("openerService");

// out-build/vs/platform/url/common/url.js
var IURLService = createDecorator("urlService");

// out-build/vs/workbench/services/chat/common/pukuAuthService.js
var PUKU_API_BASE = "https://api.puku.sh";
var PUKU_SESSION_TOKEN_KEY = "puku.sessionToken";
var PUKU_USER_KEY = "puku.user";
var IPukuAuthService = createDecorator("pukuAuthService");
var PukuAuthService = class PukuAuthService2 extends Disposable {
  constructor(logService, openerService, storageService, urlService, requestService) {
    super();
    this.logService = logService;
    this.openerService = openerService;
    this.storageService = storageService;
    this.urlService = urlService;
    this.requestService = requestService;
    this._onDidChangeSession = this._register(new Emitter());
    this.onDidChangeSession = this._onDidChangeSession.event;
    this.logService.info("[PukuAuthService] Initializing");
    this._register(this.urlService.registerHandler(this));
  }
  get session() {
    return this._session;
  }
  isAuthenticated() {
    return !!this._session;
  }
  getSessionToken() {
    return this._session?.sessionToken;
  }
  /**
   * Handle URI callback from OAuth flow
   * URI format: puku://Puku.puku-editor/auth/callback?token=xxx
   */
  async handleURL(uri) {
    this.logService.info("[PukuAuthService] Received URI callback:", uri.toString());
    if (uri.authority.toLowerCase() !== "puku.puku-editor" || uri.path !== "/auth/callback") {
      return false;
    }
    let params = new URLSearchParams(uri.query);
    let token = params.get("token");
    this.logService.info("[PukuAuthService] First try - token:", token ? "found" : "null");
    if (!token) {
      try {
        const decodedQuery = decodeURIComponent(uri.query);
        this.logService.info("[PukuAuthService] Decoded query:", decodedQuery);
        params = new URLSearchParams(decodedQuery);
        token = params.get("token");
        this.logService.info("[PukuAuthService] Second try - token:", token ? "found" : "null");
      } catch {
        this.logService.error("[PukuAuthService] Failed to decode query string");
      }
    }
    if (!token) {
      this.logService.error("[PukuAuthService] No token in callback URI");
      if (this._pendingSignIn) {
        this._pendingSignIn.reject(new Error("No token received from OAuth flow"));
        this._pendingSignIn = void 0;
      }
      return true;
    }
    try {
      const userInfo = await this.validateSessionAndGetUser(token);
      this._session = {
        user: userInfo,
        sessionToken: token,
        createdAt: Date.now()
      };
      this.storageService.store(
        PUKU_SESSION_TOKEN_KEY,
        token,
        -1,
        1
        /* StorageTarget.MACHINE */
      );
      this.storageService.store(
        PUKU_USER_KEY,
        JSON.stringify(userInfo),
        -1,
        1
        /* StorageTarget.MACHINE */
      );
      this.logService.info("[PukuAuthService] Authenticated as", userInfo.email);
      this._onDidChangeSession.fire(this._session);
      if (this._pendingSignIn) {
        const authSession = {
          id: `puku-${userInfo.id}`,
          accessToken: token,
          account: {
            id: userInfo.id,
            label: userInfo.email
          },
          scopes: ["openid", "email", "profile"]
        };
        this._pendingSignIn.resolve(authSession);
        this._pendingSignIn = void 0;
      }
      if (this._signInTimeout) {
        clearTimeout(this._signInTimeout);
        this._signInTimeout = void 0;
      }
    } catch (error) {
      this.logService.error("[PukuAuthService] Error after OAuth callback:", error);
      if (this._pendingSignIn) {
        this._pendingSignIn.reject(error);
        this._pendingSignIn = void 0;
      }
    }
    return true;
  }
  /**
   * Validate session token and get user info from Puku API
   */
  async validateSessionAndGetUser(sessionToken) {
    const response = await this.requestService.request({
      type: "GET",
      url: `${PUKU_API_BASE}/auth/session`,
      headers: {
        "Authorization": `Bearer ${sessionToken}`,
        "Content-Type": "application/json"
      }
    }, CancellationToken.None);
    if (!response.res.statusCode || response.res.statusCode !== 200) {
      throw new Error(`Failed to validate session: ${response.res.statusCode}`);
    }
    const responseText = await asText(response);
    if (!responseText) {
      throw new Error("Empty response from session validation");
    }
    return JSON.parse(responseText);
  }
  /**
   * Sign in with Google via Puku API
   */
  async signInWithGoogle() {
    this.logService.info("[PukuAuthService] Starting Google OAuth sign-in");
    const signInPromise = new Promise((resolve2, reject) => {
      this._pendingSignIn = { resolve: resolve2, reject };
    });
    this._signInTimeout = setTimeout(() => {
      if (this._pendingSignIn) {
        this._pendingSignIn.reject(new Error("Sign-in timed out"));
        this._pendingSignIn = void 0;
      }
    }, 5 * 60 * 1e3);
    try {
      const authUrl = `${PUKU_API_BASE}/auth/google`;
      await this.openerService.open(URI.parse(authUrl), { openExternal: true });
      const session = await signInPromise;
      return session;
    } catch (error) {
      this.logService.error("[PukuAuthService] Sign-in error:", error);
      throw error;
    } finally {
      if (this._signInTimeout) {
        clearTimeout(this._signInTimeout);
        this._signInTimeout = void 0;
      }
    }
  }
  /**
   * Sign out from Puku
   */
  async signOut() {
    this.logService.info("[PukuAuthService] Signing out");
    if (this._session?.sessionToken) {
      try {
        await this.requestService.request({
          type: "POST",
          url: `${PUKU_API_BASE}/auth/logout`,
          headers: {
            "Authorization": `Bearer ${this._session.sessionToken}`,
            "Content-Type": "application/json"
          }
        }, CancellationToken.None);
      } catch {
      }
    }
    this._session = void 0;
    this.storageService.remove(
      PUKU_SESSION_TOKEN_KEY,
      -1
      /* StorageScope.APPLICATION */
    );
    this.storageService.remove(
      PUKU_USER_KEY,
      -1
      /* StorageScope.APPLICATION */
    );
    this._onDidChangeSession.fire(void 0);
  }
  /**
   * Initialize - restore session from storage
   */
  async initialize() {
    this.logService.info("[PukuAuthService] Initializing");
    try {
      const storedToken = this.storageService.get(
        PUKU_SESSION_TOKEN_KEY,
        -1
        /* StorageScope.APPLICATION */
      );
      const storedUserJson = this.storageService.get(
        PUKU_USER_KEY,
        -1
        /* StorageScope.APPLICATION */
      );
      if (storedToken && storedUserJson) {
        this.logService.info("[PukuAuthService] Found stored session, validating...");
        try {
          const userInfo = await this.validateSessionAndGetUser(storedToken);
          this._session = {
            user: userInfo,
            sessionToken: storedToken,
            createdAt: Date.now()
          };
          this.storageService.store(
            PUKU_USER_KEY,
            JSON.stringify(userInfo),
            -1,
            1
            /* StorageTarget.MACHINE */
          );
          this.logService.info("[PukuAuthService] Session restored for", userInfo.email);
          this._onDidChangeSession.fire(this._session);
        } catch (error) {
          this.logService.info("[PukuAuthService] Stored session is invalid, clearing");
          this.storageService.remove(
            PUKU_SESSION_TOKEN_KEY,
            -1
            /* StorageScope.APPLICATION */
          );
          this.storageService.remove(
            PUKU_USER_KEY,
            -1
            /* StorageScope.APPLICATION */
          );
        }
      }
    } catch (error) {
      this.logService.error("[PukuAuthService] Error during initialization:", error);
    }
  }
  dispose() {
    if (this._signInTimeout) {
      clearTimeout(this._signInTimeout);
    }
    super.dispose();
  }
};
PukuAuthService = __decorate([
  __param(0, ILogService),
  __param(1, IOpenerService),
  __param(2, IStorageService),
  __param(3, IURLService),
  __param(4, IRequestService)
], PukuAuthService);
registerSingleton(
  IPukuAuthService,
  PukuAuthService,
  0
  /* InstantiationType.Eager */
);

// out-build/vs/workbench/services/lifecycle/common/lifecycle.js
var ILifecycleService = createDecorator("lifecycleService");
var WillShutdownJoinerOrder;
(function(WillShutdownJoinerOrder2) {
  WillShutdownJoinerOrder2[WillShutdownJoinerOrder2["Default"] = 1] = "Default";
  WillShutdownJoinerOrder2[WillShutdownJoinerOrder2["Last"] = 2] = "Last";
})(WillShutdownJoinerOrder || (WillShutdownJoinerOrder = {}));
var ShutdownReason;
(function(ShutdownReason2) {
  ShutdownReason2[ShutdownReason2["CLOSE"] = 1] = "CLOSE";
  ShutdownReason2[ShutdownReason2["QUIT"] = 2] = "QUIT";
  ShutdownReason2[ShutdownReason2["RELOAD"] = 3] = "RELOAD";
  ShutdownReason2[ShutdownReason2["LOAD"] = 4] = "LOAD";
})(ShutdownReason || (ShutdownReason = {}));
var StartupKind;
(function(StartupKind2) {
  StartupKind2[StartupKind2["NewWindow"] = 1] = "NewWindow";
  StartupKind2[StartupKind2["ReloadedWindow"] = 3] = "ReloadedWindow";
  StartupKind2[StartupKind2["ReopenedWindow"] = 4] = "ReopenedWindow";
})(StartupKind || (StartupKind = {}));
var LifecyclePhase;
(function(LifecyclePhase2) {
  LifecyclePhase2[LifecyclePhase2["Starting"] = 1] = "Starting";
  LifecyclePhase2[LifecyclePhase2["Ready"] = 2] = "Ready";
  LifecyclePhase2[LifecyclePhase2["Restored"] = 3] = "Restored";
  LifecyclePhase2[LifecyclePhase2["Eventually"] = 4] = "Eventually";
})(LifecyclePhase || (LifecyclePhase = {}));

// out-build/vs/workbench/services/chat/common/chatEntitlementService.js
var ChatEntitlementRequests_1;
var ChatEntitlementContext_1;
var ChatEntitlementContextKeys;
(function(ChatEntitlementContextKeys2) {
  ChatEntitlementContextKeys2.Setup = {
    hidden: new RawContextKey("chatSetupHidden", false, true),
    // True when chat setup is explicitly hidden.
    installed: new RawContextKey("chatSetupInstalled", false, true),
    // True when the chat extension is installed and enabled.
    disabled: new RawContextKey("chatSetupDisabled", false, true),
    // True when the chat extension is disabled due to any other reason than workspace trust.
    untrusted: new RawContextKey("chatSetupUntrusted", false, true),
    // True when the chat extension is disabled due to workspace trust.
    later: new RawContextKey("chatSetupLater", false, true),
    // True when the user wants to finish setup later.
    registered: new RawContextKey("chatSetupRegistered", false, true)
    // True when the user has registered as Free or Pro user.
  };
  ChatEntitlementContextKeys2.Entitlement = {
    signedOut: new RawContextKey("chatEntitlementSignedOut", false, true),
    // True when user is signed out.
    canSignUp: new RawContextKey("chatPlanCanSignUp", false, true),
    // True when user can sign up to be a chat free user.
    planFree: new RawContextKey("chatPlanFree", false, true),
    // True when user is a chat free user.
    planPro: new RawContextKey("chatPlanPro", false, true),
    // True when user is a chat pro user.
    planProPlus: new RawContextKey("chatPlanProPlus", false, true),
    // True when user is a chat pro plus user.
    planBusiness: new RawContextKey("chatPlanBusiness", false, true),
    // True when user is a chat business user.
    planEnterprise: new RawContextKey("chatPlanEnterprise", false, true),
    // True when user is a chat enterprise user.
    organisations: new RawContextKey("chatEntitlementOrganisations", void 0, true),
    // The organizations the user belongs to.
    internal: new RawContextKey("chatEntitlementInternal", false, true),
    // True when user belongs to internal organisation.
    sku: new RawContextKey("chatEntitlementSku", void 0, true)
    // The SKU of the user.
  };
  ChatEntitlementContextKeys2.chatQuotaExceeded = new RawContextKey("chatQuotaExceeded", false, true);
  ChatEntitlementContextKeys2.completionsQuotaExceeded = new RawContextKey("completionsQuotaExceeded", false, true);
  ChatEntitlementContextKeys2.chatAnonymous = new RawContextKey("chatAnonymous", false, true);
})(ChatEntitlementContextKeys || (ChatEntitlementContextKeys = {}));
var IChatEntitlementService = createDecorator("chatEntitlementService");
var ChatEntitlement;
(function(ChatEntitlement2) {
  ChatEntitlement2[ChatEntitlement2["Unknown"] = 1] = "Unknown";
  ChatEntitlement2[ChatEntitlement2["Unresolved"] = 2] = "Unresolved";
  ChatEntitlement2[ChatEntitlement2["Available"] = 3] = "Available";
  ChatEntitlement2[ChatEntitlement2["Unavailable"] = 4] = "Unavailable";
  ChatEntitlement2[ChatEntitlement2["Free"] = 5] = "Free";
  ChatEntitlement2[ChatEntitlement2["Pro"] = 6] = "Pro";
  ChatEntitlement2[ChatEntitlement2["ProPlus"] = 7] = "ProPlus";
  ChatEntitlement2[ChatEntitlement2["Business"] = 8] = "Business";
  ChatEntitlement2[ChatEntitlement2["Enterprise"] = 9] = "Enterprise";
})(ChatEntitlement || (ChatEntitlement = {}));
function isProUser(chatEntitlement) {
  return chatEntitlement === ChatEntitlement.Pro || chatEntitlement === ChatEntitlement.ProPlus || chatEntitlement === ChatEntitlement.Business || chatEntitlement === ChatEntitlement.Enterprise;
}
var defaultChat = {
  extensionId: product_default.defaultChatAgent?.extensionId ?? "",
  chatExtensionId: product_default.defaultChatAgent?.chatExtensionId ?? "",
  upgradePlanUrl: product_default.defaultChatAgent?.upgradePlanUrl ?? "",
  provider: product_default.defaultChatAgent?.provider ?? { default: { id: "" }, enterprise: { id: "" } },
  providerUriSetting: product_default.defaultChatAgent?.providerUriSetting ?? "",
  providerScopes: product_default.defaultChatAgent?.providerScopes ?? [[]],
  entitlementUrl: product_default.defaultChatAgent?.entitlementUrl ?? "",
  entitlementSignupLimitedUrl: product_default.defaultChatAgent?.entitlementSignupLimitedUrl ?? "",
  completionsAdvancedSetting: product_default.defaultChatAgent?.completionsAdvancedSetting ?? "",
  chatQuotaExceededContext: product_default.defaultChatAgent?.chatQuotaExceededContext ?? "",
  completionsQuotaExceededContext: product_default.defaultChatAgent?.completionsQuotaExceededContext ?? ""
};
var CHAT_ALLOW_ANONYMOUS_CONFIGURATION_KEY = "chat.allowAnonymousAccess";
function isAnonymous(configurationService, entitlement, sentiment) {
  if (configurationService.getValue(CHAT_ALLOW_ANONYMOUS_CONFIGURATION_KEY) !== true) {
    return false;
  }
  if (entitlement !== ChatEntitlement.Unknown) {
    return false;
  }
  if (sentiment.hidden || sentiment.disabled) {
    return false;
  }
  return true;
}
function logChatEntitlements(state, configurationService, telemetryService) {
  telemetryService.publicLog2("chatEntitlements", {
    chatHidden: Boolean(state.hidden),
    chatDisabled: Boolean(state.disabled),
    chatEntitlement: state.entitlement,
    chatRegistered: Boolean(state.registered),
    chatAnonymous: isAnonymous(configurationService, state.entitlement, state)
  });
}
var ChatEntitlementService = class ChatEntitlementService2 extends Disposable {
  constructor(instantiationService, productService, environmentService, contextKeyService, configurationService, telemetryService, lifecycleService, pukuAuthService, logService) {
    super();
    this.contextKeyService = contextKeyService;
    this.configurationService = configurationService;
    this.telemetryService = telemetryService;
    this.lifecycleService = lifecycleService;
    this.pukuAuthService = pukuAuthService;
    this.logService = logService;
    this._onDidChangeQuotaExceeded = this._register(new Emitter());
    this.onDidChangeQuotaExceeded = this._onDidChangeQuotaExceeded.event;
    this._onDidChangeQuotaRemaining = this._register(new Emitter());
    this.onDidChangeQuotaRemaining = this._onDidChangeQuotaRemaining.event;
    this._quotas = {};
    this.ExtensionQuotaContextKeys = {
      chatQuotaExceeded: defaultChat.chatQuotaExceededContext,
      completionsQuotaExceeded: defaultChat.completionsQuotaExceededContext
    };
    this._onDidChangeAnonymous = this._register(new Emitter());
    this.onDidChangeAnonymous = this._onDidChangeAnonymous.event;
    this.anonymousObs = observableFromEvent(this.onDidChangeAnonymous, () => this.anonymous);
    this.chatQuotaExceededContextKey = ChatEntitlementContextKeys.chatQuotaExceeded.bindTo(this.contextKeyService);
    this.completionsQuotaExceededContextKey = ChatEntitlementContextKeys.completionsQuotaExceeded.bindTo(this.contextKeyService);
    this.anonymousContextKey = ChatEntitlementContextKeys.chatAnonymous.bindTo(this.contextKeyService);
    this.anonymousContextKey.set(this.anonymous);
    this.onDidChangeEntitlement = Event.map(Event.filter(this.contextKeyService.onDidChangeContext, (e) => e.affectsSome(/* @__PURE__ */ new Set([
      ChatEntitlementContextKeys.Entitlement.planPro.key,
      ChatEntitlementContextKeys.Entitlement.planBusiness.key,
      ChatEntitlementContextKeys.Entitlement.planEnterprise.key,
      ChatEntitlementContextKeys.Entitlement.planProPlus.key,
      ChatEntitlementContextKeys.Entitlement.planFree.key,
      ChatEntitlementContextKeys.Entitlement.canSignUp.key,
      ChatEntitlementContextKeys.Entitlement.signedOut.key,
      ChatEntitlementContextKeys.Entitlement.organisations.key,
      ChatEntitlementContextKeys.Entitlement.internal.key,
      ChatEntitlementContextKeys.Entitlement.sku.key
    ])), this._store), () => {
    }, this._store);
    this.entitlementObs = observableFromEvent(this.onDidChangeEntitlement, () => this.entitlement);
    this.onDidChangeSentiment = Event.map(Event.filter(this.contextKeyService.onDidChangeContext, (e) => e.affectsSome(/* @__PURE__ */ new Set([
      ChatEntitlementContextKeys.Setup.hidden.key,
      ChatEntitlementContextKeys.Setup.disabled.key,
      ChatEntitlementContextKeys.Setup.untrusted.key,
      ChatEntitlementContextKeys.Setup.installed.key,
      ChatEntitlementContextKeys.Setup.later.key,
      ChatEntitlementContextKeys.Setup.registered.key
    ])), this._store), () => {
    }, this._store);
    this.sentimentObs = observableFromEvent(this.onDidChangeSentiment, () => this.sentiment);
    if (
      // TODO@bpasero remove this condition and 'serverlessWebEnabled' once Chat web support lands
      isWeb && !environmentService.remoteAuthority && !configurationService.getValue("chat.experimental.serverlessWebEnabled")
    ) {
      ChatEntitlementContextKeys.Setup.hidden.bindTo(this.contextKeyService).set(true);
      return;
    }
    if (!productService.defaultChatAgent) {
      return;
    }
    const context = this.context = new Lazy(() => this._register(instantiationService.createInstance(ChatEntitlementContext)));
    this.requests = new Lazy(() => this._register(instantiationService.createInstance(ChatEntitlementRequests, context.value, {
      clearQuotas: () => this.clearQuotas(),
      acceptQuotas: (quotas) => this.acceptQuotas(quotas)
    })));
    this.registerListeners();
  }
  get entitlement() {
    if (this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.planPro.key) === true) {
      return ChatEntitlement.Pro;
    } else if (this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.planBusiness.key) === true) {
      return ChatEntitlement.Business;
    } else if (this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.planEnterprise.key) === true) {
      return ChatEntitlement.Enterprise;
    } else if (this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.planProPlus.key) === true) {
      return ChatEntitlement.ProPlus;
    } else if (this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.planFree.key) === true) {
      return ChatEntitlement.Free;
    } else if (this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.canSignUp.key) === true) {
      return ChatEntitlement.Available;
    } else if (this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.signedOut.key) === true) {
      return ChatEntitlement.Unknown;
    }
    return ChatEntitlement.Unresolved;
  }
  get isInternal() {
    return this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.internal.key) === true;
  }
  get organisations() {
    return this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.organisations.key);
  }
  get sku() {
    return this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Entitlement.sku.key);
  }
  get quotas() {
    return this._quotas;
  }
  registerListeners() {
    const quotaExceededSet = /* @__PURE__ */ new Set([this.ExtensionQuotaContextKeys.chatQuotaExceeded, this.ExtensionQuotaContextKeys.completionsQuotaExceeded]);
    const cts = this._register(new MutableDisposable());
    this._register(this.contextKeyService.onDidChangeContext((e) => {
      if (e.affectsSome(quotaExceededSet)) {
        if (cts.value) {
          cts.value.cancel();
        }
        cts.value = new CancellationTokenSource();
        this.update(cts.value.token);
      }
    }));
    let anonymousUsage = this.anonymous;
    const updateAnonymousUsage = () => {
      const newAnonymousUsage = this.anonymous;
      if (newAnonymousUsage !== anonymousUsage) {
        anonymousUsage = newAnonymousUsage;
        this.anonymousContextKey.set(newAnonymousUsage);
        if (this.context?.hasValue) {
          logChatEntitlements(this.context.value.state, this.configurationService, this.telemetryService);
        }
        this._onDidChangeAnonymous.fire();
      }
    };
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(CHAT_ALLOW_ANONYMOUS_CONFIGURATION_KEY)) {
        updateAnonymousUsage();
      }
    }));
    this._register(this.onDidChangeEntitlement(() => updateAnonymousUsage()));
    this._register(this.onDidChangeSentiment(() => updateAnonymousUsage()));
    this.lifecycleService.when(
      4
      /* LifecyclePhase.Eventually */
    ).then(() => {
      if (this.context?.hasValue) {
        logChatEntitlements(this.context.value.state, this.configurationService, this.telemetryService);
      }
    });
    this._register(this.pukuAuthService.onDidChangeSession((session) => {
      this.logService.info("[chat entitlement] Puku session changed:", session?.user?.email ?? "signed out");
      if (session) {
        this.context?.value.update({ entitlement: ChatEntitlement.Free, organisations: void 0, sku: "puku-free" });
        this.requests?.value.fetchPukuQuotas().catch((err) => {
          this.logService.error("[chat entitlement] Error fetching Puku quotas:", err);
        });
      } else {
        this.context?.value.update({ entitlement: ChatEntitlement.Unknown, organisations: void 0, sku: void 0 });
      }
    }));
    if (this.pukuAuthService.isAuthenticated()) {
      this.logService.info("[chat entitlement] Puku already authenticated:", this.pukuAuthService.session?.user?.email);
      this.context?.value.update({ entitlement: ChatEntitlement.Free, organisations: void 0, sku: "puku-free" });
      this.requests?.value.fetchPukuQuotas().catch((err) => {
        this.logService.error("[chat entitlement] Error fetching Puku quotas:", err);
      });
    }
  }
  acceptQuotas(quotas) {
    const oldQuota = this._quotas;
    this._quotas = quotas;
    this.updateContextKeys();
    const { changed: chatChanged } = this.compareQuotas(oldQuota.chat, quotas.chat);
    const { changed: completionsChanged } = this.compareQuotas(oldQuota.completions, quotas.completions);
    const { changed: premiumChatChanged } = this.compareQuotas(oldQuota.premiumChat, quotas.premiumChat);
    if (chatChanged.exceeded || completionsChanged.exceeded || premiumChatChanged.exceeded) {
      this._onDidChangeQuotaExceeded.fire();
    }
    if (chatChanged.remaining || completionsChanged.remaining || premiumChatChanged.remaining) {
      this._onDidChangeQuotaRemaining.fire();
    }
  }
  compareQuotas(oldQuota, newQuota) {
    return {
      changed: {
        exceeded: oldQuota?.percentRemaining === 0 !== (newQuota?.percentRemaining === 0),
        remaining: oldQuota?.percentRemaining !== newQuota?.percentRemaining
      }
    };
  }
  clearQuotas() {
    this.acceptQuotas({});
  }
  updateContextKeys() {
    this.chatQuotaExceededContextKey.set(this._quotas.chat?.percentRemaining === 0);
    this.completionsQuotaExceededContextKey.set(this._quotas.completions?.percentRemaining === 0);
  }
  get sentiment() {
    return {
      installed: this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Setup.installed.key) === true,
      hidden: this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Setup.hidden.key) === true,
      disabled: this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Setup.disabled.key) === true,
      untrusted: this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Setup.untrusted.key) === true,
      later: this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Setup.later.key) === true,
      registered: this.contextKeyService.getContextKeyValue(ChatEntitlementContextKeys.Setup.registered.key) === true
    };
  }
  get anonymous() {
    return isAnonymous(this.configurationService, this.entitlement, this.sentiment);
  }
  //#endregion
  async update(token) {
    await this.requests?.value.forceResolveEntitlement(void 0, token);
  }
};
ChatEntitlementService = __decorate([
  __param(0, IInstantiationService),
  __param(1, IProductService),
  __param(2, IWorkbenchEnvironmentService),
  __param(3, IContextKeyService),
  __param(4, IConfigurationService),
  __param(5, ITelemetryService),
  __param(6, ILifecycleService),
  __param(7, IPukuAuthService),
  __param(8, ILogService)
], ChatEntitlementService);
var ChatEntitlementRequests = ChatEntitlementRequests_1 = class ChatEntitlementRequests2 extends Disposable {
  static providerId(configurationService) {
    if (configurationService.getValue(`${defaultChat.completionsAdvancedSetting}.authProvider`) === defaultChat.provider.enterprise.id) {
      return defaultChat.provider.enterprise.id;
    }
    return defaultChat.provider.default.id;
  }
  constructor(context, chatQuotasAccessor, telemetryService, authenticationService, logService, requestService, dialogService, openerService, configurationService, authenticationExtensionsService, lifecycleService, pukuAuthService, commandService) {
    super();
    this.context = context;
    this.chatQuotasAccessor = chatQuotasAccessor;
    this.telemetryService = telemetryService;
    this.authenticationService = authenticationService;
    this.logService = logService;
    this.requestService = requestService;
    this.dialogService = dialogService;
    this.openerService = openerService;
    this.configurationService = configurationService;
    this.authenticationExtensionsService = authenticationExtensionsService;
    this.lifecycleService = lifecycleService;
    this.pukuAuthService = pukuAuthService;
    this.commandService = commandService;
    this.pendingResolveCts = new CancellationTokenSource();
    this.didResolveEntitlements = false;
    this.state = { entitlement: this.context.state.entitlement };
    this.registerListeners();
    this.resolve();
  }
  registerListeners() {
    this._register(this.authenticationService.onDidChangeDeclaredProviders(() => this.resolve()));
    this._register(this.authenticationService.onDidChangeSessions((e) => {
      if (e.providerId === ChatEntitlementRequests_1.providerId(this.configurationService)) {
        this.resolve();
      }
    }));
    this._register(this.authenticationService.onDidRegisterAuthenticationProvider((e) => {
      if (e.id === ChatEntitlementRequests_1.providerId(this.configurationService)) {
        this.resolve();
      }
    }));
    this._register(this.authenticationService.onDidUnregisterAuthenticationProvider((e) => {
      if (e.id === ChatEntitlementRequests_1.providerId(this.configurationService)) {
        this.resolve();
      }
    }));
    this._register(this.context.onDidChange(() => {
      if (!this.context.state.installed || this.context.state.disabled || this.context.state.entitlement === ChatEntitlement.Unknown) {
        this.state = { entitlement: this.state.entitlement, quotas: void 0 };
        this.chatQuotasAccessor.clearQuotas();
      }
    }));
  }
  async resolve() {
    this.pendingResolveCts.dispose(true);
    const cts = this.pendingResolveCts = new CancellationTokenSource();
    if (this.pukuAuthService.isAuthenticated()) {
      this.logService.info("[chat entitlement] Using Puku authentication, skipping GitHub session lookup");
      return;
    }
    const session = await this.findMatchingProviderSession(cts.token);
    if (cts.token.isCancellationRequested) {
      return;
    }
    let state = void 0;
    if (session) {
      if (this.state.entitlement === ChatEntitlement.Unknown) {
        state = { entitlement: ChatEntitlement.Unresolved };
      }
    } else {
      this.didResolveEntitlements = false;
      state = { entitlement: ChatEntitlement.Unknown };
    }
    if (state) {
      this.update(state);
    }
    if (session && !this.didResolveEntitlements) {
      await this.resolveEntitlement(session, cts.token);
    }
  }
  async findMatchingProviderSession(token) {
    if (this.pukuAuthService.isAuthenticated()) {
      this.logService.info("[chat entitlement] findMatchingProviderSession: Puku authenticated, returning empty");
      return void 0;
    }
    const sessions = await this.doGetSessions(ChatEntitlementRequests_1.providerId(this.configurationService));
    if (token.isCancellationRequested) {
      return void 0;
    }
    const matchingSessions = /* @__PURE__ */ new Set();
    for (const session of sessions) {
      for (const scopes of defaultChat.providerScopes) {
        if (this.includesScopes(session.scopes, scopes)) {
          matchingSessions.add(session);
        }
      }
    }
    return matchingSessions.size > 0 ? Array.from(matchingSessions) : void 0;
  }
  async doGetSessions(providerId) {
    const preferredAccountName = this.authenticationExtensionsService.getAccountPreference(defaultChat.chatExtensionId, providerId) ?? this.authenticationExtensionsService.getAccountPreference(defaultChat.extensionId, providerId);
    let preferredAccount;
    for (const account of await this.authenticationService.getAccounts(providerId)) {
      if (account.label === preferredAccountName) {
        preferredAccount = account;
        break;
      }
    }
    try {
      return await this.authenticationService.getSessions(providerId, void 0, { account: preferredAccount });
    } catch (error) {
    }
    return [];
  }
  includesScopes(scopes, expectedScopes) {
    return expectedScopes.every((scope) => scopes.includes(scope));
  }
  async resolveEntitlement(sessions, token) {
    const entitlements = await this.doResolveEntitlement(sessions, token);
    if (typeof entitlements?.entitlement === "number" && !token.isCancellationRequested) {
      this.didResolveEntitlements = true;
      this.update(entitlements);
    }
    return entitlements;
  }
  async doResolveEntitlement(sessions, token) {
    if (token.isCancellationRequested) {
      return void 0;
    }
    const response = await this.request(this.getEntitlementUrl(), "GET", void 0, sessions, token);
    if (token.isCancellationRequested) {
      return void 0;
    }
    if (!response) {
      this.logService.trace("[chat entitlement]: no response");
      return { entitlement: ChatEntitlement.Unresolved };
    }
    if (response.res.statusCode && response.res.statusCode !== 200) {
      this.logService.trace(`[chat entitlement]: unexpected status code ${response.res.statusCode}`);
      return response.res.statusCode === 401 || // oauth token being unavailable (expired/revoked)
      response.res.statusCode === 404 ? {
        entitlement: ChatEntitlement.Unknown
        /* treat as signed out */
      } : { entitlement: ChatEntitlement.Unresolved };
    }
    let responseText = null;
    try {
      responseText = await asText(response);
    } catch (error) {
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    if (!responseText) {
      this.logService.trace("[chat entitlement]: response has no content");
      return { entitlement: ChatEntitlement.Unresolved };
    }
    let entitlementsResponse;
    try {
      entitlementsResponse = JSON.parse(responseText);
      this.logService.trace(`[chat entitlement]: parsed result is ${JSON.stringify(entitlementsResponse)}`);
    } catch (err) {
      this.logService.trace(`[chat entitlement]: error parsing response (${err})`);
      return { entitlement: ChatEntitlement.Unresolved };
    }
    let entitlement;
    if (entitlementsResponse.access_type_sku === "free_limited_copilot") {
      entitlement = ChatEntitlement.Free;
    } else if (entitlementsResponse.can_signup_for_limited) {
      entitlement = ChatEntitlement.Available;
    } else if (entitlementsResponse.copilot_plan === "individual") {
      entitlement = ChatEntitlement.Pro;
    } else if (entitlementsResponse.copilot_plan === "individual_pro") {
      entitlement = ChatEntitlement.ProPlus;
    } else if (entitlementsResponse.copilot_plan === "business") {
      entitlement = ChatEntitlement.Business;
    } else if (entitlementsResponse.copilot_plan === "enterprise") {
      entitlement = ChatEntitlement.Enterprise;
    } else if (entitlementsResponse.chat_enabled) {
      entitlement = ChatEntitlement.Pro;
    } else {
      entitlement = ChatEntitlement.Unavailable;
    }
    const entitlements = {
      entitlement,
      organisations: entitlementsResponse.organization_login_list,
      quotas: this.toQuotas(entitlementsResponse),
      sku: entitlementsResponse.access_type_sku
    };
    this.logService.trace(`[chat entitlement]: resolved to ${entitlements.entitlement}, quotas: ${JSON.stringify(entitlements.quotas)}`);
    this.telemetryService.publicLog2("chatInstallEntitlement", {
      entitlement: entitlements.entitlement,
      tid: entitlementsResponse.analytics_tracking_id,
      sku: entitlements.sku,
      quotaChat: entitlements.quotas?.chat?.remaining,
      quotaPremiumChat: entitlements.quotas?.premiumChat?.remaining,
      quotaCompletions: entitlements.quotas?.completions?.remaining,
      quotaResetDate: entitlements.quotas?.resetDate
    });
    return entitlements;
  }
  getEntitlementUrl() {
    if (ChatEntitlementRequests_1.providerId(this.configurationService) === defaultChat.provider.enterprise.id) {
      try {
        const enterpriseUrl = new URL(this.configurationService.getValue(defaultChat.providerUriSetting));
        return `${enterpriseUrl.protocol}//api.${enterpriseUrl.hostname}${enterpriseUrl.port ? ":" + enterpriseUrl.port : ""}/copilot_internal/user`;
      } catch (error) {
        this.logService.error(error);
      }
    }
    return defaultChat.entitlementUrl;
  }
  toQuotas(response) {
    const quotas = {
      resetDate: response.quota_reset_date_utc ?? response.quota_reset_date ?? response.limited_user_reset_date,
      resetDateHasTime: typeof response.quota_reset_date_utc === "string"
    };
    if (response.monthly_quotas?.chat && typeof response.limited_user_quotas?.chat === "number") {
      quotas.chat = {
        total: response.monthly_quotas.chat,
        remaining: response.limited_user_quotas.chat,
        percentRemaining: Math.min(100, Math.max(0, response.limited_user_quotas.chat / response.monthly_quotas.chat * 100)),
        overageEnabled: false,
        overageCount: 0,
        unlimited: false
      };
    }
    if (response.monthly_quotas?.completions && typeof response.limited_user_quotas?.completions === "number") {
      quotas.completions = {
        total: response.monthly_quotas.completions,
        remaining: response.limited_user_quotas.completions,
        percentRemaining: Math.min(100, Math.max(0, response.limited_user_quotas.completions / response.monthly_quotas.completions * 100)),
        overageEnabled: false,
        overageCount: 0,
        unlimited: false
      };
    }
    if (response.quota_snapshots) {
      for (const quotaType of ["chat", "completions", "premium_interactions"]) {
        const rawQuotaSnapshot = response.quota_snapshots[quotaType];
        if (!rawQuotaSnapshot) {
          continue;
        }
        const quotaSnapshot = {
          total: rawQuotaSnapshot.entitlement,
          remaining: rawQuotaSnapshot.remaining,
          percentRemaining: Math.min(100, Math.max(0, rawQuotaSnapshot.percent_remaining)),
          overageEnabled: rawQuotaSnapshot.overage_permitted,
          overageCount: rawQuotaSnapshot.overage_count,
          unlimited: rawQuotaSnapshot.unlimited
        };
        switch (quotaType) {
          case "chat":
            quotas.chat = quotaSnapshot;
            break;
          case "completions":
            quotas.completions = quotaSnapshot;
            break;
          case "premium_interactions":
            quotas.premiumChat = quotaSnapshot;
            break;
        }
      }
    }
    return quotas;
  }
  /**
   * Fetch usage quotas from Puku API
   */
  async fetchPukuQuotas() {
    const sessionToken = this.pukuAuthService.getSessionToken();
    if (!sessionToken) {
      this.logService.warn("[chat entitlement] No Puku session token available");
      return;
    }
    try {
      this.logService.info("[chat entitlement] Fetching quotas from Puku API");
      const response = await this.requestService.request({
        type: "GET",
        url: "https://api.puku.sh/puku/v1/usage",
        headers: {
          "Authorization": `Bearer ${sessionToken}`,
          "Content-Type": "application/json"
        }
      }, CancellationToken.None);
      if (!response.res.statusCode || response.res.statusCode !== 200) {
        this.logService.warn(`[chat entitlement] Puku usage endpoint returned ${response.res.statusCode}`);
        return;
      }
      const responseText = await asText(response);
      if (!responseText) {
        this.logService.warn("[chat entitlement] Empty response from Puku usage endpoint");
        return;
      }
      const usageData = JSON.parse(responseText);
      this.logService.info("[chat entitlement] Puku usage data:", JSON.stringify(usageData));
      if (usageData.quotas) {
        this.chatQuotasAccessor.acceptQuotas(usageData.quotas);
        this.logService.info("[chat entitlement] Updated quotas from Puku API");
      }
    } catch (error) {
      this.logService.error("[chat entitlement] Error fetching Puku quotas:", error);
    }
  }
  async request(url, type, body, sessions, token) {
    let lastRequest;
    for (const session of sessions) {
      if (token.isCancellationRequested) {
        return lastRequest;
      }
      try {
        const response = await this.requestService.request({
          type,
          url,
          data: type === "POST" ? JSON.stringify(body) : void 0,
          disableCache: true,
          headers: {
            "Authorization": `Bearer ${session.accessToken}`
          }
        }, token);
        const status = response.res.statusCode;
        if (status && status !== 200) {
          lastRequest = response;
          continue;
        }
        return response;
      } catch (error) {
        if (!token.isCancellationRequested) {
          this.logService.error(`[chat entitlement] request: error ${error}`);
        }
      }
    }
    return lastRequest;
  }
  update(state) {
    this.state = state;
    this.context.update({ entitlement: this.state.entitlement, organisations: this.state.organisations, sku: this.state.sku });
    if (state.quotas) {
      this.chatQuotasAccessor.acceptQuotas(state.quotas);
    }
  }
  async forceResolveEntitlement(sessions, token = CancellationToken.None) {
    if (this.pukuAuthService.isAuthenticated()) {
      this.logService.info("[chat entitlement] forceResolveEntitlement: Using Puku authentication, skipping GitHub");
      return void 0;
    }
    if (!sessions) {
      sessions = await this.findMatchingProviderSession(token);
    }
    if (!sessions || sessions.length === 0) {
      return void 0;
    }
    return this.resolveEntitlement(sessions, token);
  }
  async signUpFree(sessions) {
    const body = {
      restricted_telemetry: this.telemetryService.telemetryLevel === 0 ? "disabled" : "enabled",
      public_code_suggestions: "enabled"
    };
    const response = await this.request(defaultChat.entitlementSignupLimitedUrl, "POST", body, sessions, CancellationToken.None);
    if (!response) {
      const retry = await this.onUnknownSignUpError(localize(15095, null), "[chat entitlement] sign-up: no response");
      return retry ? this.signUpFree(sessions) : { errorCode: 1 };
    }
    if (response.res.statusCode && response.res.statusCode !== 200) {
      if (response.res.statusCode === 422) {
        try {
          const responseText2 = await asText(response);
          if (responseText2) {
            const responseError = JSON.parse(responseText2);
            if (typeof responseError.message === "string" && responseError.message) {
              this.onUnprocessableSignUpError(`[chat entitlement] sign-up: unprocessable entity (${responseError.message})`, responseError.message);
              return { errorCode: response.res.statusCode };
            }
          }
        } catch (error) {
        }
      }
      const retry = await this.onUnknownSignUpError(localize(15096, null, response.res.statusCode), `[chat entitlement] sign-up: unexpected status code ${response.res.statusCode}`);
      return retry ? this.signUpFree(sessions) : { errorCode: response.res.statusCode };
    }
    let responseText = null;
    try {
      responseText = await asText(response);
    } catch (error) {
    }
    if (!responseText) {
      const retry = await this.onUnknownSignUpError(localize(15097, null), "[chat entitlement] sign-up: response has no content");
      return retry ? this.signUpFree(sessions) : { errorCode: 2 };
    }
    let parsedResult = void 0;
    try {
      parsedResult = JSON.parse(responseText);
      this.logService.trace(`[chat entitlement] sign-up: response is ${responseText}`);
    } catch (err) {
      const retry = await this.onUnknownSignUpError(localize(15098, null), `[chat entitlement] sign-up: error parsing response (${err})`);
      return retry ? this.signUpFree(sessions) : { errorCode: 3 };
    }
    this.update({ entitlement: ChatEntitlement.Free });
    return Boolean(parsedResult?.subscribed);
  }
  async onUnknownSignUpError(detail, logMessage) {
    this.logService.error(logMessage);
    if (!this.lifecycleService.willShutdown) {
      const { confirmed } = await this.dialogService.confirm({
        type: severity_default.Error,
        message: localize(15099, null),
        detail,
        primaryButton: localize(15100, null)
      });
      return confirmed;
    }
    return false;
  }
  onUnprocessableSignUpError(logMessage, logDetails) {
    this.logService.error(logMessage);
    if (!this.lifecycleService.willShutdown) {
      this.dialogService.prompt({
        type: severity_default.Error,
        message: localize(15101, null),
        detail: logDetails,
        buttons: [
          {
            label: localize(15102, null),
            run: () => {
            }
          },
          {
            label: localize(15103, null),
            run: () => this.openerService.open(URI.parse(defaultChat.upgradePlanUrl))
          }
        ]
      });
    }
  }
  async signIn(options2) {
    if (options2?.useSocialProvider === "google") {
      this.logService.info("[chat entitlement] Using Puku auth for Google sign-in");
      const session2 = await this.pukuAuthService.signInWithGoogle();
      const entitlements2 = { entitlement: ChatEntitlement.Free, organisations: void 0, sku: void 0 };
      this.update(entitlements2);
      try {
        await this.commandService.executeCommand("_puku.refreshAuth");
        this.logService.info("[chat entitlement] Notified extension layer of auth change");
      } catch (error) {
        this.logService.trace("[chat entitlement] Extension notification skipped (extension may not be loaded yet)");
      }
      return { session: session2, entitlements: entitlements2 };
    }
    const providerId = ChatEntitlementRequests_1.providerId(this.configurationService);
    let defaultProviderScopes;
    if (this.configurationService.getValue("chat.signInWithAlternateScopes") === true) {
      defaultProviderScopes = defaultChat.providerScopes.at(-1) ?? [];
    } else {
      defaultProviderScopes = defaultChat.providerScopes.at(0) ?? [];
    }
    const scopes = options2?.additionalScopes ? distinct([...defaultProviderScopes, ...options2.additionalScopes]) : defaultProviderScopes;
    const session = await this.authenticationService.createSession(providerId, scopes, {
      extraAuthorizeParameters: { get_started_with: "copilot-vscode" },
      provider: options2?.useSocialProvider
    });
    this.authenticationExtensionsService.updateAccountPreference(defaultChat.extensionId, providerId, session.account);
    this.authenticationExtensionsService.updateAccountPreference(defaultChat.chatExtensionId, providerId, session.account);
    const entitlements = await this.forceResolveEntitlement([session]);
    return { session, entitlements };
  }
  dispose() {
    this.pendingResolveCts.dispose(true);
    super.dispose();
  }
};
ChatEntitlementRequests = ChatEntitlementRequests_1 = __decorate([
  __param(2, ITelemetryService),
  __param(3, IAuthenticationService),
  __param(4, ILogService),
  __param(5, IRequestService),
  __param(6, IDialogService),
  __param(7, IOpenerService),
  __param(8, IConfigurationService),
  __param(9, IAuthenticationExtensionsService),
  __param(10, ILifecycleService),
  __param(11, IPukuAuthService),
  __param(12, ICommandService)
], ChatEntitlementRequests);
var ChatEntitlementContext = class ChatEntitlementContext2 extends Disposable {
  static {
    ChatEntitlementContext_1 = this;
  }
  static {
    this.CHAT_ENTITLEMENT_CONTEXT_STORAGE_KEY = "chat.setupContext";
  }
  static {
    this.CHAT_DISABLED_CONFIGURATION_KEY = "chat.disableAIFeatures";
  }
  get state() {
    return this.withConfiguration(this.suspendedState ?? this._state);
  }
  constructor(contextKeyService, storageService, logService, configurationService, telemetryService) {
    super();
    this.storageService = storageService;
    this.logService = logService;
    this.configurationService = configurationService;
    this.telemetryService = telemetryService;
    this.suspendedState = void 0;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.updateBarrier = void 0;
    this.canSignUpContextKey = ChatEntitlementContextKeys.Entitlement.canSignUp.bindTo(contextKeyService);
    this.signedOutContextKey = ChatEntitlementContextKeys.Entitlement.signedOut.bindTo(contextKeyService);
    this.freeContextKey = ChatEntitlementContextKeys.Entitlement.planFree.bindTo(contextKeyService);
    this.proContextKey = ChatEntitlementContextKeys.Entitlement.planPro.bindTo(contextKeyService);
    this.proPlusContextKey = ChatEntitlementContextKeys.Entitlement.planProPlus.bindTo(contextKeyService);
    this.businessContextKey = ChatEntitlementContextKeys.Entitlement.planBusiness.bindTo(contextKeyService);
    this.enterpriseContextKey = ChatEntitlementContextKeys.Entitlement.planEnterprise.bindTo(contextKeyService);
    this.organisationsContextKey = ChatEntitlementContextKeys.Entitlement.organisations.bindTo(contextKeyService);
    this.isInternalContextKey = ChatEntitlementContextKeys.Entitlement.internal.bindTo(contextKeyService);
    this.skuContextKey = ChatEntitlementContextKeys.Entitlement.sku.bindTo(contextKeyService);
    this.hiddenContext = ChatEntitlementContextKeys.Setup.hidden.bindTo(contextKeyService);
    this.laterContext = ChatEntitlementContextKeys.Setup.later.bindTo(contextKeyService);
    this.installedContext = ChatEntitlementContextKeys.Setup.installed.bindTo(contextKeyService);
    this.disabledContext = ChatEntitlementContextKeys.Setup.disabled.bindTo(contextKeyService);
    this.untrustedContext = ChatEntitlementContextKeys.Setup.untrusted.bindTo(contextKeyService);
    this.registeredContext = ChatEntitlementContextKeys.Setup.registered.bindTo(contextKeyService);
    this._state = this.storageService.getObject(
      ChatEntitlementContext_1.CHAT_ENTITLEMENT_CONTEXT_STORAGE_KEY,
      0
      /* StorageScope.PROFILE */
    ) ?? { entitlement: ChatEntitlement.Unknown, organisations: void 0, sku: void 0 };
    this.updateContextSync();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(ChatEntitlementContext_1.CHAT_DISABLED_CONFIGURATION_KEY)) {
        this.updateContext();
      }
    }));
  }
  withConfiguration(state) {
    if (this.configurationService.getValue(ChatEntitlementContext_1.CHAT_DISABLED_CONFIGURATION_KEY) === true) {
      return {
        ...state,
        hidden: true
        // Setting always wins: if AI is disabled, set `hidden: true`
      };
    }
    return state;
  }
  async update(context) {
    this.logService.trace(`[chat entitlement context] update(): ${JSON.stringify(context)}`);
    const oldState = JSON.stringify(this._state);
    if (typeof context.installed === "boolean" && typeof context.disabled === "boolean" && typeof context.untrusted === "boolean") {
      this._state.installed = context.installed;
      this._state.disabled = context.disabled;
      this._state.untrusted = context.untrusted;
      if (context.installed && !context.disabled) {
        context.hidden = false;
      }
    }
    if (typeof context.hidden === "boolean") {
      this._state.hidden = context.hidden;
    }
    if (typeof context.later === "boolean") {
      this._state.later = context.later;
    }
    if (typeof context.entitlement === "number") {
      this._state.entitlement = context.entitlement;
      this._state.organisations = context.organisations;
      this._state.sku = context.sku;
      if (this._state.entitlement === ChatEntitlement.Free || isProUser(this._state.entitlement)) {
        this._state.registered = true;
      } else if (this._state.entitlement === ChatEntitlement.Available) {
        this._state.registered = false;
      }
    }
    if (oldState === JSON.stringify(this._state)) {
      return;
    }
    this.storageService.store(
      ChatEntitlementContext_1.CHAT_ENTITLEMENT_CONTEXT_STORAGE_KEY,
      {
        ...this._state,
        later: void 0
        // do not persist this across restarts for now
      },
      0,
      1
      /* StorageTarget.MACHINE */
    );
    return this.updateContext();
  }
  async updateContext() {
    await this.updateBarrier?.wait();
    this.updateContextSync();
  }
  updateContextSync() {
    const state = this.withConfiguration(this._state);
    this.signedOutContextKey.set(state.entitlement === ChatEntitlement.Unknown);
    this.canSignUpContextKey.set(state.entitlement === ChatEntitlement.Available);
    this.freeContextKey.set(state.entitlement === ChatEntitlement.Free);
    this.proContextKey.set(state.entitlement === ChatEntitlement.Pro);
    this.proPlusContextKey.set(state.entitlement === ChatEntitlement.ProPlus);
    this.businessContextKey.set(state.entitlement === ChatEntitlement.Business);
    this.enterpriseContextKey.set(state.entitlement === ChatEntitlement.Enterprise);
    this.organisationsContextKey.set(state.organisations);
    this.isInternalContextKey.set(Boolean(state.organisations?.some((org) => org === "github" || org === "microsoft" || org === "ms-copilot" || org === "MicrosoftCopilot")));
    this.skuContextKey.set(state.sku);
    this.hiddenContext.set(!!state.hidden);
    this.laterContext.set(!!state.later);
    this.installedContext.set(!!state.installed);
    this.disabledContext.set(!!state.disabled);
    this.untrustedContext.set(!!state.untrusted);
    this.registeredContext.set(!!state.registered);
    this.logService.trace(`[chat entitlement context] updateContext(): ${JSON.stringify(state)}`);
    logChatEntitlements(state, this.configurationService, this.telemetryService);
    this._onDidChange.fire();
  }
  suspend() {
    this.suspendedState = { ...this._state };
    this.updateBarrier = new Barrier();
  }
  resume() {
    this.suspendedState = void 0;
    this.updateBarrier?.open();
    this.updateBarrier = void 0;
  }
};
ChatEntitlementContext = ChatEntitlementContext_1 = __decorate([
  __param(0, IContextKeyService),
  __param(1, IStorageService),
  __param(2, ILogService),
  __param(3, IConfigurationService),
  __param(4, ITelemetryService)
], ChatEntitlementContext);
registerSingleton(
  IChatEntitlementService,
  ChatEntitlementService,
  0
  /* InstantiationType.Eager */
);

// out-build/vs/workbench/contrib/chat/common/chatContextKeys.js
var ChatContextKeys;
(function(ChatContextKeys2) {
  ChatContextKeys2.responseVote = new RawContextKey("chatSessionResponseVote", "", { type: "string", description: localize(6359, null) });
  ChatContextKeys2.responseDetectedAgentCommand = new RawContextKey("chatSessionResponseDetectedAgentOrCommand", false, { type: "boolean", description: localize(6360, null) });
  ChatContextKeys2.responseSupportsIssueReporting = new RawContextKey("chatResponseSupportsIssueReporting", false, { type: "boolean", description: localize(6361, null) });
  ChatContextKeys2.responseIsFiltered = new RawContextKey("chatSessionResponseFiltered", false, { type: "boolean", description: localize(6362, null) });
  ChatContextKeys2.responseHasError = new RawContextKey("chatSessionResponseError", false, { type: "boolean", description: localize(6363, null) });
  ChatContextKeys2.requestInProgress = new RawContextKey("chatSessionRequestInProgress", false, { type: "boolean", description: localize(6364, null) });
  ChatContextKeys2.currentlyEditing = new RawContextKey("chatSessionCurrentlyEditing", false, { type: "boolean", description: localize(6365, null) });
  ChatContextKeys2.currentlyEditingInput = new RawContextKey("chatSessionCurrentlyEditingInput", false, { type: "boolean", description: localize(6366, null) });
  ChatContextKeys2.isResponse = new RawContextKey("chatResponse", false, { type: "boolean", description: localize(6367, null) });
  ChatContextKeys2.isRequest = new RawContextKey("chatRequest", false, { type: "boolean", description: localize(6368, null) });
  ChatContextKeys2.itemId = new RawContextKey("chatItemId", "", { type: "string", description: localize(6369, null) });
  ChatContextKeys2.lastItemId = new RawContextKey("chatLastItemId", [], { type: "string", description: localize(6370, null) });
  ChatContextKeys2.editApplied = new RawContextKey("chatEditApplied", false, { type: "boolean", description: localize(6371, null) });
  ChatContextKeys2.inputHasText = new RawContextKey("chatInputHasText", false, { type: "boolean", description: localize(6372, null) });
  ChatContextKeys2.inputHasFocus = new RawContextKey("chatInputHasFocus", false, { type: "boolean", description: localize(6373, null) });
  ChatContextKeys2.inChatInput = new RawContextKey("inChatInput", false, { type: "boolean", description: localize(6374, null) });
  ChatContextKeys2.inChatSession = new RawContextKey("inChat", false, { type: "boolean", description: localize(6375, null) });
  ChatContextKeys2.inChatEditor = new RawContextKey("inChatEditor", false, { type: "boolean", description: localize(6376, null) });
  ChatContextKeys2.inChatTerminalToolOutput = new RawContextKey("inChatTerminalToolOutput", false, { type: "boolean", description: localize(6377, null) });
  ChatContextKeys2.chatModeKind = new RawContextKey("chatAgentKind", ChatModeKind.Ask, { type: "string", description: localize(6378, null) });
  ChatContextKeys2.chatToolCount = new RawContextKey("chatToolCount", 0, { type: "number", description: localize(6379, null) });
  ChatContextKeys2.chatToolGroupingThreshold = new RawContextKey("chat.toolGroupingThreshold", 0, { type: "number", description: localize(6380, null) });
  ChatContextKeys2.supported = ContextKeyExpr.or(IsWebContext.negate(), RemoteNameContext.notEqualsTo(""), ContextKeyExpr.has("config.chat.experimental.serverlessWebEnabled"));
  ChatContextKeys2.enabled = new RawContextKey("chatIsEnabled", false, { type: "boolean", description: localize(6381, null) });
  ChatContextKeys2.lockedToCodingAgent = new RawContextKey("lockedToCodingAgent", false, { type: "boolean", description: localize(6382, null) });
  ChatContextKeys2.agentSupportsAttachments = new RawContextKey("agentSupportsAttachments", false, { type: "boolean", description: localize(6383, null) });
  ChatContextKeys2.withinEditSessionDiff = new RawContextKey("withinEditSessionDiff", false, { type: "boolean", description: localize(6384, null) });
  ChatContextKeys2.filePartOfEditSession = new RawContextKey("filePartOfEditSession", false, { type: "boolean", description: localize(6385, null) });
  ChatContextKeys2.extensionParticipantRegistered = new RawContextKey("chatPanelExtensionParticipantRegistered", false, { type: "boolean", description: localize(6386, null) });
  ChatContextKeys2.panelParticipantRegistered = new RawContextKey("chatPanelParticipantRegistered", false, { type: "boolean", description: localize(6387, null) });
  ChatContextKeys2.chatEditingCanUndo = new RawContextKey("chatEditingCanUndo", false, { type: "boolean", description: localize(6388, null) });
  ChatContextKeys2.chatEditingCanRedo = new RawContextKey("chatEditingCanRedo", false, { type: "boolean", description: localize(6389, null) });
  ChatContextKeys2.languageModelsAreUserSelectable = new RawContextKey("chatModelsAreUserSelectable", false, { type: "boolean", description: localize(6390, null) });
  ChatContextKeys2.chatSessionHasModels = new RawContextKey("chatSessionHasModels", false, { type: "boolean", description: localize(6391, null) });
  ChatContextKeys2.extensionInvalid = new RawContextKey("chatExtensionInvalid", false, { type: "boolean", description: localize(6392, null) });
  ChatContextKeys2.inputCursorAtTop = new RawContextKey("chatCursorAtTop", false);
  ChatContextKeys2.inputHasAgent = new RawContextKey("chatInputHasAgent", false);
  ChatContextKeys2.location = new RawContextKey("chatLocation", void 0);
  ChatContextKeys2.inQuickChat = new RawContextKey("quickChatHasFocus", false, { type: "boolean", description: localize(6393, null) });
  ChatContextKeys2.hasFileAttachments = new RawContextKey("chatHasFileAttachments", false, { type: "boolean", description: localize(6394, null) });
  ChatContextKeys2.remoteJobCreating = new RawContextKey("chatRemoteJobCreating", false, { type: "boolean", description: localize(6395, null) });
  ChatContextKeys2.hasRemoteCodingAgent = new RawContextKey("hasRemoteCodingAgent", false, localize(6396, null));
  ChatContextKeys2.enableRemoteCodingAgentPromptFileOverlay = new RawContextKey("enableRemoteCodingAgentPromptFileOverlay", false, localize(6397, null));
  ChatContextKeys2.skipChatRequestInProgressMessage = new RawContextKey("chatSkipRequestInProgressMessage", false, { type: "boolean", description: localize(6398, null) });
  ChatContextKeys2.Setup = ChatEntitlementContextKeys.Setup;
  ChatContextKeys2.Entitlement = ChatEntitlementContextKeys.Entitlement;
  ChatContextKeys2.chatQuotaExceeded = ChatEntitlementContextKeys.chatQuotaExceeded;
  ChatContextKeys2.completionsQuotaExceeded = ChatEntitlementContextKeys.completionsQuotaExceeded;
  ChatContextKeys2.Editing = {
    hasToolConfirmation: new RawContextKey("chatHasToolConfirmation", false, { type: "boolean", description: localize(6399, null) }),
    hasElicitationRequest: new RawContextKey("chatHasElicitationRequest", false, { type: "boolean", description: localize(6400, null) })
  };
  ChatContextKeys2.Tools = {
    toolsCount: new RawContextKey("toolsCount", 0, { type: "number", description: localize(6401, null) })
  };
  ChatContextKeys2.Modes = {
    hasCustomChatModes: new RawContextKey("chatHasCustomAgents", false, { type: "boolean", description: localize(6402, null) })
  };
  ChatContextKeys2.panelLocation = new RawContextKey("chatPanelLocation", void 0, { type: "number", description: localize(6403, null) });
  ChatContextKeys2.inEmptyStateWithHistoryEnabled = new RawContextKey("chatInEmptyStateWithHistoryEnabled", false, { type: "boolean", description: localize(6404, null) });
  ChatContextKeys2.sessionType = new RawContextKey("chatSessionType", "", { type: "string", description: localize(6405, null) });
  ChatContextKeys2.isArchivedItem = new RawContextKey("chatIsArchivedItem", false, { type: "boolean", description: localize(6406, null) });
  ChatContextKeys2.isActiveSession = new RawContextKey("chatIsActiveSession", false, { type: "boolean", description: localize(6407, null) });
  ChatContextKeys2.isKatexMathElement = new RawContextKey("chatIsKatexMathElement", false, { type: "boolean", description: localize(6408, null) });
})(ChatContextKeys || (ChatContextKeys = {}));
var ChatContextKeyExprs;
(function(ChatContextKeyExprs2) {
  ChatContextKeyExprs2.inEditingMode = ContextKeyExpr.or(ChatContextKeys.chatModeKind.isEqualTo(ChatModeKind.Edit), ChatContextKeys.chatModeKind.isEqualTo(ChatModeKind.Agent));
  ChatContextKeyExprs2.chatSetupTriggerContext = ContextKeyExpr.or(ChatContextKeys.Setup.installed.negate(), ChatContextKeys.Entitlement.canSignUp);
  ChatContextKeyExprs2.agentViewWhen = ContextKeyExpr.and(ChatEntitlementContextKeys.Setup.hidden.negate(), ChatEntitlementContextKeys.Setup.disabled.negate(), ContextKeyExpr.equals(`config.${ChatConfiguration.AgentSessionsViewLocation}`, "view"));
})(ChatContextKeyExprs || (ChatContextKeyExprs = {}));

// out-build/vs/workbench/contrib/chat/common/chatAgents.js
var ChatAgentNameService_1;
var IChatAgentService = createDecorator("chatAgentService");
var ChatAgentService = class ChatAgentService2 extends Disposable {
  static {
    this.AGENT_LEADER = "@";
  }
  constructor(contextKeyService, configurationService) {
    super();
    this.contextKeyService = contextKeyService;
    this.configurationService = configurationService;
    this._agents = /* @__PURE__ */ new Map();
    this._onDidChangeAgents = new Emitter();
    this.onDidChangeAgents = this._onDidChangeAgents.event;
    this._agentsContextKeys = /* @__PURE__ */ new Set();
    this._hasToolsAgent = false;
    this._chatParticipantDetectionProviders = /* @__PURE__ */ new Map();
    this._agentCompletionProviders = /* @__PURE__ */ new Map();
    this._hasDefaultAgent = ChatContextKeys.enabled.bindTo(this.contextKeyService);
    this._extensionAgentRegistered = ChatContextKeys.extensionParticipantRegistered.bindTo(this.contextKeyService);
    this._defaultAgentRegistered = ChatContextKeys.panelParticipantRegistered.bindTo(this.contextKeyService);
    this._register(contextKeyService.onDidChangeContext((e) => {
      if (e.affectsSome(this._agentsContextKeys)) {
        this._updateContextKeys();
      }
    }));
  }
  registerAgent(id2, data2) {
    const existingAgent = this.getAgent(id2);
    if (existingAgent) {
      throw new Error(`Agent already registered: ${JSON.stringify(id2)}`);
    }
    const that = this;
    const commands = data2.slashCommands;
    data2 = {
      ...data2,
      get slashCommands() {
        return commands.filter((c) => !c.when || that.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(c.when)));
      }
    };
    const entry = { data: data2 };
    this._agents.set(id2, entry);
    this._updateAgentsContextKeys();
    this._updateContextKeys();
    this._onDidChangeAgents.fire(void 0);
    return toDisposable(() => {
      this._agents.delete(id2);
      this._updateAgentsContextKeys();
      this._updateContextKeys();
      this._onDidChangeAgents.fire(void 0);
    });
  }
  _updateAgentsContextKeys() {
    this._agentsContextKeys.clear();
    for (const agent of this._agents.values()) {
      if (agent.data.when) {
        const expr = ContextKeyExpr.deserialize(agent.data.when);
        for (const key of expr?.keys() || []) {
          this._agentsContextKeys.add(key);
        }
      }
    }
  }
  _updateContextKeys() {
    let extensionAgentRegistered = false;
    let defaultAgentRegistered = false;
    let toolsAgentRegistered = false;
    for (const agent of this.getAgents()) {
      if (agent.isDefault) {
        if (!agent.isCore) {
          extensionAgentRegistered = true;
        }
        if (agent.id === "chat.setup" || agent.id === "github.copilot.editsAgent") {
          toolsAgentRegistered = true;
        } else {
          defaultAgentRegistered = true;
        }
      }
    }
    this._defaultAgentRegistered.set(defaultAgentRegistered);
    this._extensionAgentRegistered.set(extensionAgentRegistered);
    if (toolsAgentRegistered !== this._hasToolsAgent) {
      this._hasToolsAgent = toolsAgentRegistered;
      this._onDidChangeAgents.fire(this.getDefaultAgent(ChatAgentLocation.Chat, ChatModeKind.Agent));
    }
  }
  registerAgentImplementation(id2, agentImpl) {
    const entry = this._agents.get(id2);
    if (!entry) {
      throw new Error(`Unknown agent: ${JSON.stringify(id2)}`);
    }
    if (entry.impl) {
      throw new Error(`Agent already has implementation: ${JSON.stringify(id2)}`);
    }
    if (entry.data.isDefault) {
      this._hasDefaultAgent.set(true);
    }
    entry.impl = agentImpl;
    this._onDidChangeAgents.fire(new MergedChatAgent(entry.data, agentImpl));
    return toDisposable(() => {
      entry.impl = void 0;
      this._onDidChangeAgents.fire(void 0);
      if (entry.data.isDefault) {
        this._hasDefaultAgent.set(Iterable.some(this._agents.values(), (agent) => agent.data.isDefault));
      }
    });
  }
  registerDynamicAgent(data2, agentImpl) {
    data2.isDynamic = true;
    const agent = { data: data2, impl: agentImpl };
    this._agents.set(data2.id, agent);
    this._onDidChangeAgents.fire(new MergedChatAgent(data2, agentImpl));
    return toDisposable(() => {
      this._agents.delete(data2.id);
      this._onDidChangeAgents.fire(void 0);
    });
  }
  registerAgentCompletionProvider(id2, provider) {
    this._agentCompletionProviders.set(id2, provider);
    return {
      dispose: () => {
        this._agentCompletionProviders.delete(id2);
      }
    };
  }
  async getAgentCompletionItems(id2, query, token) {
    return await this._agentCompletionProviders.get(id2)?.(query, token) ?? [];
  }
  updateAgent(id2, updateMetadata) {
    const agent = this._agents.get(id2);
    if (!agent?.impl) {
      throw new Error(`No activated agent with id ${JSON.stringify(id2)} registered`);
    }
    agent.data.metadata = { ...agent.data.metadata, ...updateMetadata };
    this._onDidChangeAgents.fire(new MergedChatAgent(agent.data, agent.impl));
  }
  getDefaultAgent(location2, mode = ChatModeKind.Ask) {
    return this._preferExtensionAgent(this.getActivatedAgents().filter((a) => {
      if (mode && !a.modes.includes(mode)) {
        return false;
      }
      return !!a.isDefault && a.locations.includes(location2);
    }));
  }
  get hasToolsAgent() {
    return !!this.configurationService.getValue(ChatConfiguration.AgentEnabled);
  }
  getContributedDefaultAgent(location2) {
    return this._preferExtensionAgent(this.getAgents().filter((a) => !!a.isDefault && a.locations.includes(location2)));
  }
  _preferExtensionAgent(agents) {
    return findLast(agents, (agent) => !agent.isCore) ?? agents.at(-1);
  }
  getAgent(id2, includeDisabled = false) {
    if (!this._agentIsEnabled(id2) && !includeDisabled) {
      return;
    }
    return this._agents.get(id2)?.data;
  }
  _agentIsEnabled(idOrAgent) {
    const entry = typeof idOrAgent === "string" ? this._agents.get(idOrAgent) : idOrAgent;
    return !entry?.data.when || this.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(entry.data.when));
  }
  getAgentByFullyQualifiedId(id2) {
    const agent = Iterable.find(this._agents.values(), (a) => getFullyQualifiedId(a.data) === id2)?.data;
    if (agent && !this._agentIsEnabled(agent.id)) {
      return;
    }
    return agent;
  }
  /**
   * Returns all agent datas that exist- static registered and dynamic ones.
   */
  getAgents() {
    return Array.from(this._agents.values()).map((entry) => entry.data).filter((a) => this._agentIsEnabled(a.id));
  }
  getActivatedAgents() {
    return Array.from(this._agents.values()).filter((a) => !!a.impl).filter((a) => this._agentIsEnabled(a.data.id)).map((a) => new MergedChatAgent(a.data, a.impl));
  }
  getAgentsByName(name2) {
    return this._preferExtensionAgents(this.getAgents().filter((a) => a.name === name2));
  }
  _preferExtensionAgents(agents) {
    const extensionAgents = agents.filter((a) => !a.isCore);
    return extensionAgents.length > 0 ? extensionAgents : agents;
  }
  agentHasDupeName(id2) {
    const agent = this.getAgent(id2);
    if (!agent) {
      return false;
    }
    return this.getAgentsByName(agent.name).filter((a) => a.extensionId.value !== agent.extensionId.value).length > 0;
  }
  async invokeAgent(id2, request, progress, history, token) {
    const data2 = this._agents.get(id2);
    if (!data2?.impl) {
      throw new Error(`No activated agent with id "${id2}"`);
    }
    return await data2.impl.invoke(request, progress, history, token);
  }
  setRequestTools(id2, requestId, tools) {
    const data2 = this._agents.get(id2);
    if (!data2?.impl) {
      throw new Error(`No activated agent with id "${id2}"`);
    }
    data2.impl.setRequestTools?.(requestId, tools);
  }
  async getFollowups(id2, request, result, history, token) {
    const data2 = this._agents.get(id2);
    if (!data2?.impl?.provideFollowups) {
      return [];
    }
    return data2.impl.provideFollowups(request, result, history, token);
  }
  async getChatTitle(id2, history, token) {
    const data2 = this._agents.get(id2);
    if (!data2?.impl?.provideChatTitle) {
      return void 0;
    }
    return data2.impl.provideChatTitle(history, token);
  }
  async getChatSummary(id2, history, token) {
    const data2 = this._agents.get(id2);
    if (!data2?.impl?.provideChatSummary) {
      return void 0;
    }
    return data2.impl.provideChatSummary(history, token);
  }
  registerChatParticipantDetectionProvider(handle, provider) {
    this._chatParticipantDetectionProviders.set(handle, provider);
    return toDisposable(() => {
      this._chatParticipantDetectionProviders.delete(handle);
    });
  }
  hasChatParticipantDetectionProviders() {
    return this._chatParticipantDetectionProviders.size > 0;
  }
  async detectAgentOrCommand(request, history, options2, token) {
    const provider = Iterable.first(this._chatParticipantDetectionProviders.values());
    if (!provider) {
      return;
    }
    const participants = this.getAgents().reduce((acc, a) => {
      if (a.locations.includes(options2.location)) {
        acc.push({ participant: a.id, disambiguation: a.disambiguation ?? [] });
        for (const command2 of a.slashCommands) {
          acc.push({ participant: a.id, command: command2.name, disambiguation: command2.disambiguation ?? [] });
        }
      }
      return acc;
    }, []);
    const result = await provider.provideParticipantDetection(request, history, { ...options2, participants }, token);
    if (!result) {
      return;
    }
    const agent = this.getAgent(result.participant);
    if (!agent) {
      return;
    }
    if (!result.command) {
      return { agent };
    }
    const command = agent?.slashCommands.find((c) => c.name === result.command);
    if (!command) {
      return;
    }
    return { agent, command };
  }
};
ChatAgentService = __decorate([
  __param(0, IContextKeyService),
  __param(1, IConfigurationService)
], ChatAgentService);
var MergedChatAgent = class {
  constructor(data2, impl) {
    this.data = data2;
    this.impl = impl;
  }
  get id() {
    return this.data.id;
  }
  get name() {
    return this.data.name ?? "";
  }
  get fullName() {
    return this.data.fullName ?? "";
  }
  get description() {
    return this.data.description ?? "";
  }
  get extensionId() {
    return this.data.extensionId;
  }
  get extensionVersion() {
    return this.data.extensionVersion;
  }
  get extensionPublisherId() {
    return this.data.extensionPublisherId;
  }
  get extensionPublisherDisplayName() {
    return this.data.publisherDisplayName;
  }
  get extensionDisplayName() {
    return this.data.extensionDisplayName;
  }
  get isDefault() {
    return this.data.isDefault;
  }
  get isCore() {
    return this.data.isCore;
  }
  get metadata() {
    return this.data.metadata;
  }
  get slashCommands() {
    return this.data.slashCommands;
  }
  get locations() {
    return this.data.locations;
  }
  get modes() {
    return this.data.modes;
  }
  get disambiguation() {
    return this.data.disambiguation;
  }
  async invoke(request, progress, history, token) {
    return this.impl.invoke(request, progress, history, token);
  }
  setRequestTools(requestId, tools) {
    this.impl.setRequestTools?.(requestId, tools);
  }
  async provideFollowups(request, result, history, token) {
    if (this.impl.provideFollowups) {
      return this.impl.provideFollowups(request, result, history, token);
    }
    return [];
  }
  toJSON() {
    return this.data;
  }
};
var IChatAgentNameService = createDecorator("chatAgentNameService");
var ChatAgentNameService = class ChatAgentNameService2 {
  static {
    ChatAgentNameService_1 = this;
  }
  static {
    this.StorageKey = "chat.participantNameRegistry";
  }
  constructor(productService, requestService, logService, storageService) {
    this.requestService = requestService;
    this.logService = logService;
    this.storageService = storageService;
    this.registry = observableValue(this, /* @__PURE__ */ Object.create(null));
    this.disposed = false;
    if (!productService.chatParticipantRegistry) {
      return;
    }
    this.url = productService.chatParticipantRegistry;
    const raw = storageService.get(
      ChatAgentNameService_1.StorageKey,
      -1
      /* StorageScope.APPLICATION */
    );
    try {
      this.registry.set(JSON.parse(raw ?? "{}"), void 0);
    } catch (err) {
      storageService.remove(
        ChatAgentNameService_1.StorageKey,
        -1
        /* StorageScope.APPLICATION */
      );
    }
    this.refresh();
  }
  refresh() {
    if (this.disposed) {
      return;
    }
    this.update().catch((err) => this.logService.warn("Failed to fetch chat participant registry", err)).then(() => timeout(5 * 60 * 1e3)).then(() => this.refresh());
  }
  async update() {
    const context = await this.requestService.request({ type: "GET", url: this.url }, CancellationToken.None);
    if (context.res.statusCode !== 200) {
      throw new Error("Could not get extensions report.");
    }
    const result = await asJson(context);
    if (!result || result.version !== 1) {
      throw new Error("Unexpected chat participant registry response.");
    }
    const registry = result.restrictedChatParticipants;
    this.registry.set(registry, void 0);
    this.storageService.store(
      ChatAgentNameService_1.StorageKey,
      JSON.stringify(registry),
      -1,
      1
      /* StorageTarget.MACHINE */
    );
  }
  /**
   * Returns true if the agent is allowed to use this name
   */
  getAgentNameRestriction(chatAgentData) {
    if (chatAgentData.isCore) {
      return true;
    }
    const nameAllowed = this.checkAgentNameRestriction(chatAgentData.name, chatAgentData).get();
    const fullNameAllowed = !chatAgentData.fullName || this.checkAgentNameRestriction(chatAgentData.fullName.replace(/\s/g, ""), chatAgentData).get();
    return nameAllowed && fullNameAllowed;
  }
  checkAgentNameRestriction(name2, chatAgentData) {
    const allowList = this.registry.map((registry) => registry[name2.toLowerCase()]);
    return allowList.map((allowList2) => {
      if (!allowList2) {
        return true;
      }
      return allowList2.some((id2) => equalsIgnoreCase(id2, id2.includes(".") ? chatAgentData.extensionId.value : chatAgentData.extensionPublisherId));
    });
  }
  dispose() {
    this.disposed = true;
  }
};
ChatAgentNameService = ChatAgentNameService_1 = __decorate([
  __param(0, IProductService),
  __param(1, IRequestService),
  __param(2, ILogService),
  __param(3, IStorageService)
], ChatAgentNameService);
function getFullyQualifiedId(chatAgentData) {
  return `${chatAgentData.extensionId.value}.${chatAgentData.id}`;
}

// out-build/vs/workbench/contrib/chat/common/promptSyntax/service/promptsService.js
var IPromptsService = createDecorator("IPromptsService");
var PromptsStorage;
(function(PromptsStorage2) {
  PromptsStorage2["local"] = "local";
  PromptsStorage2["user"] = "user";
  PromptsStorage2["extension"] = "extension";
})(PromptsStorage || (PromptsStorage = {}));

// out-build/vs/workbench/contrib/chat/common/chatModes.js
var ChatModeService_1;
var IChatModeService = createDecorator("chatModeService");
var ChatModeService = class ChatModeService2 extends Disposable {
  static {
    ChatModeService_1 = this;
  }
  static {
    this.CUSTOM_MODES_STORAGE_KEY = "chat.customModes";
  }
  constructor(promptsService, chatAgentService, contextKeyService, logService, storageService) {
    super();
    this.promptsService = promptsService;
    this.chatAgentService = chatAgentService;
    this.logService = logService;
    this.storageService = storageService;
    this._customModeInstances = /* @__PURE__ */ new Map();
    this._onDidChangeChatModes = new Emitter();
    this.onDidChangeChatModes = this._onDidChangeChatModes.event;
    this.hasCustomModes = ChatContextKeys.Modes.hasCustomChatModes.bindTo(contextKeyService);
    this.loadCachedModes();
    void this.refreshCustomPromptModes(true);
    this._register(this.promptsService.onDidChangeCustomAgents(() => {
      void this.refreshCustomPromptModes(true);
    }));
    this._register(this.storageService.onWillSaveState(() => this.saveCachedModes()));
    let didHaveToolsAgent = this.chatAgentService.hasToolsAgent;
    this._register(this.chatAgentService.onDidChangeAgents(() => {
      if (didHaveToolsAgent !== this.chatAgentService.hasToolsAgent) {
        didHaveToolsAgent = this.chatAgentService.hasToolsAgent;
        this._onDidChangeChatModes.fire();
      }
    }));
  }
  loadCachedModes() {
    try {
      const cachedCustomModes = this.storageService.getObject(
        ChatModeService_1.CUSTOM_MODES_STORAGE_KEY,
        1
        /* StorageScope.WORKSPACE */
      );
      if (cachedCustomModes) {
        this.deserializeCachedModes(cachedCustomModes);
      }
    } catch (error) {
      this.logService.error(error, "Failed to load cached custom agents");
    }
  }
  deserializeCachedModes(cachedCustomModes) {
    if (!Array.isArray(cachedCustomModes)) {
      this.logService.error("Invalid cached custom modes data: expected array");
      return;
    }
    for (const cachedMode of cachedCustomModes) {
      if (isCachedChatModeData(cachedMode) && cachedMode.uri) {
        try {
          const uri = URI.revive(cachedMode.uri);
          const customChatMode = {
            uri,
            name: cachedMode.name,
            description: cachedMode.description,
            tools: cachedMode.customTools,
            model: cachedMode.model,
            argumentHint: cachedMode.argumentHint,
            agentInstructions: cachedMode.modeInstructions ?? { content: cachedMode.body ?? "", toolReferences: [] },
            handOffs: cachedMode.handOffs,
            target: cachedMode.target,
            source: reviveChatModeSource(cachedMode.source) ?? { storage: PromptsStorage.local }
          };
          const instance = new CustomChatMode(customChatMode);
          this._customModeInstances.set(uri.toString(), instance);
        } catch (error) {
          this.logService.error(error, "Failed to revive cached custom agent");
        }
      }
    }
    this.hasCustomModes.set(this._customModeInstances.size > 0);
  }
  saveCachedModes() {
    try {
      const modesToCache = Array.from(this._customModeInstances.values());
      this.storageService.store(
        ChatModeService_1.CUSTOM_MODES_STORAGE_KEY,
        modesToCache,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    } catch (error) {
      this.logService.warn("Failed to save cached custom agents", error);
    }
  }
  async refreshCustomPromptModes(fireChangeEvent) {
    try {
      const customModes = await this.promptsService.getCustomAgents(CancellationToken.None);
      const seenUris = /* @__PURE__ */ new Set();
      for (const customMode of customModes) {
        const uriString = customMode.uri.toString();
        seenUris.add(uriString);
        let modeInstance = this._customModeInstances.get(uriString);
        if (modeInstance) {
          modeInstance.updateData(customMode);
        } else {
          modeInstance = new CustomChatMode(customMode);
          this._customModeInstances.set(uriString, modeInstance);
        }
      }
      for (const [uriString] of this._customModeInstances.entries()) {
        if (!seenUris.has(uriString)) {
          this._customModeInstances.delete(uriString);
        }
      }
      this.hasCustomModes.set(this._customModeInstances.size > 0);
    } catch (error) {
      this.logService.error(error, "Failed to load custom agents");
      this._customModeInstances.clear();
      this.hasCustomModes.set(false);
    }
    if (fireChangeEvent) {
      this._onDidChangeChatModes.fire();
    }
  }
  getModes() {
    return {
      builtin: this.getBuiltinModes(),
      custom: this.getCustomModes()
    };
  }
  findModeById(id2) {
    return this.getBuiltinModes().find((mode) => mode.id === id2) ?? this._customModeInstances.get(id2);
  }
  findModeByName(name2) {
    return this.getBuiltinModes().find((mode) => mode.name.get() === name2) ?? this.getCustomModes().find((mode) => mode.name.get() === name2);
  }
  getBuiltinModes() {
    const builtinModes = [
      ChatMode.Ask
    ];
    if (this.chatAgentService.hasToolsAgent) {
      builtinModes.unshift(ChatMode.Agent);
    }
    builtinModes.push(ChatMode.Edit);
    return builtinModes;
  }
  getCustomModes() {
    return this.chatAgentService.hasToolsAgent ? Array.from(this._customModeInstances.values()) : [];
  }
};
ChatModeService = ChatModeService_1 = __decorate([
  __param(0, IPromptsService),
  __param(1, IChatAgentService),
  __param(2, IContextKeyService),
  __param(3, ILogService),
  __param(4, IStorageService)
], ChatModeService);
function isCachedChatModeData(data2) {
  if (typeof data2 !== "object" || data2 === null) {
    return false;
  }
  const mode = data2;
  return typeof mode.id === "string" && typeof mode.name === "string" && typeof mode.kind === "string" && (mode.description === void 0 || typeof mode.description === "string") && (mode.customTools === void 0 || Array.isArray(mode.customTools)) && (mode.modeInstructions === void 0 || typeof mode.modeInstructions === "object" && mode.modeInstructions !== null) && (mode.model === void 0 || typeof mode.model === "string") && (mode.argumentHint === void 0 || typeof mode.argumentHint === "string") && (mode.handOffs === void 0 || Array.isArray(mode.handOffs)) && (mode.uri === void 0 || typeof mode.uri === "object" && mode.uri !== null) && (mode.source === void 0 || isChatModeSourceData(mode.source)) && (mode.target === void 0 || typeof mode.target === "string");
}
var CustomChatMode = class {
  get name() {
    return this._nameObservable;
  }
  get description() {
    return this._descriptionObservable;
  }
  get isBuiltin() {
    return isBuiltinChatMode(this);
  }
  get customTools() {
    return this._customToolsObservable;
  }
  get model() {
    return this._modelObservable;
  }
  get argumentHint() {
    return this._argumentHintObservable;
  }
  get modeInstructions() {
    return this._modeInstructions;
  }
  get uri() {
    return this._uriObservable;
  }
  get label() {
    return this.name;
  }
  get handOffs() {
    return this._handoffsObservable;
  }
  get source() {
    return this._source;
  }
  get target() {
    return this._targetObservable;
  }
  constructor(customChatMode) {
    this.kind = ChatModeKind.Agent;
    this.id = customChatMode.uri.toString();
    this._nameObservable = observableValue("name", customChatMode.name);
    this._descriptionObservable = observableValue("description", customChatMode.description);
    this._customToolsObservable = observableValue("customTools", customChatMode.tools);
    this._modelObservable = observableValue("model", customChatMode.model);
    this._argumentHintObservable = observableValue("argumentHint", customChatMode.argumentHint);
    this._handoffsObservable = observableValue("handOffs", customChatMode.handOffs);
    this._targetObservable = observableValue("target", customChatMode.target);
    this._modeInstructions = observableValue("_modeInstructions", customChatMode.agentInstructions);
    this._uriObservable = observableValue("uri", customChatMode.uri);
    this._source = customChatMode.source;
  }
  /**
   * Updates the underlying data and triggers observable changes
   */
  updateData(newData) {
    transaction((tx) => {
      this._nameObservable.set(newData.name, tx);
      this._descriptionObservable.set(newData.description, tx);
      this._customToolsObservable.set(newData.tools, tx);
      this._modelObservable.set(newData.model, tx);
      this._argumentHintObservable.set(newData.argumentHint, tx);
      this._handoffsObservable.set(newData.handOffs, tx);
      this._targetObservable.set(newData.target, tx);
      this._modeInstructions.set(newData.agentInstructions, tx);
      this._uriObservable.set(newData.uri, tx);
      this._source = newData.source;
    });
  }
  toJSON() {
    return {
      id: this.id,
      name: this.name.get(),
      description: this.description.get(),
      kind: this.kind,
      customTools: this.customTools.get(),
      model: this.model.get(),
      argumentHint: this.argumentHint.get(),
      modeInstructions: this.modeInstructions.get(),
      uri: this.uri.get(),
      handOffs: this.handOffs.get(),
      source: serializeChatModeSource(this._source),
      target: this.target.get()
    };
  }
};
function isChatModeSourceData(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const data2 = value;
  if (data2.storage === PromptsStorage.extension) {
    return typeof data2.extensionId === "string";
  }
  return data2.storage === PromptsStorage.local || data2.storage === PromptsStorage.user;
}
function serializeChatModeSource(source) {
  if (!source) {
    return void 0;
  }
  if (source.storage === PromptsStorage.extension) {
    return { storage: PromptsStorage.extension, extensionId: source.extensionId.value };
  }
  return { storage: source.storage };
}
function reviveChatModeSource(data2) {
  if (!data2) {
    return void 0;
  }
  if (data2.storage === PromptsStorage.extension) {
    return { storage: PromptsStorage.extension, extensionId: new ExtensionIdentifier(data2.extensionId) };
  }
  return { storage: data2.storage };
}
var BuiltinChatMode = class {
  constructor(kind, label, description) {
    this.kind = kind;
    this.name = constObservable(kind);
    this.label = constObservable(label);
    this.description = observableValue("description", description);
  }
  get isBuiltin() {
    return isBuiltinChatMode(this);
  }
  get id() {
    return this.kind;
  }
  get target() {
    return observableValue("target", void 0);
  }
  /**
   * Getters are not json-stringified
   */
  toJSON() {
    return {
      id: this.id,
      name: this.name.get(),
      description: this.description.get(),
      kind: this.kind
    };
  }
};
var ChatMode;
(function(ChatMode2) {
  ChatMode2.Ask = new BuiltinChatMode(ChatModeKind.Ask, "Ask", localize(6416, null));
  ChatMode2.Edit = new BuiltinChatMode(ChatModeKind.Edit, "Edit", localize(6417, null));
  ChatMode2.Agent = new BuiltinChatMode(ChatModeKind.Agent, "Agent", localize(6418, null));
})(ChatMode || (ChatMode = {}));
function isBuiltinChatMode(mode) {
  return mode.id === ChatMode.Ask.id || mode.id === ChatMode.Edit.id || mode.id === ChatMode.Agent.id;
}

// out-build/vs/workbench/contrib/chat/common/languageModels.js
var ChatMessageRole;
(function(ChatMessageRole2) {
  ChatMessageRole2[ChatMessageRole2["System"] = 0] = "System";
  ChatMessageRole2[ChatMessageRole2["User"] = 1] = "User";
  ChatMessageRole2[ChatMessageRole2["Assistant"] = 2] = "Assistant";
})(ChatMessageRole || (ChatMessageRole = {}));
var LanguageModelPartAudience2;
(function(LanguageModelPartAudience3) {
  LanguageModelPartAudience3[LanguageModelPartAudience3["Assistant"] = 0] = "Assistant";
  LanguageModelPartAudience3[LanguageModelPartAudience3["User"] = 1] = "User";
  LanguageModelPartAudience3[LanguageModelPartAudience3["Extension"] = 2] = "Extension";
})(LanguageModelPartAudience2 || (LanguageModelPartAudience2 = {}));
var ChatImageMimeType2;
(function(ChatImageMimeType3) {
  ChatImageMimeType3["PNG"] = "image/png";
  ChatImageMimeType3["JPEG"] = "image/jpeg";
  ChatImageMimeType3["GIF"] = "image/gif";
  ChatImageMimeType3["WEBP"] = "image/webp";
  ChatImageMimeType3["BMP"] = "image/bmp";
})(ChatImageMimeType2 || (ChatImageMimeType2 = {}));
var ImageDetailLevel;
(function(ImageDetailLevel2) {
  ImageDetailLevel2["Low"] = "low";
  ImageDetailLevel2["High"] = "high";
})(ImageDetailLevel || (ImageDetailLevel = {}));
var ILanguageModelChatMetadata;
(function(ILanguageModelChatMetadata2) {
  function suitableForAgentMode(metadata) {
    const supportsToolsAgent = typeof metadata.capabilities?.agentMode === "undefined" || metadata.capabilities.agentMode;
    return supportsToolsAgent && !!metadata.capabilities?.toolCalling;
  }
  ILanguageModelChatMetadata2.suitableForAgentMode = suitableForAgentMode;
  function asQualifiedName(metadata) {
    return `${metadata.name} (${metadata.vendor})`;
  }
  ILanguageModelChatMetadata2.asQualifiedName = asQualifiedName;
  function matchesQualifiedName(name2, metadata) {
    if (metadata.vendor === "copilot" && name2 === metadata.name) {
      return true;
    }
    return name2 === asQualifiedName(metadata);
  }
  ILanguageModelChatMetadata2.matchesQualifiedName = matchesQualifiedName;
})(ILanguageModelChatMetadata || (ILanguageModelChatMetadata = {}));
var ILanguageModelsService = createDecorator("ILanguageModelsService");
var languageModelChatProviderType = {
  type: "object",
  required: ["vendor", "displayName"],
  properties: {
    vendor: {
      type: "string",
      description: localize(6442, null)
    },
    displayName: {
      type: "string",
      description: localize(6443, null)
    },
    managementCommand: {
      type: "string",
      description: localize(6444, null)
    },
    when: {
      type: "string",
      description: localize(6445, null)
    }
  }
};
var languageModelChatProviderExtensionPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "languageModelChatProviders",
  jsonSchema: {
    description: localize(6446, null),
    oneOf: [
      languageModelChatProviderType,
      {
        type: "array",
        items: languageModelChatProviderType
      }
    ]
  },
  activationEventsGenerator: function* (contribs) {
    for (const contrib of contribs) {
      yield `onLanguageModelChatProvider:${contrib.vendor}`;
    }
  }
});
var LanguageModelsService = class LanguageModelsService2 {
  constructor(_extensionService, _logService, _storageService, _contextKeyService, _configurationService, _chatEntitlementService) {
    this._extensionService = _extensionService;
    this._logService = _logService;
    this._storageService = _storageService;
    this._configurationService = _configurationService;
    this._chatEntitlementService = _chatEntitlementService;
    this._store = new DisposableStore();
    this._providers = /* @__PURE__ */ new Map();
    this._modelCache = /* @__PURE__ */ new Map();
    this._vendors = /* @__PURE__ */ new Map();
    this._resolveLMSequencer = new SequencerByKey();
    this._modelPickerUserPreferences = {};
    this._onLanguageModelChange = this._store.add(new Emitter());
    this.onDidChangeLanguageModels = this._onLanguageModelChange.event;
    this._hasUserSelectableModels = ChatContextKeys.languageModelsAreUserSelectable.bindTo(_contextKeyService);
    this._contextKeyService = _contextKeyService;
    this._modelPickerUserPreferences = this._storageService.getObject("chatModelPickerPreferences", 0, this._modelPickerUserPreferences);
    const entitlementChangeHandler = () => {
      if ((this._chatEntitlementService.entitlement === ChatEntitlement.Business || this._chatEntitlementService.entitlement === ChatEntitlement.Enterprise) && !this._chatEntitlementService.isInternal) {
        this._modelPickerUserPreferences = {};
        this._storageService.store(
          "chatModelPickerPreferences",
          this._modelPickerUserPreferences,
          0,
          0
          /* StorageTarget.USER */
        );
      }
    };
    entitlementChangeHandler();
    this._store.add(this._chatEntitlementService.onDidChangeEntitlement(entitlementChangeHandler));
    this._store.add(this.onDidChangeLanguageModels(() => {
      this._hasUserSelectableModels.set(this._modelCache.size > 0 && Array.from(this._modelCache.values()).some((model) => model.isUserSelectable));
    }));
    this._store.add(languageModelChatProviderExtensionPoint.setHandler((extensions) => {
      this._vendors.clear();
      for (const extension of extensions) {
        for (const item of Iterable.wrap(extension.value)) {
          if (this._vendors.has(item.vendor)) {
            extension.collector.error(localize(6447, null, item.vendor));
            continue;
          }
          if (isFalsyOrWhitespace(item.vendor)) {
            extension.collector.error(localize(6448, null));
            continue;
          }
          if (item.vendor.trim() !== item.vendor) {
            extension.collector.error(localize(6449, null));
            continue;
          }
          this._vendors.set(item.vendor, item);
          if (this._hasStoredModelForVendor(item.vendor)) {
            this._extensionService.activateByEvent(`onLanguageModelChatProvider:${item.vendor}`);
          }
        }
      }
      for (const [vendor, _] of this._providers) {
        if (!this._vendors.has(vendor)) {
          this._providers.delete(vendor);
        }
      }
    }));
  }
  _hasStoredModelForVendor(vendor) {
    return Object.keys(this._modelPickerUserPreferences).some((modelId) => {
      return modelId.startsWith(vendor);
    });
  }
  dispose() {
    this._store.dispose();
    this._providers.clear();
  }
  updateModelPickerPreference(modelIdentifier, showInModelPicker) {
    const model = this._modelCache.get(modelIdentifier);
    if (!model) {
      this._logService.warn(`[LM] Cannot update model picker preference for unknown model ${modelIdentifier}`);
      return;
    }
    this._modelPickerUserPreferences[modelIdentifier] = showInModelPicker;
    if (showInModelPicker === model.isUserSelectable) {
      delete this._modelPickerUserPreferences[modelIdentifier];
      this._storageService.store(
        "chatModelPickerPreferences",
        this._modelPickerUserPreferences,
        0,
        0
        /* StorageTarget.USER */
      );
    } else if (model.isUserSelectable !== showInModelPicker) {
      this._storageService.store(
        "chatModelPickerPreferences",
        this._modelPickerUserPreferences,
        0,
        0
        /* StorageTarget.USER */
      );
    }
    this._onLanguageModelChange.fire(model.vendor);
    this._logService.trace(`[LM] Updated model picker preference for ${modelIdentifier} to ${showInModelPicker}`);
  }
  getVendors() {
    return Array.from(this._vendors.values()).filter((vendor) => {
      if (!vendor.when) {
        return true;
      }
      const whenClause = ContextKeyExpr.deserialize(vendor.when);
      return whenClause ? this._contextKeyService.contextMatchesRules(whenClause) : false;
    });
  }
  getLanguageModelIds() {
    return Array.from(this._modelCache.keys());
  }
  lookupLanguageModel(modelIdentifier) {
    const model = this._modelCache.get(modelIdentifier);
    if (model && this._configurationService.getValue("chat.experimentalShowAllModels")) {
      return { ...model, isUserSelectable: true };
    }
    if (model && this._modelPickerUserPreferences[modelIdentifier] !== void 0) {
      return { ...model, isUserSelectable: this._modelPickerUserPreferences[modelIdentifier] };
    }
    return model;
  }
  _clearModelCache(vendor) {
    for (const [id2, model] of this._modelCache.entries()) {
      if (model.vendor === vendor) {
        this._modelCache.delete(id2);
      }
    }
  }
  async _resolveLanguageModels(vendor, silent) {
    await this._extensionService.activateByEvent(`onLanguageModelChatProvider:${vendor}`);
    const provider = this._providers.get(vendor);
    if (!provider) {
      this._logService.warn(`[LM] No provider registered for vendor ${vendor}`);
      return;
    }
    return this._resolveLMSequencer.queue(vendor, async () => {
      try {
        let modelsAndIdentifiers = await provider.provideLanguageModelChatInfo({ silent }, CancellationToken.None);
        if (!silent && modelsAndIdentifiers.some((m) => m.metadata.isUserSelectable)) {
          modelsAndIdentifiers = modelsAndIdentifiers.filter((m) => m.metadata.isUserSelectable || this._modelPickerUserPreferences[m.identifier] === true);
        }
        this._clearModelCache(vendor);
        for (const modelAndIdentifier of modelsAndIdentifiers) {
          if (this._modelCache.has(modelAndIdentifier.identifier)) {
            this._logService.warn(`[LM] Model ${modelAndIdentifier.identifier} is already registered. Skipping.`);
            continue;
          }
          this._modelCache.set(modelAndIdentifier.identifier, modelAndIdentifier.metadata);
        }
        this._logService.trace(`[LM] Resolved language models for vendor ${vendor}`, modelsAndIdentifiers);
      } catch (error) {
        this._logService.error(`[LM] Error resolving language models for vendor ${vendor}:`, error);
      }
      this._onLanguageModelChange.fire(vendor);
    });
  }
  async selectLanguageModels(selector, allowPromptingUser) {
    if (selector.vendor) {
      await this._resolveLanguageModels(selector.vendor, !allowPromptingUser);
    } else {
      const allVendors = Array.from(this._vendors.keys());
      await Promise.all(allVendors.map((vendor) => this._resolveLanguageModels(vendor, !allowPromptingUser)));
    }
    const result = [];
    for (const [internalModelIdentifier, model] of this._modelCache) {
      if ((selector.vendor === void 0 || model.vendor === selector.vendor) && (selector.family === void 0 || model.family === selector.family) && (selector.version === void 0 || model.version === selector.version) && (selector.id === void 0 || model.id === selector.id)) {
        result.push(internalModelIdentifier);
      }
    }
    this._logService.trace("[LM] selected language models", selector, result);
    return result;
  }
  registerLanguageModelProvider(vendor, provider) {
    this._logService.trace("[LM] registering language model provider", vendor, provider);
    if (!this._vendors.has(vendor)) {
      throw new Error(`Chat model provider uses UNKNOWN vendor ${vendor}.`);
    }
    if (this._providers.has(vendor)) {
      throw new Error(`Chat model provider for vendor ${vendor} is already registered.`);
    }
    this._providers.set(vendor, provider);
    if (this._hasStoredModelForVendor(vendor)) {
      this._resolveLanguageModels(vendor, true);
    }
    const modelChangeListener = provider.onDidChange(async () => {
      await this._resolveLanguageModels(vendor, true);
    });
    return toDisposable(() => {
      this._logService.trace("[LM] UNregistered language model provider", vendor);
      this._clearModelCache(vendor);
      this._providers.delete(vendor);
      modelChangeListener.dispose();
    });
  }
  async sendChatRequest(modelId, from, messages, options2, token) {
    const provider = this._providers.get(this._modelCache.get(modelId)?.vendor || "");
    if (!provider) {
      throw new Error(`Chat provider for model ${modelId} is not registered.`);
    }
    return provider.sendChatRequest(modelId, messages, from, options2, token);
  }
  computeTokenLength(modelId, message, token) {
    const model = this._modelCache.get(modelId);
    if (!model) {
      throw new Error(`Chat model ${modelId} could not be found.`);
    }
    const provider = this._providers.get(model.vendor);
    if (!provider) {
      throw new Error(`Chat provider for model ${modelId} is not registered.`);
    }
    return provider.provideTokenCount(modelId, message, token);
  }
};
LanguageModelsService = __decorate([
  __param(0, IExtensionService),
  __param(1, ILogService),
  __param(2, IStorageService),
  __param(3, IContextKeyService),
  __param(4, IConfigurationService),
  __param(5, IChatEntitlementService)
], LanguageModelsService);

// out-build/vs/workbench/contrib/chat/common/tools/toolHelpers.js
function createToolSimpleTextResult(value) {
  return {
    content: [{
      kind: "text",
      value
    }]
  };
}

// out-build/vs/workbench/contrib/chat/common/tools/runSubagentTool.js
var RunSubagentToolId = "runSubagent";
var BaseModelDescription = `Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.

- Agents do not run async or in the background, you will wait for the agent's result.
- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.
- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.
- The agent's outputs should generally be trusted
- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent`;
var RunSubagentTool = class RunSubagentTool2 extends Disposable {
  constructor(chatAgentService, chatService, chatModeService, languageModelToolsService, languageModelsService, logService, toolsService, configurationService) {
    super();
    this.chatAgentService = chatAgentService;
    this.chatService = chatService;
    this.chatModeService = chatModeService;
    this.languageModelToolsService = languageModelToolsService;
    this.languageModelsService = languageModelsService;
    this.logService = logService;
    this.toolsService = toolsService;
    this.configurationService = configurationService;
  }
  getToolData() {
    const runSubagentToolData = {
      id: RunSubagentToolId,
      toolReferenceName: VSCodeToolReference.runSubagent,
      legacyToolReferenceFullNames: ["runSubagent"],
      icon: ThemeIcon.fromId(Codicon.organization.id),
      displayName: localize(6602, null),
      userDescription: localize(6603, null),
      modelDescription: BaseModelDescription,
      source: ToolDataSource.Internal,
      inputSchema: {
        type: "object",
        properties: {
          prompt: {
            type: "string",
            description: "A detailed description of the task for the agent to perform"
          },
          description: {
            type: "string",
            description: "A short (3-5 word) description of the task"
          }
        },
        required: ["prompt", "description"]
      }
    };
    if (this.configurationService.getValue(ChatConfiguration.SubagentToolCustomAgents)) {
      runSubagentToolData.inputSchema.properties["subagentType"] = {
        type: "string",
        description: "Optional ID of a specific agent to invoke. If not provided, uses the current agent."
      };
      runSubagentToolData.modelDescription += `
- If the user asks for a certain agent by name, you MUST provide that EXACT subagentType (case-sensitive) to invoke that specific agent.`;
    }
    return runSubagentToolData;
  }
  async invoke(invocation, _countTokens, _progress, token) {
    const args = invocation.parameters;
    this.logService.debug(`RunSubagentTool: Invoking with prompt: ${args.prompt.substring(0, 100)}...`);
    if (!invocation.context) {
      throw new Error("toolInvocationToken is required for this tool");
    }
    const model = this.chatService.getSession(invocation.context.sessionResource);
    if (!model) {
      throw new Error("Chat model not found for session");
    }
    const request = model.getRequests().at(-1);
    try {
      const defaultAgent = this.chatAgentService.getDefaultAgent(ChatAgentLocation.Chat, ChatModeKind.Agent);
      if (!defaultAgent) {
        return createToolSimpleTextResult("Error: No default agent available");
      }
      let modeModelId = invocation.modelId;
      let modeTools = invocation.userSelectedTools;
      let modeInstructions;
      if (args.subagentType) {
        const mode = this.chatModeService.findModeByName(args.subagentType);
        if (mode) {
          const modeModelQualifiedName = mode.model?.get();
          if (modeModelQualifiedName) {
            const modelIds = this.languageModelsService.getLanguageModelIds();
            for (const modelId of modelIds) {
              const metadata = this.languageModelsService.lookupLanguageModel(modelId);
              if (metadata && ILanguageModelChatMetadata.matchesQualifiedName(modeModelQualifiedName, metadata)) {
                modeModelId = modelId;
                break;
              }
            }
          }
          const modeCustomTools = mode.customTools?.get();
          if (modeCustomTools) {
            const enablementMap = this.languageModelToolsService.toToolAndToolSetEnablementMap(modeCustomTools, mode.target?.get());
            modeTools = {};
            for (const [tool, enabled] of enablementMap) {
              if (!(tool instanceof ToolSet)) {
                modeTools[tool.id] = enabled;
              }
            }
          }
          const instructions = mode.modeInstructions?.get();
          modeInstructions = instructions && {
            name: mode.name.get(),
            content: instructions.content,
            toolReferences: this.toolsService.toToolReferences(instructions.toolReferences),
            metadata: instructions.metadata
          };
        } else {
          this.logService.warn(`RunSubagentTool: Agent '${args.subagentType}' not found, using current configuration`);
        }
      }
      const markdownParts = [];
      let inEdit = false;
      const progressCallback = (parts) => {
        for (const part of parts) {
          if (part.kind === "prepareToolInvocation" || part.kind === "textEdit" || part.kind === "notebookEdit" || part.kind === "codeblockUri") {
            if (part.kind === "codeblockUri" && !inEdit) {
              inEdit = true;
              model.acceptResponseProgress(request, { kind: "markdownContent", content: new MarkdownString("```\n"), fromSubagent: true });
            }
            model.acceptResponseProgress(request, part);
            if (part.kind === "prepareToolInvocation") {
              markdownParts.length = 0;
            }
          } else if (part.kind === "markdownContent") {
            if (inEdit) {
              model.acceptResponseProgress(request, { kind: "markdownContent", content: new MarkdownString("\n```\n\n"), fromSubagent: true });
              inEdit = false;
            }
            markdownParts.push(part.content.value);
          }
        }
      };
      if (modeTools) {
        modeTools[RunSubagentToolId] = false;
        modeTools[ManageTodoListToolToolId] = false;
      }
      const agentRequest = {
        sessionId: invocation.context.sessionId,
        sessionResource: invocation.context.sessionResource,
        requestId: invocation.callId ?? `subagent-${Date.now()}`,
        agentId: defaultAgent.id,
        message: args.prompt,
        variables: { variables: [] },
        location: ChatAgentLocation.Chat,
        isSubagent: true,
        userSelectedModelId: modeModelId,
        userSelectedTools: modeTools,
        modeInstructions
      };
      const result = await this.chatAgentService.invokeAgent(defaultAgent.id, agentRequest, progressCallback, [], token);
      if (result.errorDetails) {
        return createToolSimpleTextResult(`Agent error: ${result.errorDetails.message}`);
      }
      return createToolSimpleTextResult(markdownParts.join("") || "Agent completed with no output");
    } catch (error) {
      const errorMessage = `Error invoking subagent: ${error instanceof Error ? error.message : "Unknown error"}`;
      this.logService.error(errorMessage, error);
      return createToolSimpleTextResult(errorMessage);
    }
  }
  async prepareToolInvocation(context, _token) {
    const args = context.parameters;
    return {
      invocationMessage: args.description
    };
  }
};
RunSubagentTool = __decorate([
  __param(0, IChatAgentService),
  __param(1, IChatService),
  __param(2, IChatModeService),
  __param(3, ILanguageModelToolsService),
  __param(4, ILanguageModelsService),
  __param(5, ILogService),
  __param(6, ILanguageModelToolsService),
  __param(7, IConfigurationService)
], RunSubagentTool);

// out-build/vs/workbench/contrib/chat/common/tools/tools.js
var BuiltinToolsContribution = class BuiltinToolsContribution2 extends Disposable {
  static {
    this.ID = "chat.builtinTools";
  }
  constructor(toolsService, instantiationService, configurationService) {
    super();
    this.configurationService = configurationService;
    const editTool = instantiationService.createInstance(EditTool);
    this._register(toolsService.registerTool(EditToolData, editTool));
    const writeOnlyMode = this.configurationService.getValue(TodoListToolWriteOnlySettingId) === true;
    const includeDescription = this.configurationService.getValue(TodoListToolDescriptionFieldSettingId) !== false;
    const todoToolData = createManageTodoListToolData(writeOnlyMode, includeDescription);
    const manageTodoListTool = this._register(instantiationService.createInstance(ManageTodoListTool, writeOnlyMode, includeDescription));
    this._register(toolsService.registerTool(todoToolData, manageTodoListTool));
    const confirmationTool = instantiationService.createInstance(ConfirmationTool);
    this._register(toolsService.registerTool(ConfirmationToolData, confirmationTool));
    const runSubagentTool = this._register(instantiationService.createInstance(RunSubagentTool));
    const runSubagentToolData = runSubagentTool.getToolData();
    this._register(toolsService.registerTool(runSubagentToolData, runSubagentTool));
    const customAgentToolSet = this._register(toolsService.createToolSet(ToolDataSource.Internal, "custom-agent", VSCodeToolReference.customAgent, {
      icon: ThemeIcon.fromId(Codicon.agent.id),
      description: localize(6604, null)
    }));
    this._register(customAgentToolSet.addTool(runSubagentToolData));
  }
};
BuiltinToolsContribution = __decorate([
  __param(0, ILanguageModelToolsService),
  __param(1, IInstantiationService),
  __param(2, IConfigurationService)
], BuiltinToolsContribution);
var InternalFetchWebPageToolId = "vscode_fetchWebPage_internal";

// out-build/vs/base/common/keybindings.js
var BinaryKeybindingsMask;
(function(BinaryKeybindingsMask2) {
  BinaryKeybindingsMask2[BinaryKeybindingsMask2["CtrlCmd"] = 2048] = "CtrlCmd";
  BinaryKeybindingsMask2[BinaryKeybindingsMask2["Shift"] = 1024] = "Shift";
  BinaryKeybindingsMask2[BinaryKeybindingsMask2["Alt"] = 512] = "Alt";
  BinaryKeybindingsMask2[BinaryKeybindingsMask2["WinCtrl"] = 256] = "WinCtrl";
  BinaryKeybindingsMask2[BinaryKeybindingsMask2["KeyCode"] = 255] = "KeyCode";
})(BinaryKeybindingsMask || (BinaryKeybindingsMask = {}));
function decodeKeybinding(keybinding, OS2) {
  if (typeof keybinding === "number") {
    if (keybinding === 0) {
      return null;
    }
    const firstChord = (keybinding & 65535) >>> 0;
    const secondChord = (keybinding & 4294901760) >>> 16;
    if (secondChord !== 0) {
      return new Keybinding([
        createSimpleKeybinding(firstChord, OS2),
        createSimpleKeybinding(secondChord, OS2)
      ]);
    }
    return new Keybinding([createSimpleKeybinding(firstChord, OS2)]);
  } else {
    const chords = [];
    for (let i = 0; i < keybinding.length; i++) {
      chords.push(createSimpleKeybinding(keybinding[i], OS2));
    }
    return new Keybinding(chords);
  }
}
function createSimpleKeybinding(keybinding, OS2) {
  const ctrlCmd = keybinding & 2048 ? true : false;
  const winCtrl = keybinding & 256 ? true : false;
  const ctrlKey = OS2 === 2 ? winCtrl : ctrlCmd;
  const shiftKey = keybinding & 1024 ? true : false;
  const altKey = keybinding & 512 ? true : false;
  const metaKey = OS2 === 2 ? ctrlCmd : winCtrl;
  const keyCode = keybinding & 255;
  return new KeyCodeChord(ctrlKey, shiftKey, altKey, metaKey, keyCode);
}
var KeyCodeChord = class _KeyCodeChord {
  constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyCode = keyCode;
  }
  equals(other) {
    return other instanceof _KeyCodeChord && this.ctrlKey === other.ctrlKey && this.shiftKey === other.shiftKey && this.altKey === other.altKey && this.metaKey === other.metaKey && this.keyCode === other.keyCode;
  }
  getHashCode() {
    const ctrl = this.ctrlKey ? "1" : "0";
    const shift = this.shiftKey ? "1" : "0";
    const alt = this.altKey ? "1" : "0";
    const meta = this.metaKey ? "1" : "0";
    return `K${ctrl}${shift}${alt}${meta}${this.keyCode}`;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  toKeybinding() {
    return new Keybinding([this]);
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
};
var Keybinding = class {
  constructor(chords) {
    if (chords.length === 0) {
      throw illegalArgument(`chords`);
    }
    this.chords = chords;
  }
  getHashCode() {
    let result = "";
    for (let i = 0, len = this.chords.length; i < len; i++) {
      if (i !== 0) {
        result += ";";
      }
      result += this.chords[i].getHashCode();
    }
    return result;
  }
  equals(other) {
    if (other === null) {
      return false;
    }
    if (this.chords.length !== other.chords.length) {
      return false;
    }
    for (let i = 0; i < this.chords.length; i++) {
      if (!this.chords[i].equals(other.chords[i])) {
        return false;
      }
    }
    return true;
  }
};

// out-build/vs/platform/keybinding/common/keybindingsRegistry.js
var KeybindingWeight;
(function(KeybindingWeight2) {
  KeybindingWeight2[KeybindingWeight2["EditorCore"] = 0] = "EditorCore";
  KeybindingWeight2[KeybindingWeight2["EditorContrib"] = 100] = "EditorContrib";
  KeybindingWeight2[KeybindingWeight2["WorkbenchContrib"] = 200] = "WorkbenchContrib";
  KeybindingWeight2[KeybindingWeight2["BuiltinExtension"] = 300] = "BuiltinExtension";
  KeybindingWeight2[KeybindingWeight2["ExternalExtension"] = 400] = "ExternalExtension";
})(KeybindingWeight || (KeybindingWeight = {}));
var KeybindingsRegistryImpl = class _KeybindingsRegistryImpl {
  constructor() {
    this._coreKeybindings = new LinkedList();
    this._extensionKeybindings = [];
    this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(kb) {
    if (OS === 1) {
      if (kb && kb.win) {
        return kb.win;
      }
    } else if (OS === 2) {
      if (kb && kb.mac) {
        return kb.mac;
      }
    } else {
      if (kb && kb.linux) {
        return kb.linux;
      }
    }
    return kb;
  }
  registerKeybindingRule(rule) {
    const actualKb = _KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
    const result = new DisposableStore();
    if (actualKb && actualKb.primary) {
      const kk = decodeKeybinding(actualKb.primary, OS);
      if (kk) {
        result.add(this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, 0, rule.when));
      }
    }
    if (actualKb && Array.isArray(actualKb.secondary)) {
      for (let i = 0, len = actualKb.secondary.length; i < len; i++) {
        const k = actualKb.secondary[i];
        const kk = decodeKeybinding(k, OS);
        if (kk) {
          result.add(this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, -i - 1, rule.when));
        }
      }
    }
    return result;
  }
  setExtensionKeybindings(rules) {
    const result = [];
    let keybindingsLen = 0;
    for (const rule of rules) {
      if (rule.keybinding) {
        result[keybindingsLen++] = {
          keybinding: rule.keybinding,
          command: rule.id,
          commandArgs: rule.args,
          when: rule.when,
          weight1: rule.weight,
          weight2: 0,
          extensionId: rule.extensionId || null,
          isBuiltinExtension: rule.isBuiltinExtension || false
        };
      }
    }
    this._extensionKeybindings = result;
    this._cachedMergedKeybindings = null;
  }
  registerCommandAndKeybindingRule(desc) {
    return combinedDisposable(this.registerKeybindingRule(desc), CommandsRegistry.registerCommand(desc));
  }
  _registerDefaultKeybinding(keybinding, commandId, commandArgs, weight1, weight2, when) {
    const remove = this._coreKeybindings.push({
      keybinding,
      command: commandId,
      commandArgs,
      when,
      weight1,
      weight2,
      extensionId: null,
      isBuiltinExtension: false
    });
    this._cachedMergedKeybindings = null;
    return toDisposable(() => {
      remove();
      this._cachedMergedKeybindings = null;
    });
  }
  getDefaultKeybindings() {
    if (!this._cachedMergedKeybindings) {
      this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings);
      this._cachedMergedKeybindings.sort(sorter);
    }
    return this._cachedMergedKeybindings.slice(0);
  }
};
var KeybindingsRegistry = new KeybindingsRegistryImpl();
var Extensions6 = {
  EditorModes: "platform.keybindingsRegistry"
};
Registry.add(Extensions6.EditorModes, KeybindingsRegistry);
function sorter(a, b) {
  if (a.weight1 !== b.weight1) {
    return a.weight1 - b.weight1;
  }
  if (a.command && b.command) {
    if (a.command < b.command) {
      return -1;
    }
    if (a.command > b.command) {
      return 1;
    }
  }
  return a.weight2 - b.weight2;
}

// out-build/vs/platform/actions/common/actions.js
var MenuItemAction_1;
function isIMenuItem(item) {
  return item.command !== void 0;
}
var MenuId = class _MenuId {
  static {
    this._instances = /* @__PURE__ */ new Map();
  }
  static {
    this.CommandPalette = new _MenuId("CommandPalette");
  }
  static {
    this.DebugBreakpointsContext = new _MenuId("DebugBreakpointsContext");
  }
  static {
    this.DebugCallStackContext = new _MenuId("DebugCallStackContext");
  }
  static {
    this.DebugConsoleContext = new _MenuId("DebugConsoleContext");
  }
  static {
    this.DebugVariablesContext = new _MenuId("DebugVariablesContext");
  }
  static {
    this.NotebookVariablesContext = new _MenuId("NotebookVariablesContext");
  }
  static {
    this.DebugHoverContext = new _MenuId("DebugHoverContext");
  }
  static {
    this.DebugWatchContext = new _MenuId("DebugWatchContext");
  }
  static {
    this.DebugToolBar = new _MenuId("DebugToolBar");
  }
  static {
    this.DebugToolBarStop = new _MenuId("DebugToolBarStop");
  }
  static {
    this.DebugDisassemblyContext = new _MenuId("DebugDisassemblyContext");
  }
  static {
    this.DebugCallStackToolbar = new _MenuId("DebugCallStackToolbar");
  }
  static {
    this.DebugCreateConfiguration = new _MenuId("DebugCreateConfiguration");
  }
  static {
    this.EditorContext = new _MenuId("EditorContext");
  }
  static {
    this.SimpleEditorContext = new _MenuId("SimpleEditorContext");
  }
  static {
    this.EditorContent = new _MenuId("EditorContent");
  }
  static {
    this.EditorLineNumberContext = new _MenuId("EditorLineNumberContext");
  }
  static {
    this.EditorContextCopy = new _MenuId("EditorContextCopy");
  }
  static {
    this.EditorContextPeek = new _MenuId("EditorContextPeek");
  }
  static {
    this.EditorContextShare = new _MenuId("EditorContextShare");
  }
  static {
    this.EditorTitle = new _MenuId("EditorTitle");
  }
  static {
    this.CompactWindowEditorTitle = new _MenuId("CompactWindowEditorTitle");
  }
  static {
    this.EditorTitleRun = new _MenuId("EditorTitleRun");
  }
  static {
    this.EditorTitleContext = new _MenuId("EditorTitleContext");
  }
  static {
    this.EditorTitleContextShare = new _MenuId("EditorTitleContextShare");
  }
  static {
    this.EmptyEditorGroup = new _MenuId("EmptyEditorGroup");
  }
  static {
    this.EmptyEditorGroupContext = new _MenuId("EmptyEditorGroupContext");
  }
  static {
    this.EditorTabsBarContext = new _MenuId("EditorTabsBarContext");
  }
  static {
    this.EditorTabsBarShowTabsSubmenu = new _MenuId("EditorTabsBarShowTabsSubmenu");
  }
  static {
    this.EditorTabsBarShowTabsZenModeSubmenu = new _MenuId("EditorTabsBarShowTabsZenModeSubmenu");
  }
  static {
    this.EditorActionsPositionSubmenu = new _MenuId("EditorActionsPositionSubmenu");
  }
  static {
    this.EditorSplitMoveSubmenu = new _MenuId("EditorSplitMoveSubmenu");
  }
  static {
    this.ExplorerContext = new _MenuId("ExplorerContext");
  }
  static {
    this.ExplorerContextShare = new _MenuId("ExplorerContextShare");
  }
  static {
    this.ExtensionContext = new _MenuId("ExtensionContext");
  }
  static {
    this.ExtensionEditorContextMenu = new _MenuId("ExtensionEditorContextMenu");
  }
  static {
    this.GlobalActivity = new _MenuId("GlobalActivity");
  }
  static {
    this.CommandCenter = new _MenuId("CommandCenter");
  }
  static {
    this.CommandCenterCenter = new _MenuId("CommandCenterCenter");
  }
  static {
    this.LayoutControlMenuSubmenu = new _MenuId("LayoutControlMenuSubmenu");
  }
  static {
    this.LayoutControlMenu = new _MenuId("LayoutControlMenu");
  }
  static {
    this.MenubarMainMenu = new _MenuId("MenubarMainMenu");
  }
  static {
    this.MenubarAppearanceMenu = new _MenuId("MenubarAppearanceMenu");
  }
  static {
    this.MenubarDebugMenu = new _MenuId("MenubarDebugMenu");
  }
  static {
    this.MenubarEditMenu = new _MenuId("MenubarEditMenu");
  }
  static {
    this.MenubarCopy = new _MenuId("MenubarCopy");
  }
  static {
    this.MenubarFileMenu = new _MenuId("MenubarFileMenu");
  }
  static {
    this.MenubarGoMenu = new _MenuId("MenubarGoMenu");
  }
  static {
    this.MenubarHelpMenu = new _MenuId("MenubarHelpMenu");
  }
  static {
    this.MenubarLayoutMenu = new _MenuId("MenubarLayoutMenu");
  }
  static {
    this.MenubarNewBreakpointMenu = new _MenuId("MenubarNewBreakpointMenu");
  }
  static {
    this.PanelAlignmentMenu = new _MenuId("PanelAlignmentMenu");
  }
  static {
    this.PanelPositionMenu = new _MenuId("PanelPositionMenu");
  }
  static {
    this.ActivityBarPositionMenu = new _MenuId("ActivityBarPositionMenu");
  }
  static {
    this.MenubarPreferencesMenu = new _MenuId("MenubarPreferencesMenu");
  }
  static {
    this.MenubarRecentMenu = new _MenuId("MenubarRecentMenu");
  }
  static {
    this.MenubarSelectionMenu = new _MenuId("MenubarSelectionMenu");
  }
  static {
    this.MenubarShare = new _MenuId("MenubarShare");
  }
  static {
    this.MenubarSwitchEditorMenu = new _MenuId("MenubarSwitchEditorMenu");
  }
  static {
    this.MenubarSwitchGroupMenu = new _MenuId("MenubarSwitchGroupMenu");
  }
  static {
    this.MenubarTerminalMenu = new _MenuId("MenubarTerminalMenu");
  }
  static {
    this.MenubarTerminalSuggestStatusMenu = new _MenuId("MenubarTerminalSuggestStatusMenu");
  }
  static {
    this.MenubarViewMenu = new _MenuId("MenubarViewMenu");
  }
  static {
    this.MenubarHomeMenu = new _MenuId("MenubarHomeMenu");
  }
  static {
    this.OpenEditorsContext = new _MenuId("OpenEditorsContext");
  }
  static {
    this.OpenEditorsContextShare = new _MenuId("OpenEditorsContextShare");
  }
  static {
    this.ProblemsPanelContext = new _MenuId("ProblemsPanelContext");
  }
  static {
    this.SCMInputBox = new _MenuId("SCMInputBox");
  }
  static {
    this.SCMChangeContext = new _MenuId("SCMChangeContext");
  }
  static {
    this.SCMResourceContext = new _MenuId("SCMResourceContext");
  }
  static {
    this.SCMResourceContextShare = new _MenuId("SCMResourceContextShare");
  }
  static {
    this.SCMResourceFolderContext = new _MenuId("SCMResourceFolderContext");
  }
  static {
    this.SCMResourceGroupContext = new _MenuId("SCMResourceGroupContext");
  }
  static {
    this.SCMSourceControl = new _MenuId("SCMSourceControl");
  }
  static {
    this.SCMSourceControlInline = new _MenuId("SCMSourceControlInline");
  }
  static {
    this.SCMSourceControlTitle = new _MenuId("SCMSourceControlTitle");
  }
  static {
    this.SCMHistoryTitle = new _MenuId("SCMHistoryTitle");
  }
  static {
    this.SCMHistoryItemContext = new _MenuId("SCMHistoryItemContext");
  }
  static {
    this.SCMHistoryItemChangeContext = new _MenuId("SCMHistoryItemChangeContext");
  }
  static {
    this.SCMHistoryItemRefContext = new _MenuId("SCMHistoryItemRefContext");
  }
  static {
    this.SCMArtifactGroupContext = new _MenuId("SCMArtifactGroupContext");
  }
  static {
    this.SCMArtifactContext = new _MenuId("SCMArtifactContext");
  }
  static {
    this.SCMQuickDiffDecorations = new _MenuId("SCMQuickDiffDecorations");
  }
  static {
    this.SCMTitle = new _MenuId("SCMTitle");
  }
  static {
    this.SearchContext = new _MenuId("SearchContext");
  }
  static {
    this.SearchActionMenu = new _MenuId("SearchActionContext");
  }
  static {
    this.StatusBarWindowIndicatorMenu = new _MenuId("StatusBarWindowIndicatorMenu");
  }
  static {
    this.StatusBarRemoteIndicatorMenu = new _MenuId("StatusBarRemoteIndicatorMenu");
  }
  static {
    this.StickyScrollContext = new _MenuId("StickyScrollContext");
  }
  static {
    this.TestItem = new _MenuId("TestItem");
  }
  static {
    this.TestItemGutter = new _MenuId("TestItemGutter");
  }
  static {
    this.TestProfilesContext = new _MenuId("TestProfilesContext");
  }
  static {
    this.TestMessageContext = new _MenuId("TestMessageContext");
  }
  static {
    this.TestMessageContent = new _MenuId("TestMessageContent");
  }
  static {
    this.TestPeekElement = new _MenuId("TestPeekElement");
  }
  static {
    this.TestPeekTitle = new _MenuId("TestPeekTitle");
  }
  static {
    this.TestCallStack = new _MenuId("TestCallStack");
  }
  static {
    this.TestCoverageFilterItem = new _MenuId("TestCoverageFilterItem");
  }
  static {
    this.TouchBarContext = new _MenuId("TouchBarContext");
  }
  static {
    this.TitleBar = new _MenuId("TitleBar");
  }
  static {
    this.TitleBarContext = new _MenuId("TitleBarContext");
  }
  static {
    this.TitleBarTitleContext = new _MenuId("TitleBarTitleContext");
  }
  static {
    this.TunnelContext = new _MenuId("TunnelContext");
  }
  static {
    this.TunnelPrivacy = new _MenuId("TunnelPrivacy");
  }
  static {
    this.TunnelProtocol = new _MenuId("TunnelProtocol");
  }
  static {
    this.TunnelPortInline = new _MenuId("TunnelInline");
  }
  static {
    this.TunnelTitle = new _MenuId("TunnelTitle");
  }
  static {
    this.TunnelLocalAddressInline = new _MenuId("TunnelLocalAddressInline");
  }
  static {
    this.TunnelOriginInline = new _MenuId("TunnelOriginInline");
  }
  static {
    this.ViewItemContext = new _MenuId("ViewItemContext");
  }
  static {
    this.ViewContainerTitle = new _MenuId("ViewContainerTitle");
  }
  static {
    this.ViewContainerTitleContext = new _MenuId("ViewContainerTitleContext");
  }
  static {
    this.ViewTitle = new _MenuId("ViewTitle");
  }
  static {
    this.ViewTitleContext = new _MenuId("ViewTitleContext");
  }
  static {
    this.CommentEditorActions = new _MenuId("CommentEditorActions");
  }
  static {
    this.CommentThreadTitle = new _MenuId("CommentThreadTitle");
  }
  static {
    this.CommentThreadActions = new _MenuId("CommentThreadActions");
  }
  static {
    this.CommentThreadAdditionalActions = new _MenuId("CommentThreadAdditionalActions");
  }
  static {
    this.CommentThreadTitleContext = new _MenuId("CommentThreadTitleContext");
  }
  static {
    this.CommentThreadCommentContext = new _MenuId("CommentThreadCommentContext");
  }
  static {
    this.CommentTitle = new _MenuId("CommentTitle");
  }
  static {
    this.CommentActions = new _MenuId("CommentActions");
  }
  static {
    this.CommentsViewThreadActions = new _MenuId("CommentsViewThreadActions");
  }
  static {
    this.InteractiveToolbar = new _MenuId("InteractiveToolbar");
  }
  static {
    this.InteractiveCellTitle = new _MenuId("InteractiveCellTitle");
  }
  static {
    this.InteractiveCellDelete = new _MenuId("InteractiveCellDelete");
  }
  static {
    this.InteractiveCellExecute = new _MenuId("InteractiveCellExecute");
  }
  static {
    this.InteractiveInputExecute = new _MenuId("InteractiveInputExecute");
  }
  static {
    this.InteractiveInputConfig = new _MenuId("InteractiveInputConfig");
  }
  static {
    this.ReplInputExecute = new _MenuId("ReplInputExecute");
  }
  static {
    this.IssueReporter = new _MenuId("IssueReporter");
  }
  static {
    this.NotebookToolbar = new _MenuId("NotebookToolbar");
  }
  static {
    this.NotebookToolbarContext = new _MenuId("NotebookToolbarContext");
  }
  static {
    this.NotebookStickyScrollContext = new _MenuId("NotebookStickyScrollContext");
  }
  static {
    this.NotebookCellTitle = new _MenuId("NotebookCellTitle");
  }
  static {
    this.NotebookCellDelete = new _MenuId("NotebookCellDelete");
  }
  static {
    this.NotebookCellInsert = new _MenuId("NotebookCellInsert");
  }
  static {
    this.NotebookCellBetween = new _MenuId("NotebookCellBetween");
  }
  static {
    this.NotebookCellListTop = new _MenuId("NotebookCellTop");
  }
  static {
    this.NotebookCellExecute = new _MenuId("NotebookCellExecute");
  }
  static {
    this.NotebookCellExecuteGoTo = new _MenuId("NotebookCellExecuteGoTo");
  }
  static {
    this.NotebookCellExecutePrimary = new _MenuId("NotebookCellExecutePrimary");
  }
  static {
    this.NotebookDiffCellInputTitle = new _MenuId("NotebookDiffCellInputTitle");
  }
  static {
    this.NotebookDiffDocumentMetadata = new _MenuId("NotebookDiffDocumentMetadata");
  }
  static {
    this.NotebookDiffCellMetadataTitle = new _MenuId("NotebookDiffCellMetadataTitle");
  }
  static {
    this.NotebookDiffCellOutputsTitle = new _MenuId("NotebookDiffCellOutputsTitle");
  }
  static {
    this.NotebookOutputToolbar = new _MenuId("NotebookOutputToolbar");
  }
  static {
    this.NotebookOutlineFilter = new _MenuId("NotebookOutlineFilter");
  }
  static {
    this.NotebookOutlineActionMenu = new _MenuId("NotebookOutlineActionMenu");
  }
  static {
    this.NotebookEditorLayoutConfigure = new _MenuId("NotebookEditorLayoutConfigure");
  }
  static {
    this.NotebookKernelSource = new _MenuId("NotebookKernelSource");
  }
  static {
    this.BulkEditTitle = new _MenuId("BulkEditTitle");
  }
  static {
    this.BulkEditContext = new _MenuId("BulkEditContext");
  }
  static {
    this.TimelineItemContext = new _MenuId("TimelineItemContext");
  }
  static {
    this.TimelineTitle = new _MenuId("TimelineTitle");
  }
  static {
    this.TimelineTitleContext = new _MenuId("TimelineTitleContext");
  }
  static {
    this.TimelineFilterSubMenu = new _MenuId("TimelineFilterSubMenu");
  }
  static {
    this.AgentSessionsTitle = new _MenuId("AgentSessionsTitle");
  }
  static {
    this.AgentSessionsFilterSubMenu = new _MenuId("AgentSessionsFilterSubMenu");
  }
  static {
    this.AccountsContext = new _MenuId("AccountsContext");
  }
  static {
    this.SidebarTitle = new _MenuId("SidebarTitle");
  }
  static {
    this.PanelTitle = new _MenuId("PanelTitle");
  }
  static {
    this.AuxiliaryBarTitle = new _MenuId("AuxiliaryBarTitle");
  }
  static {
    this.TerminalInstanceContext = new _MenuId("TerminalInstanceContext");
  }
  static {
    this.TerminalEditorInstanceContext = new _MenuId("TerminalEditorInstanceContext");
  }
  static {
    this.TerminalNewDropdownContext = new _MenuId("TerminalNewDropdownContext");
  }
  static {
    this.TerminalTabContext = new _MenuId("TerminalTabContext");
  }
  static {
    this.TerminalTabEmptyAreaContext = new _MenuId("TerminalTabEmptyAreaContext");
  }
  static {
    this.TerminalStickyScrollContext = new _MenuId("TerminalStickyScrollContext");
  }
  static {
    this.WebviewContext = new _MenuId("WebviewContext");
  }
  static {
    this.InlineCompletionsActions = new _MenuId("InlineCompletionsActions");
  }
  static {
    this.InlineEditsActions = new _MenuId("InlineEditsActions");
  }
  static {
    this.NewFile = new _MenuId("NewFile");
  }
  static {
    this.MergeInput1Toolbar = new _MenuId("MergeToolbar1Toolbar");
  }
  static {
    this.MergeInput2Toolbar = new _MenuId("MergeToolbar2Toolbar");
  }
  static {
    this.MergeBaseToolbar = new _MenuId("MergeBaseToolbar");
  }
  static {
    this.MergeInputResultToolbar = new _MenuId("MergeToolbarResultToolbar");
  }
  static {
    this.InlineSuggestionToolbar = new _MenuId("InlineSuggestionToolbar");
  }
  static {
    this.InlineEditToolbar = new _MenuId("InlineEditToolbar");
  }
  static {
    this.ChatContext = new _MenuId("ChatContext");
  }
  static {
    this.ChatCodeBlock = new _MenuId("ChatCodeblock");
  }
  static {
    this.ChatCompareBlock = new _MenuId("ChatCompareBlock");
  }
  static {
    this.ChatMessageTitle = new _MenuId("ChatMessageTitle");
  }
  static {
    this.ChatHistory = new _MenuId("ChatHistory");
  }
  static {
    this.ChatWelcomeContext = new _MenuId("ChatWelcomeContext");
  }
  static {
    this.ChatMessageFooter = new _MenuId("ChatMessageFooter");
  }
  static {
    this.ChatExecute = new _MenuId("ChatExecute");
  }
  static {
    this.ChatInput = new _MenuId("ChatInput");
  }
  static {
    this.ChatInputSide = new _MenuId("ChatInputSide");
  }
  static {
    this.ChatModePicker = new _MenuId("ChatModePicker");
  }
  static {
    this.ChatEditingWidgetToolbar = new _MenuId("ChatEditingWidgetToolbar");
  }
  static {
    this.ChatEditingEditorContent = new _MenuId("ChatEditingEditorContent");
  }
  static {
    this.ChatEditingEditorHunk = new _MenuId("ChatEditingEditorHunk");
  }
  static {
    this.ChatEditingDeletedNotebookCell = new _MenuId("ChatEditingDeletedNotebookCell");
  }
  static {
    this.ChatInputAttachmentToolbar = new _MenuId("ChatInputAttachmentToolbar");
  }
  static {
    this.ChatEditingWidgetModifiedFilesToolbar = new _MenuId("ChatEditingWidgetModifiedFilesToolbar");
  }
  static {
    this.ChatInputResourceAttachmentContext = new _MenuId("ChatInputResourceAttachmentContext");
  }
  static {
    this.ChatInputSymbolAttachmentContext = new _MenuId("ChatInputSymbolAttachmentContext");
  }
  static {
    this.ChatInlineResourceAnchorContext = new _MenuId("ChatInlineResourceAnchorContext");
  }
  static {
    this.ChatInlineSymbolAnchorContext = new _MenuId("ChatInlineSymbolAnchorContext");
  }
  static {
    this.ChatMessageCheckpoint = new _MenuId("ChatMessageCheckpoint");
  }
  static {
    this.ChatMessageRestoreCheckpoint = new _MenuId("ChatMessageRestoreCheckpoint");
  }
  static {
    this.ChatNewMenu = new _MenuId("ChatNewMenu");
  }
  static {
    this.ChatEditingCodeBlockContext = new _MenuId("ChatEditingCodeBlockContext");
  }
  static {
    this.ChatTitleBarMenu = new _MenuId("ChatTitleBarMenu");
  }
  static {
    this.ChatAttachmentsContext = new _MenuId("ChatAttachmentsContext");
  }
  static {
    this.ChatToolOutputResourceToolbar = new _MenuId("ChatToolOutputResourceToolbar");
  }
  static {
    this.ChatTextEditorMenu = new _MenuId("ChatTextEditorMenu");
  }
  static {
    this.ChatToolOutputResourceContext = new _MenuId("ChatToolOutputResourceContext");
  }
  static {
    this.ChatMultiDiffContext = new _MenuId("ChatMultiDiffContext");
  }
  static {
    this.ChatSessionsMenu = new _MenuId("ChatSessionsMenu");
  }
  static {
    this.ChatSessionsCreateSubMenu = new _MenuId("ChatSessionsCreateSubMenu");
  }
  static {
    this.ChatConfirmationMenu = new _MenuId("ChatConfirmationMenu");
  }
  static {
    this.ChatEditorInlineExecute = new _MenuId("ChatEditorInputExecute");
  }
  static {
    this.ChatEditorInlineInputSide = new _MenuId("ChatEditorInputSide");
  }
  static {
    this.AccessibleView = new _MenuId("AccessibleView");
  }
  static {
    this.MultiDiffEditorFileToolbar = new _MenuId("MultiDiffEditorFileToolbar");
  }
  static {
    this.DiffEditorHunkToolbar = new _MenuId("DiffEditorHunkToolbar");
  }
  static {
    this.DiffEditorSelectionToolbar = new _MenuId("DiffEditorSelectionToolbar");
  }
  /**
   * Create or reuse a `MenuId` with the given identifier
   */
  static for(identifier) {
    return _MenuId._instances.get(identifier) ?? new _MenuId(identifier);
  }
  /**
   * Create a new `MenuId` with the unique identifier. Will throw if a menu
   * with the identifier already exists, use `MenuId.for(ident)` or a unique
   * identifier
   */
  constructor(identifier) {
    if (_MenuId._instances.has(identifier)) {
      throw new TypeError(`MenuId with identifier '${identifier}' already exists. Use MenuId.for(ident) or a unique identifier`);
    }
    _MenuId._instances.set(identifier, this);
    this.id = identifier;
  }
};
var IMenuService = createDecorator("menuService");
var MenuRegistryChangeEvent = class _MenuRegistryChangeEvent {
  static {
    this._all = /* @__PURE__ */ new Map();
  }
  static for(id2) {
    let value = this._all.get(id2);
    if (!value) {
      value = new _MenuRegistryChangeEvent(id2);
      this._all.set(id2, value);
    }
    return value;
  }
  static merge(events) {
    const ids = /* @__PURE__ */ new Set();
    for (const item of events) {
      if (item instanceof _MenuRegistryChangeEvent) {
        ids.add(item.id);
      }
    }
    return ids;
  }
  constructor(id2) {
    this.id = id2;
    this.has = (candidate) => candidate === id2;
  }
};
var MenuRegistry = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
    this._menuItems = /* @__PURE__ */ new Map();
    this._onDidChangeMenu = new MicrotaskEmitter({
      merge: MenuRegistryChangeEvent.merge
    });
    this.onDidChangeMenu = this._onDidChangeMenu.event;
  }
  addCommand(command) {
    this._commands.set(command.id, command);
    this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(MenuId.CommandPalette));
    return markAsSingleton(toDisposable(() => {
      if (this._commands.delete(command.id)) {
        this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(MenuId.CommandPalette));
      }
    }));
  }
  getCommand(id2) {
    return this._commands.get(id2);
  }
  getCommands() {
    const map = /* @__PURE__ */ new Map();
    this._commands.forEach((value, key) => map.set(key, value));
    return map;
  }
  appendMenuItem(id2, item) {
    let list2 = this._menuItems.get(id2);
    if (!list2) {
      list2 = new LinkedList();
      this._menuItems.set(id2, list2);
    }
    const rm = list2.push(item);
    this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(id2));
    return markAsSingleton(toDisposable(() => {
      rm();
      this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(id2));
    }));
  }
  appendMenuItems(items) {
    const result = new DisposableStore();
    for (const { id: id2, item } of items) {
      result.add(this.appendMenuItem(id2, item));
    }
    return result;
  }
  getMenuItems(id2) {
    let result;
    if (this._menuItems.has(id2)) {
      result = [...this._menuItems.get(id2)];
    } else {
      result = [];
    }
    if (id2 === MenuId.CommandPalette) {
      this._appendImplicitItems(result);
    }
    return result;
  }
  _appendImplicitItems(result) {
    const set = /* @__PURE__ */ new Set();
    for (const item of result) {
      if (isIMenuItem(item)) {
        set.add(item.command.id);
        if (item.alt) {
          set.add(item.alt.id);
        }
      }
    }
    this._commands.forEach((command, id2) => {
      if (!set.has(id2)) {
        result.push({ command });
      }
    });
  }
}();
var MenuItemAction = MenuItemAction_1 = class MenuItemAction2 {
  static label(action, options2) {
    return options2?.renderShortTitle && action.shortTitle ? typeof action.shortTitle === "string" ? action.shortTitle : action.shortTitle.value : typeof action.title === "string" ? action.title : action.title.value;
  }
  constructor(item, alt, options2, hideActions, menuKeybinding, contextKeyService, _commandService) {
    this.hideActions = hideActions;
    this.menuKeybinding = menuKeybinding;
    this._commandService = _commandService;
    this.id = item.id;
    this.label = MenuItemAction_1.label(item, options2);
    this.tooltip = (typeof item.tooltip === "string" ? item.tooltip : item.tooltip?.value) ?? "";
    this.enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);
    this.checked = void 0;
    let icon;
    if (item.toggled) {
      const toggled = item.toggled.condition ? item.toggled : { condition: item.toggled };
      this.checked = contextKeyService.contextMatchesRules(toggled.condition);
      if (this.checked && toggled.tooltip) {
        this.tooltip = typeof toggled.tooltip === "string" ? toggled.tooltip : toggled.tooltip.value;
      }
      if (this.checked && ThemeIcon.isThemeIcon(toggled.icon)) {
        icon = toggled.icon;
      }
      if (this.checked && toggled.title) {
        this.label = typeof toggled.title === "string" ? toggled.title : toggled.title.value;
      }
    }
    if (!icon) {
      icon = ThemeIcon.isThemeIcon(item.icon) ? item.icon : void 0;
    }
    this.item = item;
    this.alt = alt ? new MenuItemAction_1(alt, void 0, options2, hideActions, void 0, contextKeyService, _commandService) : void 0;
    this._options = options2;
    this.class = icon && ThemeIcon.asClassName(icon);
  }
  run(...args) {
    let runArgs = [];
    if (this._options?.arg) {
      runArgs = [...runArgs, this._options.arg];
    }
    if (this._options?.shouldForwardArgs) {
      runArgs = [...runArgs, ...args];
    }
    return this._commandService.executeCommand(this.id, ...runArgs);
  }
};
MenuItemAction = MenuItemAction_1 = __decorate([
  __param(5, IContextKeyService),
  __param(6, ICommandService)
], MenuItemAction);

// out-build/vs/workbench/contrib/extensions/common/extensions.js
var EXTENSIONS_CATEGORY = localize2(8534, "Extensions");
var ExtensionState;
(function(ExtensionState2) {
  ExtensionState2[ExtensionState2["Installing"] = 0] = "Installing";
  ExtensionState2[ExtensionState2["Installed"] = 1] = "Installed";
  ExtensionState2[ExtensionState2["Uninstalling"] = 2] = "Uninstalling";
  ExtensionState2[ExtensionState2["Uninstalled"] = 3] = "Uninstalled";
})(ExtensionState || (ExtensionState = {}));
var ExtensionRuntimeActionType;
(function(ExtensionRuntimeActionType2) {
  ExtensionRuntimeActionType2["ReloadWindow"] = "reloadWindow";
  ExtensionRuntimeActionType2["RestartExtensions"] = "restartExtensions";
  ExtensionRuntimeActionType2["DownloadUpdate"] = "downloadUpdate";
  ExtensionRuntimeActionType2["ApplyUpdate"] = "applyUpdate";
  ExtensionRuntimeActionType2["QuitAndInstall"] = "quitAndInstall";
})(ExtensionRuntimeActionType || (ExtensionRuntimeActionType = {}));
var IExtensionsWorkbenchService = createDecorator("extensionsWorkbenchService");
var ExtensionEditorTab;
(function(ExtensionEditorTab2) {
  ExtensionEditorTab2["Readme"] = "readme";
  ExtensionEditorTab2["Features"] = "features";
  ExtensionEditorTab2["Changelog"] = "changelog";
  ExtensionEditorTab2["Dependencies"] = "dependencies";
  ExtensionEditorTab2["ExtensionPack"] = "extensionPack";
})(ExtensionEditorTab || (ExtensionEditorTab = {}));
var ExtensionContainers = class ExtensionContainers2 extends Disposable {
  constructor(containers, extensionsWorkbenchService) {
    super();
    this.containers = containers;
    this._register(extensionsWorkbenchService.onChange(this.update, this));
  }
  set extension(extension) {
    this.containers.forEach((c) => c.extension = extension);
  }
  update(extension) {
    for (const container of this.containers) {
      if (extension && container.extension) {
        if (areSameExtensions(container.extension.identifier, extension.identifier)) {
          if (container.extension.server && extension.server && container.extension.server !== extension.server) {
            if (container.updateWhenCounterExtensionChanges) {
              container.update();
            }
          } else {
            container.extension = extension;
          }
        }
      } else {
        container.update();
      }
    }
  }
};
ExtensionContainers = __decorate([
  __param(1, IExtensionsWorkbenchService)
], ExtensionContainers);
var DefaultViewsContext = new RawContextKey("defaultExtensionViews", true);
var HasOutdatedExtensionsContext = new RawContextKey("hasOutdatedExtensions", false);
var CONTEXT_HAS_GALLERY = new RawContextKey("hasGallery", false);
var CONTEXT_EXTENSIONS_GALLERY_STATUS = new RawContextKey(
  "extensionsGalleryStatus",
  "unavailable"
  /* ExtensionGalleryManifestStatus.Unavailable */
);
var ExtensionResultsListFocused = new RawContextKey("extensionResultListFocused ", true);
var SearchMcpServersContext = new RawContextKey("searchMcpServers", false);
var extensionsSearchActionsMenu = new MenuId("extensionsSearchActionsMenu");
var extensionsFilterSubMenu = new MenuId("extensionsFilterSubMenu");

// out-build/vs/workbench/contrib/extensions/common/searchExtensionsTool.js
var SearchExtensionsToolId = "vscode_searchExtensions_internal";
var SearchExtensionsToolData = {
  id: SearchExtensionsToolId,
  toolReferenceName: "extensions",
  legacyToolReferenceFullNames: ["extensions"],
  icon: ThemeIcon.fromId(Codicon.extensions.id),
  displayName: localize(8554, null),
  modelDescription: "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
  userDescription: localize(8555, null),
  source: ToolDataSource.Internal,
  inputSchema: {
    type: "object",
    properties: {
      category: {
        type: "string",
        description: "The category of extensions to search for",
        enum: EXTENSION_CATEGORIES
      },
      keywords: {
        type: "array",
        items: {
          type: "string"
        },
        description: "The keywords to search for"
      },
      ids: {
        type: "array",
        items: {
          type: "string"
        },
        description: "The ids of the extensions to search for"
      }
    }
  }
};
var SearchExtensionsTool = class SearchExtensionsTool2 {
  constructor(extensionWorkbenchService) {
    this.extensionWorkbenchService = extensionWorkbenchService;
  }
  async invoke(invocation, _countTokens, _progress, token) {
    const params = invocation.parameters;
    if (!params.keywords?.length && !params.category && !params.ids?.length) {
      return {
        content: [{
          kind: "text",
          value: localize(8556, null)
        }]
      };
    }
    const extensionsMap = /* @__PURE__ */ new Map();
    const addExtension = (extensions) => {
      for (const extension of extensions) {
        if (extension.deprecationInfo || extension.isMalicious) {
          continue;
        }
        extensionsMap.set(extension.identifier.id.toLowerCase(), {
          id: extension.identifier.id,
          name: extension.displayName,
          description: extension.description,
          installed: extension.state === 1,
          installCount: extension.installCount ?? 0,
          rating: extension.rating ?? 0,
          categories: extension.categories ?? [],
          tags: extension.gallery?.tags ?? []
        });
      }
    };
    const queryAndAddExtensions = async (text) => {
      const extensions = await this.extensionWorkbenchService.queryGallery({
        text,
        pageSize: 10,
        sortBy: "InstallCount"
        /* SortBy.InstallCount */
      }, token);
      if (extensions.firstPage.length) {
        addExtension(extensions.firstPage);
      }
    };
    if (params.ids?.length) {
      const extensions = await this.extensionWorkbenchService.getExtensions(params.ids.map((id2) => ({ id: id2 })), token);
      addExtension(extensions);
    }
    if (params.keywords?.length) {
      for (const keyword of params.keywords ?? []) {
        if (keyword === "featured") {
          await queryAndAddExtensions("featured");
        } else {
          let text = params.category ? `category:"${params.category}"` : "";
          text = keyword ? `${text} ${keyword}`.trim() : text;
          await queryAndAddExtensions(text);
        }
      }
    } else {
      await queryAndAddExtensions(`category:"${params.category}"`);
    }
    const result = Array.from(extensionsMap.values());
    return {
      content: [{
        kind: "text",
        value: `Here are the list of extensions:
${JSON.stringify(result)}
. Important: Use the following format to display extensions to the user because there is a renderer available to parse these extensions in this format and display them with all details. So, do not describe about the extensions to the user.
\`\`\`vscode-extensions
extensionId1,extensionId2
\`\`\`
.`
      }],
      toolResultDetails: {
        input: JSON.stringify(params),
        output: [{ type: "embed", isText: true, value: JSON.stringify(result.map((extension) => extension.id)) }]
      }
    };
  }
};
SearchExtensionsTool = __decorate([
  __param(0, IExtensionsWorkbenchService)
], SearchExtensionsTool);

// out-build/vs/workbench/api/common/extHostLanguageModelTools.js
var Tool = class {
  constructor(data2) {
    this._apiObject = new Lazy(() => {
      const that = this;
      return Object.freeze({
        get name() {
          return that._data.id;
        },
        get description() {
          return that._data.modelDescription;
        },
        get inputSchema() {
          return that._data.inputSchema;
        },
        get tags() {
          return that._data.tags ?? [];
        },
        get source() {
          return void 0;
        }
      });
    });
    this._apiObjectWithChatParticipantAdditions = new Lazy(() => {
      const that = this;
      const source = LanguageModelToolSource.to(that._data.source);
      return Object.freeze({
        get name() {
          return that._data.id;
        },
        get description() {
          return that._data.modelDescription;
        },
        get inputSchema() {
          return that._data.inputSchema;
        },
        get tags() {
          return that._data.tags ?? [];
        },
        get source() {
          return source;
        }
      });
    });
    this._data = data2;
  }
  update(newData) {
    this._data = newData;
  }
  get data() {
    return this._data;
  }
  get apiObject() {
    return this._apiObject.value;
  }
  get apiObjectWithChatParticipantAdditions() {
    return this._apiObjectWithChatParticipantAdditions.value;
  }
};
var ExtHostLanguageModelTools = class {
  constructor(mainContext, _languageModels) {
    this._languageModels = _languageModels;
    this._registeredTools = /* @__PURE__ */ new Map();
    this._tokenCountFuncs = /* @__PURE__ */ new Map();
    this._allTools = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadLanguageModelTools);
    this._proxy.$getTools().then((tools) => {
      for (const tool of tools) {
        this._allTools.set(tool.id, new Tool(revive(tool)));
      }
    });
  }
  async $countTokensForInvocation(callId, input, token) {
    const fn = this._tokenCountFuncs.get(callId);
    if (!fn) {
      throw new Error(`Tool invocation call ${callId} not found`);
    }
    return await fn(input, token);
  }
  async invokeTool(extension, toolId, options2, token) {
    const callId = generateUuid();
    if (options2.tokenizationOptions) {
      this._tokenCountFuncs.set(callId, options2.tokenizationOptions.countTokens);
    }
    try {
      if (options2.toolInvocationToken && !isToolInvocationContext(options2.toolInvocationToken)) {
        throw new Error(`Invalid tool invocation token`);
      }
      if ((toolId === InternalEditToolId || toolId === ExtensionEditToolId) && !isProposedApiEnabled(extension, "chatParticipantPrivate")) {
        throw new Error(`Invalid tool: ${toolId}`);
      }
      const result = await this._proxy.$invokeTool({
        toolId,
        callId,
        parameters: options2.input,
        tokenBudget: options2.tokenizationOptions?.tokenBudget,
        context: options2.toolInvocationToken,
        chatRequestId: isProposedApiEnabled(extension, "chatParticipantPrivate") ? options2.chatRequestId : void 0,
        chatInteractionId: isProposedApiEnabled(extension, "chatParticipantPrivate") ? options2.chatInteractionId : void 0,
        fromSubAgent: isProposedApiEnabled(extension, "chatParticipantPrivate") ? options2.fromSubAgent : void 0
      }, token);
      const dto = result instanceof SerializableObjectWithBuffers ? result.value : result;
      return LanguageModelToolResult3.to(revive(dto));
    } finally {
      this._tokenCountFuncs.delete(callId);
    }
  }
  $onDidChangeTools(tools) {
    const oldTools = new Set(this._registeredTools.keys());
    for (const tool of tools) {
      oldTools.delete(tool.id);
      const existing = this._allTools.get(tool.id);
      if (existing) {
        existing.update(tool);
      } else {
        this._allTools.set(tool.id, new Tool(revive(tool)));
      }
    }
    for (const id2 of oldTools) {
      this._allTools.delete(id2);
    }
  }
  getTools(extension) {
    const hasParticipantAdditions = isProposedApiEnabled(extension, "chatParticipantPrivate");
    return Array.from(this._allTools.values()).map((tool) => hasParticipantAdditions ? tool.apiObjectWithChatParticipantAdditions : tool.apiObject).filter((tool) => {
      switch (tool.name) {
        case InternalEditToolId:
        case ExtensionEditToolId:
        case InternalFetchWebPageToolId:
        case SearchExtensionsToolId:
          return isProposedApiEnabled(extension, "chatParticipantPrivate");
        default:
          return true;
      }
    });
  }
  async $invokeTool(dto, token) {
    const item = this._registeredTools.get(dto.toolId);
    if (!item) {
      throw new Error(`Unknown tool ${dto.toolId}`);
    }
    const options2 = {
      input: dto.parameters,
      toolInvocationToken: revive(dto.context)
    };
    if (isProposedApiEnabled(item.extension, "chatParticipantPrivate")) {
      options2.chatRequestId = dto.chatRequestId;
      options2.chatInteractionId = dto.chatInteractionId;
      options2.chatSessionId = dto.context?.sessionId;
      options2.fromSubAgent = dto.fromSubAgent;
    }
    if (isProposedApiEnabled(item.extension, "chatParticipantAdditions") && dto.modelId) {
      options2.model = await this.getModel(dto.modelId, item.extension);
    }
    if (dto.tokenBudget !== void 0) {
      options2.tokenizationOptions = {
        tokenBudget: dto.tokenBudget,
        countTokens: this._tokenCountFuncs.get(dto.callId) || ((value, token2 = CancellationToken.None) => this._proxy.$countTokensForInvocation(dto.callId, value, token2))
      };
    }
    let progress;
    if (isProposedApiEnabled(item.extension, "toolProgress")) {
      let lastProgress;
      progress = {
        report: (value) => {
          if (value.increment !== void 0) {
            lastProgress = (lastProgress ?? 0) + value.increment;
          }
          this._proxy.$acceptToolProgress(dto.callId, {
            message: MarkdownString4.fromStrict(value.message),
            progress: lastProgress === void 0 ? void 0 : lastProgress / 100
          });
        }
      };
    }
    const extensionResult = await raceCancellation(Promise.resolve(item.tool.invoke(options2, token, progress)), token);
    if (!extensionResult) {
      throw new CancellationError();
    }
    return LanguageModelToolResult3.from(extensionResult, item.extension);
  }
  async getModel(modelId, extension) {
    let model;
    if (modelId) {
      model = await this._languageModels.getLanguageModelByIdentifier(extension, modelId);
    }
    if (!model) {
      model = await this._languageModels.getDefaultLanguageModel(extension);
      if (!model) {
        throw new Error("Language model unavailable");
      }
    }
    return model;
  }
  async $prepareToolInvocation(toolId, context, token) {
    const item = this._registeredTools.get(toolId);
    if (!item) {
      throw new Error(`Unknown tool ${toolId}`);
    }
    const options2 = {
      input: context.parameters,
      chatRequestId: context.chatRequestId,
      chatSessionId: context.chatSessionId,
      chatInteractionId: context.chatInteractionId
    };
    if (item.tool.prepareInvocation) {
      const result = await item.tool.prepareInvocation(options2, token);
      if (!result) {
        return void 0;
      }
      if (result.pastTenseMessage || result.presentation) {
        checkProposedApiEnabled(item.extension, "chatParticipantPrivate");
      }
      return {
        confirmationMessages: result.confirmationMessages ? {
          title: typeof result.confirmationMessages.title === "string" ? result.confirmationMessages.title : MarkdownString4.from(result.confirmationMessages.title),
          message: typeof result.confirmationMessages.message === "string" ? result.confirmationMessages.message : MarkdownString4.from(result.confirmationMessages.message)
        } : void 0,
        invocationMessage: MarkdownString4.fromStrict(result.invocationMessage),
        pastTenseMessage: MarkdownString4.fromStrict(result.pastTenseMessage),
        presentation: result.presentation
      };
    }
    return void 0;
  }
  registerTool(extension, id2, tool) {
    this._registeredTools.set(id2, { extension, tool });
    this._proxy.$registerTool(id2);
    return toDisposable(() => {
      this._registeredTools.delete(id2);
      this._proxy.$unregisterTool(id2);
    });
  }
};

// out-build/vs/workbench/api/common/extHostLanguages.js
var ExtHostLanguages = class {
  constructor(mainContext, _documents, _commands, _uriTransformer) {
    this._documents = _documents;
    this._commands = _commands;
    this._uriTransformer = _uriTransformer;
    this._languageIds = [];
    this._handlePool = 0;
    this._ids = /* @__PURE__ */ new Set();
    this._proxy = mainContext.getProxy(MainContext.MainThreadLanguages);
  }
  $acceptLanguageIds(ids) {
    this._languageIds = ids;
  }
  async getLanguages() {
    return this._languageIds.slice(0);
  }
  async changeLanguage(uri, languageId) {
    await this._proxy.$changeLanguage(uri, languageId);
    const data2 = this._documents.getDocumentData(uri);
    if (!data2) {
      throw new Error(`document '${uri.toString()}' NOT found`);
    }
    return data2.document;
  }
  async tokenAtPosition(document2, position) {
    const versionNow = document2.version;
    const pos = Position4.from(position);
    const info = await this._proxy.$tokensAtPosition(document2.uri, pos);
    const defaultRange = {
      type: StandardTokenType.Other,
      range: document2.getWordRangeAtPosition(position) ?? new Range2(position.line, position.character, position.line, position.character)
    };
    if (!info) {
      return defaultRange;
    }
    const result = {
      range: Range4.to(info.range),
      type: TokenType2.to(info.type)
    };
    if (!result.range.contains(position)) {
      return defaultRange;
    }
    if (versionNow !== document2.version) {
      return defaultRange;
    }
    return result;
  }
  createLanguageStatusItem(extension, id2, selector) {
    const handle = this._handlePool++;
    const proxy = this._proxy;
    const ids = this._ids;
    const fullyQualifiedId = `${extension.identifier.value}/${id2}`;
    if (ids.has(fullyQualifiedId)) {
      throw new Error(`LanguageStatusItem with id '${id2}' ALREADY exists`);
    }
    ids.add(fullyQualifiedId);
    const data2 = {
      selector,
      id: id2,
      name: extension.displayName ?? extension.name,
      severity: LanguageStatusSeverity.Information,
      command: void 0,
      text: "",
      detail: "",
      busy: false
    };
    let soonHandle;
    const commandDisposables = new DisposableStore();
    const updateAsync = () => {
      soonHandle?.dispose();
      if (!ids.has(fullyQualifiedId)) {
        console.warn(`LanguageStatusItem (${id2}) from ${extension.identifier.value} has been disposed and CANNOT be updated anymore`);
        return;
      }
      soonHandle = disposableTimeout(() => {
        commandDisposables.clear();
        this._proxy.$setLanguageStatus(handle, {
          id: fullyQualifiedId,
          name: data2.name ?? extension.displayName ?? extension.name,
          source: extension.displayName ?? extension.name,
          selector: DocumentSelector.from(data2.selector, this._uriTransformer),
          label: data2.text,
          detail: data2.detail ?? "",
          severity: data2.severity === LanguageStatusSeverity.Error ? severity_default.Error : data2.severity === LanguageStatusSeverity.Warning ? severity_default.Warning : severity_default.Info,
          command: data2.command && this._commands.toInternal(data2.command, commandDisposables),
          accessibilityInfo: data2.accessibilityInformation,
          busy: data2.busy
        });
      }, 0);
    };
    const result = {
      dispose() {
        commandDisposables.dispose();
        soonHandle?.dispose();
        proxy.$removeLanguageStatus(handle);
        ids.delete(fullyQualifiedId);
      },
      get id() {
        return data2.id;
      },
      get name() {
        return data2.name;
      },
      set name(value) {
        data2.name = value;
        updateAsync();
      },
      get selector() {
        return data2.selector;
      },
      set selector(value) {
        data2.selector = value;
        updateAsync();
      },
      get text() {
        return data2.text;
      },
      set text(value) {
        data2.text = value;
        updateAsync();
      },
      set text2(value) {
        checkProposedApiEnabled(extension, "languageStatusText");
        data2.text = value;
        updateAsync();
      },
      get text2() {
        checkProposedApiEnabled(extension, "languageStatusText");
        return data2.text;
      },
      get detail() {
        return data2.detail;
      },
      set detail(value) {
        data2.detail = value;
        updateAsync();
      },
      get severity() {
        return data2.severity;
      },
      set severity(value) {
        data2.severity = value;
        updateAsync();
      },
      get accessibilityInformation() {
        return data2.accessibilityInformation;
      },
      set accessibilityInformation(value) {
        data2.accessibilityInformation = value;
        updateAsync();
      },
      get command() {
        return data2.command;
      },
      set command(value) {
        data2.command = value;
        updateAsync();
      },
      get busy() {
        return data2.busy;
      },
      set busy(value) {
        data2.busy = value;
        updateAsync();
      }
    };
    updateAsync();
    return result;
  }
};

// out-build/vs/workbench/api/common/extHostMessageService.js
function isMessageItem(item) {
  return item && item.title;
}
var ExtHostMessageService = class ExtHostMessageService2 {
  constructor(mainContext, _logService) {
    this._logService = _logService;
    this._proxy = mainContext.getProxy(MainContext.MainThreadMessageService);
  }
  showMessage(extension, severity, message, optionsOrFirstItem, rest) {
    const options2 = {
      source: { identifier: extension.identifier, label: extension.displayName || extension.name }
    };
    let items;
    if (typeof optionsOrFirstItem === "string" || isMessageItem(optionsOrFirstItem)) {
      items = [optionsOrFirstItem, ...rest];
    } else {
      options2.modal = optionsOrFirstItem?.modal;
      options2.useCustom = optionsOrFirstItem?.useCustom;
      options2.detail = optionsOrFirstItem?.detail;
      items = rest;
    }
    if (options2.useCustom) {
      checkProposedApiEnabled(extension, "resolvers");
    }
    const commands = [];
    let hasCloseAffordance = false;
    for (let handle = 0; handle < items.length; handle++) {
      const command = items[handle];
      if (typeof command === "string") {
        commands.push({ title: command, handle, isCloseAffordance: false });
      } else if (typeof command === "object") {
        const { title, isCloseAffordance } = command;
        commands.push({ title, isCloseAffordance: !!isCloseAffordance, handle });
        if (isCloseAffordance) {
          if (hasCloseAffordance) {
            this._logService.warn(`[${extension.identifier}] Only one message item can have 'isCloseAffordance':`, command);
          } else {
            hasCloseAffordance = true;
          }
        }
      } else {
        this._logService.warn(`[${extension.identifier}] Invalid message item:`, command);
      }
    }
    return this._proxy.$showMessage(severity, message, options2, commands).then((handle) => {
      if (typeof handle === "number") {
        return items[handle];
      }
      return void 0;
    });
  }
};
ExtHostMessageService = __decorate([
  __param(1, ILogService)
], ExtHostMessageService);

// out-build/vs/workbench/api/common/extHostNotebookDocument.js
var RawContentChangeEvent = class {
  constructor(start, deletedCount, deletedItems, items) {
    this.start = start;
    this.deletedCount = deletedCount;
    this.deletedItems = deletedItems;
    this.items = items;
  }
  asApiEvent() {
    return {
      range: new NotebookRange(this.start, this.start + this.deletedCount),
      addedCells: this.items.map((cell) => cell.apiCell),
      removedCells: this.deletedItems
    };
  }
};
var ExtHostCell = class {
  static asModelAddData(cell) {
    return {
      EOL: cell.eol,
      lines: cell.source,
      languageId: cell.language,
      uri: cell.uri,
      isDirty: false,
      versionId: 1,
      encoding: "utf8"
    };
  }
  constructor(notebook, _extHostDocument, _cellData) {
    this.notebook = notebook;
    this._extHostDocument = _extHostDocument;
    this._cellData = _cellData;
    this.handle = _cellData.handle;
    this.uri = URI.revive(_cellData.uri);
    this.cellKind = _cellData.cellKind;
    this._outputs = _cellData.outputs.map(NotebookCellOutput2.to);
    this._internalMetadata = _cellData.internalMetadata ?? {};
    this._metadata = Object.freeze(_cellData.metadata ?? {});
    this._previousResult = Object.freeze(NotebookCellExecutionSummary.to(_cellData.internalMetadata ?? {}));
  }
  get internalMetadata() {
    return this._internalMetadata;
  }
  get apiCell() {
    if (!this._apiCell) {
      const that = this;
      const data2 = this._extHostDocument.getDocument(this.uri);
      if (!data2) {
        throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`);
      }
      const apiCell = {
        get index() {
          return that.notebook.getCellIndex(that);
        },
        notebook: that.notebook.apiNotebook,
        kind: NotebookCellKind2.to(this._cellData.cellKind),
        document: data2.document,
        get mime() {
          return that._mime;
        },
        set mime(value) {
          that._mime = value;
        },
        get outputs() {
          return that._outputs.slice(0);
        },
        get metadata() {
          return that._metadata;
        },
        get executionSummary() {
          return that._previousResult;
        }
      };
      this._apiCell = Object.freeze(apiCell);
    }
    return this._apiCell;
  }
  setOutputs(newOutputs) {
    this._outputs = newOutputs.map(NotebookCellOutput2.to);
  }
  setOutputItems(outputId, append, newOutputItems) {
    const newItems = newOutputItems.map(NotebookCellOutputItem2.to);
    const output = this._outputs.find((op) => op.id === outputId);
    if (output) {
      if (!append) {
        output.items.length = 0;
      }
      output.items.push(...newItems);
      if (output.items.length > 1 && output.items.every((item) => isTextStreamMime(item.mime))) {
        const mimeOutputs = /* @__PURE__ */ new Map();
        const mimeTypes = [];
        output.items.forEach((item) => {
          let items;
          if (mimeOutputs.has(item.mime)) {
            items = mimeOutputs.get(item.mime);
          } else {
            items = [];
            mimeOutputs.set(item.mime, items);
            mimeTypes.push(item.mime);
          }
          items.push(item.data);
        });
        output.items.length = 0;
        mimeTypes.forEach((mime) => {
          const compressed = compressOutputItemStreams(mimeOutputs.get(mime));
          output.items.push({
            mime,
            data: compressed.data.buffer
          });
        });
      }
    }
  }
  setMetadata(newMetadata) {
    this._metadata = Object.freeze(newMetadata);
  }
  setInternalMetadata(newInternalMetadata) {
    this._internalMetadata = newInternalMetadata;
    this._previousResult = Object.freeze(NotebookCellExecutionSummary.to(newInternalMetadata));
  }
  setMime(newMime) {
  }
};
var ExtHostNotebookDocument = class _ExtHostNotebookDocument {
  static {
    this._handlePool = 0;
  }
  constructor(_proxy, _textDocumentsAndEditors, _textDocuments, uri, data2) {
    this._proxy = _proxy;
    this._textDocumentsAndEditors = _textDocumentsAndEditors;
    this._textDocuments = _textDocuments;
    this.uri = uri;
    this.handle = _ExtHostNotebookDocument._handlePool++;
    this._cells = [];
    this._versionId = 0;
    this._isDirty = false;
    this._disposed = false;
    this._notebookType = data2.viewType;
    this._metadata = Object.freeze(data2.metadata ?? /* @__PURE__ */ Object.create(null));
    this._spliceNotebookCells([[0, 0, data2.cells]], true, void 0);
    this._versionId = data2.versionId;
  }
  dispose() {
    this._disposed = true;
  }
  get versionId() {
    return this._versionId;
  }
  get apiNotebook() {
    if (!this._notebook) {
      const that = this;
      const apiObject = {
        get uri() {
          return that.uri;
        },
        get version() {
          return that._versionId;
        },
        get notebookType() {
          return that._notebookType;
        },
        get isDirty() {
          return that._isDirty;
        },
        get isUntitled() {
          return that.uri.scheme === Schemas.untitled;
        },
        get isClosed() {
          return that._disposed;
        },
        get metadata() {
          return that._metadata;
        },
        get cellCount() {
          return that._cells.length;
        },
        cellAt(index) {
          index = that._validateIndex(index);
          return that._cells[index].apiCell;
        },
        getCells(range) {
          const cells = range ? that._getCells(range) : that._cells;
          return cells.map((cell) => cell.apiCell);
        },
        save() {
          return that._save();
        },
        [Symbol.for("debug.description")]() {
          return `NotebookDocument(${this.uri.toString()})`;
        }
      };
      this._notebook = Object.freeze(apiObject);
    }
    return this._notebook;
  }
  acceptDocumentPropertiesChanged(data2) {
    if (data2.metadata) {
      this._metadata = Object.freeze({ ...this._metadata, ...data2.metadata });
    }
  }
  acceptDirty(isDirty) {
    this._isDirty = isDirty;
  }
  acceptModelChanged(event, isDirty, newMetadata) {
    this._versionId = event.versionId;
    this._isDirty = isDirty;
    this.acceptDocumentPropertiesChanged({ metadata: newMetadata });
    const result = {
      notebook: this.apiNotebook,
      metadata: newMetadata,
      cellChanges: [],
      contentChanges: []
    };
    const relaxedCellChanges = [];
    for (const rawEvent of event.rawEvents) {
      if (rawEvent.kind === NotebookCellsChangeType.ModelChange) {
        this._spliceNotebookCells(rawEvent.changes, false, result.contentChanges);
      } else if (rawEvent.kind === NotebookCellsChangeType.Move) {
        this._moveCells(rawEvent.index, rawEvent.length, rawEvent.newIdx, result.contentChanges);
      } else if (rawEvent.kind === NotebookCellsChangeType.Output) {
        this._setCellOutputs(rawEvent.index, rawEvent.outputs);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, outputs: this._cells[rawEvent.index].apiCell.outputs });
      } else if (rawEvent.kind === NotebookCellsChangeType.OutputItem) {
        this._setCellOutputItems(rawEvent.index, rawEvent.outputId, rawEvent.append, rawEvent.outputItems);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, outputs: this._cells[rawEvent.index].apiCell.outputs });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellLanguage) {
        this._changeCellLanguage(rawEvent.index, rawEvent.language);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, document: this._cells[rawEvent.index].apiCell.document });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellContent) {
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, document: this._cells[rawEvent.index].apiCell.document });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellMime) {
        this._changeCellMime(rawEvent.index, rawEvent.mime);
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellMetadata) {
        this._changeCellMetadata(rawEvent.index, rawEvent.metadata);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, metadata: this._cells[rawEvent.index].apiCell.metadata });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellInternalMetadata) {
        this._changeCellInternalMetadata(rawEvent.index, rawEvent.internalMetadata);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, executionSummary: this._cells[rawEvent.index].apiCell.executionSummary });
      }
    }
    const map = /* @__PURE__ */ new Map();
    for (let i = 0; i < relaxedCellChanges.length; i++) {
      const relaxedCellChange = relaxedCellChanges[i];
      const existing = map.get(relaxedCellChange.cell);
      if (existing === void 0) {
        const newLen = result.cellChanges.push({
          document: void 0,
          executionSummary: void 0,
          metadata: void 0,
          outputs: void 0,
          ...relaxedCellChange
        });
        map.set(relaxedCellChange.cell, newLen - 1);
      } else {
        result.cellChanges[existing] = {
          ...result.cellChanges[existing],
          ...relaxedCellChange
        };
      }
    }
    Object.freeze(result);
    Object.freeze(result.cellChanges);
    Object.freeze(result.contentChanges);
    return result;
  }
  _validateIndex(index) {
    index = index | 0;
    if (index < 0) {
      return 0;
    } else if (index >= this._cells.length) {
      return this._cells.length - 1;
    } else {
      return index;
    }
  }
  _validateRange(range) {
    let start = range.start | 0;
    let end = range.end | 0;
    if (start < 0) {
      start = 0;
    }
    if (end > this._cells.length) {
      end = this._cells.length;
    }
    return range.with({ start, end });
  }
  _getCells(range) {
    range = this._validateRange(range);
    const result = [];
    for (let i = range.start; i < range.end; i++) {
      result.push(this._cells[i]);
    }
    return result;
  }
  async _save() {
    if (this._disposed) {
      return Promise.reject(new Error("Notebook has been closed"));
    }
    return this._proxy.$trySaveNotebook(this.uri);
  }
  _spliceNotebookCells(splices, initialization, bucket) {
    if (this._disposed) {
      return;
    }
    const contentChangeEvents = [];
    const addedCellDocuments = [];
    const removedCellDocuments = [];
    splices.reverse().forEach((splice) => {
      const cellDtos = splice[2];
      const newCells = cellDtos.map((cell) => {
        const extCell = new ExtHostCell(this, this._textDocumentsAndEditors, cell);
        if (!initialization) {
          addedCellDocuments.push(ExtHostCell.asModelAddData(cell));
        }
        return extCell;
      });
      const changeEvent = new RawContentChangeEvent(splice[0], splice[1], [], newCells);
      const deletedItems = this._cells.splice(splice[0], splice[1], ...newCells);
      for (const cell of deletedItems) {
        removedCellDocuments.push(cell.uri);
        changeEvent.deletedItems.push(cell.apiCell);
      }
      contentChangeEvents.push(changeEvent);
    });
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      addedDocuments: addedCellDocuments,
      removedDocuments: removedCellDocuments
    });
    if (bucket) {
      for (const changeEvent of contentChangeEvents) {
        bucket.push(changeEvent.asApiEvent());
      }
    }
  }
  _moveCells(index, length, newIdx, bucket) {
    const cells = this._cells.splice(index, length);
    this._cells.splice(newIdx, 0, ...cells);
    const changes = [
      new RawContentChangeEvent(index, length, cells.map((c) => c.apiCell), []),
      new RawContentChangeEvent(newIdx, 0, [], cells)
    ];
    for (const change of changes) {
      bucket.push(change.asApiEvent());
    }
  }
  _setCellOutputs(index, outputs) {
    const cell = this._cells[index];
    cell.setOutputs(outputs);
  }
  _setCellOutputItems(index, outputId, append, outputItems) {
    const cell = this._cells[index];
    cell.setOutputItems(outputId, append, outputItems);
  }
  _changeCellLanguage(index, newLanguageId) {
    const cell = this._cells[index];
    if (cell.apiCell.document.languageId !== newLanguageId) {
      this._textDocuments.$acceptModelLanguageChanged(cell.uri, newLanguageId);
    }
  }
  _changeCellMime(index, newMime) {
    const cell = this._cells[index];
    cell.apiCell.mime = newMime;
  }
  _changeCellMetadata(index, newMetadata) {
    const cell = this._cells[index];
    cell.setMetadata(newMetadata);
  }
  _changeCellInternalMetadata(index, newInternalMetadata) {
    const cell = this._cells[index];
    cell.setInternalMetadata(newInternalMetadata);
  }
  getCellFromApiCell(apiCell) {
    return this._cells.find((cell) => cell.apiCell === apiCell);
  }
  getCellFromIndex(index) {
    return this._cells[index];
  }
  getCell(cellHandle) {
    return this._cells.find((cell) => cell.handle === cellHandle);
  }
  getCellIndex(cell) {
    return this._cells.indexOf(cell);
  }
};

// out-build/vs/workbench/api/common/extHostNotebookEditor.js
var ExtHostNotebookEditor = class _ExtHostNotebookEditor {
  static {
    this.apiEditorsToExtHost = /* @__PURE__ */ new WeakMap();
  }
  constructor(id2, _proxy, notebookData, _visibleRanges, _selections, _viewColumn, viewType) {
    this.id = id2;
    this._proxy = _proxy;
    this.notebookData = notebookData;
    this._visibleRanges = _visibleRanges;
    this._selections = _selections;
    this._viewColumn = _viewColumn;
    this.viewType = viewType;
    this._visible = false;
  }
  get apiEditor() {
    if (!this._editor) {
      const that = this;
      this._editor = {
        get notebook() {
          return that.notebookData.apiNotebook;
        },
        get selection() {
          return that._selections[0];
        },
        set selection(selection) {
          this.selections = [selection];
        },
        get selections() {
          return that._selections;
        },
        set selections(value) {
          if (!Array.isArray(value) || !value.every(NotebookRange.isNotebookRange)) {
            throw illegalArgument("selections");
          }
          that._selections = value.length === 0 ? [new NotebookRange(0, 0)] : value;
          that._trySetSelections(that._selections);
        },
        get visibleRanges() {
          return that._visibleRanges;
        },
        revealRange(range, revealType) {
          that._proxy.$tryRevealRange(that.id, NotebookRange2.from(range), revealType ?? NotebookEditorRevealType2.Default);
        },
        get viewColumn() {
          return that._viewColumn;
        },
        get replOptions() {
          if (that.viewType === "repl") {
            return { appendIndex: this.notebook.cellCount - 1 };
          }
          return void 0;
        },
        [Symbol.for("debug.description")]() {
          return `NotebookEditor(${this.notebook.uri.toString()})`;
        }
      };
      _ExtHostNotebookEditor.apiEditorsToExtHost.set(this._editor, this);
    }
    return this._editor;
  }
  get visible() {
    return this._visible;
  }
  _acceptVisibility(value) {
    this._visible = value;
  }
  _acceptVisibleRanges(value) {
    this._visibleRanges = value;
  }
  _acceptSelections(selections) {
    this._selections = selections;
  }
  _trySetSelections(value) {
    this._proxy.$trySetSelections(this.id, value.map(NotebookRange2.from));
  }
  _acceptViewColumn(value) {
    this._viewColumn = value;
  }
};

// out-build/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js
var TreeNode = class {
  constructor(piece, color) {
    this.piece = piece;
    this.color = color;
    this.size_left = 0;
    this.lf_left = 0;
    this.parent = this;
    this.left = this;
    this.right = this;
  }
  next() {
    if (this.right !== SENTINEL) {
      return leftest(this.right);
    }
    let node = this;
    while (node.parent !== SENTINEL) {
      if (node.parent.left === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL) {
      return SENTINEL;
    } else {
      return node.parent;
    }
  }
  prev() {
    if (this.left !== SENTINEL) {
      return righttest(this.left);
    }
    let node = this;
    while (node.parent !== SENTINEL) {
      if (node.parent.right === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL) {
      return SENTINEL;
    } else {
      return node.parent;
    }
  }
  detach() {
    this.parent = null;
    this.left = null;
    this.right = null;
  }
};
var NodeColor;
(function(NodeColor2) {
  NodeColor2[NodeColor2["Black"] = 0] = "Black";
  NodeColor2[NodeColor2["Red"] = 1] = "Red";
})(NodeColor || (NodeColor = {}));
var SENTINEL = new TreeNode(
  null,
  0
  /* NodeColor.Black */
);
SENTINEL.parent = SENTINEL;
SENTINEL.left = SENTINEL;
SENTINEL.right = SENTINEL;
SENTINEL.color = 0;
function leftest(node) {
  while (node.left !== SENTINEL) {
    node = node.left;
  }
  return node;
}
function righttest(node) {
  while (node.right !== SENTINEL) {
    node = node.right;
  }
  return node;
}
function calculateSize(node) {
  if (node === SENTINEL) {
    return 0;
  }
  return node.size_left + node.piece.length + calculateSize(node.right);
}
function calculateLF(node) {
  if (node === SENTINEL) {
    return 0;
  }
  return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
}
function resetSentinel() {
  SENTINEL.parent = SENTINEL;
}
function leftRotate2(tree, x) {
  const y = x.right;
  y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  x.right = y.left;
  if (y.left !== SENTINEL) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL) {
    tree.root = y;
  } else if (x.parent.left === x) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
}
function rightRotate(tree, y) {
  const x = y.left;
  y.left = x.right;
  if (x.right !== SENTINEL) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  if (y.parent === SENTINEL) {
    tree.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
}
function rbDelete(tree, z) {
  let x;
  let y;
  if (z.left === SENTINEL) {
    y = z;
    x = y.right;
  } else if (z.right === SENTINEL) {
    y = z;
    x = y.left;
  } else {
    y = leftest(z.right);
    x = y.right;
  }
  if (y === tree.root) {
    tree.root = x;
    x.color = 0;
    z.detach();
    resetSentinel();
    tree.root.parent = SENTINEL;
    return;
  }
  const yWasRed = y.color === 1;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
    recomputeTreeMetadata(tree, x);
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    recomputeTreeMetadata(tree, x);
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    y.color = z.color;
    if (z === tree.root) {
      tree.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL) {
      y.right.parent = y;
    }
    y.size_left = z.size_left;
    y.lf_left = z.lf_left;
    recomputeTreeMetadata(tree, y);
  }
  z.detach();
  if (x.parent.left === x) {
    const newSizeLeft = calculateSize(x);
    const newLFLeft = calculateLF(x);
    if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
      const delta3 = newSizeLeft - x.parent.size_left;
      const lf_delta = newLFLeft - x.parent.lf_left;
      x.parent.size_left = newSizeLeft;
      x.parent.lf_left = newLFLeft;
      updateTreeMetadata(tree, x.parent, delta3, lf_delta);
    }
  }
  recomputeTreeMetadata(tree, x.parent);
  if (yWasRed) {
    resetSentinel();
    return;
  }
  let w;
  while (x !== tree.root && x.color === 0) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        leftRotate2(tree, x.parent);
        w = x.parent.right;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.right.color === 0) {
          w.left.color = 0;
          w.color = 1;
          rightRotate(tree, w);
          w = x.parent.right;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.right.color = 0;
        leftRotate2(tree, x.parent);
        x = tree.root;
      }
    } else {
      w = x.parent.left;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        rightRotate(tree, x.parent);
        w = x.parent.left;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.left.color === 0) {
          w.right.color = 0;
          w.color = 1;
          leftRotate2(tree, w);
          w = x.parent.left;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.left.color = 0;
        rightRotate(tree, x.parent);
        x = tree.root;
      }
    }
  }
  x.color = 0;
  resetSentinel();
}
function fixInsert(tree, x) {
  recomputeTreeMetadata(tree, x);
  while (x !== tree.root && x.parent.color === 1) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate2(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        rightRotate(tree, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        leftRotate2(tree, x.parent.parent);
      }
    }
  }
  tree.root.color = 0;
}
function updateTreeMetadata(tree, x, delta3, lineFeedCntDelta) {
  while (x !== tree.root && x !== SENTINEL) {
    if (x.parent.left === x) {
      x.parent.size_left += delta3;
      x.parent.lf_left += lineFeedCntDelta;
    }
    x = x.parent;
  }
}
function recomputeTreeMetadata(tree, x) {
  let delta3 = 0;
  let lf_delta = 0;
  if (x === tree.root) {
    return;
  }
  while (x !== tree.root && x === x.parent.right) {
    x = x.parent;
  }
  if (x === tree.root) {
    return;
  }
  x = x.parent;
  delta3 = calculateSize(x.left) - x.size_left;
  lf_delta = calculateLF(x.left) - x.lf_left;
  x.size_left += delta3;
  x.lf_left += lf_delta;
  while (x !== tree.root && (delta3 !== 0 || lf_delta !== 0)) {
    if (x.parent.left === x) {
      x.parent.size_left += delta3;
      x.parent.lf_left += lf_delta;
    }
    x = x.parent;
  }
}

// out-build/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js
var AverageBufferSize = 65535;
function createUintArray(arr) {
  let r;
  if (arr[arr.length - 1] < 65536) {
    r = new Uint16Array(arr.length);
  } else {
    r = new Uint32Array(arr.length);
  }
  r.set(arr, 0);
  return r;
}
var LineStarts = class {
  constructor(lineStarts, cr, lf, crlf, isBasicASCII2) {
    this.lineStarts = lineStarts;
    this.cr = cr;
    this.lf = lf;
    this.crlf = crlf;
    this.isBasicASCII = isBasicASCII2;
  }
};
function createLineStartsFast(str, readonly = true) {
  const r = [0];
  let rLength = 1;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        r[rLength++] = i + 2;
        i++;
      } else {
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      r[rLength++] = i + 1;
    }
  }
  if (readonly) {
    return createUintArray(r);
  } else {
    return r;
  }
}
function createLineStarts(r, str) {
  r.length = 0;
  r[0] = 0;
  let rLength = 1;
  let cr = 0, lf = 0, crlf = 0;
  let isBasicASCII2 = true;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        crlf++;
        r[rLength++] = i + 2;
        i++;
      } else {
        cr++;
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      lf++;
      r[rLength++] = i + 1;
    } else {
      if (isBasicASCII2) {
        if (chr !== 9 && (chr < 32 || chr > 126)) {
          isBasicASCII2 = false;
        }
      }
    }
  }
  const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII2);
  r.length = 0;
  return result;
}
var Piece = class {
  constructor(bufferIndex, start, end, lineFeedCnt, length) {
    this.bufferIndex = bufferIndex;
    this.start = start;
    this.end = end;
    this.lineFeedCnt = lineFeedCnt;
    this.length = length;
  }
};
var StringBuffer = class {
  constructor(buffer, lineStarts) {
    this.buffer = buffer;
    this.lineStarts = lineStarts;
  }
};
var PieceTreeSnapshot = class {
  constructor(tree, BOM) {
    this._pieces = [];
    this._tree = tree;
    this._BOM = BOM;
    this._index = 0;
    if (tree.root !== SENTINEL) {
      tree.iterate(tree.root, (node) => {
        if (node !== SENTINEL) {
          this._pieces.push(node.piece);
        }
        return true;
      });
    }
  }
  read() {
    if (this._pieces.length === 0) {
      if (this._index === 0) {
        this._index++;
        return this._BOM;
      } else {
        return null;
      }
    }
    if (this._index > this._pieces.length - 1) {
      return null;
    }
    if (this._index === 0) {
      return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
    }
    return this._tree.getPieceContent(this._pieces[this._index++]);
  }
};
var PieceTreeSearchCache = class {
  constructor(limit) {
    this._limit = limit;
    this._cache = [];
  }
  get(offset) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const nodePos = this._cache[i];
      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
        return nodePos;
      }
    }
    return null;
  }
  get2(lineNumber) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const nodePos = this._cache[i];
      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
        return nodePos;
      }
    }
    return null;
  }
  set(nodePosition) {
    if (this._cache.length >= this._limit) {
      this._cache.shift();
    }
    this._cache.push(nodePosition);
  }
  validate(offset) {
    let hasInvalidVal = false;
    const tmp = this._cache;
    for (let i = 0; i < tmp.length; i++) {
      const nodePos = tmp[i];
      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
        tmp[i] = null;
        hasInvalidVal = true;
        continue;
      }
    }
    if (hasInvalidVal) {
      const newArr = [];
      for (const entry of tmp) {
        if (entry !== null) {
          newArr.push(entry);
        }
      }
      this._cache = newArr;
    }
  }
};
var PieceTreeBase = class {
  constructor(chunks, eol, eolNormalized) {
    this.create(chunks, eol, eolNormalized);
  }
  create(chunks, eol, eolNormalized) {
    this._buffers = [
      new StringBuffer("", [0])
    ];
    this._lastChangeBufferPos = { line: 0, column: 0 };
    this.root = SENTINEL;
    this._lineCnt = 1;
    this._length = 0;
    this._EOL = eol;
    this._EOLLength = eol.length;
    this._EOLNormalized = eolNormalized;
    let lastNode = null;
    for (let i = 0, len = chunks.length; i < len; i++) {
      if (chunks[i].buffer.length > 0) {
        if (!chunks[i].lineStarts) {
          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
        }
        const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
        this._buffers.push(chunks[i]);
        lastNode = this.rbInsertRight(lastNode, piece);
      }
    }
    this._searchCache = new PieceTreeSearchCache(1);
    this._lastVisitedLine = { lineNumber: 0, value: "" };
    this.computeBufferMetadata();
  }
  normalizeEOL(eol) {
    const averageBufferSize = AverageBufferSize;
    const min = averageBufferSize - Math.floor(averageBufferSize / 3);
    const max = min * 2;
    let tempChunk = "";
    let tempChunkLen = 0;
    const chunks = [];
    this.iterate(this.root, (node) => {
      const str = this.getNodeContent(node);
      const len = str.length;
      if (tempChunkLen <= min || tempChunkLen + len < max) {
        tempChunk += str;
        tempChunkLen += len;
        return true;
      }
      const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
      tempChunk = str;
      tempChunkLen = len;
      return true;
    });
    if (tempChunkLen > 0) {
      const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
    }
    this.create(chunks, eol, true);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(newEOL) {
    this._EOL = newEOL;
    this._EOLLength = this._EOL.length;
    this.normalizeEOL(newEOL);
  }
  createSnapshot(BOM) {
    return new PieceTreeSnapshot(this, BOM);
  }
  equal(other) {
    if (this.getLength() !== other.getLength()) {
      return false;
    }
    if (this.getLineCount() !== other.getLineCount()) {
      return false;
    }
    let offset = 0;
    const ret = this.iterate(this.root, (node) => {
      if (node === SENTINEL) {
        return true;
      }
      const str = this.getNodeContent(node);
      const len = str.length;
      const startPosition = other.nodeAt(offset);
      const endPosition = other.nodeAt(offset + len);
      const val = other.getValueInRange2(startPosition, endPosition);
      offset += len;
      return str === val;
    });
    return ret;
  }
  getOffsetAt(lineNumber, column) {
    let leftLen = 0;
    let x = this.root;
    while (x !== SENTINEL) {
      if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
        leftLen += x.size_left;
        const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        return leftLen += accumualtedValInCurrentIndex + column - 1;
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        leftLen += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return leftLen;
  }
  getPositionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    let x = this.root;
    let lfCnt = 0;
    const originalOffset = offset;
    while (x !== SENTINEL) {
      if (x.size_left !== 0 && x.size_left >= offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        const out = this.getIndexOf(x, offset - x.size_left);
        lfCnt += x.lf_left + out.index;
        if (out.index === 0) {
          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          const column = originalOffset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        }
        return new Position(lfCnt + 1, out.remainder + 1);
      } else {
        offset -= x.size_left + x.piece.length;
        lfCnt += x.lf_left + x.piece.lineFeedCnt;
        if (x.right === SENTINEL) {
          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          const column = originalOffset - offset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        } else {
          x = x.right;
        }
      }
    }
    return new Position(1, 1);
  }
  getValueInRange(range, eol) {
    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
      return "";
    }
    const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);
    const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);
    const value = this.getValueInRange2(startPosition, endPosition);
    if (eol) {
      if (eol !== this._EOL || !this._EOLNormalized) {
        return value.replace(/\r\n|\r|\n/g, eol);
      }
      if (eol === this.getEOL() && this._EOLNormalized) {
        if (eol === "\r\n") {
        }
        return value;
      }
      return value.replace(/\r\n|\r|\n/g, eol);
    }
    return value;
  }
  getValueInRange2(startPosition, endPosition) {
    if (startPosition.node === endPosition.node) {
      const node = startPosition.node;
      const buffer2 = this._buffers[node.piece.bufferIndex].buffer;
      const startOffset2 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
      return buffer2.substring(startOffset2 + startPosition.remainder, startOffset2 + endPosition.remainder);
    }
    let x = startPosition.node;
    const buffer = this._buffers[x.piece.bufferIndex].buffer;
    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
    let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
    x = x.next();
    while (x !== SENTINEL) {
      const buffer2 = this._buffers[x.piece.bufferIndex].buffer;
      const startOffset2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (x === endPosition.node) {
        ret += buffer2.substring(startOffset2, startOffset2 + endPosition.remainder);
        break;
      } else {
        ret += buffer2.substr(startOffset2, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  getLinesContent() {
    const lines = [];
    let linesLength = 0;
    let currentLine = "";
    let danglingCR = false;
    this.iterate(this.root, (node) => {
      if (node === SENTINEL) {
        return true;
      }
      const piece = node.piece;
      let pieceLength = piece.length;
      if (pieceLength === 0) {
        return true;
      }
      const buffer = this._buffers[piece.bufferIndex].buffer;
      const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
      const pieceStartLine = piece.start.line;
      const pieceEndLine = piece.end.line;
      let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;
      if (danglingCR) {
        if (buffer.charCodeAt(pieceStartOffset) === 10) {
          pieceStartOffset++;
          pieceLength--;
        }
        lines[linesLength++] = currentLine;
        currentLine = "";
        danglingCR = false;
        if (pieceLength === 0) {
          return true;
        }
      }
      if (pieceStartLine === pieceEndLine) {
        if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13) {
          danglingCR = true;
          currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);
        } else {
          currentLine += buffer.substr(pieceStartOffset, pieceLength);
        }
        return true;
      }
      currentLine += this._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, "");
      lines[linesLength++] = currentLine;
      for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {
        currentLine = this._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\r\n|\r|\n)$/, "");
        lines[linesLength++] = currentLine;
      }
      if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13) {
        danglingCR = true;
        if (piece.end.column === 0) {
          linesLength--;
        } else {
          currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);
        }
      } else {
        currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);
      }
      return true;
    });
    if (danglingCR) {
      lines[linesLength++] = currentLine;
      currentLine = "";
    }
    lines[linesLength++] = currentLine;
    return lines;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(lineNumber) {
    if (this._lastVisitedLine.lineNumber === lineNumber) {
      return this._lastVisitedLine.value;
    }
    this._lastVisitedLine.lineNumber = lineNumber;
    if (lineNumber === this._lineCnt) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
    } else if (this._EOLNormalized) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
    } else {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, "");
    }
    return this._lastVisitedLine.value;
  }
  _getCharCode(nodePos) {
    if (nodePos.remainder === nodePos.node.piece.length) {
      const matchingNode = nodePos.node.next();
      if (!matchingNode) {
        return 0;
      }
      const buffer = this._buffers[matchingNode.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
      return buffer.buffer.charCodeAt(startOffset);
    } else {
      const buffer = this._buffers[nodePos.node.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
      const targetOffset = startOffset + nodePos.remainder;
      return buffer.buffer.charCodeAt(targetOffset);
    }
  }
  getLineCharCode(lineNumber, index) {
    const nodePos = this.nodeAt2(lineNumber, index + 1);
    return this._getCharCode(nodePos);
  }
  getLineLength(lineNumber) {
    if (lineNumber === this.getLineCount()) {
      const startOffset = this.getOffsetAt(lineNumber, 1);
      return this.getLength() - startOffset;
    }
    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
  }
  getCharCode(offset) {
    const nodePos = this.nodeAt(offset);
    return this._getCharCode(nodePos);
  }
  getNearestChunk(offset) {
    const nodePos = this.nodeAt(offset);
    if (nodePos.remainder === nodePos.node.piece.length) {
      const matchingNode = nodePos.node.next();
      if (!matchingNode || matchingNode === SENTINEL) {
        return "";
      }
      const buffer = this._buffers[matchingNode.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
      return buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);
    } else {
      const buffer = this._buffers[nodePos.node.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
      const targetOffset = startOffset + nodePos.remainder;
      const targetEnd = startOffset + nodePos.node.piece.length;
      return buffer.buffer.substring(targetOffset, targetEnd);
    }
  }
  findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
    const buffer = this._buffers[node.piece.bufferIndex];
    const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
    const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
    const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
    let m;
    const ret = { line: 0, column: 0 };
    let searchText;
    let offsetInBuffer;
    if (searcher._wordSeparators) {
      searchText = buffer.buffer.substring(start, end);
      offsetInBuffer = (offset) => offset + start;
      searcher.reset(0);
    } else {
      searchText = buffer.buffer;
      offsetInBuffer = (offset) => offset;
      searcher.reset(start);
    }
    do {
      m = searcher.next(searchText);
      if (m) {
        if (offsetInBuffer(m.index) >= end) {
          return resultLen;
        }
        this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);
        const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
        const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
        const retEndColumn = retStartColumn + m[0].length;
        result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
        if (offsetInBuffer(m.index) + m[0].length >= end) {
          return resultLen;
        }
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    const result = [];
    let resultLen = 0;
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
    if (startPosition === null) {
      return [];
    }
    const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
    if (endPosition === null) {
      return [];
    }
    let start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    const end = this.positionInBuffer(endPosition.node, endPosition.remainder);
    if (startPosition.node === endPosition.node) {
      this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
      return result;
    }
    let startLineNumber = searchRange.startLineNumber;
    let currentNode = startPosition.node;
    while (currentNode !== endPosition.node) {
      const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
      if (lineBreakCnt >= 1) {
        const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
        const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
        const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
        const startColumn3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
        resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn3, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
        if (resultLen >= limitResultCount) {
          return result;
        }
        startLineNumber += lineBreakCnt;
      }
      const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      if (startLineNumber === searchRange.endLineNumber) {
        const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
        resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
        return result;
      }
      resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn2), startLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
      if (resultLen >= limitResultCount) {
        return result;
      }
      startLineNumber++;
      startPosition = this.nodeAt2(startLineNumber, 1);
      currentNode = startPosition.node;
      start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    }
    if (startLineNumber === searchRange.endLineNumber) {
      const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
      return result;
    }
    const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
    resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
    return result;
  }
  _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
    const wordSeparators2 = searchData.wordSeparators;
    if (!captureMatches && searchData.simpleSearch) {
      const searchString = searchData.simpleSearch;
      const searchStringLen = searchString.length;
      const textLength = text.length;
      let lastMatchIndex = -searchStringLen;
      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
        if (!wordSeparators2 || isValidMatch(wordSeparators2, text, textLength, lastMatchIndex, searchStringLen)) {
          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
          if (resultLen >= limitResultCount) {
            return resultLen;
          }
        }
      }
      return resultLen;
    }
    let m;
    searcher.reset(0);
    do {
      m = searcher.next(text);
      if (m) {
        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  // #endregion
  // #region Piece Table
  insert(offset, value, eolNormalized = false) {
    this._EOLNormalized = this._EOLNormalized && eolNormalized;
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (this.root !== SENTINEL) {
      const { node, remainder, nodeStartOffset } = this.nodeAt(offset);
      const piece = node.piece;
      const bufferIndex = piece.bufferIndex;
      const insertPosInBuffer = this.positionInBuffer(node, remainder);
      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {
        this.appendToNode(node, value);
        this.computeBufferMetadata();
        return;
      }
      if (nodeStartOffset === offset) {
        this.insertContentToNodeLeft(value, node);
        this._searchCache.validate(offset);
      } else if (nodeStartOffset + node.piece.length > offset) {
        const nodesToDel = [];
        let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));
        if (this.shouldCheckCRLF() && this.endWithCR(value)) {
          const headOfRight = this.nodeCharCodeAt(node, remainder);
          if (headOfRight === 10) {
            const newStart = { line: newRightPiece.start.line + 1, column: 0 };
            newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
            value += "\n";
          }
        }
        if (this.shouldCheckCRLF() && this.startWithLF(value)) {
          const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
          if (tailOfLeft === 13) {
            const previousPos = this.positionInBuffer(node, remainder - 1);
            this.deleteNodeTail(node, previousPos);
            value = "\r" + value;
            if (node.piece.length === 0) {
              nodesToDel.push(node);
            }
          } else {
            this.deleteNodeTail(node, insertPosInBuffer);
          }
        } else {
          this.deleteNodeTail(node, insertPosInBuffer);
        }
        const newPieces = this.createNewPieces(value);
        if (newRightPiece.length > 0) {
          this.rbInsertRight(node, newRightPiece);
        }
        let tmpNode = node;
        for (let k = 0; k < newPieces.length; k++) {
          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
        }
        this.deleteNodes(nodesToDel);
      } else {
        this.insertContentToNodeRight(value, node);
      }
    } else {
      const pieces = this.createNewPieces(value);
      let node = this.rbInsertLeft(null, pieces[0]);
      for (let k = 1; k < pieces.length; k++) {
        node = this.rbInsertRight(node, pieces[k]);
      }
    }
    this.computeBufferMetadata();
  }
  delete(offset, cnt) {
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (cnt <= 0 || this.root === SENTINEL) {
      return;
    }
    const startPosition = this.nodeAt(offset);
    const endPosition = this.nodeAt(offset + cnt);
    const startNode = startPosition.node;
    const endNode = endPosition.node;
    if (startNode === endNode) {
      const startSplitPosInBuffer2 = this.positionInBuffer(startNode, startPosition.remainder);
      const endSplitPosInBuffer2 = this.positionInBuffer(startNode, endPosition.remainder);
      if (startPosition.nodeStartOffset === offset) {
        if (cnt === startNode.piece.length) {
          const next = startNode.next();
          rbDelete(this, startNode);
          this.validateCRLFWithPrevNode(next);
          this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(startNode, endSplitPosInBuffer2);
        this._searchCache.validate(offset);
        this.validateCRLFWithPrevNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
        this.deleteNodeTail(startNode, startSplitPosInBuffer2);
        this.validateCRLFWithNextNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(startNode, startSplitPosInBuffer2, endSplitPosInBuffer2);
      this.computeBufferMetadata();
      return;
    }
    const nodesToDel = [];
    const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
    this.deleteNodeTail(startNode, startSplitPosInBuffer);
    this._searchCache.validate(offset);
    if (startNode.piece.length === 0) {
      nodesToDel.push(startNode);
    }
    const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
    this.deleteNodeHead(endNode, endSplitPosInBuffer);
    if (endNode.piece.length === 0) {
      nodesToDel.push(endNode);
    }
    const secondNode = startNode.next();
    for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {
      nodesToDel.push(node);
    }
    const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
    this.deleteNodes(nodesToDel);
    this.validateCRLFWithNextNode(prev);
    this.computeBufferMetadata();
  }
  insertContentToNodeLeft(value, node) {
    const nodesToDel = [];
    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
      const piece = node.piece;
      const newStart = { line: piece.start.line + 1, column: 0 };
      const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
      node.piece = nPiece;
      value += "\n";
      updateTreeMetadata(this, node, -1, -1);
      if (node.piece.length === 0) {
        nodesToDel.push(node);
      }
    }
    const newPieces = this.createNewPieces(value);
    let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
    for (let k = newPieces.length - 2; k >= 0; k--) {
      newNode = this.rbInsertLeft(newNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
    this.deleteNodes(nodesToDel);
  }
  insertContentToNodeRight(value, node) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    const newPieces = this.createNewPieces(value);
    const newNode = this.rbInsertRight(node, newPieces[0]);
    let tmpNode = newNode;
    for (let k = 1; k < newPieces.length; k++) {
      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
  }
  positionInBuffer(node, remainder, ret) {
    const piece = node.piece;
    const bufferIndex = node.piece.bufferIndex;
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    const startOffset = lineStarts[piece.start.line] + piece.start.column;
    const offset = startOffset + remainder;
    let low = piece.start.line;
    let high = piece.end.line;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStart = lineStarts[mid];
      if (mid === high) {
        break;
      }
      midStop = lineStarts[mid + 1];
      if (offset < midStart) {
        high = mid - 1;
      } else if (offset >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    if (ret) {
      ret.line = mid;
      ret.column = offset - midStart;
      return null;
    }
    return {
      line: mid,
      column: offset - midStart
    };
  }
  getLineFeedCnt(bufferIndex, start, end) {
    if (end.column === 0) {
      return end.line - start.line;
    }
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    if (end.line === lineStarts.length - 1) {
      return end.line - start.line;
    }
    const nextLineStartOffset = lineStarts[end.line + 1];
    const endOffset = lineStarts[end.line] + end.column;
    if (nextLineStartOffset > endOffset + 1) {
      return end.line - start.line;
    }
    const previousCharOffset = endOffset - 1;
    const buffer = this._buffers[bufferIndex].buffer;
    if (buffer.charCodeAt(previousCharOffset) === 13) {
      return end.line - start.line + 1;
    } else {
      return end.line - start.line;
    }
  }
  offsetInBuffer(bufferIndex, cursor) {
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    return lineStarts[cursor.line] + cursor.column;
  }
  deleteNodes(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      rbDelete(this, nodes[i]);
    }
  }
  createNewPieces(text) {
    if (text.length > AverageBufferSize) {
      const newPieces = [];
      while (text.length > AverageBufferSize) {
        const lastChar = text.charCodeAt(AverageBufferSize - 1);
        let splitText;
        if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
          splitText = text.substring(0, AverageBufferSize - 1);
          text = text.substring(AverageBufferSize - 1);
        } else {
          splitText = text.substring(0, AverageBufferSize);
          text = text.substring(AverageBufferSize);
        }
        const lineStarts3 = createLineStartsFast(splitText);
        newPieces.push(new Piece(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: lineStarts3.length - 1, column: splitText.length - lineStarts3[lineStarts3.length - 1] },
          lineStarts3.length - 1,
          splitText.length
        ));
        this._buffers.push(new StringBuffer(splitText, lineStarts3));
      }
      const lineStarts2 = createLineStartsFast(text);
      newPieces.push(new Piece(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: lineStarts2.length - 1, column: text.length - lineStarts2[lineStarts2.length - 1] },
        lineStarts2.length - 1,
        text.length
      ));
      this._buffers.push(new StringBuffer(text, lineStarts2));
      return newPieces;
    }
    let startOffset = this._buffers[0].buffer.length;
    const lineStarts = createLineStartsFast(text, false);
    let start = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };
      start = this._lastChangeBufferPos;
      for (let i = 0; i < lineStarts.length; i++) {
        lineStarts[i] += startOffset + 1;
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += "_" + text;
      startOffset += 1;
    } else {
      if (startOffset !== 0) {
        for (let i = 0; i < lineStarts.length; i++) {
          lineStarts[i] += startOffset;
        }
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += text;
    }
    const endOffset = this._buffers[0].buffer.length;
    const endIndex = this._buffers[0].lineStarts.length - 1;
    const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
    const endPos = { line: endIndex, column: endColumn };
    const newPiece = new Piece(
      0,
      /** todo@peng */
      start,
      endPos,
      this.getLineFeedCnt(0, start, endPos),
      endOffset - startOffset
    );
    this._lastChangeBufferPos = endPos;
    return [newPiece];
  }
  getLinesRawContent() {
    return this.getContentOfSubTree(this.root);
  }
  getLineRawContent(lineNumber, endOffset = 0) {
    let x = this.root;
    let ret = "";
    const cache2 = this._searchCache.get2(lineNumber);
    if (cache2) {
      x = cache2.node;
      const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache2.nodeStartLineNumber - 1);
      const buffer = this._buffers[x.piece.bufferIndex].buffer;
      const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (cache2.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
        ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
      } else {
        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache2.nodeStartLineNumber);
        return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
      }
    } else {
      let nodeStartOffset = 0;
      const originalLineNumber = lineNumber;
      while (x !== SENTINEL) {
        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {
          x = x.left;
        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          nodeStartOffset += x.size_left;
          this._searchCache.set({
            node: x,
            nodeStartOffset,
            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
          });
          return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
          break;
        } else {
          lineNumber -= x.lf_left + x.piece.lineFeedCnt;
          nodeStartOffset += x.size_left + x.piece.length;
          x = x.right;
        }
      }
    }
    x = x.next();
    while (x !== SENTINEL) {
      const buffer = this._buffers[x.piece.bufferIndex].buffer;
      if (x.piece.lineFeedCnt > 0) {
        const accumulatedValue = this.getAccumulatedValue(x, 0);
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);
        return ret;
      } else {
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer.substr(startOffset, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  computeBufferMetadata() {
    let x = this.root;
    let lfCnt = 1;
    let len = 0;
    while (x !== SENTINEL) {
      lfCnt += x.lf_left + x.piece.lineFeedCnt;
      len += x.size_left + x.piece.length;
      x = x.right;
    }
    this._lineCnt = lfCnt;
    this._length = len;
    this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(node, accumulatedValue) {
    const piece = node.piece;
    const pos = this.positionInBuffer(node, accumulatedValue);
    const lineCnt = pos.line - piece.start.line;
    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
      const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
      if (realLineCnt !== lineCnt) {
        return { index: realLineCnt, remainder: 0 };
      }
    }
    return { index: lineCnt, remainder: pos.column };
  }
  getAccumulatedValue(node, index) {
    if (index < 0) {
      return 0;
    }
    const piece = node.piece;
    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    const expectedLineStartIndex = piece.start.line + index + 1;
    if (expectedLineStartIndex > piece.end.line) {
      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
    } else {
      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
    }
  }
  deleteNodeTail(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const newEnd = pos;
    const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = newEndOffset - originalEndOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  deleteNodeHead(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const newStart = pos;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
    const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = originalStartOffset - newStartOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  shrinkNode(node, start, end) {
    const piece = node.piece;
    const originalStartPos = piece.start;
    const originalEndPos = piece.end;
    const oldLength = piece.length;
    const oldLFCnt = piece.lineFeedCnt;
    const newEnd = start;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
    const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
    const newNode = this.rbInsertRight(node, newPiece);
    this.validateCRLFWithPrevNode(newNode);
  }
  appendToNode(node, value) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
    const startOffset = this._buffers[0].buffer.length;
    this._buffers[0].buffer += value;
    const lineStarts = createLineStartsFast(value, false);
    for (let i = 0; i < lineStarts.length; i++) {
      lineStarts[i] += startOffset;
    }
    if (hitCRLF) {
      const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop();
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
    const endIndex = this._buffers[0].lineStarts.length - 1;
    const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
    const newEnd = { line: endIndex, column: endColumn };
    const newLength = node.piece.length + value.length;
    const oldLineFeedCnt = node.piece.lineFeedCnt;
    const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
    const lf_delta = newLineFeedCnt - oldLineFeedCnt;
    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
    this._lastChangeBufferPos = newEnd;
    updateTreeMetadata(this, node, value.length, lf_delta);
  }
  nodeAt(offset) {
    let x = this.root;
    const cache2 = this._searchCache.get(offset);
    if (cache2) {
      return {
        node: cache2.node,
        nodeStartOffset: cache2.nodeStartOffset,
        remainder: offset - cache2.nodeStartOffset
      };
    }
    let nodeStartOffset = 0;
    while (x !== SENTINEL) {
      if (x.size_left > offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        nodeStartOffset += x.size_left;
        const ret = {
          node: x,
          remainder: offset - x.size_left,
          nodeStartOffset
        };
        this._searchCache.set(ret);
        return ret;
      } else {
        offset -= x.size_left + x.piece.length;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return null;
  }
  nodeAt2(lineNumber, column) {
    let x = this.root;
    let nodeStartOffset = 0;
    while (x !== SENTINEL) {
      if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
        nodeStartOffset += x.size_left;
        return {
          node: x,
          remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),
          nodeStartOffset
        };
      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        if (prevAccumualtedValue + column - 1 <= x.piece.length) {
          return {
            node: x,
            remainder: prevAccumualtedValue + column - 1,
            nodeStartOffset
          };
        } else {
          column -= x.piece.length - prevAccumualtedValue;
          break;
        }
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    x = x.next();
    while (x !== SENTINEL) {
      if (x.piece.lineFeedCnt > 0) {
        const accumulatedValue = this.getAccumulatedValue(x, 0);
        const nodeStartOffset2 = this.offsetOfNode(x);
        return {
          node: x,
          remainder: Math.min(column - 1, accumulatedValue),
          nodeStartOffset: nodeStartOffset2
        };
      } else {
        if (x.piece.length >= column - 1) {
          const nodeStartOffset2 = this.offsetOfNode(x);
          return {
            node: x,
            remainder: column - 1,
            nodeStartOffset: nodeStartOffset2
          };
        } else {
          column -= x.piece.length;
        }
      }
      x = x.next();
    }
    return null;
  }
  nodeCharCodeAt(node, offset) {
    if (node.piece.lineFeedCnt < 1) {
      return -1;
    }
    const buffer = this._buffers[node.piece.bufferIndex];
    const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
    return buffer.buffer.charCodeAt(newOffset);
  }
  offsetOfNode(node) {
    if (!node) {
      return 0;
    }
    let pos = node.size_left;
    while (node !== this.root) {
      if (node.parent.right === node) {
        pos += node.parent.size_left + node.parent.piece.length;
      }
      node = node.parent;
    }
    return pos;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === "\n");
  }
  startWithLF(val) {
    if (typeof val === "string") {
      return val.charCodeAt(0) === 10;
    }
    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {
      return false;
    }
    const piece = val.piece;
    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    const line = piece.start.line;
    const startOffset = lineStarts[line] + piece.start.column;
    if (line === lineStarts.length - 1) {
      return false;
    }
    const nextLineOffset = lineStarts[line + 1];
    if (nextLineOffset > startOffset + 1) {
      return false;
    }
    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
  }
  endWithCR(val) {
    if (typeof val === "string") {
      return val.charCodeAt(val.length - 1) === 13;
    }
    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {
      return false;
    }
    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(nextNode) {
    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
      const node = nextNode.prev();
      if (this.endWithCR(node)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  validateCRLFWithNextNode(node) {
    if (this.shouldCheckCRLF() && this.endWithCR(node)) {
      const nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  fixCRLF(prev, next) {
    const nodesToDel = [];
    const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
    let newEnd;
    if (prev.piece.end.column === 0) {
      newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };
    } else {
      newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
    }
    const prevNewLength = prev.piece.length - 1;
    const prevNewLFCnt = prev.piece.lineFeedCnt - 1;
    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
    updateTreeMetadata(this, prev, -1, -1);
    if (prev.piece.length === 0) {
      nodesToDel.push(prev);
    }
    const newStart = { line: next.piece.start.line + 1, column: 0 };
    const newLength = next.piece.length - 1;
    const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, next, -1, -1);
    if (next.piece.length === 0) {
      nodesToDel.push(next);
    }
    const pieces = this.createNewPieces("\r\n");
    this.rbInsertRight(prev, pieces[0]);
    for (let i = 0; i < nodesToDel.length; i++) {
      rbDelete(this, nodesToDel[i]);
    }
  }
  adjustCarriageReturnFromNext(value, node) {
    if (this.shouldCheckCRLF() && this.endWithCR(value)) {
      const nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        value += "\n";
        if (nextNode.piece.length === 1) {
          rbDelete(this, nextNode);
        } else {
          const piece = nextNode.piece;
          const newStart = { line: piece.start.line + 1, column: 0 };
          const newLength = piece.length - 1;
          const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
          updateTreeMetadata(this, nextNode, -1, -1);
        }
        return true;
      }
    }
    return false;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(node, callback) {
    if (node === SENTINEL) {
      return callback(SENTINEL);
    }
    const leftRet = this.iterate(node.left, callback);
    if (!leftRet) {
      return leftRet;
    }
    return callback(node) && this.iterate(node.right, callback);
  }
  getNodeContent(node) {
    if (node === SENTINEL) {
      return "";
    }
    const buffer = this._buffers[node.piece.bufferIndex];
    const piece = node.piece;
    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const currentContent = buffer.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  getPieceContent(piece) {
    const buffer = this._buffers[piece.bufferIndex];
    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const currentContent = buffer.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(node, p) {
    const z = new TreeNode(
      p,
      1
      /* NodeColor.Red */
    );
    z.left = SENTINEL;
    z.right = SENTINEL;
    z.parent = SENTINEL;
    z.size_left = 0;
    z.lf_left = 0;
    const x = this.root;
    if (x === SENTINEL) {
      this.root = z;
      z.color = 0;
    } else if (node.right === SENTINEL) {
      node.right = z;
      z.parent = node;
    } else {
      const nextNode = leftest(node.right);
      nextNode.left = z;
      z.parent = nextNode;
    }
    fixInsert(this, z);
    return z;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(node, p) {
    const z = new TreeNode(
      p,
      1
      /* NodeColor.Red */
    );
    z.left = SENTINEL;
    z.right = SENTINEL;
    z.parent = SENTINEL;
    z.size_left = 0;
    z.lf_left = 0;
    if (this.root === SENTINEL) {
      this.root = z;
      z.color = 0;
    } else if (node.left === SENTINEL) {
      node.left = z;
      z.parent = node;
    } else {
      const prevNode = righttest(node.left);
      prevNode.right = z;
      z.parent = prevNode;
    }
    fixInsert(this, z);
    return z;
  }
  getContentOfSubTree(node) {
    let str = "";
    this.iterate(node, (node2) => {
      str += this.getNodeContent(node2);
      return true;
    });
    return str;
  }
};

// out-build/vs/editor/common/core/misc/eolCounter.js
var StringEOL;
(function(StringEOL2) {
  StringEOL2[StringEOL2["Unknown"] = 0] = "Unknown";
  StringEOL2[StringEOL2["Invalid"] = 3] = "Invalid";
  StringEOL2[StringEOL2["LF"] = 1] = "LF";
  StringEOL2[StringEOL2["CRLF"] = 2] = "CRLF";
})(StringEOL || (StringEOL = {}));
function countEOL(text) {
  let eolCount = 0;
  let firstLineLength = 0;
  let lastLineStart = 0;
  let eol = 0;
  for (let i = 0, len = text.length; i < len; i++) {
    const chr = text.charCodeAt(i);
    if (chr === 13) {
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      if (i + 1 < len && text.charCodeAt(i + 1) === 10) {
        eol |= 2;
        i++;
      } else {
        eol |= 3;
      }
      lastLineStart = i + 1;
    } else if (chr === 10) {
      eol |= 1;
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      lastLineStart = i + 1;
    }
  }
  if (eolCount === 0) {
    firstLineLength = text.length;
  }
  return [eolCount, firstLineLength, text.length - lastLineStart, eol];
}

// out-build/vs/editor/common/core/stringBuilder.js
var _utf16LE_TextDecoder;
function getUTF16LE_TextDecoder() {
  if (!_utf16LE_TextDecoder) {
    _utf16LE_TextDecoder = new TextDecoder("UTF-16LE");
  }
  return _utf16LE_TextDecoder;
}
function decodeUTF16LE(source, offset, len) {
  const view = new Uint16Array(source.buffer, offset, len);
  if (len > 0 && (view[0] === 65279 || view[0] === 65534)) {
    return compatDecodeUTF16LE(source, offset, len);
  }
  return getUTF16LE_TextDecoder().decode(view);
}
function compatDecodeUTF16LE(source, offset, len) {
  const result = [];
  let resultLen = 0;
  for (let i = 0; i < len; i++) {
    const charCode = readUInt16LE(source, offset);
    offset += 2;
    result[resultLen++] = String.fromCharCode(charCode);
  }
  return result.join("");
}

// out-build/vs/editor/common/core/textChange.js
function escapeNewLine(str) {
  return str.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
var TextChange = class _TextChange {
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  constructor(oldPosition, oldText, newPosition, newText) {
    this.oldPosition = oldPosition;
    this.oldText = oldText;
    this.newPosition = newPosition;
    this.newText = newText;
  }
  toString() {
    if (this.oldText.length === 0) {
      return `(insert@${this.oldPosition} "${escapeNewLine(this.newText)}")`;
    }
    if (this.newText.length === 0) {
      return `(delete@${this.oldPosition} "${escapeNewLine(this.oldText)}")`;
    }
    return `(replace@${this.oldPosition} "${escapeNewLine(this.oldText)}" with "${escapeNewLine(this.newText)}")`;
  }
  static _writeStringSize(str) {
    return 4 + 2 * str.length;
  }
  static _writeString(b, str, offset) {
    const len = str.length;
    writeUInt32BE(b, len, offset);
    offset += 4;
    for (let i = 0; i < len; i++) {
      writeUInt16LE(b, str.charCodeAt(i), offset);
      offset += 2;
    }
    return offset;
  }
  static _readString(b, offset) {
    const len = readUInt32BE(b, offset);
    offset += 4;
    return decodeUTF16LE(b, offset, len);
  }
  writeSize() {
    return 4 + 4 + _TextChange._writeStringSize(this.oldText) + _TextChange._writeStringSize(this.newText);
  }
  write(b, offset) {
    writeUInt32BE(b, this.oldPosition, offset);
    offset += 4;
    writeUInt32BE(b, this.newPosition, offset);
    offset += 4;
    offset = _TextChange._writeString(b, this.oldText, offset);
    offset = _TextChange._writeString(b, this.newText, offset);
    return offset;
  }
  static read(b, offset, dest) {
    const oldPosition = readUInt32BE(b, offset);
    offset += 4;
    const newPosition = readUInt32BE(b, offset);
    offset += 4;
    const oldText = _TextChange._readString(b, offset);
    offset += _TextChange._writeStringSize(oldText);
    const newText = _TextChange._readString(b, offset);
    offset += _TextChange._writeStringSize(newText);
    dest.push(new _TextChange(oldPosition, oldText, newPosition, newText));
    return offset;
  }
};

// out-build/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js
var PieceTreeTextBuffer = class _PieceTreeTextBuffer extends Disposable {
  get onDidChangeContent() {
    return this._onDidChangeContent.event;
  }
  constructor(chunks, BOM, eol, containsRTL2, containsUnusualLineTerminators2, isBasicASCII2, eolNormalized) {
    super();
    this._onDidChangeContent = this._register(new Emitter());
    this._BOM = BOM;
    this._mightContainNonBasicASCII = !isBasicASCII2;
    this._mightContainRTL = containsRTL2;
    this._mightContainUnusualLineTerminators = containsUnusualLineTerminators2;
    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);
  }
  // #region TextBuffer
  equals(other) {
    if (!(other instanceof _PieceTreeTextBuffer)) {
      return false;
    }
    if (this._BOM !== other._BOM) {
      return false;
    }
    if (this.getEOL() !== other.getEOL()) {
      return false;
    }
    return this._pieceTree.equal(other._pieceTree);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = false;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(preserveBOM) {
    return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : "");
  }
  getOffsetAt(lineNumber, column) {
    return this._pieceTree.getOffsetAt(lineNumber, column);
  }
  getPositionAt(offset) {
    return this._pieceTree.getPositionAt(offset);
  }
  getRangeAt(start, length) {
    const end = start + length;
    const startPosition = this.getPositionAt(start);
    const endPosition = this.getPositionAt(end);
    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
  }
  getValueInRange(range, eol = 0) {
    if (range.isEmpty()) {
      return "";
    }
    const lineEnding = this._getEndOfLine(eol);
    return this._pieceTree.getValueInRange(range, lineEnding);
  }
  getValueLengthInRange(range, eol = 0) {
    if (range.isEmpty()) {
      return 0;
    }
    if (range.startLineNumber === range.endLineNumber) {
      return range.endColumn - range.startColumn;
    }
    const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);
    const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);
    let eolOffsetCompensation = 0;
    const desiredEOL = this._getEndOfLine(eol);
    const actualEOL = this.getEOL();
    if (desiredEOL.length !== actualEOL.length) {
      const delta3 = desiredEOL.length - actualEOL.length;
      const eolCount = range.endLineNumber - range.startLineNumber;
      eolOffsetCompensation = delta3 * eolCount;
    }
    return endOffset - startOffset + eolOffsetCompensation;
  }
  getCharacterCountInRange(range, eol = 0) {
    if (this._mightContainNonBasicASCII) {
      let result = 0;
      const fromLineNumber = range.startLineNumber;
      const toLineNumber = range.endLineNumber;
      for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
        const lineContent = this.getLineContent(lineNumber);
        const fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;
        const toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;
        for (let offset = fromOffset; offset < toOffset; offset++) {
          if (isHighSurrogate(lineContent.charCodeAt(offset))) {
            result = result + 1;
            offset = offset + 1;
          } else {
            result = result + 1;
          }
        }
      }
      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);
      return result;
    }
    return this.getValueLengthInRange(range, eol);
  }
  getNearestChunk(offset) {
    return this._pieceTree.getNearestChunk(offset);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(lineNumber) {
    return this._pieceTree.getLineContent(lineNumber);
  }
  getLineCharCode(lineNumber, index) {
    return this._pieceTree.getLineCharCode(lineNumber, index);
  }
  getCharCode(offset) {
    return this._pieceTree.getCharCode(offset);
  }
  getLineLength(lineNumber) {
    return this._pieceTree.getLineLength(lineNumber);
  }
  getLineMinColumn(lineNumber) {
    return 1;
  }
  getLineMaxColumn(lineNumber) {
    return this.getLineLength(lineNumber) + 1;
  }
  getLineFirstNonWhitespaceColumn(lineNumber) {
    const result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 1;
  }
  getLineLastNonWhitespaceColumn(lineNumber) {
    const result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 2;
  }
  _getEndOfLine(eol) {
    switch (eol) {
      case 1:
        return "\n";
      case 2:
        return "\r\n";
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(newEOL) {
    this._pieceTree.setEOL(newEOL);
  }
  applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {
    let mightContainRTL = this._mightContainRTL;
    let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;
    let mightContainNonBasicASCII = this._mightContainNonBasicASCII;
    let canReduceOperations = true;
    let operations = [];
    for (let i = 0; i < rawOperations.length; i++) {
      const op = rawOperations[i];
      if (canReduceOperations && op._isTracked) {
        canReduceOperations = false;
      }
      const validatedRange = op.range;
      if (op.text) {
        let textMightContainNonBasicASCII = true;
        if (!mightContainNonBasicASCII) {
          textMightContainNonBasicASCII = !isBasicASCII(op.text);
          mightContainNonBasicASCII = textMightContainNonBasicASCII;
        }
        if (!mightContainRTL && textMightContainNonBasicASCII) {
          mightContainRTL = containsRTL(op.text);
        }
        if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {
          mightContainUnusualLineTerminators = containsUnusualLineTerminators(op.text);
        }
      }
      let validText = "";
      let eolCount = 0;
      let firstLineLength = 0;
      let lastLineLength = 0;
      if (op.text) {
        let strEOL;
        [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);
        const bufferEOL = this.getEOL();
        const expectedStrEOL = bufferEOL === "\r\n" ? 2 : 1;
        if (strEOL === 0 || strEOL === expectedStrEOL) {
          validText = op.text;
        } else {
          validText = op.text.replace(/\r\n|\r|\n/g, bufferEOL);
        }
      }
      operations[i] = {
        sortIndex: i,
        identifier: op.identifier || null,
        range: validatedRange,
        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
        rangeLength: this.getValueLengthInRange(validatedRange),
        text: validText,
        eolCount,
        firstLineLength,
        lastLineLength,
        forceMoveMarkers: Boolean(op.forceMoveMarkers),
        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
      };
    }
    operations.sort(_PieceTreeTextBuffer._sortOpsAscending);
    let hasTouchingRanges = false;
    for (let i = 0, count2 = operations.length - 1; i < count2; i++) {
      const rangeEnd = operations[i].range.getEndPosition();
      const nextRangeStart = operations[i + 1].range.getStartPosition();
      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
        if (nextRangeStart.isBefore(rangeEnd)) {
          throw new Error("Overlapping ranges are not allowed!");
        }
        hasTouchingRanges = true;
      }
    }
    if (canReduceOperations) {
      operations = this._reduceOperations(operations);
    }
    const reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? _PieceTreeTextBuffer._getInverseEditRanges(operations) : [];
    const newTrimAutoWhitespaceCandidates = [];
    if (recordTrimAutoWhitespace) {
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        const reverseRange = reverseRanges[i];
        if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {
          for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
            let currentLineContent = "";
            if (lineNumber === reverseRange.startLineNumber) {
              currentLineContent = this.getLineContent(op.range.startLineNumber);
              if (firstNonWhitespaceIndex(currentLineContent) !== -1) {
                continue;
              }
            }
            newTrimAutoWhitespaceCandidates.push({ lineNumber, oldContent: currentLineContent });
          }
        }
      }
    }
    let reverseOperations = null;
    if (computeUndoEdits) {
      let reverseRangeDeltaOffset = 0;
      reverseOperations = [];
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        const reverseRange = reverseRanges[i];
        const bufferText = this.getValueInRange(op.range);
        const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;
        reverseRangeDeltaOffset += op.text.length - bufferText.length;
        reverseOperations[i] = {
          sortIndex: op.sortIndex,
          identifier: op.identifier,
          range: reverseRange,
          text: bufferText,
          textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)
        };
      }
      if (!hasTouchingRanges) {
        reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);
      }
    }
    this._mightContainRTL = mightContainRTL;
    this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;
    this._mightContainNonBasicASCII = mightContainNonBasicASCII;
    const contentChanges = this._doApplyEdits(operations);
    let trimAutoWhitespaceLineNumbers = null;
    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
      newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);
      trimAutoWhitespaceLineNumbers = [];
      for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
        const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
          continue;
        }
        const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
        const lineContent = this.getLineContent(lineNumber);
        if (lineContent.length === 0 || lineContent === prevContent || firstNonWhitespaceIndex(lineContent) !== -1) {
          continue;
        }
        trimAutoWhitespaceLineNumbers.push(lineNumber);
      }
    }
    this._onDidChangeContent.fire();
    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(operations) {
    if (operations.length < 1e3) {
      return operations;
    }
    return [this._toSingleEditOperation(operations)];
  }
  _toSingleEditOperation(operations) {
    let forceMoveMarkers = false;
    const firstEditRange = operations[0].range;
    const lastEditRange = operations[operations.length - 1].range;
    const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);
    let lastEndLineNumber = firstEditRange.startLineNumber;
    let lastEndColumn = firstEditRange.startColumn;
    const result = [];
    for (let i = 0, len = operations.length; i < len; i++) {
      const operation = operations[i];
      const range = operation.range;
      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
      result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));
      if (operation.text.length > 0) {
        result.push(operation.text);
      }
      lastEndLineNumber = range.endLineNumber;
      lastEndColumn = range.endColumn;
    }
    const text = result.join("");
    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
    return {
      sortIndex: 0,
      identifier: operations[0].identifier,
      range: entireEditRange,
      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
      rangeLength: this.getValueLengthInRange(
        entireEditRange,
        0
        /* EndOfLinePreference.TextDefined */
      ),
      text,
      eolCount,
      firstLineLength,
      lastLineLength,
      forceMoveMarkers,
      isAutoWhitespaceEdit: false
    };
  }
  _doApplyEdits(operations) {
    operations.sort(_PieceTreeTextBuffer._sortOpsDescending);
    const contentChanges = [];
    for (let i = 0; i < operations.length; i++) {
      const op = operations[i];
      const startLineNumber = op.range.startLineNumber;
      const startColumn = op.range.startColumn;
      const endLineNumber = op.range.endLineNumber;
      const endColumn = op.range.endColumn;
      if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {
        continue;
      }
      if (op.text) {
        this._pieceTree.delete(op.rangeOffset, op.rangeLength);
        this._pieceTree.insert(op.rangeOffset, op.text, true);
      } else {
        this._pieceTree.delete(op.rangeOffset, op.rangeLength);
      }
      const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      contentChanges.push({
        range: contentChangeRange,
        rangeLength: op.rangeLength,
        text: op.text,
        rangeOffset: op.rangeOffset,
        forceMoveMarkers: op.forceMoveMarkers
      });
    }
    return contentChanges;
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
  }
  // #endregion
  // #region helper
  // testing purpose.
  getPieceTree() {
    return this._pieceTree;
  }
  static _getInverseEditRange(range, text) {
    const startLineNumber = range.startLineNumber;
    const startColumn = range.startColumn;
    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
    let resultRange;
    if (text.length > 0) {
      const lineCount = eolCount + 1;
      if (lineCount === 1) {
        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLineLength);
      } else {
        resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLineLength + 1);
      }
    } else {
      resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);
    }
    return resultRange;
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(operations) {
    const result = [];
    let prevOpEndLineNumber = 0;
    let prevOpEndColumn = 0;
    let prevOp = null;
    for (let i = 0, len = operations.length; i < len; i++) {
      const op = operations[i];
      let startLineNumber;
      let startColumn;
      if (prevOp) {
        if (prevOp.range.endLineNumber === op.range.startLineNumber) {
          startLineNumber = prevOpEndLineNumber;
          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
        } else {
          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
          startColumn = op.range.startColumn;
        }
      } else {
        startLineNumber = op.range.startLineNumber;
        startColumn = op.range.startColumn;
      }
      let resultRange;
      if (op.text.length > 0) {
        const lineCount = op.eolCount + 1;
        if (lineCount === 1) {
          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);
        } else {
          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);
        }
      } else {
        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);
      }
      prevOpEndLineNumber = resultRange.endLineNumber;
      prevOpEndColumn = resultRange.endColumn;
      result.push(resultRange);
      prevOp = op;
    }
    return result;
  }
  static _sortOpsAscending(a, b) {
    const r = Range.compareRangesUsingEnds(a.range, b.range);
    if (r === 0) {
      return a.sortIndex - b.sortIndex;
    }
    return r;
  }
  static _sortOpsDescending(a, b) {
    const r = Range.compareRangesUsingEnds(a.range, b.range);
    if (r === 0) {
      return b.sortIndex - a.sortIndex;
    }
    return -r;
  }
};

// out-build/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js
var PieceTreeTextBufferFactory = class {
  constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {
    this._chunks = _chunks;
    this._bom = _bom;
    this._cr = _cr;
    this._lf = _lf;
    this._crlf = _crlf;
    this._containsRTL = _containsRTL;
    this._containsUnusualLineTerminators = _containsUnusualLineTerminators;
    this._isBasicASCII = _isBasicASCII;
    this._normalizeEOL = _normalizeEOL;
  }
  _getEOL(defaultEOL) {
    const totalEOLCount = this._cr + this._lf + this._crlf;
    const totalCRCount = this._cr + this._crlf;
    if (totalEOLCount === 0) {
      return defaultEOL === 1 ? "\n" : "\r\n";
    }
    if (totalCRCount > totalEOLCount / 2) {
      return "\r\n";
    }
    return "\n";
  }
  create(defaultEOL) {
    const eol = this._getEOL(defaultEOL);
    const chunks = this._chunks;
    if (this._normalizeEOL && (eol === "\r\n" && (this._cr > 0 || this._lf > 0) || eol === "\n" && (this._cr > 0 || this._crlf > 0))) {
      for (let i = 0, len = chunks.length; i < len; i++) {
        const str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
        const newLineStart = createLineStartsFast(str);
        chunks[i] = new StringBuffer(str, newLineStart);
      }
    }
    const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer, disposable: textBuffer };
  }
  getFirstLineText(lengthLimit) {
    return this._chunks[0].buffer.substr(0, lengthLimit).split(/\r\n|\r|\n/)[0];
  }
};
var PieceTreeTextBufferBuilder = class {
  constructor() {
    this.chunks = [];
    this.BOM = "";
    this._hasPreviousChar = false;
    this._previousChar = 0;
    this._tmpLineStarts = [];
    this.cr = 0;
    this.lf = 0;
    this.crlf = 0;
    this.containsRTL = false;
    this.containsUnusualLineTerminators = false;
    this.isBasicASCII = true;
  }
  acceptChunk(chunk) {
    if (chunk.length === 0) {
      return;
    }
    if (this.chunks.length === 0) {
      if (startsWithUTF8BOM(chunk)) {
        this.BOM = UTF8_BOM_CHARACTER;
        chunk = chunk.substr(1);
      }
    }
    const lastChar = chunk.charCodeAt(chunk.length - 1);
    if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
      this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
      this._hasPreviousChar = true;
      this._previousChar = lastChar;
    } else {
      this._acceptChunk1(chunk, false);
      this._hasPreviousChar = false;
      this._previousChar = lastChar;
    }
  }
  _acceptChunk1(chunk, allowEmptyStrings) {
    if (!allowEmptyStrings && chunk.length === 0) {
      return;
    }
    if (this._hasPreviousChar) {
      this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
    } else {
      this._acceptChunk2(chunk);
    }
  }
  _acceptChunk2(chunk) {
    const lineStarts = createLineStarts(this._tmpLineStarts, chunk);
    this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));
    this.cr += lineStarts.cr;
    this.lf += lineStarts.lf;
    this.crlf += lineStarts.crlf;
    if (!lineStarts.isBasicASCII) {
      this.isBasicASCII = false;
      if (!this.containsRTL) {
        this.containsRTL = containsRTL(chunk);
      }
      if (!this.containsUnusualLineTerminators) {
        this.containsUnusualLineTerminators = containsUnusualLineTerminators(chunk);
      }
    }
  }
  finish(normalizeEOL = true) {
    this._finish();
    return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);
  }
  _finish() {
    if (this.chunks.length === 0) {
      this._acceptChunk1("", true);
    }
    if (this._hasPreviousChar) {
      this._hasPreviousChar = false;
      const lastChunk = this.chunks[this.chunks.length - 1];
      lastChunk.buffer += String.fromCharCode(this._previousChar);
      const newLineStarts = createLineStartsFast(lastChunk.buffer);
      lastChunk.lineStarts = newLineStarts;
      if (this._previousChar === 13) {
        this.cr++;
      }
    }
  }
};

// out-build/vs/workbench/contrib/search/common/cellSearchModel.js
var CellSearchModel = class extends Disposable {
  constructor(_source, _inputTextBuffer, _outputs) {
    super();
    this._source = _source;
    this._inputTextBuffer = _inputTextBuffer;
    this._outputs = _outputs;
    this._outputTextBuffers = void 0;
  }
  _getFullModelRange(buffer) {
    const lineCount = buffer.getLineCount();
    return new Range(1, 1, lineCount, this._getLineMaxColumn(buffer, lineCount));
  }
  _getLineMaxColumn(buffer, lineNumber) {
    if (lineNumber < 1 || lineNumber > buffer.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return buffer.getLineLength(lineNumber) + 1;
  }
  get inputTextBuffer() {
    if (!this._inputTextBuffer) {
      const builder = new PieceTreeTextBufferBuilder();
      builder.acceptChunk(this._source);
      const bufferFactory = builder.finish(true);
      const { textBuffer, disposable } = bufferFactory.create(
        1
        /* DefaultEndOfLine.LF */
      );
      this._inputTextBuffer = textBuffer;
      this._register(disposable);
    }
    return this._inputTextBuffer;
  }
  get outputTextBuffers() {
    if (!this._outputTextBuffers) {
      this._outputTextBuffers = this._outputs.map((output) => {
        const builder = new PieceTreeTextBufferBuilder();
        builder.acceptChunk(output);
        const bufferFactory = builder.finish(true);
        const { textBuffer, disposable } = bufferFactory.create(
          1
          /* DefaultEndOfLine.LF */
        );
        this._register(disposable);
        return textBuffer;
      });
    }
    return this._outputTextBuffers;
  }
  findInInputs(target) {
    const searchParams = new SearchParams(target, false, false, null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return [];
    }
    const fullInputRange = this._getFullModelRange(this.inputTextBuffer);
    return this.inputTextBuffer.findMatchesLineByLine(fullInputRange, searchData, true, 5e3);
  }
  findInOutputs(target) {
    const searchParams = new SearchParams(target, false, false, null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return [];
    }
    return this.outputTextBuffers.map((buffer) => {
      const matches = buffer.findMatchesLineByLine(this._getFullModelRange(buffer), searchData, true, 5e3);
      if (matches.length === 0) {
        return void 0;
      }
      return {
        textBuffer: buffer,
        matches
      };
    }).filter((item) => !!item);
  }
};

// out-build/vs/workbench/contrib/search/common/searchNotebookHelpers.js
function genericCellMatchesToTextSearchMatches(contentMatches, buffer) {
  let previousEndLine = -1;
  const contextGroupings = [];
  let currentContextGrouping = [];
  contentMatches.forEach((match2) => {
    if (match2.range.startLineNumber !== previousEndLine) {
      if (currentContextGrouping.length > 0) {
        contextGroupings.push([...currentContextGrouping]);
        currentContextGrouping = [];
      }
    }
    currentContextGrouping.push(match2);
    previousEndLine = match2.range.endLineNumber;
  });
  if (currentContextGrouping.length > 0) {
    contextGroupings.push([...currentContextGrouping]);
  }
  const textSearchResults = contextGroupings.map((grouping) => {
    const lineTexts = [];
    const firstLine = grouping[0].range.startLineNumber;
    const lastLine = grouping[grouping.length - 1].range.endLineNumber;
    for (let i = firstLine; i <= lastLine; i++) {
      lineTexts.push(buffer.getLineContent(i));
    }
    return new TextSearchMatch(lineTexts.join("\n") + "\n", grouping.map((m) => new Range(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1)));
  });
  return textSearchResults;
}

// out-build/vs/workbench/common/configuration.js
var applicationConfigurationNodeBase = Object.freeze({
  "id": "application",
  "order": 100,
  "title": localize(4370, null),
  "type": "object"
});
var workbenchConfigurationNodeBase = Object.freeze({
  "id": "workbench",
  "order": 7,
  "title": localize(4371, null),
  "type": "object"
});
var securityConfigurationNodeBase = Object.freeze({
  "id": "security",
  "scope": 1,
  "title": localize(4372, null),
  "type": "object",
  "order": 7
});
var problemsConfigurationNodeBase = Object.freeze({
  "id": "problems",
  "title": localize(4373, null),
  "type": "object",
  "order": 101
});
var windowConfigurationNodeBase = Object.freeze({
  "id": "window",
  "order": 8,
  "title": localize(4374, null),
  "type": "object"
});
var Extensions7 = {
  ConfigurationMigration: "base.contributions.configuration.migration"
};
var ConfigurationMigrationRegistry = class {
  constructor() {
    this.migrations = [];
    this._onDidRegisterConfigurationMigrations = new Emitter();
    this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event;
  }
  registerConfigurationMigrations(configurationMigrations) {
    this.migrations.push(...configurationMigrations);
  }
};
var configurationMigrationRegistry = new ConfigurationMigrationRegistry();
Registry.add(Extensions7.ConfigurationMigration, configurationMigrationRegistry);
var ConfigurationMigrationWorkbenchContribution = class ConfigurationMigrationWorkbenchContribution2 extends Disposable {
  static {
    this.ID = "workbench.contrib.configurationMigration";
  }
  constructor(configurationService, workspaceService) {
    super();
    this.configurationService = configurationService;
    this.workspaceService = workspaceService;
    this._register(this.workspaceService.onDidChangeWorkspaceFolders(async (e) => {
      for (const folder of e.added) {
        await this.migrateConfigurationsForFolder(folder, configurationMigrationRegistry.migrations);
      }
    }));
    this.migrateConfigurations(configurationMigrationRegistry.migrations);
    this._register(configurationMigrationRegistry.onDidRegisterConfigurationMigration((migration) => this.migrateConfigurations(migration)));
  }
  async migrateConfigurations(migrations) {
    await this.migrateConfigurationsForFolder(void 0, migrations);
    for (const folder of this.workspaceService.getWorkspace().folders) {
      await this.migrateConfigurationsForFolder(folder, migrations);
    }
  }
  async migrateConfigurationsForFolder(folder, migrations) {
    await Promise.all([migrations.map((migration) => this.migrateConfigurationsForFolderAndOverride(migration, folder?.uri))]);
  }
  async migrateConfigurationsForFolderAndOverride(migration, resource) {
    const inspectData = this.configurationService.inspect(migration.key, { resource });
    const targetPairs = this.workspaceService.getWorkbenchState() === 3 ? [
      [
        "user",
        2
        /* ConfigurationTarget.USER */
      ],
      [
        "userLocal",
        3
        /* ConfigurationTarget.USER_LOCAL */
      ],
      [
        "userRemote",
        4
        /* ConfigurationTarget.USER_REMOTE */
      ],
      [
        "workspace",
        5
        /* ConfigurationTarget.WORKSPACE */
      ],
      [
        "workspaceFolder",
        6
        /* ConfigurationTarget.WORKSPACE_FOLDER */
      ]
    ] : [
      [
        "user",
        2
        /* ConfigurationTarget.USER */
      ],
      [
        "userLocal",
        3
        /* ConfigurationTarget.USER_LOCAL */
      ],
      [
        "userRemote",
        4
        /* ConfigurationTarget.USER_REMOTE */
      ],
      [
        "workspace",
        5
        /* ConfigurationTarget.WORKSPACE */
      ]
    ];
    for (const [dataKey, target] of targetPairs) {
      const inspectValue = inspectData[dataKey];
      if (!inspectValue) {
        continue;
      }
      const migrationValues = [];
      if (inspectValue.value !== void 0) {
        const keyValuePairs = await this.runMigration(migration, dataKey, inspectValue.value, resource, void 0);
        for (const keyValuePair of keyValuePairs ?? []) {
          migrationValues.push([keyValuePair, []]);
        }
      }
      for (const { identifiers: identifiers2, value } of inspectValue.overrides ?? []) {
        if (value !== void 0) {
          const keyValuePairs = await this.runMigration(migration, dataKey, value, resource, identifiers2);
          for (const keyValuePair of keyValuePairs ?? []) {
            migrationValues.push([keyValuePair, identifiers2]);
          }
        }
      }
      if (migrationValues.length) {
        await Promise.allSettled(migrationValues.map(async ([[key, value], overrideIdentifiers]) => this.configurationService.updateValue(key, value.value, { resource, overrideIdentifiers }, target)));
      }
    }
  }
  async runMigration(migration, dataKey, value, resource, overrideIdentifiers) {
    const valueAccessor = (key) => {
      const inspectData = this.configurationService.inspect(key, { resource });
      const inspectValue = inspectData[dataKey];
      if (!inspectValue) {
        return void 0;
      }
      if (!overrideIdentifiers) {
        return inspectValue.value;
      }
      return inspectValue.overrides?.find(({ identifiers: identifiers2 }) => equals2(identifiers2, overrideIdentifiers))?.value;
    };
    const result = await migration.migrateFn(value, valueAccessor);
    return Array.isArray(result) ? result : [[migration.key, result]];
  }
};
ConfigurationMigrationWorkbenchContribution = __decorate([
  __param(0, IConfigurationService),
  __param(1, IWorkspaceContextService)
], ConfigurationMigrationWorkbenchContribution);
var DynamicWorkbenchSecurityConfiguration = class DynamicWorkbenchSecurityConfiguration2 extends Disposable {
  static {
    this.ID = "workbench.contrib.dynamicWorkbenchSecurityConfiguration";
  }
  constructor(remoteAgentService) {
    super();
    this.remoteAgentService = remoteAgentService;
    this._ready = new DeferredPromise();
    this.ready = this._ready.p;
    this.create();
  }
  async create() {
    try {
      await this.doCreate();
    } finally {
      this._ready.complete();
    }
  }
  async doCreate() {
    if (!isWindows) {
      const remoteEnvironment = await this.remoteAgentService.getEnvironment();
      if (remoteEnvironment?.os !== 1) {
        return;
      }
    }
    const registry = Registry.as(Extensions2.Configuration);
    registry.registerConfiguration({
      ...securityConfigurationNodeBase,
      "properties": {
        "security.allowedUNCHosts": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^[^\\\\]+$",
            "patternErrorMessage": localize(4375, null)
          },
          "default": [],
          "markdownDescription": localize(4376, null),
          "scope": 3
          /* ConfigurationScope.APPLICATION_MACHINE */
        },
        "security.restrictUNCAccess": {
          "type": "boolean",
          "default": true,
          "markdownDescription": localize(4377, null),
          "scope": 3
          /* ConfigurationScope.APPLICATION_MACHINE */
        }
      }
    });
  }
};
DynamicWorkbenchSecurityConfiguration = __decorate([
  __param(0, IRemoteAgentService)
], DynamicWorkbenchSecurityConfiguration);
var CONFIG_NEW_WINDOW_PROFILE = "window.newWindowProfile";
var DynamicWindowConfiguration = class DynamicWindowConfiguration2 extends Disposable {
  static {
    this.ID = "workbench.contrib.dynamicWindowConfiguration";
  }
  constructor(userDataProfilesService, configurationService) {
    super();
    this.userDataProfilesService = userDataProfilesService;
    this.configurationService = configurationService;
    this.registerNewWindowProfileConfiguration();
    this._register(this.userDataProfilesService.onDidChangeProfiles((e) => this.registerNewWindowProfileConfiguration()));
    this.setNewWindowProfile();
    this.checkAndResetNewWindowProfileConfig();
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.source !== 7 && e.affectsConfiguration(CONFIG_NEW_WINDOW_PROFILE)) {
        this.setNewWindowProfile();
      }
    }));
    this._register(this.userDataProfilesService.onDidChangeProfiles(() => this.checkAndResetNewWindowProfileConfig()));
  }
  registerNewWindowProfileConfiguration() {
    const registry = Registry.as(Extensions2.Configuration);
    const configurationNode = {
      ...windowConfigurationNodeBase,
      "properties": {
        [CONFIG_NEW_WINDOW_PROFILE]: {
          "type": ["string", "null"],
          "default": null,
          "enum": [...this.userDataProfilesService.profiles.map((profile) => profile.name), null],
          "enumItemLabels": [...this.userDataProfilesService.profiles.map(() => ""), localize(4378, null)],
          "description": localize(4379, null),
          "scope": 1
        }
      }
    };
    if (this.configurationNode) {
      registry.updateConfigurations({ add: [configurationNode], remove: [this.configurationNode] });
    } else {
      registry.registerConfiguration(configurationNode);
    }
    this.configurationNode = configurationNode;
  }
  setNewWindowProfile() {
    const newWindowProfileName = this.configurationService.getValue(CONFIG_NEW_WINDOW_PROFILE);
    this.newWindowProfile = newWindowProfileName ? this.userDataProfilesService.profiles.find((profile) => profile.name === newWindowProfileName) : void 0;
  }
  checkAndResetNewWindowProfileConfig() {
    const newWindowProfileName = this.configurationService.getValue(CONFIG_NEW_WINDOW_PROFILE);
    if (!newWindowProfileName) {
      return;
    }
    const profile = this.newWindowProfile ? this.userDataProfilesService.profiles.find((profile2) => profile2.id === this.newWindowProfile.id) : void 0;
    if (newWindowProfileName === profile?.name) {
      return;
    }
    this.configurationService.updateValue(CONFIG_NEW_WINDOW_PROFILE, profile?.name);
  }
};
DynamicWindowConfiguration = __decorate([
  __param(0, IUserDataProfilesService),
  __param(1, IConfigurationService)
], DynamicWindowConfiguration);

// out-build/vs/workbench/services/editor/common/editorResolverService.js
var IEditorResolverService = createDecorator("editorResolverService");
var configurationRegistry2 = Registry.as(Extensions2.Configuration);
var editorAssociationsConfigurationNode = {
  ...workbenchConfigurationNodeBase,
  properties: {
    "workbench.editorAssociations": {
      type: "object",
      markdownDescription: localize(15251, null),
      additionalProperties: {
        type: "string"
      }
    }
  }
};
configurationRegistry2.registerConfiguration(editorAssociationsConfigurationNode);
var RegisteredEditorPriority;
(function(RegisteredEditorPriority2) {
  RegisteredEditorPriority2["builtin"] = "builtin";
  RegisteredEditorPriority2["option"] = "option";
  RegisteredEditorPriority2["exclusive"] = "exclusive";
  RegisteredEditorPriority2["default"] = "default";
})(RegisteredEditorPriority || (RegisteredEditorPriority = {}));
var ResolvedStatus;
(function(ResolvedStatus2) {
  ResolvedStatus2[ResolvedStatus2["ABORT"] = 1] = "ABORT";
  ResolvedStatus2[ResolvedStatus2["NONE"] = 2] = "NONE";
})(ResolvedStatus || (ResolvedStatus = {}));
function globMatchesResource(globPattern, resource) {
  const excludedSchemes = /* @__PURE__ */ new Set([
    Schemas.extension,
    Schemas.webviewPanel,
    Schemas.vscodeWorkspaceTrust,
    Schemas.vscodeSettings
  ]);
  if (excludedSchemes.has(resource.scheme)) {
    return false;
  }
  const matchOnPath = typeof globPattern === "string" && globPattern.indexOf(posix.sep) >= 0;
  const target = matchOnPath ? `${resource.scheme}:${resource.path}` : basename2(resource);
  return match(globPattern, target, { ignoreCase: true });
}

// out-build/vs/workbench/api/common/extHostNotebook.js
var ExtHostNotebookController = class _ExtHostNotebookController {
  static {
    this._notebookStatusBarItemProviderHandlePool = 0;
  }
  get activeNotebookEditor() {
    return this._activeNotebookEditor?.apiEditor;
  }
  get visibleNotebookEditors() {
    return this._visibleNotebookEditors.map((editor) => editor.apiEditor);
  }
  constructor(mainContext, commands, _textDocumentsAndEditors, _textDocuments, _extHostFileSystem, _extHostSearch, _logService) {
    this._textDocumentsAndEditors = _textDocumentsAndEditors;
    this._textDocuments = _textDocuments;
    this._extHostFileSystem = _extHostFileSystem;
    this._extHostSearch = _extHostSearch;
    this._logService = _logService;
    this._notebookStatusBarItemProviders = /* @__PURE__ */ new Map();
    this._documents = new ResourceMap();
    this._editors = /* @__PURE__ */ new Map();
    this._onDidChangeActiveNotebookEditor = new Emitter();
    this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event;
    this._visibleNotebookEditors = [];
    this._onDidOpenNotebookDocument = new Emitter();
    this.onDidOpenNotebookDocument = this._onDidOpenNotebookDocument.event;
    this._onDidCloseNotebookDocument = new Emitter();
    this.onDidCloseNotebookDocument = this._onDidCloseNotebookDocument.event;
    this._onDidChangeVisibleNotebookEditors = new Emitter();
    this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event;
    this._statusBarCache = new Cache2("NotebookCellStatusBarCache");
    this._handlePool = 0;
    this._notebookSerializer = /* @__PURE__ */ new Map();
    this._notebookProxy = mainContext.getProxy(MainContext.MainThreadNotebook);
    this._notebookDocumentsProxy = mainContext.getProxy(MainContext.MainThreadNotebookDocuments);
    this._notebookEditorsProxy = mainContext.getProxy(MainContext.MainThreadNotebookEditors);
    this._commandsConverter = commands.converter;
    commands.registerArgumentProcessor({
      // Serialized INotebookCellActionContext
      processArgument: (arg) => {
        if (arg && arg.$mid === 13) {
          const notebookUri = arg.notebookEditor?.notebookUri;
          const cellHandle = arg.cell.handle;
          const data2 = this._documents.get(notebookUri);
          const cell = data2?.getCell(cellHandle);
          if (cell) {
            return cell.apiCell;
          }
        }
        if (arg && arg.$mid === 14) {
          const notebookUri = arg.uri;
          const data2 = this._documents.get(notebookUri);
          if (data2) {
            return data2.apiNotebook;
          }
        }
        return arg;
      }
    });
    _ExtHostNotebookController._registerApiCommands(commands);
  }
  getEditorById(editorId) {
    const editor = this._editors.get(editorId);
    if (!editor) {
      throw new Error(`unknown text editor: ${editorId}. known editors: ${[...this._editors.keys()]} `);
    }
    return editor;
  }
  getIdByEditor(editor) {
    for (const [id2, candidate] of this._editors) {
      if (candidate.apiEditor === editor) {
        return id2;
      }
    }
    return void 0;
  }
  get notebookDocuments() {
    return [...this._documents.values()];
  }
  getNotebookDocument(uri, relaxed) {
    const result = this._documents.get(uri);
    if (!result && !relaxed) {
      throw new Error(`NO notebook document for '${uri}'`);
    }
    return result;
  }
  static _convertNotebookRegistrationData(extension, registration) {
    if (!registration) {
      return;
    }
    const viewOptionsFilenamePattern = registration.filenamePattern.map((pattern) => NotebookExclusiveDocumentPattern.from(pattern)).filter((pattern) => pattern !== void 0);
    if (registration.filenamePattern && !viewOptionsFilenamePattern) {
      console.warn(`Notebook content provider view options file name pattern is invalid ${registration.filenamePattern}`);
      return void 0;
    }
    return {
      extension: extension.identifier,
      providerDisplayName: extension.displayName || extension.name,
      displayName: registration.displayName,
      filenamePattern: viewOptionsFilenamePattern,
      priority: registration.exclusive ? RegisteredEditorPriority.exclusive : void 0
    };
  }
  registerNotebookCellStatusBarItemProvider(extension, notebookType, provider) {
    const handle = _ExtHostNotebookController._notebookStatusBarItemProviderHandlePool++;
    const eventHandle = typeof provider.onDidChangeCellStatusBarItems === "function" ? _ExtHostNotebookController._notebookStatusBarItemProviderHandlePool++ : void 0;
    this._notebookStatusBarItemProviders.set(handle, provider);
    this._notebookProxy.$registerNotebookCellStatusBarItemProvider(handle, eventHandle, notebookType);
    let subscription;
    if (eventHandle !== void 0) {
      subscription = provider.onDidChangeCellStatusBarItems((_) => this._notebookProxy.$emitCellStatusBarEvent(eventHandle));
    }
    return new Disposable2(() => {
      this._notebookStatusBarItemProviders.delete(handle);
      this._notebookProxy.$unregisterNotebookCellStatusBarItemProvider(handle, eventHandle);
      subscription?.dispose();
    });
  }
  async createNotebookDocument(options2) {
    const canonicalUri = await this._notebookDocumentsProxy.$tryCreateNotebook({
      viewType: options2.viewType,
      content: options2.content && NotebookData2.from(options2.content)
    });
    return URI.revive(canonicalUri);
  }
  async openNotebookDocument(uri) {
    const cached = this._documents.get(uri);
    if (cached) {
      return cached.apiNotebook;
    }
    const canonicalUri = await this._notebookDocumentsProxy.$tryOpenNotebook(uri);
    const document2 = this._documents.get(URI.revive(canonicalUri));
    return assertReturnsDefined(document2?.apiNotebook);
  }
  async showNotebookDocument(notebook, options2) {
    let resolvedOptions;
    if (typeof options2 === "object") {
      resolvedOptions = {
        position: ViewColumn2.from(options2.viewColumn),
        preserveFocus: options2.preserveFocus,
        selections: options2.selections && options2.selections.map(NotebookRange2.from),
        pinned: typeof options2.preview === "boolean" ? !options2.preview : void 0,
        label: typeof options2.asRepl === "string" ? options2.asRepl : typeof options2.asRepl === "object" ? options2.asRepl.label : void 0
      };
    } else {
      resolvedOptions = {
        preserveFocus: false,
        pinned: true
      };
    }
    const viewType = !!options2?.asRepl ? "repl" : notebook.notebookType;
    const editorId = await this._notebookEditorsProxy.$tryShowNotebookDocument(notebook.uri, viewType, resolvedOptions);
    const editor = editorId && this._editors.get(editorId)?.apiEditor;
    if (editor) {
      return editor;
    }
    if (editorId) {
      throw new Error(`Could NOT open editor for "${notebook.uri.toString()}" because another editor opened in the meantime.`);
    } else {
      throw new Error(`Could NOT open editor for "${notebook.uri.toString()}".`);
    }
  }
  async $provideNotebookCellStatusBarItems(handle, uri, index, token) {
    const provider = this._notebookStatusBarItemProviders.get(handle);
    const revivedUri = URI.revive(uri);
    const document2 = this._documents.get(revivedUri);
    if (!document2 || !provider) {
      return;
    }
    const cell = document2.getCellFromIndex(index);
    if (!cell) {
      return;
    }
    const result = await provider.provideCellStatusBarItems(cell.apiCell, token);
    if (!result) {
      return void 0;
    }
    const disposables = new DisposableStore();
    const cacheId = this._statusBarCache.add([disposables]);
    const resultArr = Array.isArray(result) ? result : [result];
    const items = resultArr.map((item) => NotebookStatusBarItem.from(item, this._commandsConverter, disposables));
    return {
      cacheId,
      items
    };
  }
  $releaseNotebookCellStatusBarItems(cacheId) {
    this._statusBarCache.delete(cacheId);
  }
  registerNotebookSerializer(extension, viewType, serializer, options2, registration) {
    if (isFalsyOrWhitespace(viewType)) {
      throw new Error(`viewType cannot be empty or just whitespace`);
    }
    const handle = this._handlePool++;
    this._notebookSerializer.set(handle, { viewType, serializer, options: options2 });
    this._notebookProxy.$registerNotebookSerializer(handle, { id: extension.identifier, location: extension.extensionLocation }, viewType, NotebookDocumentContentOptions.from(options2), _ExtHostNotebookController._convertNotebookRegistrationData(extension, registration));
    return toDisposable(() => {
      this._notebookProxy.$unregisterNotebookSerializer(handle);
    });
  }
  async $dataToNotebook(handle, bytes, token) {
    const serializer = this._notebookSerializer.get(handle);
    if (!serializer) {
      throw new Error("NO serializer found");
    }
    const data2 = await serializer.serializer.deserializeNotebook(bytes.buffer, token);
    return new SerializableObjectWithBuffers(NotebookData2.from(data2));
  }
  async $notebookToData(handle, data2, token) {
    const serializer = this._notebookSerializer.get(handle);
    if (!serializer) {
      throw new Error("NO serializer found");
    }
    const bytes = await serializer.serializer.serializeNotebook(NotebookData2.to(data2.value), token);
    return VSBuffer.wrap(bytes);
  }
  async $saveNotebook(handle, uriComponents, versionId, options2, token) {
    const uri = URI.revive(uriComponents);
    const serializer = this._notebookSerializer.get(handle);
    this.trace(`enter saveNotebook(versionId: ${versionId}, ${uri.toString()})`);
    try {
      if (!serializer) {
        throw new NotebookSaveError("NO serializer found");
      }
      const document2 = this._documents.get(uri);
      if (!document2) {
        throw new NotebookSaveError("Document NOT found");
      }
      if (document2.versionId !== versionId) {
        throw new NotebookSaveError("Document version mismatch, expected: " + versionId + ", actual: " + document2.versionId);
      }
      if (!this._extHostFileSystem.value.isWritableFileSystem(uri.scheme)) {
        throw new FileOperationError(
          localize(3018, null, this._resourceForError(uri)),
          6
          /* files.FileOperationResult.FILE_PERMISSION_DENIED */
        );
      }
      const data2 = {
        metadata: filter(document2.apiNotebook.metadata, (key) => !(serializer.options?.transientDocumentMetadata ?? {})[key]),
        cells: []
      };
      for (const cell of document2.apiNotebook.getCells()) {
        const cellData = new NotebookCellData(cell.kind, cell.document.getText(), cell.document.languageId, cell.mime, !serializer.options?.transientOutputs ? [...cell.outputs] : [], cell.metadata, cell.executionSummary);
        cellData.metadata = filter(cell.metadata, (key) => !(serializer.options?.transientCellMetadata ?? {})[key]);
        data2.cells.push(cellData);
      }
      await this._validateWriteFile(uri, options2);
      if (token.isCancellationRequested) {
        throw new CancellationError();
      }
      const bytes = await serializer.serializer.serializeNotebook(data2, token);
      if (token.isCancellationRequested) {
        throw new CancellationError();
      }
      this.trace(`serialized versionId: ${versionId} ${uri.toString()}`);
      await this._extHostFileSystem.value.writeFile(uri, bytes);
      this.trace(`Finished write versionId: ${versionId} ${uri.toString()}`);
      const providerExtUri = this._extHostFileSystem.getFileSystemProviderExtUri(uri.scheme);
      const stat = await this._extHostFileSystem.value.stat(uri);
      const fileStats = {
        name: providerExtUri.basename(uri),
        isFile: (stat.type & FileType.File) !== 0,
        isDirectory: (stat.type & FileType.Directory) !== 0,
        isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,
        mtime: stat.mtime,
        ctime: stat.ctime,
        size: stat.size,
        readonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || !this._extHostFileSystem.value.isWritableFileSystem(uri.scheme),
        locked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),
        etag: etag({ mtime: stat.mtime, size: stat.size }),
        children: void 0
      };
      this.trace(`exit saveNotebook(versionId: ${versionId}, ${uri.toString()})`);
      return fileStats;
    } catch (error) {
      if (error instanceof FileOperationError) {
        return { ...error, message: error.message };
      }
      throw error;
    }
  }
  /**
   * Search for query in all notebooks that can be deserialized by the serializer fetched by `handle`.
   *
   * @param handle used to get notebook serializer
   * @param textQuery the text query to search using
   * @param viewTypeFileTargets the globs (and associated ranks) that are targetting for opening this type of notebook
   * @param otherViewTypeFileTargets ranked globs for other editors that we should consider when deciding whether it will open as this notebook
   * @param token cancellation token
   * @returns `IRawClosedNotebookFileMatch` for every file. Files without matches will just have a `IRawClosedNotebookFileMatch`
   * 	with no `cellResults`. This allows the caller to know what was searched in already, even if it did not yield results.
   */
  async $searchInNotebooks(handle, textQuery, viewTypeFileTargets, otherViewTypeFileTargets, token) {
    const serializer = this._notebookSerializer.get(handle)?.serializer;
    if (!serializer) {
      return {
        limitHit: false,
        results: []
      };
    }
    const finalMatchedTargets = new ResourceSet();
    const runFileQueries = async (includes, token2, textQuery2) => {
      await Promise.all(includes.map(async (include) => await Promise.all(include.filenamePatterns.map((filePattern) => {
        const query = {
          _reason: textQuery2._reason,
          folderQueries: textQuery2.folderQueries,
          includePattern: textQuery2.includePattern,
          excludePattern: textQuery2.excludePattern,
          maxResults: textQuery2.maxResults,
          type: 1,
          filePattern
        };
        return this._extHostSearch.doInternalFileSearchWithCustomCallback(query, token2, (data2) => {
          data2.forEach((uri) => {
            if (finalMatchedTargets.has(uri)) {
              return;
            }
            const hasOtherMatches = otherViewTypeFileTargets.some((target) => {
              if (include.isFromSettings && !target.isFromSettings) {
                return false;
              } else {
                return target.filenamePatterns.some((targetFilePattern) => globMatchesResource(targetFilePattern, uri));
              }
            });
            if (hasOtherMatches) {
              return;
            }
            finalMatchedTargets.add(uri);
          });
        }).catch((err) => {
          if (err.code === "ENOENT") {
            console.warn(`Could not find notebook search results, ignoring notebook results.`);
            return {
              limitHit: false,
              messages: []
            };
          } else {
            throw err;
          }
        });
      }))));
      return;
    };
    await runFileQueries(viewTypeFileTargets, token, textQuery);
    const results = new ResourceMap();
    let limitHit = false;
    const promises = Array.from(finalMatchedTargets).map(async (uri) => {
      const cellMatches = [];
      try {
        if (token.isCancellationRequested) {
          return;
        }
        if (textQuery.maxResults && [...results.values()].reduce((acc, value) => acc + value.cellResults.length, 0) > textQuery.maxResults) {
          limitHit = true;
          return;
        }
        const simpleCells = [];
        const notebook = this._documents.get(uri);
        if (notebook) {
          const cells = notebook.apiNotebook.getCells();
          cells.forEach((e) => simpleCells.push({
            input: e.document.getText(),
            outputs: e.outputs.flatMap((value) => value.items.map((output) => output.data.toString()))
          }));
        } else {
          const fileContent = await this._extHostFileSystem.value.readFile(uri);
          const bytes = VSBuffer.fromString(fileContent.toString());
          const notebook2 = await serializer.deserializeNotebook(bytes.buffer, token);
          if (token.isCancellationRequested) {
            return;
          }
          const data2 = NotebookData2.from(notebook2);
          data2.cells.forEach((cell) => simpleCells.push({
            input: cell.source,
            outputs: cell.outputs.flatMap((value) => value.items.map((output) => output.valueBytes.toString()))
          }));
        }
        if (token.isCancellationRequested) {
          return;
        }
        simpleCells.forEach((cell, index) => {
          const target = textQuery.contentPattern.pattern;
          const cellModel = new CellSearchModel(cell.input, void 0, cell.outputs);
          const inputMatches = cellModel.findInInputs(target);
          const outputMatches = cellModel.findInOutputs(target);
          const webviewResults = outputMatches.flatMap((outputMatch) => genericCellMatchesToTextSearchMatches(outputMatch.matches, outputMatch.textBuffer)).map((textMatch, index2) => {
            textMatch.webviewIndex = index2;
            return textMatch;
          });
          if (inputMatches.length > 0 || outputMatches.length > 0) {
            const cellMatch = {
              index,
              contentResults: genericCellMatchesToTextSearchMatches(inputMatches, cellModel.inputTextBuffer),
              webviewResults
            };
            cellMatches.push(cellMatch);
          }
        });
        const fileMatch = {
          resource: uri,
          cellResults: cellMatches
        };
        results.set(uri, fileMatch);
        return;
      } catch (e) {
        return;
      }
    });
    await Promise.all(promises);
    return {
      limitHit,
      results: [...results.values()]
    };
  }
  async _validateWriteFile(uri, options2) {
    const stat = await this._extHostFileSystem.value.stat(uri);
    if (typeof options2?.mtime === "number" && typeof options2.etag === "string" && options2.etag !== ETAG_DISABLED && typeof stat.mtime === "number" && typeof stat.size === "number" && options2.mtime < stat.mtime && options2.etag !== etag({ mtime: options2.mtime, size: stat.size })) {
      throw new FileOperationError(localize(3019, null), 3, options2);
    }
    return;
  }
  _resourceForError(uri) {
    return uri.scheme === Schemas.file ? uri.fsPath : uri.toString();
  }
  // --- open, save, saveAs, backup
  _createExtHostEditor(document2, editorId, data2) {
    if (this._editors.has(editorId)) {
      throw new Error(`editor with id ALREADY EXSIST: ${editorId}`);
    }
    const editor = new ExtHostNotebookEditor(editorId, this._notebookEditorsProxy, document2, data2.visibleRanges.map(NotebookRange2.to), data2.selections.map(NotebookRange2.to), typeof data2.viewColumn === "number" ? ViewColumn2.to(data2.viewColumn) : void 0, data2.viewType);
    this._editors.set(editorId, editor);
  }
  $acceptDocumentAndEditorsDelta(delta3) {
    if (delta3.value.removedDocuments) {
      for (const uri of delta3.value.removedDocuments) {
        const revivedUri = URI.revive(uri);
        const document2 = this._documents.get(revivedUri);
        if (document2) {
          document2.dispose();
          this._documents.delete(revivedUri);
          this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ removedDocuments: document2.apiNotebook.getCells().map((cell) => cell.document.uri) });
          this._onDidCloseNotebookDocument.fire(document2.apiNotebook);
        }
        for (const editor of this._editors.values()) {
          if (editor.notebookData.uri.toString() === revivedUri.toString()) {
            this._editors.delete(editor.id);
          }
        }
      }
    }
    if (delta3.value.addedDocuments) {
      const addedCellDocuments = [];
      for (const modelData of delta3.value.addedDocuments) {
        const uri = URI.revive(modelData.uri);
        if (this._documents.has(uri)) {
          throw new Error(`adding EXISTING notebook ${uri} `);
        }
        const document2 = new ExtHostNotebookDocument(this._notebookDocumentsProxy, this._textDocumentsAndEditors, this._textDocuments, uri, modelData);
        addedCellDocuments.push(...modelData.cells.map((cell) => ExtHostCell.asModelAddData(cell)));
        this._documents.get(uri)?.dispose();
        this._documents.set(uri, document2);
        this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ addedDocuments: addedCellDocuments });
        this._onDidOpenNotebookDocument.fire(document2.apiNotebook);
      }
    }
    if (delta3.value.addedEditors) {
      for (const editorModelData of delta3.value.addedEditors) {
        if (this._editors.has(editorModelData.id)) {
          return;
        }
        const revivedUri = URI.revive(editorModelData.documentUri);
        const document2 = this._documents.get(revivedUri);
        if (document2) {
          this._createExtHostEditor(document2, editorModelData.id, editorModelData);
        }
      }
    }
    const removedEditors = [];
    if (delta3.value.removedEditors) {
      for (const editorid of delta3.value.removedEditors) {
        const editor = this._editors.get(editorid);
        if (editor) {
          this._editors.delete(editorid);
          if (this._activeNotebookEditor?.id === editor.id) {
            this._activeNotebookEditor = void 0;
          }
          removedEditors.push(editor);
        }
      }
    }
    if (delta3.value.visibleEditors) {
      this._visibleNotebookEditors = delta3.value.visibleEditors.map((id2) => this._editors.get(id2)).filter((editor) => !!editor);
      const visibleEditorsSet = /* @__PURE__ */ new Set();
      this._visibleNotebookEditors.forEach((editor) => visibleEditorsSet.add(editor.id));
      for (const editor of this._editors.values()) {
        const newValue = visibleEditorsSet.has(editor.id);
        editor._acceptVisibility(newValue);
      }
      this._visibleNotebookEditors = [...this._editors.values()].map((e) => e).filter((e) => e.visible);
      this._onDidChangeVisibleNotebookEditors.fire(this.visibleNotebookEditors);
    }
    if (delta3.value.newActiveEditor === null) {
      this._activeNotebookEditor = void 0;
    } else if (delta3.value.newActiveEditor) {
      const activeEditor = this._editors.get(delta3.value.newActiveEditor);
      if (!activeEditor) {
        console.error(`FAILED to find active notebook editor ${delta3.value.newActiveEditor}`);
      }
      this._activeNotebookEditor = this._editors.get(delta3.value.newActiveEditor);
    }
    if (delta3.value.newActiveEditor !== void 0) {
      this._onDidChangeActiveNotebookEditor.fire(this._activeNotebookEditor?.apiEditor);
    }
  }
  static _registerApiCommands(extHostCommands) {
    const notebookTypeArg = ApiCommandArgument.String.with("notebookType", "A notebook type");
    const commandDataToNotebook = new ApiCommand("vscode.executeDataToNotebook", "_executeDataToNotebook", "Invoke notebook serializer", [notebookTypeArg, new ApiCommandArgument("data", "Bytes to convert to data", (v) => v instanceof Uint8Array, (v) => VSBuffer.wrap(v))], new ApiCommandResult("Notebook Data", (data2) => NotebookData2.to(data2.value)));
    const commandNotebookToData = new ApiCommand("vscode.executeNotebookToData", "_executeNotebookToData", "Invoke notebook serializer", [notebookTypeArg, new ApiCommandArgument("NotebookData", "Notebook data to convert to bytes", (v) => true, (v) => new SerializableObjectWithBuffers(NotebookData2.from(v)))], new ApiCommandResult("Bytes", (dto) => dto.buffer));
    extHostCommands.registerApiCommand(commandDataToNotebook);
    extHostCommands.registerApiCommand(commandNotebookToData);
  }
  trace(msg) {
    this._logService.trace(`[Extension Host Notebook] ${msg}`);
  }
};
var NotebookSaveError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotebookSaveError";
  }
};

// out-build/vs/workbench/api/common/extHostNotebookDocumentSaveParticipant.js
var ExtHostNotebookDocumentSaveParticipant = class {
  constructor(_logService, _notebooksAndEditors, _mainThreadBulkEdits, _thresholds = { timeout: 1500, errors: 3 }) {
    this._logService = _logService;
    this._notebooksAndEditors = _notebooksAndEditors;
    this._mainThreadBulkEdits = _mainThreadBulkEdits;
    this._thresholds = _thresholds;
    this._onWillSaveNotebookDocumentEvent = new AsyncEmitter();
  }
  dispose() {
  }
  getOnWillSaveNotebookDocumentEvent(extension) {
    return (listener, thisArg, disposables) => {
      const wrappedListener = function wrapped(e) {
        listener.call(thisArg, e);
      };
      wrappedListener.extension = extension;
      return this._onWillSaveNotebookDocumentEvent.event(wrappedListener, void 0, disposables);
    };
  }
  async $participateInSave(resource, reason, token) {
    const revivedUri = URI.revive(resource);
    const document2 = this._notebooksAndEditors.getNotebookDocument(revivedUri);
    if (!document2) {
      throw new Error("Unable to resolve notebook document");
    }
    const edits = [];
    await this._onWillSaveNotebookDocumentEvent.fireAsync({ notebook: document2.apiNotebook, reason: TextDocumentSaveReason2.to(reason) }, token, async (thenable, listener) => {
      const now = Date.now();
      const data2 = await await Promise.resolve(thenable);
      if (Date.now() - now > this._thresholds.timeout) {
        this._logService.warn("onWillSaveNotebookDocument-listener from extension", listener.extension.identifier);
      }
      if (token.isCancellationRequested) {
        return;
      }
      if (data2) {
        if (data2 instanceof WorkspaceEdit) {
          edits.push(data2);
        } else {
          this._logService.warn("onWillSaveNotebookDocument-listener from extension", listener.extension.identifier, "ignored due to invalid data");
        }
      }
      return;
    });
    if (token.isCancellationRequested) {
      return false;
    }
    if (edits.length === 0) {
      return true;
    }
    const dto = { edits: [] };
    for (const edit2 of edits) {
      const { edits: edits2 } = WorkspaceEdit3.from(edit2);
      dto.edits = dto.edits.concat(edits2);
    }
    return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new SerializableObjectWithBuffers(dto));
  }
};

// out-build/vs/workbench/api/common/extHostNotebookDocuments.js
var ExtHostNotebookDocuments = class {
  constructor(_notebooksAndEditors) {
    this._notebooksAndEditors = _notebooksAndEditors;
    this._onDidSaveNotebookDocument = new Emitter();
    this.onDidSaveNotebookDocument = this._onDidSaveNotebookDocument.event;
    this._onDidChangeNotebookDocument = new Emitter();
    this.onDidChangeNotebookDocument = this._onDidChangeNotebookDocument.event;
  }
  $acceptModelChanged(uri, event, isDirty, newMetadata) {
    const document2 = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));
    const e = document2.acceptModelChanged(event.value, isDirty, newMetadata);
    this._onDidChangeNotebookDocument.fire(e);
  }
  $acceptDirtyStateChanged(uri, isDirty) {
    const document2 = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));
    document2.acceptDirty(isDirty);
  }
  $acceptModelSaved(uri) {
    const document2 = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));
    this._onDidSaveNotebookDocument.fire(document2.apiNotebook);
  }
};

// out-build/vs/workbench/api/common/extHostNotebookEditors.js
var ExtHostNotebookEditors = class ExtHostNotebookEditors2 {
  constructor(_logService, _notebooksAndEditors) {
    this._logService = _logService;
    this._notebooksAndEditors = _notebooksAndEditors;
    this._onDidChangeNotebookEditorSelection = new Emitter();
    this._onDidChangeNotebookEditorVisibleRanges = new Emitter();
    this.onDidChangeNotebookEditorSelection = this._onDidChangeNotebookEditorSelection.event;
    this.onDidChangeNotebookEditorVisibleRanges = this._onDidChangeNotebookEditorVisibleRanges.event;
  }
  $acceptEditorPropertiesChanged(id2, data2) {
    this._logService.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", id2, data2);
    const editor = this._notebooksAndEditors.getEditorById(id2);
    if (data2.visibleRanges) {
      editor._acceptVisibleRanges(data2.visibleRanges.ranges.map(NotebookRange2.to));
    }
    if (data2.selections) {
      editor._acceptSelections(data2.selections.selections.map(NotebookRange2.to));
    }
    if (data2.visibleRanges) {
      this._onDidChangeNotebookEditorVisibleRanges.fire({
        notebookEditor: editor.apiEditor,
        visibleRanges: editor.apiEditor.visibleRanges
      });
    }
    if (data2.selections) {
      this._onDidChangeNotebookEditorSelection.fire(Object.freeze({
        notebookEditor: editor.apiEditor,
        selections: editor.apiEditor.selections
      }));
    }
  }
  $acceptEditorViewColumns(data2) {
    for (const id2 in data2) {
      const editor = this._notebooksAndEditors.getEditorById(id2);
      editor._acceptViewColumn(ViewColumn2.to(data2[id2]));
    }
  }
};
ExtHostNotebookEditors = __decorate([
  __param(0, ILogService)
], ExtHostNotebookEditors);

// out-build/vs/workbench/contrib/notebook/common/notebookExecutionService.js
var CellExecutionUpdateType;
(function(CellExecutionUpdateType2) {
  CellExecutionUpdateType2[CellExecutionUpdateType2["Output"] = 1] = "Output";
  CellExecutionUpdateType2[CellExecutionUpdateType2["OutputItems"] = 2] = "OutputItems";
  CellExecutionUpdateType2[CellExecutionUpdateType2["ExecutionState"] = 3] = "ExecutionState";
})(CellExecutionUpdateType || (CellExecutionUpdateType = {}));
var INotebookExecutionService = createDecorator("INotebookExecutionService");

// out-build/vs/workbench/contrib/notebook/common/notebookKernelService.js
var variablePageSize = 100;
var ProxyKernelState;
(function(ProxyKernelState2) {
  ProxyKernelState2[ProxyKernelState2["Disconnected"] = 1] = "Disconnected";
  ProxyKernelState2[ProxyKernelState2["Connected"] = 2] = "Connected";
  ProxyKernelState2[ProxyKernelState2["Initializing"] = 3] = "Initializing";
})(ProxyKernelState || (ProxyKernelState = {}));
var INotebookKernelService = createDecorator("INotebookKernelService");
var INotebookKernelHistoryService = createDecorator("INotebookKernelHistoryService");

// out-build/vs/workbench/api/common/extHostNotebookKernels.js
var ExtHostNotebookKernels = class ExtHostNotebookKernels2 {
  constructor(mainContext, _initData, _extHostNotebook, _commands, _logService) {
    this._initData = _initData;
    this._extHostNotebook = _extHostNotebook;
    this._commands = _commands;
    this._logService = _logService;
    this._activeExecutions = new ResourceMap();
    this._activeNotebookExecutions = new ResourceMap();
    this._kernelDetectionTask = /* @__PURE__ */ new Map();
    this._kernelDetectionTaskHandlePool = 0;
    this._kernelSourceActionProviders = /* @__PURE__ */ new Map();
    this._kernelSourceActionProviderHandlePool = 0;
    this._kernelData = /* @__PURE__ */ new Map();
    this._handlePool = 0;
    this.id = 0;
    this.variableStore = {};
    this._proxy = mainContext.getProxy(MainContext.MainThreadNotebookKernels);
    const selectKernelApiCommand = new ApiCommand("notebook.selectKernel", "_notebook.selectKernel", "Trigger kernel picker for specified notebook editor widget", [
      new ApiCommandArgument("options", "Select kernel options", (v) => true, (v) => {
        if (v && "notebookEditor" in v && "id" in v) {
          const notebookEditorId = this._extHostNotebook.getIdByEditor(v.notebookEditor);
          return {
            id: v.id,
            extension: v.extension,
            notebookEditorId
          };
        } else if (v && "notebookEditor" in v) {
          const notebookEditorId = this._extHostNotebook.getIdByEditor(v.notebookEditor);
          if (notebookEditorId === void 0) {
            throw new Error(`Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${v.notebookEditor.notebook.uri.toString()}`);
          }
          if ("skipIfAlreadySelected" in v) {
            return { notebookEditorId, skipIfAlreadySelected: v.skipIfAlreadySelected };
          }
          return { notebookEditorId };
        }
        return v;
      })
    ], ApiCommandResult.Void);
    const requestKernelVariablesApiCommand = new ApiCommand("vscode.executeNotebookVariableProvider", "_executeNotebookVariableProvider", "Execute notebook variable provider", [ApiCommandArgument.Uri], new ApiCommandResult("A promise that resolves to an array of variables", (value, apiArgs) => {
      return value.map((variable) => {
        return {
          variable: {
            name: variable.name,
            value: variable.value,
            expression: variable.expression,
            type: variable.type,
            language: variable.language
          },
          hasNamedChildren: variable.hasNamedChildren,
          indexedChildrenCount: variable.indexedChildrenCount
        };
      });
    }));
    this._commands.registerApiCommand(selectKernelApiCommand);
    this._commands.registerApiCommand(requestKernelVariablesApiCommand);
  }
  createNotebookController(extension, id2, viewType, label, handler, preloads) {
    for (const data3 of this._kernelData.values()) {
      if (data3.controller.id === id2 && ExtensionIdentifier.equals(extension.identifier, data3.extensionId)) {
        throw new Error(`notebook controller with id '${id2}' ALREADY exist`);
      }
    }
    const handle = this._handlePool++;
    const that = this;
    this._logService.trace(`NotebookController[${handle}], CREATED by ${extension.identifier.value}, ${id2}`);
    const _defaultExecutHandler = () => console.warn(`NO execute handler from notebook controller '${data2.id}' of extension: '${extension.identifier}'`);
    let isDisposed = false;
    const onDidChangeSelection = new Emitter();
    const onDidReceiveMessage = new Emitter();
    const data2 = {
      id: createKernelId(extension.identifier, id2),
      notebookType: viewType,
      extensionId: extension.identifier,
      extensionLocation: extension.extensionLocation,
      label: label || extension.identifier.value,
      preloads: preloads ? preloads.map(NotebookRendererScript2.from) : []
    };
    let _executeHandler = handler ?? _defaultExecutHandler;
    let _interruptHandler;
    let _variableProvider;
    this._proxy.$addKernel(handle, data2).catch((err) => {
      console.log(err);
      isDisposed = true;
    });
    let tokenPool = 0;
    const _update = () => {
      if (isDisposed) {
        return;
      }
      const myToken = ++tokenPool;
      Promise.resolve().then(() => {
        if (myToken === tokenPool) {
          this._proxy.$updateKernel(handle, data2);
        }
      });
    };
    const associatedNotebooks = new ResourceMap();
    const controller = {
      get id() {
        return id2;
      },
      get notebookType() {
        return data2.notebookType;
      },
      onDidChangeSelectedNotebooks: onDidChangeSelection.event,
      get label() {
        return data2.label;
      },
      set label(value) {
        data2.label = value ?? extension.displayName ?? extension.name;
        _update();
      },
      get detail() {
        return data2.detail ?? "";
      },
      set detail(value) {
        data2.detail = value;
        _update();
      },
      get description() {
        return data2.description ?? "";
      },
      set description(value) {
        data2.description = value;
        _update();
      },
      get supportedLanguages() {
        return data2.supportedLanguages;
      },
      set supportedLanguages(value) {
        data2.supportedLanguages = value;
        _update();
      },
      get supportsExecutionOrder() {
        return data2.supportsExecutionOrder ?? false;
      },
      set supportsExecutionOrder(value) {
        data2.supportsExecutionOrder = value;
        _update();
      },
      get rendererScripts() {
        return data2.preloads ? data2.preloads.map(NotebookRendererScript2.to) : [];
      },
      get executeHandler() {
        return _executeHandler;
      },
      set executeHandler(value) {
        _executeHandler = value ?? _defaultExecutHandler;
      },
      get interruptHandler() {
        return _interruptHandler;
      },
      set interruptHandler(value) {
        _interruptHandler = value;
        data2.supportsInterrupt = Boolean(value);
        _update();
      },
      set variableProvider(value) {
        checkProposedApiEnabled(extension, "notebookVariableProvider");
        _variableProvider = value;
        data2.hasVariableProvider = !!value;
        value?.onDidChangeVariables((e) => that._proxy.$variablesUpdated(e.uri));
        _update();
      },
      get variableProvider() {
        return _variableProvider;
      },
      createNotebookCellExecution(cell) {
        if (isDisposed) {
          throw new Error("notebook controller is DISPOSED");
        }
        if (!associatedNotebooks.has(cell.notebook.uri)) {
          that._logService.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(associatedNotebooks.keys()).map((u) => u.toString()));
          throw new Error(`notebook controller is NOT associated to notebook: ${cell.notebook.uri.toString()}`);
        }
        return that._createNotebookCellExecution(cell, createKernelId(extension.identifier, this.id));
      },
      createNotebookExecution(notebook) {
        checkProposedApiEnabled(extension, "notebookExecution");
        if (isDisposed) {
          throw new Error("notebook controller is DISPOSED");
        }
        if (!associatedNotebooks.has(notebook.uri)) {
          that._logService.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(associatedNotebooks.keys()).map((u) => u.toString()));
          throw new Error(`notebook controller is NOT associated to notebook: ${notebook.uri.toString()}`);
        }
        return that._createNotebookExecution(notebook, createKernelId(extension.identifier, this.id));
      },
      dispose: () => {
        if (!isDisposed) {
          this._logService.trace(`NotebookController[${handle}], DISPOSED`);
          isDisposed = true;
          this._kernelData.delete(handle);
          onDidChangeSelection.dispose();
          onDidReceiveMessage.dispose();
          this._proxy.$removeKernel(handle);
        }
      },
      // --- priority
      updateNotebookAffinity(notebook, priority) {
        if (priority === NotebookControllerAffinity2.Hidden) {
          checkProposedApiEnabled(extension, "notebookControllerAffinityHidden");
        }
        that._proxy.$updateNotebookPriority(handle, notebook.uri, priority);
      },
      // --- ipc
      onDidReceiveMessage: onDidReceiveMessage.event,
      postMessage(message, editor) {
        checkProposedApiEnabled(extension, "notebookMessaging");
        return that._proxy.$postMessage(handle, editor && that._extHostNotebook.getIdByEditor(editor), message);
      },
      asWebviewUri(uri) {
        checkProposedApiEnabled(extension, "notebookMessaging");
        return asWebviewUri(uri, that._initData.remote);
      }
    };
    this._kernelData.set(handle, {
      extensionId: extension.identifier,
      controller,
      onDidReceiveMessage,
      onDidChangeSelection,
      associatedNotebooks
    });
    return controller;
  }
  getIdByController(controller) {
    for (const [_, candidate] of this._kernelData) {
      if (candidate.controller === controller) {
        return createKernelId(candidate.extensionId, controller.id);
      }
    }
    return null;
  }
  createNotebookControllerDetectionTask(extension, viewType) {
    const handle = this._kernelDetectionTaskHandlePool++;
    const that = this;
    this._logService.trace(`NotebookControllerDetectionTask[${handle}], CREATED by ${extension.identifier.value}`);
    this._proxy.$addKernelDetectionTask(handle, viewType);
    const detectionTask = {
      dispose: () => {
        this._kernelDetectionTask.delete(handle);
        that._proxy.$removeKernelDetectionTask(handle);
      }
    };
    this._kernelDetectionTask.set(handle, detectionTask);
    return detectionTask;
  }
  registerKernelSourceActionProvider(extension, viewType, provider) {
    const handle = this._kernelSourceActionProviderHandlePool++;
    const eventHandle = typeof provider.onDidChangeNotebookKernelSourceActions === "function" ? handle : void 0;
    const that = this;
    this._kernelSourceActionProviders.set(handle, provider);
    this._logService.trace(`NotebookKernelSourceActionProvider[${handle}], CREATED by ${extension.identifier.value}`);
    this._proxy.$addKernelSourceActionProvider(handle, handle, viewType);
    let subscription;
    if (eventHandle !== void 0) {
      subscription = provider.onDidChangeNotebookKernelSourceActions((_) => this._proxy.$emitNotebookKernelSourceActionsChangeEvent(eventHandle));
    }
    return {
      dispose: () => {
        this._kernelSourceActionProviders.delete(handle);
        that._proxy.$removeKernelSourceActionProvider(handle, handle);
        subscription?.dispose();
      }
    };
  }
  async $provideKernelSourceActions(handle, token) {
    const provider = this._kernelSourceActionProviders.get(handle);
    if (provider) {
      const disposables = new DisposableStore();
      const ret = await provider.provideNotebookKernelSourceActions(token);
      return (ret ?? []).map((item) => NotebookKernelSourceAction2.from(item, this._commands.converter, disposables));
    }
    return [];
  }
  $acceptNotebookAssociation(handle, uri, value) {
    const obj = this._kernelData.get(handle);
    if (obj) {
      const notebook = this._extHostNotebook.getNotebookDocument(URI.revive(uri));
      if (value) {
        obj.associatedNotebooks.set(notebook.uri, true);
      } else {
        obj.associatedNotebooks.delete(notebook.uri);
      }
      this._logService.trace(`NotebookController[${handle}] ASSOCIATE notebook`, notebook.uri.toString(), value);
      obj.onDidChangeSelection.fire({
        selected: value,
        notebook: notebook.apiNotebook
      });
    }
  }
  async $executeCells(handle, uri, handles) {
    const obj = this._kernelData.get(handle);
    if (!obj) {
      return;
    }
    const document2 = this._extHostNotebook.getNotebookDocument(URI.revive(uri));
    const cells = [];
    for (const cellHandle of handles) {
      const cell = document2.getCell(cellHandle);
      if (cell) {
        cells.push(cell.apiCell);
      }
    }
    try {
      this._logService.trace(`NotebookController[${handle}] EXECUTE cells`, document2.uri.toString(), cells.length);
      await obj.controller.executeHandler.call(obj.controller, cells, document2.apiNotebook, obj.controller);
    } catch (err) {
      this._logService.error(`NotebookController[${handle}] execute cells FAILED`, err);
      console.error(err);
    }
  }
  async $cancelCells(handle, uri, handles) {
    const obj = this._kernelData.get(handle);
    if (!obj) {
      return;
    }
    const document2 = this._extHostNotebook.getNotebookDocument(URI.revive(uri));
    if (obj.controller.interruptHandler) {
      await obj.controller.interruptHandler.call(obj.controller, document2.apiNotebook);
    } else {
      for (const cellHandle of handles) {
        const cell = document2.getCell(cellHandle);
        if (cell) {
          this._activeExecutions.get(cell.uri)?.cancel();
        }
      }
    }
    if (obj.controller.interruptHandler) {
      const items = this._activeNotebookExecutions.get(document2.uri);
      this._activeNotebookExecutions.delete(document2.uri);
      if (handles.length && Array.isArray(items) && items.length) {
        items.forEach((d) => d.dispose());
      }
    }
  }
  async $provideVariables(handle, requestId, notebookUri, parentId, kind, start, token) {
    const obj = this._kernelData.get(handle);
    if (!obj) {
      return;
    }
    const document2 = this._extHostNotebook.getNotebookDocument(URI.revive(notebookUri));
    const variableProvider = obj.controller.variableProvider;
    if (!variableProvider) {
      return;
    }
    let parent = void 0;
    if (parentId !== void 0) {
      parent = this.variableStore[parentId];
      if (!parent) {
        return;
      }
    } else {
      this.variableStore = {};
    }
    const requestKind = kind === "named" ? NotebookVariablesRequestKind.Named : NotebookVariablesRequestKind.Indexed;
    const variableResults = variableProvider.provideVariables(document2.apiNotebook, parent, requestKind, start, token);
    let resultCount = 0;
    for await (const result of variableResults) {
      if (token.isCancellationRequested) {
        return;
      }
      const variable = {
        id: this.id++,
        name: result.variable.name,
        value: result.variable.value,
        type: result.variable.type,
        interfaces: result.variable.interfaces,
        language: result.variable.language,
        expression: result.variable.expression,
        hasNamedChildren: result.hasNamedChildren,
        indexedChildrenCount: result.indexedChildrenCount,
        extensionId: obj.extensionId.value
      };
      this.variableStore[variable.id] = result.variable;
      this._proxy.$receiveVariable(requestId, variable);
      if (resultCount++ >= variablePageSize) {
        return;
      }
    }
  }
  $acceptKernelMessageFromRenderer(handle, editorId, message) {
    const obj = this._kernelData.get(handle);
    if (!obj) {
      return;
    }
    const editor = this._extHostNotebook.getEditorById(editorId);
    obj.onDidReceiveMessage.fire(Object.freeze({ editor: editor.apiEditor, message }));
  }
  // ---
  _createNotebookCellExecution(cell, controllerId) {
    if (cell.index < 0) {
      throw new Error("CANNOT execute cell that has been REMOVED from notebook");
    }
    const notebook = this._extHostNotebook.getNotebookDocument(cell.notebook.uri);
    const cellObj = notebook.getCellFromApiCell(cell);
    if (!cellObj) {
      throw new Error("invalid cell");
    }
    if (this._activeExecutions.has(cellObj.uri)) {
      throw new Error(`duplicate execution for ${cellObj.uri}`);
    }
    const execution = new NotebookCellExecutionTask(controllerId, cellObj, this._proxy);
    this._activeExecutions.set(cellObj.uri, execution);
    const listener = execution.onDidChangeState(() => {
      if (execution.state === NotebookCellExecutionTaskState.Resolved) {
        execution.dispose();
        listener.dispose();
        this._activeExecutions.delete(cellObj.uri);
      }
    });
    return execution.asApiObject();
  }
  // ---
  _createNotebookExecution(nb, controllerId) {
    const notebook = this._extHostNotebook.getNotebookDocument(nb.uri);
    const runningCell = nb.getCells().find((cell) => {
      const apiCell = notebook.getCellFromApiCell(cell);
      return apiCell && this._activeExecutions.has(apiCell.uri);
    });
    if (runningCell) {
      throw new Error(`duplicate cell execution for ${runningCell.document.uri}`);
    }
    if (this._activeNotebookExecutions.has(notebook.uri)) {
      throw new Error(`duplicate notebook execution for ${notebook.uri}`);
    }
    const execution = new NotebookExecutionTask(controllerId, notebook, this._proxy);
    const listener = execution.onDidChangeState(() => {
      if (execution.state === NotebookExecutionTaskState.Resolved) {
        execution.dispose();
        listener.dispose();
        this._activeNotebookExecutions.delete(notebook.uri);
      }
    });
    this._activeNotebookExecutions.set(notebook.uri, [execution, listener]);
    return execution.asApiObject();
  }
};
ExtHostNotebookKernels = __decorate([
  __param(4, ILogService)
], ExtHostNotebookKernels);
var NotebookCellExecutionTaskState;
(function(NotebookCellExecutionTaskState2) {
  NotebookCellExecutionTaskState2[NotebookCellExecutionTaskState2["Init"] = 0] = "Init";
  NotebookCellExecutionTaskState2[NotebookCellExecutionTaskState2["Started"] = 1] = "Started";
  NotebookCellExecutionTaskState2[NotebookCellExecutionTaskState2["Resolved"] = 2] = "Resolved";
})(NotebookCellExecutionTaskState || (NotebookCellExecutionTaskState = {}));
var NotebookCellExecutionTask = class _NotebookCellExecutionTask extends Disposable {
  static {
    this.HANDLE = 0;
  }
  get state() {
    return this._state;
  }
  constructor(controllerId, _cell, _proxy) {
    super();
    this._cell = _cell;
    this._proxy = _proxy;
    this._handle = _NotebookCellExecutionTask.HANDLE++;
    this._onDidChangeState = new Emitter();
    this.onDidChangeState = this._onDidChangeState.event;
    this._state = NotebookCellExecutionTaskState.Init;
    this._tokenSource = this._register(new CancellationTokenSource());
    this._collector = new TimeoutBasedCollector(10, (updates) => this.update(updates));
    this._executionOrder = _cell.internalMetadata.executionOrder;
    this._proxy.$createExecution(this._handle, controllerId, this._cell.notebook.uri, this._cell.handle);
  }
  cancel() {
    this._tokenSource.cancel();
  }
  async updateSoon(update) {
    await this._collector.addItem(update);
  }
  async update(update) {
    const updates = Array.isArray(update) ? update : [update];
    return this._proxy.$updateExecution(this._handle, new SerializableObjectWithBuffers(updates));
  }
  verifyStateForOutput() {
    if (this._state === NotebookCellExecutionTaskState.Init) {
      throw new Error("Must call start before modifying cell output");
    }
    if (this._state === NotebookCellExecutionTaskState.Resolved) {
      throw new Error("Cannot modify cell output after calling resolve");
    }
  }
  cellIndexToHandle(cellOrCellIndex) {
    let cell = this._cell;
    if (cellOrCellIndex) {
      cell = this._cell.notebook.getCellFromApiCell(cellOrCellIndex);
    }
    if (!cell) {
      throw new Error("INVALID cell");
    }
    return cell.handle;
  }
  validateAndConvertOutputs(items) {
    return items.map((output) => {
      const newOutput = NotebookCellOutput.ensureUniqueMimeTypes(output.items, true);
      if (newOutput === output.items) {
        return NotebookCellOutput2.from(output);
      }
      return NotebookCellOutput2.from({
        items: newOutput,
        id: output.id,
        metadata: output.metadata
      });
    });
  }
  async updateOutputs(outputs, cell, append) {
    const handle = this.cellIndexToHandle(cell);
    const outputDtos = this.validateAndConvertOutputs(asArray(outputs));
    return this.updateSoon({
      editType: CellExecutionUpdateType.Output,
      cellHandle: handle,
      append,
      outputs: outputDtos
    });
  }
  async updateOutputItems(items, output, append) {
    items = NotebookCellOutput.ensureUniqueMimeTypes(asArray(items), true);
    return this.updateSoon({
      editType: CellExecutionUpdateType.OutputItems,
      items: items.map(NotebookCellOutputItem2.from),
      outputId: output.id,
      append
    });
  }
  asApiObject() {
    const that = this;
    const result = {
      get token() {
        return that._tokenSource.token;
      },
      get cell() {
        return that._cell.apiCell;
      },
      get executionOrder() {
        return that._executionOrder;
      },
      set executionOrder(v) {
        that._executionOrder = v;
        that.update([{
          editType: CellExecutionUpdateType.ExecutionState,
          executionOrder: that._executionOrder
        }]);
      },
      start(startTime) {
        if (that._state === NotebookCellExecutionTaskState.Resolved || that._state === NotebookCellExecutionTaskState.Started) {
          throw new Error("Cannot call start again");
        }
        that._state = NotebookCellExecutionTaskState.Started;
        that._onDidChangeState.fire();
        that.update({
          editType: CellExecutionUpdateType.ExecutionState,
          runStartTime: startTime
        });
      },
      end(success, endTime, executionError) {
        if (that._state === NotebookCellExecutionTaskState.Resolved) {
          throw new Error("Cannot call resolve twice");
        }
        that._state = NotebookCellExecutionTaskState.Resolved;
        that._onDidChangeState.fire();
        that._collector.flush();
        const error = createSerializeableError(executionError);
        that._proxy.$completeExecution(that._handle, new SerializableObjectWithBuffers({
          runEndTime: endTime,
          lastRunSuccess: success,
          error
        }));
      },
      clearOutput(cell) {
        that.verifyStateForOutput();
        return that.updateOutputs([], cell, false);
      },
      appendOutput(outputs, cell) {
        that.verifyStateForOutput();
        return that.updateOutputs(outputs, cell, true);
      },
      replaceOutput(outputs, cell) {
        that.verifyStateForOutput();
        return that.updateOutputs(outputs, cell, false);
      },
      appendOutputItems(items, output) {
        that.verifyStateForOutput();
        return that.updateOutputItems(items, output, true);
      },
      replaceOutputItems(items, output) {
        that.verifyStateForOutput();
        return that.updateOutputItems(items, output, false);
      }
    };
    return Object.freeze(result);
  }
};
function createSerializeableError(executionError) {
  const convertRange = (range) => range ? {
    startLineNumber: range.start.line,
    startColumn: range.start.character,
    endLineNumber: range.end.line,
    endColumn: range.end.character
  } : void 0;
  const convertStackFrame = (frame) => ({
    uri: frame.uri,
    position: frame.position,
    label: frame.label
  });
  const error = executionError ? {
    name: executionError.name,
    message: executionError.message,
    stack: executionError.stack instanceof Array ? executionError.stack.map((frame) => convertStackFrame(frame)) : executionError.stack,
    location: convertRange(executionError.location),
    uri: executionError.uri
  } : void 0;
  return error;
}
var NotebookExecutionTaskState;
(function(NotebookExecutionTaskState2) {
  NotebookExecutionTaskState2[NotebookExecutionTaskState2["Init"] = 0] = "Init";
  NotebookExecutionTaskState2[NotebookExecutionTaskState2["Started"] = 1] = "Started";
  NotebookExecutionTaskState2[NotebookExecutionTaskState2["Resolved"] = 2] = "Resolved";
})(NotebookExecutionTaskState || (NotebookExecutionTaskState = {}));
var NotebookExecutionTask = class _NotebookExecutionTask extends Disposable {
  static {
    this.HANDLE = 0;
  }
  get state() {
    return this._state;
  }
  constructor(controllerId, _notebook, _proxy) {
    super();
    this._notebook = _notebook;
    this._proxy = _proxy;
    this._handle = _NotebookExecutionTask.HANDLE++;
    this._onDidChangeState = new Emitter();
    this.onDidChangeState = this._onDidChangeState.event;
    this._state = NotebookExecutionTaskState.Init;
    this._tokenSource = this._register(new CancellationTokenSource());
    this._proxy.$createNotebookExecution(this._handle, controllerId, this._notebook.uri);
  }
  cancel() {
    this._tokenSource.cancel();
  }
  asApiObject() {
    const result = {
      start: () => {
        if (this._state === NotebookExecutionTaskState.Resolved || this._state === NotebookExecutionTaskState.Started) {
          throw new Error("Cannot call start again");
        }
        this._state = NotebookExecutionTaskState.Started;
        this._onDidChangeState.fire();
        this._proxy.$beginNotebookExecution(this._handle);
      },
      end: () => {
        if (this._state === NotebookExecutionTaskState.Resolved) {
          throw new Error("Cannot call resolve twice");
        }
        this._state = NotebookExecutionTaskState.Resolved;
        this._onDidChangeState.fire();
        this._proxy.$completeNotebookExecution(this._handle);
      }
    };
    return Object.freeze(result);
  }
};
var TimeoutBasedCollector = class {
  constructor(delay, callback) {
    this.delay = delay;
    this.callback = callback;
    this.batch = [];
    this.startedTimer = Date.now();
  }
  addItem(item) {
    this.batch.push(item);
    if (!this.currentDeferred) {
      this.currentDeferred = new DeferredPromise();
      this.startedTimer = Date.now();
      timeout(this.delay).then(() => {
        return this.flush();
      });
    }
    if (Date.now() - this.startedTimer > this.delay) {
      return this.flush();
    }
    return this.currentDeferred.p;
  }
  flush() {
    if (this.batch.length === 0 || !this.currentDeferred) {
      return Promise.resolve();
    }
    const deferred = this.currentDeferred;
    this.currentDeferred = void 0;
    const batch = this.batch;
    this.batch = [];
    return this.callback(batch).finally(() => deferred.complete());
  }
};
function createKernelId(extensionIdentifier, id2) {
  return `${extensionIdentifier.value}/${id2}`;
}

// out-build/vs/workbench/api/common/extHostNotebookRenderers.js
var ExtHostNotebookRenderers = class {
  constructor(mainContext, _extHostNotebook) {
    this._extHostNotebook = _extHostNotebook;
    this._rendererMessageEmitters = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadNotebookRenderers);
  }
  $postRendererMessage(editorId, rendererId, message) {
    const editor = this._extHostNotebook.getEditorById(editorId);
    this._rendererMessageEmitters.get(rendererId)?.fire({ editor: editor.apiEditor, message });
  }
  createRendererMessaging(manifest, rendererId) {
    if (!manifest.contributes?.notebookRenderer?.some((r) => r.id === rendererId)) {
      throw new Error(`Extensions may only call createRendererMessaging() for renderers they contribute (got ${rendererId})`);
    }
    const messaging = {
      onDidReceiveMessage: (listener, thisArg, disposables) => {
        return this.getOrCreateEmitterFor(rendererId).event(listener, thisArg, disposables);
      },
      postMessage: (message, editorOrAlias) => {
        if (ExtHostNotebookEditor.apiEditorsToExtHost.has(message)) {
          [message, editorOrAlias] = [editorOrAlias, message];
        }
        const extHostEditor = editorOrAlias && ExtHostNotebookEditor.apiEditorsToExtHost.get(editorOrAlias);
        return this.proxy.$postMessage(extHostEditor?.id, rendererId, message);
      }
    };
    return messaging;
  }
  getOrCreateEmitterFor(rendererId) {
    let emitter = this._rendererMessageEmitters.get(rendererId);
    if (emitter) {
      return emitter;
    }
    emitter = new Emitter({
      onDidRemoveLastListener: () => {
        emitter?.dispose();
        this._rendererMessageEmitters.delete(rendererId);
      }
    });
    this._rendererMessageEmitters.set(rendererId, emitter);
    return emitter;
  }
};

// out-build/vs/workbench/api/common/extHostProfileContentHandler.js
var ExtHostProfileContentHandlers = class {
  constructor(mainContext) {
    this.handlers = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadProfileContentHandlers);
  }
  registerProfileContentHandler(extension, id2, handler) {
    checkProposedApiEnabled(extension, "profileContentHandlers");
    if (this.handlers.has(id2)) {
      throw new Error(`Handler with id '${id2}' already registered`);
    }
    this.handlers.set(id2, handler);
    this.proxy.$registerProfileContentHandler(id2, handler.name, handler.description, extension.identifier.value);
    return toDisposable(() => {
      this.handlers.delete(id2);
      this.proxy.$unregisterProfileContentHandler(id2);
    });
  }
  async $saveProfile(id2, name2, content, token) {
    const handler = this.handlers.get(id2);
    if (!handler) {
      throw new Error(`Unknown handler with id: ${id2}`);
    }
    return handler.saveProfile(name2, content, token);
  }
  async $readProfile(id2, idOrUri, token) {
    const handler = this.handlers.get(id2);
    if (!handler) {
      throw new Error(`Unknown handler with id: ${id2}`);
    }
    return handler.readProfile(isString(idOrUri) ? idOrUri : URI.revive(idOrUri), token);
  }
};

// out-build/vs/workbench/api/common/extHostQuickDiff.js
var ExtHostQuickDiff = class _ExtHostQuickDiff {
  static {
    this.handlePool = 0;
  }
  constructor(mainContext, uriTransformer) {
    this.uriTransformer = uriTransformer;
    this.providers = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadQuickDiff);
  }
  $provideOriginalResource(handle, uriComponents, token) {
    const uri = URI.revive(uriComponents);
    const provider = this.providers.get(handle);
    if (!provider) {
      return Promise.resolve(null);
    }
    return asPromise(() => provider.provideOriginalResource(uri, token)).then((r) => r || null);
  }
  registerQuickDiffProvider(extension, selector, quickDiffProvider, id2, label, rootUri) {
    const handle = _ExtHostQuickDiff.handlePool++;
    this.providers.set(handle, quickDiffProvider);
    const extensionId = ExtensionIdentifier.toKey(extension.identifier);
    this.proxy.$registerQuickDiffProvider(handle, DocumentSelector.from(selector, this.uriTransformer), `${extensionId}.${id2}`, label, rootUri);
    return {
      dispose: () => {
        this.proxy.$unregisterQuickDiffProvider(handle);
        this.providers.delete(handle);
      }
    };
  }
};

// out-build/vs/workbench/api/common/extHostQuickOpen.js
function createExtHostQuickOpen(mainContext, workspace, commands) {
  const proxy = mainContext.getProxy(MainContext.MainThreadQuickOpen);
  class ExtHostQuickOpenImpl {
    constructor(workspace2, commands2) {
      this._sessions = /* @__PURE__ */ new Map();
      this._instances = 0;
      this._workspace = workspace2;
      this._commands = commands2;
    }
    showQuickPick(extension, itemsOrItemsPromise, options2, token = CancellationToken.None) {
      this._onDidSelectItem = void 0;
      const itemsPromise = Promise.resolve(itemsOrItemsPromise);
      const instance = ++this._instances;
      if (options2?.prompt) {
        checkProposedApiEnabled(extension, "quickPickPrompt");
      }
      const quickPickWidget = proxy.$show(instance, {
        title: options2?.title,
        placeHolder: options2?.placeHolder,
        prompt: options2?.prompt,
        matchOnDescription: options2?.matchOnDescription,
        matchOnDetail: options2?.matchOnDetail,
        ignoreFocusLost: options2?.ignoreFocusOut,
        canPickMany: options2?.canPickMany
      }, token);
      const widgetClosedMarker = {};
      const widgetClosedPromise = quickPickWidget.then(() => widgetClosedMarker);
      return Promise.race([widgetClosedPromise, itemsPromise]).then((result) => {
        if (result === widgetClosedMarker) {
          return void 0;
        }
        return itemsPromise.then((items) => {
          const pickItems = [];
          for (let handle = 0; handle < items.length; handle++) {
            const item = items[handle];
            if (typeof item === "string") {
              pickItems.push({ label: item, handle });
            } else if (item.kind === QuickPickItemKind.Separator) {
              pickItems.push({ type: "separator", label: item.label });
            } else {
              if (item.tooltip) {
                checkProposedApiEnabled(extension, "quickPickItemTooltip");
              }
              if (item.resourceUri) {
                checkProposedApiEnabled(extension, "quickPickItemResource");
              }
              pickItems.push({
                label: item.label,
                iconPathDto: IconPath.from(item.iconPath),
                description: item.description,
                detail: item.detail,
                picked: item.picked,
                alwaysShow: item.alwaysShow,
                tooltip: MarkdownString4.fromStrict(item.tooltip),
                resourceUri: item.resourceUri,
                handle
              });
            }
          }
          if (options2 && typeof options2.onDidSelectItem === "function") {
            this._onDidSelectItem = (handle) => {
              options2.onDidSelectItem(items[handle]);
            };
          }
          proxy.$setItems(instance, pickItems);
          return quickPickWidget.then((handle) => {
            if (typeof handle === "number") {
              return items[handle];
            } else if (Array.isArray(handle)) {
              return handle.map((h) => items[h]);
            }
            return void 0;
          });
        });
      }).then(void 0, (err) => {
        if (isCancellationError(err)) {
          return void 0;
        }
        proxy.$setError(instance, err);
        return Promise.reject(err);
      });
    }
    $onItemSelected(handle) {
      this._onDidSelectItem?.(handle);
    }
    // ---- input
    showInput(options2, token = CancellationToken.None) {
      this._validateInput = options2?.validateInput;
      return proxy.$input(options2, typeof this._validateInput === "function", token).then(void 0, (err) => {
        if (isCancellationError(err)) {
          return void 0;
        }
        return Promise.reject(err);
      });
    }
    async $validateInput(input) {
      if (!this._validateInput) {
        return;
      }
      const result = await this._validateInput(input);
      if (!result || typeof result === "string") {
        return result;
      }
      let severity;
      switch (result.severity) {
        case InputBoxValidationSeverity.Info:
          severity = severity_default.Info;
          break;
        case InputBoxValidationSeverity.Warning:
          severity = severity_default.Warning;
          break;
        case InputBoxValidationSeverity.Error:
          severity = severity_default.Error;
          break;
        default:
          severity = result.message ? severity_default.Error : severity_default.Ignore;
          break;
      }
      return {
        content: result.message,
        severity
      };
    }
    // ---- workspace folder picker
    async showWorkspaceFolderPick(options2, token = CancellationToken.None) {
      const selectedFolder = await this._commands.executeCommand("_workbench.pickWorkspaceFolder", [options2]);
      if (!selectedFolder) {
        return void 0;
      }
      const workspaceFolders = await this._workspace.getWorkspaceFolders2();
      if (!workspaceFolders) {
        return void 0;
      }
      return workspaceFolders.find((folder) => folder.uri.toString() === selectedFolder.uri.toString());
    }
    // ---- QuickInput
    createQuickPick(extension) {
      const session = new ExtHostQuickPick(extension, () => this._sessions.delete(session._id));
      this._sessions.set(session._id, session);
      return session;
    }
    createInputBox(extension) {
      const session = new ExtHostInputBox(extension, () => this._sessions.delete(session._id));
      this._sessions.set(session._id, session);
      return session;
    }
    $onDidChangeValue(sessionId, value) {
      const session = this._sessions.get(sessionId);
      session?._fireDidChangeValue(value);
    }
    $onDidAccept(sessionId) {
      const session = this._sessions.get(sessionId);
      session?._fireDidAccept();
    }
    $onDidChangeActive(sessionId, handles) {
      const session = this._sessions.get(sessionId);
      if (session instanceof ExtHostQuickPick) {
        session._fireDidChangeActive(handles);
      }
    }
    $onDidChangeSelection(sessionId, handles) {
      const session = this._sessions.get(sessionId);
      if (session instanceof ExtHostQuickPick) {
        session._fireDidChangeSelection(handles);
      }
    }
    $onDidTriggerButton(sessionId, handle, checked) {
      const session = this._sessions.get(sessionId);
      session?._fireDidTriggerButton(handle, checked);
    }
    $onDidTriggerItemButton(sessionId, itemHandle, buttonHandle) {
      const session = this._sessions.get(sessionId);
      if (session instanceof ExtHostQuickPick) {
        session._fireDidTriggerItemButton(itemHandle, buttonHandle);
      }
    }
    $onDidHide(sessionId) {
      const session = this._sessions.get(sessionId);
      session?._fireDidHide();
    }
  }
  class ExtHostQuickInput {
    static {
      this._nextId = 1;
    }
    constructor(_extension, _onDidDispose) {
      this._extension = _extension;
      this._onDidDispose = _onDidDispose;
      this._id = ExtHostQuickPick._nextId++;
      this._visible = false;
      this._expectingHide = false;
      this._enabled = true;
      this._busy = false;
      this._ignoreFocusOut = true;
      this._value = "";
      this._valueSelection = void 0;
      this._buttons = [];
      this._handlesToButtons = /* @__PURE__ */ new Map();
      this._onDidAcceptEmitter = new Emitter();
      this._onDidChangeValueEmitter = new Emitter();
      this._onDidTriggerButtonEmitter = new Emitter();
      this._onDidHideEmitter = new Emitter();
      this._pendingUpdate = { id: this._id };
      this._disposed = false;
      this._disposables = [
        this._onDidTriggerButtonEmitter,
        this._onDidHideEmitter,
        this._onDidAcceptEmitter,
        this._onDidChangeValueEmitter
      ];
      this.onDidChangeValue = this._onDidChangeValueEmitter.event;
      this.onDidAccept = this._onDidAcceptEmitter.event;
      this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event;
      this.onDidHide = this._onDidHideEmitter.event;
    }
    get title() {
      return this._title;
    }
    set title(title) {
      this._title = title;
      this.update({ title });
    }
    get step() {
      return this._steps;
    }
    set step(step) {
      this._steps = step;
      this.update({ step });
    }
    get totalSteps() {
      return this._totalSteps;
    }
    set totalSteps(totalSteps) {
      this._totalSteps = totalSteps;
      this.update({ totalSteps });
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(enabled) {
      this._enabled = enabled;
      this.update({ enabled });
    }
    get busy() {
      return this._busy;
    }
    set busy(busy) {
      this._busy = busy;
      this.update({ busy });
    }
    get ignoreFocusOut() {
      return this._ignoreFocusOut;
    }
    set ignoreFocusOut(ignoreFocusOut) {
      this._ignoreFocusOut = ignoreFocusOut;
      this.update({ ignoreFocusOut });
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this._value = value;
      this.update({ value });
    }
    get valueSelection() {
      return this._valueSelection;
    }
    set valueSelection(valueSelection) {
      this._valueSelection = valueSelection;
      this.update({ valueSelection });
    }
    get placeholder() {
      return this._placeholder;
    }
    set placeholder(placeholder) {
      this._placeholder = placeholder;
      this.update({ placeholder });
    }
    get buttons() {
      return this._buttons;
    }
    set buttons(buttons) {
      if (buttons.some((button) => typeof button.location === "number" || typeof button.toggle === "object" && typeof button.toggle.checked === "boolean")) {
        checkProposedApiEnabled(this._extension, "quickInputButtonLocation");
      }
      if (buttons.some((button) => typeof button.location === "number" && button.location !== QuickInputButtonLocation.Input && typeof button.toggle === "object" && typeof button.toggle.checked === "boolean")) {
        throw new Error("QuickInputButtons with toggle set are only supported in the Input location.");
      }
      this._buttons = buttons.slice();
      this._handlesToButtons.clear();
      buttons.forEach((button, i) => {
        const handle = button === QuickInputButtons.Back ? -1 : i;
        this._handlesToButtons.set(handle, button);
      });
      this.update({
        buttons: buttons.map((button, i) => {
          return {
            iconPathDto: IconPath.from(button.iconPath),
            tooltip: button.tooltip,
            handle: button === QuickInputButtons.Back ? -1 : i,
            location: typeof button.location === "number" ? button.location : void 0,
            checked: typeof button.toggle === "object" && typeof button.toggle.checked === "boolean" ? button.toggle.checked : void 0
          };
        })
      });
    }
    show() {
      this._visible = true;
      this._expectingHide = true;
      this.update({ visible: true });
    }
    hide() {
      this._visible = false;
      this.update({ visible: false });
    }
    _fireDidAccept() {
      this._onDidAcceptEmitter.fire();
    }
    _fireDidChangeValue(value) {
      this._value = value;
      this._onDidChangeValueEmitter.fire(value);
    }
    _fireDidTriggerButton(handle, checked) {
      const button = this._handlesToButtons.get(handle);
      if (button) {
        if (checked !== void 0 && button.toggle) {
          button.toggle.checked = checked;
        }
        this._onDidTriggerButtonEmitter.fire(button);
      }
    }
    _fireDidHide() {
      if (this._expectingHide) {
        this._expectingHide = this._visible;
        this._onDidHideEmitter.fire();
      }
    }
    dispose() {
      if (this._disposed) {
        return;
      }
      this._disposed = true;
      this._fireDidHide();
      this._disposables = dispose(this._disposables);
      if (this._updateTimeout) {
        clearTimeout(this._updateTimeout);
        this._updateTimeout = void 0;
      }
      this._onDidDispose();
      proxy.$dispose(this._id);
    }
    update(properties) {
      if (this._disposed) {
        return;
      }
      for (const key of Object.keys(properties)) {
        const value = properties[key];
        this._pendingUpdate[key] = value === void 0 ? null : value;
      }
      if ("visible" in this._pendingUpdate) {
        if (this._updateTimeout) {
          clearTimeout(this._updateTimeout);
          this._updateTimeout = void 0;
        }
        this.dispatchUpdate();
      } else if (this._visible && !this._updateTimeout) {
        this._updateTimeout = setTimeout(() => {
          this._updateTimeout = void 0;
          this.dispatchUpdate();
        }, 0);
      }
    }
    dispatchUpdate() {
      proxy.$createOrUpdate(this._pendingUpdate);
      this._pendingUpdate = { id: this._id };
    }
  }
  class ExtHostQuickPick extends ExtHostQuickInput {
    constructor(extension, onDispose) {
      super(extension, onDispose);
      this._items = [];
      this._handlesToItems = /* @__PURE__ */ new Map();
      this._itemsToHandles = /* @__PURE__ */ new Map();
      this._canSelectMany = false;
      this._matchOnDescription = true;
      this._matchOnDetail = true;
      this._sortByLabel = true;
      this._keepScrollPosition = false;
      this._activeItems = [];
      this._onDidChangeActiveEmitter = new Emitter();
      this._selectedItems = [];
      this._onDidChangeSelectionEmitter = new Emitter();
      this._onDidTriggerItemButtonEmitter = new Emitter();
      this.onDidChangeActive = this._onDidChangeActiveEmitter.event;
      this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event;
      this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event;
      this._disposables.push(this._onDidChangeActiveEmitter, this._onDidChangeSelectionEmitter, this._onDidTriggerItemButtonEmitter);
      this.update({ type: "quickPick" });
    }
    get items() {
      return this._items;
    }
    set items(items) {
      this._items = items.slice();
      this._handlesToItems.clear();
      this._itemsToHandles.clear();
      items.forEach((item, i) => {
        this._handlesToItems.set(i, item);
        this._itemsToHandles.set(item, i);
      });
      const pickItems = [];
      for (let handle = 0; handle < items.length; handle++) {
        const item = items[handle];
        if (item.kind === QuickPickItemKind.Separator) {
          pickItems.push({ type: "separator", label: item.label });
        } else {
          if (item.tooltip) {
            checkProposedApiEnabled(this._extension, "quickPickItemTooltip");
          }
          if (item.resourceUri) {
            checkProposedApiEnabled(this._extension, "quickPickItemResource");
          }
          pickItems.push({
            handle,
            label: item.label,
            iconPathDto: IconPath.from(item.iconPath),
            description: item.description,
            detail: item.detail,
            picked: item.picked,
            alwaysShow: item.alwaysShow,
            tooltip: MarkdownString4.fromStrict(item.tooltip),
            resourceUri: item.resourceUri,
            buttons: item.buttons?.map((button, i) => {
              return {
                iconPathDto: IconPath.from(button.iconPath),
                tooltip: button.tooltip,
                handle: i
              };
            })
          });
        }
      }
      this.update({
        items: pickItems
      });
    }
    get canSelectMany() {
      return this._canSelectMany;
    }
    set canSelectMany(canSelectMany) {
      this._canSelectMany = canSelectMany;
      this.update({ canSelectMany });
    }
    get matchOnDescription() {
      return this._matchOnDescription;
    }
    set matchOnDescription(matchOnDescription) {
      this._matchOnDescription = matchOnDescription;
      this.update({ matchOnDescription });
    }
    get matchOnDetail() {
      return this._matchOnDetail;
    }
    set matchOnDetail(matchOnDetail) {
      this._matchOnDetail = matchOnDetail;
      this.update({ matchOnDetail });
    }
    get sortByLabel() {
      return this._sortByLabel;
    }
    set sortByLabel(sortByLabel) {
      this._sortByLabel = sortByLabel;
      this.update({ sortByLabel });
    }
    get keepScrollPosition() {
      return this._keepScrollPosition;
    }
    set keepScrollPosition(keepScrollPosition) {
      this._keepScrollPosition = keepScrollPosition;
      this.update({ keepScrollPosition });
    }
    get prompt() {
      return this._prompt;
    }
    set prompt(prompt) {
      checkProposedApiEnabled(this._extension, "quickPickPrompt");
      this._prompt = prompt;
      this.update({ prompt });
    }
    get activeItems() {
      return this._activeItems;
    }
    set activeItems(activeItems) {
      this._activeItems = activeItems.filter((item) => this._itemsToHandles.has(item));
      this.update({ activeItems: this._activeItems.map((item) => this._itemsToHandles.get(item)) });
    }
    get selectedItems() {
      return this._selectedItems;
    }
    set selectedItems(selectedItems) {
      this._selectedItems = selectedItems.filter((item) => this._itemsToHandles.has(item));
      this.update({ selectedItems: this._selectedItems.map((item) => this._itemsToHandles.get(item)) });
    }
    _fireDidChangeActive(handles) {
      const items = coalesce(handles.map((handle) => this._handlesToItems.get(handle)));
      this._activeItems = items;
      this._onDidChangeActiveEmitter.fire(items);
    }
    _fireDidChangeSelection(handles) {
      const items = coalesce(handles.map((handle) => this._handlesToItems.get(handle)));
      this._selectedItems = items;
      this._onDidChangeSelectionEmitter.fire(items);
    }
    _fireDidTriggerItemButton(itemHandle, buttonHandle) {
      const item = this._handlesToItems.get(itemHandle);
      if (!item || !item.buttons || !item.buttons.length) {
        return;
      }
      const button = item.buttons[buttonHandle];
      if (button) {
        this._onDidTriggerItemButtonEmitter.fire({
          button,
          item
        });
      }
    }
  }
  class ExtHostInputBox extends ExtHostQuickInput {
    constructor(extension, onDispose) {
      super(extension, onDispose);
      this._password = false;
      this.update({ type: "inputBox" });
    }
    get password() {
      return this._password;
    }
    set password(password) {
      this._password = password;
      this.update({ password });
    }
    get prompt() {
      return this._prompt;
    }
    set prompt(prompt) {
      this._prompt = prompt;
      this.update({ prompt });
    }
    get validationMessage() {
      return this._validationMessage;
    }
    set validationMessage(validationMessage) {
      this._validationMessage = validationMessage;
      if (!validationMessage) {
        this.update({ validationMessage: void 0, severity: severity_default.Ignore });
      } else if (typeof validationMessage === "string") {
        this.update({ validationMessage, severity: severity_default.Error });
      } else {
        this.update({ validationMessage: validationMessage.message, severity: validationMessage.severity ?? severity_default.Error });
      }
    }
  }
  return new ExtHostQuickOpenImpl(workspace, commands);
}

// out-build/vs/base/common/comparers.js
var intlFileNameCollatorBaseNumeric = new Lazy(() => {
  const collator = safeIntl.Collator(void 0, { numeric: true, sensitivity: "base" }).value;
  return {
    collator,
    collatorIsNumeric: collator.resolvedOptions().numeric
  };
});
var intlFileNameCollatorNumeric = new Lazy(() => {
  const collator = safeIntl.Collator(void 0, { numeric: true }).value;
  return {
    collator
  };
});
var intlFileNameCollatorNumericCaseInsensitive = new Lazy(() => {
  const collator = safeIntl.Collator(void 0, { numeric: true, sensitivity: "accent" }).value;
  return {
    collator
  };
});
function compareFileNames(one, other, caseSensitive = false) {
  const a = one || "";
  const b = other || "";
  const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);
  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {
    return a < b ? -1 : 1;
  }
  return result;
}
function comparePathComponents(one, other, caseSensitive = false) {
  if (!caseSensitive) {
    one = one && one.toLowerCase();
    other = other && other.toLowerCase();
  }
  if (one === other) {
    return 0;
  }
  return one < other ? -1 : 1;
}
function comparePaths(one, other, caseSensitive = false) {
  const oneParts = one.split(sep);
  const otherParts = other.split(sep);
  const lastOne = oneParts.length - 1;
  const lastOther = otherParts.length - 1;
  let endOne, endOther;
  for (let i = 0; ; i++) {
    endOne = lastOne === i;
    endOther = lastOther === i;
    if (endOne && endOther) {
      return compareFileNames(oneParts[i], otherParts[i], caseSensitive);
    } else if (endOne) {
      return -1;
    } else if (endOther) {
      return 1;
    }
    const result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);
    if (result !== 0) {
      return result;
    }
  }
}

// out-build/vs/workbench/api/common/extHostSCM.js
function isUri2(thing) {
  return thing instanceof URI;
}
function uriEquals(a, b) {
  if (a.scheme === Schemas.file && b.scheme === Schemas.file && isLinux) {
    return a.toString() === b.toString();
  }
  return a.toString().toLowerCase() === b.toString().toLowerCase();
}
function getIconResource(decorations) {
  if (!decorations) {
    return void 0;
  } else if (typeof decorations.iconPath === "string") {
    return URI.file(decorations.iconPath);
  } else if (URI.isUri(decorations.iconPath)) {
    return decorations.iconPath;
  } else if (ThemeIcon.isThemeIcon(decorations.iconPath)) {
    return decorations.iconPath;
  } else {
    return void 0;
  }
}
function getHistoryItemIconDto(icon) {
  if (!icon) {
    return void 0;
  } else if (URI.isUri(icon)) {
    return icon;
  } else if (ThemeIcon.isThemeIcon(icon)) {
    return icon;
  } else {
    const iconDto = icon;
    return { light: iconDto.light, dark: iconDto.dark };
  }
}
function toSCMHistoryItemDto(historyItem) {
  const authorIcon = getHistoryItemIconDto(historyItem.authorIcon);
  const tooltip = MarkdownString4.fromStrict(historyItem.tooltip);
  const references = historyItem.references?.map((r) => ({
    ...r,
    icon: getHistoryItemIconDto(r.icon)
  }));
  return { ...historyItem, authorIcon, references, tooltip };
}
function toSCMHistoryItemRefDto(historyItemRef) {
  return historyItemRef ? { ...historyItemRef, icon: getHistoryItemIconDto(historyItemRef.icon) } : void 0;
}
function compareResourceThemableDecorations(a, b) {
  if (!a.iconPath && !b.iconPath) {
    return 0;
  } else if (!a.iconPath) {
    return -1;
  } else if (!b.iconPath) {
    return 1;
  }
  const aPath = typeof a.iconPath === "string" ? a.iconPath : URI.isUri(a.iconPath) ? a.iconPath.fsPath : a.iconPath.id;
  const bPath = typeof b.iconPath === "string" ? b.iconPath : URI.isUri(b.iconPath) ? b.iconPath.fsPath : b.iconPath.id;
  return comparePaths(aPath, bPath);
}
function compareResourceStatesDecorations(a, b) {
  let result = 0;
  if (a.strikeThrough !== b.strikeThrough) {
    return a.strikeThrough ? 1 : -1;
  }
  if (a.faded !== b.faded) {
    return a.faded ? 1 : -1;
  }
  if (a.tooltip !== b.tooltip) {
    return (a.tooltip || "").localeCompare(b.tooltip || "");
  }
  result = compareResourceThemableDecorations(a, b);
  if (result !== 0) {
    return result;
  }
  if (a.light && b.light) {
    result = compareResourceThemableDecorations(a.light, b.light);
  } else if (a.light) {
    return 1;
  } else if (b.light) {
    return -1;
  }
  if (result !== 0) {
    return result;
  }
  if (a.dark && b.dark) {
    result = compareResourceThemableDecorations(a.dark, b.dark);
  } else if (a.dark) {
    return 1;
  } else if (b.dark) {
    return -1;
  }
  return result;
}
function compareCommands(a, b) {
  if (a.command !== b.command) {
    return a.command < b.command ? -1 : 1;
  }
  if (a.title !== b.title) {
    return a.title < b.title ? -1 : 1;
  }
  if (a.tooltip !== b.tooltip) {
    if (a.tooltip !== void 0 && b.tooltip !== void 0) {
      return a.tooltip < b.tooltip ? -1 : 1;
    } else if (a.tooltip !== void 0) {
      return 1;
    } else if (b.tooltip !== void 0) {
      return -1;
    }
  }
  if (a.arguments === b.arguments) {
    return 0;
  } else if (!a.arguments) {
    return -1;
  } else if (!b.arguments) {
    return 1;
  } else if (a.arguments.length !== b.arguments.length) {
    return a.arguments.length - b.arguments.length;
  }
  for (let i = 0; i < a.arguments.length; i++) {
    const aArg = a.arguments[i];
    const bArg = b.arguments[i];
    if (aArg === bArg) {
      continue;
    }
    if (isUri2(aArg) && isUri2(bArg) && uriEquals(aArg, bArg)) {
      continue;
    }
    return aArg < bArg ? -1 : 1;
  }
  return 0;
}
function compareResourceStates(a, b) {
  let result = comparePaths(a.resourceUri.fsPath, b.resourceUri.fsPath, true);
  if (result !== 0) {
    return result;
  }
  if (a.command && b.command) {
    result = compareCommands(a.command, b.command);
  } else if (a.command) {
    return 1;
  } else if (b.command) {
    return -1;
  }
  if (result !== 0) {
    return result;
  }
  if (a.decorations && b.decorations) {
    result = compareResourceStatesDecorations(a.decorations, b.decorations);
  } else if (a.decorations) {
    return 1;
  } else if (b.decorations) {
    return -1;
  }
  if (result !== 0) {
    return result;
  }
  if (a.multiFileDiffEditorModifiedUri && b.multiFileDiffEditorModifiedUri) {
    result = comparePaths(a.multiFileDiffEditorModifiedUri.fsPath, b.multiFileDiffEditorModifiedUri.fsPath, true);
  } else if (a.multiFileDiffEditorModifiedUri) {
    return 1;
  } else if (b.multiFileDiffEditorModifiedUri) {
    return -1;
  }
  if (result !== 0) {
    return result;
  }
  if (a.multiDiffEditorOriginalUri && b.multiDiffEditorOriginalUri) {
    result = comparePaths(a.multiDiffEditorOriginalUri.fsPath, b.multiDiffEditorOriginalUri.fsPath, true);
  } else if (a.multiDiffEditorOriginalUri) {
    return 1;
  } else if (b.multiDiffEditorOriginalUri) {
    return -1;
  }
  return result;
}
function compareArgs(a, b) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function commandEquals(a, b) {
  return a.command === b.command && a.title === b.title && a.tooltip === b.tooltip && (a.arguments && b.arguments ? compareArgs(a.arguments, b.arguments) : a.arguments === b.arguments);
}
function commandListEquals(a, b) {
  return equals(a, b, commandEquals);
}
var ExtHostSCMInputBox = class {
  #proxy;
  #extHostDocuments;
  get value() {
    return this._value;
  }
  set value(value) {
    value = value ?? "";
    this.#proxy.$setInputBoxValue(this._sourceControlHandle, value);
    this.updateValue(value);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    this.#proxy.$setInputBoxPlaceholder(this._sourceControlHandle, placeholder);
    this._placeholder = placeholder;
  }
  get validateInput() {
    checkProposedApiEnabled(this._extension, "scmValidation");
    return this._validateInput;
  }
  set validateInput(fn) {
    checkProposedApiEnabled(this._extension, "scmValidation");
    if (fn && typeof fn !== "function") {
      throw new Error(`[${this._extension.identifier.value}]: Invalid SCM input box validation function`);
    }
    this._validateInput = fn;
    this.#proxy.$setValidationProviderIsEnabled(this._sourceControlHandle, !!fn);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    enabled = !!enabled;
    if (this._enabled === enabled) {
      return;
    }
    this._enabled = enabled;
    this.#proxy.$setInputBoxEnablement(this._sourceControlHandle, enabled);
  }
  get visible() {
    return this._visible;
  }
  set visible(visible) {
    visible = !!visible;
    if (this._visible === visible) {
      return;
    }
    this._visible = visible;
    this.#proxy.$setInputBoxVisibility(this._sourceControlHandle, visible);
  }
  get document() {
    checkProposedApiEnabled(this._extension, "scmTextDocument");
    return this.#extHostDocuments.getDocument(this._documentUri);
  }
  constructor(_extension, _extHostDocuments, proxy, _sourceControlHandle, _documentUri) {
    this._extension = _extension;
    this._sourceControlHandle = _sourceControlHandle;
    this._documentUri = _documentUri;
    this._value = "";
    this._onDidChange = new Emitter();
    this._placeholder = "";
    this._enabled = true;
    this._visible = true;
    this.#extHostDocuments = _extHostDocuments;
    this.#proxy = proxy;
  }
  showValidationMessage(message, type) {
    checkProposedApiEnabled(this._extension, "scmValidation");
    this.#proxy.$showValidationMessage(this._sourceControlHandle, message, SourceControlInputBoxValidationType2.from(type));
  }
  $onInputBoxValueChange(value) {
    this.updateValue(value);
  }
  updateValue(value) {
    this._value = value;
    this._onDidChange.fire(value);
  }
};
var ExtHostSourceControlResourceGroup = class _ExtHostSourceControlResourceGroup {
  static {
    this._handlePool = 0;
  }
  get disposed() {
    return this._disposed;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(label) {
    this._label = label;
    this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, label);
  }
  get contextValue() {
    return this._contextValue;
  }
  set contextValue(contextValue) {
    this._contextValue = contextValue;
    this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features);
  }
  get hideWhenEmpty() {
    return this._hideWhenEmpty;
  }
  set hideWhenEmpty(hideWhenEmpty) {
    this._hideWhenEmpty = hideWhenEmpty;
    this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features);
  }
  get features() {
    return {
      contextValue: this.contextValue,
      hideWhenEmpty: this.hideWhenEmpty
    };
  }
  get resourceStates() {
    return [...this._resourceStates];
  }
  set resourceStates(resources) {
    this._resourceStates = [...resources];
    this._onDidUpdateResourceStates.fire();
  }
  constructor(_proxy, _commands, _sourceControlHandle, _id, _label, multiDiffEditorEnableViewChanges, _extension) {
    this._proxy = _proxy;
    this._commands = _commands;
    this._sourceControlHandle = _sourceControlHandle;
    this._id = _id;
    this._label = _label;
    this.multiDiffEditorEnableViewChanges = multiDiffEditorEnableViewChanges;
    this._extension = _extension;
    this._resourceHandlePool = 0;
    this._resourceStates = [];
    this._resourceStatesMap = /* @__PURE__ */ new Map();
    this._resourceStatesCommandsMap = /* @__PURE__ */ new Map();
    this._resourceStatesDisposablesMap = /* @__PURE__ */ new Map();
    this._onDidUpdateResourceStates = new Emitter();
    this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event;
    this._disposed = false;
    this._onDidDispose = new Emitter();
    this.onDidDispose = this._onDidDispose.event;
    this._handlesSnapshot = [];
    this._resourceSnapshot = [];
    this._contextValue = void 0;
    this._hideWhenEmpty = void 0;
    this.handle = _ExtHostSourceControlResourceGroup._handlePool++;
  }
  getResourceState(handle) {
    return this._resourceStatesMap.get(handle);
  }
  $executeResourceCommand(handle, preserveFocus) {
    const command = this._resourceStatesCommandsMap.get(handle);
    if (!command) {
      return Promise.resolve(void 0);
    }
    return asPromise(() => this._commands.executeCommand(command.command, ...command.arguments || [], preserveFocus));
  }
  _takeResourceStateSnapshot() {
    const snapshot = [...this._resourceStates].sort(compareResourceStates);
    const diffs = sortedDiff(this._resourceSnapshot, snapshot, compareResourceStates);
    const splices = diffs.map((diff2) => {
      const toInsert = diff2.toInsert.map((r) => {
        const handle = this._resourceHandlePool++;
        this._resourceStatesMap.set(handle, r);
        const sourceUri = r.resourceUri;
        let command;
        if (r.command) {
          if (r.command.command === "vscode.open" || r.command.command === "vscode.diff" || r.command.command === "vscode.changes") {
            const disposables = new DisposableStore();
            command = this._commands.converter.toInternal(r.command, disposables);
            this._resourceStatesDisposablesMap.set(handle, disposables);
          } else {
            this._resourceStatesCommandsMap.set(handle, r.command);
          }
        }
        const hasScmMultiDiffEditorProposalEnabled = isProposedApiEnabled(this._extension, "scmMultiDiffEditor");
        const multiFileDiffEditorOriginalUri = hasScmMultiDiffEditorProposalEnabled ? r.multiDiffEditorOriginalUri : void 0;
        const multiFileDiffEditorModifiedUri = hasScmMultiDiffEditorProposalEnabled ? r.multiFileDiffEditorModifiedUri : void 0;
        const icon = getIconResource(r.decorations);
        const lightIcon = r.decorations && getIconResource(r.decorations.light) || icon;
        const darkIcon = r.decorations && getIconResource(r.decorations.dark) || icon;
        const icons = [lightIcon, darkIcon];
        const tooltip = r.decorations && r.decorations.tooltip || "";
        const strikeThrough = r.decorations && !!r.decorations.strikeThrough;
        const faded = r.decorations && !!r.decorations.faded;
        const contextValue = r.contextValue || "";
        const rawResource = [handle, sourceUri, icons, tooltip, strikeThrough, faded, contextValue, command, multiFileDiffEditorOriginalUri, multiFileDiffEditorModifiedUri];
        return { rawResource, handle };
      });
      return { start: diff2.start, deleteCount: diff2.deleteCount, toInsert };
    });
    const rawResourceSplices = splices.map(({ start, deleteCount, toInsert }) => [start, deleteCount, toInsert.map((i) => i.rawResource)]);
    const reverseSplices = splices.reverse();
    for (const { start, deleteCount, toInsert } of reverseSplices) {
      const handles = toInsert.map((i) => i.handle);
      const handlesToDelete = this._handlesSnapshot.splice(start, deleteCount, ...handles);
      for (const handle of handlesToDelete) {
        this._resourceStatesMap.delete(handle);
        this._resourceStatesCommandsMap.delete(handle);
        this._resourceStatesDisposablesMap.get(handle)?.dispose();
        this._resourceStatesDisposablesMap.delete(handle);
      }
    }
    this._resourceSnapshot = snapshot;
    return rawResourceSplices;
  }
  dispose() {
    this._disposed = true;
    this._onDidDispose.fire();
  }
};
var ExtHostSourceControl = class _ExtHostSourceControl {
  static {
    this._handlePool = 0;
  }
  #proxy;
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  get rootUri() {
    return this._rootUri;
  }
  get contextValue() {
    checkProposedApiEnabled(this._extension, "scmProviderOptions");
    return this._contextValue;
  }
  set contextValue(contextValue) {
    checkProposedApiEnabled(this._extension, "scmProviderOptions");
    if (this._contextValue === contextValue) {
      return;
    }
    this._contextValue = contextValue;
    this.#proxy.$updateSourceControl(this.handle, { contextValue });
  }
  get inputBox() {
    return this._inputBox;
  }
  get count() {
    return this._count;
  }
  set count(count2) {
    if (this._count === count2) {
      return;
    }
    this._count = count2;
    this.#proxy.$updateSourceControl(this.handle, { count: count2 });
  }
  get quickDiffProvider() {
    return this._quickDiffProvider;
  }
  set quickDiffProvider(quickDiffProvider) {
    this._quickDiffProvider = quickDiffProvider;
    let quickDiffLabel = void 0;
    if (isProposedApiEnabled(this._extension, "quickDiffProvider")) {
      quickDiffLabel = quickDiffProvider?.label;
    }
    this.#proxy.$updateSourceControl(this.handle, { hasQuickDiffProvider: !!quickDiffProvider, quickDiffLabel });
  }
  get secondaryQuickDiffProvider() {
    checkProposedApiEnabled(this._extension, "quickDiffProvider");
    return this._secondaryQuickDiffProvider;
  }
  set secondaryQuickDiffProvider(secondaryQuickDiffProvider) {
    checkProposedApiEnabled(this._extension, "quickDiffProvider");
    this._secondaryQuickDiffProvider = secondaryQuickDiffProvider;
    const secondaryQuickDiffLabel = secondaryQuickDiffProvider?.label;
    this.#proxy.$updateSourceControl(this.handle, { hasSecondaryQuickDiffProvider: !!secondaryQuickDiffProvider, secondaryQuickDiffLabel });
  }
  get historyProvider() {
    checkProposedApiEnabled(this._extension, "scmHistoryProvider");
    return this._historyProvider;
  }
  set historyProvider(historyProvider) {
    checkProposedApiEnabled(this._extension, "scmHistoryProvider");
    this._historyProvider = historyProvider;
    this._historyProviderDisposable.value = new DisposableStore();
    this.#proxy.$updateSourceControl(this.handle, { hasHistoryProvider: !!historyProvider });
    if (historyProvider) {
      this._historyProviderDisposable.value.add(historyProvider.onDidChangeCurrentHistoryItemRefs(() => {
        const historyItemRef = toSCMHistoryItemRefDto(historyProvider?.currentHistoryItemRef);
        const historyItemRemoteRef = toSCMHistoryItemRefDto(historyProvider?.currentHistoryItemRemoteRef);
        const historyItemBaseRef = toSCMHistoryItemRefDto(historyProvider?.currentHistoryItemBaseRef);
        this.#proxy.$onDidChangeHistoryProviderCurrentHistoryItemRefs(this.handle, historyItemRef, historyItemRemoteRef, historyItemBaseRef);
      }));
      this._historyProviderDisposable.value.add(historyProvider.onDidChangeHistoryItemRefs((e) => {
        if (e.added.length === 0 && e.modified.length === 0 && e.removed.length === 0) {
          return;
        }
        const added = e.added.map((ref) => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) }));
        const modified = e.modified.map((ref) => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) }));
        const removed = e.removed.map((ref) => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) }));
        this.#proxy.$onDidChangeHistoryProviderHistoryItemRefs(this.handle, { added, modified, removed, silent: e.silent });
      }));
    }
  }
  get artifactProvider() {
    checkProposedApiEnabled(this._extension, "scmArtifactProvider");
    return this._artifactProvider;
  }
  set artifactProvider(artifactProvider) {
    checkProposedApiEnabled(this._extension, "scmArtifactProvider");
    this._artifactProvider = artifactProvider;
    this._artifactProviderDisposable.value = new DisposableStore();
    this.#proxy.$updateSourceControl(this.handle, { hasArtifactProvider: !!artifactProvider });
    if (artifactProvider) {
      this._artifactProviderDisposable.value.add(artifactProvider.onDidChangeArtifacts((groups) => {
        if (groups.length !== 0) {
          this.#proxy.$onDidChangeArtifacts(this.handle, groups);
        }
      }));
    }
  }
  get commitTemplate() {
    return this._commitTemplate;
  }
  set commitTemplate(commitTemplate) {
    if (commitTemplate === this._commitTemplate) {
      return;
    }
    this._commitTemplate = commitTemplate;
    this.#proxy.$updateSourceControl(this.handle, { commitTemplate });
  }
  get acceptInputCommand() {
    return this._acceptInputCommand;
  }
  set acceptInputCommand(acceptInputCommand) {
    this._acceptInputDisposables.value = new DisposableStore();
    this._acceptInputCommand = acceptInputCommand;
    const internal = this._commands.converter.toInternal(acceptInputCommand, this._acceptInputDisposables.value);
    this.#proxy.$updateSourceControl(this.handle, { acceptInputCommand: internal });
  }
  get actionButton() {
    checkProposedApiEnabled(this._extension, "scmActionButton");
    return this._actionButton;
  }
  set actionButton(actionButton) {
    checkProposedApiEnabled(this._extension, "scmActionButton");
    if (structuralEquals(this._actionButton, actionButton)) {
      return;
    }
    const oldActionButtonDisposables = this._actionButtonDisposables;
    this._actionButtonDisposables = new DisposableStore();
    this._actionButton = actionButton;
    const actionButtonDto = actionButton !== void 0 ? {
      command: {
        ...this._commands.converter.toInternal(actionButton.command, this._actionButtonDisposables),
        shortTitle: actionButton.command.shortTitle
      },
      secondaryCommands: actionButton.secondaryCommands?.map((commandGroup) => {
        return commandGroup.map((command) => this._commands.converter.toInternal(command, this._actionButtonDisposables));
      }),
      enabled: actionButton.enabled
    } : null;
    this.#proxy.$updateSourceControl(this.handle, { actionButton: actionButtonDto }).finally(() => oldActionButtonDisposables.dispose());
  }
  get statusBarCommands() {
    return this._statusBarCommands;
  }
  set statusBarCommands(statusBarCommands) {
    if (this._statusBarCommands && statusBarCommands && commandListEquals(this._statusBarCommands, statusBarCommands)) {
      return;
    }
    const oldStatusBarDisposables = this._statusBarDisposables;
    this._statusBarDisposables = new DisposableStore();
    this._statusBarCommands = statusBarCommands;
    const internal = (statusBarCommands || []).map((c) => this._commands.converter.toInternal(c, this._statusBarDisposables));
    this.#proxy.$updateSourceControl(this.handle, { statusBarCommands: internal }).finally(() => oldStatusBarDisposables.dispose());
  }
  get selected() {
    return this._selected;
  }
  constructor(_extension, _extHostDocuments, proxy, _commands, _id, _label, _rootUri, _iconPath, _parent) {
    this._extension = _extension;
    this._commands = _commands;
    this._id = _id;
    this._label = _label;
    this._rootUri = _rootUri;
    this._onDidDispose = new Emitter();
    this.onDidDispose = this._onDidDispose.event;
    this._groups = /* @__PURE__ */ new Map();
    this._contextValue = void 0;
    this._count = void 0;
    this._quickDiffProvider = void 0;
    this._secondaryQuickDiffProvider = void 0;
    this._historyProviderDisposable = new MutableDisposable();
    this._artifactProviderDisposable = new MutableDisposable();
    this._commitTemplate = void 0;
    this._acceptInputDisposables = new MutableDisposable();
    this._acceptInputCommand = void 0;
    this._actionButtonDisposables = new DisposableStore();
    this._statusBarDisposables = new DisposableStore();
    this._statusBarCommands = void 0;
    this._selected = false;
    this._onDidChangeSelection = new Emitter();
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this.handle = _ExtHostSourceControl._handlePool++;
    this.createdResourceGroups = /* @__PURE__ */ new Map();
    this.updatedResourceGroups = /* @__PURE__ */ new Set();
    this.#proxy = proxy;
    const inputBoxDocumentUri = URI.from({
      scheme: Schemas.vscodeSourceControl,
      path: `${_id}/scm${this.handle}/input`,
      query: _rootUri ? `rootUri=${encodeURIComponent(_rootUri.toString())}` : void 0
    });
    this._inputBox = new ExtHostSCMInputBox(_extension, _extHostDocuments, this.#proxy, this.handle, inputBoxDocumentUri);
    this.#proxy.$registerSourceControl(this.handle, _parent?.handle, _id, _label, _rootUri, getHistoryItemIconDto(_iconPath), inputBoxDocumentUri);
    this.onDidDisposeParent = _parent ? _parent.onDidDispose : Event.None;
  }
  createResourceGroup(id2, label, options2) {
    const multiDiffEditorEnableViewChanges = isProposedApiEnabled(this._extension, "scmMultiDiffEditor") && options2?.multiDiffEditorEnableViewChanges === true;
    const group = new ExtHostSourceControlResourceGroup(this.#proxy, this._commands, this.handle, id2, label, multiDiffEditorEnableViewChanges, this._extension);
    const disposable = Event.once(group.onDidDispose)(() => this.createdResourceGroups.delete(group));
    this.createdResourceGroups.set(group, disposable);
    this.eventuallyAddResourceGroups();
    return group;
  }
  eventuallyAddResourceGroups() {
    const groups = [];
    const splices = [];
    for (const [group, disposable] of this.createdResourceGroups) {
      disposable.dispose();
      const updateListener = group.onDidUpdateResourceStates(() => {
        this.updatedResourceGroups.add(group);
        this.eventuallyUpdateResourceStates();
      });
      Event.once(group.onDidDispose)(() => {
        this.updatedResourceGroups.delete(group);
        updateListener.dispose();
        this._groups.delete(group.handle);
        this.#proxy.$unregisterGroup(this.handle, group.handle);
      });
      groups.push([group.handle, group.id, group.label, group.features, group.multiDiffEditorEnableViewChanges]);
      const snapshot = group._takeResourceStateSnapshot();
      if (snapshot.length > 0) {
        splices.push([group.handle, snapshot]);
      }
      this._groups.set(group.handle, group);
    }
    this.#proxy.$registerGroups(this.handle, groups, splices);
    this.createdResourceGroups.clear();
  }
  eventuallyUpdateResourceStates() {
    const splices = [];
    this.updatedResourceGroups.forEach((group) => {
      const snapshot = group._takeResourceStateSnapshot();
      if (snapshot.length === 0) {
        return;
      }
      splices.push([group.handle, snapshot]);
    });
    if (splices.length > 0) {
      this.#proxy.$spliceResourceStates(this.handle, splices);
    }
    this.updatedResourceGroups.clear();
  }
  getResourceGroup(handle) {
    return this._groups.get(handle);
  }
  setSelectionState(selected) {
    this._selected = selected;
    this._onDidChangeSelection.fire(selected);
  }
  dispose() {
    this._acceptInputDisposables.dispose();
    this._actionButtonDisposables.dispose();
    this._statusBarDisposables.dispose();
    this._historyProviderDisposable.dispose();
    this._artifactProviderDisposable.dispose();
    this._groups.forEach((group) => group.dispose());
    this.#proxy.$unregisterSourceControl(this.handle);
    this._onDidDispose.fire();
    this._onDidDispose.dispose();
  }
};
__decorate([
  debounce(100)
], ExtHostSourceControl.prototype, "eventuallyAddResourceGroups", null);
__decorate([
  debounce(100)
], ExtHostSourceControl.prototype, "eventuallyUpdateResourceStates", null);
var ExtHostSCM = class ExtHostSCM2 {
  get onDidChangeActiveProvider() {
    return this._onDidChangeActiveProvider.event;
  }
  constructor(mainContext, _commands, _extHostDocuments, logService) {
    this._commands = _commands;
    this._extHostDocuments = _extHostDocuments;
    this.logService = logService;
    this._sourceControls = /* @__PURE__ */ new Map();
    this._sourceControlsByExtension = new ExtensionIdentifierMap();
    this._onDidChangeActiveProvider = new Emitter();
    this._proxy = mainContext.getProxy(MainContext.MainThreadSCM);
    this._telemetry = mainContext.getProxy(MainContext.MainThreadTelemetry);
    _commands.registerArgumentProcessor({
      processArgument: (arg) => {
        if (arg && arg.$mid === 3) {
          const sourceControl = this._sourceControls.get(arg.sourceControlHandle);
          if (!sourceControl) {
            return arg;
          }
          const group = sourceControl.getResourceGroup(arg.groupHandle);
          if (!group) {
            return arg;
          }
          return group.getResourceState(arg.handle);
        } else if (arg && arg.$mid === 4) {
          const sourceControl = this._sourceControls.get(arg.sourceControlHandle);
          if (!sourceControl) {
            return arg;
          }
          return sourceControl.getResourceGroup(arg.groupHandle);
        } else if (arg && arg.$mid === 5) {
          const sourceControl = this._sourceControls.get(arg.handle);
          if (!sourceControl) {
            return arg;
          }
          return sourceControl;
        }
        return arg;
      }
    });
  }
  createSourceControl(extension, id2, label, rootUri, iconPath, parent) {
    this.logService.trace("ExtHostSCM#createSourceControl", extension.identifier.value, id2, label, rootUri);
    this._telemetry.$publicLog2("api/scm/createSourceControl", {
      extensionId: extension.identifier.value
    });
    const parentSourceControl = parent ? Iterable.find(this._sourceControls.values(), (s) => s === parent) : void 0;
    const sourceControl = new ExtHostSourceControl(extension, this._extHostDocuments, this._proxy, this._commands, id2, label, rootUri, iconPath, parentSourceControl);
    this._sourceControls.set(sourceControl.handle, sourceControl);
    const sourceControls = this._sourceControlsByExtension.get(extension.identifier) || [];
    sourceControls.push(sourceControl);
    this._sourceControlsByExtension.set(extension.identifier, sourceControls);
    return sourceControl;
  }
  // Deprecated
  getLastInputBox(extension) {
    this.logService.trace("ExtHostSCM#getLastInputBox", extension.identifier.value);
    const sourceControls = this._sourceControlsByExtension.get(extension.identifier);
    const sourceControl = sourceControls && sourceControls[sourceControls.length - 1];
    return sourceControl && sourceControl.inputBox;
  }
  $provideOriginalResource(sourceControlHandle, uriComponents, token) {
    const uri = URI.revive(uriComponents);
    this.logService.trace("ExtHostSCM#$provideOriginalResource", sourceControlHandle, uri.toString());
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl || !sourceControl.quickDiffProvider || !sourceControl.quickDiffProvider.provideOriginalResource) {
      return Promise.resolve(null);
    }
    return asPromise(() => sourceControl.quickDiffProvider.provideOriginalResource(uri, token)).then((r) => r || null);
  }
  $provideSecondaryOriginalResource(sourceControlHandle, uriComponents, token) {
    const uri = URI.revive(uriComponents);
    this.logService.trace("ExtHostSCM#$provideSecondaryOriginalResource", sourceControlHandle, uri.toString());
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl || !sourceControl.secondaryQuickDiffProvider || !sourceControl.secondaryQuickDiffProvider.provideOriginalResource) {
      return Promise.resolve(null);
    }
    return asPromise(() => sourceControl.secondaryQuickDiffProvider.provideOriginalResource(uri, token)).then((r) => r || null);
  }
  $onInputBoxValueChange(sourceControlHandle, value) {
    this.logService.trace("ExtHostSCM#$onInputBoxValueChange", sourceControlHandle);
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl) {
      return Promise.resolve(void 0);
    }
    sourceControl.inputBox.$onInputBoxValueChange(value);
    return Promise.resolve(void 0);
  }
  $executeResourceCommand(sourceControlHandle, groupHandle, handle, preserveFocus) {
    this.logService.trace("ExtHostSCM#$executeResourceCommand", sourceControlHandle, groupHandle, handle);
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl) {
      return Promise.resolve(void 0);
    }
    const group = sourceControl.getResourceGroup(groupHandle);
    if (!group) {
      return Promise.resolve(void 0);
    }
    return group.$executeResourceCommand(handle, preserveFocus);
  }
  $validateInput(sourceControlHandle, value, cursorPosition) {
    this.logService.trace("ExtHostSCM#$validateInput", sourceControlHandle);
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl) {
      return Promise.resolve(void 0);
    }
    if (!sourceControl.inputBox.validateInput) {
      return Promise.resolve(void 0);
    }
    return asPromise(() => sourceControl.inputBox.validateInput(value, cursorPosition)).then((result) => {
      if (!result) {
        return Promise.resolve(void 0);
      }
      const message = MarkdownString4.fromStrict(result.message);
      if (!message) {
        return Promise.resolve(void 0);
      }
      return Promise.resolve([message, result.type]);
    });
  }
  $setSelectedSourceControl(selectedSourceControlHandle) {
    this.logService.trace("ExtHostSCM#$setSelectedSourceControl", selectedSourceControlHandle);
    if (selectedSourceControlHandle !== void 0) {
      this._sourceControls.get(selectedSourceControlHandle)?.setSelectionState(true);
    }
    if (this._selectedSourceControlHandle !== void 0) {
      this._sourceControls.get(this._selectedSourceControlHandle)?.setSelectionState(false);
    }
    this._selectedSourceControlHandle = selectedSourceControlHandle;
    return Promise.resolve(void 0);
  }
  async $resolveHistoryItem(sourceControlHandle, historyItemId, token) {
    try {
      const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;
      const historyItem = await historyProvider?.resolveHistoryItem(historyItemId, token);
      return historyItem ? toSCMHistoryItemDto(historyItem) : void 0;
    } catch (err) {
      this.logService.error("ExtHostSCM#$resolveHistoryItem", err);
      return void 0;
    }
  }
  async $resolveHistoryItemChatContext(sourceControlHandle, historyItemId, token) {
    try {
      const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;
      const chatContext = await historyProvider?.resolveHistoryItemChatContext(historyItemId, token);
      return chatContext ?? void 0;
    } catch (err) {
      this.logService.error("ExtHostSCM#$resolveHistoryItemChatContext", err);
      return void 0;
    }
  }
  async $resolveHistoryItemChangeRangeChatContext(sourceControlHandle, historyItemId, historyItemParentId, path, token) {
    try {
      const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;
      const chatContext = await historyProvider?.resolveHistoryItemChangeRangeChatContext?.(historyItemId, historyItemParentId, path, token);
      return chatContext ?? void 0;
    } catch (err) {
      this.logService.error("ExtHostSCM#$resolveHistoryItemChangeRangeChatContext", err);
      return void 0;
    }
  }
  async $resolveHistoryItemRefsCommonAncestor(sourceControlHandle, historyItemRefs, token) {
    try {
      const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;
      const ancestor = await historyProvider?.resolveHistoryItemRefsCommonAncestor(historyItemRefs, token);
      return ancestor ?? void 0;
    } catch (err) {
      this.logService.error("ExtHostSCM#$resolveHistoryItemRefsCommonAncestor", err);
      return void 0;
    }
  }
  async $provideHistoryItemRefs(sourceControlHandle, historyItemRefs, token) {
    try {
      const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;
      const refs = await historyProvider?.provideHistoryItemRefs(historyItemRefs, token);
      return refs?.map((ref) => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) })) ?? void 0;
    } catch (err) {
      this.logService.error("ExtHostSCM#$provideHistoryItemRefs", err);
      return void 0;
    }
  }
  async $provideHistoryItems(sourceControlHandle, options2, token) {
    try {
      const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;
      const historyItems = await historyProvider?.provideHistoryItems(options2, token);
      return historyItems?.map((item) => toSCMHistoryItemDto(item)) ?? void 0;
    } catch (err) {
      this.logService.error("ExtHostSCM#$provideHistoryItems", err);
      return void 0;
    }
  }
  async $provideHistoryItemChanges(sourceControlHandle, historyItemId, historyItemParentId, token) {
    try {
      const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;
      const changes = await historyProvider?.provideHistoryItemChanges(historyItemId, historyItemParentId, token);
      return changes ?? void 0;
    } catch (err) {
      this.logService.error("ExtHostSCM#$provideHistoryItemChanges", err);
      return void 0;
    }
  }
  async $provideArtifactGroups(sourceControlHandle, token) {
    try {
      const artifactProvider = this._sourceControls.get(sourceControlHandle)?.artifactProvider;
      const groups = await artifactProvider?.provideArtifactGroups(token);
      return groups?.map((group) => ({
        ...group,
        icon: getHistoryItemIconDto(group.icon)
      }));
    } catch (err) {
      this.logService.error("ExtHostSCM#$provideArtifactGroups", err);
      return void 0;
    }
  }
  async $provideArtifacts(sourceControlHandle, group, token) {
    try {
      const artifactProvider = this._sourceControls.get(sourceControlHandle)?.artifactProvider;
      const artifacts = await artifactProvider?.provideArtifacts(group, token);
      return artifacts?.map((artifact) => ({
        ...artifact,
        icon: getHistoryItemIconDto(artifact.icon)
      }));
    } catch (err) {
      this.logService.error("ExtHostSCM#$provideArtifacts", err);
      return void 0;
    }
  }
};
ExtHostSCM = __decorate([
  __param(3, ILogService)
], ExtHostSCM);

// out-build/vs/workbench/api/common/extHostShare.js
var ExtHostShare = class _ExtHostShare {
  static {
    this.handlePool = 0;
  }
  constructor(mainContext, uriTransformer) {
    this.uriTransformer = uriTransformer;
    this.providers = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadShare);
  }
  async $provideShare(handle, shareableItem, token) {
    const provider = this.providers.get(handle);
    const result = await provider?.provideShare({ selection: Range4.to(shareableItem.selection), resourceUri: URI.revive(shareableItem.resourceUri) }, token);
    return result ?? void 0;
  }
  registerShareProvider(selector, provider) {
    const handle = _ExtHostShare.handlePool++;
    this.providers.set(handle, provider);
    this.proxy.$registerShareProvider(handle, DocumentSelector.from(selector, this.uriTransformer), provider.id, provider.label, provider.priority);
    return {
      dispose: () => {
        this.proxy.$unregisterShareProvider(handle);
        this.providers.delete(handle);
      }
    };
  }
};

// out-build/vs/workbench/api/common/extHostSpeech.js
var ExtHostSpeech = class _ExtHostSpeech {
  static {
    this.ID_POOL = 1;
  }
  constructor(mainContext) {
    this.providers = /* @__PURE__ */ new Map();
    this.sessions = /* @__PURE__ */ new Map();
    this.synthesizers = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadSpeech);
  }
  async $createSpeechToTextSession(handle, session, language2) {
    const provider = this.providers.get(handle);
    if (!provider) {
      return;
    }
    const disposables = new DisposableStore();
    const cts = new CancellationTokenSource();
    this.sessions.set(session, cts);
    const speechToTextSession = await provider.provideSpeechToTextSession(cts.token, language2 ? { language: language2 } : void 0);
    if (!speechToTextSession) {
      return;
    }
    disposables.add(speechToTextSession.onDidChange((e) => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      this.proxy.$emitSpeechToTextEvent(session, e);
    }));
    disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));
  }
  async $cancelSpeechToTextSession(session) {
    this.sessions.get(session)?.dispose(true);
    this.sessions.delete(session);
  }
  async $createTextToSpeechSession(handle, session, language2) {
    const provider = this.providers.get(handle);
    if (!provider) {
      return;
    }
    const disposables = new DisposableStore();
    const cts = new CancellationTokenSource();
    this.sessions.set(session, cts);
    const textToSpeech = await provider.provideTextToSpeechSession(cts.token, language2 ? { language: language2 } : void 0);
    if (!textToSpeech) {
      return;
    }
    this.synthesizers.set(session, textToSpeech);
    disposables.add(textToSpeech.onDidChange((e) => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      this.proxy.$emitTextToSpeechEvent(session, e);
    }));
    disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));
  }
  async $synthesizeSpeech(session, text) {
    this.synthesizers.get(session)?.synthesize(text);
  }
  async $cancelTextToSpeechSession(session) {
    this.sessions.get(session)?.dispose(true);
    this.sessions.delete(session);
    this.synthesizers.delete(session);
  }
  async $createKeywordRecognitionSession(handle, session) {
    const provider = this.providers.get(handle);
    if (!provider) {
      return;
    }
    const disposables = new DisposableStore();
    const cts = new CancellationTokenSource();
    this.sessions.set(session, cts);
    const keywordRecognitionSession = await provider.provideKeywordRecognitionSession(cts.token);
    if (!keywordRecognitionSession) {
      return;
    }
    disposables.add(keywordRecognitionSession.onDidChange((e) => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      this.proxy.$emitKeywordRecognitionEvent(session, e);
    }));
    disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));
  }
  async $cancelKeywordRecognitionSession(session) {
    this.sessions.get(session)?.dispose(true);
    this.sessions.delete(session);
  }
  registerProvider(extension, identifier, provider) {
    const handle = _ExtHostSpeech.ID_POOL++;
    this.providers.set(handle, provider);
    this.proxy.$registerProvider(handle, identifier, { extension, displayName: extension.value });
    return toDisposable(() => {
      this.proxy.$unregisterProvider(handle);
      this.providers.delete(handle);
    });
  }
};

// out-build/vs/workbench/api/common/extHostStatusBar.js
var ExtHostStatusBarEntry = class _ExtHostStatusBarEntry {
  static {
    this.ID_GEN = 0;
  }
  static {
    this.ALLOWED_BACKGROUND_COLORS = /* @__PURE__ */ new Map([
      ["statusBarItem.errorBackground", new ThemeColor2("statusBarItem.errorForeground")],
      ["statusBarItem.warningBackground", new ThemeColor2("statusBarItem.warningForeground")]
    ]);
  }
  #proxy;
  #commands;
  constructor(proxy, commands, staticItems, extension, id2, alignment = StatusBarAlignment.Left, priority, _onDispose) {
    this._onDispose = _onDispose;
    this._disposed = false;
    this._text = "";
    this._staleCommandRegistrations = new DisposableStore();
    this.#proxy = proxy;
    this.#commands = commands;
    if (id2 && extension) {
      this._entryId = asStatusBarItemIdentifier(extension.identifier, id2);
      const item = staticItems.get(this._entryId);
      if (item) {
        alignment = item.alignLeft ? StatusBarAlignment.Left : StatusBarAlignment.Right;
        priority = item.priority;
        this._visible = true;
        this.name = item.name;
        this.text = item.text;
        this.tooltip = item.tooltip;
        this.command = item.command;
        this.accessibilityInformation = item.accessibilityInformation;
      }
    } else {
      this._entryId = String(_ExtHostStatusBarEntry.ID_GEN++);
    }
    this._extension = extension;
    this._id = id2;
    this._alignment = alignment;
    this._priority = this.validatePriority(priority);
  }
  validatePriority(priority) {
    if (!isNumber(priority)) {
      return void 0;
    }
    if (priority === Number.POSITIVE_INFINITY) {
      return Number.MAX_VALUE;
    }
    if (priority === Number.NEGATIVE_INFINITY) {
      return -Number.MAX_VALUE;
    }
    return priority;
  }
  get id() {
    return this._id ?? this._extension.identifier.value;
  }
  get entryId() {
    return this._entryId;
  }
  get alignment() {
    return this._alignment;
  }
  get priority() {
    return this._priority;
  }
  get text() {
    return this._text;
  }
  get name() {
    return this._name;
  }
  get tooltip() {
    return this._tooltip;
  }
  get tooltip2() {
    if (this._extension) {
      checkProposedApiEnabled(this._extension, "statusBarItemTooltip");
    }
    return this._tooltip2;
  }
  get color() {
    return this._color;
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  get command() {
    return this._command?.fromApi;
  }
  get accessibilityInformation() {
    return this._accessibilityInformation;
  }
  set text(text) {
    this._text = text;
    this.update();
  }
  set name(name2) {
    this._name = name2;
    this.update();
  }
  set tooltip(tooltip) {
    this._tooltip = tooltip;
    this.update();
  }
  set tooltip2(tooltip) {
    if (this._extension) {
      checkProposedApiEnabled(this._extension, "statusBarItemTooltip");
    }
    this._tooltip2 = tooltip;
    this.update();
  }
  set color(color) {
    this._color = color;
    this.update();
  }
  set backgroundColor(color) {
    if (color && !_ExtHostStatusBarEntry.ALLOWED_BACKGROUND_COLORS.has(color.id)) {
      color = void 0;
    }
    this._backgroundColor = color;
    this.update();
  }
  set command(command) {
    if (this._command?.fromApi === command) {
      return;
    }
    if (this._latestCommandRegistration) {
      this._staleCommandRegistrations.add(this._latestCommandRegistration);
    }
    this._latestCommandRegistration = new DisposableStore();
    if (typeof command === "string") {
      this._command = {
        fromApi: command,
        internal: this.#commands.toInternal({ title: "", command }, this._latestCommandRegistration)
      };
    } else if (command) {
      this._command = {
        fromApi: command,
        internal: this.#commands.toInternal(command, this._latestCommandRegistration)
      };
    } else {
      this._command = void 0;
    }
    this.update();
  }
  set accessibilityInformation(accessibilityInformation) {
    this._accessibilityInformation = accessibilityInformation;
    this.update();
  }
  show() {
    this._visible = true;
    this.update();
  }
  hide() {
    clearTimeout(this._timeoutHandle);
    this._visible = false;
    this.#proxy.$disposeEntry(this._entryId);
  }
  update() {
    if (this._disposed || !this._visible) {
      return;
    }
    clearTimeout(this._timeoutHandle);
    this._timeoutHandle = setTimeout(() => {
      this._timeoutHandle = void 0;
      let id2;
      if (this._extension) {
        if (this._id) {
          id2 = `${this._extension.identifier.value}.${this._id}`;
        } else {
          id2 = this._extension.identifier.value;
        }
      } else {
        id2 = this._id;
      }
      let name2;
      if (this._name) {
        name2 = this._name;
      } else {
        name2 = localize(3020, null, this._extension.displayName || this._extension.name);
      }
      let color = this._color;
      if (this._backgroundColor) {
        color = _ExtHostStatusBarEntry.ALLOWED_BACKGROUND_COLORS.get(this._backgroundColor.id);
      }
      let tooltip;
      let hasTooltipProvider;
      if (typeof this._tooltip2 === "function") {
        tooltip = MarkdownString4.fromStrict(this._tooltip);
        hasTooltipProvider = true;
      } else {
        tooltip = MarkdownString4.fromStrict(this._tooltip2 ?? this._tooltip);
        hasTooltipProvider = false;
      }
      this.#proxy.$setEntry(this._entryId, id2, this._extension?.identifier.value, name2, this._text, tooltip, hasTooltipProvider, this._command?.internal, color, this._backgroundColor, this._alignment === StatusBarAlignment.Left, this._priority, this._accessibilityInformation);
      this._staleCommandRegistrations.clear();
    }, 0);
  }
  dispose() {
    this.hide();
    this._onDispose?.();
    this._disposed = true;
  }
};
var StatusBarMessage = class {
  constructor(statusBar) {
    this._messages = [];
    this._item = statusBar.createStatusBarEntry(void 0, "status.extensionMessage", StatusBarAlignment.Left, Number.MIN_VALUE);
    this._item.name = localize(3021, null);
  }
  dispose() {
    this._messages.length = 0;
    this._item.dispose();
  }
  setMessage(message) {
    const data2 = { message };
    this._messages.unshift(data2);
    this._update();
    return new Disposable2(() => {
      const idx = this._messages.indexOf(data2);
      if (idx >= 0) {
        this._messages.splice(idx, 1);
        this._update();
      }
    });
  }
  _update() {
    if (this._messages.length > 0) {
      this._item.text = this._messages[0].message;
      this._item.show();
    } else {
      this._item.hide();
    }
  }
};
var ExtHostStatusBar = class {
  constructor(mainContext, commands) {
    this._entries = /* @__PURE__ */ new Map();
    this._existingItems = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadStatusBar);
    this._commands = commands;
    this._statusMessage = new StatusBarMessage(this);
  }
  $acceptStaticEntries(added) {
    for (const item of added) {
      this._existingItems.set(item.entryId, item);
    }
  }
  async $provideTooltip(entryId, cancellation) {
    const entry = this._entries.get(entryId);
    if (!entry) {
      return void 0;
    }
    const tooltip = typeof entry.tooltip2 === "function" ? await entry.tooltip2(cancellation) : entry.tooltip2;
    return !cancellation.isCancellationRequested ? MarkdownString4.fromStrict(tooltip) : void 0;
  }
  createStatusBarEntry(extension, id2, alignment, priority) {
    const entry = new ExtHostStatusBarEntry(this._proxy, this._commands, this._existingItems, extension, id2, alignment, priority, () => this._entries.delete(entry.entryId));
    this._entries.set(entry.entryId, entry);
    return entry;
  }
  setStatusBarMessage(text, timeoutOrThenable) {
    const d = this._statusMessage.setMessage(text);
    let handle;
    if (typeof timeoutOrThenable === "number") {
      handle = setTimeout(() => d.dispose(), timeoutOrThenable);
    } else if (typeof timeoutOrThenable !== "undefined") {
      timeoutOrThenable.then(() => d.dispose(), () => d.dispose());
    }
    return new Disposable2(() => {
      d.dispose();
      clearTimeout(handle);
    });
  }
};

// out-build/vs/workbench/api/common/extHostTextEditors.js
var ExtHostEditors = class extends Disposable {
  constructor(mainContext, _extHostDocumentsAndEditors) {
    super();
    this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
    this._onDidChangeTextEditorSelection = new Emitter();
    this._onDidChangeTextEditorOptions = new Emitter();
    this._onDidChangeTextEditorVisibleRanges = new Emitter();
    this._onDidChangeTextEditorViewColumn = new Emitter();
    this._onDidChangeTextEditorDiffInformation = new Emitter();
    this._onDidChangeActiveTextEditor = new Emitter();
    this._onDidChangeVisibleTextEditors = new Emitter();
    this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
    this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
    this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event;
    this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
    this.onDidChangeTextEditorDiffInformation = this._onDidChangeTextEditorDiffInformation.event;
    this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
    this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadTextEditors);
    this._register(this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors((e) => this._onDidChangeVisibleTextEditors.fire(e)));
    this._register(this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor((e) => this._onDidChangeActiveTextEditor.fire(e)));
  }
  getActiveTextEditor() {
    return this._extHostDocumentsAndEditors.activeEditor();
  }
  getVisibleTextEditors(internal) {
    const editors = this._extHostDocumentsAndEditors.allEditors();
    return internal ? editors : editors.map((editor) => editor.value);
  }
  async showTextDocument(document2, columnOrOptions, preserveFocus) {
    let options2;
    if (typeof columnOrOptions === "number") {
      options2 = {
        position: ViewColumn2.from(columnOrOptions),
        preserveFocus
      };
    } else if (typeof columnOrOptions === "object") {
      options2 = {
        position: ViewColumn2.from(columnOrOptions.viewColumn),
        preserveFocus: columnOrOptions.preserveFocus,
        selection: typeof columnOrOptions.selection === "object" ? Range4.from(columnOrOptions.selection) : void 0,
        pinned: typeof columnOrOptions.preview === "boolean" ? !columnOrOptions.preview : void 0
      };
    } else {
      options2 = {
        preserveFocus: false
      };
    }
    const editorId = await this._proxy.$tryShowTextDocument(document2.uri, options2);
    const editor = editorId && this._extHostDocumentsAndEditors.getEditor(editorId);
    if (editor) {
      return editor.value;
    }
    if (editorId) {
      throw new Error(`Could NOT open editor for "${document2.uri.toString()}" because another editor opened in the meantime.`);
    } else {
      throw new Error(`Could NOT open editor for "${document2.uri.toString()}".`);
    }
  }
  createTextEditorDecorationType(extension, options2) {
    return new TextEditorDecorationType(this._proxy, extension, options2).value;
  }
  // --- called from main thread
  $acceptEditorPropertiesChanged(id2, data2) {
    const textEditor = this._extHostDocumentsAndEditors.getEditor(id2);
    if (!textEditor) {
      throw new Error("unknown text editor");
    }
    if (data2.options) {
      textEditor._acceptOptions(data2.options);
    }
    if (data2.selections) {
      const selections = data2.selections.selections.map(Selection3.to);
      textEditor._acceptSelections(selections);
    }
    if (data2.visibleRanges) {
      const visibleRanges = coalesce(data2.visibleRanges.map(Range4.to));
      textEditor._acceptVisibleRanges(visibleRanges);
    }
    if (data2.options) {
      this._onDidChangeTextEditorOptions.fire({
        textEditor: textEditor.value,
        options: { ...data2.options, lineNumbers: TextEditorLineNumbersStyle2.to(data2.options.lineNumbers) }
      });
    }
    if (data2.selections) {
      const kind = TextEditorSelectionChangeKind.fromValue(data2.selections.source);
      const selections = data2.selections.selections.map(Selection3.to);
      this._onDidChangeTextEditorSelection.fire({
        textEditor: textEditor.value,
        selections,
        kind
      });
    }
    if (data2.visibleRanges) {
      const visibleRanges = coalesce(data2.visibleRanges.map(Range4.to));
      this._onDidChangeTextEditorVisibleRanges.fire({
        textEditor: textEditor.value,
        visibleRanges
      });
    }
  }
  $acceptEditorPositionData(data2) {
    for (const id2 in data2) {
      const textEditor = this._extHostDocumentsAndEditors.getEditor(id2);
      if (!textEditor) {
        throw new Error("Unknown text editor");
      }
      const viewColumn = ViewColumn2.to(data2[id2]);
      if (textEditor.value.viewColumn !== viewColumn) {
        textEditor._acceptViewColumn(viewColumn);
        this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor.value, viewColumn });
      }
    }
  }
  $acceptEditorDiffInformation(id2, diffInformation) {
    const textEditor = this._extHostDocumentsAndEditors.getEditor(id2);
    if (!textEditor) {
      throw new Error("unknown text editor");
    }
    if (!diffInformation) {
      textEditor._acceptDiffInformation(void 0);
      this._onDidChangeTextEditorDiffInformation.fire({
        textEditor: textEditor.value,
        diffInformation: void 0
      });
      return;
    }
    const that = this;
    const result = diffInformation.map((diff2) => {
      const original = URI.revive(diff2.original);
      const modified = URI.revive(diff2.modified);
      const changes = diff2.changes.map((change) => {
        const [originalStartLineNumber, originalEndLineNumberExclusive, modifiedStartLineNumber, modifiedEndLineNumberExclusive] = change;
        let kind;
        if (originalStartLineNumber === originalEndLineNumberExclusive) {
          kind = TextEditorChangeKind.Addition;
        } else if (modifiedStartLineNumber === modifiedEndLineNumberExclusive) {
          kind = TextEditorChangeKind.Deletion;
        } else {
          kind = TextEditorChangeKind.Modification;
        }
        return {
          original: {
            startLineNumber: originalStartLineNumber,
            endLineNumberExclusive: originalEndLineNumberExclusive
          },
          modified: {
            startLineNumber: modifiedStartLineNumber,
            endLineNumberExclusive: modifiedEndLineNumberExclusive
          },
          kind
        };
      });
      return Object.freeze({
        documentVersion: diff2.documentVersion,
        original,
        modified,
        changes,
        get isStale() {
          const document2 = that._extHostDocumentsAndEditors.getDocument(modified);
          return document2?.version !== diff2.documentVersion;
        }
      });
    });
    textEditor._acceptDiffInformation(result);
    this._onDidChangeTextEditorDiffInformation.fire({
      textEditor: textEditor.value,
      diffInformation: result
    });
  }
  getDiffInformation(id2) {
    return Promise.resolve(this._proxy.$getDiffInformation(id2));
  }
};

// out-build/vs/workbench/api/common/extHostTheming.js
var ExtHostTheming = class ExtHostTheming2 {
  constructor(_extHostRpc) {
    this._actual = new ColorTheme(ColorThemeKind.Dark);
    this._onDidChangeActiveColorTheme = new Emitter();
  }
  get activeColorTheme() {
    return this._actual;
  }
  $onColorThemeChange(type) {
    let kind;
    switch (type) {
      case "light":
        kind = ColorThemeKind.Light;
        break;
      case "hcDark":
        kind = ColorThemeKind.HighContrast;
        break;
      case "hcLight":
        kind = ColorThemeKind.HighContrastLight;
        break;
      default:
        kind = ColorThemeKind.Dark;
    }
    this._actual = new ColorTheme(kind);
    this._onDidChangeActiveColorTheme.fire(this._actual);
  }
  get onDidChangeActiveColorTheme() {
    return this._onDidChangeActiveColorTheme.event;
  }
};
ExtHostTheming = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostTheming);

// out-build/vs/workbench/api/common/extHostTimeline.js
var IExtHostTimeline = createDecorator("IExtHostTimeline");
var ExtHostTimeline = class {
  constructor(mainContext, commands) {
    this._providers = /* @__PURE__ */ new Map();
    this._itemsBySourceAndUriMap = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadTimeline);
    commands.registerArgumentProcessor({
      processArgument: (arg, extension) => {
        if (arg && arg.$mid === 12) {
          if (this._providers.get(arg.source) && extension && isProposedApiEnabled(extension, "timeline")) {
            const uri = arg.uri === void 0 ? void 0 : URI.revive(arg.uri);
            return this._itemsBySourceAndUriMap.get(arg.source)?.get(getUriKey(uri))?.get(arg.handle);
          } else {
            return void 0;
          }
        }
        return arg;
      }
    });
  }
  async $getTimeline(id2, uri, options2, token) {
    const item = this._providers.get(id2);
    return item?.provider.provideTimeline(URI.revive(uri), options2, token);
  }
  registerTimelineProvider(scheme, provider, extensionId, commandConverter) {
    const timelineDisposables = new DisposableStore();
    const convertTimelineItem = this.convertTimelineItem(provider.id, commandConverter, timelineDisposables).bind(this);
    let disposable;
    if (provider.onDidChange) {
      disposable = provider.onDidChange((e) => this._proxy.$emitTimelineChangeEvent({ uri: void 0, reset: true, ...e, id: provider.id }), this);
    }
    const itemsBySourceAndUriMap = this._itemsBySourceAndUriMap;
    return this.registerTimelineProviderCore({
      ...provider,
      scheme,
      onDidChange: void 0,
      async provideTimeline(uri, options2, token) {
        if (options2?.resetCache) {
          timelineDisposables.clear();
          itemsBySourceAndUriMap.get(provider.id)?.clear();
        }
        const result = await provider.provideTimeline(uri, options2, token);
        if (result === void 0 || result === null) {
          return void 0;
        }
        const convertItem = convertTimelineItem(uri, options2);
        return {
          ...result,
          source: provider.id,
          items: result.items.map(convertItem)
        };
      },
      dispose() {
        for (const sourceMap of itemsBySourceAndUriMap.values()) {
          sourceMap.get(provider.id)?.clear();
        }
        disposable?.dispose();
        timelineDisposables.dispose();
      }
    }, extensionId);
  }
  convertTimelineItem(source, commandConverter, disposables) {
    return (uri, options2) => {
      let items;
      if (options2?.cacheResults) {
        let itemsByUri = this._itemsBySourceAndUriMap.get(source);
        if (itemsByUri === void 0) {
          itemsByUri = /* @__PURE__ */ new Map();
          this._itemsBySourceAndUriMap.set(source, itemsByUri);
        }
        const uriKey = getUriKey(uri);
        items = itemsByUri.get(uriKey);
        if (items === void 0) {
          items = /* @__PURE__ */ new Map();
          itemsByUri.set(uriKey, items);
        }
      }
      return (item) => {
        const { iconPath, ...props } = item;
        const handle = `${source}|${item.id ?? item.timestamp}`;
        items?.set(handle, item);
        let icon;
        let iconDark;
        let themeIcon;
        if (item.iconPath) {
          if (iconPath instanceof ThemeIcon2) {
            themeIcon = { id: iconPath.id, color: iconPath.color };
          } else if (URI.isUri(iconPath)) {
            icon = iconPath;
            iconDark = iconPath;
          } else {
            ({ light: icon, dark: iconDark } = iconPath);
          }
        }
        let tooltip;
        if (MarkdownString2.isMarkdownString(props.tooltip)) {
          tooltip = MarkdownString4.from(props.tooltip);
        } else if (isString(props.tooltip)) {
          tooltip = props.tooltip;
        } else if (MarkdownString2.isMarkdownString(props.detail)) {
          console.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip");
          tooltip = MarkdownString4.from(props.detail);
        } else if (isString(props.detail)) {
          console.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip");
          tooltip = props.detail;
        }
        return {
          ...props,
          id: props.id ?? void 0,
          handle,
          source,
          command: item.command ? commandConverter.toInternal(item.command, disposables) : void 0,
          icon,
          iconDark,
          themeIcon,
          tooltip,
          accessibilityInformation: item.accessibilityInformation
        };
      };
    };
  }
  registerTimelineProviderCore(provider, extension) {
    const existing = this._providers.get(provider.id);
    if (existing) {
      throw new Error(`Timeline Provider ${provider.id} already exists.`);
    }
    this._proxy.$registerTimelineProvider({
      id: provider.id,
      label: provider.label,
      scheme: provider.scheme
    });
    this._providers.set(provider.id, { provider, extension });
    return toDisposable(() => {
      for (const sourceMap of this._itemsBySourceAndUriMap.values()) {
        sourceMap.get(provider.id)?.clear();
      }
      this._providers.delete(provider.id);
      this._proxy.$unregisterTimelineProvider(provider.id);
      provider.dispose();
    });
  }
};
function getUriKey(uri) {
  return uri?.toString();
}

// out-build/vs/workbench/common/views.js
var VIEWS_LOG_NAME = localize(4621, null);
var defaultViewIcon = registerIcon("default-view-icon", Codicon.window, localize(4622, null));
var Extensions8;
(function(Extensions9) {
  Extensions9.ViewContainersRegistry = "workbench.registry.view.containers";
  Extensions9.ViewsRegistry = "workbench.registry.view";
})(Extensions8 || (Extensions8 = {}));
var ViewContainerLocation;
(function(ViewContainerLocation2) {
  ViewContainerLocation2[ViewContainerLocation2["Sidebar"] = 0] = "Sidebar";
  ViewContainerLocation2[ViewContainerLocation2["Panel"] = 1] = "Panel";
  ViewContainerLocation2[ViewContainerLocation2["AuxiliaryBar"] = 2] = "AuxiliaryBar";
})(ViewContainerLocation || (ViewContainerLocation = {}));
var ViewContainersRegistryImpl = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidRegister = this._register(new Emitter());
    this.onDidRegister = this._onDidRegister.event;
    this._onDidDeregister = this._register(new Emitter());
    this.onDidDeregister = this._onDidDeregister.event;
    this.viewContainers = /* @__PURE__ */ new Map();
    this.defaultViewContainers = [];
  }
  get all() {
    return [...this.viewContainers.values()].flat();
  }
  registerViewContainer(viewContainerDescriptor, viewContainerLocation, options2) {
    const existing = this.get(viewContainerDescriptor.id);
    if (existing) {
      return existing;
    }
    const viewContainer = viewContainerDescriptor;
    viewContainer.openCommandActionDescriptor = options2?.doNotRegisterOpenCommand ? void 0 : viewContainer.openCommandActionDescriptor ?? { id: viewContainer.id };
    const viewContainers = getOrSet(this.viewContainers, viewContainerLocation, []);
    viewContainers.push(viewContainer);
    if (options2?.isDefault) {
      this.defaultViewContainers.push(viewContainer);
    }
    this._onDidRegister.fire({ viewContainer, viewContainerLocation });
    return viewContainer;
  }
  deregisterViewContainer(viewContainer) {
    for (const viewContainerLocation of this.viewContainers.keys()) {
      const viewContainers = this.viewContainers.get(viewContainerLocation);
      const index = viewContainers?.indexOf(viewContainer);
      if (index !== -1) {
        viewContainers?.splice(index, 1);
        if (viewContainers.length === 0) {
          this.viewContainers.delete(viewContainerLocation);
        }
        this._onDidDeregister.fire({ viewContainer, viewContainerLocation });
        return;
      }
    }
  }
  get(id2) {
    return this.all.filter((viewContainer) => viewContainer.id === id2)[0];
  }
  getViewContainers(location2) {
    return [...this.viewContainers.get(location2) || []];
  }
  getViewContainerLocation(container) {
    return [...this.viewContainers.keys()].filter((location2) => this.getViewContainers(location2).filter((viewContainer) => viewContainer?.id === container.id).length > 0)[0];
  }
  getDefaultViewContainer(location2) {
    return this.defaultViewContainers.find((viewContainer) => this.getViewContainerLocation(viewContainer) === location2);
  }
};
Registry.add(Extensions8.ViewContainersRegistry, new ViewContainersRegistryImpl());
var ViewContentGroups;
(function(ViewContentGroups2) {
  ViewContentGroups2["Open"] = "2_open";
  ViewContentGroups2["Debug"] = "4_debug";
  ViewContentGroups2["SCM"] = "5_scm";
  ViewContentGroups2["More"] = "9_more";
})(ViewContentGroups || (ViewContentGroups = {}));
function compareViewContentDescriptors(a, b) {
  const aGroup = a.group ?? ViewContentGroups.More;
  const bGroup = b.group ?? ViewContentGroups.More;
  if (aGroup !== bGroup) {
    return aGroup.localeCompare(bGroup);
  }
  return (a.order ?? 5) - (b.order ?? 5);
}
var ViewsRegistry = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onViewsRegistered = this._register(new Emitter());
    this.onViewsRegistered = this._onViewsRegistered.event;
    this._onViewsDeregistered = this._register(new Emitter());
    this.onViewsDeregistered = this._onViewsDeregistered.event;
    this._onDidChangeContainer = this._register(new Emitter());
    this.onDidChangeContainer = this._onDidChangeContainer.event;
    this._onDidChangeViewWelcomeContent = this._register(new Emitter());
    this.onDidChangeViewWelcomeContent = this._onDidChangeViewWelcomeContent.event;
    this._viewContainers = [];
    this._views = /* @__PURE__ */ new Map();
    this._viewWelcomeContents = new SetMap();
  }
  registerViews(views, viewContainer) {
    this.registerViews2([{ views, viewContainer }]);
  }
  registerViews2(views) {
    views.forEach(({ views: views2, viewContainer }) => this.addViews(views2, viewContainer));
    this._onViewsRegistered.fire(views);
  }
  deregisterViews(viewDescriptors, viewContainer) {
    const views = this.removeViews(viewDescriptors, viewContainer);
    if (views.length) {
      this._onViewsDeregistered.fire({ views, viewContainer });
    }
  }
  moveViews(viewsToMove, viewContainer) {
    for (const container of this._views.keys()) {
      if (container !== viewContainer) {
        const views = this.removeViews(viewsToMove, container);
        if (views.length) {
          this.addViews(views, viewContainer);
          this._onDidChangeContainer.fire({ views, from: container, to: viewContainer });
        }
      }
    }
  }
  getViews(loc) {
    return this._views.get(loc) || [];
  }
  getView(id2) {
    for (const viewContainer of this._viewContainers) {
      const viewDescriptor = (this._views.get(viewContainer) || []).filter((v) => v.id === id2)[0];
      if (viewDescriptor) {
        return viewDescriptor;
      }
    }
    return null;
  }
  getViewContainer(viewId) {
    for (const viewContainer of this._viewContainers) {
      const viewDescriptor = (this._views.get(viewContainer) || []).filter((v) => v.id === viewId)[0];
      if (viewDescriptor) {
        return viewContainer;
      }
    }
    return null;
  }
  registerViewWelcomeContent(id2, viewContent) {
    this._viewWelcomeContents.add(id2, viewContent);
    this._onDidChangeViewWelcomeContent.fire(id2);
    return toDisposable(() => {
      this._viewWelcomeContents.delete(id2, viewContent);
      this._onDidChangeViewWelcomeContent.fire(id2);
    });
  }
  registerViewWelcomeContent2(id2, viewContentMap) {
    const disposables = /* @__PURE__ */ new Map();
    for (const [key, content] of viewContentMap) {
      this._viewWelcomeContents.add(id2, content);
      disposables.set(key, toDisposable(() => {
        this._viewWelcomeContents.delete(id2, content);
        this._onDidChangeViewWelcomeContent.fire(id2);
      }));
    }
    this._onDidChangeViewWelcomeContent.fire(id2);
    return disposables;
  }
  getViewWelcomeContent(id2) {
    const result = [];
    this._viewWelcomeContents.forEach(id2, (descriptor) => result.push(descriptor));
    return result.sort(compareViewContentDescriptors);
  }
  addViews(viewDescriptors, viewContainer) {
    let views = this._views.get(viewContainer);
    if (!views) {
      views = [];
      this._views.set(viewContainer, views);
      this._viewContainers.push(viewContainer);
    }
    for (const viewDescriptor of viewDescriptors) {
      if (this.getView(viewDescriptor.id) !== null) {
        throw new Error(localize(4623, null, viewDescriptor.id));
      }
      views.push(viewDescriptor);
    }
  }
  removeViews(viewDescriptors, viewContainer) {
    const views = this._views.get(viewContainer);
    if (!views) {
      return [];
    }
    const viewsToDeregister = [];
    const remaningViews = [];
    for (const view of views) {
      if (!viewDescriptors.includes(view)) {
        remaningViews.push(view);
      } else {
        viewsToDeregister.push(view);
      }
    }
    if (viewsToDeregister.length) {
      if (remaningViews.length) {
        this._views.set(viewContainer, remaningViews);
      } else {
        this._views.delete(viewContainer);
        this._viewContainers.splice(this._viewContainers.indexOf(viewContainer), 1);
      }
    }
    return viewsToDeregister;
  }
};
Registry.add(Extensions8.ViewsRegistry, new ViewsRegistry());
var IViewDescriptorService = createDecorator("viewDescriptorService");
var ViewVisibilityState;
(function(ViewVisibilityState2) {
  ViewVisibilityState2[ViewVisibilityState2["Default"] = 0] = "Default";
  ViewVisibilityState2[ViewVisibilityState2["Expand"] = 1] = "Expand";
})(ViewVisibilityState || (ViewVisibilityState = {}));
var TreeItemCollapsibleState2;
(function(TreeItemCollapsibleState3) {
  TreeItemCollapsibleState3[TreeItemCollapsibleState3["None"] = 0] = "None";
  TreeItemCollapsibleState3[TreeItemCollapsibleState3["Collapsed"] = 1] = "Collapsed";
  TreeItemCollapsibleState3[TreeItemCollapsibleState3["Expanded"] = 2] = "Expanded";
})(TreeItemCollapsibleState2 || (TreeItemCollapsibleState2 = {}));
var NoTreeViewError = class extends Error {
  constructor(treeViewId) {
    super(localize(4624, null, treeViewId));
    this.name = "NoTreeViewError";
  }
  static is(err) {
    return !!err && err.name === "NoTreeViewError";
  }
};

// out-build/vs/editor/common/services/treeViewsDnd.js
var TreeViewsDnDService = class {
  constructor() {
    this._dragOperations = /* @__PURE__ */ new Map();
  }
  removeDragOperationTransfer(uuid) {
    if (uuid && this._dragOperations.has(uuid)) {
      const operation = this._dragOperations.get(uuid);
      this._dragOperations.delete(uuid);
      return operation;
    }
    return void 0;
  }
  addDragOperationTransfer(uuid, transferPromise) {
    this._dragOperations.set(uuid, transferPromise);
  }
};

// out-build/vs/workbench/api/common/extHostTreeViews.js
function toTreeItemLabel(label, extension) {
  if (isString(label)) {
    return { label };
  }
  if (label && typeof label === "object" && label.label) {
    let highlights = void 0;
    if (Array.isArray(label.highlights)) {
      highlights = label.highlights.filter((highlight) => highlight.length === 2 && typeof highlight[0] === "number" && typeof highlight[1] === "number");
      highlights = highlights.length ? highlights : void 0;
    }
    if (isString(label.label)) {
      return { label: label.label, highlights };
    } else if (MarkdownString2.isMarkdownString(label.label)) {
      checkProposedApiEnabled(extension, "treeItemMarkdownLabel");
      return { label: MarkdownString4.from(label.label), highlights };
    }
  }
  return void 0;
}
var ExtHostTreeViews = class extends Disposable {
  constructor(_proxy, _commands, _logService) {
    super();
    this._proxy = _proxy;
    this._commands = _commands;
    this._logService = _logService;
    this._treeViews = /* @__PURE__ */ new Map();
    this._treeDragAndDropService = new TreeViewsDnDService();
    function isTreeViewConvertableItem(arg) {
      return arg && arg.$treeViewId && (arg.$treeItemHandle || arg.$selectedTreeItems || arg.$focusedTreeItem);
    }
    _commands.registerArgumentProcessor({
      processArgument: (arg) => {
        if (isTreeViewConvertableItem(arg)) {
          return this._convertArgument(arg);
        } else if (Array.isArray(arg) && arg.length > 0) {
          return arg.map((item) => {
            if (isTreeViewConvertableItem(item)) {
              return this._convertArgument(item);
            }
            return item;
          });
        }
        return arg;
      }
    });
  }
  registerTreeDataProvider(id2, treeDataProvider, extension) {
    const treeView = this.createTreeView(id2, { treeDataProvider }, extension);
    return { dispose: () => treeView.dispose() };
  }
  createTreeView(viewId, options2, extension) {
    if (!options2 || !options2.treeDataProvider) {
      throw new Error("Options with treeDataProvider is mandatory");
    }
    const dropMimeTypes = options2.dragAndDropController?.dropMimeTypes ?? [];
    const dragMimeTypes = options2.dragAndDropController?.dragMimeTypes ?? [];
    const hasHandleDrag = !!options2.dragAndDropController?.handleDrag;
    const hasHandleDrop = !!options2.dragAndDropController?.handleDrop;
    const treeView = this._createExtHostTreeView(viewId, options2, extension);
    const proxyOptions = { showCollapseAll: !!options2.showCollapseAll, canSelectMany: !!options2.canSelectMany, dropMimeTypes, dragMimeTypes, hasHandleDrag, hasHandleDrop, manuallyManageCheckboxes: !!options2.manageCheckboxStateManually };
    const registerPromise = this._proxy.$registerTreeViewDataProvider(viewId, proxyOptions);
    const view = {
      get onDidCollapseElement() {
        return treeView.onDidCollapseElement;
      },
      get onDidExpandElement() {
        return treeView.onDidExpandElement;
      },
      get selection() {
        return treeView.selectedElements;
      },
      get onDidChangeSelection() {
        return treeView.onDidChangeSelection;
      },
      get activeItem() {
        checkProposedApiEnabled(extension, "treeViewActiveItem");
        return treeView.focusedElement;
      },
      get onDidChangeActiveItem() {
        checkProposedApiEnabled(extension, "treeViewActiveItem");
        return treeView.onDidChangeActiveItem;
      },
      get visible() {
        return treeView.visible;
      },
      get onDidChangeVisibility() {
        return treeView.onDidChangeVisibility;
      },
      get onDidChangeCheckboxState() {
        return treeView.onDidChangeCheckboxState;
      },
      get message() {
        return treeView.message;
      },
      set message(message) {
        if (isMarkdownString(message)) {
          checkProposedApiEnabled(extension, "treeViewMarkdownMessage");
        }
        treeView.message = message;
      },
      get title() {
        return treeView.title;
      },
      set title(title) {
        treeView.title = title;
      },
      get description() {
        return treeView.description;
      },
      set description(description) {
        treeView.description = description;
      },
      get badge() {
        return treeView.badge;
      },
      set badge(badge) {
        if (badge !== void 0 && ViewBadge.isViewBadge(badge)) {
          treeView.badge = {
            value: Math.floor(Math.abs(badge.value)),
            tooltip: badge.tooltip
          };
        } else if (badge === void 0) {
          treeView.badge = void 0;
        }
      },
      reveal: (element, options3) => {
        return treeView.reveal(element, options3);
      },
      dispose: async () => {
        await registerPromise;
        this._treeViews.delete(viewId);
        treeView.dispose();
      }
    };
    this._register(view);
    return view;
  }
  async $getChildren(treeViewId, treeItemHandles) {
    const treeView = this._treeViews.get(treeViewId);
    if (!treeView) {
      return Promise.reject(new NoTreeViewError(treeViewId));
    }
    if (!treeItemHandles) {
      const children = await treeView.getChildren();
      return children ? [[0, ...children]] : void 0;
    }
    const result = [];
    for (let i = 0; i < treeItemHandles.length; i++) {
      const treeItemHandle = treeItemHandles[i];
      const children = await treeView.getChildren(treeItemHandle);
      if (children) {
        result.push([i, ...children]);
      }
    }
    return result;
  }
  async $handleDrop(destinationViewId, requestId, treeDataTransferDTO, targetItemHandle, token, operationUuid, sourceViewId, sourceTreeItemHandles) {
    const treeView = this._treeViews.get(destinationViewId);
    if (!treeView) {
      return Promise.reject(new NoTreeViewError(destinationViewId));
    }
    const treeDataTransfer = DataTransfer3.toDataTransfer(treeDataTransferDTO, async (dataItemIndex) => {
      return (await this._proxy.$resolveDropFileData(destinationViewId, requestId, dataItemIndex)).buffer;
    });
    if (sourceViewId === destinationViewId && sourceTreeItemHandles) {
      await this._addAdditionalTransferItems(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid);
    }
    return treeView.onDrop(treeDataTransfer, targetItemHandle, token);
  }
  async _addAdditionalTransferItems(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid) {
    const existingTransferOperation = this._treeDragAndDropService.removeDragOperationTransfer(operationUuid);
    if (existingTransferOperation) {
      (await existingTransferOperation)?.forEach((value, key) => {
        if (value) {
          treeDataTransfer.set(key, value);
        }
      });
    } else if (operationUuid && treeView.handleDrag) {
      const willDropPromise = treeView.handleDrag(sourceTreeItemHandles, treeDataTransfer, token);
      this._treeDragAndDropService.addDragOperationTransfer(operationUuid, willDropPromise);
      await willDropPromise;
    }
    return treeDataTransfer;
  }
  async $handleDrag(sourceViewId, sourceTreeItemHandles, operationUuid, token) {
    const treeView = this._treeViews.get(sourceViewId);
    if (!treeView) {
      return Promise.reject(new NoTreeViewError(sourceViewId));
    }
    const treeDataTransfer = await this._addAdditionalTransferItems(new DataTransfer(), treeView, sourceTreeItemHandles, token, operationUuid);
    if (!treeDataTransfer || token.isCancellationRequested) {
      return;
    }
    return DataTransfer3.from(treeDataTransfer);
  }
  async $hasResolve(treeViewId) {
    const treeView = this._treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    return treeView.hasResolve;
  }
  $resolve(treeViewId, treeItemHandle, token) {
    const treeView = this._treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    return treeView.resolveTreeItem(treeItemHandle, token);
  }
  $setExpanded(treeViewId, treeItemHandle, expanded) {
    const treeView = this._treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setExpanded(treeItemHandle, expanded);
  }
  $setSelectionAndFocus(treeViewId, selectedHandles, focusedHandle) {
    const treeView = this._treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setSelectionAndFocus(selectedHandles, focusedHandle);
  }
  $setVisible(treeViewId, isVisible) {
    const treeView = this._treeViews.get(treeViewId);
    if (!treeView) {
      if (!isVisible) {
        return;
      }
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setVisible(isVisible);
  }
  $changeCheckboxState(treeViewId, checkboxUpdate) {
    const treeView = this._treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setCheckboxState(checkboxUpdate);
  }
  _createExtHostTreeView(id2, options2, extension) {
    const treeView = this._register(new ExtHostTreeView(id2, options2, this._proxy, this._commands.converter, this._logService, extension));
    this._treeViews.set(id2, treeView);
    return treeView;
  }
  _convertArgument(arg) {
    const treeView = this._treeViews.get(arg.$treeViewId);
    const asItemHandle = arg;
    if (treeView && asItemHandle.$treeItemHandle) {
      return treeView.getExtensionElement(asItemHandle.$treeItemHandle);
    }
    const asPaneHandle = arg;
    if (treeView && asPaneHandle.$focusedTreeItem) {
      return treeView.focusedElement;
    }
    return null;
  }
};
var ExtHostTreeView = class _ExtHostTreeView extends Disposable {
  static {
    this.LABEL_HANDLE_PREFIX = "0";
  }
  static {
    this.ID_HANDLE_PREFIX = "1";
  }
  get visible() {
    return this._visible;
  }
  get selectedElements() {
    return this._selectedHandles.map((handle) => this.getExtensionElement(handle)).filter((element) => !isUndefinedOrNull(element));
  }
  get focusedElement() {
    return this._focusedHandle ? this.getExtensionElement(this._focusedHandle) : void 0;
  }
  constructor(_viewId, options2, _proxy, _commands, _logService, _extension) {
    super();
    this._viewId = _viewId;
    this._proxy = _proxy;
    this._commands = _commands;
    this._logService = _logService;
    this._extension = _extension;
    this._roots = void 0;
    this._elements = /* @__PURE__ */ new Map();
    this._nodes = /* @__PURE__ */ new Map();
    this._visible = false;
    this._selectedHandles = [];
    this._focusedHandle = void 0;
    this._onDidExpandElement = this._register(new Emitter());
    this.onDidExpandElement = this._onDidExpandElement.event;
    this._onDidCollapseElement = this._register(new Emitter());
    this.onDidCollapseElement = this._onDidCollapseElement.event;
    this._onDidChangeSelection = this._register(new Emitter());
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this._onDidChangeActiveItem = this._register(new Emitter());
    this.onDidChangeActiveItem = this._onDidChangeActiveItem.event;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._onDidChangeCheckboxState = this._register(new Emitter());
    this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
    this._onDidChangeData = this._register(new Emitter());
    this._refreshPromise = Promise.resolve();
    this._refreshQueue = Promise.resolve();
    this._nodesToClear = /* @__PURE__ */ new Set();
    this._message = "";
    this._title = "";
    this._refreshCancellationSource = new CancellationTokenSource();
    if (_extension.contributes && _extension.contributes.views) {
      for (const location2 in _extension.contributes.views) {
        for (const view of _extension.contributes.views[location2]) {
          if (view.id === _viewId) {
            this._title = view.name;
          }
        }
      }
    }
    this._dataProvider = options2.treeDataProvider;
    this._dndController = options2.dragAndDropController;
    if (this._dataProvider.onDidChangeTreeData) {
      this._register(this._dataProvider.onDidChangeTreeData((elementOrElements) => {
        if (Array.isArray(elementOrElements) && elementOrElements.length === 0) {
          return;
        }
        this._onDidChangeData.fire({ message: false, element: elementOrElements });
      }));
    }
    let refreshingPromise;
    let promiseCallback;
    const onDidChangeData = Event.debounce(this._onDidChangeData.event, (result, current) => {
      if (!result) {
        result = { message: false, elements: [] };
      }
      if (current.element !== false) {
        if (!refreshingPromise) {
          refreshingPromise = new Promise((c) => promiseCallback = c);
          this._refreshPromise = this._refreshPromise.then(() => refreshingPromise);
        }
        if (Array.isArray(current.element)) {
          result.elements.push(...current.element);
        } else {
          result.elements.push(current.element);
        }
      }
      if (current.message) {
        result.message = true;
      }
      return result;
    }, 200, true);
    this._register(onDidChangeData(({ message, elements }) => {
      if (elements.length) {
        elements = distinct(elements);
        this._refreshQueue = this._refreshQueue.then(() => {
          const _promiseCallback = promiseCallback;
          refreshingPromise = null;
          const childrenToClear = Array.from(this._nodesToClear);
          this._nodesToClear.clear();
          this._debugLogRefresh("start", elements, childrenToClear);
          return this._refresh(elements).then(() => {
            this._debugLogRefresh("done", elements, childrenToClear);
            this._clearNodes(childrenToClear);
            return _promiseCallback();
          }).catch((e) => {
            const message2 = e instanceof Error ? e.message : JSON.stringify(e);
            this._debugLogRefresh("error", elements, childrenToClear);
            this._clearNodes(childrenToClear);
            this._logService.error(`Unable to refresh tree view ${this._viewId}: ${message2}`);
            return _promiseCallback();
          });
        });
      }
      if (message) {
        this._proxy.$setMessage(this._viewId, MarkdownString4.fromStrict(this._message) ?? "");
      }
    }));
  }
  _debugCollectHandles(elements) {
    const changed = [];
    for (const el of elements) {
      if (!el) {
        changed.push("<root>");
        continue;
      }
      const node = this._nodes.get(el);
      if (node) {
        changed.push(node.item.handle);
      }
    }
    const roots = this._roots?.map((r) => r.item.handle) ?? [];
    return { changed, roots };
  }
  _debugLogRefresh(phase, elements, childrenToClear) {
    if (!this._isDebugLogging()) {
      return;
    }
    try {
      const snapshot = this._debugCollectHandles(elements);
      snapshot.clearing = childrenToClear.map((n) => n.item.handle);
      const changedCount = snapshot.changed.length;
      const nodesToClearLen = childrenToClear.length;
      this._logService.debug(`[TreeView:${this._viewId}] refresh ${phase} changed=${changedCount} nodesToClear=${nodesToClearLen} elements.size=${this._elements.size} nodes.size=${this._nodes.size} handles=${JSON.stringify(snapshot)}`);
    } catch {
      this._logService.debug(`[TreeView:${this._viewId}] refresh ${phase} (snapshot failed)`);
    }
  }
  _isDebugLogging() {
    try {
      const level = this._logService.getLevel();
      return level === LogLevel.Debug || level === LogLevel.Trace;
    } catch {
      return false;
    }
  }
  async getChildren(parentHandle) {
    const parentElement = parentHandle ? this.getExtensionElement(parentHandle) : void 0;
    if (parentHandle && !parentElement) {
      this._logService.error(`No tree item with id '${parentHandle}' found.`);
      return Promise.resolve([]);
    }
    let childrenNodes = this._getChildrenNodes(parentHandle);
    if (!childrenNodes) {
      childrenNodes = await this._fetchChildrenNodes(parentElement);
    }
    return childrenNodes ? childrenNodes.map((n) => n.item) : void 0;
  }
  getExtensionElement(treeItemHandle) {
    return this._elements.get(treeItemHandle);
  }
  reveal(element, options2) {
    options2 = options2 ? options2 : { select: true, focus: false };
    const select = isUndefinedOrNull(options2.select) ? true : options2.select;
    const focus = isUndefinedOrNull(options2.focus) ? false : options2.focus;
    const expand = isUndefinedOrNull(options2.expand) ? false : options2.expand;
    if (typeof this._dataProvider.getParent !== "function") {
      return Promise.reject(new Error(`Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method`));
    }
    if (element) {
      return this._refreshPromise.then(() => this._resolveUnknownParentChain(element)).then((parentChain) => this._resolveTreeNode(element, parentChain[parentChain.length - 1]).then((treeNode) => this._proxy.$reveal(this._viewId, { item: treeNode.item, parentChain: parentChain.map((p) => p.item) }, { select, focus, expand })), (error) => this._logService.error(error));
    } else {
      return this._proxy.$reveal(this._viewId, void 0, { select, focus, expand });
    }
  }
  get message() {
    return this._message;
  }
  set message(message) {
    this._message = message;
    this._onDidChangeData.fire({ message: true, element: false });
  }
  get title() {
    return this._title;
  }
  set title(title) {
    this._title = title;
    this._proxy.$setTitle(this._viewId, title, this._description);
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
    this._proxy.$setTitle(this._viewId, this._title, description);
  }
  get badge() {
    return this._badge;
  }
  set badge(badge) {
    if (this._badge?.value === badge?.value && this._badge?.tooltip === badge?.tooltip) {
      return;
    }
    this._badge = ViewBadge2.from(badge);
    this._proxy.$setBadge(this._viewId, badge);
  }
  setExpanded(treeItemHandle, expanded) {
    const element = this.getExtensionElement(treeItemHandle);
    if (element) {
      if (expanded) {
        this._onDidExpandElement.fire(Object.freeze({ element }));
      } else {
        this._onDidCollapseElement.fire(Object.freeze({ element }));
      }
    }
  }
  setSelectionAndFocus(selectedHandles, focusedHandle) {
    const changedSelection = !equals(this._selectedHandles, selectedHandles);
    this._selectedHandles = selectedHandles;
    const changedFocus = this._focusedHandle !== focusedHandle;
    this._focusedHandle = focusedHandle;
    if (changedSelection) {
      this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements }));
    }
    if (changedFocus) {
      this._onDidChangeActiveItem.fire(Object.freeze({ activeItem: this.focusedElement }));
    }
  }
  setVisible(visible) {
    if (visible !== this._visible) {
      this._visible = visible;
      this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible }));
    }
  }
  async setCheckboxState(checkboxUpdates) {
    const items = (await Promise.all(checkboxUpdates.map(async (checkboxUpdate) => {
      const extensionItem = this.getExtensionElement(checkboxUpdate.treeItemHandle);
      if (extensionItem) {
        return {
          extensionItem,
          treeItem: await this._dataProvider.getTreeItem(extensionItem),
          newState: checkboxUpdate.newState ? TreeItemCheckboxState.Checked : TreeItemCheckboxState.Unchecked
        };
      }
      return Promise.resolve(void 0);
    }))).filter((item) => item !== void 0);
    items.forEach((item) => {
      item.treeItem.checkboxState = item.newState ? TreeItemCheckboxState.Checked : TreeItemCheckboxState.Unchecked;
    });
    this._onDidChangeCheckboxState.fire({ items: items.map((item) => [item.extensionItem, item.newState]) });
  }
  async handleDrag(sourceTreeItemHandles, treeDataTransfer, token) {
    const extensionTreeItems = [];
    for (const sourceHandle of sourceTreeItemHandles) {
      const extensionItem = this.getExtensionElement(sourceHandle);
      if (extensionItem) {
        extensionTreeItems.push(extensionItem);
      }
    }
    if (!this._dndController?.handleDrag || extensionTreeItems.length === 0) {
      return;
    }
    await this._dndController.handleDrag(extensionTreeItems, treeDataTransfer, token);
    return treeDataTransfer;
  }
  get hasHandleDrag() {
    return !!this._dndController?.handleDrag;
  }
  async onDrop(treeDataTransfer, targetHandleOrNode, token) {
    const target = targetHandleOrNode ? this.getExtensionElement(targetHandleOrNode) : void 0;
    if (!target && targetHandleOrNode || !this._dndController?.handleDrop) {
      return;
    }
    return asPromise(() => this._dndController?.handleDrop ? this._dndController.handleDrop(target, treeDataTransfer, token) : void 0);
  }
  get hasResolve() {
    return !!this._dataProvider.resolveTreeItem;
  }
  async resolveTreeItem(treeItemHandle, token) {
    if (!this._dataProvider.resolveTreeItem) {
      return;
    }
    const element = this._elements.get(treeItemHandle);
    if (element) {
      const node = this._nodes.get(element);
      if (node) {
        const resolve2 = await this._dataProvider.resolveTreeItem(node.extensionItem, element, token) ?? node.extensionItem;
        this._validateTreeItem(resolve2);
        node.item.tooltip = this._getTooltip(resolve2.tooltip);
        node.item.command = this._getCommand(node.disposableStore, resolve2.command);
        return node.item;
      }
    }
    return;
  }
  _resolveUnknownParentChain(element) {
    return this._resolveParent(element).then((parent) => {
      if (!parent) {
        return Promise.resolve([]);
      }
      return this._resolveUnknownParentChain(parent).then((result) => this._resolveTreeNode(parent, result[result.length - 1]).then((parentNode) => {
        result.push(parentNode);
        return result;
      }));
    });
  }
  _resolveParent(element) {
    const node = this._nodes.get(element);
    if (node) {
      return Promise.resolve(node.parent ? this._elements.get(node.parent.item.handle) : void 0);
    }
    return asPromise(() => this._dataProvider.getParent(element));
  }
  _resolveTreeNode(element, parent) {
    const node = this._nodes.get(element);
    if (node) {
      return Promise.resolve(node);
    }
    return asPromise(() => this._dataProvider.getTreeItem(element)).then((extTreeItem) => this._createHandle(element, extTreeItem, parent, true)).then((handle) => this.getChildren(parent ? parent.item.handle : void 0).then(() => {
      const cachedElement = this.getExtensionElement(handle);
      if (cachedElement) {
        const node2 = this._nodes.get(cachedElement);
        if (node2) {
          return Promise.resolve(node2);
        }
      }
      throw new Error(`Cannot resolve tree item for element ${handle} from extension ${this._extension.identifier.value}`);
    }));
  }
  _getChildrenNodes(parentNodeOrHandle) {
    if (parentNodeOrHandle) {
      let parentNode;
      if (typeof parentNodeOrHandle === "string") {
        const parentElement = this.getExtensionElement(parentNodeOrHandle);
        parentNode = parentElement ? this._nodes.get(parentElement) : void 0;
      } else {
        parentNode = parentNodeOrHandle;
      }
      return parentNode ? parentNode.children || void 0 : void 0;
    }
    return this._roots;
  }
  async _fetchChildrenNodes(parentElement) {
    this._addChildrenToClear(parentElement);
    const cts = new CancellationTokenSource(this._refreshCancellationSource.token);
    try {
      const elements = await this._dataProvider.getChildren(parentElement);
      const parentNode = parentElement ? this._nodes.get(parentElement) : void 0;
      if (cts.token.isCancellationRequested) {
        return void 0;
      }
      const coalescedElements = coalesce(elements || []);
      const treeItems = await Promise.all(coalesce(coalescedElements).map((element) => {
        return this._dataProvider.getTreeItem(element);
      }));
      if (cts.token.isCancellationRequested) {
        return void 0;
      }
      const items = treeItems.map((item, index) => item ? this._createAndRegisterTreeNode(coalescedElements[index], item, parentNode) : null);
      return coalesce(items);
    } finally {
      cts.dispose();
    }
  }
  _refresh(elements) {
    const hasRoot = elements.some((element) => !element);
    if (hasRoot) {
      this._refreshCancellationSource.dispose(true);
      this._refreshCancellationSource = new CancellationTokenSource();
      this._addChildrenToClear();
      return this._proxy.$refresh(this._viewId);
    } else {
      const handlesToRefresh = this._getHandlesToRefresh(elements);
      if (handlesToRefresh.length) {
        return this._refreshHandles(handlesToRefresh);
      }
    }
    return Promise.resolve(void 0);
  }
  _getHandlesToRefresh(elements) {
    const elementsToUpdate = /* @__PURE__ */ new Set();
    const elementNodes = elements.map((element) => this._nodes.get(element));
    for (const elementNode of elementNodes) {
      if (elementNode && !elementsToUpdate.has(elementNode.item.handle)) {
        let currentNode = elementNode;
        while (currentNode && currentNode.parent && elementNodes.findIndex((node) => currentNode && currentNode.parent && node && node.item.handle === currentNode.parent.item.handle) === -1) {
          const parentElement = this._elements.get(currentNode.parent.item.handle);
          currentNode = parentElement ? this._nodes.get(parentElement) : void 0;
        }
        if (currentNode && !currentNode.parent) {
          elementsToUpdate.add(elementNode.item.handle);
        }
      }
    }
    const handlesToUpdate = [];
    elementsToUpdate.forEach((handle) => {
      const element = this._elements.get(handle);
      if (element) {
        const node = this._nodes.get(element);
        if (node && (!node.parent || !elementsToUpdate.has(node.parent.item.handle))) {
          handlesToUpdate.push(handle);
        }
      }
    });
    return handlesToUpdate;
  }
  _refreshHandles(itemHandles) {
    const itemsToRefresh = {};
    return Promise.all(itemHandles.map((treeItemHandle) => this._refreshNode(treeItemHandle).then((node) => {
      if (node) {
        itemsToRefresh[treeItemHandle] = node.item;
      }
    }))).then(() => Object.keys(itemsToRefresh).length ? this._proxy.$refresh(this._viewId, itemsToRefresh) : void 0);
  }
  _refreshNode(treeItemHandle) {
    const extElement = this.getExtensionElement(treeItemHandle);
    if (extElement) {
      const existing = this._nodes.get(extElement);
      if (existing) {
        this._addChildrenToClear(extElement);
        return asPromise(() => this._dataProvider.getTreeItem(extElement)).then((extTreeItem) => {
          if (extTreeItem) {
            const newNode = this._createTreeNode(extElement, extTreeItem, existing.parent);
            this._updateNodeCache(extElement, newNode, existing, existing.parent);
            existing.dispose();
            return newNode;
          }
          return null;
        });
      }
    }
    return Promise.resolve(null);
  }
  _createAndRegisterTreeNode(element, extTreeItem, parentNode) {
    const node = this._createTreeNode(element, extTreeItem, parentNode);
    if (extTreeItem.id && this._elements.has(node.item.handle)) {
      throw new Error(localize(3024, null, extTreeItem.id));
    }
    this._addNodeToCache(element, node);
    this._addNodeToParentCache(node, parentNode);
    return node;
  }
  _getTooltip(tooltip) {
    if (MarkdownString2.isMarkdownString(tooltip)) {
      return MarkdownString4.from(tooltip);
    }
    return tooltip;
  }
  _getCommand(disposable, command) {
    return command ? { ...this._commands.toInternal(command, disposable), originalId: command.command } : void 0;
  }
  _getCheckbox(extensionTreeItem) {
    if (extensionTreeItem.checkboxState === void 0) {
      return void 0;
    }
    let checkboxState;
    let tooltip = void 0;
    let accessibilityInformation = void 0;
    if (typeof extensionTreeItem.checkboxState === "number") {
      checkboxState = extensionTreeItem.checkboxState;
    } else {
      checkboxState = extensionTreeItem.checkboxState.state;
      tooltip = extensionTreeItem.checkboxState.tooltip;
      accessibilityInformation = extensionTreeItem.checkboxState.accessibilityInformation;
    }
    return { isChecked: checkboxState === TreeItemCheckboxState.Checked, tooltip, accessibilityInformation };
  }
  _validateTreeItem(extensionTreeItem) {
    if (!TreeItem.isTreeItem(extensionTreeItem, this._extension)) {
      throw new Error(`Extension ${this._extension.identifier.value} has provided an invalid tree item.`);
    }
  }
  _createTreeNode(element, extensionTreeItem, parent) {
    this._validateTreeItem(extensionTreeItem);
    const disposableStore = this._register(new DisposableStore());
    const handle = this._createHandle(element, extensionTreeItem, parent);
    const icon = this._getLightIconPath(extensionTreeItem);
    const item = {
      handle,
      parentHandle: parent ? parent.item.handle : void 0,
      label: toTreeItemLabel(extensionTreeItem.label, this._extension),
      description: extensionTreeItem.description,
      resourceUri: extensionTreeItem.resourceUri,
      tooltip: this._getTooltip(extensionTreeItem.tooltip),
      command: this._getCommand(disposableStore, extensionTreeItem.command),
      contextValue: extensionTreeItem.contextValue,
      icon,
      iconDark: this._getDarkIconPath(extensionTreeItem) || icon,
      themeIcon: this._getThemeIcon(extensionTreeItem),
      collapsibleState: isUndefinedOrNull(extensionTreeItem.collapsibleState) ? TreeItemCollapsibleState.None : extensionTreeItem.collapsibleState,
      accessibilityInformation: extensionTreeItem.accessibilityInformation,
      checkbox: this._getCheckbox(extensionTreeItem)
    };
    return {
      item,
      extensionItem: extensionTreeItem,
      parent,
      children: void 0,
      disposableStore,
      dispose() {
        disposableStore.dispose();
      }
    };
  }
  _getThemeIcon(extensionTreeItem) {
    return extensionTreeItem.iconPath instanceof ThemeIcon2 ? extensionTreeItem.iconPath : void 0;
  }
  _createHandle(element, { id: id2, label, resourceUri }, parent, returnFirst) {
    if (id2) {
      return `${_ExtHostTreeView.ID_HANDLE_PREFIX}/${id2}`;
    }
    const treeItemLabel = toTreeItemLabel(label, this._extension);
    const prefix = parent ? parent.item.handle : _ExtHostTreeView.LABEL_HANDLE_PREFIX;
    let labelValue = "";
    if (treeItemLabel) {
      if (isMarkdownString(treeItemLabel.label)) {
        labelValue = treeItemLabel.label.value;
      } else {
        labelValue = treeItemLabel.label;
      }
    }
    let elementId = labelValue || (resourceUri ? basename2(resourceUri) : "");
    elementId = elementId.indexOf("/") !== -1 ? elementId.replace("/", "//") : elementId;
    const existingHandle = this._nodes.has(element) ? this._nodes.get(element).item.handle : void 0;
    const childrenNodes = this._getChildrenNodes(parent) || [];
    let handle;
    let counter = 0;
    do {
      handle = `${prefix}/${counter}:${elementId}`;
      if (returnFirst || !this._elements.has(handle) || existingHandle === handle) {
        break;
      }
      counter++;
    } while (counter <= childrenNodes.length);
    return handle;
  }
  _getLightIconPath(extensionTreeItem) {
    if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof ThemeIcon2)) {
      if (typeof extensionTreeItem.iconPath === "string" || URI.isUri(extensionTreeItem.iconPath)) {
        return this._getIconPath(extensionTreeItem.iconPath);
      }
      return this._getIconPath(extensionTreeItem.iconPath.light);
    }
    return void 0;
  }
  _getDarkIconPath(extensionTreeItem) {
    if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof ThemeIcon2) && extensionTreeItem.iconPath.dark) {
      return this._getIconPath(extensionTreeItem.iconPath.dark);
    }
    return void 0;
  }
  _getIconPath(iconPath) {
    if (URI.isUri(iconPath)) {
      return iconPath;
    }
    return URI.file(iconPath);
  }
  _addNodeToCache(element, node) {
    this._elements.set(node.item.handle, element);
    this._nodes.set(element, node);
  }
  _updateNodeCache(element, newNode, existing, parentNode) {
    this._elements.delete(newNode.item.handle);
    this._nodes.delete(element);
    if (newNode.item.handle !== existing.item.handle) {
      this._elements.delete(existing.item.handle);
    }
    this._addNodeToCache(element, newNode);
    const childrenNodes = this._getChildrenNodes(parentNode) || [];
    const childNode = childrenNodes.filter((c) => c.item.handle === existing.item.handle)[0];
    if (childNode) {
      childrenNodes.splice(childrenNodes.indexOf(childNode), 1, newNode);
    }
  }
  _addNodeToParentCache(node, parentNode) {
    if (parentNode) {
      if (!parentNode.children) {
        parentNode.children = [];
      }
      parentNode.children.push(node);
    } else {
      if (!this._roots) {
        this._roots = [];
      }
      this._roots.push(node);
    }
  }
  _addChildrenToClear(parentElement) {
    if (parentElement) {
      const node = this._nodes.get(parentElement);
      if (node) {
        if (node.children) {
          for (const child of node.children) {
            this._nodesToClear.add(child);
            const childElement = this._elements.get(child.item.handle);
            if (childElement) {
              this._addChildrenToClear(childElement);
              this._nodes.delete(childElement);
              this._elements.delete(child.item.handle);
            }
          }
        }
        node.children = void 0;
      }
    } else {
      this._addAllToClear();
    }
  }
  _addAllToClear() {
    this._roots = void 0;
    this._nodes.forEach((node) => {
      this._nodesToClear.add(node);
    });
    this._nodes.clear();
    this._elements.clear();
  }
  _clearNodes(nodes) {
    dispose(nodes);
  }
  _clearAll() {
    this._roots = void 0;
    this._elements.clear();
    dispose(this._nodes.values());
    this._nodes.clear();
    dispose(this._nodesToClear);
    this._nodesToClear.clear();
  }
  dispose() {
    super.dispose();
    this._refreshCancellationSource.dispose();
    this._clearAll();
    this._proxy.$disposeTree(this._viewId);
  }
};

// out-build/vs/workbench/api/common/extHostUriOpener.js
var ExtHostUriOpeners = class _ExtHostUriOpeners {
  static {
    this.supportedSchemes = /* @__PURE__ */ new Set([Schemas.http, Schemas.https]);
  }
  constructor(mainContext) {
    this._openers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadUriOpeners);
  }
  registerExternalUriOpener(extensionId, id2, opener, metadata) {
    if (this._openers.has(id2)) {
      throw new Error(`Opener with id '${id2}' already registered`);
    }
    const invalidScheme = metadata.schemes.find((scheme) => !_ExtHostUriOpeners.supportedSchemes.has(scheme));
    if (invalidScheme) {
      throw new Error(`Scheme '${invalidScheme}' is not supported. Only http and https are currently supported.`);
    }
    this._openers.set(id2, opener);
    this._proxy.$registerUriOpener(id2, metadata.schemes, extensionId, metadata.label);
    return toDisposable(() => {
      this._openers.delete(id2);
      this._proxy.$unregisterUriOpener(id2);
    });
  }
  async $canOpenUri(id2, uriComponents, token) {
    const opener = this._openers.get(id2);
    if (!opener) {
      throw new Error(`Unknown opener with id: ${id2}`);
    }
    const uri = URI.revive(uriComponents);
    return opener.canOpenExternalUri(uri, token);
  }
  async $openUri(id2, context, token) {
    const opener = this._openers.get(id2);
    if (!opener) {
      throw new Error(`Unknown opener id: '${id2}'`);
    }
    return opener.openExternalUri(URI.revive(context.resolvedUri), {
      sourceUri: URI.revive(context.sourceUri)
    }, token);
  }
};

// out-build/vs/workbench/api/common/extHostWebviewPanels.js
var ExtHostWebviewPanel = class extends Disposable {
  #handle;
  #proxy;
  #viewType;
  #webview;
  #options;
  #title;
  #iconPath;
  #viewColumn;
  #visible;
  #active;
  #isDisposed;
  #onDidDispose;
  #onDidChangeViewState;
  constructor(handle, proxy, webview, params) {
    super();
    this.#viewColumn = void 0;
    this.#visible = true;
    this.#isDisposed = false;
    this.#onDidDispose = this._register(new Emitter());
    this.onDidDispose = this.#onDidDispose.event;
    this.#onDidChangeViewState = this._register(new Emitter());
    this.onDidChangeViewState = this.#onDidChangeViewState.event;
    this.#handle = handle;
    this.#proxy = proxy;
    this.#webview = webview;
    this.#viewType = params.viewType;
    this.#options = params.panelOptions;
    this.#viewColumn = params.viewColumn;
    this.#title = params.title;
    this.#active = params.active;
  }
  dispose() {
    if (this.#isDisposed) {
      return;
    }
    this.#isDisposed = true;
    this.#onDidDispose.fire();
    this.#proxy.$disposeWebview(this.#handle);
    this.#webview.dispose();
    super.dispose();
  }
  get webview() {
    this.assertNotDisposed();
    return this.#webview;
  }
  get viewType() {
    this.assertNotDisposed();
    return this.#viewType;
  }
  get title() {
    this.assertNotDisposed();
    return this.#title;
  }
  set title(value) {
    this.assertNotDisposed();
    if (this.#title !== value) {
      this.#title = value;
      this.#proxy.$setTitle(this.#handle, value);
    }
  }
  get iconPath() {
    this.assertNotDisposed();
    return this.#iconPath;
  }
  set iconPath(value) {
    this.assertNotDisposed();
    if (this.#iconPath !== value) {
      this.#iconPath = value;
      this.#proxy.$setIconPath(this.#handle, URI.isUri(value) ? { light: value, dark: value } : value);
    }
  }
  get options() {
    return this.#options;
  }
  get viewColumn() {
    this.assertNotDisposed();
    if (typeof this.#viewColumn === "number" && this.#viewColumn < 0) {
      return void 0;
    }
    return this.#viewColumn;
  }
  get active() {
    this.assertNotDisposed();
    return this.#active;
  }
  get visible() {
    this.assertNotDisposed();
    return this.#visible;
  }
  _updateViewState(newState) {
    if (this.#isDisposed) {
      return;
    }
    if (this.active !== newState.active || this.visible !== newState.visible || this.viewColumn !== newState.viewColumn) {
      this.#active = newState.active;
      this.#visible = newState.visible;
      this.#viewColumn = newState.viewColumn;
      this.#onDidChangeViewState.fire({ webviewPanel: this });
    }
  }
  reveal(viewColumn, preserveFocus) {
    this.assertNotDisposed();
    this.#proxy.$reveal(this.#handle, {
      viewColumn: typeof viewColumn === "undefined" ? void 0 : ViewColumn2.from(viewColumn),
      preserveFocus: !!preserveFocus
    });
  }
  assertNotDisposed() {
    if (this.#isDisposed) {
      throw new Error("Webview is disposed");
    }
  }
};
var ExtHostWebviewPanels = class _ExtHostWebviewPanels extends Disposable {
  static newHandle() {
    return generateUuid();
  }
  constructor(mainContext, webviews, workspace) {
    super();
    this.webviews = webviews;
    this.workspace = workspace;
    this._webviewPanels = /* @__PURE__ */ new Map();
    this._serializers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadWebviewPanels);
  }
  dispose() {
    super.dispose();
    this._webviewPanels.forEach((value) => value.dispose());
    this._webviewPanels.clear();
  }
  createWebviewPanel(extension, viewType, title, showOptions, options2 = {}) {
    const viewColumn = typeof showOptions === "object" ? showOptions.viewColumn : showOptions;
    const webviewShowOptions = {
      viewColumn: ViewColumn2.from(viewColumn),
      preserveFocus: typeof showOptions === "object" && !!showOptions.preserveFocus
    };
    const serializeBuffersForPostMessage = shouldSerializeBuffersForPostMessage(extension);
    const handle = _ExtHostWebviewPanels.newHandle();
    this._proxy.$createWebviewPanel(toExtensionData(extension), handle, viewType, {
      title,
      panelOptions: serializeWebviewPanelOptions(options2),
      webviewOptions: serializeWebviewOptions(extension, this.workspace, options2),
      serializeBuffersForPostMessage
    }, webviewShowOptions);
    const webview = this.webviews.createNewWebview(handle, options2, extension);
    const panel = this.createNewWebviewPanel(handle, viewType, title, viewColumn, options2, webview, true);
    return panel;
  }
  $onDidChangeWebviewPanelViewStates(newStates) {
    const handles = Object.keys(newStates);
    handles.sort((a, b) => {
      const stateA = newStates[a];
      const stateB = newStates[b];
      if (stateA.active) {
        return 1;
      }
      if (stateB.active) {
        return -1;
      }
      return +stateA.visible - +stateB.visible;
    });
    for (const handle of handles) {
      const panel = this.getWebviewPanel(handle);
      if (!panel) {
        continue;
      }
      const newState = newStates[handle];
      panel._updateViewState({
        active: newState.active,
        visible: newState.visible,
        viewColumn: ViewColumn2.to(newState.position)
      });
    }
  }
  async $onDidDisposeWebviewPanel(handle) {
    const panel = this.getWebviewPanel(handle);
    panel?.dispose();
    this._webviewPanels.delete(handle);
    this.webviews.deleteWebview(handle);
  }
  registerWebviewPanelSerializer(extension, viewType, serializer) {
    if (this._serializers.has(viewType)) {
      throw new Error(`Serializer for '${viewType}' already registered`);
    }
    this._serializers.set(viewType, { serializer, extension });
    this._proxy.$registerSerializer(viewType, {
      serializeBuffersForPostMessage: shouldSerializeBuffersForPostMessage(extension)
    });
    return new Disposable2(() => {
      this._serializers.delete(viewType);
      this._proxy.$unregisterSerializer(viewType);
    });
  }
  async $deserializeWebviewPanel(webviewHandle, viewType, initData, position) {
    const entry = this._serializers.get(viewType);
    if (!entry) {
      throw new Error(`No serializer found for '${viewType}'`);
    }
    const { serializer, extension } = entry;
    const webview = this.webviews.createNewWebview(webviewHandle, initData.webviewOptions, extension);
    const revivedPanel = this.createNewWebviewPanel(webviewHandle, viewType, initData.title, position, initData.panelOptions, webview, initData.active);
    await serializer.deserializeWebviewPanel(revivedPanel, initData.state);
  }
  createNewWebviewPanel(webviewHandle, viewType, title, position, options2, webview, active) {
    const panel = new ExtHostWebviewPanel(webviewHandle, this._proxy, webview, { viewType, title, viewColumn: position, panelOptions: options2, active });
    this._webviewPanels.set(webviewHandle, panel);
    return panel;
  }
  getWebviewPanel(handle) {
    return this._webviewPanels.get(handle);
  }
};
function serializeWebviewPanelOptions(options2) {
  return {
    enableFindWidget: options2.enableFindWidget,
    retainContextWhenHidden: options2.retainContextWhenHidden
  };
}

// out-build/vs/workbench/api/common/extHostWebviewView.js
var ExtHostWebviewView = class extends Disposable {
  #handle;
  #proxy;
  #viewType;
  #webview;
  #isDisposed;
  #isVisible;
  #title;
  #description;
  #badge;
  constructor(handle, proxy, viewType, title, webview, isVisible) {
    super();
    this.#isDisposed = false;
    this.#onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this.#onDidChangeVisibility.event;
    this.#onDidDispose = this._register(new Emitter());
    this.onDidDispose = this.#onDidDispose.event;
    this.#viewType = viewType;
    this.#title = title;
    this.#handle = handle;
    this.#proxy = proxy;
    this.#webview = webview;
    this.#isVisible = isVisible;
  }
  dispose() {
    if (this.#isDisposed) {
      return;
    }
    this.#isDisposed = true;
    this.#onDidDispose.fire();
    this.#webview.dispose();
    super.dispose();
  }
  #onDidChangeVisibility;
  #onDidDispose;
  get title() {
    this.assertNotDisposed();
    return this.#title;
  }
  set title(value) {
    this.assertNotDisposed();
    if (this.#title !== value) {
      this.#title = value;
      this.#proxy.$setWebviewViewTitle(this.#handle, value);
    }
  }
  get description() {
    this.assertNotDisposed();
    return this.#description;
  }
  set description(value) {
    this.assertNotDisposed();
    if (this.#description !== value) {
      this.#description = value;
      this.#proxy.$setWebviewViewDescription(this.#handle, value);
    }
  }
  get visible() {
    return this.#isVisible;
  }
  get webview() {
    return this.#webview;
  }
  get viewType() {
    return this.#viewType;
  }
  /* internal */
  _setVisible(visible) {
    if (visible === this.#isVisible || this.#isDisposed) {
      return;
    }
    this.#isVisible = visible;
    this.#onDidChangeVisibility.fire();
  }
  get badge() {
    this.assertNotDisposed();
    return this.#badge;
  }
  set badge(badge) {
    this.assertNotDisposed();
    if (badge?.value === this.#badge?.value && badge?.tooltip === this.#badge?.tooltip) {
      return;
    }
    this.#badge = ViewBadge2.from(badge);
    this.#proxy.$setWebviewViewBadge(this.#handle, badge);
  }
  show(preserveFocus) {
    this.assertNotDisposed();
    this.#proxy.$show(this.#handle, !!preserveFocus);
  }
  assertNotDisposed() {
    if (this.#isDisposed) {
      throw new Error("Webview is disposed");
    }
  }
};
var ExtHostWebviewViews = class {
  constructor(mainContext, _extHostWebview) {
    this._extHostWebview = _extHostWebview;
    this._viewProviders = /* @__PURE__ */ new Map();
    this._webviewViews = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadWebviewViews);
  }
  registerWebviewViewProvider(extension, viewType, provider, webviewOptions) {
    if (this._viewProviders.has(viewType)) {
      throw new Error(`View provider for '${viewType}' already registered`);
    }
    this._viewProviders.set(viewType, { provider, extension });
    this._proxy.$registerWebviewViewProvider(toExtensionData(extension), viewType, {
      retainContextWhenHidden: webviewOptions?.retainContextWhenHidden,
      serializeBuffersForPostMessage: shouldSerializeBuffersForPostMessage(extension)
    });
    return new Disposable2(() => {
      this._viewProviders.delete(viewType);
      this._proxy.$unregisterWebviewViewProvider(viewType);
    });
  }
  async $resolveWebviewView(webviewHandle, viewType, title, state, cancellation) {
    const entry = this._viewProviders.get(viewType);
    if (!entry) {
      throw new Error(`No view provider found for '${viewType}'`);
    }
    const { provider, extension } = entry;
    const webview = this._extHostWebview.createNewWebview(webviewHandle, {
      /* todo */
    }, extension);
    const revivedView = new ExtHostWebviewView(webviewHandle, this._proxy, viewType, title, webview, true);
    this._webviewViews.set(webviewHandle, revivedView);
    await provider.resolveWebviewView(revivedView, { state }, cancellation);
  }
  async $onDidChangeWebviewViewVisibility(webviewHandle, visible) {
    const webviewView = this.getWebviewView(webviewHandle);
    webviewView._setVisible(visible);
  }
  async $disposeWebviewView(webviewHandle) {
    const webviewView = this.getWebviewView(webviewHandle);
    this._webviewViews.delete(webviewHandle);
    webviewView.dispose();
    this._extHostWebview.deleteWebview(webviewHandle);
  }
  getWebviewView(handle) {
    const entry = this._webviewViews.get(handle);
    if (!entry) {
      throw new Error("No webview found");
    }
    return entry;
  }
};

// out-build/vs/workbench/api/common/extHostChatContext.js
var ExtHostChatContext = class ExtHostChatContext2 extends Disposable {
  constructor(extHostRpc) {
    super();
    this._handlePool = 0;
    this._providers = /* @__PURE__ */ new Map();
    this._itemPool = 0;
    this._items = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadChatContext);
  }
  async $provideChatContext(handle, token) {
    this._items.delete(handle);
    const provider = this._getProvider(handle);
    if (!provider.provideChatContextExplicit) {
      throw new Error("provideChatContext not implemented");
    }
    const result = await provider.provideChatContextExplicit(token) ?? [];
    const items = [];
    for (const item of result) {
      const itemHandle = this._addTrackedItem(handle, item);
      items.push({
        handle: itemHandle,
        icon: item.icon,
        label: item.label,
        modelDescription: item.modelDescription,
        value: item.value
      });
    }
    return items;
  }
  _addTrackedItem(handle, item) {
    const itemHandle = this._itemPool++;
    if (!this._items.has(handle)) {
      this._items.set(handle, /* @__PURE__ */ new Map());
    }
    this._items.get(handle).set(itemHandle, item);
    return itemHandle;
  }
  async $provideChatContextForResource(handle, options2, token) {
    const provider = this._getProvider(handle);
    if (!provider.provideChatContextForResource) {
      throw new Error("provideChatContextForResource not implemented");
    }
    const result = await provider.provideChatContextForResource({ resource: URI.revive(options2.resource) }, token);
    if (!result) {
      return void 0;
    }
    const itemHandle = this._addTrackedItem(handle, result);
    const item = {
      handle: itemHandle,
      icon: result.icon,
      label: result.label,
      modelDescription: result.modelDescription,
      value: options2.withValue ? result.value : void 0
    };
    if (options2.withValue && !item.value && provider.resolveChatContext) {
      const resolved = await provider.resolveChatContext(result, token);
      item.value = resolved?.value;
    }
    return item;
  }
  async _doResolve(provider, context, extItem, token) {
    const extResult = await provider.resolveChatContext(extItem, token);
    const result = extResult ?? context;
    return {
      handle: context.handle,
      icon: result.icon,
      label: result.label,
      modelDescription: result.modelDescription,
      value: result.value
    };
  }
  async $resolveChatContext(handle, context, token) {
    const provider = this._getProvider(handle);
    if (!provider.resolveChatContext) {
      throw new Error("resolveChatContext not implemented");
    }
    const extItem = this._items.get(handle)?.get(context.handle);
    if (!extItem) {
      throw new Error("Chat context item not found");
    }
    return this._doResolve(provider, context, extItem, token);
  }
  registerChatContextProvider(selector, id2, provider) {
    const handle = this._handlePool++;
    const disposables = new DisposableStore();
    this._listenForWorkspaceContextChanges(handle, provider, disposables);
    this._providers.set(handle, { provider, disposables });
    this._proxy.$registerChatContextProvider(handle, `${id2}`, selector ? DocumentSelector.from(selector) : void 0, {}, { supportsResource: !!provider.provideChatContextForResource, supportsResolve: !!provider.resolveChatContext });
    return {
      dispose: () => {
        this._providers.delete(handle);
        this._proxy.$unregisterChatContextProvider(handle);
        disposables.dispose();
      }
    };
  }
  _listenForWorkspaceContextChanges(handle, provider, disposables) {
    if (!provider.onDidChangeWorkspaceChatContext || !provider.provideWorkspaceChatContext) {
      return;
    }
    disposables.add(provider.onDidChangeWorkspaceChatContext(async () => {
      const workspaceContexts = await provider.provideWorkspaceChatContext(CancellationToken.None);
      const resolvedContexts = [];
      for (const item of workspaceContexts ?? []) {
        const contextItem = {
          icon: item.icon,
          label: item.label,
          modelDescription: item.modelDescription,
          value: item.value,
          handle: this._itemPool++
        };
        const resolved = await this._doResolve(provider, contextItem, item, CancellationToken.None);
        resolvedContexts.push(resolved);
      }
      this._proxy.$updateWorkspaceContextItems(handle, resolvedContexts);
    }));
  }
  _getProvider(handle) {
    if (!this._providers.has(handle)) {
      throw new Error("Chat context provider not found");
    }
    return this._providers.get(handle).provider;
  }
  dispose() {
    super.dispose();
    for (const { disposables } of this._providers.values()) {
      disposables.dispose();
    }
  }
};
ExtHostChatContext = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostChatContext);

// out-build/vs/workbench/api/common/extHost.api.impl.js
function createApiFactoryAndRegisterActors(accessor) {
  const initData = accessor.get(IExtHostInitDataService);
  const extHostFileSystemInfo = accessor.get(IExtHostFileSystemInfo);
  const extHostConsumerFileSystem = accessor.get(IExtHostConsumerFileSystem);
  const extensionService = accessor.get(IExtHostExtensionService);
  const extHostWorkspace = accessor.get(IExtHostWorkspace);
  const extHostTelemetry = accessor.get(IExtHostTelemetry);
  const extHostConfiguration = accessor.get(IExtHostConfiguration);
  const uriTransformer = accessor.get(IURITransformerService);
  const rpcProtocol = accessor.get(IExtHostRpcService);
  const extHostStorage = accessor.get(IExtHostStorage);
  const extensionStoragePaths = accessor.get(IExtensionStoragePaths);
  const extHostLoggerService = accessor.get(ILoggerService);
  const extHostLogService = accessor.get(ILogService);
  const extHostTunnelService = accessor.get(IExtHostTunnelService);
  const extHostApiDeprecation = accessor.get(IExtHostApiDeprecationService);
  const extHostWindow = accessor.get(IExtHostWindow);
  const extHostUrls = accessor.get(IExtHostUrlsService);
  const extHostSecretState = accessor.get(IExtHostSecretState);
  const extHostEditorTabs = accessor.get(IExtHostEditorTabs);
  const extHostManagedSockets = accessor.get(IExtHostManagedSockets);
  const extHostProgress = accessor.get(IExtHostProgress);
  const extHostAuthentication = accessor.get(IExtHostAuthentication);
  const extHostLanguageModels = accessor.get(IExtHostLanguageModels);
  const extHostMcp = accessor.get(IExtHostMpcService);
  const extHostDataChannels = accessor.get(IExtHostDataChannels);
  rpcProtocol.set(ExtHostContext.ExtHostFileSystemInfo, extHostFileSystemInfo);
  rpcProtocol.set(ExtHostContext.ExtHostLogLevelServiceShape, extHostLoggerService);
  rpcProtocol.set(ExtHostContext.ExtHostWorkspace, extHostWorkspace);
  rpcProtocol.set(ExtHostContext.ExtHostConfiguration, extHostConfiguration);
  rpcProtocol.set(ExtHostContext.ExtHostExtensionService, extensionService);
  rpcProtocol.set(ExtHostContext.ExtHostStorage, extHostStorage);
  rpcProtocol.set(ExtHostContext.ExtHostTunnelService, extHostTunnelService);
  rpcProtocol.set(ExtHostContext.ExtHostWindow, extHostWindow);
  rpcProtocol.set(ExtHostContext.ExtHostUrls, extHostUrls);
  rpcProtocol.set(ExtHostContext.ExtHostSecretState, extHostSecretState);
  rpcProtocol.set(ExtHostContext.ExtHostTelemetry, extHostTelemetry);
  rpcProtocol.set(ExtHostContext.ExtHostEditorTabs, extHostEditorTabs);
  rpcProtocol.set(ExtHostContext.ExtHostManagedSockets, extHostManagedSockets);
  rpcProtocol.set(ExtHostContext.ExtHostProgress, extHostProgress);
  rpcProtocol.set(ExtHostContext.ExtHostAuthentication, extHostAuthentication);
  rpcProtocol.set(ExtHostContext.ExtHostChatProvider, extHostLanguageModels);
  rpcProtocol.set(ExtHostContext.ExtHostDataChannels, extHostDataChannels);
  const extHostDecorations = rpcProtocol.set(ExtHostContext.ExtHostDecorations, accessor.get(IExtHostDecorations));
  const extHostDocumentsAndEditors = rpcProtocol.set(ExtHostContext.ExtHostDocumentsAndEditors, accessor.get(IExtHostDocumentsAndEditors));
  const extHostCommands = rpcProtocol.set(ExtHostContext.ExtHostCommands, accessor.get(IExtHostCommands));
  const extHostTerminalService = rpcProtocol.set(ExtHostContext.ExtHostTerminalService, accessor.get(IExtHostTerminalService));
  const extHostTerminalShellIntegration = rpcProtocol.set(ExtHostContext.ExtHostTerminalShellIntegration, accessor.get(IExtHostTerminalShellIntegration));
  const extHostDebugService = rpcProtocol.set(ExtHostContext.ExtHostDebugService, accessor.get(IExtHostDebugService));
  const extHostSearch = rpcProtocol.set(ExtHostContext.ExtHostSearch, accessor.get(IExtHostSearch));
  const extHostTask = rpcProtocol.set(ExtHostContext.ExtHostTask, accessor.get(IExtHostTask));
  const extHostOutputService = rpcProtocol.set(ExtHostContext.ExtHostOutputService, accessor.get(IExtHostOutputService));
  const extHostLocalization = rpcProtocol.set(ExtHostContext.ExtHostLocalization, accessor.get(IExtHostLocalizationService));
  const extHostDocuments = rpcProtocol.set(ExtHostContext.ExtHostDocuments, new ExtHostDocuments(rpcProtocol, extHostDocumentsAndEditors));
  const extHostDocumentContentProviders = rpcProtocol.set(ExtHostContext.ExtHostDocumentContentProviders, new ExtHostDocumentContentProvider(rpcProtocol, extHostDocumentsAndEditors, extHostLogService));
  const extHostDocumentSaveParticipant = rpcProtocol.set(ExtHostContext.ExtHostDocumentSaveParticipant, new ExtHostDocumentSaveParticipant(extHostLogService, extHostDocuments, rpcProtocol.getProxy(MainContext.MainThreadBulkEdits)));
  const extHostNotebook = rpcProtocol.set(ExtHostContext.ExtHostNotebook, new ExtHostNotebookController(rpcProtocol, extHostCommands, extHostDocumentsAndEditors, extHostDocuments, extHostConsumerFileSystem, extHostSearch, extHostLogService));
  const extHostNotebookDocuments = rpcProtocol.set(ExtHostContext.ExtHostNotebookDocuments, new ExtHostNotebookDocuments(extHostNotebook));
  const extHostNotebookEditors = rpcProtocol.set(ExtHostContext.ExtHostNotebookEditors, new ExtHostNotebookEditors(extHostLogService, extHostNotebook));
  const extHostNotebookKernels = rpcProtocol.set(ExtHostContext.ExtHostNotebookKernels, new ExtHostNotebookKernels(rpcProtocol, initData, extHostNotebook, extHostCommands, extHostLogService));
  const extHostNotebookRenderers = rpcProtocol.set(ExtHostContext.ExtHostNotebookRenderers, new ExtHostNotebookRenderers(rpcProtocol, extHostNotebook));
  const extHostNotebookDocumentSaveParticipant = rpcProtocol.set(ExtHostContext.ExtHostNotebookDocumentSaveParticipant, new ExtHostNotebookDocumentSaveParticipant(extHostLogService, extHostNotebook, rpcProtocol.getProxy(MainContext.MainThreadBulkEdits)));
  const extHostEditors = rpcProtocol.set(ExtHostContext.ExtHostEditors, new ExtHostEditors(rpcProtocol, extHostDocumentsAndEditors));
  const extHostTreeViews = rpcProtocol.set(ExtHostContext.ExtHostTreeViews, new ExtHostTreeViews(rpcProtocol.getProxy(MainContext.MainThreadTreeViews), extHostCommands, extHostLogService));
  const extHostEditorInsets = rpcProtocol.set(ExtHostContext.ExtHostEditorInsets, new ExtHostEditorInsets(rpcProtocol.getProxy(MainContext.MainThreadEditorInsets), extHostEditors, initData.remote));
  const extHostDiagnostics = rpcProtocol.set(ExtHostContext.ExtHostDiagnostics, new ExtHostDiagnostics(rpcProtocol, extHostLogService, extHostFileSystemInfo, extHostDocumentsAndEditors));
  const extHostLanguages = rpcProtocol.set(ExtHostContext.ExtHostLanguages, new ExtHostLanguages(rpcProtocol, extHostDocuments, extHostCommands.converter, uriTransformer));
  const extHostLanguageFeatures = rpcProtocol.set(ExtHostContext.ExtHostLanguageFeatures, new ExtHostLanguageFeatures(rpcProtocol, uriTransformer, extHostDocuments, extHostCommands, extHostDiagnostics, extHostLogService, extHostApiDeprecation, extHostTelemetry));
  const extHostCodeMapper = rpcProtocol.set(ExtHostContext.ExtHostCodeMapper, new ExtHostCodeMapper(rpcProtocol));
  const extHostFileSystem = rpcProtocol.set(ExtHostContext.ExtHostFileSystem, new ExtHostFileSystem(rpcProtocol, extHostLanguageFeatures));
  const extHostFileSystemEvent = rpcProtocol.set(ExtHostContext.ExtHostFileSystemEventService, new ExtHostFileSystemEventService(rpcProtocol, extHostLogService, extHostDocumentsAndEditors));
  const extHostQuickOpen = rpcProtocol.set(ExtHostContext.ExtHostQuickOpen, createExtHostQuickOpen(rpcProtocol, extHostWorkspace, extHostCommands));
  const extHostSCM = rpcProtocol.set(ExtHostContext.ExtHostSCM, new ExtHostSCM(rpcProtocol, extHostCommands, extHostDocuments, extHostLogService));
  const extHostQuickDiff = rpcProtocol.set(ExtHostContext.ExtHostQuickDiff, new ExtHostQuickDiff(rpcProtocol, uriTransformer));
  const extHostShare = rpcProtocol.set(ExtHostContext.ExtHostShare, new ExtHostShare(rpcProtocol, uriTransformer));
  const extHostComment = rpcProtocol.set(ExtHostContext.ExtHostComments, createExtHostComments(rpcProtocol, extHostCommands, extHostDocuments));
  const extHostLabelService = rpcProtocol.set(ExtHostContext.ExtHostLabelService, new ExtHostLabelService(rpcProtocol));
  const extHostTheming = rpcProtocol.set(ExtHostContext.ExtHostTheming, new ExtHostTheming(rpcProtocol));
  const extHostTimeline = rpcProtocol.set(ExtHostContext.ExtHostTimeline, new ExtHostTimeline(rpcProtocol, extHostCommands));
  const extHostWebviews = rpcProtocol.set(ExtHostContext.ExtHostWebviews, new ExtHostWebviews(rpcProtocol, initData.remote, extHostWorkspace, extHostLogService, extHostApiDeprecation));
  const extHostWebviewPanels = rpcProtocol.set(ExtHostContext.ExtHostWebviewPanels, new ExtHostWebviewPanels(rpcProtocol, extHostWebviews, extHostWorkspace));
  const extHostCustomEditors = rpcProtocol.set(ExtHostContext.ExtHostCustomEditors, new ExtHostCustomEditors(rpcProtocol, extHostDocuments, extensionStoragePaths, extHostWebviews, extHostWebviewPanels));
  const extHostWebviewViews = rpcProtocol.set(ExtHostContext.ExtHostWebviewViews, new ExtHostWebviewViews(rpcProtocol, extHostWebviews));
  const extHostTesting = rpcProtocol.set(ExtHostContext.ExtHostTesting, accessor.get(IExtHostTesting));
  const extHostUriOpeners = rpcProtocol.set(ExtHostContext.ExtHostUriOpeners, new ExtHostUriOpeners(rpcProtocol));
  const extHostProfileContentHandlers = rpcProtocol.set(ExtHostContext.ExtHostProfileContentHandlers, new ExtHostProfileContentHandlers(rpcProtocol));
  const extHostChatOutputRenderer = rpcProtocol.set(ExtHostContext.ExtHostChatOutputRenderer, new ExtHostChatOutputRenderer(rpcProtocol, extHostWebviews));
  rpcProtocol.set(ExtHostContext.ExtHostInteractive, new ExtHostInteractive(rpcProtocol, extHostNotebook, extHostDocumentsAndEditors, extHostCommands, extHostLogService));
  const extHostLanguageModelTools = rpcProtocol.set(ExtHostContext.ExtHostLanguageModelTools, new ExtHostLanguageModelTools(rpcProtocol, extHostLanguageModels));
  const extHostChatSessions = rpcProtocol.set(ExtHostContext.ExtHostChatSessions, new ExtHostChatSessions(extHostCommands, extHostLanguageModels, rpcProtocol, extHostLogService));
  const extHostChatAgents2 = rpcProtocol.set(ExtHostContext.ExtHostChatAgents2, new ExtHostChatAgents2(rpcProtocol, extHostLogService, extHostCommands, extHostDocuments, extHostLanguageModels, extHostDiagnostics, extHostLanguageModelTools));
  const extHostChatContext = rpcProtocol.set(ExtHostContext.ExtHostChatContext, new ExtHostChatContext(rpcProtocol));
  const extHostAiRelatedInformation = rpcProtocol.set(ExtHostContext.ExtHostAiRelatedInformation, new ExtHostRelatedInformation(rpcProtocol));
  const extHostAiEmbeddingVector = rpcProtocol.set(ExtHostContext.ExtHostAiEmbeddingVector, new ExtHostAiEmbeddingVector(rpcProtocol));
  const extHostAiSettingsSearch = rpcProtocol.set(ExtHostContext.ExtHostAiSettingsSearch, new ExtHostAiSettingsSearch(rpcProtocol));
  const extHostStatusBar = rpcProtocol.set(ExtHostContext.ExtHostStatusBar, new ExtHostStatusBar(rpcProtocol, extHostCommands.converter));
  const extHostSpeech = rpcProtocol.set(ExtHostContext.ExtHostSpeech, new ExtHostSpeech(rpcProtocol));
  const extHostEmbeddings = rpcProtocol.set(ExtHostContext.ExtHostEmbeddings, new ExtHostEmbeddings(rpcProtocol));
  rpcProtocol.set(ExtHostContext.ExtHostMcp, accessor.get(IExtHostMpcService));
  const expected = Object.values(ExtHostContext);
  rpcProtocol.assertRegistered(expected);
  const extHostBulkEdits = new ExtHostBulkEdits(rpcProtocol, extHostDocumentsAndEditors);
  const extHostClipboard = new ExtHostClipboard(rpcProtocol);
  const extHostMessageService = new ExtHostMessageService(rpcProtocol, extHostLogService);
  const extHostDialogs = new ExtHostDialogs(rpcProtocol);
  const extHostChatStatus = new ExtHostChatStatus(rpcProtocol);
  ExtHostApiCommands.register(extHostCommands);
  return function(extension, extensionInfo, configProvider) {
    function _asExtensionEvent(actual) {
      return (listener, thisArgs, disposables) => {
        const handle = actual((e) => {
          try {
            listener.call(thisArgs, e);
          } catch (err) {
            onUnexpectedExternalError(new ExtensionError(extension.identifier, err, "FAILED to handle event"));
          }
        });
        disposables?.push(handle);
        return handle;
      };
    }
    const checkSelector = function() {
      let done = !extension.isUnderDevelopment;
      function informOnce() {
        if (!done) {
          extHostLogService.info(`Extension '${extension.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`);
          done = true;
        }
      }
      return function perform(selector) {
        if (Array.isArray(selector)) {
          selector.forEach(perform);
        } else if (typeof selector === "string") {
          informOnce();
        } else {
          const filter2 = selector;
          if (typeof filter2.scheme === "undefined") {
            informOnce();
          }
          if (typeof filter2.exclusive === "boolean") {
            checkProposedApiEnabled(extension, "documentFiltersExclusive");
          }
        }
        return selector;
      };
    }();
    const authentication = {
      getSession(providerId, scopesOrChallenge, options2) {
        if (typeof options2?.forceNewSession === "object" && options2.forceNewSession.learnMore || typeof options2?.createIfNone === "object" && options2.createIfNone.learnMore) {
          checkProposedApiEnabled(extension, "authLearnMore");
        }
        if (options2?.authorizationServer) {
          checkProposedApiEnabled(extension, "authIssuers");
        }
        return extHostAuthentication.getSession(extension, providerId, scopesOrChallenge, options2);
      },
      getAccounts(providerId) {
        return extHostAuthentication.getAccounts(providerId);
      },
      // TODO: remove this after GHPR and Codespaces move off of it
      async hasSession(providerId, scopes) {
        checkProposedApiEnabled(extension, "authSession");
        return !!await extHostAuthentication.getSession(extension, providerId, scopes, { silent: true });
      },
      get onDidChangeSessions() {
        return _asExtensionEvent(extHostAuthentication.getExtensionScopedSessionsEvent(extension.identifier.value));
      },
      registerAuthenticationProvider(id2, label, provider, options2) {
        if (options2?.supportedAuthorizationServers) {
          checkProposedApiEnabled(extension, "authIssuers");
        }
        return extHostAuthentication.registerAuthenticationProvider(id2, label, provider, options2);
      }
    };
    const commands = {
      registerCommand(id2, command, thisArgs) {
        return extHostCommands.registerCommand(true, id2, command, thisArgs, void 0, extension);
      },
      registerTextEditorCommand(id2, callback, thisArg) {
        return extHostCommands.registerCommand(true, id2, (...args) => {
          const activeTextEditor = extHostEditors.getActiveTextEditor();
          if (!activeTextEditor) {
            extHostLogService.warn("Cannot execute " + id2 + " because there is no active text editor.");
            return void 0;
          }
          return activeTextEditor.edit((edit2) => {
            callback.apply(thisArg, [activeTextEditor, edit2, ...args]);
          }).then((result) => {
            if (!result) {
              extHostLogService.warn("Edits from command " + id2 + " were not applied.");
            }
          }, (err) => {
            extHostLogService.warn("An error occurred while running command " + id2, err);
          });
        }, void 0, void 0, extension);
      },
      registerDiffInformationCommand: (id2, callback, thisArg) => {
        checkProposedApiEnabled(extension, "diffCommand");
        return extHostCommands.registerCommand(true, id2, async (...args) => {
          const activeTextEditor = extHostDocumentsAndEditors.activeEditor(true);
          if (!activeTextEditor) {
            extHostLogService.warn("Cannot execute " + id2 + " because there is no active text editor.");
            return void 0;
          }
          const diff2 = await extHostEditors.getDiffInformation(activeTextEditor.id);
          callback.apply(thisArg, [diff2, ...args]);
        }, void 0, void 0, extension);
      },
      executeCommand(id2, ...args) {
        return extHostCommands.executeCommand(id2, ...args);
      },
      getCommands(filterInternal = false) {
        return extHostCommands.getCommands(filterInternal);
      }
    };
    const env2 = {
      get machineId() {
        return initData.telemetryInfo.machineId;
      },
      get devDeviceId() {
        checkProposedApiEnabled(extension, "devDeviceId");
        return initData.telemetryInfo.devDeviceId ?? initData.telemetryInfo.machineId;
      },
      get sessionId() {
        return initData.telemetryInfo.sessionId;
      },
      get language() {
        return initData.environment.appLanguage;
      },
      get appName() {
        return initData.environment.appName;
      },
      get appRoot() {
        return initData.environment.appRoot?.fsPath ?? "";
      },
      get appHost() {
        return initData.environment.appHost;
      },
      get uriScheme() {
        return initData.environment.appUriScheme;
      },
      get clipboard() {
        return extHostClipboard.value;
      },
      get shell() {
        return extHostTerminalService.getDefaultShell(false);
      },
      get onDidChangeShell() {
        return _asExtensionEvent(extHostTerminalService.onDidChangeShell);
      },
      get isTelemetryEnabled() {
        return extHostTelemetry.getTelemetryConfiguration();
      },
      get onDidChangeTelemetryEnabled() {
        return _asExtensionEvent(extHostTelemetry.onDidChangeTelemetryEnabled);
      },
      get telemetryConfiguration() {
        checkProposedApiEnabled(extension, "telemetry");
        return extHostTelemetry.getTelemetryDetails();
      },
      get onDidChangeTelemetryConfiguration() {
        checkProposedApiEnabled(extension, "telemetry");
        return _asExtensionEvent(extHostTelemetry.onDidChangeTelemetryConfiguration);
      },
      get isNewAppInstall() {
        return isNewAppInstall(initData.telemetryInfo.firstSessionDate);
      },
      createTelemetryLogger(sender, options2) {
        ExtHostTelemetryLogger.validateSender(sender);
        return extHostTelemetry.instantiateLogger(extension, sender, options2);
      },
      async openExternal(uri, options2) {
        return extHostWindow.openUri(uri, {
          allowTunneling: initData.remote.isRemote ?? (initData.remote.authority ? await extHostTunnelService.hasTunnelProvider() : false),
          allowContributedOpeners: options2?.allowContributedOpeners
        });
      },
      async asExternalUri(uri) {
        if (uri.scheme === initData.environment.appUriScheme) {
          return extHostUrls.createAppUri(uri);
        }
        try {
          return await extHostWindow.asExternalUri(uri, { allowTunneling: !!initData.remote.authority });
        } catch (err) {
          if (matchesScheme(uri, Schemas.http) || matchesScheme(uri, Schemas.https)) {
            return uri;
          }
          throw err;
        }
      },
      get remoteName() {
        return getRemoteName(initData.remote.authority);
      },
      get remoteAuthority() {
        checkProposedApiEnabled(extension, "resolvers");
        return initData.remote.authority;
      },
      get uiKind() {
        return initData.uiKind;
      },
      get logLevel() {
        return extHostLogService.getLevel();
      },
      get onDidChangeLogLevel() {
        return _asExtensionEvent(extHostLogService.onDidChangeLogLevel);
      },
      get appQuality() {
        checkProposedApiEnabled(extension, "resolvers");
        return initData.quality;
      },
      get appCommit() {
        checkProposedApiEnabled(extension, "resolvers");
        return initData.commit;
      },
      getDataChannel(channelId) {
        checkProposedApiEnabled(extension, "dataChannels");
        return extHostDataChannels.createDataChannel(extension, channelId);
      }
    };
    if (!initData.environment.extensionTestsLocationURI) {
      Object.freeze(env2);
    }
    const tests = {
      createTestController(provider, label, refreshHandler) {
        return extHostTesting.createTestController(extension, provider, label, refreshHandler);
      },
      createTestObserver() {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.createTestObserver();
      },
      runTests(provider) {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.runTests(provider);
      },
      registerTestFollowupProvider(provider) {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.registerTestFollowupProvider(provider);
      },
      get onDidChangeTestResults() {
        checkProposedApiEnabled(extension, "testObserver");
        return _asExtensionEvent(extHostTesting.onResultsChanged);
      },
      get testResults() {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.results;
      }
    };
    const extensionKind = initData.remote.isRemote ? ExtensionKind.Workspace : ExtensionKind.UI;
    const extensions = {
      getExtension(extensionId, includeFromDifferentExtensionHosts) {
        if (!isProposedApiEnabled(extension, "extensionsAny")) {
          includeFromDifferentExtensionHosts = false;
        }
        const mine = extensionInfo.mine.getExtensionDescription(extensionId);
        if (mine) {
          return new Extension(extensionService, extension.identifier, mine, extensionKind, false);
        }
        if (includeFromDifferentExtensionHosts) {
          const foreign = extensionInfo.all.getExtensionDescription(extensionId);
          if (foreign) {
            return new Extension(extensionService, extension.identifier, foreign, extensionKind, true);
          }
        }
        return void 0;
      },
      get all() {
        const result = [];
        for (const desc of extensionInfo.mine.getAllExtensionDescriptions()) {
          result.push(new Extension(extensionService, extension.identifier, desc, extensionKind, false));
        }
        return result;
      },
      get allAcrossExtensionHosts() {
        checkProposedApiEnabled(extension, "extensionsAny");
        const local = new ExtensionIdentifierSet(extensionInfo.mine.getAllExtensionDescriptions().map((desc) => desc.identifier));
        const result = [];
        for (const desc of extensionInfo.all.getAllExtensionDescriptions()) {
          const isFromDifferentExtensionHost = !local.has(desc.identifier);
          result.push(new Extension(extensionService, extension.identifier, desc, extensionKind, isFromDifferentExtensionHost));
        }
        return result;
      },
      get onDidChange() {
        if (isProposedApiEnabled(extension, "extensionsAny")) {
          return _asExtensionEvent(Event.any(extensionInfo.mine.onDidChange, extensionInfo.all.onDidChange));
        }
        return _asExtensionEvent(extensionInfo.mine.onDidChange);
      }
    };
    const languages = {
      createDiagnosticCollection(name2) {
        return extHostDiagnostics.createDiagnosticCollection(extension.identifier, name2);
      },
      get onDidChangeDiagnostics() {
        return _asExtensionEvent(extHostDiagnostics.onDidChangeDiagnostics);
      },
      getDiagnostics: (resource) => {
        return extHostDiagnostics.getDiagnostics(resource);
      },
      getLanguages() {
        return extHostLanguages.getLanguages();
      },
      setTextDocumentLanguage(document2, languageId) {
        return extHostLanguages.changeLanguage(document2.uri, languageId);
      },
      match(selector, document2) {
        const interalSelector = LanguageSelector.from(selector);
        let notebook;
        if (targetsNotebooks(interalSelector)) {
          notebook = extHostNotebook.notebookDocuments.find((value) => value.apiNotebook.getCells().find((c) => c.document === document2))?.apiNotebook;
        }
        return score(interalSelector, document2.uri, document2.languageId, true, notebook?.uri, notebook?.notebookType);
      },
      registerCodeActionsProvider(selector, provider, metadata) {
        return extHostLanguageFeatures.registerCodeActionProvider(extension, checkSelector(selector), provider, metadata);
      },
      registerDocumentPasteEditProvider(selector, provider, metadata) {
        return extHostLanguageFeatures.registerDocumentPasteEditProvider(extension, checkSelector(selector), provider, metadata);
      },
      registerCodeLensProvider(selector, provider) {
        return extHostLanguageFeatures.registerCodeLensProvider(extension, checkSelector(selector), provider);
      },
      registerDefinitionProvider(selector, provider) {
        return extHostLanguageFeatures.registerDefinitionProvider(extension, checkSelector(selector), provider);
      },
      registerDeclarationProvider(selector, provider) {
        return extHostLanguageFeatures.registerDeclarationProvider(extension, checkSelector(selector), provider);
      },
      registerImplementationProvider(selector, provider) {
        return extHostLanguageFeatures.registerImplementationProvider(extension, checkSelector(selector), provider);
      },
      registerTypeDefinitionProvider(selector, provider) {
        return extHostLanguageFeatures.registerTypeDefinitionProvider(extension, checkSelector(selector), provider);
      },
      registerHoverProvider(selector, provider) {
        return extHostLanguageFeatures.registerHoverProvider(extension, checkSelector(selector), provider, extension.identifier);
      },
      registerEvaluatableExpressionProvider(selector, provider) {
        return extHostLanguageFeatures.registerEvaluatableExpressionProvider(extension, checkSelector(selector), provider, extension.identifier);
      },
      registerInlineValuesProvider(selector, provider) {
        return extHostLanguageFeatures.registerInlineValuesProvider(extension, checkSelector(selector), provider, extension.identifier);
      },
      registerDocumentHighlightProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentHighlightProvider(extension, checkSelector(selector), provider);
      },
      registerMultiDocumentHighlightProvider(selector, provider) {
        return extHostLanguageFeatures.registerMultiDocumentHighlightProvider(extension, checkSelector(selector), provider);
      },
      registerLinkedEditingRangeProvider(selector, provider) {
        return extHostLanguageFeatures.registerLinkedEditingRangeProvider(extension, checkSelector(selector), provider);
      },
      registerReferenceProvider(selector, provider) {
        return extHostLanguageFeatures.registerReferenceProvider(extension, checkSelector(selector), provider);
      },
      registerRenameProvider(selector, provider) {
        return extHostLanguageFeatures.registerRenameProvider(extension, checkSelector(selector), provider);
      },
      registerNewSymbolNamesProvider(selector, provider) {
        checkProposedApiEnabled(extension, "newSymbolNamesProvider");
        return extHostLanguageFeatures.registerNewSymbolNamesProvider(extension, checkSelector(selector), provider);
      },
      registerDocumentSymbolProvider(selector, provider, metadata) {
        return extHostLanguageFeatures.registerDocumentSymbolProvider(extension, checkSelector(selector), provider, metadata);
      },
      registerWorkspaceSymbolProvider(provider) {
        return extHostLanguageFeatures.registerWorkspaceSymbolProvider(extension, provider);
      },
      registerDocumentFormattingEditProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentFormattingEditProvider(extension, checkSelector(selector), provider);
      },
      registerDocumentRangeFormattingEditProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(extension, checkSelector(selector), provider);
      },
      registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacters) {
        return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(extension, checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
      },
      registerDocumentSemanticTokensProvider(selector, provider, legend) {
        return extHostLanguageFeatures.registerDocumentSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
      },
      registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        return extHostLanguageFeatures.registerDocumentRangeSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
      },
      registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {
        if (typeof firstItem === "object") {
          return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, firstItem);
        }
        return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, typeof firstItem === "undefined" ? [] : [firstItem, ...remaining]);
      },
      registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
        return extHostLanguageFeatures.registerCompletionItemProvider(extension, checkSelector(selector), provider, triggerCharacters);
      },
      registerInlineCompletionItemProvider(selector, provider, metadata) {
        if (provider.handleDidShowCompletionItem) {
          checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        }
        if (provider.handleDidPartiallyAcceptCompletionItem) {
          checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        }
        if (metadata) {
          checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        }
        return extHostLanguageFeatures.registerInlineCompletionsProvider(extension, checkSelector(selector), provider, metadata);
      },
      get inlineCompletionsUnificationState() {
        checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        return extHostLanguageFeatures.inlineCompletionsUnificationState;
      },
      onDidChangeCompletionsUnificationState(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        return _asExtensionEvent(extHostLanguageFeatures.onDidChangeInlineCompletionsUnificationState)(listener, thisArg, disposables);
      },
      registerDocumentLinkProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentLinkProvider(extension, checkSelector(selector), provider);
      },
      registerColorProvider(selector, provider) {
        return extHostLanguageFeatures.registerColorProvider(extension, checkSelector(selector), provider);
      },
      registerFoldingRangeProvider(selector, provider) {
        return extHostLanguageFeatures.registerFoldingRangeProvider(extension, checkSelector(selector), provider);
      },
      registerSelectionRangeProvider(selector, provider) {
        return extHostLanguageFeatures.registerSelectionRangeProvider(extension, selector, provider);
      },
      registerCallHierarchyProvider(selector, provider) {
        return extHostLanguageFeatures.registerCallHierarchyProvider(extension, selector, provider);
      },
      registerTypeHierarchyProvider(selector, provider) {
        return extHostLanguageFeatures.registerTypeHierarchyProvider(extension, selector, provider);
      },
      setLanguageConfiguration: (language2, configuration) => {
        return extHostLanguageFeatures.setLanguageConfiguration(extension, language2, configuration);
      },
      getTokenInformationAtPosition(doc, pos) {
        checkProposedApiEnabled(extension, "tokenInformation");
        return extHostLanguages.tokenAtPosition(doc, pos);
      },
      registerInlayHintsProvider(selector, provider) {
        return extHostLanguageFeatures.registerInlayHintsProvider(extension, selector, provider);
      },
      createLanguageStatusItem(id2, selector) {
        return extHostLanguages.createLanguageStatusItem(extension, id2, selector);
      },
      registerDocumentDropEditProvider(selector, provider, metadata) {
        return extHostLanguageFeatures.registerDocumentOnDropEditProvider(extension, selector, provider, metadata);
      }
    };
    const window2 = {
      get activeTextEditor() {
        return extHostEditors.getActiveTextEditor();
      },
      get visibleTextEditors() {
        return extHostEditors.getVisibleTextEditors();
      },
      get activeTerminal() {
        return extHostTerminalService.activeTerminal;
      },
      get terminals() {
        return extHostTerminalService.terminals;
      },
      async showTextDocument(documentOrUri, columnOrOptions, preserveFocus) {
        if (URI.isUri(documentOrUri) && documentOrUri.scheme === Schemas.vscodeRemote && !documentOrUri.authority) {
          extHostApiDeprecation.report("workspace.showTextDocument", extension, `A URI of 'vscode-remote' scheme requires an authority.`);
        }
        const document2 = await (URI.isUri(documentOrUri) ? Promise.resolve(workspace.openTextDocument(documentOrUri)) : Promise.resolve(documentOrUri));
        return extHostEditors.showTextDocument(document2, columnOrOptions, preserveFocus);
      },
      createTextEditorDecorationType(options2) {
        return extHostEditors.createTextEditorDecorationType(extension, options2);
      },
      onDidChangeActiveTextEditor(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostEditors.onDidChangeActiveTextEditor)(listener, thisArg, disposables);
      },
      onDidChangeVisibleTextEditors(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostEditors.onDidChangeVisibleTextEditors)(listener, thisArg, disposables);
      },
      onDidChangeTextEditorSelection(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostEditors.onDidChangeTextEditorSelection)(listener, thisArgs, disposables);
      },
      onDidChangeTextEditorOptions(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostEditors.onDidChangeTextEditorOptions)(listener, thisArgs, disposables);
      },
      onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostEditors.onDidChangeTextEditorVisibleRanges)(listener, thisArgs, disposables);
      },
      onDidChangeTextEditorViewColumn(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostEditors.onDidChangeTextEditorViewColumn)(listener, thisArg, disposables);
      },
      onDidChangeTextEditorDiffInformation(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "textEditorDiffInformation");
        return _asExtensionEvent(extHostEditors.onDidChangeTextEditorDiffInformation)(listener, thisArg, disposables);
      },
      onDidCloseTerminal(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTerminalService.onDidCloseTerminal)(listener, thisArg, disposables);
      },
      onDidOpenTerminal(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTerminalService.onDidOpenTerminal)(listener, thisArg, disposables);
      },
      onDidChangeActiveTerminal(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTerminalService.onDidChangeActiveTerminal)(listener, thisArg, disposables);
      },
      onDidChangeTerminalDimensions(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "terminalDimensions");
        return _asExtensionEvent(extHostTerminalService.onDidChangeTerminalDimensions)(listener, thisArg, disposables);
      },
      onDidChangeTerminalState(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTerminalService.onDidChangeTerminalState)(listener, thisArg, disposables);
      },
      onDidWriteTerminalData(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "terminalDataWriteEvent");
        return _asExtensionEvent(extHostTerminalService.onDidWriteTerminalData)(listener, thisArg, disposables);
      },
      onDidExecuteTerminalCommand(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "terminalExecuteCommandEvent");
        return _asExtensionEvent(extHostTerminalService.onDidExecuteTerminalCommand)(listener, thisArg, disposables);
      },
      onDidChangeTerminalShellIntegration(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTerminalShellIntegration.onDidChangeTerminalShellIntegration)(listener, thisArg, disposables);
      },
      onDidStartTerminalShellExecution(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTerminalShellIntegration.onDidStartTerminalShellExecution)(listener, thisArg, disposables);
      },
      onDidEndTerminalShellExecution(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTerminalShellIntegration.onDidEndTerminalShellExecution)(listener, thisArg, disposables);
      },
      get state() {
        return extHostWindow.getState();
      },
      onDidChangeWindowState(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostWindow.onDidChangeWindowState)(listener, thisArg, disposables);
      },
      showInformationMessage(message, ...rest) {
        return extHostMessageService.showMessage(extension, severity_default.Info, message, rest[0], rest.slice(1));
      },
      showWarningMessage(message, ...rest) {
        return extHostMessageService.showMessage(extension, severity_default.Warning, message, rest[0], rest.slice(1));
      },
      showErrorMessage(message, ...rest) {
        return extHostMessageService.showMessage(extension, severity_default.Error, message, rest[0], rest.slice(1));
      },
      showQuickPick(items, options2, token) {
        return extHostQuickOpen.showQuickPick(extension, items, options2, token);
      },
      showWorkspaceFolderPick(options2) {
        return extHostQuickOpen.showWorkspaceFolderPick(options2);
      },
      showInputBox(options2, token) {
        return extHostQuickOpen.showInput(options2, token);
      },
      showOpenDialog(options2) {
        return extHostDialogs.showOpenDialog(options2);
      },
      showSaveDialog(options2) {
        return extHostDialogs.showSaveDialog(options2);
      },
      createStatusBarItem(alignmentOrId, priorityOrAlignment, priorityArg) {
        let id2;
        let alignment;
        let priority;
        if (typeof alignmentOrId === "string") {
          id2 = alignmentOrId;
          alignment = priorityOrAlignment;
          priority = priorityArg;
        } else {
          alignment = alignmentOrId;
          priority = priorityOrAlignment;
        }
        return extHostStatusBar.createStatusBarEntry(extension, id2, alignment, priority);
      },
      setStatusBarMessage(text, timeoutOrThenable) {
        return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);
      },
      withScmProgress(task) {
        extHostApiDeprecation.report("window.withScmProgress", extension, `Use 'withProgress' instead.`);
        return extHostProgress.withProgress(extension, { location: ProgressLocation.SourceControl }, (progress, token) => task({ report(n) {
        } }));
      },
      withProgress(options2, task) {
        return extHostProgress.withProgress(extension, options2, task);
      },
      createOutputChannel(name2, options2) {
        return extHostOutputService.createOutputChannel(name2, options2, extension);
      },
      createWebviewPanel(viewType, title, showOptions, options2) {
        return extHostWebviewPanels.createWebviewPanel(extension, viewType, title, showOptions, options2);
      },
      createWebviewTextEditorInset(editor, line, height, options2) {
        checkProposedApiEnabled(extension, "editorInsets");
        return extHostEditorInsets.createWebviewEditorInset(editor, line, height, options2, extension);
      },
      createTerminal(nameOrOptions, shellPath, shellArgs) {
        if (typeof nameOrOptions === "object") {
          if ("pty" in nameOrOptions) {
            return extHostTerminalService.createExtensionTerminal(nameOrOptions);
          }
          return extHostTerminalService.createTerminalFromOptions(nameOrOptions);
        }
        return extHostTerminalService.createTerminal(nameOrOptions, shellPath, shellArgs);
      },
      registerTerminalLinkProvider(provider) {
        return extHostTerminalService.registerLinkProvider(provider);
      },
      registerTerminalProfileProvider(id2, provider) {
        return extHostTerminalService.registerProfileProvider(extension, id2, provider);
      },
      registerTerminalCompletionProvider(provider, ...triggerCharacters) {
        checkProposedApiEnabled(extension, "terminalCompletionProvider");
        return extHostTerminalService.registerTerminalCompletionProvider(extension, provider, ...triggerCharacters);
      },
      registerTerminalQuickFixProvider(id2, provider) {
        checkProposedApiEnabled(extension, "terminalQuickFixProvider");
        return extHostTerminalService.registerTerminalQuickFixProvider(id2, extension.identifier.value, provider);
      },
      registerTreeDataProvider(viewId, treeDataProvider) {
        return extHostTreeViews.registerTreeDataProvider(viewId, treeDataProvider, extension);
      },
      createTreeView(viewId, options2) {
        return extHostTreeViews.createTreeView(viewId, options2, extension);
      },
      registerWebviewPanelSerializer: (viewType, serializer) => {
        return extHostWebviewPanels.registerWebviewPanelSerializer(extension, viewType, serializer);
      },
      registerCustomEditorProvider: (viewType, provider, options2 = {}) => {
        return extHostCustomEditors.registerCustomEditorProvider(extension, viewType, provider, options2);
      },
      registerFileDecorationProvider(provider) {
        return extHostDecorations.registerFileDecorationProvider(provider, extension);
      },
      registerUriHandler(handler) {
        return extHostUrls.registerUriHandler(extension, handler);
      },
      createQuickPick() {
        return extHostQuickOpen.createQuickPick(extension);
      },
      createInputBox() {
        return extHostQuickOpen.createInputBox(extension);
      },
      get activeColorTheme() {
        return extHostTheming.activeColorTheme;
      },
      onDidChangeActiveColorTheme(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostTheming.onDidChangeActiveColorTheme)(listener, thisArg, disposables);
      },
      registerWebviewViewProvider(viewId, provider, options2) {
        return extHostWebviewViews.registerWebviewViewProvider(extension, viewId, provider, options2?.webviewOptions);
      },
      get activeNotebookEditor() {
        return extHostNotebook.activeNotebookEditor;
      },
      onDidChangeActiveNotebookEditor(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostNotebook.onDidChangeActiveNotebookEditor)(listener, thisArgs, disposables);
      },
      get visibleNotebookEditors() {
        return extHostNotebook.visibleNotebookEditors;
      },
      get onDidChangeVisibleNotebookEditors() {
        return _asExtensionEvent(extHostNotebook.onDidChangeVisibleNotebookEditors);
      },
      onDidChangeNotebookEditorSelection(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostNotebookEditors.onDidChangeNotebookEditorSelection)(listener, thisArgs, disposables);
      },
      onDidChangeNotebookEditorVisibleRanges(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostNotebookEditors.onDidChangeNotebookEditorVisibleRanges)(listener, thisArgs, disposables);
      },
      showNotebookDocument(document2, options2) {
        return extHostNotebook.showNotebookDocument(document2, options2);
      },
      registerExternalUriOpener(id2, opener, metadata) {
        checkProposedApiEnabled(extension, "externalUriOpener");
        return extHostUriOpeners.registerExternalUriOpener(extension.identifier, id2, opener, metadata);
      },
      registerProfileContentHandler(id2, handler) {
        checkProposedApiEnabled(extension, "profileContentHandlers");
        return extHostProfileContentHandlers.registerProfileContentHandler(extension, id2, handler);
      },
      registerQuickDiffProvider(selector, quickDiffProvider, id2, label, rootUri) {
        checkProposedApiEnabled(extension, "quickDiffProvider");
        return extHostQuickDiff.registerQuickDiffProvider(extension, checkSelector(selector), quickDiffProvider, id2, label, rootUri);
      },
      get tabGroups() {
        return extHostEditorTabs.tabGroups;
      },
      registerShareProvider(selector, provider) {
        checkProposedApiEnabled(extension, "shareProvider");
        return extHostShare.registerShareProvider(checkSelector(selector), provider);
      },
      get nativeHandle() {
        checkProposedApiEnabled(extension, "nativeWindowHandle");
        return extHostWindow.nativeHandle;
      },
      createChatStatusItem: (id2) => {
        checkProposedApiEnabled(extension, "chatStatusItem");
        return extHostChatStatus.createChatStatusItem(extension, id2);
      }
    };
    const workspace = {
      get rootPath() {
        extHostApiDeprecation.report("workspace.rootPath", extension, `Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath`);
        return extHostWorkspace.getPath();
      },
      set rootPath(value) {
        throw new ReadonlyError("rootPath");
      },
      getWorkspaceFolder(resource) {
        return extHostWorkspace.getWorkspaceFolder(resource);
      },
      get workspaceFolders() {
        return extHostWorkspace.getWorkspaceFolders();
      },
      get name() {
        return extHostWorkspace.name;
      },
      set name(value) {
        throw new ReadonlyError("name");
      },
      get workspaceFile() {
        return extHostWorkspace.workspaceFile;
      },
      set workspaceFile(value) {
        throw new ReadonlyError("workspaceFile");
      },
      updateWorkspaceFolders: (index, deleteCount, ...workspaceFoldersToAdd) => {
        return extHostWorkspace.updateWorkspaceFolders(extension, index, deleteCount || 0, ...workspaceFoldersToAdd);
      },
      onDidChangeWorkspaceFolders: function(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostWorkspace.onDidChangeWorkspace)(listener, thisArgs, disposables);
      },
      asRelativePath: (pathOrUri, includeWorkspace) => {
        return extHostWorkspace.getRelativePath(pathOrUri, includeWorkspace);
      },
      findFiles: (include, exclude, maxResults, token) => {
        return extHostWorkspace.findFiles(include, exclude, maxResults, extension.identifier, token);
      },
      findFiles2: (filePattern, options2, token) => {
        checkProposedApiEnabled(extension, "findFiles2");
        return extHostWorkspace.findFiles2(filePattern, options2, extension.identifier, token);
      },
      findTextInFiles: (query, optionsOrCallback, callbackOrToken, token) => {
        checkProposedApiEnabled(extension, "findTextInFiles");
        let options2;
        let callback;
        if (typeof optionsOrCallback === "object") {
          options2 = optionsOrCallback;
          callback = callbackOrToken;
        } else {
          options2 = {};
          callback = optionsOrCallback;
          token = callbackOrToken;
        }
        return extHostWorkspace.findTextInFiles(query, options2 || {}, callback, extension.identifier, token);
      },
      findTextInFiles2: (query, options2, token) => {
        checkProposedApiEnabled(extension, "findTextInFiles2");
        checkProposedApiEnabled(extension, "textSearchProvider2");
        return extHostWorkspace.findTextInFiles2(query, options2, extension.identifier, token);
      },
      save: (uri) => {
        return extHostWorkspace.save(uri);
      },
      saveAs: (uri) => {
        return extHostWorkspace.saveAs(uri);
      },
      saveAll: (includeUntitled) => {
        return extHostWorkspace.saveAll(includeUntitled);
      },
      applyEdit(edit2, metadata) {
        return extHostBulkEdits.applyWorkspaceEdit(edit2, extension, metadata);
      },
      createFileSystemWatcher: (pattern, optionsOrIgnoreCreate, ignoreChange, ignoreDelete) => {
        const options2 = {
          ignoreCreateEvents: Boolean(optionsOrIgnoreCreate),
          ignoreChangeEvents: Boolean(ignoreChange),
          ignoreDeleteEvents: Boolean(ignoreDelete)
        };
        return extHostFileSystemEvent.createFileSystemWatcher(extHostWorkspace, configProvider, extension, pattern, options2);
      },
      get textDocuments() {
        return extHostDocuments.getAllDocumentData().map((data2) => data2.document);
      },
      set textDocuments(value) {
        throw new ReadonlyError("textDocuments");
      },
      openTextDocument(uriOrFileNameOrOptions, options2) {
        let uriPromise;
        options2 = options2 ?? uriOrFileNameOrOptions;
        if (typeof uriOrFileNameOrOptions === "string") {
          uriPromise = Promise.resolve(URI.file(uriOrFileNameOrOptions));
        } else if (URI.isUri(uriOrFileNameOrOptions)) {
          uriPromise = Promise.resolve(uriOrFileNameOrOptions);
        } else if (!options2 || typeof options2 === "object") {
          uriPromise = extHostDocuments.createDocumentData(options2);
        } else {
          throw new Error("illegal argument - uriOrFileNameOrOptions");
        }
        return uriPromise.then((uri) => {
          extHostLogService.trace(`openTextDocument from ${extension.identifier}`);
          if (uri.scheme === Schemas.vscodeRemote && !uri.authority) {
            extHostApiDeprecation.report("workspace.openTextDocument", extension, `A URI of 'vscode-remote' scheme requires an authority.`);
          }
          return extHostDocuments.ensureDocumentData(uri, options2).then((documentData) => {
            return documentData.document;
          });
        });
      },
      onDidOpenTextDocument: (listener, thisArgs, disposables) => {
        return _asExtensionEvent(extHostDocuments.onDidAddDocument)(listener, thisArgs, disposables);
      },
      onDidCloseTextDocument: (listener, thisArgs, disposables) => {
        return _asExtensionEvent(extHostDocuments.onDidRemoveDocument)(listener, thisArgs, disposables);
      },
      onDidChangeTextDocument: (listener, thisArgs, disposables) => {
        if (isProposedApiEnabled(extension, "textDocumentChangeReason")) {
          return _asExtensionEvent(extHostDocuments.onDidChangeDocumentWithReason)(listener, thisArgs, disposables);
        }
        return _asExtensionEvent(extHostDocuments.onDidChangeDocument)(listener, thisArgs, disposables);
      },
      onDidSaveTextDocument: (listener, thisArgs, disposables) => {
        return _asExtensionEvent(extHostDocuments.onDidSaveDocument)(listener, thisArgs, disposables);
      },
      onWillSaveTextDocument: (listener, thisArgs, disposables) => {
        return _asExtensionEvent(extHostDocumentSaveParticipant.getOnWillSaveTextDocumentEvent(extension))(listener, thisArgs, disposables);
      },
      get notebookDocuments() {
        return extHostNotebook.notebookDocuments.map((d) => d.apiNotebook);
      },
      async openNotebookDocument(uriOrType, content) {
        let uri;
        if (URI.isUri(uriOrType)) {
          uri = uriOrType;
          await extHostNotebook.openNotebookDocument(uriOrType);
        } else if (typeof uriOrType === "string") {
          uri = URI.revive(await extHostNotebook.createNotebookDocument({ viewType: uriOrType, content }));
        } else {
          throw new Error("Invalid arguments");
        }
        return extHostNotebook.getNotebookDocument(uri).apiNotebook;
      },
      onDidSaveNotebookDocument(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostNotebookDocuments.onDidSaveNotebookDocument)(listener, thisArg, disposables);
      },
      onDidChangeNotebookDocument(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostNotebookDocuments.onDidChangeNotebookDocument)(listener, thisArg, disposables);
      },
      onWillSaveNotebookDocument(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostNotebookDocumentSaveParticipant.getOnWillSaveNotebookDocumentEvent(extension))(listener, thisArg, disposables);
      },
      get onDidOpenNotebookDocument() {
        return _asExtensionEvent(extHostNotebook.onDidOpenNotebookDocument);
      },
      get onDidCloseNotebookDocument() {
        return _asExtensionEvent(extHostNotebook.onDidCloseNotebookDocument);
      },
      registerNotebookSerializer(viewType, serializer, options2, registration) {
        return extHostNotebook.registerNotebookSerializer(extension, viewType, serializer, options2, isProposedApiEnabled(extension, "notebookLiveShare") ? registration : void 0);
      },
      onDidChangeConfiguration: (listener, thisArgs, disposables) => {
        return _asExtensionEvent(configProvider.onDidChangeConfiguration)(listener, thisArgs, disposables);
      },
      getConfiguration(section, scope) {
        scope = arguments.length === 1 ? void 0 : scope;
        return configProvider.getConfiguration(section, scope, extension);
      },
      registerTextDocumentContentProvider(scheme, provider) {
        return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
      },
      registerTaskProvider: (type, provider) => {
        extHostApiDeprecation.report("window.registerTaskProvider", extension, `Use the corresponding function on the 'tasks' namespace instead`);
        return extHostTask.registerTaskProvider(extension, type, provider);
      },
      registerFileSystemProvider(scheme, provider, options2) {
        return combinedDisposable(extHostFileSystem.registerFileSystemProvider(extension, scheme, provider, options2), extHostConsumerFileSystem.addFileSystemProvider(scheme, provider, options2));
      },
      get fs() {
        return extHostConsumerFileSystem.value;
      },
      registerFileSearchProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "fileSearchProvider");
        return extHostSearch.registerFileSearchProviderOld(scheme, provider);
      },
      registerTextSearchProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "textSearchProvider");
        return extHostSearch.registerTextSearchProviderOld(scheme, provider);
      },
      registerAITextSearchProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "aiTextSearchProvider");
        checkProposedApiEnabled(extension, "textSearchProvider2");
        return extHostSearch.registerAITextSearchProvider(scheme, provider);
      },
      registerFileSearchProvider2: (scheme, provider) => {
        checkProposedApiEnabled(extension, "fileSearchProvider2");
        return extHostSearch.registerFileSearchProvider(scheme, provider);
      },
      registerTextSearchProvider2: (scheme, provider) => {
        checkProposedApiEnabled(extension, "textSearchProvider2");
        return extHostSearch.registerTextSearchProvider(scheme, provider);
      },
      registerRemoteAuthorityResolver: (authorityPrefix, resolver) => {
        checkProposedApiEnabled(extension, "resolvers");
        return extensionService.registerRemoteAuthorityResolver(authorityPrefix, resolver);
      },
      registerResourceLabelFormatter: (formatter) => {
        checkProposedApiEnabled(extension, "resolvers");
        return extHostLabelService.$registerResourceLabelFormatter(formatter);
      },
      getRemoteExecServer: (authority) => {
        checkProposedApiEnabled(extension, "resolvers");
        return extensionService.getRemoteExecServer(authority);
      },
      onDidCreateFiles: (listener, thisArg, disposables) => {
        return _asExtensionEvent(extHostFileSystemEvent.onDidCreateFile)(listener, thisArg, disposables);
      },
      onDidDeleteFiles: (listener, thisArg, disposables) => {
        return _asExtensionEvent(extHostFileSystemEvent.onDidDeleteFile)(listener, thisArg, disposables);
      },
      onDidRenameFiles: (listener, thisArg, disposables) => {
        return _asExtensionEvent(extHostFileSystemEvent.onDidRenameFile)(listener, thisArg, disposables);
      },
      onWillCreateFiles: (listener, thisArg, disposables) => {
        return _asExtensionEvent(extHostFileSystemEvent.getOnWillCreateFileEvent(extension))(listener, thisArg, disposables);
      },
      onWillDeleteFiles: (listener, thisArg, disposables) => {
        return _asExtensionEvent(extHostFileSystemEvent.getOnWillDeleteFileEvent(extension))(listener, thisArg, disposables);
      },
      onWillRenameFiles: (listener, thisArg, disposables) => {
        return _asExtensionEvent(extHostFileSystemEvent.getOnWillRenameFileEvent(extension))(listener, thisArg, disposables);
      },
      openTunnel: (forward) => {
        checkProposedApiEnabled(extension, "tunnels");
        return extHostTunnelService.openTunnel(extension, forward).then((value) => {
          if (!value) {
            throw new Error("cannot open tunnel");
          }
          return value;
        });
      },
      get tunnels() {
        checkProposedApiEnabled(extension, "tunnels");
        return extHostTunnelService.getTunnels();
      },
      onDidChangeTunnels: (listener, thisArg, disposables) => {
        checkProposedApiEnabled(extension, "tunnels");
        return _asExtensionEvent(extHostTunnelService.onDidChangeTunnels)(listener, thisArg, disposables);
      },
      registerPortAttributesProvider: (portSelector, provider) => {
        checkProposedApiEnabled(extension, "portsAttributes");
        return extHostTunnelService.registerPortsAttributesProvider(portSelector, provider);
      },
      registerTunnelProvider: (tunnelProvider, information) => {
        checkProposedApiEnabled(extension, "tunnelFactory");
        return extHostTunnelService.registerTunnelProvider(tunnelProvider, information);
      },
      registerTimelineProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "timeline");
        return extHostTimeline.registerTimelineProvider(scheme, provider, extension.identifier, extHostCommands.converter);
      },
      get isTrusted() {
        return extHostWorkspace.trusted;
      },
      requestWorkspaceTrust: (options2) => {
        checkProposedApiEnabled(extension, "workspaceTrust");
        return extHostWorkspace.requestWorkspaceTrust(options2);
      },
      onDidGrantWorkspaceTrust: (listener, thisArgs, disposables) => {
        return _asExtensionEvent(extHostWorkspace.onDidGrantWorkspaceTrust)(listener, thisArgs, disposables);
      },
      registerEditSessionIdentityProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "editSessionIdentityProvider");
        return extHostWorkspace.registerEditSessionIdentityProvider(scheme, provider);
      },
      onWillCreateEditSessionIdentity: (listener, thisArgs, disposables) => {
        checkProposedApiEnabled(extension, "editSessionIdentityProvider");
        return _asExtensionEvent(extHostWorkspace.getOnWillCreateEditSessionIdentityEvent(extension))(listener, thisArgs, disposables);
      },
      registerCanonicalUriProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "canonicalUriProvider");
        return extHostWorkspace.registerCanonicalUriProvider(scheme, provider);
      },
      getCanonicalUri: (uri, options2, token) => {
        checkProposedApiEnabled(extension, "canonicalUriProvider");
        return extHostWorkspace.provideCanonicalUri(uri, options2, token);
      },
      decode(content, options2) {
        return extHostWorkspace.decode(content, options2);
      },
      encode(content, options2) {
        return extHostWorkspace.encode(content, options2);
      }
    };
    const scm = {
      get inputBox() {
        extHostApiDeprecation.report("scm.inputBox", extension, `Use 'SourceControl.inputBox' instead`);
        return extHostSCM.getLastInputBox(extension);
      },
      createSourceControl(id2, label, rootUri, iconPath, parent) {
        if (iconPath || parent) {
          checkProposedApiEnabled(extension, "scmProviderOptions");
        }
        return extHostSCM.createSourceControl(extension, id2, label, rootUri, iconPath, parent);
      }
    };
    const comments = {
      createCommentController(id2, label) {
        return extHostComment.createCommentController(extension, id2, label);
      }
    };
    const debug = {
      get activeDebugSession() {
        return extHostDebugService.activeDebugSession;
      },
      get activeDebugConsole() {
        return extHostDebugService.activeDebugConsole;
      },
      get breakpoints() {
        return extHostDebugService.breakpoints;
      },
      get activeStackItem() {
        return extHostDebugService.activeStackItem;
      },
      registerDebugVisualizationProvider(id2, provider) {
        checkProposedApiEnabled(extension, "debugVisualization");
        return extHostDebugService.registerDebugVisualizationProvider(extension, id2, provider);
      },
      registerDebugVisualizationTreeProvider(id2, provider) {
        checkProposedApiEnabled(extension, "debugVisualization");
        return extHostDebugService.registerDebugVisualizationTree(extension, id2, provider);
      },
      onDidStartDebugSession(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostDebugService.onDidStartDebugSession)(listener, thisArg, disposables);
      },
      onDidTerminateDebugSession(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostDebugService.onDidTerminateDebugSession)(listener, thisArg, disposables);
      },
      onDidChangeActiveDebugSession(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostDebugService.onDidChangeActiveDebugSession)(listener, thisArg, disposables);
      },
      onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostDebugService.onDidReceiveDebugSessionCustomEvent)(listener, thisArg, disposables);
      },
      onDidChangeBreakpoints(listener, thisArgs, disposables) {
        return _asExtensionEvent(extHostDebugService.onDidChangeBreakpoints)(listener, thisArgs, disposables);
      },
      onDidChangeActiveStackItem(listener, thisArg, disposables) {
        return _asExtensionEvent(extHostDebugService.onDidChangeActiveStackItem)(listener, thisArg, disposables);
      },
      registerDebugConfigurationProvider(debugType, provider, triggerKind) {
        return extHostDebugService.registerDebugConfigurationProvider(debugType, provider, triggerKind || DebugConfigurationProviderTriggerKind.Initial);
      },
      registerDebugAdapterDescriptorFactory(debugType, factory) {
        return extHostDebugService.registerDebugAdapterDescriptorFactory(extension, debugType, factory);
      },
      registerDebugAdapterTrackerFactory(debugType, factory) {
        return extHostDebugService.registerDebugAdapterTrackerFactory(debugType, factory);
      },
      startDebugging(folder, nameOrConfig, parentSessionOrOptions) {
        if (!parentSessionOrOptions || typeof parentSessionOrOptions === "object" && "configuration" in parentSessionOrOptions) {
          return extHostDebugService.startDebugging(folder, nameOrConfig, { parentSession: parentSessionOrOptions });
        }
        return extHostDebugService.startDebugging(folder, nameOrConfig, parentSessionOrOptions || {});
      },
      stopDebugging(session) {
        return extHostDebugService.stopDebugging(session);
      },
      addBreakpoints(breakpoints) {
        return extHostDebugService.addBreakpoints(breakpoints);
      },
      removeBreakpoints(breakpoints) {
        return extHostDebugService.removeBreakpoints(breakpoints);
      },
      asDebugSourceUri(source, session) {
        return extHostDebugService.asDebugSourceUri(source, session);
      }
    };
    const tasks = {
      registerTaskProvider: (type, provider) => {
        return extHostTask.registerTaskProvider(extension, type, provider);
      },
      fetchTasks: (filter2) => {
        return extHostTask.fetchTasks(filter2);
      },
      executeTask: (task) => {
        return extHostTask.executeTask(extension, task);
      },
      get taskExecutions() {
        return extHostTask.taskExecutions;
      },
      onDidStartTask: (listener, thisArgs, disposables) => {
        const wrappedListener = (event) => {
          if (!isProposedApiEnabled(extension, "taskExecutionTerminal")) {
            if (event?.execution?.terminal !== void 0) {
              event.execution.terminal = void 0;
            }
          }
          const eventWithExecution = {
            ...event,
            execution: event.execution
          };
          return listener.call(thisArgs, eventWithExecution);
        };
        return _asExtensionEvent(extHostTask.onDidStartTask)(wrappedListener, thisArgs, disposables);
      },
      onDidEndTask: (listeners, thisArgs, disposables) => {
        return _asExtensionEvent(extHostTask.onDidEndTask)(listeners, thisArgs, disposables);
      },
      onDidStartTaskProcess: (listeners, thisArgs, disposables) => {
        return _asExtensionEvent(extHostTask.onDidStartTaskProcess)(listeners, thisArgs, disposables);
      },
      onDidEndTaskProcess: (listeners, thisArgs, disposables) => {
        return _asExtensionEvent(extHostTask.onDidEndTaskProcess)(listeners, thisArgs, disposables);
      },
      onDidStartTaskProblemMatchers: (listeners, thisArgs, disposables) => {
        checkProposedApiEnabled(extension, "taskProblemMatcherStatus");
        return _asExtensionEvent(extHostTask.onDidStartTaskProblemMatchers)(listeners, thisArgs, disposables);
      },
      onDidEndTaskProblemMatchers: (listeners, thisArgs, disposables) => {
        checkProposedApiEnabled(extension, "taskProblemMatcherStatus");
        return _asExtensionEvent(extHostTask.onDidEndTaskProblemMatchers)(listeners, thisArgs, disposables);
      }
    };
    const notebooks = {
      createNotebookController(id2, notebookType, label, handler, rendererScripts) {
        return extHostNotebookKernels.createNotebookController(extension, id2, notebookType, label, handler, isProposedApiEnabled(extension, "notebookMessaging") ? rendererScripts : void 0);
      },
      registerNotebookCellStatusBarItemProvider: (notebookType, provider) => {
        return extHostNotebook.registerNotebookCellStatusBarItemProvider(extension, notebookType, provider);
      },
      createRendererMessaging(rendererId) {
        return extHostNotebookRenderers.createRendererMessaging(extension, rendererId);
      },
      createNotebookControllerDetectionTask(notebookType) {
        checkProposedApiEnabled(extension, "notebookKernelSource");
        return extHostNotebookKernels.createNotebookControllerDetectionTask(extension, notebookType);
      },
      registerKernelSourceActionProvider(notebookType, provider) {
        checkProposedApiEnabled(extension, "notebookKernelSource");
        return extHostNotebookKernels.registerKernelSourceActionProvider(extension, notebookType, provider);
      }
    };
    const l10n = {
      t(...params) {
        if (typeof params[0] === "string") {
          const key = params.shift();
          const argsFormatted = !params || typeof params[0] !== "object" ? params : params[0];
          return extHostLocalization.getMessage(extension.identifier.value, { message: key, args: argsFormatted });
        }
        return extHostLocalization.getMessage(extension.identifier.value, params[0]);
      },
      get bundle() {
        return extHostLocalization.getBundle(extension.identifier.value);
      },
      get uri() {
        return extHostLocalization.getBundleUri(extension.identifier.value);
      }
    };
    const interactive = {
      transferActiveChat(toWorkspace) {
        checkProposedApiEnabled(extension, "interactive");
        return extHostChatAgents2.transferActiveChat(toWorkspace);
      }
    };
    const ai = {
      getRelatedInformation(query, types) {
        checkProposedApiEnabled(extension, "aiRelatedInformation");
        return extHostAiRelatedInformation.getRelatedInformation(extension, query, types);
      },
      registerRelatedInformationProvider(type, provider) {
        checkProposedApiEnabled(extension, "aiRelatedInformation");
        return extHostAiRelatedInformation.registerRelatedInformationProvider(extension, type, provider);
      },
      registerEmbeddingVectorProvider(model, provider) {
        checkProposedApiEnabled(extension, "aiRelatedInformation");
        return extHostAiEmbeddingVector.registerEmbeddingVectorProvider(extension, model, provider);
      },
      registerSettingsSearchProvider(provider) {
        checkProposedApiEnabled(extension, "aiSettingsSearch");
        return extHostAiSettingsSearch.registerSettingsSearchProvider(extension, provider);
      }
    };
    const chat = {
      registerMappedEditsProvider(_selector, _provider) {
        checkProposedApiEnabled(extension, "mappedEditsProvider");
        return { dispose() {
        } };
      },
      registerMappedEditsProvider2(provider) {
        checkProposedApiEnabled(extension, "mappedEditsProvider");
        return extHostCodeMapper.registerMappedEditsProvider(extension, provider);
      },
      createChatParticipant(id2, handler) {
        return extHostChatAgents2.createChatAgent(extension, id2, handler);
      },
      createDynamicChatParticipant(id2, dynamicProps, handler) {
        checkProposedApiEnabled(extension, "chatParticipantPrivate");
        return extHostChatAgents2.createDynamicChatAgent(extension, id2, dynamicProps, handler);
      },
      registerChatParticipantDetectionProvider(provider) {
        checkProposedApiEnabled(extension, "chatParticipantPrivate");
        return extHostChatAgents2.registerChatParticipantDetectionProvider(extension, provider);
      },
      registerRelatedFilesProvider(provider, metadata) {
        checkProposedApiEnabled(extension, "chatEditing");
        return extHostChatAgents2.registerRelatedFilesProvider(extension, provider, metadata);
      },
      onDidDisposeChatSession: (listeners, thisArgs, disposables) => {
        checkProposedApiEnabled(extension, "chatParticipantPrivate");
        return _asExtensionEvent(extHostChatAgents2.onDidDisposeChatSession)(listeners, thisArgs, disposables);
      },
      registerChatSessionItemProvider: (chatSessionType, provider) => {
        checkProposedApiEnabled(extension, "chatSessionsProvider");
        return extHostChatSessions.registerChatSessionItemProvider(extension, chatSessionType, provider);
      },
      registerChatSessionContentProvider(scheme, provider, chatParticipant, capabilities) {
        checkProposedApiEnabled(extension, "chatSessionsProvider");
        return extHostChatSessions.registerChatSessionContentProvider(extension, scheme, chatParticipant, provider, capabilities);
      },
      registerChatOutputRenderer: (viewType, renderer) => {
        checkProposedApiEnabled(extension, "chatOutputRenderer");
        return extHostChatOutputRenderer.registerChatOutputRenderer(extension, viewType, renderer);
      },
      registerChatContextProvider(selector, id2, provider) {
        checkProposedApiEnabled(extension, "chatContextProvider");
        return extHostChatContext.registerChatContextProvider(selector ? checkSelector(selector) : void 0, `${extension.id}-${id2}`, provider);
      }
    };
    const lm = {
      selectChatModels: (selector) => {
        return extHostLanguageModels.selectLanguageModels(extension, selector ?? {});
      },
      onDidChangeChatModels: (listener, thisArgs, disposables) => {
        return extHostLanguageModels.onDidChangeProviders(listener, thisArgs, disposables);
      },
      registerLanguageModelChatProvider: (vendor, provider) => {
        return extHostLanguageModels.registerLanguageModelChatProvider(extension, vendor, provider);
      },
      get isModelProxyAvailable() {
        checkProposedApiEnabled(extension, "languageModelProxy");
        return extHostLanguageModels.isModelProxyAvailable;
      },
      onDidChangeModelProxyAvailability: (listener, thisArgs, disposables) => {
        checkProposedApiEnabled(extension, "languageModelProxy");
        return extHostLanguageModels.onDidChangeModelProxyAvailability(listener, thisArgs, disposables);
      },
      getModelProxy: () => {
        checkProposedApiEnabled(extension, "languageModelProxy");
        return extHostLanguageModels.getModelProxy(extension);
      },
      registerLanguageModelProxyProvider: (provider) => {
        checkProposedApiEnabled(extension, "chatParticipantPrivate");
        return extHostLanguageModels.registerLanguageModelProxyProvider(extension, provider);
      },
      // --- embeddings
      get embeddingModels() {
        checkProposedApiEnabled(extension, "embeddings");
        return extHostEmbeddings.embeddingsModels;
      },
      onDidChangeEmbeddingModels: (listener, thisArgs, disposables) => {
        checkProposedApiEnabled(extension, "embeddings");
        return extHostEmbeddings.onDidChange(listener, thisArgs, disposables);
      },
      registerEmbeddingsProvider(embeddingsModel, provider) {
        checkProposedApiEnabled(extension, "embeddings");
        return extHostEmbeddings.registerEmbeddingsProvider(extension, embeddingsModel, provider);
      },
      async computeEmbeddings(embeddingsModel, input, token) {
        checkProposedApiEnabled(extension, "embeddings");
        if (typeof input === "string") {
          return extHostEmbeddings.computeEmbeddings(embeddingsModel, input, token);
        } else {
          return extHostEmbeddings.computeEmbeddings(embeddingsModel, input, token);
        }
      },
      registerTool(name2, tool) {
        return extHostLanguageModelTools.registerTool(extension, name2, tool);
      },
      invokeTool(name2, parameters, token) {
        return extHostLanguageModelTools.invokeTool(extension, name2, parameters, token);
      },
      get tools() {
        return extHostLanguageModelTools.getTools(extension);
      },
      fileIsIgnored(uri, token) {
        return extHostLanguageModels.fileIsIgnored(extension, uri, token);
      },
      registerIgnoredFileProvider(provider) {
        return extHostLanguageModels.registerIgnoredFileProvider(extension, provider);
      },
      registerMcpServerDefinitionProvider(id2, provider) {
        return extHostMcp.registerMcpConfigurationProvider(extension, id2, provider);
      },
      onDidChangeChatRequestTools(...args) {
        checkProposedApiEnabled(extension, "chatParticipantAdditions");
        return _asExtensionEvent(extHostChatAgents2.onDidChangeChatRequestTools)(...args);
      }
    };
    const speech = {
      registerSpeechProvider(id2, provider) {
        checkProposedApiEnabled(extension, "speech");
        return extHostSpeech.registerProvider(extension.identifier, id2, provider);
      }
    };
    return {
      version: initData.version,
      // namespaces
      ai,
      authentication,
      commands,
      comments,
      chat,
      debug,
      env: env2,
      extensions,
      interactive,
      l10n,
      languages,
      lm,
      notebooks,
      scm,
      speech,
      tasks,
      tests,
      window: window2,
      workspace,
      // types
      Breakpoint,
      TerminalOutputAnchor,
      ChatResultFeedbackKind,
      ChatVariableLevel,
      ChatCompletionItem,
      ChatReferenceDiagnostic,
      CallHierarchyIncomingCall,
      CallHierarchyItem,
      CallHierarchyOutgoingCall,
      CancellationError,
      CancellationTokenSource,
      CandidatePortSource,
      CodeAction,
      CodeActionKind,
      CodeActionTriggerKind,
      CodeLens,
      Color,
      ColorInformation,
      ColorPresentation,
      ColorThemeKind,
      CommentMode: CommentMode2,
      CommentState: CommentState2,
      CommentThreadCollapsibleState: CommentThreadCollapsibleState2,
      CommentThreadState: CommentThreadState2,
      CommentThreadApplicability: CommentThreadApplicability2,
      CommentThreadFocus,
      CompletionItem,
      CompletionItemKind: CompletionItemKind2,
      CompletionItemTag: CompletionItemTag2,
      CompletionList,
      CompletionTriggerKind: CompletionTriggerKind2,
      ConfigurationTarget: ConfigurationTarget2,
      CustomExecution,
      DebugAdapterExecutable,
      DebugAdapterInlineImplementation,
      DebugAdapterNamedPipeServer,
      DebugAdapterServer,
      DebugConfigurationProviderTriggerKind,
      DebugConsoleMode,
      DebugVisualization,
      DecorationRangeBehavior,
      Diagnostic,
      DiagnosticRelatedInformation,
      DiagnosticSeverity,
      DiagnosticTag,
      Disposable: Disposable2,
      DocumentHighlight,
      DocumentHighlightKind: DocumentHighlightKind2,
      MultiDocumentHighlight,
      DocumentLink,
      DocumentSymbol,
      EndOfLine,
      EnvironmentVariableMutatorType,
      EvaluatableExpression,
      InlineValueText,
      InlineValueVariableLookup,
      InlineValueEvaluatableExpression,
      InlineCompletionTriggerKind: InlineCompletionTriggerKind2,
      InlineCompletionsDisposeReasonKind,
      EventEmitter: Emitter,
      ExtensionKind,
      ExtensionMode,
      ExternalUriOpenerPriority: ExternalUriOpenerPriority2,
      FileChangeType: FileChangeType2,
      FileDecoration,
      FileDecoration2: FileDecoration,
      FileSystemError,
      FileType,
      FilePermission,
      FoldingRange,
      FoldingRangeKind: FoldingRangeKind2,
      FunctionBreakpoint,
      InlineCompletionItem: InlineSuggestion,
      InlineCompletionList: InlineSuggestionList,
      Hover,
      VerboseHover,
      HoverVerbosityAction: HoverVerbosityAction2,
      IndentAction,
      Location,
      MarkdownString: MarkdownString2,
      OverviewRulerLane,
      ParameterInformation,
      PortAutoForwardAction,
      Position: Position2,
      ProcessExecution,
      ProgressLocation,
      QuickInputButtonLocation,
      QuickInputButtons,
      Range: Range2,
      RelativePattern,
      Selection,
      SelectionRange,
      SemanticTokens,
      SemanticTokensBuilder,
      SemanticTokensEdit,
      SemanticTokensEdits,
      SemanticTokensLegend,
      ShellExecution,
      ShellQuoting,
      SignatureHelp,
      SignatureHelpTriggerKind: SignatureHelpTriggerKind2,
      SignatureInformation,
      SnippetString,
      SourceBreakpoint,
      StandardTokenType,
      StatusBarAlignment,
      SymbolInformation,
      SymbolKind: SymbolKind2,
      SymbolTag: SymbolTag2,
      Task,
      TaskEventKind,
      TaskGroup,
      TaskPanelKind,
      TaskRevealKind,
      TaskScope,
      TerminalLink,
      TerminalQuickFixTerminalCommand: TerminalQuickFixCommand,
      TerminalQuickFixOpener,
      TerminalLocation,
      TerminalProfile,
      TerminalExitReason,
      TerminalShellExecutionCommandLineConfidence,
      TerminalCompletionItem,
      TerminalCompletionItemKind,
      TerminalCompletionList,
      TerminalShellType,
      TextDocumentSaveReason,
      TextEdit,
      SnippetTextEdit,
      TextEditorCursorStyle,
      TextEditorChangeKind,
      TextEditorLineNumbersStyle,
      TextEditorRevealType: TextEditorRevealType2,
      TextEditorSelectionChangeKind,
      SyntaxTokenType,
      TextDocumentChangeReason,
      ThemeColor: ThemeColor2,
      ThemeIcon: ThemeIcon2,
      TreeItem,
      TreeItemCheckboxState,
      TreeItemCollapsibleState,
      TypeHierarchyItem,
      UIKind,
      Uri: URI,
      ViewColumn,
      WorkspaceEdit,
      // proposed api types
      DocumentPasteTriggerKind: DocumentPasteTriggerKind2,
      DocumentDropEdit,
      DocumentDropOrPasteEditKind,
      DocumentPasteEdit,
      InlayHint,
      InlayHintLabelPart,
      InlayHintKind: InlayHintKind2,
      RemoteAuthorityResolverError,
      ResolvedAuthority,
      ManagedResolvedAuthority,
      SourceControlInputBoxValidationType,
      ExtensionRuntime,
      TimelineItem,
      NotebookRange,
      NotebookCellKind,
      NotebookCellExecutionState: NotebookCellExecutionState2,
      NotebookCellData,
      NotebookData,
      NotebookRendererScript,
      NotebookCellStatusBarAlignment,
      NotebookEditorRevealType: NotebookEditorRevealType2,
      NotebookCellOutput,
      NotebookCellOutputItem,
      CellErrorStackFrame,
      NotebookCellStatusBarItem,
      NotebookControllerAffinity,
      NotebookControllerAffinity2,
      NotebookEdit,
      NotebookKernelSourceAction,
      NotebookVariablesRequestKind,
      PortAttributes,
      LinkedEditingRanges,
      TestResultState: TestResultState2,
      TestRunRequest,
      TestMessage,
      TestMessageStackFrame,
      TestTag,
      TestRunProfileKind,
      TextSearchCompleteMessageType,
      DataTransfer,
      DataTransferItem,
      TestCoverageCount,
      FileCoverage,
      StatementCoverage,
      BranchCoverage,
      DeclarationCoverage,
      WorkspaceTrustState,
      LanguageStatusSeverity,
      QuickPickItemKind,
      InputBoxValidationSeverity,
      TabInputText: TextTabInput,
      TabInputTextDiff: TextDiffTabInput,
      TabInputTextMerge: TextMergeTabInput,
      TabInputCustom: CustomEditorTabInput,
      TabInputNotebook: NotebookEditorTabInput,
      TabInputNotebookDiff: NotebookDiffEditorTabInput,
      TabInputWebview: WebviewEditorTabInput,
      TabInputTerminal: TerminalEditorTabInput,
      TabInputInteractiveWindow: InteractiveWindowInput,
      TabInputChat: ChatEditorTabInput,
      TabInputTextMultiDiff: TextMultiDiffTabInput,
      TelemetryTrustedValue,
      LogLevel,
      EditSessionIdentityMatch,
      InteractiveSessionVoteDirection,
      ChatCopyKind,
      ChatEditingSessionActionOutcome,
      InteractiveEditorResponseFeedbackKind,
      DebugStackFrame,
      DebugThread,
      RelatedInformationType,
      SpeechToTextStatus,
      TextToSpeechStatus,
      PartialAcceptTriggerKind: PartialAcceptTriggerKind2,
      InlineCompletionEndOfLifeReasonKind: InlineCompletionEndOfLifeReasonKind2,
      InlineCompletionDisplayLocationKind,
      KeywordRecognitionStatus,
      ChatImageMimeType,
      ChatResponseMarkdownPart,
      ChatResponseFileTreePart,
      ChatResponseAnchorPart,
      ChatResponseProgressPart,
      ChatResponseProgressPart2,
      ChatResponseThinkingProgressPart,
      ChatResponseReferencePart,
      ChatResponseReferencePart2: ChatResponseReferencePart,
      ChatResponseCodeCitationPart,
      ChatResponseCodeblockUriPart,
      ChatResponseWarningPart,
      ChatResponseTextEditPart,
      ChatResponseNotebookEditPart,
      ChatResponseMarkdownWithVulnerabilitiesPart,
      ChatResponseCommandButtonPart,
      ChatResponseConfirmationPart,
      ChatResponseMovePart,
      ChatResponseExtensionsPart,
      ChatResponseExternalEditPart,
      ChatResponsePullRequestPart,
      ChatPrepareToolInvocationPart,
      ChatResponseMultiDiffPart,
      ChatResponseReferencePartStatusKind,
      ChatResponseClearToPreviousToolInvocationReason,
      ChatRequestTurn,
      ChatRequestTurn2: ChatRequestTurn,
      ChatResponseTurn,
      ChatResponseTurn2,
      ChatToolInvocationPart,
      ChatLocation,
      ChatSessionStatus: ChatSessionStatus2,
      ChatRequestEditorData,
      ChatRequestNotebookData,
      ChatReferenceBinaryData,
      ChatRequestEditedFileEventKind,
      LanguageModelChatMessageRole,
      LanguageModelChatMessage,
      LanguageModelChatMessage2,
      LanguageModelToolResultPart,
      LanguageModelToolResultPart2: LanguageModelToolResultPart,
      LanguageModelTextPart,
      LanguageModelTextPart2: LanguageModelTextPart,
      LanguageModelPartAudience,
      ToolResultAudience: LanguageModelPartAudience,
      // back compat
      LanguageModelToolCallPart,
      LanguageModelThinkingPart,
      LanguageModelError,
      LanguageModelToolResult,
      LanguageModelToolResult2,
      LanguageModelDataPart,
      LanguageModelDataPart2: LanguageModelDataPart,
      LanguageModelToolExtensionSource,
      LanguageModelToolMCPSource,
      ExtendedLanguageModelToolResult,
      LanguageModelChatToolMode,
      LanguageModelPromptTsxPart,
      NewSymbolName,
      NewSymbolNameTag: NewSymbolNameTag2,
      NewSymbolNameTriggerKind: NewSymbolNameTriggerKind2,
      ExcludeSettingOptions,
      TextSearchContext2,
      TextSearchMatch2,
      AISearchKeyword,
      TextSearchCompleteMessageTypeNew: TextSearchCompleteMessageType,
      ChatErrorLevel,
      McpHttpServerDefinition,
      McpHttpServerDefinition2: McpHttpServerDefinition,
      McpStdioServerDefinition,
      McpStdioServerDefinition2: McpStdioServerDefinition,
      McpToolAvailability,
      SettingsSearchResultKind
    };
  };
}

// out-build/vs/workbench/api/common/extHostRequireInterceptor.js
var NodeModuleAliasingModuleFactory_1;
var RequireInterceptor = class RequireInterceptor2 {
  constructor(_apiFactory, _extensionRegistry, _instaService, _extHostConfiguration, _extHostExtensionService, _initData, _logService) {
    this._apiFactory = _apiFactory;
    this._extensionRegistry = _extensionRegistry;
    this._instaService = _instaService;
    this._extHostConfiguration = _extHostConfiguration;
    this._extHostExtensionService = _extHostExtensionService;
    this._initData = _initData;
    this._logService = _logService;
    this._factories = /* @__PURE__ */ new Map();
    this._alternatives = [];
  }
  async install() {
    this._installInterceptor();
    mark("code/extHost/willWaitForConfig");
    const configProvider = await this._extHostConfiguration.getConfigProvider();
    mark("code/extHost/didWaitForConfig");
    const extensionPaths = await this._extHostExtensionService.getExtensionPathIndex();
    this.register(new VSCodeNodeModuleFactory(this._apiFactory, extensionPaths, this._extensionRegistry, configProvider, this._logService));
    this.register(this._instaService.createInstance(NodeModuleAliasingModuleFactory));
    if (this._initData.remote.isRemote) {
      this.register(this._instaService.createInstance(OpenNodeModuleFactory, extensionPaths, this._initData.environment.appUriScheme));
    }
  }
  register(interceptor) {
    if ("nodeModuleName" in interceptor) {
      if (Array.isArray(interceptor.nodeModuleName)) {
        for (const moduleName of interceptor.nodeModuleName) {
          this._factories.set(moduleName, interceptor);
        }
      } else {
        this._factories.set(interceptor.nodeModuleName, interceptor);
      }
    }
    if (typeof interceptor.alternativeModuleName === "function") {
      this._alternatives.push((moduleName) => {
        return interceptor.alternativeModuleName(moduleName);
      });
    }
  }
};
RequireInterceptor = __decorate([
  __param(2, IInstantiationService),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostExtensionService),
  __param(5, IExtHostInitDataService),
  __param(6, ILogService)
], RequireInterceptor);
var NodeModuleAliasingModuleFactory = class NodeModuleAliasingModuleFactory2 {
  static {
    NodeModuleAliasingModuleFactory_1 = this;
  }
  static {
    this.aliased = /* @__PURE__ */ new Map([
      ["vscode-ripgrep", "@vscode/ripgrep"],
      ["vscode-windows-registry", "@vscode/windows-registry"]
    ]);
  }
  constructor(initData) {
    if (initData.environment.appRoot && NodeModuleAliasingModuleFactory_1.aliased.size) {
      const root = escapeRegExpCharacters(this.forceForwardSlashes(initData.environment.appRoot.fsPath));
      const npmIdChrs = `[a-z0-9_.-]`;
      const npmModuleName = `@${npmIdChrs}+\\/${npmIdChrs}+|${npmIdChrs}+`;
      const moduleFolders = "node_modules|node_modules\\.asar(?:\\.unpacked)?";
      this.re = new RegExp(`^(${root}/${moduleFolders}\\/)(${npmModuleName})(.*)$`, "i");
    }
  }
  alternativeModuleName(name2) {
    if (!this.re) {
      return;
    }
    const result = this.re.exec(this.forceForwardSlashes(name2));
    if (!result) {
      return;
    }
    const [, prefix, moduleName, suffix] = result;
    const dealiased = NodeModuleAliasingModuleFactory_1.aliased.get(moduleName);
    if (dealiased === void 0) {
      return;
    }
    console.warn(`${moduleName} as been renamed to ${dealiased}, please update your imports`);
    return prefix + dealiased + suffix;
  }
  forceForwardSlashes(str) {
    return str.replace(/\\/g, "/");
  }
};
NodeModuleAliasingModuleFactory = NodeModuleAliasingModuleFactory_1 = __decorate([
  __param(0, IExtHostInitDataService)
], NodeModuleAliasingModuleFactory);
var VSCodeNodeModuleFactory = class {
  constructor(_apiFactory, _extensionPaths, _extensionRegistry, _configProvider, _logService) {
    this._apiFactory = _apiFactory;
    this._extensionPaths = _extensionPaths;
    this._extensionRegistry = _extensionRegistry;
    this._configProvider = _configProvider;
    this._logService = _logService;
    this.nodeModuleName = "vscode";
    this._extApiImpl = new ExtensionIdentifierMap();
  }
  load(_request, parent) {
    const ext = this._extensionPaths.findSubstr(parent);
    if (ext) {
      let apiImpl = this._extApiImpl.get(ext.identifier);
      if (!apiImpl) {
        apiImpl = this._apiFactory(ext, this._extensionRegistry, this._configProvider);
        this._extApiImpl.set(ext.identifier, apiImpl);
      }
      return apiImpl;
    }
    if (!this._defaultApiImpl) {
      let extensionPathsPretty = "";
      this._extensionPaths.forEach((value, index) => extensionPathsPretty += `	${index} -> ${value.identifier.value}
`);
      this._logService.warn(`Could not identify extension for 'vscode' require call from ${parent}. These are the extension path mappings: 
${extensionPathsPretty}`);
      this._defaultApiImpl = this._apiFactory(nullExtensionDescription, this._extensionRegistry, this._configProvider);
    }
    return this._defaultApiImpl;
  }
};
var OpenNodeModuleFactory = class OpenNodeModuleFactory2 {
  constructor(_extensionPaths, _appUriScheme, rpcService) {
    this._extensionPaths = _extensionPaths;
    this._appUriScheme = _appUriScheme;
    this.nodeModuleName = ["open", "opn"];
    this._mainThreadTelemetry = rpcService.getProxy(MainContext.MainThreadTelemetry);
    const mainThreadWindow = rpcService.getProxy(MainContext.MainThreadWindow);
    this._impl = (target, options2) => {
      const uri = URI.parse(target);
      if (options2) {
        return this.callOriginal(target, options2);
      }
      if (uri.scheme === "http" || uri.scheme === "https") {
        return mainThreadWindow.$openUri(uri, target, { allowTunneling: true });
      } else if (uri.scheme === "mailto" || uri.scheme === this._appUriScheme) {
        return mainThreadWindow.$openUri(uri, target, {});
      }
      return this.callOriginal(target, options2);
    };
  }
  load(request, parent, original) {
    const extension = this._extensionPaths.findSubstr(parent);
    if (extension) {
      this._extensionId = extension.identifier.value;
      this.sendShimmingTelemetry();
    }
    this._original = original(request);
    return this._impl;
  }
  callOriginal(target, options2) {
    this.sendNoForwardTelemetry();
    return this._original(target, options2);
  }
  sendShimmingTelemetry() {
    if (!this._extensionId) {
      return;
    }
    this._mainThreadTelemetry.$publicLog2("shimming.open", { extension: this._extensionId });
  }
  sendNoForwardTelemetry() {
    if (!this._extensionId) {
      return;
    }
    this._mainThreadTelemetry.$publicLog2("shimming.open.call.noForward", { extension: this._extensionId });
  }
};
OpenNodeModuleFactory = __decorate([
  __param(2, IExtHostRpcService)
], OpenNodeModuleFactory);

// out-build/vs/workbench/api/common/extHostConsoleForwarder.js
var AbstractExtHostConsoleForwarder = class AbstractExtHostConsoleForwarder2 {
  constructor(extHostRpc, initData) {
    this._mainThreadConsole = extHostRpc.getProxy(MainContext.MainThreadConsole);
    this._includeStack = initData.consoleForward.includeStack;
    this._logNative = initData.consoleForward.logNative;
    this._wrapConsoleMethod("info", "log");
    this._wrapConsoleMethod("log", "log");
    this._wrapConsoleMethod("warn", "warn");
    this._wrapConsoleMethod("debug", "debug");
    this._wrapConsoleMethod("error", "error");
  }
  /**
   * Wraps a console message so that it is transmitted to the renderer. If
   * native logging is turned on, the original console message will be written
   * as well. This is needed since the console methods are "magic" in V8 and
   * are the only methods that allow later introspection of logged variables.
   *
   * The wrapped property is not defined with `writable: false` to avoid
   * throwing errors, but rather a no-op setting. See https://github.com/microsoft/vscode-extension-telemetry/issues/88
   */
  _wrapConsoleMethod(method, severity) {
    const that = this;
    const original = console[method];
    Object.defineProperty(console, method, {
      set: () => {
      },
      get: () => function() {
        that._handleConsoleCall(method, severity, original, arguments);
      }
    });
  }
  _handleConsoleCall(method, severity, original, args) {
    this._mainThreadConsole.$logExtensionHostMessage({
      type: "__$console",
      severity,
      arguments: safeStringifyArgumentsToArray(args, this._includeStack)
    });
    if (this._logNative) {
      this._nativeConsoleLogMessage(method, original, args);
    }
  }
};
AbstractExtHostConsoleForwarder = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService)
], AbstractExtHostConsoleForwarder);
var MAX_LENGTH = 1e5;
function safeStringifyArgumentsToArray(args, includeStack) {
  const argsArray = [];
  if (args.length) {
    for (let i = 0; i < args.length; i++) {
      let arg = args[i];
      if (typeof arg === "undefined") {
        arg = "undefined";
      } else if (arg instanceof Error) {
        const errorObj = arg;
        if (errorObj.stack) {
          arg = errorObj.stack;
        } else {
          arg = errorObj.toString();
        }
      }
      argsArray.push(arg);
    }
  }
  if (includeStack) {
    const stack = new Error().stack;
    if (stack) {
      argsArray.push({ __$stack: stack.split("\n").slice(3).join("\n") });
    }
  }
  try {
    const res = safeStringify2(argsArray);
    if (res.length > MAX_LENGTH) {
      return "Output omitted for a large object that exceeds the limits";
    }
    return res;
  } catch (error) {
    return `Output omitted for an object that cannot be inspected ('${error.toString()}')`;
  }
}

// out-build/vs/workbench/api/worker/extHostConsoleForwarder.js
var ExtHostConsoleForwarder = class ExtHostConsoleForwarder2 extends AbstractExtHostConsoleForwarder {
  constructor(extHostRpc, initData) {
    super(extHostRpc, initData);
  }
  _nativeConsoleLogMessage(_method, original, args) {
    original.apply(console, args);
  }
};
ExtHostConsoleForwarder = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService)
], ExtHostConsoleForwarder);

// out-build/vs/workbench/api/worker/extHostExtensionService.js
var WorkerRequireInterceptor = class extends RequireInterceptor {
  _installInterceptor() {
  }
  getModule(request, parent) {
    for (const alternativeModuleName of this._alternatives) {
      const alternative = alternativeModuleName(request);
      if (alternative) {
        request = alternative;
        break;
      }
    }
    if (this._factories.has(request)) {
      return this._factories.get(request).load(request, parent, () => {
        throw new Error("CANNOT LOAD MODULE from here.");
      });
    }
    return void 0;
  }
};
var ExtHostExtensionService = class extends AbstractExtHostExtensionService {
  constructor() {
    super(...arguments);
    this.extensionRuntime = ExtensionRuntime.Webworker;
  }
  async _beforeAlmostReadyToRunExtensions() {
    this._instaService.createInstance(ExtHostConsoleForwarder);
    const apiFactory = this._instaService.invokeFunction(createApiFactoryAndRegisterActors);
    this._fakeModules = this._instaService.createInstance(WorkerRequireInterceptor, apiFactory, { mine: this._myRegistry, all: this._globalRegistry });
    await this._fakeModules.install();
    performance.mark("code/extHost/didInitAPI");
    await this._waitForDebuggerAttachment();
  }
  _getEntryPoint(extensionDescription) {
    return extensionDescription.browser;
  }
  async _loadCommonJSModule(extension, module2, activationTimesBuilder) {
    module2 = module2.with({ path: ensureSuffix(module2.path, ".js") });
    const extensionId = extension?.identifier.value;
    if (extensionId) {
      performance.mark(`code/extHost/willFetchExtensionCode/${extensionId}`);
    }
    const browserUri = URI.revive(await this._mainThreadExtensionsProxy.$asBrowserUri(module2));
    const response = await fetch(browserUri.toString(true));
    if (extensionId) {
      performance.mark(`code/extHost/didFetchExtensionCode/${extensionId}`);
    }
    if (response.status !== 200) {
      throw new Error(response.statusText);
    }
    const source = await response.text();
    const sourceURL = `${module2.toString(true)}#vscode-extension`;
    const fullSource = `${source}
//# sourceURL=${sourceURL}`;
    let initFn;
    try {
      initFn = new Function("module", "exports", "require", fullSource);
    } catch (err) {
      if (extensionId) {
        console.error(`Loading code for extension ${extensionId} failed: ${err.message}`);
      } else {
        console.error(`Loading code failed: ${err.message}`);
      }
      console.error(`${module2.toString(true)}${typeof err.line === "number" ? ` line ${err.line}` : ""}${typeof err.column === "number" ? ` column ${err.column}` : ""}`);
      console.error(err);
      throw err;
    }
    if (extension) {
      await this._extHostLocalizationService.initializeLocalizedMessages(extension);
    }
    const _exports = {};
    const _module = { exports: _exports };
    const _require = (request) => {
      const result = this._fakeModules.getModule(request, module2);
      if (result === void 0) {
        throw new Error(`Cannot load module '${request}'`);
      }
      return result;
    };
    try {
      activationTimesBuilder.codeLoadingStart();
      if (extensionId) {
        performance.mark(`code/extHost/willLoadExtensionCode/${extensionId}`);
      }
      initFn(_module, _exports, _require);
      return _module.exports !== _exports ? _module.exports : _exports;
    } finally {
      if (extensionId) {
        performance.mark(`code/extHost/didLoadExtensionCode/${extensionId}`);
      }
      activationTimesBuilder.codeLoadingStop();
    }
  }
  _loadESMModule(extension, module2, activationTimesBuilder) {
    throw new Error("ESM modules are not supported in the web worker extension host");
  }
  async $setRemoteEnvironment(_env) {
    return;
  }
  async _waitForDebuggerAttachment(waitTimeout = 5e3) {
    if (!this._initData.environment.isExtensionDevelopmentDebug) {
      return;
    }
    const deadline = Date.now() + waitTimeout;
    while (Date.now() < deadline && !("__jsDebugIsReady" in globalThis)) {
      await timeout(10);
    }
  }
};
function ensureSuffix(path, suffix) {
  const extName = extname(path);
  return extName ? path : path + suffix;
}

// out-build/vs/workbench/api/worker/extHost.worker.services.js
registerSingleton(ILogService, new SyncDescriptor(ExtHostLogService, [true], true));
registerSingleton(
  IExtHostAuthentication,
  ExtHostAuthentication,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtHostExtensionService,
  ExtHostExtensionService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IExtensionStoragePaths,
  ExtensionStoragePaths,
  0
  /* InstantiationType.Eager */
);
registerSingleton(IExtHostTelemetry, new SyncDescriptor(ExtHostTelemetry, [true], true));

// out-build/vs/workbench/api/worker/extensionHostWorker.js
var nativeClose = self.close.bind(self);
self.close = () => console.trace(`'close' has been blocked`);
var nativePostMessage = postMessage.bind(self);
self.postMessage = () => console.trace(`'postMessage' has been blocked`);
function shouldTransformUri(uri) {
  return /^(file|vscode-remote):/i.test(uri);
}
var nativeFetch = fetch.bind(self);
function patchFetching(asBrowserUri) {
  self.fetch = async function(input, init) {
    if (input instanceof Request) {
      return nativeFetch(input, init);
    }
    if (shouldTransformUri(String(input))) {
      input = (await asBrowserUri(URI.parse(String(input)))).toString(true);
    }
    return nativeFetch(input, init);
  };
  self.XMLHttpRequest = class extends XMLHttpRequest {
    open(method, url, async, username, password) {
      (async () => {
        if (shouldTransformUri(url.toString())) {
          url = (await asBrowserUri(URI.parse(url.toString()))).toString(true);
        }
        super.open(method, url, async ?? true, username, password);
      })();
    }
  };
}
self.importScripts = () => {
  throw new Error(`'importScripts' has been blocked`);
};
self.addEventListener = () => console.trace(`'addEventListener' has been blocked`);
self["AMDLoader"] = void 0;
self["NLSLoaderPlugin"] = void 0;
self["define"] = void 0;
self["require"] = void 0;
self["webkitRequestFileSystem"] = void 0;
self["webkitRequestFileSystemSync"] = void 0;
self["webkitResolveLocalFileSystemSyncURL"] = void 0;
self["webkitResolveLocalFileSystemURL"] = void 0;
if (self.Worker) {
  const _Worker = self.Worker;
  Worker = function(stringUrl, options2) {
    if (/^file:/i.test(stringUrl.toString())) {
      stringUrl = FileAccess.uriToBrowserUri(URI.parse(stringUrl.toString())).toString(true);
    } else if (/^vscode-remote:/i.test(stringUrl.toString())) {
      throw new Error(`Creating workers from remote extensions is currently not supported.`);
    }
    const bootstrapFnSource = function bootstrapFn(workerUrl) {
      function asWorkerBrowserUrl(url) {
        if (typeof url === "string" || url instanceof URL) {
          return String(url).replace(/^file:\/\//i, "vscode-file://vscode-app");
        }
        return url;
      }
      const nativeFetch2 = fetch.bind(self);
      self.fetch = function(input, init) {
        if (input instanceof Request) {
          return nativeFetch2(input, init);
        }
        return nativeFetch2(asWorkerBrowserUrl(input), init);
      };
      self.XMLHttpRequest = class extends XMLHttpRequest {
        open(method, url, async, username, password) {
          return super.open(method, asWorkerBrowserUrl(url), async ?? true, username, password);
        }
      };
      const nativeImportScripts = importScripts.bind(self);
      self.importScripts = (...urls) => {
        nativeImportScripts(...urls.map(asWorkerBrowserUrl));
      };
      nativeImportScripts(workerUrl);
    }.toString();
    const js = `(${bootstrapFnSource}('${stringUrl}'))`;
    options2 = options2 || {};
    options2.name = `${name} -> ${options2.name || basename(stringUrl.toString())}`;
    const blob = new Blob([js], { type: "application/javascript" });
    const blobUrl = URL.createObjectURL(blob);
    return new _Worker(blobUrl, options2);
  };
} else {
  self.Worker = class extends NestedWorker {
    constructor(stringOrUrl, options2) {
      super(nativePostMessage, stringOrUrl, { name: basename(stringOrUrl.toString()), ...options2 });
    }
  };
}
var hostUtil = new class {
  constructor() {
    this.pid = void 0;
  }
  exit(_code) {
    nativeClose();
  }
}();
var ExtensionWorker = class {
  constructor() {
    const channel = new MessageChannel();
    const emitter = new Emitter();
    let terminating = false;
    nativePostMessage(channel.port2, [channel.port2]);
    channel.port1.onmessage = (event) => {
      const { data: data2 } = event;
      if (!(data2 instanceof ArrayBuffer)) {
        console.warn("UNKNOWN data received", data2);
        return;
      }
      const msg = VSBuffer.wrap(new Uint8Array(data2, 0, data2.byteLength));
      if (isMessageOfType(
        msg,
        2
        /* MessageType.Terminate */
      )) {
        terminating = true;
        onTerminate("received terminate message from renderer");
        return;
      }
      emitter.fire(msg);
    };
    this.protocol = {
      onMessage: emitter.event,
      send: (vsbuf) => {
        if (!terminating) {
          const data2 = vsbuf.buffer.buffer.slice(vsbuf.buffer.byteOffset, vsbuf.buffer.byteOffset + vsbuf.buffer.byteLength);
          channel.port1.postMessage(data2, [data2]);
        }
      }
    };
  }
};
function connectToRenderer(protocol) {
  return new Promise((resolve2) => {
    const once = protocol.onMessage((raw) => {
      once.dispose();
      const initData = JSON.parse(raw.toString());
      protocol.send(createMessageOfType(
        0
        /* MessageType.Initialized */
      ));
      resolve2({ protocol, initData });
    });
    protocol.send(createMessageOfType(
      1
      /* MessageType.Ready */
    ));
  });
}
var onTerminate = (reason) => nativeClose();
function isInitMessage(a) {
  return !!a && typeof a === "object" && a.type === "vscode.init" && a.data instanceof Map;
}
function create() {
  mark(`code/extHost/willConnectToRenderer`);
  const res = new ExtensionWorker();
  return {
    onmessage(message) {
      if (!isInitMessage(message)) {
        return;
      }
      connectToRenderer(res.protocol).then((data2) => {
        mark(`code/extHost/didWaitForInitData`);
        const extHostMain = new ExtensionHostMain(data2.protocol, data2.initData, hostUtil, null, message.data);
        patchFetching((uri) => extHostMain.asBrowserUri(uri));
        onTerminate = (reason) => extHostMain.terminate(reason);
      });
    }
  };
}

// out-build/vs/workbench/api/worker/extensionHostWorkerMain.js
var data = create();
self.onmessage = (e) => data.onmessage(e.data);

//# sourceMappingURL=extensionHostWorkerMain.js.map
